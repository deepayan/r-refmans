<!DOCTYPE html><html><head><title>Help for package VCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#VCA-package'><p>(V)ariance (C)omponent (A)nalysis.</p></a></li>
<li><a href='#anovaMM'><p>ANOVA-Type Estimation of Mixed Models</p></a></li>
<li><a href='#anovaVCA'><p>ANOVA-Type Estimation of Variance Components for Random Models</p></a></li>
<li><a href='#as.matrix.VCA'><p>Standard 'as.matrix' Method for 'VCA' S3-Objects</p></a></li>
<li><a href='#as.matrix.VCAinference'><p>Standard 'as.matrix' Method for 'VCAinference' S3-Objects</p></a></li>
<li><a href='#buildList'><p>Build a Nested List.</p></a></li>
<li><a href='#CA19_9'><p>Reproducibility Example Dataset from CLSI EP05-A3</p></a></li>
<li><a href='#check4MKL'><p>Check for Availability of Intel's Math Kernel Library</p></a></li>
<li><a href='#checkData'><p>Check Random Model for Given Dataset.</p></a></li>
<li><a href='#checkVars'><p>Check Tow Formula Terms for Potential Problems.</p></a></li>
<li><a href='#chol2invData'><p>Dataset Generating Error in Function 'chol2inv'</p></a></li>
<li><a href='#coef.VCA'><p>Extract Fixed Effects from 'VCA' Object</p></a></li>
<li><a href='#dataEP05A2_1'><p>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</p></a></li>
<li><a href='#dataEP05A2_2'><p>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</p></a></li>
<li><a href='#dataEP05A2_3'><p>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</p></a></li>
<li><a href='#dataEP05A3_MS_1'><p>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</p></a></li>
<li><a href='#dataEP05A3_MS_2'><p>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</p></a></li>
<li><a href='#dataEP05A3_MS_3'><p>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</p></a></li>
<li><a href='#dataRS0003_1'><p>Simulated Repeated Measurements Data.</p></a></li>
<li><a href='#dataRS0003_2'><p>Simulated Repeated Measurements Data.</p></a></li>
<li><a href='#dataRS0003_3'><p>Simulated Repeated Measurements Data.</p></a></li>
<li><a href='#dataRS0005_1'><p>Simulated Data of 5/3 Experiment.</p></a></li>
<li><a href='#dataRS0005_2'><p>Simulated Data of 5/3 Experiment.</p></a></li>
<li><a href='#dataRS0005_3'><p>Simulated Data of 5/3 Experiment.</p></a></li>
<li><a href='#DfSattHelper'><p>Variance-Covariance Matrix of Fixed Effects as Function of Covariance Parameter Estimates</p></a></li>
<li><a href='#errorMessage'><p>Convert Objects to Detailed Error Message.</p></a></li>
<li><a href='#fitLMM'><p>Fit Linear Mixed Model by ANOVA or REML</p></a></li>
<li><a href='#fitVCA'><p>Fit Variance Component Model by ANOVA or REML</p></a></li>
<li><a href='#fixef'><p>Generic Method for Extracting Fixed Effects from a Fitted Model</p></a></li>
<li><a href='#fixef.VCA'><p>Extract Fixed Effects from 'VCA' Object</p></a></li>
<li><a href='#Fsweep'><p>Calling F90-implementation of the SWEEP-Operator</p></a></li>
<li><a href='#getCI'><p>Extract Confidence Intervals from VCA-Objects.</p></a></li>
<li><a href='#getDDFM'><p>Degrees of Freedom for Testing Linear Contrasts of Fixed Effects and Least Square Means</p></a></li>
<li><a href='#getDF'><p>Extract Degrees of Freedom from Linear Hypotheses of Fixed Effects or LS Means</p></a></li>
<li><a href='#getGB'><p>Giesbrecht &amp; Burns Approximation of the Variance-Covariance Matrix of Variance Components</p></a></li>
<li><a href='#getIP.remlVCA'><p>Intermediate Precision for remlVCA-fitted objects of class 'VCA'</p></a></li>
<li><a href='#getL'><p>Construct Linear Contrast Matrix for Hypothesis Tests</p></a></li>
<li><a href='#getMat'><p>Extract a Specific Matrix from a 'VCA' Object</p></a></li>
<li><a href='#getMM'><p>Overparameterized Design Matrices</p></a></li>
<li><a href='#getSSQsweep'><p>ANOVA Sum of Squares via Sweeping</p></a></li>
<li><a href='#getV'><p>Determine V-Matrix for a 'VCA' Object</p></a></li>
<li><a href='#Glucose'><p>Inermediate Precision Data from CLSI EP05-A3</p></a></li>
<li><a href='#HugeData'><p>Huge Dataset with Three Variables</p></a></li>
<li><a href='#isBalanced'><p>Check Whether Design Is Balanced Or Not</p></a></li>
<li><a href='#legend.m'><p>Add Legend to Margin.</p></a></li>
<li><a href='#lmerG'><p>Construct Variance-Covariance Matrix of Random Effects for Models Fitted by Function 'lmer'</p></a></li>
<li><a href='#lmerMatrices'><p>Derive and Compute Matrices for Objects Fitted by Function 'lmer'</p></a></li>
<li><a href='#lmerSummary'><p>Derive VCA-Summary Table from an Object Fitted via Function <code>lmer</code></p></a></li>
<li><a href='#load_if_installed'><p>Load 'RevoUtilsMath'-package if available</p></a></li>
<li><a href='#lsmeans'><p>Least Squares Means of Fixed Effects</p></a></li>
<li><a href='#LSMeans_Data'><p>Dataset for Unit-Testing of LS Means</p></a></li>
<li><a href='#lsmMat'><p>Contrast Matrix for LS Means</p></a></li>
<li><a href='#MLrepro'><p>Multi-Lot Reproducibility Data.</p></a></li>
<li><a href='#model.frame.VCA'><p>Extract the Model Frame from a 'VCA' Object</p></a></li>
<li><a href='#model.matrix.VCA'><p>Model Matrix of a Fitted VCA-Object</p></a></li>
<li><a href='#MPinv'><p>Moore-Penrose Generalized Inverse of a Matrix</p></a></li>
<li><a href='#orderData'><p>Re-Order Data.Frame</p></a></li>
<li><a href='#Orthodont'><p>Orthodont dataset from R-package 'nlme'</p></a></li>
<li><a href='#plot.VCA'><p>Standard 'plot' Method for 'VCA' S3-Objects.</p></a></li>
<li><a href='#plotRandVar'><p>Plot Random Variates of a Mixed Model ('VCA' Object).</p></a></li>
<li><a href='#predict.VCA'><p>Predictions from a Model Fitted by <code>fitLMM</code></p></a></li>
<li><a href='#print.VCA'><p>Standard Printing Method for Objects of Class 'VCA'</p></a></li>
<li><a href='#print.VCAinference'><p>Standard Print Method for Objects of Class 'VCAinference'</p></a></li>
<li><a href='#protectedCall'><p>Wrap Function-Calls to Execute Additional Checks.</p></a></li>
<li><a href='#ranef'><p>Generic Method for Extracting Random Effects from a Fitted Model</p></a></li>
<li><a href='#ranef.VCA'><p>Extract Random Effects from 'VCA' Object</p></a></li>
<li><a href='#realData'><p>Real-World Data</p></a></li>
<li><a href='#remlMM'><p>Fit Linear Mixed Models via REML</p></a></li>
<li><a href='#remlVCA'><p>Perform (V)ariance (C)omponent (A)nalysis via REML-Estimation</p></a></li>
<li><a href='#ReproData1'><p>Multi-Site Data for Estimating Reproducibility Precision</p></a></li>
<li><a href='#reScale'><p>Re-Scale results of 'VCA' or 'VCAinference'</p></a></li>
<li><a href='#residuals.VCA'><p>Extract Residuals of a 'VCA' Object</p></a></li>
<li><a href='#SattDF'><p>Satterthwaite Approximation for Total Degrees of Freedom and for Single Variance Components</p></a></li>
<li><a href='#Scale'><p>Automatically Scale Data Calling these Functions: 'anovaVCA', 'anovaMM', 'remlVCA' or 'remlMM'</p></a></li>
<li><a href='#scaleData'><p>Scale Response Variable to Ensure Robust Numerical Calculations</p></a></li>
<li><a href='#sleepstudy'><p>sleepstudy dataset from R-package 'lme4'</p></a></li>
<li><a href='#Solve'><p>Solve System of Linear Equations using Inverse of Cholesky-Root</p></a></li>
<li><a href='#solveMME'><p>Solve Mixed Model Equations</p></a></li>
<li><a href='#stepwiseVCA'><p>Bottom-Up Step-Wise VCA-Analysis of the Complete Dataset</p></a></li>
<li><a href='#summarize.VCA'><p>Summarize Outcome of a Variance Component Analysis.</p></a></li>
<li><a href='#test.fixef'><p>Perform t-Tests for Linear Contrasts on Fixed Effects</p></a></li>
<li><a href='#test.lsmeans'><p>Perform t-Tests for Linear Contrasts on LS Means</p></a></li>
<li><a href='#Trace'><p>Compute the Trace of a Matrix</p></a></li>
<li><a href='#varPlot'><p>Variability Chart for Hierarchical Models.</p></a></li>
<li><a href='#VCAdata1'><p>Simulated Data for Variance Component Analysis.</p></a></li>
<li><a href='#VCAinference'><p>Inferential Statistics for VCA-Results</p></a></li>
<li><a href='#vcov.VCA'><p>Calculate Variance-Covariance Matrix of Fixed Effects for an 'VCA' Object</p></a></li>
<li><a href='#vcovFixed'><p>Calculate Variance-Covariance Matrix and Standard Errors of Fixed Effects for an 'VCA' Object</p></a></li>
<li><a href='#vcovVC'><p>Calculate Variance-Covariance Matrix of Variance Components of 'VCA' objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Variance Component Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Andre Schuetzenmeister [aut, cre], Florian Dufey [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andre Schuetzenmeister &lt;andre.schuetzenmeister@roche.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, lme4, Matrix, methods, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>VFP, STB, knitr, rmarkdown, prettydoc, RUnit</td>
</tr>
<tr>
<td>Description:</td>
<td>
 ANOVA and REML estimation of linear mixed models is implemented, once following
 Searle et al. (1991, ANOVA for unbalanced data), once making use of the 'lme4' package.
 The primary objective of this package is to perform a variance component analysis (VCA)
 according to CLSI EP05-A3 guideline "Evaluation of Precision of Quantitative Measurement
 Procedures" (2014). There are plotting methods for visualization of an experimental design,
 plotting random effects and residuals. For ANOVA type estimation two methods for computing
 ANOVA mean squares are implemented (SWEEP and quadratic forms). The covariance matrix of 
 variance components can be derived, which is used in estimating confidence intervals. Linear
 hypotheses of fixed effects and LS means can be computed. LS means can be computed at specific
 values of covariables and with custom weighting schemes for factor variables. See ?VCA for a
 more comprehensive description of the features. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 16:13:19 UTC; schueta6</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='VCA-package'>(V)ariance (C)omponent (A)nalysis.</h2><span id='topic+VCA'></span><span id='topic+VCA-package'></span>

<h3>Description</h3>

<p>This package implements ANOVA-type estimation of variance components (VC) for linear mixed models (LMM), and provides 
Restricted Maximum Likelihood (REML) estimation incorporating functionality of the <code>lme4</code> package. For models fitted by REML
the typical VCA-table is derived, also containing the variances of VC, which are approximated by the method outlined in Giesbrecht &amp; Burns (1985). 
REML-estimation is available via functions <code><a href="#topic+remlVCA">remlVCA</a></code> for variance component analysis (VCA) and <code><a href="#topic+remlMM">remlMM</a></code> for fitting
general LMM.
</p>
<p>ANOVA-methodology is a special method of moments approach for estimating (predicting) variance components implemented in functions
<code><a href="#topic+anovaMM">anovaMM</a></code> and <code><a href="#topic+anovaVCA">anovaVCA</a></code>. The former represents a general, unrestricted approach to fitting
linear mixed models, whereas the latter is tailored for performing a VCA on random models.
Experiments of this type frequently occur in performance evaluation analyses of diagnostic tests or analyzers (devices)
quantifying various types of precision (see e.g. guideline EP05-A2/A3 of the Clinical and Laboratory Standards Institute - CLSI). 
</p>
<p>The general Satterthwaite approximation of denominator degrees of freedom for tests of fixed effects (<code><a href="#topic+test.fixef">test.fixef</a></code>) and
LS Means (<code><a href="#topic+test.lsmeans">test.lsmeans</a></code>) is implemented as used in SAS PROC MIXED.	Results differ for unbalanced designs because of the
different approaches to estimating the covariance matrix of variance components. Here, two algorithms are implemented for models fitted
via ANOVA, <code class="reqn">1^{st}</code> the &quot;exact&quot; method described in Searle et. al (1992), <code class="reqn">2^{nd}</code> an approximation described in Giesbrecht &amp; Burns (1985).
The latter is also used for models fitted by REML. See <code><a href="#topic+test.fixef">test.fixef</a></code> and <code><a href="#topic+getGB">getGB</a></code> for details on this topic.
</p>
<p>Furthermore, the Satterthwaite approximation of degrees of freedom for individual VCs and total variance is implemented. These are employed
in Chi-Squared tests of estimated variances against a claimed value (total, error), as well as in Chi-Squared based confidence intervals (CI) (see <code><a href="#topic+VCAinference">VCAinference</a></code>). 
Whenever ANOVA-type estimated VCs become negative, the default is to set them equal to 0. ANOVA mean squares used within the Satterthwaite approximation
will be adapted to this situation by re-computing ANOVA mean squares (<code class="reqn">s_{MS}</code>) as <code class="reqn">s_{MS} = C * \sigma^{2 }</code>,
where <code class="reqn">C</code> is a coefficient matrix and a function of the design matrix and <code class="reqn">\sigma^{2}</code> is the column-vector of adapted variance components.
Total variance corresponds to a conservative estimate of the total variability in these cases, i.e. it will be larger than e.g. the total variance of the
same model fitted by REML, because the negative VC will not contribute to total variance. See the documentation <code><a href="#topic+anovaVCA">anovaVCA</a></code> and <code><a href="#topic+anovaMM">anovaMM</a></code>
for details, specifically argument <code>NegVC</code>.
</p>
<p>Additionally to fitting linear mixed models and performing VCA-analyses, various plotting methods are implemented, e.g. a variability chart 
visualizing the variability in sub-classes emerging from an experimental design (<code><a href="#topic+varPlot">varPlot</a></code>). Random effects and residuals can be transformed 
and plotted using function <code><a href="#topic+plotRandVar">plotRandVar</a></code>. Standardization and studentization are generally available, Pearson-type transformation is only
available for residuals. Plotting (studentized) random variates of a LMM should always be done to reveal potential problems of the fitted model, e.g. 
violation of model assumptions and/or whether there are outlying observations.<br />
</p>
<p>There are not any more two approaches to estimating ANOVA sums (SSQ) of squares as in previous package-versions. Now, only a fast FORTRAN-routine is used generating
the column vector of SSQ, coefficient matrix C (previously computed using the Abbreviated Doolittle and Square Root Method), and the covariance matrix of VC.
Overall, this leads to a dramatic reduction of computation time for models fitted using ANOVA.
</p>
<p>Further reduction of the computation time can be achieved using Intel's <code>Math Kernel Library (MKL)</code>. When the package is loaded it will be automatically
checked whether this is the case or not.
</p>
<p>In LS Means computation of fitted LMM it is possible to compute LS Means using specific values of covariables, which is equivalent to using option 'AT' in 
the 'lsmeans'-statement of SAS PROC MIXED. It is also possible to apply other than the default weighting scheme for (fixed) factor-variables. See the details section
in <code><a href="#topic+lsmeans">lsmeans</a></code> and the description of argument <code>at</code>.
</p>
<p>Note: The 'UnitTests' directory within the package-directory contains a pre-defined test-suite which can be run by sourcing
'RunAllTests.R' for user side testing (installation verification). It requires the 'RUnit' package and checks the numerical
equivalence to reference results (SAS PROC MIXED method=type1/reml, SAS PROC VARCOMP) for balanced and unbalanced data and different experimental designs.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> VCA</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.5.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2024-02-07</td>
</tr>
<tr>
 <td style="text-align: left;">
    License:  </td><td style="text-align: left;"> GPL (&gt;=3) </td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>,
Florian Dufey <a href="mailto:florian.dufey@roche.com">florian.dufey@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York
</p>
<p>Goodnight, J.H. (1979), A Tutorial on the SWEEP Operator, The American Statistician, 33:3, 149-158
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>
<p>Satterthwaite, F.E. (1946),  An Approximate Distribution of Estimates of Variance Components., Biometrics Bulletin 2, 110-114
</p>
<p>Gaylor,D.W., Lucas,H.L., Anderson,R.L. (1970), Calculation of Expected Mean Squares by the Abbreviated Doolittle and Square Root Methods., Biometrics 26 (4): 641-655
</p>
<p>SAS Help and Documentation PROC MIXED, SAS Institute Inc., Cary, NC, USA
</p>

<hr>
<h2 id='anovaMM'>ANOVA-Type Estimation of Mixed Models</h2><span id='topic+anovaMM'></span>

<h3>Description</h3>

<p>Estimate/Predict random effects employing ANOVA-type estimation and obtain generalized least squares estimates
of fixed effects for any linear mixed model including random models and linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovaMM(
  form,
  Data,
  by = NULL,
  VarVC.method = c("scm", "gb"),
  NegVC = FALSE,
  quiet = FALSE,
  order.data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anovaMM_+3A_form">form</code></td>
<td>
<p>(formula) specifying the linear mixed model (fixed and random part of the model),
all random terms need to be enclosed by round brackets. Any variable not being bracketed
will be considered as fixed. Interaction terms containing at least one random factor
will automatically be random (Piepho et al. 2003). All terms appearing in the model 
(fixed or random) need to be compliant with the regular expression &quot;^[^[\.]]?[[:alnum:]_\.]*$&quot;,
i.e. they may not start with a dot and may then only consist of alpha-numeric characters, 
dot and underscore. Otherwise, an error will be issued.</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables referenced in 'form', note that variables can only be
of type &quot;numeric&quot;, &quot;factor&quot; or &quot;character&quot;. The latter will be automatically converted to &quot;factor&quot;.</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_by">by</code></td>
<td>
<p>(factor, character) variable specifying groups for which the analysis should be performed individually,
i.e. by-processing</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_varvc.method">VarVC.method</code></td>
<td>
<p>(character) string specifying whether to use the algorithm given in Searle et al. (1992) which corresponds to <code>VarVC.method="scm"</code> or in
Giesbrecht and Burns (1985) which can be specified via &quot;gb&quot;. Method &quot;scm&quot; (Searle, Casella, McCulloch)
is the exact algorithm, &quot;gb&quot; (Giesbrecht, Burns) is termed &quot;rough approximation&quot;
by the authors, but sufficiently exact compared to e.g. SAS PROC MIXED (method=type1) which
uses the inverse of the Fisher-Information matrix as approximation. For balanced designs all
methods give identical results, only in unbalanced designs differences occur.</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_negvc">NegVC</code></td>
<td>
<p>(logical) FALSE = negative variance component estimates (VC) will be set to 0 and they will not 
contribute to the total variance (as done e.g. in SAS PROC NESTED, conservative estimate of total variance). 
The original ANOVA estimates can be found in element 'VCoriginal'. 
The degrees of freedom of the total variance are based on adapted mean squares (MS) (see details).
TRUE = negative variance component estimates will not be set to 0 and they will contribute to the total 
variance (original definition of the total variance).</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="anovaMM_+3A_order.data">order.data</code></td>
<td>
<p>(logical) TRUE = class-variables will be ordered increasingly, FALSE = ordering of class-variables
will remain as is</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Linear Mixed Model, noted in standard matrix notation, can be written as <code class="reqn">y = Xb + Zg + e</code>, where
<code class="reqn">y</code> is the column vector of observations, <code class="reqn">X</code> and <code class="reqn">Z</code> are design matrices assigning fixed (<code class="reqn">b</code>),
respectively, random (<code class="reqn">g</code>) effects to observations, and <code class="reqn">e</code> is the column vector of residual errors.
Whenever there is an intercept in the model, i.e. the substring &quot;-1&quot; is not part of the model formula, the same
restriction as in SAS PROC MIXED is introduced setting the last fixed effect equal to zero. Note, that the results
of an linear contrasts are not affected by using an intercept or not, except that constrained fixed effects cannot
be part of such contrasts (one could use the intercept estimated instead).
</p>
<p>Here, no further restrictions on the type of model are made. One can fit mixed models as well as random models, which
constitute a sub-set of mixed models (intercept being the only fixed effect). Variables must be either of type &quot;numeric&quot;
or &quot;factor&quot;. &quot;character&quot; variables are automatically converted to factors and the response variable has to be numeric, of course.
In case that 'class(Data[,i])' is neither one of these three options, an error is issued.
Even simple linear models can be fitted, i.e. models without a random part (without <code class="reqn">Zg</code>) besides the
residual errors. In this case, an Analysis of Variance (ANOVA) table is computed in the same way as done by function 'anova.lm'.
</p>
<p>One drawback of using ANOVA-type estimation of random effects is, that random effects are independent, i.e they have
zero covariance by definition <code class="reqn">cov(g_i,g_j) = 0</code>. Another one is that estimated variance components may become negative
under certain conditions. The latter situation is addressed by setting negative variance estimates equal to zero and adapting
ANOVA mean squares (MS) as <code class="reqn">MS = C * VC</code>, where <code class="reqn">C</code> is a coefficient matrix and a function of the design matrix <code class="reqn">[X Z]</code>
and <code class="reqn">VC</code> is the column-vector of adapted variance components. The Satterthwaite approximation of total degrees of freedom 
(DF for total variance) will use adapted <code class="reqn">MS</code>-values.
</p>
<p>Note, that setting negative VCs equal to zero results in a conservative estimate of the total variance, i.e. it will be larger than
the estimate including the negative VC(s). Use parameter 'NegVC=TRUE' to explicitly allow negative variance estimates. 
</p>
<p>For further details on ANOVA Type-I estimation methods see <code><a href="#topic+anovaVCA">anovaVCA</a></code>.
</p>


<h3>Value</h3>

<p>(VCA) object
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York	
</p>
<p>Goodnight, J.H. (1979), A Tutorial on the SWEEP Operator, The American Statistician, 33:3, 149-158
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>
<p>H.P.Piepho, A.Buechse and K.Emrich (2003), A Hitchhiker's Guide to Mixed Models for Randomized Experiments,
J.Agronomy &amp; Crop Science 189, p. 310-322
</p>
<p>Gaylor,D.W., Lucas,H.L., Anderson,R.L. (1970), Calculation of Expected Mean Squares by the Abbreviated Doolittle and Square Root Methods., 
Biometrics 26 (4): 641-655 
</p>
<p>SAS Help and Documentation PROC MIXED, SAS Institute Inc., Cary, NC, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anovaVCA">anovaVCA</a></code>
</p>
<p><code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+VCAinference">VCAinference</a></code>, <code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>
<code><a href="#topic+ranef">ranef</a></code>, <code><a href="#topic+fixef">fixef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="#topic+vcovVC">vcovVC</a></code>, 
<code><a href="#topic+test.fixef">test.fixef</a></code>, <code><a href="#topic+test.lsmeans">test.lsmeans</a></code>, <code><a href="#topic+plotRandVar">plotRandVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(dataEP05A2_2)

# assuming 'day' as fixed, 'run' as random
anovaMM(y~day/(run), dataEP05A2_2)

# assuming both as random leads to same results as
# calling anovaVCA
anovaMM(y~(day)/(run), dataEP05A2_2)
anovaVCA(y~day/run, dataEP05A2_2)

# use different approaches to estimating the covariance of 
# variance components (covariance parameters)
dat.ub &lt;- dataEP05A2_2[-c(11,12,23,32,40,41,42),]			# get unbalanced data
m1.ub &lt;- anovaMM(y~day/(run), dat.ub, VarVC.method="scm")
m2.ub &lt;- anovaMM(y~day/(run), dat.ub, VarVC.method="gb")		
V1.ub &lt;- round(vcovVC(m1.ub), 12)
V2.ub &lt;- round(vcovVC(m2.ub), 12)
all(V1.ub == V2.ub)

# fit a larger random model
data(VCAdata1)
fitMM1 &lt;- anovaMM(y~((lot)+(device))/(day)/(run), VCAdata1[VCAdata1$sample==1,])
fitMM1
# now use function tailored for random models
fitRM1 &lt;- anovaVCA(y~(lot+device)/day/run, VCAdata1[VCAdata1$sample==1,])
fitRM1

# there are only 3 lots, take 'lot' as fixed 
fitMM2 &lt;- anovaMM(y~(lot+(device))/(day)/(run), VCAdata1[VCAdata1$sample==2,])

# the following model definition is equivalent to the one above,
# since a single random term in an interaction makes the interaction
# random (see the 3rd reference for details on this topic)
fitMM3 &lt;- anovaMM(y~(lot+(device))/day/run, VCAdata1[VCAdata1$sample==2,])

# fit same model for each sample using by-processing
lst &lt;- anovaMM(y~(lot+(device))/day/run, VCAdata1, by="sample")
lst

# fit mixed model originally from 'nlme' package

library(nlme)
data(Orthodont)
fit.lme &lt;- lme(distance~Sex*I(age-11), random=~I(age-11)|Subject, Orthodont) 

# re-organize data for using 'anovaMM'
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit.anovaMM1 &lt;- anovaMM(distance~Sex*age2+(Subject)*age2, Ortho)

# use simplified formula avoiding unnecessary terms
fit.anovaMM2 &lt;- anovaMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2, Ortho)

# and exclude intercept
fit.anovaMM3 &lt;- anovaMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)

# compare results
fit.lme
fit.anovaMM1
fit.anovaMM2
fit.anovaMM3

# are there a sex-specific differences?
cmat &lt;- getL(fit.anovaMM3, c("SexMale-SexFemale", "SexMale:age2-SexFemale:age2")) 
cmat

test.fixef(fit.anovaMM3, L=cmat)

# former versions of the package used R-function 'lm' and 'anova',
# which is significantly slower for sufficiently large/complex models
data(realData)
datP1 &lt;- realData[realData$PID==1,]
system.time(anova.lm.Tab &lt;- anova(lm(y~lot/calibration/day/run, datP1)))
# Using the sweeping approach for estimating ANOVA Type-1 sums of squares
# this is now the default setting. 
system.time(anovaMM.Tab1  &lt;- anovaMM(y~lot/calibration/day/run, datP1))

# compare results, note that the latter corresponds to a linear model,
# i.e. without random effects. Various matrices have already been computed,
# e.g. "R", "V" (which are identical in this case).
anova.lm.Tab
anovaMM.Tab1

## End(Not run)

</code></pre>

<hr>
<h2 id='anovaVCA'>ANOVA-Type Estimation of Variance Components for Random Models</h2><span id='topic+anovaVCA'></span>

<h3>Description</h3>

<p>This function equates observed ANOVA Type-I sums of squares (<code class="reqn">SS</code>) to their expected values and solves the resulting system of linear equations
for variance components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovaVCA(
  form,
  Data,
  by = NULL,
  NegVC = FALSE,
  VarVC.method = c("scm", "gb"),
  MME = FALSE,
  quiet = FALSE,
  order.data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anovaVCA_+3A_form">form</code></td>
<td>
<p>(formula) specifying the model to be fit, a response variable left of the '~' is mandatory</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables referenced in 'form'</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_by">by</code></td>
<td>
<p>(factor, character) variable specifying groups for which the analysis should be performed individually,
i.e. by-processing</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_negvc">NegVC</code></td>
<td>
<p>(logical) FALSE = negative variance component estimates (VC) will be set to 0 and they will not contribute to the total variance 
(as done in SAS PROC NESTED, conservative estimate of total variance). The original ANOVA estimates can be found in element 'VCoriginal'. 
The degrees of freedom of the total variance are based on adapted mean squares (MS), i.e. adapted MS are computed as <code class="reqn">D * VC</code>, where VC is 
the column vector with negative VCs set to 0. <br />
TRUE = negative variance component estimates will not be set to 0 and they will contribute to the total variance (original definition of the total variance).</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_varvc.method">VarVC.method</code></td>
<td>
<p>(character) string specifying whether to use the algorithm given in Searle et al. (1992) which corresponds to <code>VarVC.method="scm"</code> or in
Giesbrecht and Burns (1985) which can be specified via &quot;gb&quot;. Method &quot;scm&quot; (Searle, Casella, McCulloch)
is the exact algorithm, &quot;gb&quot; (Giesbrecht, Burns) is termed &quot;rough approximation&quot;
by the authors, but sufficiently exact compared to e.g. SAS PROC MIXED (method=type1) which
uses the inverse of the Fisher-Information matrix as approximation. For balanced designs all
methods give identical results, only in unbalanced designs differences occur.</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_mme">MME</code></td>
<td>
<p>(logical) TRUE = (M)ixed (M)odel (E)quations will be solved, i.e. 'VCA' object will have additional elements
&quot;RandomEffects&quot;, &quot;FixedEffects&quot;, &quot;VarFixed&quot; (variance-covariance matrix of fixed effects) and the &quot;Matrices&quot;
element has addional elements corresponding to intermediate results of solving MMEs.
FALSE = do not solve MMEs, which reduces the computation time for very complex models significantly.</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="anovaVCA_+3A_order.data">order.data</code></td>
<td>
<p>(logical) TRUE = class-variables will be ordered increasingly, FALSE = ordering of class-variables
will remain as is</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For diagnostics, a key parameter is &quot;precision&quot;, i.e. the accuracy of a quantification method influenced by varying sources of random error. 
This type of experiments is requested by regulatory authorities to proof the quality of diagnostic tests, e.g. quantifying intermediate
precision according to CLSI guideline EP5-A2/A3. No, fixed effects are allowed besides the intercept. 
Whenever fixed effects are part of the model to be analyzed, use function <code><a href="#topic+anovaMM">anovaMM</a></code> instead.
</p>
<p>Function <code>anovaVCA</code> is tailored for performing Variance Component Analyses (VCA) for random models, assuming all VCs as factor variables, i.e. their levels
correspond to distinct columns in the design matrix (dummy variables). Any predictor variables are automatically converted to factor variables, since continuous
variables may not be used on the right side of the formula 'form'.
</p>
<p>ANOVA <code class="reqn">SS</code> are computed employing the SWEEP-operator (Goodnight 1979, default).
according to Searle et al. (1992) which corresponds to <code>VarVC.method="scm"</code>.
</p>
<p>Function <code>anovaVCA</code> represents a special form of the &quot;method of moments&quot; approach applicable to arbitrary random models either balanced or unbalanced.
The system of linear equations, which is built from the ANOVA Type-I sums of squares, is closely related to the method used 
by SAS PROC VARCOMP, where ANOVA mean squares (<code class="reqn">MS</code>) are used. The former can be written as <code class="reqn">ss = C * s</code>
and the latter as <code class="reqn">ms = D * s</code>, where <code class="reqn">C</code> and <code class="reqn">D</code> denote the respective coefficient matrices, <code class="reqn">s</code> the column-vector
of variance components (VC) to be estimated/predicted, and <code class="reqn">ss</code> and <code class="reqn">ms</code> the column vector of ANOVA sum of squares, respectively, mean squares. 
Mutliplying element <code class="reqn">d_ij</code> of matrix <code class="reqn">D</code> by element <code class="reqn">c_in</code> of matrix <code class="reqn">C</code> (<code class="reqn">i,j = 1,...,n</code>), results in 
matrix <code class="reqn">C</code>. Thus, <code class="reqn">C</code> can easily be converted to <code class="reqn">D</code> by the inverse operation. Matrix <code class="reqn">D</code> is used to estimate
total degrees of freedom (DF) according to Satterthwaite (1946).
</p>
<p>The method for computing ANOVA Type-I <code class="reqn">SS</code> is much faster than fitting the linear model via <code><a href="stats.html#topic+lm">lm</a></code> and calling function <code><a href="stats.html#topic+anova">anova</a></code> on the 'lm' object
for complex models, where complex refers to the number of columns of the design matrix and the degree of unbalancedness. <code class="reqn">DF</code> are directly derived from the SWEEP-operator as the number of linearly independent
columns of the partial design matrix corresponding to a specific <code class="reqn">VC</code>.
</p>


<h3>Value</h3>

<p>(object) of class 'VCA'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York
</p>
<p>Goodnight, J.H. (1979), A Tutorial on the SWEEP Operator, The American Statistician, 33:3, 149-158
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>
<p>Satterthwaite, F.E. (1946),  An Approximate Distribution of Estimates of Variance Components., 
Biometrics Bulletin 2, 110-114
</p>
<p>Gaylor,D.W., Lucas,H.L., Anderson,R.L. (1970), Calculation of Expected Mean Squares by the Abbreviated Doolittle and Square Root Methods., 
Biometrics 26 (4): 641-655
</p>
<p>SAS Help and Documentation PROC MIXED, SAS Institute Inc., Cary, NC, USA
</p>
<p>SAS Help and Documentation PROC VARCOMP, SAS Institute Inc., Cary, NC, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anovaMM">anovaMM</a></code>, <code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>, <code><a href="#topic+print.VCA">print.VCA</a></code>, <code><a href="#topic+VCAinference">VCAinference</a></code>, 
<code><a href="#topic+ranef">ranef</a></code>, <code><a href="#topic+plotRandVar">plotRandVar</a></code>, <code><a href="#topic+stepwiseVCA">stepwiseVCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load data (CLSI EP05-A2 Within-Lab Precision Experiment) 
data(dataEP05A2_2)

# perform ANOVA-estimation of variance components
res &lt;- anovaVCA(y~day/run, dataEP05A2_2)
res

# design with two main effects (ignoring the hierarchical structure of the design)
anovaVCA(y~day+run, dataEP05A2_2)

# compute confidence intervals, perform F- and Chi-Squared tests
INF &lt;- VCAinference(res, total.claim=3.5, error.claim=2)
INF

### load data from package
data(VCAdata1)

data_sample1 &lt;- VCAdata1[VCAdata1$sample==1,]

### plot data for visual inspection
varPlot(y~lot/day/run, data_sample1)

### estimate VCs for 4-level hierarchical design (error counted) for sample_1 data
anovaVCA(y~lot/day/run, data_sample1)

### using different model (ignoring the hierarchical structure of the design)
anovaVCA(y~lot+day+lot:day:run, data_sample1)

### same model with unbalanced data
anovaVCA(y~lot+day+lot:day:run, data_sample1[-c(1,11,15),])

### use the numerical example from the CLSI EP05-A2 guideline (p.25)
data(Glucose,package="VCA")
res.ex &lt;- anovaVCA(result~day/run, Glucose)

### also perform Chi-Squared tests
### Note: in guideline claimed SD-values are used, here, claimed variances are used
VCAinference(res.ex, total.claim=3.4^2, error.claim=2.5^2)

### now use the six sample reproducibility data from CLSI EP5-A3
### and fit per sample reproducibility model
data(CA19_9)
fit.all &lt;- anovaVCA(result~site/day, CA19_9, by="sample")

reproMat &lt;- data.frame(
Sample=c("P1", "P2", "Q3", "Q4", "P5", "Q6"),
Mean= c(fit.all[[1]]$Mean, fit.all[[2]]$Mean, fit.all[[3]]$Mean, 
fit.all[[4]]$Mean, fit.all[[5]]$Mean, fit.all[[6]]$Mean),
Rep_SD=c(fit.all[[1]]$aov.tab["error","SD"], fit.all[[2]]$aov.tab["error","SD"],
fit.all[[3]]$aov.tab["error","SD"], fit.all[[4]]$aov.tab["error","SD"],
fit.all[[5]]$aov.tab["error","SD"], fit.all[[6]]$aov.tab["error","SD"]),
Rep_CV=c(fit.all[[1]]$aov.tab["error","CV[%]"],fit.all[[2]]$aov.tab["error","CV[%]"],
fit.all[[3]]$aov.tab["error","CV[%]"],fit.all[[4]]$aov.tab["error","CV[%]"],
fit.all[[5]]$aov.tab["error","CV[%]"],fit.all[[6]]$aov.tab["error","CV[%]"]),
WLP_SD=c(sqrt(sum(fit.all[[1]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[2]]$aov.tab[3:4, "VC"])),
sqrt(sum(fit.all[[3]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[4]]$aov.tab[3:4, "VC"])),
sqrt(sum(fit.all[[5]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[6]]$aov.tab[3:4, "VC"]))),
WLP_CV=c(sqrt(sum(fit.all[[1]]$aov.tab[3:4,"VC"]))/fit.all[[1]]$Mean*100,
sqrt(sum(fit.all[[2]]$aov.tab[3:4,"VC"]))/fit.all[[2]]$Mean*100,
sqrt(sum(fit.all[[3]]$aov.tab[3:4,"VC"]))/fit.all[[3]]$Mean*100,
sqrt(sum(fit.all[[4]]$aov.tab[3:4,"VC"]))/fit.all[[4]]$Mean*100,
sqrt(sum(fit.all[[5]]$aov.tab[3:4,"VC"]))/fit.all[[5]]$Mean*100,
sqrt(sum(fit.all[[6]]$aov.tab[3:4,"VC"]))/fit.all[[6]]$Mean*100),
Repro_SD=c(fit.all[[1]]$aov.tab["total","SD"],fit.all[[2]]$aov.tab["total","SD"],
fit.all[[3]]$aov.tab["total","SD"],fit.all[[4]]$aov.tab["total","SD"],
fit.all[[5]]$aov.tab["total","SD"],fit.all[[6]]$aov.tab["total","SD"]),
Repro_CV=c(fit.all[[1]]$aov.tab["total","CV[%]"],fit.all[[2]]$aov.tab["total","CV[%]"],
fit.all[[3]]$aov.tab["total","CV[%]"],fit.all[[4]]$aov.tab["total","CV[%]"],
fit.all[[5]]$aov.tab["total","CV[%]"],fit.all[[6]]$aov.tab["total","CV[%]"]))

for(i in 3:8) reproMat[,i] &lt;- round(reproMat[,i],digits=ifelse(i%%2==0,1,3))
reproMat

# now plot the precision profile over all samples
plot(reproMat[,"Mean"], reproMat[,"Rep_CV"], type="l", main="Precision Profile CA19-9",
xlab="Mean CA19-9 Value", ylab="CV[%]")
grid()
points(reproMat[,"Mean"], reproMat[,"Rep_CV"], pch=16)

# load another example dataset and extract the "sample==1" subset
data(VCAdata1)
sample1 &lt;- VCAdata1[which(VCAdata1$sample==1),]

# generate an additional factor variable and random errors according to its levels
sample1$device &lt;- gl(3,28,252)                                      
set.seed(505)
sample1$y &lt;- sample1$y + rep(rep(rnorm(3,,.25), c(28,28,28)),3)     

# fit a crossed-nested design with main factors 'lot' and 'device' 
# and nested factors 'day' and 'run' nested below 
res1 &lt;- anovaVCA(y~(lot+device)/day/run, sample1) 
res1

# fit same model for each sample using by-processing
lst &lt;- anovaVCA(y~(lot+device)/day/run, VCAdata1, by="sample")
lst

# now fitting a nonsense model on the complete dataset "VCAdata1" 
# where the SWEEP-operator is the new default since package version 1.2
# takes ~5s
system.time(res.sw &lt;- anovaVCA(y~(sample+lot+device)/day/run, VCAdata1))
# applying functions 'anova' and 'lm' in the same manner takes ~ 265s
system.time(res.lm &lt;- anova(lm(y~(sample+lot+device)/day/run, VCAdata1)))
res.sw
res.lm

## End(Not run)
</code></pre>

<hr>
<h2 id='as.matrix.VCA'>Standard 'as.matrix' Method for 'VCA' S3-Objects</h2><span id='topic+as.matrix.VCA'></span>

<h3>Description</h3>

<p>Standard 'as.matrix' Method for 'VCA' S3-Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.VCA_+3A_x">x</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="as.matrix.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(matrix) equal to x$aov.tab with additional attributes &quot;Mean&quot; and &quot;Nobs&quot;
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.VCAinference">as.matrix.VCAinference</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
as.matrix(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.matrix.VCAinference'>Standard 'as.matrix' Method for 'VCAinference' S3-Objects</h2><span id='topic+as.matrix.VCAinference'></span>

<h3>Description</h3>

<p>This function makes use of the hidden feature of function <code><a href="#topic+print.VCAinference">print.VCAinference</a></code> which invisibly returns character 
matrices of estimated variance components expressed as &quot;VC&quot; (variance component), &quot;SD&quot; (standard deviation) or &quot;CV&quot; (coefficient
of variation). If argument &quot;what&quot; is not specified, a named list will be returned with all three matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCAinference'
as.matrix(x, what = c("VC", "SD", "CV"), digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.VCAinference_+3A_x">x</code></td>
<td>
<p>(VCAinference) object</p>
</td></tr>
<tr><td><code id="as.matrix.VCAinference_+3A_what">what</code></td>
<td>
<p>(character) one or multiple choices from &quot;VC&quot; (variance component), &quot;SD&quot; (standard deviation) or
&quot;CV&quot; (coefficient of variation)</p>
</td></tr>
<tr><td><code id="as.matrix.VCAinference_+3A_digits">digits</code></td>
<td>
<p>(integer) number of decimal digits to be used</p>
</td></tr>
<tr><td><code id="as.matrix.VCAinference_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(matrix) with point estimates, one- and two-sided confidence intervals and variances
of the estimated variance components
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.VCAinference">print.VCAinference</a></code>, <code><a href="#topic+as.matrix.VCA">as.matrix.VCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
inf &lt;- VCAinference(fit, VarVC=TRUE)
as.matrix(inf, what="VC", digits=6)
as.matrix(inf, what="SD", digits=6)
as.matrix(inf, what="CV", digits=2)

# request list of matrices
as.matrix(inf)

## End(Not run)
</code></pre>

<hr>
<h2 id='buildList'>Build a Nested List.</h2><span id='topic+buildList'></span>

<h3>Description</h3>

<p>Function <code>buildList</code> creates a nested-list reflecting the hierarchical structure of a fully-nested model, respectively, the imputed
hierarchical structure of the data (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildList(
  Data,
  Nesting,
  Current,
  resp,
  keep.order = TRUE,
  useVarNam = TRUE,
  sep = "",
  na.rm = TRUE,
  Points = list(pch = 16, cex = 0.5, col = "black")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildList_+3A_data">Data</code></td>
<td>
<p>(data.frame) with the data</p>
</td></tr>
<tr><td><code id="buildList_+3A_nesting">Nesting</code></td>
<td>
<p>(character) vector specifying the nesting structure with the top-level variable name
as 1st element and the variance component one above the residual error as last element</p>
</td></tr>
<tr><td><code id="buildList_+3A_current">Current</code></td>
<td>
<p>(character) string specifying the current level which has to be processed</p>
</td></tr>
<tr><td><code id="buildList_+3A_resp">resp</code></td>
<td>
<p>(character) string specifying the name of the response variable (column in 'Data')</p>
</td></tr>
<tr><td><code id="buildList_+3A_keep.order">keep.order</code></td>
<td>
<p>(logical) TRUE = the ordering of factor-levels is kept as provided by 'Data', FALSE = factor-levels are sorted on 
and within each level of nesting</p>
</td></tr>
<tr><td><code id="buildList_+3A_usevarnam">useVarNam</code></td>
<td>
<p>(logical) TRUE = each factor-level specifier is pasted to the variable name of the current variable and used as list-element name, 
FALSE = factor-level specifiers are used as names of list-elements; the former is useful when factor levels are indicated
as integers, e.g. days as 1,2,..., the latter is useful when factor levels are already unique, e.g. day1, day2, ...</p>
</td></tr>
<tr><td><code id="buildList_+3A_sep">sep</code></td>
<td>
<p>(character) string specifying the separator-string in case useVarNam=TRUE</p>
</td></tr>
<tr><td><code id="buildList_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) TRUE = NAs will be removed before computing the descriptive statistics AND NAs will be omitted when counting number of elements, 
FALSE = if there are NAs, this will result in NAs for the descriptive statistics</p>
</td></tr>
<tr><td><code id="buildList_+3A_points">Points</code></td>
<td>
<p>(list) specifying all parameters applicable to function 'points', used to specify scatterplots per lower-end factor-level
(e.g. run/part in EP05-A2 experiments). If list-element &quot;col&quot; is itself a list with elements &quot;var&quot; and &quot;col&quot;, where the former
specifies a variable used for assigning colors &quot;col&quot; according to the class-level of &quot;var&quot;, point-colors can be used for indicating
specific sub-classes not addressed by the model/design (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be used directly and serves as helper function for <code><a href="#topic+varPlot">varPlot</a></code>.
Each factor-level, on each level of nesting is accompanied with a set of descriptive statistics, such as mean, median, var, sd, ... which can be evaluated
later on. These information are used in function <code>varPlot</code>, which implements a variability chart.
Note, that this function is also used if data does not correspond to a fully-nested design, i.e. the hierarchical structure is
inferred from the model formula. The order of main factors (not nested within other factors) appearing in the model formula determines
the nesting structure imputed in order to plot the data as variability chart.
</p>


<h3>Value</h3>

<p>(list) which was recursively built, representing the data of the fully-nested as hierarchy
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# load data (CLSI EP05-A2 Within-Lab Precision Experiment)
data(dataEP05A2_3)

# build a list representing the hierarichal structure of a fully-nested model
# there needs to be a distinct hierarchy for being able to plot the data
# as variability chart (this function is not exported)
lst &lt;- VCA:::buildList(Data=dataEP05A2_3, Nesting=c("day", "run"), Current="day", resp="y")

## End(Not run)
</code></pre>

<hr>
<h2 id='CA19_9'>Reproducibility Example Dataset from CLSI EP05-A3</h2><span id='topic+CA19_9'></span>

<h3>Description</h3>

<p>This data set consists of the example data of a complete three-site, multisample reproducibility study as presented 
in the CLSI EP5-A3 guideline. 
It shows quantitative results of an automated immunometric assay measuring parameter CA19-9. 
This dataset is described in Appendix B of this guideline consisting of 6 samples, each measured on one of three
sites, at five days with five replicates per day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CA19_9)</code></pre>


<h3>Format</h3>

<p>data.frame with 450 rows and 4 variables.</p>


<h3>References</h3>

<p>CLSI EP05-A3 - Evaluation of Precision of Quantitative Measurement Procedures; Approved Guideline - Third Edition.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='check4MKL'>Check for Availability of Intel's Math Kernel Library</h2><span id='topic+check4MKL'></span>

<h3>Description</h3>

<p>Majority of the code is borrowed from the Microsoft R Open Rprofile.site file.
In case MKL can be detected this information will be stored in a separate envrionment, which
other function know about. If so, an optimized version of function <code><a href="#topic+getGB">getGB</a></code>
will be used which used ordinary matrix-objects instead of matrices defined by the
<code>Matrix</code>-package. This seems to accelerate computation time for large datasets
by up to factor 30.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check4MKL()
</code></pre>


<h3>Details</h3>

<p>This function is for internal use only and therefore not exported.
</p>


<h3>Value</h3>

<p>variable 'MKL' in envir &quot;msgEnv&quot; will be set to TRUE/FALSE
</p>


<h3>Author(s)</h3>

<p>Authors of the Rprofile.site file in Microsoft R Open,
Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='checkData'>Check Random Model for Given Dataset.</h2><span id='topic+checkData'></span>

<h3>Description</h3>

<p>This function is intended to check a variance component analysis
either before or after performing it. This is particularily important
for less experienced users who my not exactly know where error messages 
come from. External software using functions <code><a href="#topic+anovaVCA">anovaVCA</a></code>
or <code><a href="#topic+remlVCA">remlVCA</a></code> also via function <code><a href="#topic+fitVCA">fitVCA</a></code> may
also benefit from more user-friendly error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkData(form, Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkData_+3A_form">form</code></td>
<td>
<p>(formula) describing the model to be analyzed</p>
</td></tr>
<tr><td><code id="checkData_+3A_data">Data</code></td>
<td>
<p>(data.frame) with all variables used in 'form'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) of length equal to the number of terms in 'form' 
each element being a list of messages with identified, 
potential problems.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
dat0 &lt;- dataEP05A2_1[1:16,]
# everything should be ok
checkData(y~day/run, dat0)
# data identical response for all obs 
dat1 &lt;- dat0
dat1$y &lt;- dat1[1,"y"]
remlVCA(y~day/run, dat1)
checkData(y~day/run, dat1)
# now factor-levels have identical values
dat2 &lt;- dat0
dat2$y &lt;- dat2$y[rep(seq(1,7,2), rep(2,4))] 
checkData(y~day/run, dat2)
remlVCA(y~day/run, dat2, quiet=TRUE)
# indistinguishable terms are also problematic
dat3 &lt;- data.frame(	y=rnorm(8,10),
						day=paste("day",rep(c(1,2),c(4,4))), 
						run=rep(c(2,1), c(4,4)))
checkData(y~day/run, dat3)
anovaVCA(y~day/run, dat3)
# no replicates, thus, no error variability
dat4 &lt;- dat0[seq(1,15,2),]
dat4$day &lt;- factor(dat4$day)
dat4$run &lt;- factor(dat4$run)
checkData(y~day/run, dat4)
remlVCA(y~day/run, dat4)

## End(Not run)
</code></pre>

<hr>
<h2 id='checkVars'>Check Tow Formula Terms for Potential Problems.</h2><span id='topic+checkVars'></span>

<h3>Description</h3>

<p>Is is checked whether 'term2' is different from 'term1'
in adding information to the model. If both are main
factors, i.e. no interactions terms, it is checked whether
levels of 'term2' differ from those of 'term1'. Otherwise,
'term2' is an interaction with a part being different from
'term1'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkVars(Data, term1, term2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkVars_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables of
'term1' and 'term2'</p>
</td></tr>
<tr><td><code id="checkVars_+3A_term1">term1</code></td>
<td>
<p>(character) term of a model formula as
returned by 'attr(terms(form), \&quot;term.labels\&quot;)')</p>
</td></tr>
<tr><td><code id="checkVars_+3A_term2">term2</code></td>
<td>
<p>(character) 2nd term of a model formula as
returned by 'attr(terms(form), \&quot;term.labels\&quot;)')
to check against 'term1'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with components \&quot;Diff\&quot;=part of 'term2' distinguishing
it from 'term1', \&quot;AddInfo\&quot;=message informing about potential
problems with 'term2'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='chol2invData'>Dataset Generating Error in Function 'chol2inv'</h2><span id='topic+chol2invData'></span>

<h3>Description</h3>

<p>This dataset was added because it generates an error in function 'chol2inv' when
trying to invert the variance-covariance matrix 'V' of the mixed model 'value~ID+(Site)'.
This dataset and the associated mixed model are part of the unit-test collection of the
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chol2invData)</code></pre>


<h3>Format</h3>

<p>A data frame with 158 observations on the following 3 variables.
</p>

<ul>
<li><p> value<br /><br />
The response variable.<br /><br />
</p>
</li>
<li><p> ID<br /><br />
Variable with 6 levels corresponding to samples.<br /><br />
</p>
</li>
<li><p> Site<br /><br />
Variable with 3 levels corresponding to sites/devices.<br />
</p>
</li></ul>

<hr>
<h2 id='coef.VCA'>Extract Fixed Effects from 'VCA' Object</h2><span id='topic+coef.VCA'></span>

<h3>Description</h3>

<p>For conveniently using objects of class 'VCA' with other packages expecting this
function, e.g. the 'multcomp' package for general linear hypotheses for parametric
models (currently not fully implemented).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
coef(object, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object where fixed effects shall be extracted</p>
</td></tr>
<tr><td><code id="coef.VCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="coef.VCA_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit1 &lt;- anovaMM(y~day/(run), dataEP05A2_1)
coef(fit1)
fit2 &lt;- anovaVCA(y~day/run, dataEP05A2_1)
coef(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dataEP05A2_1'>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</h2><span id='topic+dataEP05A2_1'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment conducted to 
evaluate the precision performance of measurement methods. On 20 days two separate
runs with two replicates of the same sample are measured. Thus, factor 'day'
is the top-level random factor (variance component), factor 'run' is nested within
'day'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A2_1)</code></pre>


<h3>Format</h3>

<p>data.frame with 80 rows and 3 variables.</p>


<h3>References</h3>

<p>CLSI EP05-A2 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataEP05A2_2'>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</h2><span id='topic+dataEP05A2_2'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment conducted to 
evaluate the precision performance of measurement methods. On 20 days two separate
runs with two replicates of the same sample are measured. Thus, factor 'day'
is the top-level random factor (variance component), factor 'run' is nested within
'day'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A2_2)</code></pre>


<h3>Format</h3>

<p>data.frame with 80 rows and 3 variables.</p>


<h3>References</h3>

<p>CLSI EP05-A2 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataEP05A2_3'>Simulated Data of a CLSI EP05-A2 20/2/2 Experiment</h2><span id='topic+dataEP05A2_3'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment conducted to 
evaluate the precision performance of measurement methods. On 20 days two separate
runs with two replicates of the same sample are measured. Thus, factor 'day'
is the top-level random factor (variance component), factor 'run' is nested within
'day'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A2_3)</code></pre>


<h3>Format</h3>

<p>data.frame with 80 rows and 3 variables.</p>


<h3>References</h3>

<p>CLSI EP05-A2 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataEP05A3_MS_1'>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</h2><span id='topic+dataEP05A3_MS_1'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment to be conducted  
for evaluation of the precision performance of measurement methods. On 3 sites, on 5 days
5 replicates of the same sample are measured. Thus, factor 'site' is the top-level random 
factor (variance component), factor 'day' is nested within 'site'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A3_MS_1)</code></pre>


<h3>Format</h3>

<p>data.frame with 75 rows and 3 variables.</p>


<h3>References</h3>

<p>Draft of CLSI EP05-A3 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataEP05A3_MS_2'>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</h2><span id='topic+dataEP05A3_MS_2'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment to be conducted  
for evaluation of the precision performance of measurement methods. On 3 sites, on 5 days
5 replicates of the same sample are measured. Thus, factor 'site' is the top-level random 
factor (variance component), factor 'day' is nested within 'site'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A3_MS_2)</code></pre>


<h3>Format</h3>

<p>data.frame with 75 rows and 3 variables.</p>


<h3>References</h3>

<p>Draft of CLSI EP05-A3 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataEP05A3_MS_3'>Simulated Data of a CLSI EP05-A3 3/5/5 Multi-Site Experiment</h2><span id='topic+dataEP05A3_MS_3'></span>

<h3>Description</h3>

<p>This data set consists of simulated measurements for an experiment to be conducted  
for evaluation of the precision performance of measurement methods. On 3 sites, on 5 days
5 replicates of the same sample are measured. Thus, factor 'site' is the top-level random 
factor (variance component), factor 'day' is nested within 'site'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataEP05A3_MS_3)</code></pre>


<h3>Format</h3>

<p>data.frame with 75 rows and 3 variables.</p>


<h3>References</h3>

<p>Draft of CLSI EP05-A3 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='dataRS0003_1'>Simulated Repeated Measurements Data.</h2><span id='topic+dataRS0003_1'></span>

<h3>Description</h3>

<p>This data set consists of 21 measurements of the same sample, suitable
to quantify the mesurement error on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0003_1)</code></pre>


<h3>Format</h3>

<p>data.frame with 21 rows and 1 variable.</p>

<hr>
<h2 id='dataRS0003_2'>Simulated Repeated Measurements Data.</h2><span id='topic+dataRS0003_2'></span>

<h3>Description</h3>

<p>This data set consists of 21 measurements of the same sample, suitable
to quantify the mesurement error on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0003_2)</code></pre>


<h3>Format</h3>

<p>data.frame with 21 rows and 1 variable.</p>

<hr>
<h2 id='dataRS0003_3'>Simulated Repeated Measurements Data.</h2><span id='topic+dataRS0003_3'></span>

<h3>Description</h3>

<p>This data set consists of 21 measurements of the same sample, suitable
to quantify the mesurement error on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0003_3)</code></pre>


<h3>Format</h3>

<p>data.frame with 21 rows and 1 variable.</p>

<hr>
<h2 id='dataRS0005_1'>Simulated Data of 5/3 Experiment.</h2><span id='topic+dataRS0005_1'></span>

<h3>Description</h3>

<p>This data set consists of 15 measurements of the same sample, 
measured on 5 days with 3 measurements on each day. This small
experiment is suitable to quantify between-day variability on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0005_1)</code></pre>


<h3>Format</h3>

<p>data.frame with 15 rows and 2 variables.</p>

<hr>
<h2 id='dataRS0005_2'>Simulated Data of 5/3 Experiment.</h2><span id='topic+dataRS0005_2'></span>

<h3>Description</h3>

<p>This data set consists of 15 measurements of the same sample, 
measured on 5 days with 3 measurements on each day. This small
experiment is suitable to quantify between-day variability on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0005_2)</code></pre>


<h3>Format</h3>

<p>data.frame with 15 rows and 2 variables.</p>

<hr>
<h2 id='dataRS0005_3'>Simulated Data of 5/3 Experiment.</h2><span id='topic+dataRS0005_3'></span>

<h3>Description</h3>

<p>This data set consists of 15 measurements of the same sample, 
measured on 5 days with 3 measurements on each day. This small
experiment is suitable to quantify between-day variability on the same device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRS0005_3)</code></pre>


<h3>Format</h3>

<p>data.frame with 15 rows and 2 variables.</p>

<hr>
<h2 id='DfSattHelper'>Variance-Covariance Matrix of Fixed Effects as Function of Covariance Parameter Estimates</h2><span id='topic+DfSattHelper'></span>

<h3>Description</h3>

<p>This is a helper function for function <code><a href="#topic+test.fixef">test.fixef</a></code> approximating degrees of freedom for 
linear contrasts of fixed effect parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DfSattHelper(obj, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DfSattHelper_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="DfSattHelper_+3A_x">x</code></td>
<td>
<p>(numeric) vector of covariance parameter estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(matrix) corresponding to the variance-covariance matrix of fixed effects
</p>

<hr>
<h2 id='errorMessage'>Convert Objects to Detailed Error Message.</h2><span id='topic+errorMessage'></span>

<h3>Description</h3>

<p>Function takes one or multiple objects and converts them to a single
error-message. Objects can be output of functions <code><a href="base.html#topic+try">try</a></code> or
<code><a href="#topic+checkData">checkData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorMessage(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorMessage_+3A_...">...</code></td>
<td>
<p>one or multiple objects separated by comma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(characer) string combining information from input-objects
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
dat2 &lt;- dataEP05A2_1[1:16,]
dat2$y &lt;- dat2$y[rep(seq(1,7,2), rep(2,4))] 
errorMessage(try(1/"a"), checkData(y~day/run, dat2))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitLMM'>Fit Linear Mixed Model by ANOVA or REML</h2><span id='topic+fitLMM'></span>

<h3>Description</h3>

<p>Function serves as interface to functions <code><a href="#topic+anovaMM">anovaMM</a></code> and <code><a href="#topic+remlMM">remlMM</a></code>
for fitting a linear mixed model (LMM) either by ANOVA or REML. All arguments applicable
to either one of these functions can be specified (see <code><a href="#topic+anovaMM">anovaMM</a></code> or <code><a href="#topic+remlMM">remlMM</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitLMM(
  form,
  Data,
  method = c("anova", "reml"),
  scale = TRUE,
  VarVC = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitLMM_+3A_form">form</code></td>
<td>
<p>(formula) specifiying the linear mixed model, random effects need to be identified by enclosing
them in round brackets, i.e. ~a/(b) will model factor 'a' as fixed and 'b' as random</p>
</td></tr>
<tr><td><code id="fitLMM_+3A_data">Data</code></td>
<td>
<p>(data.frame)  containing all variables referenced in 'form', note that variables can only be of type
&quot;numeric&quot;, &quot;factor&quot; or &quot;character&quot;. The latter will be automatically converted to &quot;factor&quot;</p>
</td></tr>
<tr><td><code id="fitLMM_+3A_method">method</code></td>
<td>
<p>(character) either &quot;anova&quot; to use ANOVA Type-I estimation of variance components or &quot;reml&quot; to use 
restricted maximum likelihood (REML) estimation of variance component</p>
</td></tr>
<tr><td><code id="fitLMM_+3A_scale">scale</code></td>
<td>
<p>(logical) TRUE = scale values of the response aiming to avoid numerical problems
when numbers are either very small or very large, FALSE = use original scale</p>
</td></tr>
<tr><td><code id="fitLMM_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = variance-covariance matrix of variance components will be computed, FALSE = it will not
be computed</p>
</td></tr>
<tr><td><code id="fitLMM_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="#topic+anovaMM">anovaMM</a></code> or function <code><a href="#topic+remlMM">remlMM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Besides offering a convenient interface to both functions for fitting a LMM, this function also provides all elements
required for standard task of fitted models, e.g. prediction, testing general linear hypotheses via R-package <code>multcomp</code>,
etc. (see examples).
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitVCA">fitVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_2)

# assuming 'day' as fixed, 'run' as random
# Note: default method is "anova"
fitLMM(y~day/(run), dataEP05A2_2)

# explicitly request "reml"
fitLMM(y~day/(run), dataEP05A2_2, method="reml")

# assuming both as random leads to same results as
# calling anovaVCA (ANOVA is the default)
fitLMM(y~(day)/(run), dataEP05A2_2)
anovaVCA(y~day/run, dataEP05A2_2)

# now using REML-estimation
fitLMM(y~(day)/(run), dataEP05A2_2, "reml")
remlVCA(y~day/run, dataEP05A2_2)

# use different approaches to estimating the covariance of 
# variance components (covariance parameters)
# create unbalanced data
dat.ub &lt;- dataEP05A2_2[-c(11,12,23,32,40,41,42),]
m1.ub &lt;- fitLMM(y~day/(run), dat.ub, VarVC.method="scm")
# VarVC.method="gb" is an approximation not relying on quadratic forms
m2.ub &lt;- fitLMM(y~day/(run), dat.ub, VarVC.method="gb")		
# REML-estimated variance components usually differ from ANOVA-estimates
# and so do the variance-covariance matrices
m3.ub &lt;- fitLMM(y~day/(run), dat.ub, "reml", VarVC=TRUE)		
V1.ub &lt;- round(vcovVC(m1.ub), 12)
V2.ub &lt;- round(vcovVC(m2.ub), 12)
V3.ub &lt;- round(vcovVC(m3.ub), 12)

# fit a larger random model
data(VCAdata1)
fitMM1 &lt;- fitLMM(y~((lot)+(device))/(day)/(run), VCAdata1[VCAdata1$sample==1,])
fitMM1
# now use function tailored for random models
fitRM1 &lt;- anovaVCA(y~(lot+device)/day/run, VCAdata1[VCAdata1$sample==1,])
fitRM1

# there are only 3 lots, take 'lot' as fixed 
fitMM2 &lt;- fitLMM(y~(lot+(device))/(day)/(run), VCAdata1[VCAdata1$sample==2,])
# use REML on this (balanced) data
fitMM2.2 &lt;- fitLMM(y~(lot+(device))/(day)/(run), VCAdata1[VCAdata1$sample==2,], "reml")

# the following model definition is equivalent to the one above,
# since a single random term in an interaction makes the interaction
# random (see the 3rd reference for details on this topic)
fitMM3 &lt;- fitLMM(y~(lot+(device))/day/run, VCAdata1[VCAdata1$sample==2,])

# fit same model for each sample using by-processing
lst &lt;- fitLMM(y~(lot+(device))/day/run, VCAdata1, by="sample")
lst

# fit mixed model originally from 'nlme' package

library(nlme)
data(Orthodont)
fit.lme &lt;- lme(distance~Sex*I(age-11), random=~I(age-11)|Subject, Orthodont) 

# re-organize data
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit.anovaMM1 &lt;- fitLMM(distance~Sex*age2+(Subject)*age2, Ortho)

# use simplified formula avoiding unnecessary terms
fit.anovaMM2 &lt;- fitLMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2, Ortho)

# and exclude intercept
fit.anovaMM3 &lt;- fitLMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)

# compare results
fit.lme
fit.anovaMM1
fit.anovaMM2
fit.anovaMM3

# are there a sex-specific differences?
cmat &lt;- getL(fit.anovaMM3, c("SexMale-SexFemale", "SexMale:age2-SexFemale:age2")) 
cmat

test.fixef(fit.anovaMM3, L=cmat)

# fit LMM with fixed lot and device effects and test for lot-differences
data(VCAdata1)
fitS5 &lt;- fitLMM(y~(lot+device)/(day)/(run), subset(VCAdata1, sample==5), "reml")
fitS5

# apply Tukey-HSD test to screen for lot differences
library(multcomp)
res.tuk &lt;- glht(fitS5, linfct=mcp(lot="Tukey"))
summary(res.tuk)

# compact letter display
res.tuk.cld &lt;- cld(res.tuk, col=paste0("gray", c(90,60,75)))
plot(res.tuk.cld)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitVCA'>Fit Variance Component Model by ANOVA or REML</h2><span id='topic+fitVCA'></span>

<h3>Description</h3>

<p>Function serves as interface to functions <code><a href="#topic+anovaVCA">anovaVCA</a></code> and <code><a href="#topic+remlVCA">remlVCA</a></code>
for fitting a variance component models (random models) either by ANOVA or REML. All arguments applicable
to either one of these functions can be specified (see <code><a href="#topic+anovaVCA">anovaVCA</a></code> or <code><a href="#topic+remlVCA">remlVCA</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVCA(
  form,
  Data,
  method = c("anova", "reml"),
  scale = TRUE,
  VarVC = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitVCA_+3A_form">form</code></td>
<td>
<p>(formula) specifiying the variance component model (see <code><a href="#topic+anovaVCA">anovaVCA</a></code> and/or <code><a href="#topic+remlVCA">remlVCA</a></code>)</p>
</td></tr>
<tr><td><code id="fitVCA_+3A_data">Data</code></td>
<td>
<p>(data.frame)  containing all variables referenced in 'form'</p>
</td></tr>
<tr><td><code id="fitVCA_+3A_method">method</code></td>
<td>
<p>(character) either &quot;anova&quot; to use ANOVA Type-I estimation of variance components or &quot;reml&quot; to use 
restricted maximum likelihood (REML) estimation of variance component</p>
</td></tr>
<tr><td><code id="fitVCA_+3A_scale">scale</code></td>
<td>
<p>(logical) TRUE = scale values of the response aiming to avoid numerical problems
when numbers are either very small or very large, FALSE = use original scale</p>
</td></tr>
<tr><td><code id="fitVCA_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = variance-covariance matrix of variance components will be computed, FALSE = it will not
be computed</p>
</td></tr>
<tr><td><code id="fitVCA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="#topic+anovaVCA">anovaVCA</a></code> or function <code><a href="#topic+remlVCA">remlVCA</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLMM">fitLMM</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+remlVCA">remlVCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#load data (CLSI EP05-A2 Within-Lab Precision Experiment) 
data(dataEP05A2_2)

# perform ANOVA-estimation of variance components
res.anova &lt;- fitVCA(y~day/run, dataEP05A2_2, "anova")
# perform REML-estimation of variance components
res.reml &lt;- fitVCA(y~day/run, dataEP05A2_2, "reml")

# compare scaling vs. not scaling the response
fit0 &lt;- fitVCA(y~day/run, dataEP05A2_2, "anova", scale=TRUE)
fit1 &lt;- fitVCA(y~day/run, dataEP05A2_2, "anova", scale=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='fixef'>Generic Method for Extracting Fixed Effects from a Fitted Model</h2><span id='topic+fixef'></span>

<h3>Description</h3>

<p>Generic Method for Extracting Fixed Effects from a Fitted Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>(object)</p>
</td></tr>
<tr><td><code id="fixef_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.VCA">fixef.VCA</a></code>
</p>

<hr>
<h2 id='fixef.VCA'>Extract Fixed Effects from 'VCA' Object</h2><span id='topic+fixef.VCA'></span>

<h3>Description</h3>

<p>Conveniently extracting the 'FixedEffects' element of an 'VCA' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
fixef(
  object,
  type = c("simple", "complex"),
  ddfm = c("contain", "residual", "satterthwaite"),
  tol = 1e-12,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object where fixed effects shall be extracted</p>
</td></tr>
<tr><td><code id="fixef.VCA_+3A_type">type</code></td>
<td>
<p>(character) string or partial string, specifying whether
to return &quot;simple&quot; (reduced) or a rather &quot;complex&quot; (more detailed) 
information about fixed effects</p>
</td></tr>
<tr><td><code id="fixef.VCA_+3A_ddfm">ddfm</code></td>
<td>
<p>(character) string specifying the method used for computing the 
degrees of freedom of the t-statistic. Only used when type=&quot;complex&quot;.
Available methods are &quot;contain&quot;, &quot;residual&quot;, and &quot;satterthwaite&quot;.</p>
</td></tr>
<tr><td><code id="fixef.VCA_+3A_tol">tol</code></td>
<td>
<p>(numeric) value representing the numeric tolerance use in comparisons, values
smaller than 'tol' will be considered equal to 0</p>
</td></tr>
<tr><td><code id="fixef.VCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = suppress warning messages, e.g. for non-estimable contrasts</p>
</td></tr>
<tr><td><code id="fixef.VCA_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is to return the fixed effects estimates together with their standard errors.
If setting 'type=&quot;complex&quot;' or to an abbreviation (e.g. &quot;c&quot;) additional inferential statistics
on these estimates will be returned, i.e. &quot;t Value&quot;, &quot;DF&quot; and respective p-value &quot;Pr &gt; |t|&quot;. 
One can choose one of three denominator degrees of freedom ('ddfm')-methods. The implementation
of these methods are an attempt to align with the results of SAS PROC MIXED. See the respective
SAS-documentation for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/(run), dataEP05A2_1)
fixef(fit)

# for complex models it might take some time computing complex output
data(VCAdata1)
fit &lt;- anovaMM(y~(lot+device)/(day)/(run), VCAdata1[VCAdata1$sample==2,])
fixef(fit, "c")

## End(Not run)
</code></pre>

<hr>
<h2 id='Fsweep'>Calling F90-implementation of the SWEEP-Operator</h2><span id='topic+Fsweep'></span>

<h3>Description</h3>

<p>Function calls a fast Fortran90-implementation of the SWEEP operator using the
transpose of the original augmented matrix <code class="reqn">X'X</code> (see <code><a href="#topic+getSSQsweep">getSSQsweep</a></code>).
In the sweeping step, also the C matrix, needed to obtain the variance estimates from 
the sum of squares and the Covariance matrix of the estimates are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fsweep(M, asgn, thresh = 1e-10, tol = 1e-10, Ncpu = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fsweep_+3A_m">M</code></td>
<td>
<p>(matrix) matrix, representing the augmented matrix <code class="reqn">X'X</code></p>
</td></tr>
<tr><td><code id="Fsweep_+3A_asgn">asgn</code></td>
<td>
<p>(integer) vector, identifying columns in <code class="reqn">M</code> corresponding to variables, 
respectively, to their coefficients</p>
</td></tr>
<tr><td><code id="Fsweep_+3A_thresh">thresh</code></td>
<td>
<p>(numeric) value used to check whether the influence of the a coefficient
to reducing the error sum of squares is small enough to conclude that the
corresponding column in <code class="reqn">X'X</code> is a linear combination of preceding 
columns</p>
</td></tr>
<tr><td><code id="Fsweep_+3A_tol">tol</code></td>
<td>
<p>(numeric) value used to check numerical equivalence to zero</p>
</td></tr>
<tr><td><code id="Fsweep_+3A_ncpu">Ncpu</code></td>
<td>
<p>(integer) number of cores to be used for parallel processing
(not yet used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an utility-function not intended to be called directly.
</p>


<h3>Value</h3>

<p>(list) with eight elements:<br />
</p>
<table>
<tr><td><code>SSQ</code></td>
<td>
<p>(numeric) vector of ANOVA sum of squares</p>
</td></tr>
<tr><td><code>LC</code></td>
<td>
<p>(integer) vector indicating linear dependence of each column</p>
</td></tr>
<tr><td><code>DF</code></td>
<td>
<p>(integer) degrees of freedom</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>(double precision) Matrix relating the sums of squares to the variances</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>(double precision) inverse of matrix relating the sums of squares to the variances</p>
</td></tr>
<tr><td><code>VC</code></td>
<td>
<p>(double precision)  variance</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>(double precision) standard deviations</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>(double precision) covariance matrix of the estimated variances</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Dufey <a href="mailto:florian.dufey@roche.com">florian.dufey@roche.com</a>
</p>


<h3>References</h3>

<p>Goodnight, J.H. (1979), A Tutorial on the SWEEP Operator, The American Statistician, 33:3, 149-158
</p>

<hr>
<h2 id='getCI'>Extract Confidence Intervals from VCA-Objects.</h2><span id='topic+getCI'></span>

<h3>Description</h3>

<p>This utility function acutally calls function 'VCAinference' first and then extracts
the requested confidence interval (CI) information from the resulting object. You
can specify single variance components (VC) or multiple. Not specifying any specific
VC will return all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCI(
  obj,
  vc = NULL,
  type = c("vc", "sd", "cv"),
  tail = c("one-sided", "two-sided"),
  conf.level = 0.95,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCI_+3A_obj">obj</code></td>
<td>
<p>(object) of class &quot;VCA&quot;</p>
</td></tr>
<tr><td><code id="getCI_+3A_vc">vc</code></td>
<td>
<p>(integer, character) specifying which variance component to extract CI for</p>
</td></tr>
<tr><td><code id="getCI_+3A_type">type</code></td>
<td>
<p>(character) on which scale should results be returned</p>
</td></tr>
<tr><td><code id="getCI_+3A_tail">tail</code></td>
<td>
<p>(character) should one- or two-sided CI be returned</p>
</td></tr>
<tr><td><code id="getCI_+3A_conf.level">conf.level</code></td>
<td>
<p>(numeric) confidence-level to be used</p>
</td></tr>
<tr><td><code id="getCI_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = suppress additional information to be printed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataEP05A2_3)
fit &lt;- remlVCA(y~day/run, dataEP05A2_3)
getCI(fit)				# will return one-sided CI for all VC
getCI(fit, type="cv")	# now on CV-scale
getCI(fit, type="cv", conf.level=.9)
# multiple row at once
getCI(fit, vc=1:3, type="cv")
getCI(fit, vc=c("total", "error"), type="cv")
</code></pre>

<hr>
<h2 id='getDDFM'>Degrees of Freedom for Testing Linear Contrasts of Fixed Effects and Least Square Means</h2><span id='topic+getDDFM'></span>

<h3>Description</h3>

<p>There are three methods implemented, which are all available in SAS PROC MIXED, namely 
&quot;contain&quot;, &quot;residual&quot;, and &quot;satterthwaite&quot; approximations. See the documentation of SAS
PROC MIXED for details on this topic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDDFM(
  obj,
  L,
  ddfm = c("contain", "residual", "satterthwaite"),
  tol = 1e-12,
  method.grad = "simple",
  opt = TRUE,
  items = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDDFM_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_l">L</code></td>
<td>
<p>(numeric) vector specifying the linear combination of the fixed effect or
LS Means</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_ddfm">ddfm</code></td>
<td>
<p>(character) string specifying the method used for computing the denominator
degrees of freedom for tests of fixed effects or LS Means. Available methods are
&quot;contain&quot;, &quot;residual&quot;, and &quot;satterthwaite&quot;.</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_tol">tol</code></td>
<td>
<p>(numeric) value specifying the numeric tolerance for testing equality to zero</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_method.grad">method.grad</code></td>
<td>
<p>(character) string specifying the method to be used for approximating the gradient
of the variance-covariance matrix of fixed effects at the estimated covariance parameter
estimates (see function 'grad' (numDeriv) for details)</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_opt">opt</code></td>
<td>
<p>(logical) TRUE = tries to optimize computation time by avoiding unnecessary computations
for balanced datasets (see <code><a href="#topic+test.fixef">test.fixef</a></code>).</p>
</td></tr>
<tr><td><code id="getDDFM_+3A_items">items</code></td>
<td>
<p>(list) of pre-computed values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of the Satterthwaite approximation was inspired by the code of function 
'calcSatterth' of R-package 'lmerTest'.
</p>


<h3>Value</h3>

<p>(numeric) vector with the specified type of degrees of freedom
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.fixef">test.fixef</a></code>
</p>

<hr>
<h2 id='getDF'>Extract Degrees of Freedom from Linear Hypotheses of Fixed Effects or LS Means</h2><span id='topic+getDF'></span>

<h3>Description</h3>

<p>Determine degrees of freedom for custom linear hypotheses of fixed effects or LS Means
using one of three possible approximation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDF(obj, L, method = c("contain", "residual", "satterthwaite"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDF_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="getDF_+3A_l">L</code></td>
<td>
<p>(matrix) specifying one or multiple linear hypothese, as returned by function
<code><a href="#topic+getL">getL</a></code></p>
</td></tr>
<tr><td><code id="getDF_+3A_method">method</code></td>
<td>
<p>(character) the method to be used to determine the degrees of freedom for a 
linear hypothesis</p>
</td></tr>
<tr><td><code id="getDF_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function to determine the DFs for linear hypotheses in the same way
as function <code><a href="#topic+test.fixef">test.fixef</a></code>. Only the &quot;DF&quot; part is returned here which can be passed
to other functions expecting DFs as input.
</p>


<h3>Value</h3>

<p>(numeric) vector with the DFs for each row of 'L'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(VCAdata1)
tmpDat &lt;- VCAdata1[VCAdata1$sample==1,]
tmpDat &lt;- tmpDat[-c(11,51,73:76),]
fitMM &lt;- anovaMM(y~(lot+device)/(day)/(run), tmpDat)
fitMM
L &lt;- getL(fitMM, c("lot1-lot2", "device1-device2"))
getDF(fitMM, L)						# method="contain" is Default
getDF(fitMM, L, method="res")

getDF(fitMM, L, method="satt")		# takes quite long for this model

## End(Not run)
</code></pre>

<hr>
<h2 id='getGB'>Giesbrecht &amp; Burns Approximation of the Variance-Covariance Matrix of Variance Components</h2><span id='topic+getGB'></span>

<h3>Description</h3>

<p>Compute variance covariance matrix of variance components of a linear mixed model
via the method stated in Giesbrecht and Burns (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGB(obj, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGB_+3A_obj">obj</code></td>
<td>
<p>(object) with list-type structure, e.g. <code>VCA</code> object fitted by ANOVA
or a premature <code>VCA</code> object fitted by REML</p>
</td></tr>
<tr><td><code id="getGB_+3A_tol">tol</code></td>
<td>
<p>(numeric) values &lt; 'tol' will be considered being equal to zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be called by users and therefore not exported.
</p>


<h3>Value</h3>

<p>(matrix) corresponding to the Giesbrecht &amp; Burns approximation
of the variance-covariance matrix of variance components
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>,
Florian Dufey <a href="mailto:florian.dufey@roche.com">florian.dufey@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovVC">vcovVC</a></code>, <code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_3)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_3)
fit &lt;- solveMME(fit)		# some additional matrices required
getGB(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='getIP.remlVCA'>Intermediate Precision for remlVCA-fitted objects of class 'VCA'</h2><span id='topic+getIP.remlVCA'></span>

<h3>Description</h3>

<p>Intermediate precision in this context here means any sum of variances
below the full model originally fitted. A typical use case could be 
reproducibility-experiments with a single lot or multiple lots, where
a pooled version of within-lab precision shall be determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIP.remlVCA(obj, vc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIP.remlVCA_+3A_obj">obj</code></td>
<td>
<p>(object) of class 'VCA' fitted by 'remlVCA'</p>
</td></tr>
<tr><td><code id="getIP.remlVCA_+3A_vc">vc</code></td>
<td>
<p>(character) string specifying the variance component
up to which an intermediate precision shall be derived</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataEP05A2_3)
res &lt;- remlVCA(y~day/run, dataEP05A2_3)
IPday &lt;- getIP.remlVCA(res, "day:run")
VCAinference(IPday)
</code></pre>

<hr>
<h2 id='getL'>Construct Linear Contrast Matrix for Hypothesis Tests</h2><span id='topic+getL'></span>

<h3>Description</h3>

<p>Function constructs coefficient/contrast matrices from a string-representation of linear hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getL(obj, s, what = c("fixef", "lsmeans"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getL_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="getL_+3A_s">s</code></td>
<td>
<p>(character) string or vector of strings, denoting one or multiple
linear contrasts</p>
</td></tr>
<tr><td><code id="getL_+3A_what">what</code></td>
<td>
<p>(character) string specifying whether to construct contrast matrices
of fixed effects (&quot;fixed&quot;) or LS Means (&quot;lsmeans&quot;), abbreviations are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function constructs matrices expressing custom linear hypotheses of fixed effects or
LS Means. The user has to specify a string denoting this contrast which is then 
transformed into a coefficient/contrast matrix. This string may contain names of fixed effects
belonging to same same fixed term, numeric coefficients and mathematical operators &quot;+&quot;
and &quot;-&quot; (see examples).
</p>


<h3>Value</h3>

<p>(matrix) representing one linear hypothesis of fixed effects or LS Means per row
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_2)
fit &lt;- anovaMM(y~day/(run), dataEP05A2_2)
L &lt;- getL(fit, c("day1-day2", "day5-day10"), what="fixef")
L
test.fixef(fit, L=L)

# another custom hypothesis
L2 &lt;- getL(fit, "0.25*day1+0.25*day2+0.5*day3-0.5*day4-0.5*day5")
L2

# more complex model
data(VCAdata1)
dataS2 &lt;- VCAdata1[VCAdata1$sample==2,]
fit.S2 &lt;- anovaMM(y~(lot+device)/day/(run), dataS2)
L3 &lt;- getL(fit.S2, c("lot1-lot2", "lot1:device3:day19-lot1:device3:day20", 
"lot1:device1:day1-lot1:device1:day2"))
L3
test.fixef(fit.S2, L3)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMat'>Extract a Specific Matrix from a 'VCA' Object</h2><span id='topic+getMat'></span>

<h3>Description</h3>

<p>For convenience only, extracting a specific matrix from the 
&quot;Matrices&quot; element of a 'VCA' object if this matrix exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMat(obj, mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMat_+3A_obj">obj</code></td>
<td>
<p>... (VCA) object</p>
</td></tr>
<tr><td><code id="getMat_+3A_mat">mat</code></td>
<td>
<p>... (character) string specifying the matrix to be extracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'mat=&quot;Z&quot;' the design matrix of random effects will be returned.
If one is interested in the design matrix of random effects for a specific
variance component use a name like &quot;Z&quot; + NAME, where NAME has to be equal to
the name of the VC in the 'VCA' object (see examples). The same applies to 
the A-matrices in the quadratic forms, use &quot;A&quot; + NAME for extracting a specific 
A-matrix.
</p>


<h3>Value</h3>

<p>(matrix) as requested by the user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
getMat(fit, "Z")
getMat(fit, "Zday")
getMat(fit, "Zday:run")
getMat(fit, "Zerror")
fit2 &lt;- anovaMM(y~day/(run), dataEP05A2_1)
getMat(fit2, "V")			 	# Var(y)
getMat(fit2, "G")				# Var(re)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMM'>Overparameterized Design Matrices</h2><span id='topic+getMM'></span>

<h3>Description</h3>

<p>Function <code>getMM</code> constructs overparameterized design matrices from a model formula and a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMM(form, Data, keep.order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMM_+3A_form">form</code></td>
<td>
<p>(formula) with or without response specifying the model to be fit</p>
</td></tr>
<tr><td><code id="getMM_+3A_data">Data</code></td>
<td>
<p>(data.frame) with the data</p>
</td></tr>
<tr><td><code id="getMM_+3A_keep.order">keep.order</code></td>
<td>
<p>(logical) TRUE = terms in 'form' should keep their positions, otherwise
main effects come first and all interactions will be put into increasing order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs the overparameterized design matrix for a given dataset 'Data' according to
the model formula 'form'. Each combination of factor-levels and or numeric variables is identified
and accounted for by a separate column. See examples for differences compared to function 'model.matrix' (stats).
This type of design matrix is used e.g. in constructing A-matrices of quadratic forms in <code class="reqn">y</code> expressing
ANOVA sums of squares as such. This is key functionality of functions <code><a href="#topic+anovaVCA">anovaVCA</a></code> and <code><a href="#topic+anovaMM">anovaMM</a></code>
used e.g. in constructing the coefficient matrix <code class="reqn">C</code> whose inverse is used in solving for ANOVA Type-1 based
variance components..
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data (CLSI EP05-A2 Within-Lab Precision Experiment)
data(dataEP05A2_3)
tmpData &lt;- dataEP05A2_3[1:10,] 

# check out the differences
getMM(~day+day:run, tmpData)
model.matrix(~day+day:run, tmpData)

# adapt factor variables in 'tmpData'
tmpData$day &lt;- factor(tmpData$day)

# check out the differences now
getMM(~day+day:run, tmpData)
model.matrix(~day+day:run, tmpData)

# numeric covariate 'cov'
tmpData2 &lt;- dataEP05A2_3[1:10,] 
tmpData2$cov &lt;- 10+rnorm(10,,3)
model.matrix(~day*cov, tmpData2)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSSQsweep'>ANOVA Sum of Squares via Sweeping</h2><span id='topic+getSSQsweep'></span>

<h3>Description</h3>

<p>Compute ANOVA Type-1 sum of squares for linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSSQsweep(Data, tobj, random = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSSQsweep_+3A_data">Data</code></td>
<td>
<p>(data.frame) with the data</p>
</td></tr>
<tr><td><code id="getSSQsweep_+3A_tobj">tobj</code></td>
<td>
<p>(terms) object derived from original formula object</p>
</td></tr>
<tr><td><code id="getSSQsweep_+3A_random">random</code></td>
<td>
<p>(character) vector, optionally containing information about each
model term, whether it is random or fixed (only used in mixed models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs estimation of ANOVA Type-1 sum of squares
using the SWEEP-operator (see reference), operating on the augmented
matrix <code class="reqn">X'X</code>, where <code class="reqn">X</code> represents the design matrix not differentiating
between fixed and random factors. See the numerical example in <code><a href="#topic+Fsweep">Fsweep</a></code>
exemplifying the type of augmentation of <code class="reqn">X'X</code> on which sweeping is carried out.
</p>
<p>This is an utility function not intended to be called directly.
For each term in the formula the design-matrix <code class="reqn">Z</code> is constructed.
Matrix <code class="reqn">X</code> corresponds to binding all these <code class="reqn">Z</code>-matrices together column-wise.
</p>
<p>Degrees of freedom for each term are determined by subtracting the number of
linearly dependent columns from the total number of column in X asigned to a
specific term.
</p>


<h3>Value</h3>

<p>(list) representing the  with variables:<br />
</p>
<table>
<tr><td><code>aov.tab</code></td>
<td>
<p>basic ANOVA-table with degrees of freedom (DF), SS and MS</p>
</td></tr>
<tr><td><code>Lmat</code></td>
<td>
<p>(list) with components 'Z' and 'A'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>,
Florian Dufey <a href="mailto:florian.dufey@roche.com">florian.dufey@roche.com</a>
</p>


<h3>References</h3>

<p>Goodnight, J.H., (1979), A Tutorial on the SWEEP Operator, The American Statistician, 33:3, p.149-158
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fsweep">Fsweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
res &lt;- VCA:::getSSQsweep(dataEP05A2_1, terms(y~day/run))
str(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='getV'>Determine V-Matrix for a 'VCA' Object</h2><span id='topic+getV'></span>

<h3>Description</h3>

<p>Determine the estimated variance-covariance matrix of observations <code class="reqn">y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getV(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getV_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A linear mixed model can be written as <code class="reqn">y = Xb + Zg + e</code>, where <code class="reqn">y</code> is the column
vector of observations, <code class="reqn">X</code> and <code class="reqn">Z</code> are design matrices assigning fixed (<code class="reqn">b</code>),
respectively, random (<code class="reqn">g</code>) effects to observations, and <code class="reqn">e</code> is the column vector of 
residual errors.
The variance-covariance matrix of <code class="reqn">y</code> is equal to <code class="reqn">Var(y) = ZGZ^{-T} + R</code>, where <code class="reqn">R</code>
is the variance-covariance matrix of <code class="reqn">e</code> and <code class="reqn">G</code> is the variance-covariance matrix of <code class="reqn">g</code>.
Here, <code class="reqn">G</code> is assumed to be a diagonal matrix, i.e. all random effects <code class="reqn">g</code> are mutually independent
(uncorrelated).
</p>


<h3>Value</h3>

<p>(VCA) object with additional elements in the 'Matrices' element, including matrix <code class="reqn">V</code>.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='Glucose'>Inermediate Precision Data from CLSI EP05-A3</h2><span id='topic+Glucose'></span>

<h3>Description</h3>

<p>This data set consists of the Glucose intermediate precision data in the CLSI
EP05-A3 guideline, i.e. total variance for a fully-nested design with 3 variance components (day, run, error).<br />
Note, that the results in the original EP05-A3 guideline were obtained using rounded intermediate results, whereas,
package <code>VCA</code> uses full precision. Any differences between results listed in the CLSI EP05-A3 guideline
and those generated by the package are due to error propagation in the working example presented in the CLSI guideline. 
Here, full precision is used for all intermediate results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Glucose)</code></pre>


<h3>Format</h3>

<p>data.frame with 80 rows and 3 variables.</p>


<h3>References</h3>

<p>CLSI EP05-A3 - Evaluation of Precision of Quantitative Measurement Procedures; Approved Guideline - Third Edition.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='HugeData'>Huge Dataset with Three Variables</h2><span id='topic+HugeData'></span>

<h3>Description</h3>

<p>This dataset was added to have a very large dataset available for the 
unit-test suite. It is an unbalanced dataset with three variables and 8070
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HugeData)</code></pre>


<h3>Format</h3>

<p>A data frame with 8070 observations on the following 3 variables.
</p>

<ul>
<li><p> y<br /><br />
The response variable.<br /><br />
</p>
</li>
<li><p> VC1<br /><br />
Variable with 8 levels corresponding to top-level variance component.<br /><br />
</p>
</li>
<li><p> VC2<br /><br />
Variable with 3920 levels corresponding to 2nd-level variance component.<br />
</p>
</li></ul>

<hr>
<h2 id='isBalanced'>Check Whether Design Is Balanced Or Not</h2><span id='topic+isBalanced'></span>

<h3>Description</h3>

<p>Assess whether an experimental design is balanced or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isBalanced(form, Data, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isBalanced_+3A_form">form</code></td>
<td>
<p>(formula) object defining the experimental design.</p>
</td></tr>
<tr><td><code id="isBalanced_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables appearing in 'form'.</p>
</td></tr>
<tr><td><code id="isBalanced_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) TRUE = delete rows where any is NA, FALSE = NAs are not removed, if there are NAs in the
response variable and all information in independent variables is available, then only the design is checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for internal use only. Thus, it is not exported.
</p>
<p>The approach taken here is to check whether each cell defined by one level of a factor are all equal or
not. Here, data is either balanced or unbalanced, there is no concept of &quot;planned unbalancedness&quot; as
discussed e.g. in Searle et al. (1992) p.4. The expanded (simplified) formula is divided into main factors
and nested factors, where the latter are interaction terms. The <code class="reqn">N</code>-dimensional contingency table, <code class="reqn">N</code> being the
number of main factors, is checked for all cells containing the same number. If there are differences, the
dataset is classified as &quot;unbalanced&quot;. All interaction terms are tested individually. Firstly, a single factor 
is generated from combining factor levels of the first <code class="reqn">(n-1)</code> variables in the interaction term. The last variable
occuring in the interaction term is then recoded as factor-object with <code class="reqn">M</code> levels. <code class="reqn">M</code> is the number of factor
levels within each factor level defined by the first <code class="reqn">(n-1)</code> variables in the interaction term. This is done to 
account for the independence within sub-classes emerging from the combination of the first <code class="reqn">(n-1)</code> variables.
</p>


<h3>Value</h3>

<p>(logical) TRUE if data is balanced, FALSE if data is unbalanced (according to the definition of balance used)
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data1 &lt;- data.frame(site=gl(3,8), lot=factor(rep(c(2,3,1,2,3,1), 
rep(4,6))), day=rep(1:12, rep(2,12)), y=rnorm(24,25,1))

# not all combinations of 'site' and 'lot' in 'data1'

VCA:::isBalanced(y~site+lot+site:lot:day, data1)

# balanced design for this model

VCA:::isBalanced(y~lot+lot:day, data1)

# gets unbalanced if observation is NA

data1[1,"y"] &lt;- NA
VCA:::isBalanced(y~lot+lot:day, data1)
VCA:::isBalanced(y~lot+lot:day, data1, FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='legend.m'>Add Legend to Margin.</h2><span id='topic+legend.m'></span>

<h3>Description</h3>

<p>This function accepts all parameters applicable in and forwards them to function <code><a href="graphics.html#topic+legend">legend</a></code>.
There will be only made some modifications to the X-coordinate ensuring that the legend is plotted in
the right margin of the graphic device. Make sure that you have reserved sufficient space in the right
margin, e.g. 'plot.VFP(....., mar=c(4,5,4,10))'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend.m(
  x = c("center", "bottomright", "bottom", "bottomleft", "left", "topleft", "top",
    "topright", "right"),
  y = NULL,
  margin = c("right", "bottomright", "bottom", "bottomleft", "left", "topleft", "top",
    "topright"),
  offset = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend.m_+3A_x">x</code></td>
<td>
<p>(character, numeric) either one of the character strings &quot;center&quot;,&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, 
&quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; or a numeric values specifying the X-coordinate in user
coordinates</p>
</td></tr>
<tr><td><code id="legend.m_+3A_y">y</code></td>
<td>
<p>(numeric) value specifying the Y-coordiante in user coordinates, only used in case 'x' is numeric</p>
</td></tr>
<tr><td><code id="legend.m_+3A_margin">margin</code></td>
<td>
<p>(character) string specifying in which part of the margin the legend shall be added, choices are
&quot;right&quot;, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, 
&quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot; with &quot;right&quot; being the default</p>
</td></tr>
<tr><td><code id="legend.m_+3A_offset">offset</code></td>
<td>
<p>(numeric) value in [0, 0.5] specifying the offset as fraction in regard to width of the right margin</p>
</td></tr>
<tr><td><code id="legend.m_+3A_...">...</code></td>
<td>
<p>all parameters applicable in function <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

par( mar=c(10,10,10,10) )
plot(1, type="n", axes=FALSE, xlab="", ylab="")
box()
# add legend to different regions within the 'margin'
legend.m(margin="topleft", 		fill="black",	legend=c("topleft"))
legend.m(margin="top", 			fill="red", 	legend=c("top"))
legend.m(margin="topright", 		fill="blue",	legend=c("topright"))
legend.m(margin="right", 		fill="green",	legend=c("right"))
legend.m(margin="bottomright", 	fill="yellow",	legend=c("bottomright"))
legend.m(margin="bottom", 		fill="orange",	legend=c("bottom"))
legend.m(margin="bottomleft", 	fill="cyan",	legend=c("bottomleft"))
legend.m(margin="left", 			fill="magenta", legend=c("left"))

data(dataEP05A2_3)
dataEP05A2_3$user &lt;- sample(rep(c(1,2), 40))
 
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,7), VCnam=list(side=4), 
	        Points=list(pch=list(var="user", pch=c(2, 8))) )
# always check order of factor levels before annotating
order(unique(dataEP05A2_3$user))
legend.m(pch=c(8,2), legend=c("User 1", "User 2"))

# using different colors 
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,7), VCnam=list(side=4),
         Points=list(col=list(var="user", col=c("red", "green"))) )
legend.m(fill=c("green", "red"), legend=c("User 1", "User 2"))

# two additional classification variables
dataEP05A2_3$user &lt;- sample(rep(c(1,2), 40))
dataEP05A2_3$cls2 &lt;- sample(rep(c(1,2), 40))

# now combine point-coloring and plotting symbols
# to indicate two additional classification variables
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,10),
         VCnam=list(side=4, cex=1.5),
         Points=list(col=list(var="user", col=c("red", "darkgreen")),
                     pch=list(var="cls2", pch=c(21, 22)),
                     bg =list(var="user", bg =c("orange", "green"))) )

# add legend to (right) margin
legend.m(margin="right", pch=c(21, 22, 22, 22), 
         pt.bg=c("white", "white", "orange", "green"),  
         col=c("black", "black", "white", "white"), 
         pt.cex=c(1.75, 1.75, 2, 2),
         legend=c("Cls2=1", "Cls2=2", "User=2", "User=1"), 
         cex=1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='lmerG'>Construct Variance-Covariance Matrix of Random Effects for Models Fitted by Function 'lmer'</h2><span id='topic+lmerG'></span>

<h3>Description</h3>

<p>This function restricts the variance-covariance matrix of random effects <code class="reqn">G</code> to be either
diagonal ('cov=FALSE') or to take any non-zero covariances into account (default, 'cov=TRUE').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerG(obj, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmerG_+3A_obj">obj</code></td>
<td>
<p>(object) inheriting from class 'lmerMod'</p>
</td></tr>
<tr><td><code id="lmerG_+3A_cov">cov</code></td>
<td>
<p>(logical) TRUE = in case of non-zero covariances a block diagonal matrix will be constructed,
FALSE = a diagonal matrix with all off-diagonal element being equal to zero will be contructed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be called directly by users and therefore not exported!
</p>


<h3>Value</h3>

<p>(Matrix) representing the variance-covariance structure of random effects <code class="reqn">G</code>
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(lme4)
data(Orthodont)
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit &lt;-lmer(distance~Sex+Sex:age2+(age2|Subject), Ortho) 
G1 &lt;- VCA:::lmerG(fit, cov=FALSE)
G2 &lt;- VCA:::lmerG(fit, cov=TRUE)
G1[1:10,1:10]
G2[1:10,1:10]

## End(Not run)
</code></pre>

<hr>
<h2 id='lmerMatrices'>Derive and Compute Matrices for Objects Fitted by Function 'lmer'</h2><span id='topic+lmerMatrices'></span>

<h3>Description</h3>

<p>Function derives and computes all matrices required for down-stream
analyses of VCA-objects fitted with REML via function <code><a href="lme4.html#topic+lmer">lmer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerMatrices(obj, tab = NULL, terms = NULL, cov = FALSE, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmerMatrices_+3A_obj">obj</code></td>
<td>
<p>(object) inheriting from 'lmerMod'</p>
</td></tr>
<tr><td><code id="lmerMatrices_+3A_tab">tab</code></td>
<td>
<p>(data.frame) representing the basic VCA-table</p>
</td></tr>
<tr><td><code id="lmerMatrices_+3A_terms">terms</code></td>
<td>
<p>(character) vector used for ordering variance components</p>
</td></tr>
<tr><td><code id="lmerMatrices_+3A_cov">cov</code></td>
<td>
<p>(logical) take non-zero covariances among random effects into account (TRUE) or
not (FALSE), the latter is the default in this package and also implemented in
<code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>, and <code><a href="#topic+anovaMM">anovaMM</a></code>.</p>
</td></tr>
<tr><td><code id="lmerMatrices_+3A_x">X</code></td>
<td>
<p>(matrix) design matrix of fixed effects as constructed to meet VCA-package requirements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixed Model Equations (MME) are solved for fixed and random effects applying the same
constraints as in <code><a href="#topic+anovaMM">anovaMM</a></code>. 
The most elaborate and therefore time consuming part is to prepare all matrices required for 
approximating the variance-covariance matrix of variance components (see <code><a href="#topic+getGB">getGB</a></code>).
To reduce the computational time, this function tries to optimize object-classes depending
on whether Intel's (M)ath (K)ernel (L)ibrary could be loaded or not. MKL appears to be more
performant with ordinary matrix-objects, whereas all other computations are perfomred using
matrix-representations of the <code>Matrix</code>-package.
</p>
<p>This function is not intended to be called directly by users and therefore not exported.
</p>


<h3>Value</h3>

<p>(list), a premature 'VCA' object
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>
</p>

<hr>
<h2 id='lmerSummary'>Derive VCA-Summary Table from an Object Fitted via Function <code><a href="lme4.html#topic+lmer">lmer</a></code></h2><span id='topic+lmerSummary'></span>

<h3>Description</h3>

<p>This function builds a variance components analysis (VCA) table
from an object representing a model fitted by function <code><a href="lme4.html#topic+lmer">lmer</a></code>
of the <code>lme4</code> R-package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerSummary(
  obj,
  VarVC = TRUE,
  terms = NULL,
  Mean = NULL,
  cov = FALSE,
  X = NULL,
  tab.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmerSummary_+3A_obj">obj</code></td>
<td>
<p>(lmerMod) object as returned by function <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = the variance-covariance matrix of variance components will be approximated
following the Giesbrecht &amp; Burns approach, FALSE = it will not be approximated</p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_terms">terms</code></td>
<td>
<p>(character) vector, optionally defining the order of variance terms to be used</p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_mean">Mean</code></td>
<td>
<p>(numeric) mean value used for CV-calculation</p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_cov">cov</code></td>
<td>
<p>(logical) TRUE = in case of non-zero covariances a block diagonal matrix will be constructed,
FALSE = a diagonal matrix with all off-diagonal elements being equal to zero will be contructed</p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_x">X</code></td>
<td>
<p>(matrix) design matrix of fixed effects as constructed to meet VCA-package requirements</p>
</td></tr>
<tr><td><code id="lmerSummary_+3A_tab.only">tab.only</code></td>
<td>
<p>(logical) TRUE = will return only the VCA-results table as 'data.frame', argument 'VarVC' will 
be automatically set to 'FALSE' (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies the approximation of the variance-covariance
matrix of variance components according to Giesbrecht &amp; Burns (1985) and uses this
information to approximate the degrees of freedom according to Satterthwaite
(see SAS PROC MIXED documentation option 'CL').
</p>
<p>This function can be used to create a VCA-results table from almost any fitted 'lmerMod'-object, i.e. one can
apply it to a model fitted via function <code><a href="lme4.html#topic+lmer">lmer</a></code> of the <code>lme4</code>-package. The only 
additional argument that needs to be used is 'tab.only' (see examples).
</p>


<h3>Value</h3>

<p>(list) still a premature 'VCA'-object but close to a &quot;complete&quot; 'VCA'-object
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit a model with a VCA-function first
data(VCAdata1)
fit0 &lt;- remlVCA(y~(device+lot)/day/run, subset(VCAdata1, sample==5))
fit0

# fit the same model with function 'lmer' of the 'lme4'-package
library(lme4)
fit1 &lt;- lmer(y~(1|device)+(1|lot)+(1|device:lot:day)+(1|device:lot:day:run),
subset(VCAdata1, sample==5))
lmerSummary(fit1, tab.only=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_if_installed'>Load 'RevoUtilsMath'-package if available</h2><span id='topic+load_if_installed'></span>

<h3>Description</h3>

<p>This function is taken from the Rprofile.site file of Microsoft R Open.
It was added to the package namespace to avoid a NOTE during the R CMD check
process stating that this function is not gobally defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_if_installed(package)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_if_installed_+3A_package">package</code></td>
<td>
<p>(character) package name to load, usually this will be package
'RevoUtilsMath' if available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only change to the original version is a different bracketing scheme to match
the one used in the remaining source-code of the package.
</p>


<h3>Author(s)</h3>

<p>Authors of the Rprofile.site file in Microsoft R Open.
</p>

<hr>
<h2 id='lsmeans'>Least Squares Means of Fixed Effects</h2><span id='topic+lsmeans'></span>

<h3>Description</h3>

<p>Computes Least Squares Means (LS Means) of fixed effects for fitted mixed models of class 'VCA'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmeans(
  obj,
  var = NULL,
  type = c("simple", "complex"),
  ddfm = c("contain", "residual", "satterthwaite"),
  at = NULL,
  contr.mat = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmeans_+3A_obj">obj</code></td>
<td>
<p>(VCA) object having at least one fixed effect</p>
</td></tr>
<tr><td><code id="lsmeans_+3A_var">var</code></td>
<td>
<p>(character) string specifying a fixed effects variable for which
LS Means should be computed, defaults to all fixed effects, i.e. for
each level of a fixed effects variable ls means will be computed</p>
</td></tr>
<tr><td><code id="lsmeans_+3A_type">type</code></td>
<td>
<p>(character) &quot;simple&quot; = fast version of computing LS means</p>
</td></tr>
<tr><td><code id="lsmeans_+3A_ddfm">ddfm</code></td>
<td>
<p>(character) string specifying the method used for computing the 
degrees of freedom of the t-statistic. Only used when type=&quot;complex&quot;.
Available methods are &quot;contain&quot;, &quot;residual&quot;, and &quot;satterthwaite&quot;.</p>
</td></tr>
<tr><td><code id="lsmeans_+3A_at">at</code></td>
<td>
<p>(list) where each element corresponds either to a (numeric) covariable or
to a factor-variable for which the weighting scheme should be adjusted.
See details section for a thorough description of how argument 'at' works
and also see the examples.</p>
</td></tr>
<tr><td><code id="lsmeans_+3A_contr.mat">contr.mat</code></td>
<td>
<p>(logical) TRUE = the LS Means generating contrast-matrix will be added to the
result as attribute <code>contrasts</code></p>
</td></tr>
<tr><td><code id="lsmeans_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = suppress warning messages, e.g. for non-estimable contrasts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function computes LS Means of fixed effects and their corresponding 
standard errors. In case of setting argument 'type' equal to &quot;complex&quot; (or any
abbreviation) a <code class="reqn">t</code>-test is performed on each LS Mean, returning degrees
of freedom, t-statistic and corresponding p-values. One can choose from one of three
denominator degrees of freedom ('ddfm')-methods.
</p>
<p>Actually, function <code><a href="#topic+test.fixef">test.fixef</a></code> is called with the &quot;no intercept&quot; 
version of the fitted model. The &quot;complex&quot; option is significantly slower for unbalanced
designs (see <code><a href="#topic+test.fixef">test.fixef</a></code> for details). In case that the 'VarCov' element of
the 'VCA' object already exists (calling <code><a href="#topic+vcovVC">vcovVC</a></code>), which is the most time 
consuming part, results can be obtained in less amount of time.
</p>
<p>Standard Errors of LS Means are computed as <code class="reqn">TPT^{T}</code>, where <code class="reqn">T</code> is the
LS Means generating contrast matrix and <code class="reqn">P</code> is the variance-covariance matrix of
fixed effects.
</p>
<p>Argument <code>at</code> can be used to modify the values of covariables when computing LS Means and/or
to apply different weighting schemes for (fixed) factor variables in the model, e.g. when the prevelance
of factor-levels differs from a uniform distribution. Usually, if the weighting scheme is not modified,
each factor-level will contribute <code class="reqn">1/N</code> to the LS Mean, where <code class="reqn">N</code> corresponds to the number of factor-levels. 
</p>
<p>Covariables have to be specified as 'name=value', where value can be a vector of length &gt; 1. 
Each value will be evaluated for each row of the original LS Means contrast matrix. 
If multiple covariables are specified, the i-th element of covariable 1 will be matched with
the i-th element of covariable(s) 2...M, where <code class="reqn">M</code> is the number of covariables in the model.
</p>
<p>To apply a different weighting scheme for factor-variables one has to specify 'factor-name=c(level-name_1=value_1,
level-name_2=value_2, ..., level-name_N=value_N)'. The sum of all 'value_i' elements must be equal to 1, otherwise,
this factor-variable will be skipped issuing a warning. If any levels 'level-name_i' cannot be found for 
factor-variable 'factor-name', this variable will also be skipped and a warning will be issued.
See the examples section to get an impression of how this works.
</p>


<h3>Value</h3>

<p>(matrix) with LS Means of fixed effects and respective standard errors,
in case of 'type=&quot;complex&quot;'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
## Not run: 
data(dataEP05A2_2)
fit1 &lt;- anovaMM(y~day/(run), dataEP05A2_2)
lsmeans(fit1)
lsmeans(fit1,, "complex")

# a more complex model
data(VCAdata1)
fit2 &lt;- anovaMM(y~(lot+device)/(day)/(run), VCAdata1[VCAdata1$sample==2,])
lsmeans(fit2, "lot")
lsmeans(fit2, "device", "complex")

# pre-computed 'VarCov' element saves time
system.time(lsm1 &lt;- lsmeans(fit2, "device", "complex"))
fit2$VarCov &lt;- vcovVC(fit2)
system.time(lsm2 &lt;- lsmeans(fit2, "device", "complex"))
lsm1
lsm2 

# simulate some random data 
set.seed(212)
id &lt;- rep(1:10,10)
x &lt;- rnorm(200)
time &lt;- sample(1:5,200,replace=T)
y &lt;- rnorm(200)+time
snp &lt;- sample(0:1,200,replace=T)
dat &lt;- data.frame(id=id,x=x,y=y,time=time,snp=snp)
dat$snp &lt;- as.factor(dat$snp)
dat$id &lt;- as.factor(dat$id)
dat$time &lt;- as.numeric(dat$time)
dat$sex &lt;- gl(2, 100, labels=c("Male", "Female"))
dat$y &lt;- dat$y + rep(rnorm(2, 5, 1), c(100, 100))

fit3 &lt;- remlMM(y~snp+time+snp:time+sex+(id)+(id):time, dat)

# compute standard LS Means for variable "snp"
lsmeans(fit3, var="snp")
lsmeans(fit3, var="snp", type="c")    # comprehensive output

# compute LS Means at timepoints 1, 2, 3, 4
# Note: original LS Means are always part of the output
lsmeans(fit3, var="snp", at=list(time=1:4))

# compute LS Means with different weighting scheme
# for factor-variable 'sex'
lsmeans(fit3, var="snp", at=list(sex=c(Male=.3, Female=.7)))

# combine covariables at some value and altering the
# weighting scheme
lsmeans(fit3, var="snp", at=list(time=1:4, sex=c(Male=.3, Female=.7)))

# now with comprehensive output and requesting the
# LS Means generating contrast matrix
lsmeans(fit3, var="snp", type="complex", contr.mat=TRUE,
at=list(time=1:4, sex=c(Male=.3, Female=.7)))

## End(Not run)
</code></pre>

<hr>
<h2 id='LSMeans_Data'>Dataset for Unit-Testing of LS Means</h2><span id='topic+LSMeans_Data'></span>

<h3>Description</h3>

<p>This data set is used for unit-testing LS Means functionality. Reference 
results were generated in SAS PROC MIXED and rounded to two decimals as
covariance parameter estimates slightly differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LSMeans_Data)</code></pre>


<h3>Format</h3>

<p>data.frame with 200 rows and 6 variables.</p>

<hr>
<h2 id='lsmMat'>Contrast Matrix for LS Means</h2><span id='topic+lsmMat'></span>

<h3>Description</h3>

<p>Function determines appropriate contrast matrix for computing the LS Means of
each factor level of one or multiple fixed effects variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmMat(obj, var = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmMat_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="lsmMat_+3A_var">var</code></td>
<td>
<p>(character) string specifyig the fixed effects variable for which
the LS Means generating matrices should be computed</p>
</td></tr>
<tr><td><code id="lsmMat_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions implements the 5 rules given in the documentation of SAS PROC GLM for computing the LS Means.#'
The LS Means correspond to marginal means adjusted for bias introduced by unbalancedness.
</p>


<h3>Value</h3>

<p>(matrix) where each row corresponds to a LS Means generating contrast
for each factor level of one or multiple fixed effects variable(s)
</p>


<h3>Author(s)</h3>

<p>Andre Schutzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit1 &lt;- anovaMM(y~day/run, dataEP05A2_1)

VCA:::lsmMat(fit1, "day")	# function not exported
VCA:::lsmMat(fit1, "run")
VCA:::lsmMat(fit1)			# is equal to listing all fixed terms

# a more complex and unbalanced model
data(VCAdata1)
datS1 &lt;- VCAdata1[VCAdata1$sample == 1, ]
set.seed(42)
datS1ub &lt;- datS1[-sample(1:nrow(datS1))[1:25],]
fit2 &lt;- anovaMM(y~(lot+device)/day/(run), datS1ub)
VCA:::lsmMat(fit2, c("lot", "device"))

## End(Not run)
</code></pre>

<hr>
<h2 id='MLrepro'>Multi-Lot Reproducibility Data.</h2><span id='topic+MLrepro'></span>

<h3>Description</h3>

<p>This data set consists of 754 observations. There are 3 laboratories (Lab), 3 lots (Lot),
21 days (Days) per lab-lot combination, and 2 runs per day. The response variable is Result.
This dataset is used in examples and unit-tests (see subdir 'UnitTests' of the package-dir). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MLrepro)</code></pre>


<h3>Format</h3>

<p>data.frame with 754 rows and 5 variables.</p>

<hr>
<h2 id='model.frame.VCA'>Extract the Model Frame from a 'VCA' Object</h2><span id='topic+model.frame.VCA'></span>

<h3>Description</h3>

<p>Function returns the data-element of 'object' and
adds the terms-element as attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.VCA_+3A_formula">formula</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="model.frame.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It enables application of functions relying on the existence of 
this method, e.g. the functin 'glht' of the 'multcomp'
R-package.
</p>


<h3>Value</h3>

<p>(data.frame) with attribute 'terms'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='model.matrix.VCA'>Model Matrix of a Fitted VCA-Object</h2><span id='topic+model.matrix.VCA'></span>

<h3>Description</h3>

<p>Function returns matrix <code>X</code> corresponding
to the design matrix of fixed effects of the fitted
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="model.matrix.VCA_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>

<hr>
<h2 id='MPinv'>Moore-Penrose Generalized Inverse of a Matrix</h2><span id='topic+MPinv'></span>

<h3>Description</h3>

<p>This function is originally impelemented in package 'MASS' as function <code>ginv</code>. 
It was adapted to be able to deal with matrices from the 'Matrix' package,
e.g. sparse matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPinv(X, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MPinv_+3A_x">X</code></td>
<td>
<p>(object) two-dimensional, for which a Moore-Penrose inverse
has to be computed</p>
</td></tr>
<tr><td><code id="MPinv_+3A_tol">tol</code></td>
<td>
<p>(numeric) tolerance value to be used in comparisons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(object) A Moore-Penrose inverse of X.
</p>


<h3>Author(s)</h3>

<p>Authors of the 'MASS' package.
</p>

<hr>
<h2 id='orderData'>Re-Order Data.Frame</h2><span id='topic+orderData'></span>

<h3>Description</h3>

<p>Functions attempts to standardize input data for linear mixed model analyses
to overcome the problem that analysis results sometimes depend on ordering of
the data and definition of factor-levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderData(Data, trms, order.data = TRUE, exclude.numeric = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderData_+3A_data">Data</code></td>
<td>
<p>(data.frame) with input data intented to put into standard-order</p>
</td></tr>
<tr><td><code id="orderData_+3A_trms">trms</code></td>
<td>
<p>(formula, terms) object speciying a model to be fitted to <code>Data</code></p>
</td></tr>
<tr><td><code id="orderData_+3A_order.data">order.data</code></td>
<td>
<p>(logical) TRUE = variables will be increasingly ordered, FALSE = order of
the variables remains as is</p>
</td></tr>
<tr><td><code id="orderData_+3A_exclude.numeric">exclude.numeric</code></td>
<td>
<p>(logical) TRUE = numeric variables will not be included in the reordering,
which is required whenever this variable serves as covariate in a LMM, 
FALSE = numeric variables will also be converted to factors, useful in 
VCA-analysis, where all variables are interpreted as class-variables</p>
</td></tr>
<tr><td><code id="orderData_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = omits any (potentially) informative output regarding
re-ordering and type-casting of variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# random ordering
data(dataEP05A2_1)
dat &lt;- dataEP05A2_1
levels(dat$day) &lt;- sample(levels(dat$day))
# this has direct impact e.g. on order of estimated effects
fit &lt;- anovaVCA(y~day/run, dat, order.data=FALSE)
ranef(fit)
# to guarantee consistent analysis results
# independent of the any data orderings option
# 'order.data' is per default set to TRUE:
fit &lt;- anovaVCA(y~day/run, dat)
ranef(fit)
# which is identical to:
fit2 &lt;- anovaVCA(y~day/run, orderData(dat, y~day/run), order.data=FALSE)
ranef(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='Orthodont'>Orthodont dataset from R-package 'nlme'</h2><span id='topic+Orthodont'></span>

<h3>Description</h3>

<p>The Orthodont data frame has 108 rows and 4 columns of the change in an orthdontic measurement over time for several young subjects. 
</p>
<p>This dataset was included to simplify its usage in automated unit-tests (see directory UnitTests) and examples. 
</p>
<p>Investigators at the University of North Carolina Dental School followed the growth of 27 children (16 males, 11 females) 
from age 8 until age 14. Every two years they measured the distance between the pituitary and the pterygomaxillary fissure, 
two points that are easily identified on x-ray exposures of the side of the head. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Orthodont)</code></pre>


<h3>Format</h3>

<p>data.frame with 80 rows and 3 variables.</p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), Mixed-Effects Models in S and S-PLUS, Springer, New York. (Appendix A.17)		
</p>
<p>Potthoff, R. F. and Roy, S. N. (1964), A generalized multivariate analysis of variance model useful especially for growth curve problems, Biometrika, 51, 313-326. 
</p>

<hr>
<h2 id='plot.VCA'>Standard 'plot' Method for 'VCA' S3-Objects.</h2><span id='topic+plot.VCA'></span>

<h3>Description</h3>

<p>Create a variability chart from a 'VCA'-object, i.e. from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.VCA_+3A_x">x</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="plot.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the data and the model-formula from a fitted 'VCA'-object and calls function <code><a href="#topic+varPlot">varPlot</a></code>
accepting all its arguments. Please see the documention of function <code><a href="#topic+varPlot">varPlot</a></code> for a detailed description.
</p>
<p>It will not be differentiated between fixed and random effects when calling this function on a fitted linear mixed model.
</p>


<h3>Value</h3>

<p>nothing, instead a plot is generated
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varPlot">varPlot</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>,<code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>,<code><a href="#topic+remlMM">remlMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)

# standard plot without any extras
plot(fit)

# plot with some additional features
plot(fit, MeanLine=list(var=c("int", "day"), col=c("cyan", "blue"), lwd=c(2,2)))

# more complex model
data(realData)
Data &lt;- realData[realData$PID == 1,]
fit2 &lt;- anovaVCA(y~(calibration+lot)/day/run, Data)
plot(fit2, 
		BG=list(var="calibration",
				col=c("#f7fcfd","#e5f5f9","#ccece6","#99d8c9",
				      "#66c2a4","#41ae76","#238b45","#006d2c","#00441b"),
				col.table=TRUE),
	VLine=list(var=c("calibration", "lot"),
				   col=c("black", "darkgray"), lwd=c(2,1), col.table=TRUE),
		JoinLevels=list(var="lot", col=c("#ffffb2","orangered","#feb24c"),
				        lwd=c(2,2,2)),
		MeanLine=list(var="lot", col="blue", lwd=2))


## End(Not run)
</code></pre>

<hr>
<h2 id='plotRandVar'>Plot Random Variates of a Mixed Model ('VCA' Object).</h2><span id='topic+plotRandVar'></span>

<h3>Description</h3>

<p>Plots, possibly transformed, random variates of a linear mixed model (random effects, contitional or marginal
residuals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRandVar(
  obj,
  term = NULL,
  mode = c("raw", "student", "standard", "pearson"),
  main = NULL,
  Xlabels = list(),
  Points = list(),
  Vlines = list(),
  pick = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRandVar_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_term">term</code></td>
<td>
<p>(character, integer) specifying a type of residuals if one of c(&quot;conditional&quot;,
&quot;marginal&quot;), or, the name of a random term (one of obj$re.assign$terms). If 'term'
is a integer, it is interpreted as the i-th random term in 'obj$re.assign$terms'.</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_mode">mode</code></td>
<td>
<p>(character) string specifying a possible transformation of random effects or 
residuals (see <code><a href="#topic+residuals.VCA">residuals.VCA</a></code> and <code><a href="#topic+ranef.VCA">ranef.VCA</a></code>for details)</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_main">main</code></td>
<td>
<p>(character) string used as main title of the plot, if NULL, it will be automatically
generated</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_xlabels">Xlabels</code></td>
<td>
<p>(list) passed to function <code><a href="graphics.html#topic+text">text</a></code> adding labels to the bottom margin at
x-coordinates 1:N, where N is the number of random variates. Useful for customization.</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_points">Points</code></td>
<td>
<p>(list) passed to function <code><a href="graphics.html#topic+points">points</a></code> for customization of plotting symbols</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_vlines">Vlines</code></td>
<td>
<p>(list) passed to function (abline) adding vertical lines, separating random variates
for better visual separation, set to NULL for omitting vertical lines.</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_pick">pick</code></td>
<td>
<p>(logical) TRUE = lets the user identify single points using the mouse, useful, when many,
points were drawn where the X-labels are not readable.</p>
</td></tr>
<tr><td><code id="plotRandVar_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function plots either random effects of a 'VCA' object or residuals. Parameter 'term' is used to specify either
one. If 'term' is one of c(&quot;conditional&quot;, &quot;marginal&quot;) corresponding residuals will be plotted 
(see <code><a href="#topic+resid">resid</a></code> for details). If 'term' is either the name of a random term in the formula of the 'VCA'
object or an integer specifying the i-th random term, corresponding random effects will be plotted. Both types
of random variates (random effects, residuals) can be plotted untransformed (&quot;raw&quot;), &quot;studentized&quot; or &quot;standardized&quot;.
In case of residuals, one can also use the &quot;Pearson&quot;-type transformation.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
# solve mixed model equations including random effects
fit &lt;- solveMME(fit)
plotRandVar(fit, "cond", "stand")	
plotRandVar(fit, 1, "stud")						# 1st random term 'day'
plotRandVar(fit, "day", "stud")					# equivalent to the above

# for larger datasets residuals can hardly be identified
# pick out interesting points with the mouse

plotRandVar(fit, "marg", "stud", pick=TRUE)

# customize the appearance
plotRandVar( fit, 1, "stud", Vlines=list(col=c("red", "darkgreen")), 
	Xlabels=list(offset=.5, srt=60, cex=1, col="blue"),
	Points=list(col=c("black", "red", rep("black", 18)),
pch=c(3,17,rep(3,18)), cex=c(1,2,rep(1,18))))	

## End(Not run) 
</code></pre>

<hr>
<h2 id='predict.VCA'>Predictions from a Model Fitted by <code>fitLMM</code></h2><span id='topic+predict.VCA'></span>

<h3>Description</h3>

<p>Model returns fitted values in case <code>newdata</code> is NULL or evaluates
the fitted model employing user-specified data <code>newdata</code>. The default is that
fitted values incorporate fixed effects and random effects, leaving out the (conditional)
residuals only. If the interest lies in constraining predictions to the fixed effects only
set <code>re=NA</code> or incorporate just part of the random variability specifying distinct random
effects (see <code>re</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
predict(object, newdata = NULL, re = NULL, allow.new.levels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object fitted via function <code><a href="#topic+fitLMM">fitLMM</a></code></p>
</td></tr>
<tr><td><code id="predict.VCA_+3A_newdata">newdata</code></td>
<td>
<p>(data.frame) with all variables required for the specified prediction,
i.e. the default settings require all variables of the original model, 
in case of <code>re=NA</code>, only variables corresponding to fixed effects are
required.</p>
</td></tr>
<tr><td><code id="predict.VCA_+3A_re">re</code></td>
<td>
<p>(character) if NULL (default) all random effects will be included, 
to restrict predictions to the fixed effects use <code>re=NA</code>, for
a subset of random effects included in predictions use any valid
random effects specification, i.e. <code>object$random</code></p>
</td></tr>
<tr><td><code id="predict.VCA_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>(logical) if new levels (no part of the original fitted model) in newdata
are allowed. If FALSE (default), such new values in newdata will trigger
an error; if TRUE, then the prediction will use the unconditional (population-level)
values for data with previously unobserved levels (or NAs).</p>
</td></tr>
<tr><td><code id="predict.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments passdo or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector of prediction results
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzeneister@roche.com">andre.schuetzeneister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit LMM with fixed lot and device effects and test for lot-differences
data(VCAdata1)
datS5 &lt;- subset(VCAdata1, sample==5)
fitS5 &lt;- fitLMM(y~(lot+device)/(day)/(run), datS5, "anova")
fitS5

# fitted values including fixed and random effects
pred0 &lt;- predict(fitS5)
pred0
# sanity check:
all(round(pred0 + resid(fitS5) - datS5$y, 12) == 0)
# restrict to fixed effects
predict(fitS5, re=NA)
# restrict to fixed effects and dayly random effects
# see required names
fitS5$random
predict(fitS5, re="lot:device:day")

# check against original 'lmer'-predictions
# use version from VCA-package (ordinary data.frame)
data(Orthodont, package="VCA")
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age-11
# use exactly the same data, same ordering
Ortho &lt;- orderData(Ortho, distance ~ Sex * age2 + (Subject) * age2)
fit.fitLMM &lt;- fitLMM(distance ~ Sex * age2 + (Subject) * age2, Ortho, "reml")
library(lme4)
fit.lmer &lt;- lmer(distance ~ Sex + age2 + Sex:age2 + (age2 | Subject), Ortho)
# check fitted value first (fixed + random effects)
predict(fit.lmer)
predict(fit.fitLMM)
# restrict to fixed part only
predict(fit.lmer, re.form=NA)  
predict(fit.fitLMM, re=NA)
# user-specified 'newdata'
newdata &lt;- Ortho[45:54,]
newdata$age2 &lt;- newdata$age2 + 5
# include fixed and random effects
predict(fit.lmer, newdata)
predict(fit.fitLMM, newdata)
# generate new data
newdata &lt;- Ortho[45:54,]          
newdata$age2 &lt;- newdata$age2 + 5
# predict on newdata using fixed and random effects
predict(fit.lmer, newdata) 
predict(fit.fitLMM, newdata)       
# restrict prediction to random Subject effects
predict(fit.lmer, newdata, re.form=~(1|Subject))        
predict(fit.fitLMM, newdata, re="Subject")
# restrict prediction to random per-Subject slope
predict(fit.lmer, newdata, re.form=~(age2-1|Subject)) 
predict(fit.fitLMM, newdata, re="age2:Subject")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.VCA'>Standard Printing Method for Objects of Class 'VCA'</h2><span id='topic+print.VCA'></span>

<h3>Description</h3>

<p>Function prints 'VCA' objects as returned e.g. by function <code><a href="#topic+anovaVCA">anovaVCA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
print(x, digits = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.VCA_+3A_x">x</code></td>
<td>
<p>(VCA) object of class 'VCA' as returned by function 'anovaVCA'.</p>
</td></tr>
<tr><td><code id="print.VCA_+3A_digits">digits</code></td>
<td>
<p>(integer) number of digits numeric values are rounded to before printing.</p>
</td></tr>
<tr><td><code id="print.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.VCAinference'>Standard Print Method for Objects of Class 'VCAinference'</h2><span id='topic+print.VCAinference'></span>

<h3>Description</h3>

<p>Prints the list-type 'VCAinference'-object as tabulated output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCAinference'
print(x, digits = 4L, what = c("all", "VC", "SD", "CV", "VCA"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.VCAinference_+3A_x">x</code></td>
<td>
<p>(VCAinference) object</p>
</td></tr>
<tr><td><code id="print.VCAinference_+3A_digits">digits</code></td>
<td>
<p>(integer) number of decimal digits.</p>
</td></tr>
<tr><td><code id="print.VCAinference_+3A_what">what</code></td>
<td>
<p>(character) one of &quot;all&quot;, &quot;VC&quot;, &quot;SD&quot;, &quot;CV&quot;, &quot;VCA&quot; specifying which part of the 'VCA'-object is to be printed.</p>
</td></tr>
<tr><td><code id="print.VCAinference_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formats the list-type objects of class 'VCAinference' for a more comprehensive
presentation of results, which are easier to grasp. The default is to show the complete
object (VCA ANOVA-table, VC-, SD-, and CV-CIs). Using parameter 'what' allows to
restrict the printed output to certain parts. Print-function invisibly returns a matrix
or a list of matrices, depending on the values of 'what', i.e. it can be used as for
packing the inference-information in one or multiple matrix-objects and extracting it/them.
</p>


<h3>Value</h3>

<p>invisibly returns sub-elements of 'x' specified via 'what'
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VCAinference">VCAinference</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data (CLSI EP05-A2 Within-Lab Precision Experiment) 
data(dataEP05A2_1)

# perform ANOVA-estimation of variance components for a nested design
res &lt;- anovaVCA(y~day/run, Data=dataEP05A2_1)
res
inf &lt;- VCAinference(res)
inf

# show certain parts and extract them invisibly
CVmat &lt;- print(inf, what="CV")
CVmat

# show numerical values with more digits
print(inf, digit=12)

## End(Not run)
</code></pre>

<hr>
<h2 id='protectedCall'>Wrap Function-Calls to Execute Additional Checks.</h2><span id='topic+protectedCall'></span>

<h3>Description</h3>

<p>Function can be used to wrap function-calls, here, intended for model fitting
functions <code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>, <code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code>,
<code><a href="#topic+fitVCA">fitVCA</a></code>, and <code><a href="#topic+fitLMM">fitLMM</a></code>. When wrapped, there is the option to 
perform additional checks and reporting back identified problems by setting 'ErrorType=&quot;Detailed&quot;'.
There is no error-handling provided by this function, i.e. any error issued will remain an error.
It would need to be handled by <code><a href="base.html#topic+try">try</a></code>, <code><a href="base.html#topic+tryCatch">tryCatch</a></code> or similar.
Note, that inline definition of datasets within 'expr' is not supported and will issue an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protectedCall(expr, ErrorType = c("Simple", "Detailed"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protectedCall_+3A_expr">expr</code></td>
<td>
<p>(expression) to be protected, typically, a call to a model-fitting 
function from this package (see details)</p>
</td></tr>
<tr><td><code id="protectedCall_+3A_errortype">ErrorType</code></td>
<td>
<p>(ErrorType) &quot;Simple&quot;=default error-messages, &quot;Detailed&quot;= additional
data consistency checks will be performed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# nothing happens if no error occurs
data(dataEP05A2_1)
res &lt;- protectedCall(anovaVCA(form=y~day/run, Data=dataEP05A2_1))
res
# error message without additional consistency checks (default)
dat3 &lt;- data.frame(	y=rnorm(8,10),
						day=rep(c(1,2),c(4,4)), 
						run=rep(c(2,1), c(4,4)))
protectedCall(anovaVCA(form=y~day/run, Data=dat3), ErrorType="Simple")
# error message with additional consistency checks hopefully helpful for the user
protectedCall(anovaVCA(form=y~day/run, Data=dat3), ErrorType="Detailed")

# handle error
res &lt;- try(protectedCall(anovaVCA(form=y~day/run, Data=dat3), ErrorType="Detailed"), silent=TRUE)
if(is(res, "try-error"))
	cat(sub(", ErrorType .*\\)", "", sub("protectedCall\\(", "", res)))

# inline-definition of data.frames issues an error
protectedCall(anovaVCA(	form=y~day/run, 
							Data=data.frame(y=rnorm(8,10),
								day=rep(c(1,2),c(4,4)), 
								run=rep(c(2,1), c(4,4)))))

## End(Not run)
</code></pre>

<hr>
<h2 id='ranef'>Generic Method for Extracting Random Effects from a Fitted Model</h2><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Generic Method for Extracting Random Effects from a Fitted Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>(object)</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.VCA">ranef.VCA</a></code>
</p>

<hr>
<h2 id='ranef.VCA'>Extract Random Effects from 'VCA' Object</h2><span id='topic+ranef.VCA'></span>

<h3>Description</h3>

<p>Extract random effects and possibly apply a transformation to them (standardization,
studentization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
ranef(
  object,
  term = NULL,
  mode = c("raw", "student", "standard"),
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object from which random effects shall be extracted</p>
</td></tr>
<tr><td><code id="ranef.VCA_+3A_term">term</code></td>
<td>
<p>(character) string specifying a term (factor) for which random effects 
should be extracted, one can also specify an integer which is interpreted
as i-th element of 'obj$res.assign$terms'</p>
</td></tr>
<tr><td><code id="ranef.VCA_+3A_mode">mode</code></td>
<td>
<p>(character) string or abbreviation specifying whether &quot;raw&quot; residuals
should be returned or a transformed version c(&quot;student&quot; or &quot;standard&quot;)</p>
</td></tr>
<tr><td><code id="ranef.VCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="ranef.VCA_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting the 'RandomEffects' element of an 'VCA' object if this exists and applying
standardization (mean 0, sd 1) or studentization. For studentized random effects 
the i-th random effects is divided by the i-th main diagonal element of matrix <code class="reqn">O = GZ^{T}QZG</code>,
where <code class="reqn">G</code> is the covariance-matrix of random effects, <code class="reqn">Z</code> is a design matrix assigning 
random effects to observations and matrix <code class="reqn">Q = V^{-1}(I - H)</code> (see <code><a href="#topic+residuals.VCA">residuals.VCA</a></code> for further details).
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York	
</p>
<p>Laird, N.M., Ware, J.H., 1982. Random effects models for longitudinal data. Biometrics 38, 963-974.
</p>
<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
ranef(fit)

# get variable-specific random effects (REs)
# both extract the same REs
ranef(fit, "day")
ranef(fit, 1)

# get standardized REs
ranef(fit, "day:run", "standard")

# or studentized REs
ranef(fit, 2, "stu")

## End(Not run)
</code></pre>

<hr>
<h2 id='realData'>Real-World Data</h2><span id='topic+realData'></span>

<h3>Description</h3>

<p>This dataset is meant to serve as real-world representative completing the collection
of datasets coming with this package. There are 6 variables, one response variable ('y')
corresponding to concentration values of the measurand, and 5 factor variables. Variable &quot;calibration&quot;
corresponds to the day a (re-) calibration was performed, all other variables are more or less
self-explaining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(realData)</code></pre>


<h3>Format</h3>

<p>data.frame with 2268 rows and 6 variables.</p>

<hr>
<h2 id='remlMM'>Fit Linear Mixed Models via REML</h2><span id='topic+remlMM'></span>

<h3>Description</h3>

<p>Function fits Linear Mixed Models (LMM) using Restricted Maximum Likelihood (REML).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remlMM(
  form,
  Data,
  by = NULL,
  VarVC = TRUE,
  cov = TRUE,
  quiet = FALSE,
  order.data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remlMM_+3A_form">form</code></td>
<td>
<p>(formula) specifying the model to be fit, a response variable left of the '~' is mandatory, random terms
have to be enclosed in brackets (see details for definition of valid model terms)</p>
</td></tr>
<tr><td><code id="remlMM_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables referenced in 'form'</p>
</td></tr>
<tr><td><code id="remlMM_+3A_by">by</code></td>
<td>
<p>(factor, character) variable specifying groups for which the analysis should be performed individually,
i.e. by-processing</p>
</td></tr>
<tr><td><code id="remlMM_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = the variance-covariance matrix of variance components will be approximated using 
the method found in Giesbrecht &amp; Burns (1985), which also serves as basis for applying a Satterthwaite
approximation of the degrees of freedom for each variance component, FALSE = leaves out this step, 
no confidence intervals for VC will be available</p>
</td></tr>
<tr><td><code id="remlMM_+3A_cov">cov</code></td>
<td>
<p>(logical) TRUE = in case of non-zero covariances a block diagonal matrix will be constructed,
FALSE = a diagonal matrix with all off-diagonal element being equal to zero will be contructed</p>
</td></tr>
<tr><td><code id="remlMM_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any messages or warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="remlMM_+3A_order.data">order.data</code></td>
<td>
<p>(logical) TRUE = class-variables will be ordered increasingly, FALSE = ordering of class-variables
will remain as is</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is formulated exactly as in function <code><a href="#topic+anovaMM">anovaMM</a></code>, i.e. random terms need be enclosed by round brackets.
All terms appearing in the model (fixed or random) need to be compliant with the regular expression &quot;^[^[\.]]?[[:alnum:]_\.]*$&quot;,
i.e. they may not start with a dot and may then only consist of alpha-numeric characters, 
dot and underscore. Otherwise, an error will be issued.
</p>
<p>Here, a LMM is fitted by REML using the <code><a href="lme4.html#topic+lmer">lmer</a></code> function of the <code>lme4</code>-package. 
For all models the Giesbrechnt &amp; Burns (1985) approximation of the variance-covariance
matrix of variance components (VC) can be applied ('VarVC=TRUE'). A Satterthwaite approximation of the degrees of freedom
for all VC and total variance is based on this approximated matrix using <code class="reqn">df=2Z^2</code>, where
<code class="reqn">Z</code> is the Wald statistic <code class="reqn">Z=\sigma^2/se(\sigma^2)</code>, and <code class="reqn">\sigma^2</code> is here used for an
estimated variance. The variance of total variability, i.e. the sum of all VC is computed via summing
up all elements of the variance-covariance matrix of the VC.
One can constrain the variance-covariance matrix of random effects <code class="reqn">G</code> to be either diagonal ('cov=FALSE'), i.e.
all random effects are indpendent of each other (covariance is 0). If 'cov=TRUE' (the default) matrix <code class="reqn">G</code> will be
constructed as implied by the model returned by function <code><a href="lme4.html#topic+lmer">lmer</a></code>. 
</p>
<p>As for objects returned by function <code><a href="#topic+anovaMM">anovaMM</a></code> linear hypotheses of fixed effects or LS Means can be
tested with functions <code><a href="#topic+test.fixef">test.fixef</a></code> and <code><a href="#topic+test.lsmeans">test.lsmeans</a></code>. Note, that option &quot;contain&quot; does
not work for LMM fitted via REML.
</p>
<p>Note, that for large datasets approximating the variance-covariance matrix of VC is computationally expensive
and may take very long. There is no Fisher-information matrix available for 'merMod' objects, which can
serve as approximation. To avoid this time-consuming step, use argument 'VarVC=FALSE' but remember,
that no confidence intervals for any VC will be available. If you use Microsoft's R Open, formerly known
as Revolution-R, which comes with Intel's Math Kernel Library (MKL), this will be automatically detected
and an environment-optimized version will be used, reducing the computational time considerably (see examples).
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+VCAinference">VCAinference</a></code>, <code><a href="#topic+ranef.VCA">ranef.VCA</a></code>, <code><a href="#topic+residuals.VCA">residuals.VCA</a></code>,
<code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>, <code><a href="#topic+plotRandVar">plotRandVar</a></code>,  <code><a href="#topic+test.fixef">test.fixef</a></code>,  
<code><a href="#topic+test.lsmeans">test.lsmeans</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_2)

# assuming 'day' as fixed, 'run' as random
remlMM(y~day/(run), dataEP05A2_2)

# assuming both as random leads to same results as
# calling anovaVCA
remlMM(y~(day)/(run), dataEP05A2_2)
anovaVCA(y~day/run, dataEP05A2_2)
remlVCA(y~day/run, dataEP05A2_2)

# fit a larger random model
data(VCAdata1)
fitMM1 &lt;- remlMM(y~((lot)+(device))/(day)/(run), VCAdata1[VCAdata1$sample==1,])
fitMM1
# now use function tailored for random models
fitRM1 &lt;- anovaVCA(y~(lot+device)/day/run, VCAdata1[VCAdata1$sample==1,])
fitRM1

# there are only 3 lots, take 'lot' as fixed 
fitMM2 &lt;- remlMM(y~(lot+(device))/(day)/(run), VCAdata1[VCAdata1$sample==2,])

# the following model definition is equivalent to the one above,
# since a single random term in an interaction makes the interaction
# random (see the 3rd reference for details on this topic)
fitMM3 &lt;- remlMM(y~(lot+(device))/day/run, VCAdata1[VCAdata1$sample==2,])

# fit same model for each sample using by-processing
lst &lt;- remlMM(y~(lot+(device))/day/run, VCAdata1, by="sample")
lst

# fit mixed model originally from 'nlme' package

library(nlme)
data(Orthodont)
fit.lme &lt;- lme(distance~Sex*I(age-11), random=~I(age-11)|Subject, Orthodont) 

# re-organize data for using 'remlMM'
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit.remlMM1 &lt;- remlMM(distance~Sex*age2+(Subject)*age2, Ortho)

# use simplified formula avoiding unnecessary terms
fit.remlMM2 &lt;- remlMM(distance~Sex+age2+Sex:age2+(Subject)+age2:(Subject), Ortho)

# and exclude intercept
fit.remlMM3 &lt;- remlMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)

# now use exclude covariance of per-subject intercept and slope
# as for models fitted by function 'anovaMM'
fit.remlMM4 &lt;- remlMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho, cov=FALSE)

# compare results
fit.lme
fit.remlMM1
fit.remlMM2
fit.remlMM3
fit.remlMM4

# are there a sex-specific differences?
cmat &lt;- getL(fit.remlMM3, c("SexMale-SexFemale", "SexMale:age2-SexFemale:age2")) 
cmat

test.fixef(fit.remlMM3, L=cmat)

## End(Not run)
</code></pre>

<hr>
<h2 id='remlVCA'>Perform (V)ariance (C)omponent (A)nalysis via REML-Estimation</h2><span id='topic+remlVCA'></span>

<h3>Description</h3>

<p>Function performs a Variance Component Analysis (VCA) using Restricted Maximum Likelihood (REML)
to fit the random model, i.e. a linear mixed model (LMM) where the intercept is the only fixed effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remlVCA(form, Data, by = NULL, VarVC = TRUE, quiet = FALSE, order.data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remlVCA_+3A_form">form</code></td>
<td>
<p>(formula) specifying the model to be fit, a response variable left of the '~' is mandatory</p>
</td></tr>
<tr><td><code id="remlVCA_+3A_data">Data</code></td>
<td>
<p>(data.frame) containing all variables referenced in 'form'</p>
</td></tr>
<tr><td><code id="remlVCA_+3A_by">by</code></td>
<td>
<p>(factor, character) variable specifying groups for which the analysis should be performed individually,
i.e. by-processing</p>
</td></tr>
<tr><td><code id="remlVCA_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = the variance-covariance matrix of variance components will be approximated using 
the method found in Giesbrecht &amp; Burns (1985), which also serves as basis for applying a Satterthwaite
approximation of the degrees of freedom for each variance component, FALSE = leaves out this step, 
no confidence intervals for VC will be available</p>
</td></tr>
<tr><td><code id="remlVCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any messages or warnings, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="remlVCA_+3A_order.data">order.data</code></td>
<td>
<p>(logical) TRUE = class-variables will be ordered increasingly, FALSE = ordering of class-variables
will remain as is</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here, a variance component model is fitted by REML using the <code><a href="lme4.html#topic+lmer">lmer</a></code> function of the
<code>lme4</code>-package. For all models the Giesbrechnt &amp; Burns (1985) approximation of the variance-covariance
matrix of variance components (VC) is applied. A Satterthwaite approximation of the degrees of freedom
for all VC and total variance is based on this approximated matrix using <code class="reqn">df=2Z^2</code>, where
<code class="reqn">Z</code> is the Wald statistic <code class="reqn">Z=\sigma^2/se(\sigma^2)</code>, and <code class="reqn">\sigma^2</code> is here used for an
estimated variance. The variance of total variability, i.e. the sum of all VC is computed via summing
up all elements of the variance-covariance matrix of the VC.
Note, that for large datasets approximating the variance-covariance matrix of VC is computationally expensive
and may take very long. There is no Fisher-information matrix available for 'merMod' objects, which can
serve as approximation. To avoid this time-consuming step, use argument 'VarVC=FALSE' but remember,
that no confidence intervals for any VC will be available. If you use Microsoft's R Open, formerly known
as Revolution-R, which comes with Intel's Math Kernel Library (MKL), this will be automatically detected
and an environment-optimized version will be used, reducing the computational time very much (see examples).
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remlMM">remlMM</a></code>, <code><a href="#topic+VCAinference">VCAinference</a></code>, <code><a href="#topic+ranef.VCA">ranef.VCA</a></code>, <code><a href="#topic+residuals.VCA">residuals.VCA</a></code>,
<code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>, <code><a href="#topic+plotRandVar">plotRandVar</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# a VCA standard example
data(dataEP05A2_3)

# fit it by ANOVA first, then by REML
fit0 &lt;- anovaVCA(y~day/run, dataEP05A2_3) 
fit1 &lt;- remlVCA(y~day/run, dataEP05A2_3)
fit0
fit1

# make example unbalanced
set.seed(107)
dat.ub &lt;- dataEP05A2_3[-sample(1:80, 7),]
fit0ub &lt;- anovaVCA(y~day/run, dat.ub) 
fit1ub &lt;- remlVCA(y~day/run, dat.ub) 

# not that ANOVA- and REML-results now differ
fit0ub
fit1ub

### Use the six sample reproducibility data from CLSI EP5-A3
### and fit per sample reproducibility model
data(CA19_9)
fit.all &lt;- remlVCA(result~site/day, CA19_9, by="sample")

reproMat &lt;- data.frame(
Sample=c("P1", "P2", "Q3", "Q4", "P5", "Q6"),
Mean= c(fit.all[[1]]$Mean, fit.all[[2]]$Mean, fit.all[[3]]$Mean, 
fit.all[[4]]$Mean, fit.all[[5]]$Mean, fit.all[[6]]$Mean),
Rep_SD=c(fit.all[[1]]$aov.tab["error","SD"], fit.all[[2]]$aov.tab["error","SD"],
fit.all[[3]]$aov.tab["error","SD"], fit.all[[4]]$aov.tab["error","SD"],
fit.all[[5]]$aov.tab["error","SD"], fit.all[[6]]$aov.tab["error","SD"]),
Rep_CV=c(fit.all[[1]]$aov.tab["error","CV[%]"],fit.all[[2]]$aov.tab["error","CV[%]"],
fit.all[[3]]$aov.tab["error","CV[%]"],fit.all[[4]]$aov.tab["error","CV[%]"],
fit.all[[5]]$aov.tab["error","CV[%]"],fit.all[[6]]$aov.tab["error","CV[%]"]),
WLP_SD=c(sqrt(sum(fit.all[[1]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[2]]$aov.tab[3:4, "VC"])),
sqrt(sum(fit.all[[3]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[4]]$aov.tab[3:4, "VC"])),
sqrt(sum(fit.all[[5]]$aov.tab[3:4,"VC"])),sqrt(sum(fit.all[[6]]$aov.tab[3:4, "VC"]))),
WLP_CV=c(sqrt(sum(fit.all[[1]]$aov.tab[3:4,"VC"]))/fit.all[[1]]$Mean*100,
sqrt(sum(fit.all[[2]]$aov.tab[3:4,"VC"]))/fit.all[[2]]$Mean*100,
sqrt(sum(fit.all[[3]]$aov.tab[3:4,"VC"]))/fit.all[[3]]$Mean*100,
sqrt(sum(fit.all[[4]]$aov.tab[3:4,"VC"]))/fit.all[[4]]$Mean*100,
sqrt(sum(fit.all[[5]]$aov.tab[3:4,"VC"]))/fit.all[[5]]$Mean*100,
sqrt(sum(fit.all[[6]]$aov.tab[3:4,"VC"]))/fit.all[[6]]$Mean*100),
Repro_SD=c(fit.all[[1]]$aov.tab["total","SD"],fit.all[[2]]$aov.tab["total","SD"],
fit.all[[3]]$aov.tab["total","SD"],fit.all[[4]]$aov.tab["total","SD"],
fit.all[[5]]$aov.tab["total","SD"],fit.all[[6]]$aov.tab["total","SD"]),
Repro_CV=c(fit.all[[1]]$aov.tab["total","CV[%]"],fit.all[[2]]$aov.tab["total","CV[%]"],
fit.all[[3]]$aov.tab["total","CV[%]"],fit.all[[4]]$aov.tab["total","CV[%]"],
fit.all[[5]]$aov.tab["total","CV[%]"],fit.all[[6]]$aov.tab["total","CV[%]"]))

for(i in 3:8) reproMat[,i] &lt;- round(reproMat[,i],digits=ifelse(i%%2==0,1,3))
reproMat

# now plot the precision profile over all samples
plot(reproMat[,"Mean"], reproMat[,"Rep_CV"], type="l", main="Precision Profile CA19-9",
xlab="Mean CA19-9 Value", ylab="CV[%]")
grid()
points(reproMat[,"Mean"], reproMat[,"Rep_CV"], pch=16)

# REML-estimation not yes optimzed to the same degree as
# ANOVA-estimation. Note, that no variance-covariance matrix
# for the REML-fit is computed (VarVC=FALSE)!
# Note: A correct analysis would be done per-sample, this is just
#       for illustration.
data(VCAdata1)
# with complete sweeping implemented as FORTRAN-routine fit 
system.time(fit0 &lt;- anovaVCA(y~sample+(device+lot)/day/run, VCAdata1))
system.time(fit1 &lt;- remlVCA(y~sample+(device+lot)/day/run, VCAdata1, VarVC=FALSE))

# The previous example will also be interesting for environments using MKL.
# Run it once in a GNU-R environment and once in a MKL-environment
# and compare computational time of both. Note, that 'VarVC' is now set to TRUE
# and variable "sample" is put into the brackets increasing the number of random
# effects by factor 10. On my Intel Xeon E5-2687W 3.1 GHz workstation it takes
# ~ 400s with GNU-R and ~25s with MKL support (MRO) both run under Windows.
system.time(fit2 &lt;- remlVCA(y~(sample+device+lot)/day/run, VCAdata1, VarVC=TRUE))

# using the SWEEP-Operator is even faster 
system.time(fit3 &lt;- anovaVCA(y~(sample+device+lot)/day/run, VCAdata1))
fit2
fit3

## End(Not run)
</code></pre>

<hr>
<h2 id='ReproData1'>Multi-Site Data for Estimating Reproducibility Precision</h2><span id='topic+ReproData1'></span>

<h3>Description</h3>

<p>This data set consists of real-world measurements of a multi-site study aiming at quantifying
reproducibility precision. Unlike in the CLSI EP05-A3 guideline, there are two runs per day with
three replicated measurements per run. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ReproData1)</code></pre>


<h3>Format</h3>

<p>data.frame with 120 rows and 4 variables.</p>


<h3>References</h3>

<p>Approved Guideline CLSI EP05-A3 - Evaluation of Precision Performance of Quantitative Measurement Methods.
<a href="https://clsi.org">CLSI</a>
</p>

<hr>
<h2 id='reScale'>Re-Scale results of 'VCA' or 'VCAinference'</h2><span id='topic+reScale'></span>

<h3>Description</h3>

<p>Function adjusts variance components (VC) and standard deviations (SD) and their respective
confidence intervals of 'VCAinference' objects, and the 'VCAobj' sub-element. For 'VCA' objects
the VC and SD values are adjusted as well as the fixed and random effects and the covariance-matrix
of fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reScale(obj, VarVC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reScale_+3A_obj">obj</code></td>
<td>
<p>(object) either of class 'VCA' or 'VCAinference'</p>
</td></tr>
<tr><td><code id="reScale_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = variance-covariance matrix of the fitted model 'obj'
will be computed and automatically re-scaled, FALSE = variance-covariance
matrix will not be computed and re-scaled. This might cause wrong results
in downstream analyses which require this matrix on the correct scale! Only
use this option if computation time really matters!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(object) either of class 'VCA' or 'VCAinference', where results have been 
transformed back to the original scale of the response variable
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Scale">Scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_3)

# reference values
fit0 &lt;- anovaVCA(y~day/run, dataEP05A2_3, MME=TRUE)
inf0 &lt;- VCAinference(fit0, VarVC=TRUE)

fit1 &lt;- Scale("anovaVCA", y~day/run, dataEP05A2_3, MME=TRUE)
inf1 &lt;- VCAinference(fit1, VarVC=TRUE)
inf1 &lt;- reScale(inf1)

# compare to reference
print(inf0, what="VC")
print(inf1, what="VC")
print(inf0, what="SD")
print(inf1, what="SD")
print(inf0, what="CV")
print(inf1, what="CV")

# now use REML-based estimation
fit0 &lt;- remlVCA(y~day/run, dataEP05A2_3)
inf0 &lt;- VCAinference(fit0)

fit1 &lt;- Scale("remlVCA", y~day/run, dataEP05A2_3, MME=TRUE)
inf1 &lt;- VCAinference(fit1)
inf1 &lt;- reScale(inf1)

# compare to reference
print(inf0, what="VC")
print(inf1, what="VC")
print(inf0, what="SD")
print(inf1, what="SD")
print(inf0, what="CV")
print(inf1, what="CV")

## End(Not run)
</code></pre>

<hr>
<h2 id='residuals.VCA'>Extract Residuals of a 'VCA' Object</h2><span id='topic+residuals.VCA'></span><span id='topic+resid'></span>

<h3>Description</h3>

<p>Function extracts marginal or conditional residuals from a 'VCA' object, 
representing a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
residuals(
  object,
  type = c("conditional", "marginal"),
  mode = c("raw", "student", "standard", "pearson"),
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="residuals.VCA_+3A_type">type</code></td>
<td>
<p>(character) string specifying the type of residuals to be returned,
valid options are &quot;marginal&quot; and &quot;conditional&quot; or abbreviations</p>
</td></tr>
<tr><td><code id="residuals.VCA_+3A_mode">mode</code></td>
<td>
<p>(character) string or abbreviation specifying the specific transformation
applied to a certain type of residuals. There are &quot;raw&quot; (untransformed), 
&quot;standardized&quot;, &quot;studentized&quot; and &quot;pearson&quot; (see details) residuals.</p>
</td></tr>
<tr><td><code id="residuals.VCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="residuals.VCA_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two types of residuals which can be extraced from a 'VCA' object.
Marginal residuals correspond to <code class="reqn">e_m = y - \hat{y}</code>, where <code class="reqn">\hat{y} = Xb</code> with <code class="reqn">X</code>
being the design matrix of fixed effects and <code class="reqn">b</code> being the column vector of fixed
effects parameter estimates. Conditional residuals are defined as <code class="reqn">e_c = y - Xb - Zg</code>,
where <code class="reqn">Z</code> corresponds to the designs matrix of random effects <code class="reqn">g</code>. 
Whenever 'obj' is a pure-error model, e.g. 'y~1' both options will return the same values 
<code class="reqn">y - Xb</code> and <code class="reqn">b</code> corresponds to the intercept.
Each type of residuals can be standardized, studentized, or transformed to pearson-type residuals. 
The former corresponds to a transformation of residuals to have mean 0 and variance equal to 1 (<code class="reqn">(r - \bar{r})/\sigma_{r}</code>). 
Studentized residuals emerge from dividing raw residuals by the square-root of diagonal elements of the corresponding 
variance-covariance matrix. For conditional residuals, this is <code class="reqn">Var(c) = P = RQR</code>, with <code class="reqn">Q = V^{-1}(I - H)</code>,
<code class="reqn">H = XT</code> being the hat-matrix, and <code class="reqn">T = (X^{T}V^{-1}X)^{-1}X^{T}V^{-1}</code>. For marginal residuals, this matrix
is <code class="reqn">Var(m) = O = V - Q</code>. Here, &gt;<code class="reqn">^{T}</code>&lt; denotes the matrix transpose operator, 
and &gt;<code class="reqn">^{-1}</code>&lt; the regular matrix inverse. Pearson-type residuals are computed in the same manner as studentized, only
the variance-covariance matrices differ. For marginal residuals this is equal to <code class="reqn">Var(y) = V</code>, for conditional residuals
this is <code class="reqn">Var(c) = R</code> (see <code><a href="#topic+getV">getV</a></code> for details).
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Hilden-Minton, J. A. (1995). Multilevel diagnostics for mixed and hierarchical linear
models. Dissertation, University of California, Los Angeles.
</p>
<p>Nobre, J. S. &amp; Singer, J. M. (2007). Residual analysis for linear mixed models. Biometrical
Journal, 49, 863-875.
</p>
<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef">ranef</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>, <code><a href="#topic+anovaMM">anovaMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(VCAdata1)
datS1 &lt;- VCAdata1[VCAdata1$sample==1,]
fit1  &lt;- anovaVCA(y~(lot+device)/(day)/(run), datS1) 

# default is conditional (raw) residuals
resid(fit1)
resid(fit1, "m")

# get standardized version
resid(fit1, mode="stand")		# conditional residuals (default)
resid(fit1, "marg", "stand")		# marginal residuals

# get studentized version, taking their 
# covariances into account
resid(fit1, mode="stud")		# conditional residuals (default)
resid(fit1, "marg", "stud")		# marginal residuals

## End(Not run)

</code></pre>

<hr>
<h2 id='SattDF'>Satterthwaite Approximation for Total Degrees of Freedom and for Single Variance Components</h2><span id='topic+SattDF'></span>

<h3>Description</h3>

<p>This function estimates degrees of freedom of the total variance (type=&quot;total&quot;)
in random models or individual variance components (type=&quot;individual&quot;). 
It bases on the results of the unified approach to ANOVA-type estimation 
of variance components as implemented in functions <code><a href="#topic+anovaVCA">anovaVCA</a></code> 
and <code><a href="#topic+anovaMM">anovaMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SattDF(MS, Ci, DF, type = c("total", "individual"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SattDF_+3A_ms">MS</code></td>
<td>
<p>(numeric) vector of sequential mean squares (ANOVA type-1).</p>
</td></tr>
<tr><td><code id="SattDF_+3A_ci">Ci</code></td>
<td>
<p>(matrix) where elements are numeric values representing the inverse of the coefficient
matrix for calculation of expected mean squares (see <code><a href="#topic+anovaVCA">anovaVCA</a></code>).</p>
</td></tr>
<tr><td><code id="SattDF_+3A_df">DF</code></td>
<td>
<p>(numeric) vector with the degrees of freedom for each factor in a ANOVA type-1 model.</p>
</td></tr>
<tr><td><code id="SattDF_+3A_type">type</code></td>
<td>
<p>(character) string specifying whether &quot;total&quot; degrees of freedom should be approximated or those of
individual variance components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is used internally, thus, it is not exported. Option 'type=&quot;total&quot;' is used in 
functions <code><a href="#topic+anovaVCA">anovaVCA</a></code> and <code><a href="#topic+anovaMM">anovaMM</a></code> for approximating total DF.
Option 'type=&quot;individual&quot;' is used in function <code><a href="#topic+VCAinference">VCAinference</a></code> when choosing
'ci.method=&quot;satterthwaite&quot;' for approximating DFs for individual variance components.
</p>


<h3>Value</h3>

<p>numeric value representing the Satterthwaite DFs of the total variance.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(dataEP05A2_2)
res &lt;- anovaVCA(y~day/run, dataEP05A2_2)
VCA:::SattDF(res$aov.tab[-1,"MS"], getMat(res, "Ci.MS"), res$aov.tab[-1,"DF"], type="tot")

# now approximating individual DF for variance components
VCA:::SattDF(res$aov.tab[-1,"MS"], getMat(res, "Ci.MS"), res$aov.tab[-1,"DF"], type="i")

## End(Not run)
</code></pre>

<hr>
<h2 id='Scale'>Automatically Scale Data Calling these Functions: 'anovaVCA', 'anovaMM', 'remlVCA' or 'remlMM'</h2><span id='topic+Scale'></span>

<h3>Description</h3>

<p>This function scales data before fitting a linear mixed model aiming to avoid numerical problems
when numbers of the response variable are either very small or very large. It adds attribute &quot;scale&quot; 
to the resulting 'VCA'-object, which is used by function <code><a href="#topic+reScale">reScale</a></code> to transform back the
VCA-results of a <code>VCA</code> or <code>VCAinference</code> object that was previously scaled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Scale(Fun, form, Data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scale_+3A_fun">Fun</code></td>
<td>
<p>(expr, function, character) either a complete function call to one of &quot;anovaVCA&quot;, &quot;anovaMM&quot;, &quot;remlVCA&quot;, &quot;remlMM&quot;,
a character string or just the function name without quotes (see example)</p>
</td></tr>
<tr><td><code id="Scale_+3A_form">form</code></td>
<td>
<p>(formula) specifying the model to fitted by 'Fun'</p>
</td></tr>
<tr><td><code id="Scale_+3A_data">Data</code></td>
<td>
<p>(data.frame) with all variables specified via 'Fun'</p>
</td></tr>
<tr><td><code id="Scale_+3A_...">...</code></td>
<td>
<p>additional arguments applying to one of the four functions <code><a href="#topic+anovaVCA">anovaVCA</a></code>,<code><a href="#topic+anovaMM">anovaMM</a></code>,
<code><a href="#topic+remlVCA">remlVCA</a></code>, <code><a href="#topic+remlMM">remlMM</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: Scaling is applied on the complete data set, without checking whether there are incomplete
observations or not!
</p>


<h3>Value</h3>

<p>(object) of class 'VCA' which can be used as input for function <code><a href="#topic+VCAinference">VCAinference</a></code>
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reScale">reScale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_3)

# simulate very large numbers of the response
dat3   &lt;- dataEP05A2_3
dat3$y &lt;- dat3$y * 1e8

# now try to fit 21-day model to this data
fit &lt;- anovaVCA(y~day/run, dat3)

# now use 'Scale' function
fit1 &lt;- Scale("anovaVCA", y~day/run, dat3)
fit2 &lt;- Scale(anovaVCA, y~day/run, dat3)	# also works
fit3 &lt;- Scale(anovaVCA(y~day/run, dat3)) # works as well

# back to original scale
(fit1 &lt;- reScale(fit1))
(fit2 &lt;- reScale(fit2))
(fit3 &lt;- reScale(fit3))

# reference values
fit0 &lt;- anovaVCA(y~day/run, dataEP05A2_3, MME=TRUE)
inf0 &lt;- VCAinference(fit0, VarVC=TRUE)

fit1 &lt;- Scale(anovaVCA(y~day/run, dataEP05A2_3, MME=TRUE))
inf1 &lt;- VCAinference(fit1, VarVC=TRUE)
inf1 &lt;- reScale(inf1)

# compare to reference
print(inf0, what="VC")
print(inf1, what="VC")
print(inf0, what="SD")
print(inf1, what="SD")
print(inf0, what="CV")
print(inf1, what="CV")

# now use REML-based estimation
fit0 &lt;- remlVCA(y~day/run, dataEP05A2_3)
inf0 &lt;- VCAinference(fit0)

fit1 &lt;- Scale("remlVCA", y~day/run, dataEP05A2_3)
inf1 &lt;- VCAinference(fit1)
inf1 &lt;- reScale(inf1)

# compare to reference
print(inf0, what="VC")
print(inf1, what="VC")
print(inf0, what="SD")
print(inf1, what="SD")
print(inf0, what="CV")
print(inf1, what="CV")

# scaling also works with by-processing
data(VCAdata1)
fit &lt;- Scale(anovaVCA(y~(device+lot)/day/run, VCAdata1, by="sample"))
reScale(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='scaleData'>Scale Response Variable to Ensure Robust Numerical Calculations</h2><span id='topic+scaleData'></span>

<h3>Description</h3>

<p>Function determines scaling factor for transforming the mean of the response to a range
between 0.1 and 1, applies scaling of the response and binds the scaling factor to the 
data as attribute 'scale'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleData(Data = NULL, resp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleData_+3A_data">Data</code></td>
<td>
<p>(data.frame) with the data to be fitted and the response to be scaled</p>
</td></tr>
<tr><td><code id="scaleData_+3A_resp">resp</code></td>
<td>
<p>(character) name of the (numeric) response variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(data.frame) with the response scaled according to the scaling-factor,
which is recorded in the attribute <code>scale</code> of the data set
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmester@roche.com">andre.schuetzenmester@roche.com</a>
</p>

<hr>
<h2 id='sleepstudy'>sleepstudy dataset from R-package 'lme4'</h2><span id='topic+sleepstudy'></span>

<h3>Description</h3>

<p>The average reaction time per day for subjects in a sleep deprivation study. 
On day 0 the subjects had their normal amount of sleep. Starting that night 
they were restricted to 3 hours of sleep per night. The observations represent 
the average reaction time on a series of tests given each day to each subject. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sleepstudy)</code></pre>


<h3>Format</h3>

<p>A data frame with 180 observations on the following 3 variables.
</p>

<ul>
<li><p> Reaction<br /><br />
Average reaction time (ms)<br /><br />
</p>
</li>
<li><p> Days<br /><br />
Number of days of sleep deprivation<br /><br />
</p>
</li>
<li><p> Subject<br /><br />
Subject number on which the observation was made.<br />
</p>
</li></ul>


<h3>References</h3>

<p>Gregory Belenky, Nancy J. Wesensten, David R. Thorne, Maria L. Thomas, 
Helen C. Sing, Daniel P. Redmond, Michael B. Russo and Thomas J. Balkin (2003) 
Patterns of performance degradation and restoration during sleep restriction and 
subsequent recovery: a sleep dose-response study. Journal of Sleep Research 12, 1-12.
</p>

<hr>
<h2 id='Solve'>Solve System of Linear Equations using Inverse of Cholesky-Root</h2><span id='topic+Solve'></span>

<h3>Description</h3>

<p>Function solves a system of linear equations, respectively, inverts a matrix
by means of the inverse Cholesky-root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Solve(X, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Solve_+3A_x">X</code></td>
<td>
<p>(matrix, Matrix) object to be inverted</p>
</td></tr>
<tr><td><code id="Solve_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to reduce the computational time in function
<code><a href="#topic+solveMME">solveMME</a></code> which computes the inverse of the square variance-
covariance Matrix of observations. It is considerably faster than function
<code><a href="base.html#topic+solve">solve</a></code> (see example).
Whenever an error occurs, which is the case for non positive definite matrices
'X', function <code><a href="#topic+MPinv">MPinv</a></code> is called automatically yielding a generalized
inverse (Moore-Penrose inverse) of 'X'.
</p>


<h3>Value</h3>

<p>(matrix, Matrix) corresponding to the inverse of X
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# following complex (nonsense) model takes pretty long to fit
system.time(res.sw &lt;- anovaVCA(y~(sample+lot+device)/day/run, VCAdata1))
# solve mixed model equations (not automatically done to be more efficient)
system.time(res.sw &lt;- solveMME(res.sw))
# extract covariance matrix of observations V
V1 &lt;- getMat(res.sw, "V")
V2 &lt;- as.matrix(V1)
system.time(V2i &lt;- solve(V2))
system.time(V1i &lt;- VCA:::Solve(V1))
V1i &lt;- as.matrix(V1i)
dimnames(V1i) &lt;- NULL
dimnames(V2i) &lt;- NULL
all.equal(V1i, V2i)

## End(Not run) 
</code></pre>

<hr>
<h2 id='solveMME'>Solve Mixed Model Equations</h2><span id='topic+solveMME'></span>

<h3>Description</h3>

<p>Function solves the Mixed Model Equations (MME) to estimate fixed and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveMME(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveMME_+3A_obj">obj</code></td>
<td>
<p>... (VCA) object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for internal use only, thus, not exported.
</p>


<h3>Value</h3>

<p>(VCA) object, which has additional elements &quot;RandomEffects&quot; corresponding to the column vector 
of estimated random effects, &quot;FixedEffects&quot; being the column vector of estimated fixed effects. 
Element &quot;Matrices&quot; has additional elements referring to the elements of the MMEs and element
&quot;VarFixed&quot; corresponds to the variance-covariance matrix of fixed effects.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1, NegVC=TRUE)
fit &lt;- solveMME(fit)
ranef(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='stepwiseVCA'>Bottom-Up Step-Wise VCA-Analysis of the Complete Dataset</h2><span id='topic+stepwiseVCA'></span>

<h3>Description</h3>

<p>Function performs step-wise VCA-analysis on a fitted VCA-object by leaving out N-1 to 0
top-level variance components (VC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwiseVCA(obj, VarVC.method = c("scm", "gb"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwiseVCA_+3A_obj">obj</code></td>
<td>
<p>(VCA) object representing the complete analysis</p>
</td></tr>
<tr><td><code id="stepwiseVCA_+3A_varvc.method">VarVC.method</code></td>
<td>
<p>(character) string specifying the algorithm to be used for estimating variance-covariance matrix
of VCs (see <code><a href="#topic+anovaMM">anovaMM</a></code> for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the complete data to quantify sub-sets of variance components.
In each step the current total variance is estimated by subtracting the sum of all left-out VCs
from the total variance of the initial VCA object. Doing this guarantees that the contribution to the total 
variance which is due to left-out VCs is accounted for, i.e. it is estimated but not included/reported.
The degrees of freedom (DFs) of the emerging total variances of sub-sets are determined using the Satterthwaite
approximation. This is achieved by extracting the corresponding sub-matrix from the coefficient matrix <code class="reqn">C</code> of
the 'VCA' object, the sub-vector of ANOVA mean squares, and the sub-vector of degrees of freedom and calling
function <code><a href="#topic+SattDF">SattDF</a></code> method=&quot;total&quot;.
</p>
<p>This step-wise procedure starts one-level above error (repeatability) and ends at the level of the upper-most VC.
It can only be used on models fitted by ANOVA Type-1, i.e. by function <code><a href="#topic+anovaVCA">anovaVCA</a></code>.
</p>


<h3>Value</h3>

<p>(list) of (simplified) 'VCA' objects representing analysis-result of sub-models
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(VCAdata1)
datS7L1 &lt;- VCAdata1[VCAdata1$sample == 7 &amp; VCAdata1$lot == 1, ]
fit0 &lt;- anovaVCA(y~device/day/run, datS7L1, MME=TRUE)

# complete VCA-analysis result
fit0

# perform step-wise (bottom-up) VCA-analyses
sw.res &lt;- stepwiseVCA(fit0)
sw.res

# get CIs on intermediate precision 
VCAinference(sw.res[["device:day"]])

## End(Not run)
</code></pre>

<hr>
<h2 id='summarize.VCA'>Summarize Outcome of a Variance Component Analysis.</h2><span id='topic+summarize.VCA'></span><span id='topic+summarize.VCAinference'></span>

<h3>Description</h3>

<p>If a single 'VCA'-object is passed, the first step is to call 'VCAinference' for CI
estimation. For each variance component (VC) the result of the VCA is summarized
and can be configured by arguments 'type', 'tail', 'ends', and 'conf.level'. These
define which information is returned by this summary function. In case of passing
a list of 'VCA'- or 'VCAinference'-objects, a matrix will be returned where columns
correspond to list-elements, usually samples, and rows to estimated values. This is 
done as the number of estimated values usually exceeds the number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize.VCA(
  object,
  type = c("sd", "cv"),
  tail = "one-sided",
  ends = "upper",
  conf.level = 0.95,
  DF = TRUE,
  as.df = FALSE,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize.VCA_+3A_object">object</code></td>
<td>
<p>(object) of class <code>VCA</code> or <code>VCAinference</code> or a list of
these objects to be summarized.</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_type">type</code></td>
<td>
<p>(character) &quot;sd&quot; for standard devation, &quot;cv&quot; for coefficient of 
variation, and &quot;vc&quot; for variance defining on which scale results
shall be returned. Multiple can be specified.</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_tail">tail</code></td>
<td>
<p>(character) &quot;one-sided&quot; for one-sided CI, &quot;two-sided&quot; for two-sided CI,
can be abbreviated</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_ends">ends</code></td>
<td>
<p>(character) &quot;upper&quot; or &quot;lower&quot; bounds of a e.g. 95% CI, can be both</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_conf.level">conf.level</code></td>
<td>
<p>(numeric) confidence level of the CI</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_df">DF</code></td>
<td>
<p>(logical) TRUE to include degrees of freedom, FALSE to omit them</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_as.df">as.df</code></td>
<td>
<p>(logical) TRUE to transpose the returned object and convert into
a data.frame, FALSE leve</p>
</td></tr>
<tr><td><code id="summarize.VCA_+3A_print">print</code></td>
<td>
<p>(logical) TRUE print summary, FALSE omit printing and just return
matrix or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(matrix, data.frame) with VCA-results either with estimates in rows and sample(s)
in columns, or vice versa
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CA19_9)
fit.all &lt;- anovaVCA(result~site/day, CA19_9, by="sample")
summarize.VCA(fit.all)
# complete set of results
summarize.VCA(	fit.all, type=c("vc", "sd", "cv"), tail=c("one", "two"),
				ends=c("lower", "upper"))
# summarizing a single VCA-object
summarize.VCA(fit.all[[1]])

### summarizing list of 'VCAinference' objects
infs &lt;- VCAinference(fit.all)
summarize.VCAinference(infs)

## End(Not run)
</code></pre>

<hr>
<h2 id='test.fixef'>Perform t-Tests for Linear Contrasts on Fixed Effects</h2><span id='topic+test.fixef'></span>

<h3>Description</h3>

<p>This function performs t-Tests for one or multiple linear combinations (contrasts) of estimated 
fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.fixef(
  obj,
  L,
  ddfm = c("contain", "residual", "satterthwaite"),
  method.grad = "simple",
  tol = 1e-12,
  quiet = FALSE,
  opt = TRUE,
  onlyDF = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.fixef_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_l">L</code></td>
<td>
<p>(numeric) vector or matrix, specifying linear combinations of the fixed effects, in the latter case,
each line represents a disctinct linear contrast</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_ddfm">ddfm</code></td>
<td>
<p>(character) string specifying the method used for computing the denominator
degrees of freedom for tests of fixed effects or LS Means. Available methods are
&quot;contain&quot;, &quot;residual&quot;, and &quot;satterthwaite&quot;.</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_method.grad">method.grad</code></td>
<td>
<p>(character) string specifying the method to be used for approximating the gradient
of the variance-covariance matrix of fixed effects at the estimated covariance parameter
estimates (see function 'grad' (numDeriv) for details)</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_tol">tol</code></td>
<td>
<p>(numeric) value specifying the numeric tolerance for testing equality to zero</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = suppress warning messages, e.g. for non-estimable contrasts</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_opt">opt</code></td>
<td>
<p>(logical) TRUE = tries to optimize computation time by avoiding unnecessary computations
for balanced datasets (see details).</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_onlydf">onlyDF</code></td>
<td>
<p>(logical) TRUE = only the specified type of degrees of freedom are determined without carrying out
the actual hypothesis test(s)</p>
</td></tr>
<tr><td><code id="test.fixef_+3A_...">...</code></td>
<td>
<p>further parameters (for internal use actually)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here, the same procedure as in <code>SAS PROC MIXED ddfm=satterthwaite</code> (sat) is implemented. 
This implementation was inspired by the code of function 'calcSatterth' of R-package 'lmerTest'. 
Thanks to the authors for this nice implementation. <br />
Note, that approximated Satterthwaite degrees of freedom might differ from 'lmerTest' and SAS PROC MIXED.
Both use the inverse Fisher-information matrix as approximation of the variance-covariance matrix
of variance components (covariance parameters). Here, either the exact algorithm for ANOVA-estimators of
variance components, described in Searle et. al (1992) p. 176, or the approximation presented in Giesbrecht and 
Burns (19985) are used. For balanced designs their will be no differences, usually. 
In case of balanced designs, the Satterthwaite approximation is equal to the degrees of freedom of the highest
order random term in the model (see examples).
</p>


<h3>Value</h3>

<p>(numeric) vector or matrix with 4 elements/columns corresponding to &quot;Estimate&quot;, &quot;t Value&quot;, &quot;DF&quot;, and
&quot;Pr &gt; |t|&quot;.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a> inspired by authors of R-package 'lmerTest'
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York	
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>
<p>SAS Help and Documentation PROC MIXED (MODEL-statement, Option 'ddfm'), SAS Institute Inc., Cary, NC, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.lsmeans">test.lsmeans</a></code>, <code><a href="#topic+getL">getL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_2)
ub.dat &lt;- dataEP05A2_2[-c(11,12,23,32,40,41,42),]
fit1 &lt;- anovaMM(y~day/(run), ub.dat)
fit2 &lt;- remlMM(y~day/(run), ub.dat)
fe1 &lt;- fixef(fit1)
fe1
fe2 &lt;- fixef(fit2)
fe2
lc.mat &lt;- getL( fit1, c("day1-day2", "day3-day6"))
lc.mat
test.fixef(fit1, lc.mat, ddfm="satt") 
test.fixef(fit2, lc.mat, ddfm="satt")

# some inferential statistics about fixed effects estimates
L &lt;- diag(nrow(fe1))
rownames(L) &lt;- colnames(L) &lt;- rownames(fe1)
test.fixef(fit1, L)
test.fixef(fit2, L)

# using different "residual" method determining DFs
test.fixef(fit1, L, ddfm="res")
test.fixef(fit2, L, ddfm="res")  

# having 'opt=TRUE' is a good idea to save time 
# (in case of balanced designs)
data(VCAdata1)
datS3 &lt;- VCAdata1[VCAdata1$sample==3,]
fit3 &lt;- anovaMM(y~(lot+device)/(day)/run, datS3)
fit4 &lt;- remlMM(y~(lot+device)/(day)/run, datS3)  
fit3$VarCov &lt;- vcovVC(fit3)
fe3 &lt;- fixef(fit3)
fe4 &lt;- fixef(fit4)
L &lt;- diag(nrow(fe3))
rownames(L) &lt;- colnames(L) &lt;- rownames(fe3)
system.time(tst1 &lt;- test.fixef(fit3, L))
system.time(tst2 &lt;- test.fixef(fit3, L, opt=FALSE))
system.time(tst3 &lt;- test.fixef(fit4, L, opt=FALSE))
tst1
tst2
tst3

## End(Not run)
</code></pre>

<hr>
<h2 id='test.lsmeans'>Perform t-Tests for Linear Contrasts on LS Means</h2><span id='topic+test.lsmeans'></span>

<h3>Description</h3>

<p>Perform custom hypothesis tests on Least Squares Means (LS Means) of fixed effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.lsmeans(
  obj,
  L,
  ddfm = c("contain", "residual", "satterthwaite"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.lsmeans_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="test.lsmeans_+3A_l">L</code></td>
<td>
<p>(matrix) specifying one or multiple custom hypothesis tests as linear contrasts of LS Means.
Which LS Means have to be used is inferred from the column names of matrix <code class="reqn">L</code>, which need to 
be in line with the naming of LS Means in function <code><a href="#topic+lsmeans">lsmeans</a></code>.</p>
</td></tr>
<tr><td><code id="test.lsmeans_+3A_ddfm">ddfm</code></td>
<td>
<p>(character) string specifying the method used for computing the denominator
degrees of freedom of t-tests of LS Means. Available methods are &quot;contain&quot;, 
&quot;residual&quot;, and &quot;satterthwaite&quot;.</p>
</td></tr>
<tr><td><code id="test.lsmeans_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to function <code><a href="#topic+test.fixef">test.fixef</a></code> and represents a convenient way of specifying
linear contrasts of LS Means.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.fixef">test.fixef</a></code>, <code><a href="#topic+lsmeans">lsmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_2)
ub.dat &lt;- dataEP05A2_2[-c(11,12,23,32,40,41,42),]
fit1 &lt;- anovaMM(y~day/(run), ub.dat)
fit2 &lt;- remlMM(y~day/(run), ub.dat)
lsm1 &lt;- lsmeans(fit1)
lsm2 &lt;- lsmeans(fit2)
lsm1
lsm2

lc.mat &lt;- getL(fit1, c("day1-day2", "day3-day6"), "lsm")
lc.mat[1,c(1,2)] &lt;- c(1,-1)
lc.mat[2,c(3,6)] &lt;- c(1,-1)
lc.mat
test.lsmeans(fit1, lc.mat) 
test.lsmeans(fit2, lc.mat)

# fit mixed model from the 'nlme' package

library(nlme)
data(Orthodont)
fit.lme &lt;- lme(distance~Sex*I(age-11), random=~I(age-11)|Subject, Orthodont) 

# re-organize data for using 'anovaMM'
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))

# model without intercept
fit.anovaMM &lt;- anovaMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)
fit.remlMM1 &lt;- remlMM( distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)
fit.remlMM2 &lt;- remlMM( distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho, cov=FALSE)
lsm0 &lt;- lsmeans(fit.anovaMM)
lsm1 &lt;- lsmeans(fit.remlMM1)
lsm2 &lt;- lsmeans(fit.remlMM2)
lsm0
lsm1
lsm2

lc.mat &lt;- matrix(c(1,-1), nrow=1, dimnames=list("int.Male-int.Female", c("SexMale", "SexFemale")))
lc.mat
test.lsmeans(fit.anovaMM, lc.mat)	
test.lsmeans(fit.remlMM1, lc.mat)
test.lsmeans(fit.remlMM2, lc.mat)

## End(Not run)	
</code></pre>

<hr>
<h2 id='Trace'>Compute the Trace of a Matrix</h2><span id='topic+Trace'></span>

<h3>Description</h3>

<p>Function computes the sum of main-diagonal elements of a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trace(x, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trace_+3A_x">x</code></td>
<td>
<p>(matrix, Matrix) object</p>
</td></tr>
<tr><td><code id="Trace_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) value, the trace of the matrix
</p>

<hr>
<h2 id='varPlot'>Variability Chart for Hierarchical Models.</h2><span id='topic+varPlot'></span>

<h3>Description</h3>

<p>Function <code>varPlot</code> determines the sequence of variables in the model formula and uses this information to construct
the variability chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varPlot(
  form,
  Data,
  keep.order = TRUE,
  type = c(1L, 2L, 3L)[1],
  VARtype = "SD",
  htab = 0.5,
  Title = NULL,
  VSpace = NULL,
  VarLab = list(cex = 0.75, adj = c(0.5, 0.5)),
  YLabel = list(text = "Value", side = 2, line = 3.5, cex = 1.5),
  SDYLabel = list(side = 2, line = 2.5),
  Points = list(pch = 16, cex = 0.5, col = "black"),
  SDs = list(pch = 16, col = "blue", cex = 0.75),
  SDline = list(lwd = 1, lty = 1, col = "blue"),
  BG = list(border = "lightgray", col.table = FALSE),
  VLine = list(lty = 1, lwd = 1, col = "gray90"),
  HLine = NULL,
  Join = list(lty = 1, lwd = 1, col = "gray"),
  JoinLevels = NULL,
  Mean = list(pch = 3, col = "red", cex = 0.5),
  MeanLine = NULL,
  Boxplot = NULL,
  VCnam = list(cex = 0.75, col = "black", line = 0.25),
  useVarNam = FALSE,
  ylim = NULL,
  max.level = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varPlot_+3A_form">form</code></td>
<td>
<p>(formula) object specifying the model, NOTE: any crossed factors are reduced to last term of the crossing structure, i.e.
&quot;a:b&quot; is reduced to &quot;b&quot;, &quot;a:b:c&quot; is reduced to &quot;c&quot;.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_data">Data</code></td>
<td>
<p>(data.frame) with the data</p>
</td></tr>
<tr><td><code id="varPlot_+3A_keep.order">keep.order</code></td>
<td>
<p>(logical) TRUE = the ordering of factor-levels is kept as provided by 'Data', FALSE = factor-levels are sorted on 
and within each level of nesting.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_type">type</code></td>
<td>
<p>(integer) specifying the type of plot to be used, options are 1 = regular scatterplot, 2 = plot of the standard deviation,
3 = both type of plots.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_vartype">VARtype</code></td>
<td>
<p>(character) either &quot;SD&quot; (standard deviation) or &quot;CV&quot; (coefficient of variation), controls which type of measures is used to
report variability in plots when 'type' is set to either 2 or  (see 'type' above). Note that all parameters which apply to
the SD-plot will be used for the CV-plot in case 'VARtype=&quot;CV&quot;'.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_htab">htab</code></td>
<td>
<p>(numeric) value 0 &lt; htab &lt; 1 specifying the height of the table representing the experimental design. This value represents
the proportion in relation to the actual plotting area, i.e. htab=1 mean 50% of the vertical space is reserved for the table.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_title">Title</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+title">title</a></code> for printing main- or sub-titles to plots. If 'type==3',
these settings will apply to each plot. For individual settings specify a list with two elements, where each element is a
list itself specifying all parameters of function 'title'. The first one is used for the variability chart, 
the second one for the SD or CV plot. Set to NULL to omit any titles.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_vspace">VSpace</code></td>
<td>
<p>(numeric) vector of the same length as there are variance components, specifying the proportion of vertical space assigned
to each variance component in the tabular indicating the model structure. These elements have to sum to 1, otherwise equal
sizes will be used for each VC.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_varlab">VarLab</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+text">text</a></code>, used to add labels within the table environment refering
to the nesting structure. This can be a list of lists, where the i-th list corresponds to the i-th variance component, counted
in bottom-up direction, i.e. starting from the most general variance component ('day' in the 1st example).</p>
</td></tr>
<tr><td><code id="varPlot_+3A_ylabel">YLabel</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+mtext">mtext</a></code>, used for labelling the Y-axis.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_sdylabel">SDYLabel</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+mtext">mtext</a></code>, used for labelling the Y-axis.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_points">Points</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+points">points</a></code>, used to specify scatterplots per lower-end factor-level
(e.g. 'run' in formula run/day). If list-elements &quot;col&quot;, &quot;pch&quot;, &quot;bg&quot; and &quot;cex&quot; are lists themselves with elements &quot;var&quot; and &quot;col&quot;/&quot;pch&quot;/&quot;bg&quot;/&quot;cex&quot;, 
where the former specifies a variable used for assigning colors/symbols/backgrounds/sizes according to the class-level of
variable &quot;var&quot;, point-colors/plotting-symbols/plotting-symbol backgrounds/plotting-symbol sizes can be used for indicating
specific sub-classes not addressed by the model/design or indicate any sort of information (see examples).
Note the i-th element of 'col'/'pch' refers of the i-th element of unique(Data$var), even if 'var' is an integer variable.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_sds">SDs</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+points">points</a></code>, used to specify the appearance of SD-plots.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_sdline">SDline</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+lines">lines</a></code>, used to specify the (optional) line joining individual SDs,
Set to NULL to omit.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_bg">BG</code></td>
<td>
<p>(list) specifying the background for factor-levels of a nested factor. This list is passed on to function <code><a href="graphics.html#topic+rect">rect</a></code> after element
'var', which identifies the factor to be used for coloring, has been removed. If not set to NULL and no factor has been specified by the
user, the top-level factor is selected by default. If this list contains element 'col.table=TRUE', the same coloring schema is used
in the table below at the corresponding row/factor (see examples). Addionally, list-elment 'col.bg=FALSE' can be used to turn off
BG-coloring, e.g. if only the the respective row in the table below should be color-coded (defaults to 'col.bg=TRUE').
When specifying as many colors as there are factor-levels, the same color will be applied to a factor-level automatically. 
This is relevant for factors, which are not top-level (bottom in the table).
Example: BG=list(var=&quot;run&quot;, col=c(&quot;white&quot;, &quot;lightgray&quot;), border=NA) draws the background for alternating levels of factor &quot;run&quot; 
white and gray for better visual differentiation. Set to NULL to omit. Use list( ..., col=&quot;white&quot;, border=&quot;gray&quot;) for using gray 
vertical lines for separation. See argument 'VLine' for additional highlighting options of factor-levels.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_vline">VLine</code></td>
<td>
<p>(list) specifying all parameters applicable in <code><a href="graphics.html#topic+lines">lines</a></code> optionally separating levels of one or multiple variables
as vertical lines. This is useful in addition to 'BG' (see examples), where automatically 'border=NA' will be set that 'VLine' will
take full effect. If this list contains element 'col.table=TRUE', vertical lines will be extended to the table below the plot.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_hline">HLine</code></td>
<td>
<p>(list) specifying all parameters applicable in function <code><a href="graphics.html#topic+abline">abline</a></code> to add horizontal lines. Only horizontal lines can be
set specifying the 'h' parameter. 'HLine=list()' will use default settings. 'HLine=NULL' will omit horizontal lines.
In case 'type=3', two separate lists can be specified where the first list applies to the variability chart and the second list
to the SD-/CV-chart.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_join">Join</code></td>
<td>
<p>(list) specifying all parameter applicable in function <code><a href="graphics.html#topic+lines">lines</a></code> controlling how observed values within lower-level factor-levels,
are joined. Set to NULL to omit.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_joinlevels">JoinLevels</code></td>
<td>
<p>(list) specifying all arguments applicable in function <code><a href="graphics.html#topic+lines">lines</a></code>, joining factor-levels nested within higher order factor levels,
list-element &quot;var&quot; specifies this variable</p>
</td></tr>
<tr><td><code id="varPlot_+3A_mean">Mean</code></td>
<td>
<p>(list) passed to function <code><a href="graphics.html#topic+points">points</a></code> specifying plotting symbols used to indicate mean values per lower-level factor-level, 
set equal to NULL to omit.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_meanline">MeanLine</code></td>
<td>
<p>(list) passed to function <code><a href="graphics.html#topic+lines">lines</a></code> specifying the appearance of horizontal lines indicating mean values of factor levels. 
The factor variable for which mean-values of factor-levels are plotted can be specified via list-element &quot;var&quot; accepting any factor 
variable specified in 'form'. List element &quot;mar&quot; takes values in [0;.5] setting the left and right margin size of mean-lines.
Set equal to NULL to omit. Use 'var=&quot;int&quot;' for specifying the overall mean (grand mean, intercept).
If this list contains logical 'join' which is set to TRUE, these mean lines will be joined. If list-element &quot;top&quot; is set to TRUE, 
these lines will be plotted on top, which is particularily useful for very large datasets.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_boxplot">Boxplot</code></td>
<td>
<p>(list) if not NULL, a boxplot of all values within the smallest possible subgroup (replicates) will be added to the plot,
On can set list-elements 'col.box=&quot;gray65&quot;', 'col.median=&quot;white&quot;', 'col.whiskers=&quot;gray65&quot;' specifying different colors and 'lwd=3'
for the line width of the median-line and whiskers-lines as well as 'jitter=1e3' controlling the jittering of points around the
center of the box in horizontal direction, smallest possible value is 5 meaning the largest amount of jittering (1/5 in both directions)
value is)</p>
</td></tr>
<tr><td><code id="varPlot_+3A_vcnam">VCnam</code></td>
<td>
<p>(list) specifying the text-labels (names of variance components) appearing as axis-labels. These parameters are passed to function
<code><a href="graphics.html#topic+mtext">mtext</a></code>. Parameter 'side' can only be set to 2 (left) or 4 (right) controlling where names of variance components appear. 
Set to NULL to omit VC-names.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_usevarnam">useVarNam</code></td>
<td>
<p>(logical) TRUE = each factor-level specifier is pasted to the variable name of the current variable and used as list-element name, 
FALSE = factor-level specifiers are used as names of list-elements; the former is useful when factor levels are indicated
as integers, e.g. days as 1,2,..., the latter is useful when factor levels are already unique, e.g. day1, day2, ... .</p>
</td></tr>
<tr><td><code id="varPlot_+3A_ylim">ylim</code></td>
<td>
<p>(numeric) vector of length two, specifying the limits in Y-direction, if not set these values will be determined automatically.
In case of plot 'type=3' this can also be a list of two ylim-vectors, first corresponding to the variability chart, second to the
plot of error variability per replicate group</p>
</td></tr>
<tr><td><code id="varPlot_+3A_max.level">max.level</code></td>
<td>
<p>(integer) specifying the max. number of levels of a nested factor in order to draw vertical lines. If there are too many levels a black
area will be generated by many vertical lines. Level names will also be omitted.</p>
</td></tr>
<tr><td><code id="varPlot_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed on to function 'par', e.g. use 'mar' for specification of margin widths. Note, that not all of them
will have an effect, because some are fixed ensuring that a variability chart is drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a variability-chart, known from, e.g. JMP (JMP, SAS Institute Inc., Cary, NC). 
Arbitrary models can be specified via parameter 'form'. Formulas will be reduced to a simple hierarchical structure 
ordering factor-variables according to the order of appearance in 'form'. This is done to make function <code>varPlot</code> 
applicable to any random model considered in this package. 
Even if there are main factors, neither one being above or below another main factor, these are forced into a hierachy.
Besides the classic scatterplot, where observations are plotted in sub-classes emerging from the model formula, a plot of
standard deviations (SD) or coefficients of variation (CV) is provided (type=2) or both types of plots together (type=3).
</p>


<h3>Value</h3>

<p>(invisibly) returns 'Data' with additional variable 'Xcoord' giving X-coordinates of each observation
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load data (CLSI EP05-A2 Within-Lab Precision Experiment)
data(dataEP05A2_3)

# two additional classification variables (without real interpretation)
dataEP05A2_3$user &lt;- sample(rep(c(1,2), 40))
dataEP05A2_3$cls2 &lt;- sample(rep(c(1,2), 40))

# plot data as variability-chart, using automatically determined parameter 
# settings (see 'dynParmSet')
varPlot(y~day/run, dataEP05A2_3)

# display intercept (total mean)
varPlot(y~day/run, dataEP05A2_3, MeanLine=list(var="int"))

# use custom VC-names
varPlot(y~day/run, dataEP05A2_3, VCnam=list(text=c("_Day", "_Run")))

# re-plot now also indicating dayly means as blue horizontal lines
varPlot(y~day/run, dataEP05A2_3, MeanLine=list(var=c("day", "int"), col="blue"))

# now use variable-names in names of individual factor-levels and use a different 
# notation of the nesting structure
varPlot(y~day+day:run, dataEP05A2_3, useVarNam=TRUE)

# rotate names of VCs to fit into cells
varPlot(	y~day+day:run, dataEP05A2_3, useVarNam=TRUE, 
			VarLab=list(list(font=2, srt=60), list(srt=90)))

# use alternating backgrounds for each level of factor "day" 
# (top-level factor is default) 
# use a simplified model formula (NOTE: only valid for function 'varPlot')
varPlot(y~day+run, dataEP05A2_3, BG=list(col=c("gray70", "gray90"), border=NA))

# now also color the corresponding row in the table accordingly
varPlot( y~day+run, dataEP05A2_3, 
         BG=list(col=c("gray70", "gray90"), border=NA, col.table=TRUE))

# assign different point-colors according to a classification variable
# not part of the model (artificial example in this case)
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,7), VCnam=list(side=4),
         Points=list(col=list(var="user", col=c("red", "green"))) )

# always check order of factor levels before annotating
order(unique(dataEP05A2_3$user))

# add legend to right margin
legend.m(fill=c("green", "red"), legend=c("User 1", "User 2"))

# assign different plotting symbols according to a classification
# variable not part of the model
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,7), VCnam=list(side=4), 
         Points=list(pch=list(var="user", pch=c(2, 8))) )

# add legend to right margin
legend.m(pch=c(8,2), legend=c("User 1", "User 2"))

# assign custom plotting symbols by combining 'pch' and 'bg'
varPlot( y~day+day:run, dataEP05A2_3, 
         Points=list(pch=list(var="user", pch=c(21, 24)),
                     bg=list( var="user", bg=c("lightblue", "yellow"))) )

# assign custom plotting symbols by combining 'pch', 'bg', and 'cex'      
varPlot( y~day+day:run, dataEP05A2_3,                                    
         Points=list(pch=list(var="user", pch=c(21, 24)),                
                     bg =list(var="user", bg=c("lightblue", "yellow")),
                     cex=list(var="user",  cex=c(2,1))) )

# now combine point-coloring and plotting symbols
# to indicate two additional classification variables
varPlot( y~day+day:run, dataEP05A2_3, mar=c(1,5,1,10), 
         VCnam=list(side=4, cex=1.5),
         Points=list(col=list(var="user", col=c("red", "darkgreen")), 
                     pch=list(var="cls2", pch=c(21, 22)),
                     bg =list(var="user", bg =c("orange", "green"))) )

# add legend to (right) margin
 legend.m( margin="right", pch=c(21, 22, 22, 22), 
           pt.bg=c("white", "white", "orange", "green"), 
           col=c("black", "black", "white", "white"), 
           pt.cex=c(1.75, 1.75, 2, 2), 
           legend=c("Cls2=1", "Cls2=2", "User=2", "User=1"),
           cex=1.5)

# use blue lines between each level of factor "run" 
varPlot(y~day/run, dataEP05A2_3, BG=list(var="run", border="blue"))

# plot SDs for each run
varPlot(y~day+day:run, dataEP05A2_3, type=2)

# use CV instead of SD
varPlot(y~day/run, dataEP05A2_3, type=2, VARtype="CV")

# now plot variability-chart and SD-plot in one window
varPlot(y~day/run, dataEP05A2_3, type=3, useVarNam=TRUE)

# now further customize the plot
varPlot( y~day/run, dataEP05A2_3, BG=list(col=c("lightgray", "gray")),
         YLabel=list(font=2, col="blue", cex=1.75, text="Custom Y-Axis Label"),
         VCnam=list(col="red", font=4, cex=2),
         VarLab=list(list(col="blue", font=3, cex=2), list(cex=1.25, srt=-15)))

# create variability-chart of the example dataset in the CLSI EP05-A2 
# guideline (listed on p.25)
data(Glucose,package="VCA")
varPlot(result~day/run, Glucose, type=3)

# use individual settings of 'VarLab' and 'VSpace' for each variance component
varPlot(result~day/run, Glucose, type=3, 
        VarLab=list(list(srt=45, col="red", font=2), 
        list(srt=90, col="blue", font=3)), VSpace=c(.25, .75))

# set individual titles for both plot when 'type=3'
# and individual 'ylim' specifications
 varPlot(result~day/run, Glucose, type=3, 
		Title=list(	list(main="Variability Chart"), 
					list(main="Plot of SD-Values")),
		ylim=list(	c(230, 260), c(0, 10)))

# more complex experimental design
data(realData)
Data &lt;- realData[realData$PID == 1,]
varPlot(y~lot/calibration/day/run, Data, type=3)

# order levels in the tablular environment
varPlot(y~lot/calibration/day/run, Data, keep.order=FALSE)
# keeping the order as in the data set (default) was different
varPlot(y~lot/calibration/day/run, Data, keep.order=TRUE)

# improve visual appearance of the plot by alternating bg-colors
# for variable "calibration"
varPlot(y~lot/calibration/day/run, Data, type=3, keep.order=FALSE,
        BG=list(var="calibration", col=c("white", "lightgray")))

# add horizontal lines indicating mean-value for each factor-level of all variables
varPlot(y~lot/calibration/day/run, Data, type=3, keep.order=FALSE,
        BG=list(var="calibration", 
                col=c("lightgray","antiquewhite2","antiquewhite4",
                      "antiquewhite1","aliceblue","antiquewhite3",
                      "white","antiquewhite","wheat" ), 
                col.table=TRUE),
        MeanLine=list(var=c("lot", "calibration", "day", "int"), 
                      col=c("orange", "blue", "green", "magenta"), 
                      lwd=c(2,2,2,2)))

# now also highlight bounds between factor levels of "lot" and "day" 
# as vertical lines and extend them into the table (note that each 
# variable needs its specific value for 'col.table')
 varPlot(y~lot/calibration/day/run, Data, type=3, keep.order=FALSE,
		BG=list(var="calibration", 
				col=c(	"aquamarine","antiquewhite2","antiquewhite4",
						"antiquewhite1","aliceblue","antiquewhite3",
                      	"white","antiquewhite","wheat" ), 
				col.table=TRUE),
		MeanLine=list(	var=c("lot", "calibration", "day", "int"), 
						col=c("orange", "blue", "darkgreen", "magenta"), 
						lwd=c(2,2,2,2)),
		VLine=list(	var=c("lot", "day"), col=c("black", "skyblue1"),
					lwd=c(2, 1), col.table=c(TRUE, TRUE)))

# one can use argument 'JoinLevels' to join factor-levels or a variable
# nested within a higher-level factor, 'VLine' is used to separate levels
# of variables "calibration" and "lot" with different colors
 varPlot(y~calibration/lot/day/run, Data, 
         BG=list(var="calibration", 
                 col=c("#f7fcfd","#e5f5f9","#ccece6","#99d8c9",
                       "#66c2a4","#41ae76","#238b45","#006d2c","#00441b"), 
                 col.table=TRUE), 
         VLine=list(var=c("calibration", "lot"), 
                    col=c("black", "darkgray"), lwd=c(2,1), col.table=TRUE), 
         JoinLevels=list(var="lot", col=c("#ffffb2","orangered","#feb24c"), 
                         lwd=c(2,2,2)), 
         MeanLine=list(var="lot", col="blue", lwd=2))

# same plot demonstrating additional features applicable via 'Points' 
 varPlot(y~calibration/lot/day/run, Data, 
         BG=list(var="calibration", 
                 col=c("#f7fcfd","#e5f5f9","#ccece6","#99d8c9",
                       "#66c2a4","#41ae76","#238b45","#006d2c","#00441b"), 
                 col.table=TRUE), 
         VLine=list(var=c("calibration", "lot"), 
                    col=c("black", "mediumseagreen"), lwd=c(2,1), 
                    col.table=c(TRUE,TRUE)), 
         JoinLevels=list(var="lot", col=c("lightblue", "cyan", "yellow"), 
                         lwd=c(2,2,2)), 
         MeanLine=list(var="lot", col="blue", lwd=2),
         Points=list(pch=list(var="lot", pch=c(21, 22, 24)), 
                     bg =list(var="lot", bg=c("lightblue", "cyan", "yellow")), 
                     cex=1.25))

# depict measurements as boxplots
data(VCAdata1)
datS5 &lt;- subset(VCAdata1, sample==5)
varPlot(y~device/day, datS5, Boxplot=list()) 

# present points as jitter-plot around box-center
	varPlot(y~device/day, datS5, 
		Boxplot=list(jitter=1, col.box="darkgreen"),
		BG=list(var="device", col=paste0("gray", c(60, 70, 80)),
				col.table=TRUE),
		Points=list(pch=16, 
					col=list(var="run", col=c("blue", "red"))), 
		Mean=list(col="black", cex=1, lwd=2),
			VLine=list(var="day", col="white")) 
# add legend
legend( "topright", legend=c("run 1", "run 2"),
        fill=c("blue", "red"), box.lty=0, border="white")

## End(Not run)
</code></pre>

<hr>
<h2 id='VCAdata1'>Simulated Data for Variance Component Analysis.</h2><span id='topic+VCAdata1'></span>

<h3>Description</h3>

<p>This data set consists of 2520 observations. There are 3 lots (lot),
10 samples, 21 days, 2 runs within day. This simulated dataset is used in 
examples and unit-tests (see subdir 'UnitTests' of the package-dir).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VCAdata1)</code></pre>


<h3>Format</h3>

<p>data.frame with 2520 rows and 5 variables.</p>

<hr>
<h2 id='VCAinference'>Inferential Statistics for VCA-Results</h2><span id='topic+VCAinference'></span>

<h3>Description</h3>

<p>Function <code>VCAinference</code> constructs one- and two-sided confidence intervals, and performs Chi-Squared tests for total
and error variance against claimed values for 'VCA' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCAinference(
  obj,
  alpha = 0.05,
  total.claim = NA,
  error.claim = NA,
  claim.type = "VC",
  VarVC = FALSE,
  excludeNeg = TRUE,
  constrainCI = TRUE,
  ci.method = "sas",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VCAinference_+3A_obj">obj</code></td>
<td>
<p>(object) of class 'VCA' or, alternatively, a list of 'VCA' objects, where all other arguments can be 
specified as vectors, where the i-th vector element applies to the i-th element of 'obj' (see examples)</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) value specifying the significance level for <code class="reqn">100*(1-alpha)</code>% confidence intervals.</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_total.claim">total.claim</code></td>
<td>
<p>(numeric) value specifying the claim-value for the Chi-Squared test for the total variance (SD or CV, see <code>claim.type</code>).</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_error.claim">error.claim</code></td>
<td>
<p>(numeric) value specifying the claim-value for the Chi-Squared test for the error variance (SD or CV, see <code>claim.type</code>).</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_claim.type">claim.type</code></td>
<td>
<p>(character) one of &quot;VC&quot;, &quot;SD&quot;, &quot;CV&quot; specifying how claim-values have to be interpreted:<br />
&quot;VC&quot; (Default) = claim-value(s) specified in terms of variance(s),<br />
&quot;SD&quot; = claim-values specified in terms of standard deviations (SD),<br />
&quot;CV&quot; = claim-values specified in terms of coefficient(s) of variation (CV)
and are specified as percentages.<br />
If set to &quot;SD&quot; or &quot;CV&quot;, claim-values will be converted to variances before applying the Chi-Squared test (see examples).</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_varvc">VarVC</code></td>
<td>
<p>(logical) TRUE = the covariance matrix of the estimated VCs will be computed (see <code><a href="#topic+vcovVC">vcovVC</a></code>), where diagonal
elements correspond to the variances of the individual VCs. This matrix is required for estimation of CIs for 
intermediate VCs if 'method.ci=&quot;sas&quot;'. 
FALSE (Default) = computing covariance matrix of VCs is omitted, as well as CIs for intermediate VCs.</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_excludeneg">excludeNeg</code></td>
<td>
<p>(logical) TRUE = confidence intervals of negative variance estimates will not be reported. <br />
FALSE = confidence intervals for all VCs will be reported including those with negative VCs.<br />
See the details section for a thorough explanation.</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_constrainci">constrainCI</code></td>
<td>
<p>(logical) TRUE = CI-limits for all variance components are constrained to be &gt;= 0.<br />
FALSE = unconstrained CIs with potentially negative CI-limits will be reported.<br />
which will preserve the original width of CIs.
See the details section for a thorough explanation.</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_ci.method">ci.method</code></td>
<td>
<p>(character) string or abbreviation specifying which approach to use for computing confidence intervals of variance components (VC).
&quot;sas&quot; (default) uses Chi-Squared based CIs for total and error and normal approximation for all other VCs (Wald-limits, option &quot;NOBOUND&quot;
in SAS PROC MIXED); &quot;satterthwaite&quot; will approximate DFs for each VC using the Satterthwaite approach (see <code><a href="#topic+SattDF">SattDF</a></code> for models
fitted by ANOVA) and all Cis are based on the Chi-Squared distribution. This approach is conservative but avoids negative values for the lower bounds.</p>
</td></tr>
<tr><td><code id="VCAinference_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes confidence intervals (CI) for variance components (VC), standard deviations (SD)
and coefficients of variation (CV). VCs 'total' and 'error' can be tested against claimed values specifying parameters
'total.claim' and 'error.claim'. One can also specify claim-values in terms of SD or CV (see <code>claim.type</code>).<br />
Confidence intervals for VCs are constructed either following the same rules as in SAS 9.2 PROC MIXED with option 'method=type1'
(ci.method=&quot;sas&quot;) or using Satterthwaite methodology throughout (ci.method=&quot;satterthwaite&quot;). In the former approach
for VC total and error, which are constrained to be <code class="reqn">&gt;= 0</code>, CIs are based on the Chi-Squared distribution. Degrees of freedom
(DF) for total variance are approximated using the Satterthwaite approximation (which is not available in either SAS procedure).
For all other VCs, the CI is <code class="reqn">[sigma^2-QNorm(alpha/2)*SE(sigma^2); sigma^2+QNorm(1-alpha/2)*SE(sigma^2)]</code>, where QNorm(x) indicates the x-quantile of 
the standard normal distribution. The second method approximates DFs for all VCs using the Satterthwaite approximation and CIs are
based on the corresponding Chi-Squared distribution for all VCs (see examples). 
Note that in the computation of the covariance-matrix of the VCs, the estimated VCs will be used. If these are requested to be set to 0 
(<code>NegVC=FALSE</code> in <code><a href="#topic+anovaVCA">anovaVCA</a></code>), the result might not be conformable with theory given in the first reference. 
The validity of this implementation was checked against SAS 9.2 PROC MIXED (method=type1), where VCs are not constrained to be &gt;= 0. 
The sampling variances for VCs are obtained assuming normality throughout based on <code class="reqn">Var(\sigma^{2} = C^{-1} * Var(m_{SS} * (C^{-1})^{T}))</code>, 
where <code class="reqn">C^{-1}</code> is the inverse of the coefficient matrix equating observed Sum of Squares (SS)
to their expected values, and <code class="reqn">(C^{-1})^{T}</code> indicating the transpose of <code class="reqn">C^{-1}</code> (see Searle et al. 1992, pg. 176).
</p>
<p>An input <code>VCA</code>-object can be in one of three states:<br /> 
<br />
State (1) corresponds to the situation, where all VC &gt; 0.<br /> 
State (2) corresponds to the situation, where at least one VC &lt; 0.<br />
State (3) corresponds to situations, where negative VC estimates occured but were set to 0, i.e. <code>NegVC=FALSE</code> - the Default.<br />
</p>
<p>State (2) occurs when parameter <code>NegVC</code> was set to TRUE in <code><a href="#topic+anovaVCA">anovaVCA</a></code>, state (3) represents the default-setting in 
function <code><a href="#topic+anovaVCA">anovaVCA</a></code>. If a <code>VCA</code>-object is in state (1), parameter <code>excludeNeg</code> has no effect (there are no negative VCs),
only parameter <code>constrainCI</code> is evaluated. For <code>VCA</code>-objects in state(2), <code>constrainCI</code> has no effect, because constraining
CIs for unconstrained VCs makes no sense. State (3) forces parameter <code>constrainCI</code> to be set to TRUE and one can only choose whether to
exclude CIs of negative VC estimates or not. Whenever VCs have to be constrained, it is straight forward to apply constraining also to any
CI. Note that situations outlined above only occur when parameter <code>VarVC</code> is set to TRUE, which causes estimation of the covariance-matrix
of variance components. The default is only to compute and report CIs for total and error variance, which cannot become negative.
</p>


<h3>Value</h3>

<p>(VCAinference) object, a list with elements: <br />
</p>
<table>
<tr><td><code>ChiSqTest</code></td>
<td>
<p>(data.frame) with results of the Chi-Squared test</p>
</td></tr>
<tr><td><code>ConfInt</code></td>
<td>
<p>(list) with elements <code>VC</code>, <code>SD</code>, <code>CV</code>, all lists themselves containing (data.frame) objects <code>OneSided</code> and <code>TwoSided</code></p>
</td></tr>
<tr><td><code>VCAobj</code></td>
<td>
<p>(VCA) object specified as input, if <code>VarVC=TRUE</code>, the 'aov.tab' element will have an extra column &quot;Var(VC)&quot; storing variances of VC-estimates&quot;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Original CIs will always be available independent of parameter-settings of <code>excludeNeg</code> and
<code>constrainCI</code>. Original CIs are stored in attribute &quot;CIoriginal&quot; of the returned 'VCAinference'-object, e.g.
'attr(obj$ConfInt$SD$OneSided, &quot;CIoriginal&quot;)' or 'attr(obj$ConfInt$CV$TwoSided, &quot;CIoriginal&quot;)'.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components., Wiley New York
</p>
<p>Burdick, R., Graybill, F. (1992), Confidence Intervals on Variance Components. Marcel Dekker, Inc.
</p>
<p>Satterthwaite, F.E. (1946), An Approximate Distribution of Estimates of Variance Components., 
Biometrics Bulletin 2, 110-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.VCAinference">print.VCAinference</a></code>, <code><a href="#topic+anovaVCA">anovaVCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load data (CLSI EP05-A2 Within-Lab Precision Experiment) 
data(dataEP05A2_1)

# perform (V)variance (C)component (A)nalysis (also compute A-matrices)
res &lt;- anovaVCA(y~day/run, dataEP05A2_1)

# get confidence intervals for total and error (VC, SD, CV)
VCAinference(res)

# additionally request CIs for all other VCs; default is to constrain 
# CI-limits to be &gt;= 0
# first solve MME
res &lt;- solveMME(res)
VCAinference(res, VarVC=TRUE)

# now using Satterthwaite methodology for CIs
VCAinference(res, VarVC=TRUE, ci.method="satt")

# request unconstrained CIs
VCAinference(res, VarVC=TRUE, constrainCI=FALSE)

# additionally request Chi-Squared Tests of total and error, default 
# is that claim values are specified as variances (claim.type="VC")
VCAinference(res, total.claim=4.5, error.claim=3.5)

# perform Chi-Squared Tests, where claim-values are given as SD, 
# compare p-values to former example
VCAinference(res, total.claim=sqrt(4.5), error.claim=sqrt(3.5), claim.type="SD")

# now using Satterthwaite methodology for CIs
VCAinference(res, total.claim=sqrt(4.5), error.claim=sqrt(3.5), 
claim.type="SD", ci.method="satt")

# now add random error to example data forcing the ANOVA-estimate of the 
# day-variance to be negative
set.seed(121)
tmpData &lt;- dataEP05A2_1
tmpData$y &lt;- tmpData$y + rnorm(80,,3)
res2 &lt;- anovaVCA(y~day/run, tmpData)

# call 'VCAinference' with default settings
VCAinference(res2)

# extract components of the returned 'VCAinference' object
inf &lt;- VCAinference(res2, total.claim=12)
inf$ConfInt$VC$OneSided			# one-sided CIs for variance components
inf$ConfInt$VC$TwoSided			# two-sided CI for variance components
inf$ChiSqTest

# request CIs for all VCs, default is to exclude CIs of negative VCs (excludeNeg=TRUE) 
# solve MMEs first (or set MME=TRUE when calling anovaVCA)
res2 &lt;- solveMME(res2)
VCAinference(res2, VarVC=TRUE)

# request CIs for all VCs, including those for negative VCs, note that all CI-limits 
# are constrained to be &gt;= 0
VCAinference(res2, VarVC=TRUE, excludeNeg=FALSE)

# request unconstrained CIs for all VCs, including those for negative VCS
# one has to re-fit the model allowing the VCs to be negative
res3 &lt;- anovaVCA(y~day/run, tmpData, NegVC=TRUE, MME=TRUE)
VCAinference(res3, VarVC=TRUE, excludeNeg=FALSE, constrainCI=FALSE)

### use the numerical example from the CLSI EP05-A2 guideline (p.25)
data(Glucose,package="VCA")
res.ex &lt;- anovaVCA(result~day/run, Glucose)

### also perform Chi-Squared tests
### Note: in guideline claimed SD-values are used, here, claimed variances are used
VCAinference(res.ex, total.claim=3.4^2, error.claim=2.5^2)


# load another example dataset and extract the "sample_1" subset
data(VCAdata1)
sample1 &lt;- VCAdata1[which(VCAdata1$sample==1),]

# generate an additional factor variable and random errors according to its levels
sample1$device &lt;- gl(3,28,252)                                      
set.seed(505)
sample1$y &lt;- sample1$y + rep(rep(rnorm(3,,.25), c(28,28,28)),3)     

# fit a crossed-nested design with main factors 'lot' and 'device' 
# and nested factors 'day' and 'run' nested below, also request A-matrices 
res1 &lt;- anovaVCA(y~(lot+device)/day/run, sample1) 

# get confidence intervals, covariance-matrix of VCs, ..., 
# explicitly request the covariance-matrix of variance components
# solve MMEs first
res1 &lt;- solveMME(res1)
inf1 &lt;- VCAinference(res1, VarVC=TRUE, constrainCI=FALSE)
inf1

# print numerical values with more digits
print(inf1, digit=12)

# print only parts of the 'VCAinference' object (see \code{\link{print.VCAinference}})
print(inf1, digit=12, what=c("VCA", "VC"))

# extract complete covariance matrix of variance components 
# (main diagonal is part of standard output -&gt; "Var(VC"))
VarCovVC &lt;- vcovVC(inf1$VCAobj)
round(VarCovVC, 12)

# use by-processing and specific argument-values for each level of the by-variable
data(VCAdata1)
fit.all &lt;- anovaVCA(y~(device+lot)/day/run, VCAdata1, by="sample", NegVC=TRUE)
inf.all &lt;- VCAinference(fit.all, total.claim=c(.1,.75,.8,1,.5,.5,2.5,20,.1,1))
print.VCAinference(inf.all, what="VC")

## End(Not run)
</code></pre>

<hr>
<h2 id='vcov.VCA'>Calculate Variance-Covariance Matrix of Fixed Effects for an 'VCA' Object</h2><span id='topic+vcov.VCA'></span>

<h3>Description</h3>

<p>Return the variance-covariance matrix of fixed effects for a linear mixed model
applicable for objects of class 'VCA'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
vcov(object, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.VCA_+3A_object">object</code></td>
<td>
<p>(VCA) object for which the variance-covariance matrix of
fixed effects shall be calculated</p>
</td></tr>
<tr><td><code id="vcov.VCA_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
<tr><td><code id="vcov.VCA_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Actually this function only extracts this matrix or, if not available, calls function
<code><a href="#topic+vcovFixed">vcovFixed</a></code> which performs calculations. It exists for compatibility reasons,
i.e. for coneniently using objects of class 'VCA' with other packages expecting this
function, e.g. the 'multcomp' package for general linear hypotheses for parametric
models.
</p>


<h3>Value</h3>

<p>(matrix) corresponding to the variance-covariance matrix of fixed effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit1 &lt;- anovaMM(y~day/(run), dataEP05A2_1)
vcov(fit1)

fit2 &lt;- anovaVCA(y~day/run, dataEP05A2_1)
vcov(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcovFixed'>Calculate Variance-Covariance Matrix and Standard Errors of Fixed Effects for an 'VCA' Object</h2><span id='topic+vcovFixed'></span>

<h3>Description</h3>

<p>The variance-covariance matrix of fixed effects for the linear mixed model in 'obj' is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovFixed(obj, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovFixed_+3A_obj">obj</code></td>
<td>
<p>(VCA) object for which the variance-covariance matrix of
fixed effects shall be calculated</p>
</td></tr>
<tr><td><code id="vcovFixed_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of fixed effects for a linear mixed model corresponds to matrix
<code class="reqn">(X^{T}V^{-1}X)^{-}</code>, where &gt;<code class="reqn">^{T}</code>&lt; denotes the transpose operator, &gt;<code class="reqn">^{-1}</code>&lt; 
the regular matrix inverse, and &gt;<code class="reqn">^{-}</code>&lt; the generalized (Moore-Penrose) inverse of a matrix.
</p>


<h3>Value</h3>

<p>(matrix) corresponding to the variance-covariance matrix of fixed effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataEP05A2_1)
fit1 &lt;- anovaMM(y~day/(run), dataEP05A2_1)
vcov(fit1)

fit2 &lt;- anovaVCA(y~day/run, dataEP05A2_1)
vcov(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcovVC'>Calculate Variance-Covariance Matrix of Variance Components of 'VCA' objects</h2><span id='topic+vcovVC'></span>

<h3>Description</h3>

<p>This function computes the variance-covariance matrix of variance components (VC) either
applying the approach given in the <code class="reqn">1^{st}</code> reference ('method=&quot;scm&quot;') or using
the approximation given in the <code class="reqn">2^{nd}</code> reference ('method=&quot;gb&quot;').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovVC(obj, method = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovVC_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="vcovVC_+3A_method">method</code></td>
<td>
<p>(character) string, optionally specifying whether to use the algorithm given in the
1st reference (&quot;scm&quot;) or in the 2nd refernce (&quot;gb&quot;). If not not supplied, the 
option is used coming with the 'VCA' object.</p>
</td></tr>
<tr><td><code id="vcovVC_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = will suppress any warning, which will be issued otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called on a 'VCA' object, which can be the sole argument. In this case the value
assigned to element 'VarVC.method' of the 'VCA' object will be used.
</p>


<h3>Value</h3>

<p>(matrix) corresponding to variance-covariance matrix of variance components
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>,
Florian Dufey <a href="mailto:florian.dufey@roche.com">florian.dufey@roche.com</a>
</p>


<h3>References</h3>

<p>Searle, S.R, Casella, G., McCulloch, C.E. (1992), Variance Components, Wiley New York
</p>
<p>Giesbrecht, F.G. and Burns, J.C. (1985), Two-Stage Analysis Based on a Mixed Model: Large-Sample
Asymptotic Theory and Small-Sample Simulation Results, Biometrics 41, p. 477-486
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(realData)
dat1 &lt;- realData[realData$PID==1,]
fit  &lt;- anovaVCA(y~lot/calibration/day/run, dat1) 
vcovVC(fit)
vcovVC(fit, "scm")		# Searle-Casella-McCulloch method (1st reference)
vcovVC(fit, "gb")		# Giesbrecht and Burns method (2nd reference)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
