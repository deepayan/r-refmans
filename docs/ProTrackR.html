<!DOCTYPE html><html><head><title>Help for package ProTrackR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ProTrackR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ProTrackR-package'><p>Manipulate and play ProTracker Modules. A description of the package,</p>
ProTracker effect commands and test cases.</a></li>
<li><a href='#appendPattern'><p>Append a PTPattern to a PTModule</p></a></li>
<li><a href='#as.character'><p>Character representation of ProTrackR objects</p></a></li>
<li><a href='#as.raw'><p>Extract and replace raw data</p></a></li>
<li><a href='#clearSamples'><p>Clear all samples from module</p></a></li>
<li><a href='#clearSong'><p>Clear all pattern info from module</p></a></li>
<li><a href='#deletePattern'><p>Remove a PTPattern table from a PTModule object</p></a></li>
<li><a href='#effect'><p>Extract or replace effect/trigger codes</p></a></li>
<li><a href='#fineTune'><p>Fine tune a PTSample</p></a></li>
<li><a href='#fix.PTModule'><p>Attempt to fix PTModule to ProTracker specs</p></a></li>
<li><a href='#funk_table'><p>ProTracker Funk Table</p></a></li>
<li><a href='#loopLength'><p>The loop length of a PTSample</p></a></li>
<li><a href='#loopSample'><p>Looped waveform of a sample</p></a></li>
<li><a href='#loopStart'><p>The loop start position of a PTSample</p></a></li>
<li><a href='#loopState'><p>Get PTSample loop state</p></a></li>
<li><a href='#mod.intro'><p>Example of a PTModule object</p></a></li>
<li><a href='#modArchive'><p>ModArchive helper functions</p></a></li>
<li><a href='#modLand'><p>ModLand helper functions</p></a></li>
<li><a href='#MODPlugToPTPattern'><p>Convert MODPlug pattern into a PTPattern object</p></a></li>
<li><a href='#modToWave'><p>Convert a PTModule object into an audio Wave object</p></a></li>
<li><a href='#moduleSize'><p>Get module file size</p></a></li>
<li><a href='#name'><p>Obtain or replace the name of a PTModule or PTSample</p></a></li>
<li><a href='#note'><p>Extract or replace a note</p></a></li>
<li><a href='#noteToPeriod'><p>Extract period value for a specific note</p></a></li>
<li><a href='#noteUp'><p>Raise or lower notes and octaves</p></a></li>
<li><a href='#nybble'><p>Get the high or low nybble of a raw value</p></a></li>
<li><a href='#nybbleToSignedInt'><p>Get signed integer values from nybbles</p></a></li>
<li><a href='#octave'><p>Extract or replace an octave</p></a></li>
<li><a href='#pasteBlock'><p>Paste a block of PTCell data into a PTPattern</p></a></li>
<li><a href='#patternLength'><p>Get the number of PTPattern tables in a PTModule</p></a></li>
<li><a href='#patternOrder'><p>Get the pattern order table</p></a></li>
<li><a href='#patternOrderLength'><p>Get the length of the pattern order table</p></a></li>
<li><a href='#paula_clock'><p>Paula clock table</p></a></li>
<li><a href='#period_table'><p>ProTracker Period Table</p></a></li>
<li><a href='#periodToChar'><p>Get the note and octave from period table</p></a></li>
<li><a href='#playingtable'><p>Generate a table for playing a PTModule object</p></a></li>
<li><a href='#playMod'><p>Play PTModule objects</p></a></li>
<li><a href='#playSample'><p>Play audio samples</p></a></li>
<li><a href='#playWave'><p>Play Wave objects</p></a></li>
<li><a href='#plot'><p>Plot a PTModule object</p></a></li>
<li><a href='#print'><p>Print ProTrackR objects</p></a></li>
<li><a href='#proTrackerVibrato'><p>Get the vibrato table used by ProTracker</p></a></li>
<li><a href='#PTBlock'><p>Select and copy a range of PTCells into a PTBlock</p></a></li>
<li><a href='#PTCell-class'><p>The PTCell class</p></a></li>
<li><a href='#PTCell-method'><p>Coerce to or replace PTCell</p></a></li>
<li><a href='#PTModule-class'><p>The PTModule class</p></a></li>
<li><a href='#PTPattern-class'><p>The PTPattern class</p></a></li>
<li><a href='#PTPattern-method'><p>Coerce to or replace PTPattern</p></a></li>
<li><a href='#PTPatternToMODPlug'><p>Convert PTPattern data into a MODPlug pattern</p></a></li>
<li><a href='#PTSample-class'><p>The PTSample class</p></a></li>
<li><a href='#PTSample-method'><p>Coerce to or replace PTSample</p></a></li>
<li><a href='#PTTrack-class'><p>The PTTrack class</p></a></li>
<li><a href='#PTTrack-method'><p>Coerce to or replace PTTrack</p></a></li>
<li><a href='#rawToCharNull'><p>Convert raw vectors into a character string</p></a></li>
<li><a href='#rawToPTModule'><p>Convert a vector of raw data into a PTModule object</p></a></li>
<li><a href='#rawToSignedInt'><p>Convert a raw vector into signed integers (short)</p></a></li>
<li><a href='#rawToUnsignedInt'><p>Convert raw vector into a single unsigned integer value</p></a></li>
<li><a href='#read.module'><p>Read a ProTracker module file</p></a></li>
<li><a href='#read.sample'><p>Read an audio file and coerce to a PTSample object</p></a></li>
<li><a href='#resample'><p>Resample data</p></a></li>
<li><a href='#sampleLength'><p>Get the length of a PTSample</p></a></li>
<li><a href='#sampleNumber'><p>Extract or replace a sample number</p></a></li>
<li><a href='#sampleRate'><p>Calculate the sample rate for a note or period value</p></a></li>
<li><a href='#signedIntToNybble'><p>Convert a signed integer to a nybble in raw data.</p></a></li>
<li><a href='#signedIntToRaw'><p>Convert signed integers (short) into a raw vector</p></a></li>
<li><a href='#trackerFlag'><p>Tracker flag indicating version compatibility</p></a></li>
<li><a href='#unsignedIntToRaw'><p>Convert unsigned integer into a raw vector</p></a></li>
<li><a href='#volume'><p>Default playback volume of PTSample</p></a></li>
<li><a href='#waveform'><p>Extract or replace a PTSample waveform</p></a></li>
<li><a href='#write.module'><p>Export an PTModule object as a ProTracker module file</p></a></li>
<li><a href='#write.sample'><p>Write a PTSample object to an audio file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Manipulate and Play 'ProTracker' Modules</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Pepijn de Vries <a href="https://orcid.org/0000-0002-7961-6646"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pepijn de Vries &lt;pepijn.devries@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>'ProTracker' is a popular music tracker to sequence
    music on a Commodore Amiga machine. This package offers the
    opportunity to import, export, manipulate and play 'ProTracker'
    module files. Even though the file format could be considered
    archaic, it still remains popular to this date. This package
    intends to contribute to this popularity and therewith
    keeping the legacy of 'ProTracker' and the Commodore Amiga
    alive.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>Depends:</td>
<td>audio, lattice, signal, tuneR (&ge; 1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, stats, utils, XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AmigaFFH (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pepijn-devries.github.io/ProTrackR/">https://pepijn-devries.github.io/ProTrackR/</a>,
<a href="https://github.com/pepijn-devries/ProTrackR/">https://github.com/pepijn-devries/ProTrackR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pepijn-devries/ProTrackR/issues">https://github.com/pepijn-devries/ProTrackR/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 08:34:44 UTC; vries171</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ProTrackR-package'>Manipulate and play ProTracker Modules. A description of the package,
ProTracker effect commands and test cases.</h2><span id='topic+ProTrackR-package'></span><span id='topic+_PACKAGE'></span><span id='topic+EffectCommands'></span>

<h3>Description</h3>

<p>The ProTrackR package can import and export module files from the music tracker
ProTracker from the Commodore Amiga machine. This package can also render
and play module files. Furthermore, the package provides the means to manipulate and analyse
the modules.
</p>


<h3>Details</h3>

<p>ProTracker is a popular music tracker to sequence music on a Commodore
Amiga machine. This package offers the opportunity to import, export, manipulate
an play ProTracker module files. Even though the file format could be considered
archaic, it still remains popular to this date. This package intends to contribute
to this popularity and therewith keeping the legacy of ProTracker and the
Commodore Amiga alive.
</p>
<p>Some experience with ProTracker (or any other
music tracker) will promote the ease of use of this package. However,
the provided documentation and exernal links should help you,
when you're starting from scratch. A good place to start reading
this manual would be the documentation of the <code><a href="#topic+PTModule-class">PTModule</a></code>,
which describes the structure of a ProTracker module and how it is
implemented in this package. You should also have a look at the documentation
of the <code><a href="#topic+PTPattern">PTPattern</a></code>, <code><a href="#topic+PTTrack">PTTrack</a></code>, <code><a href="#topic+PTCell">PTCell</a></code> and
<code><a href="#topic+PTSample">PTSample</a></code> classes, which are all elements of the
<code><a href="#topic+PTModule">PTModule</a></code>.
</p>


<h3>Current issues and future developments</h3>

<p>For the development state of this package, please check the
<a href="https://pepijn-devries.github.io/ProTrackR/">README section on GitHub</a>.
</p>
<p>Currently, not all effect commands are implemented, although most common
ones are. I will work on implementing the remaining effect commands (see
also section below). ProTracker also has specific interpretations that
are currently not all implemented correctly.
</p>
<p>Sample switching (that is when a module switches from one sample number
to another, without specifying a new note) is also something that is implemented
differently by varying module players. This package currently does not implement
such switches conform ProTracker specs.
</p>
<p>Period values, which dictate at which fequency samples should be played, are
censored both by Amiga hardware and software coded limits in the original
ProTracker. Documentation on these limits are ambiguous. I've made a first
attempt to implement these bounds in the current version of the
package after consulting with Olav
S&oslash;rensen (who created
a ProTracker clone for modern machines: <a href="https://16-bits.org/pt.php">https://16-bits.org/pt.php</a>).
I'm really grateful for his input and doing some checks on an actual
Amiga.
</p>
<p>I also realise that the documentation of this package may be a bit cryptic
at some points. I would like to improve it where I can, but for that I need a
fresh perspective from the users. So please feel free to provide constructive
feedback such that I can improve the quality of this package.
</p>


<h3>ProTracker Effect Commands</h3>

<p>As explained before, effect commands are composed of a three hexadecimal digits.
The first digit indicates the type of effect, trigger or jump that should be applied,
the latter two digits indicate the magnitude of the effect. An exception are
commands starting with the digit 'E', for which the first two digits specify
the type of effect and only the last digit represents the magnitude. Below
all available effect commands (or codes if you will) are listed with the
magnitudes labelled 'x' or 'xy'. The overview shows which commands are used
for which kind of effect and whether it is implemented (between brackets) in
the playing routines of this package.
</p>
<p>But first a few words on speed and tempo in ProTracker. Both are two sides of
the same coin, both affect the overall speed with which patterns are played.
Speed is defined as the number of 'ticks' per pattern row and tempo sets
the duration of each tick.
So by increasing the speed value, or decreasing the tempo, the overall playing
speed of the pattern table is reduced. At the default tempo of 125, the duration
of a tick equals the vertical blank period of the monitor (1/50 seconds for PAL
and 1/60 seconds NTSC video systems). They can be set with the Fxy command.
</p>
<p>On the Commodore Amiga the chip responsible for audio output (Paula),
the audio playback of samples can be controlled by the user in two ways:
the playback rate of the sample can be changed by specifying 'period'
values (see e.g. <code><a href="#topic+periodToSampleRate">periodToSampleRate</a></code>) and specifying a
volume which is linearly scaled between 0 (silent) and 64 (maximum).
Period and volumes can only be changed at the start of each tick. This is
why the effects will be affected by the speed setting, but not the tempo.
</p>
<p>And now, without further ado, the overview of effect commands:</p>

<table>
<tr>
 <td style="text-align: left;">
   Code </td><td style="text-align: left;"> Effect </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Status </td>
</tr>
<tr>
 <td style="text-align: left;">
   0xy </td><td style="text-align: left;"> Arpeggio </td><td style="text-align: left;"> This effect alternates the pitch each tick to simulate a chord. xy needs to be greater then 00. First the specified note is played, then the pitch is increased with x semitones, then with y semitones. </td><td style="text-align: left;"> Partly implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   1xy </td><td style="text-align: left;"> Porta up </td><td style="text-align: left;"> Decrease the period value with xy every tick but the first. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   2xy </td><td style="text-align: left;"> Porta down </td><td style="text-align: left;"> Increase the period value with xy every tick but the first. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   3xy </td><td style="text-align: left;"> Porta to note </td><td style="text-align: left;"> Change the period value with xy every tick but the first, untill the specified target note is reached. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   4xy </td><td style="text-align: left;"> Vibrato </td><td style="text-align: left;"> Oscillate the pitch with magnitude x. Where y relates to the oscillation frequency. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   5xy </td><td style="text-align: left;"> Porta to note + Volume slide </td><td style="text-align: left;"> A combination of effects 3xy and Axy. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   6xy </td><td style="text-align: left;"> Vibrato + Volume slide </td><td style="text-align: left;"> A combination of effects 4xy and Axy. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   7xy </td><td style="text-align: left;"> Tremolo </td><td style="text-align: left;"> Oscillate the volume with magnitude x. Where y relates to the oscillation frequency. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   8xy </td><td style="text-align: left;"> Not implemented </td><td style="text-align: left;"> This effect command is not implemented in ProTracker, nor will it be in this package. </td><td style="text-align: left;"> Not implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   9xy </td><td style="text-align: left;"> Set sample offset </td><td style="text-align: left;"> This effect causes the note to start playing at an offset (of 256 times xy samples) into the sample, instead of just from the start. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   Axy </td><td style="text-align: left;"> Volume slide </td><td style="text-align: left;"> Change the volume every but the first tick: increase with x, decrease with y. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   Bxy </td><td style="text-align: left;"> Position jump </td><td style="text-align: left;"> Jump to position xy of the <code><a href="#topic+patternOrder">patternOrder</a></code> table. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   Cxy </td><td style="text-align: left;"> Set volume </td><td style="text-align: left;"> Set the volume with xy. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   Dxy </td><td style="text-align: left;"> Pattern break </td><td style="text-align: left;"> Break to row xy in the next pattern. Note: xy is (even though it is a hexadecimal) interpreted as a decimal. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E0x </td><td style="text-align: left;"> Turn filter on/off </td><td style="text-align: left;"> If x is even, the (emulated) hardware filter is turned on (for all tracks). It is turned off if x is odd. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E1x </td><td style="text-align: left;"> Porta up (fine) </td><td style="text-align: left;"> The period value is decreased with x, at the first tick. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E2x </td><td style="text-align: left;"> Porta down (fine) </td><td style="text-align: left;"> The period value is increased with x, at the first tick. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E3x </td><td style="text-align: left;"> Glissando Control </td><td style="text-align: left;"> This effect causes a change in the effect 3xy (porta to note).  It toggles whether to do a smooth slide or whether to slide in jumps of semitones. When x is 0 it uses a smooth slide, non-zero values will result in jumps. </td><td style="text-align: left;"> Not yet implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E4x </td><td style="text-align: left;"> Vibrato Waveform </td><td style="text-align: left;"> This effect sets the waveform for the vibrato command to follow. With x modulo 4 equals 0, a sine wave is used, with 1 ramp down, with 2 or 3 a square wave. Values greater than 4 causes the ossicating waveform not to retrigger it when a new note is played. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E5x </td><td style="text-align: left;"> Set finetune </td><td style="text-align: left;"> Set the finetune with x, where x is interpreted as a signed nybble. </td><td style="text-align: left;"> Partly implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E6x </td><td style="text-align: left;"> Pattern loop </td><td style="text-align: left;"> Set pattern loop start with E60, and loop x times when x is non-zero. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E7x </td><td style="text-align: left;"> Tremolo waveform </td><td style="text-align: left;"> Same as E4x, but this controls the wave form for the tremolo effect (7xy) rather then the vibrato effect. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E8x </td><td style="text-align: left;"> Not implemented </td><td style="text-align: left;"> According to official documentation this command is not implemented in ProTracker, but it is. Applies a filter on a looped sample, therewith destroying the original sample data. </td><td style="text-align: left;"> Not implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   E9x </td><td style="text-align: left;"> Retrigger note </td><td style="text-align: left;"> Retrigger the note every x-th tick. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   EAx </td><td style="text-align: left;"> Volume slide up (fine) </td><td style="text-align: left;"> Increase the volume with x at the first tick. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   EBx </td><td style="text-align: left;"> Volume slide down (fine) </td><td style="text-align: left;"> Decrease the volume with x at the first tick. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   ECx </td><td style="text-align: left;"> Cut note </td><td style="text-align: left;"> Cut the volume of the note to zero after x ticks. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   EDx </td><td style="text-align: left;"> Delay note </td><td style="text-align: left;"> The note is triggered with a delay of x ticks. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   EEx </td><td style="text-align: left;"> Pattern delay </td><td style="text-align: left;"> The duration of the row in ticks is multiplied by (x + 1). </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   EFx </td><td style="text-align: left;"> Not implemented </td><td style="text-align: left;"> According to official documentation this command is not implemented in ProTracker, but it is. It flips sample data in a looped sample, therewith destroying the original sample data. </td><td style="text-align: left;"> Not implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
   Fxy </td><td style="text-align: left;"> Set speed or tempo </td><td style="text-align: left;"> When xy is smaller then 32, it sets the speed in ticks per row. When xy is greater then 31, it will set the tempo, wich is inversely related to the duration of each tick. Speed and tempo can be defined in combination. </td><td style="text-align: left;"> Implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Test cases</h3>

<p>The interpretation of the effect commands can be tedious. They often vary
between module players. Even ProTracker can have a quirky (and unexpected) ways
of handling the effect commands. This package aims at staying as close to
ProTracker 'standards' as possible.
</p>
<p>The current version already implements most effect commands and common quirks
when it comes to their interpretation. My subjective estimate is that it will
correctly play roughly 95% of the ProTracker modules on <a href="https://modarchive.org">ModArchive</a>. Some
Less common unexpected behaviour is documented by the team behind <a href="https://wiki.openmpt.org/Main_Page">OpenMPT</a>, for which they developed
several test cases. The table below shows which test cases this package passes
and which it does not.</p>

<table>
<tr>
 <td style="text-align: left;">
   Test module </td><td style="text-align: left;"> Status </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#AmigaLimitsFinetune.mod">AmigaLimitsFinetune.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#ArpWraparound.mod">ArpWraparound.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#DelayBreak.mod">DelayBreak.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#finetune.mod">finetune.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PatLoop-Break.mod">PatLoop-Break.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PatternJump.mod">PatternJump.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PortaSmpChange.mod">PortaSmpChange.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PortaTarget.mod">PortaTarget.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PTInstrSwap.mod">PTInstrSwap.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#ptoffset.mod">ptoffset.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#PTSwapEmpty.mod">PTSwapEmpty.mod</a> </td><td style="text-align: left;"> Fail </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="https://wiki.openmpt.org/Development:_Test_Cases/MOD#VibratoReset.mod">VibratoReset.mod</a> </td><td style="text-align: left;"> Pass </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pepijn de Vries <a href="mailto:pepijn.devries@outlook.com">pepijn.devries@outlook.com</a> (<a href="https://orcid.org/0000-0002-7961-6646">ORCID</a>) [data contributor]
</p>


<h3>References</h3>

<p>Some basic information on ProTracker:
<a href="https://en.wikipedia.org/wiki/Protracker">https://en.wikipedia.org/wiki/Protracker</a>
</p>
<p>Some basic information on music trackers in general:
<a href="https://en.wikipedia.org/wiki/Music_tracker">https://en.wikipedia.org/wiki/Music_tracker</a>
</p>
<p>A tutorial on ProTracker on YouTube:
<a href="https://www.youtube.com/playlist?list=PLVoRT-Mqwas9gvmCRtOusCQSKNQNf6lTc">https://www.youtube.com/playlist?list=PLVoRT-Mqwas9gvmCRtOusCQSKNQNf6lTc</a>
</p>
<p>Some informal but extensive technical documentation on ProTracker:
<a href="ftp://ftp.modland.com/pub/documents/format_documentation/Protracker%20effects%20(FireLight)%20(.mod).txt">ftp://ftp.modland.com/pub/documents/format_documentation/Protracker%20effects%20(FireLight)%20(.mod).txt</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pepijn-devries.github.io/ProTrackR/">https://pepijn-devries.github.io/ProTrackR/</a>
</p>
</li>
<li> <p><a href="https://github.com/pepijn-devries/ProTrackR/">https://github.com/pepijn-devries/ProTrackR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pepijn-devries/ProTrackR/issues">https://github.com/pepijn-devries/ProTrackR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='appendPattern'>Append a PTPattern to a PTModule</h2><span id='topic+appendPattern'></span><span id='topic+appendPattern+2CPTModule+2CPTPattern-method'></span>

<h3>Description</h3>

<p>Appends a specified <code><a href="#topic+PTPattern">PTPattern</a></code> to a
<code><a href="#topic+PTModule">PTModule</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule,PTPattern'
appendPattern(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendPattern_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object to which a
<code><a href="#topic+PTPattern">PTPattern</a></code> is to be appended.</p>
</td></tr>
<tr><td><code id="appendPattern_+3A_pattern">pattern</code></td>
<td>
<p>A <code><a href="#topic+PTPattern">PTPattern</a></code> object which is
to be appended to the <code><a href="#topic+PTModule">PTModule</a></code> <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the <code><a href="#topic+trackerFlag">trackerFlag</a></code>, a ProTracker module can hold
either 64 or 100 pattern tables. As long as the number of pattern tables
is below this maximum, new pattern tables can be added to the module with
this function.
</p>
<p>The <code><a href="#topic+patternOrder">patternOrder</a></code> table should hold the maximum index of the
available pattern tables in a module, otherwise, the module is not valid.
As the maximum index increases, by appending a pattern table, the
<code><a href="#topic+patternOrder">patternOrder</a></code> table should be updated. The
<code><a href="#topic+appendPattern">appendPattern</a></code> method does this automatically, by replacing the first
non-unique index in the order table, outside the current order table's length,
with the new maximum index. If this is not possible, the highest element
in the order table is set to hold the maximum index.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PTModule">PTModule</a></code>, to which the
<code><a href="#topic+PTPattern">PTPattern</a></code> is appended.
</p>


<h3>Note</h3>

<p>As per ProTracker specification, the pattern indices
stored in the <code><a href="#topic+PTModule">PTModule</a></code> and obtained with
<code><a href="#topic+patternOrder">patternOrder</a></code> start at 0. Whereas R starts indexing at 1.
Beware of this discrepancy.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## append an empty pattern to mod.intro

mod.intro &lt;- appendPattern(mod.intro, new("PTPattern"))

## append a copy of pattern # 1 (this is pattern #0 in the
## patternOrder table) to mod.intro

mod.intro &lt;- appendPattern(mod.intro, PTPattern(mod.intro, 1))

</code></pre>

<hr>
<h2 id='as.character'>Character representation of ProTrackR objects</h2><span id='topic+as.character'></span><span id='topic+as.character+2CPTCell-method'></span><span id='topic+as.character+2CPTTrack-method'></span><span id='topic+as.character+2CPTPattern-method'></span>

<h3>Description</h3>

<p>Create a <code>character</code> representation of <code><a href="#topic+PTCell">PTCell</a></code>,
<code><a href="#topic+PTTrack">PTTrack</a></code> or <code><a href="#topic+PTPattern">PTPattern</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
as.character(x)

## S4 method for signature 'PTTrack'
as.character(x)

## S4 method for signature 'PTPattern'
as.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>
<p>An object of any of the following classes: <code><a href="#topic+PTCell">PTCell</a></code>,
<code><a href="#topic+PTTrack">PTTrack</a></code> or <code><a href="#topic+PTPattern">PTPattern</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+PTCell">PTCell</a></code> is an element of a <code><a href="#topic+PTTrack">PTTrack</a></code> which
in turn is an element of a <code><a href="#topic+PTPattern">PTPattern</a></code>. A <code><a href="#topic+PTPattern">PTPattern</a></code>
tells a tracker which sample to play at which frequency on which of the
four audio channels and with which effects. A <code><a href="#topic+PTCell">PTCell</a></code> in essence
holds all this information as described at the documentation of
the <code><a href="#topic+PTCell-class">PTCell</a></code>.
</p>
<p>Data in these objects are stored in these objects in a <code>raw</code> form,
to save working memory and to comply to the ProTracker file specifications.
As the raw data is not easy to interpret, this method is provided to
make your life (and the interpretation of the objects) easier.
</p>
<p>This method generates a character representation of each of the three objects.
These character representations can be coerced back to their original classes
with the following methods: <code><a href="#topic+PTCell-method">PTCell-method</a></code>,
<code><a href="#topic+PTTrack-method">PTTrack-method</a></code> and <code><a href="#topic+PTPattern-method">PTPattern-method</a></code>.
</p>


<h3>Value</h3>

<p>Returns a single character string when <code>x</code> is of class
<code><a href="#topic+PTCell">PTCell</a></code>.
</p>
<p>Returns a <code>vector</code> of length 64 of the type <code>character</code> when <code>x</code> is of class
<code><a href="#topic+PTTrack">PTTrack</a></code>.
</p>
<p>Returns a 64 by 4 <code>matrix</code> of the type <code>character</code> when <code>x</code> is of class
<code><a href="#topic+PTPattern">PTPattern</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other character.operations: 
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other track.operations: 
<code><a href="#topic+PTTrack-method">PTTrack-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

as.character(   PTCell(mod.intro, 1, 1, 1))

as.character(PTTrack(mod.intro, 1, 1))

as.character(PTPattern(mod.intro, 1))

</code></pre>

<hr>
<h2 id='as.raw'>Extract and replace raw data</h2><span id='topic+as.raw'></span><span id='topic+as.raw+2CPTCell-method'></span><span id='topic+as.raw+2CPTTrack-method'></span><span id='topic+as.raw+2CPTPattern-method'></span><span id='topic+as.raw+3C-'></span><span id='topic+as.raw+3C-+2CPTCell+2Craw-method'></span><span id='topic+as.raw+3C-+2CPTTrack+2Cmatrix-method'></span><span id='topic+as.raw+3C-+2CPTPattern+2Cmatrix-method'></span><span id='topic+as.raw+2CPTModule-method'></span>

<h3>Description</h3>

<p>Information of <code><a href="#topic+PTCell">PTCell</a></code>, <code><a href="#topic+PTTrack">PTTrack</a></code> and
<code><a href="#topic+PTPattern">PTPattern</a></code> objects are stored as <code>raw</code> values. This
method can be used to extract and replace this raw data. <code><a href="#topic+PTModule">PTModule</a></code>
objects can also be converted to raw data but not replaced by it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
as.raw(x)

## S4 replacement method for signature 'PTCell,raw'
as.raw(x) &lt;- value

## S4 method for signature 'PTTrack'
as.raw(x)

## S4 replacement method for signature 'PTTrack,matrix'
as.raw(x) &lt;- value

## S4 method for signature 'PTPattern'
as.raw(x)

## S4 replacement method for signature 'PTPattern,matrix'
as.raw(x) &lt;- value

## S4 method for signature 'PTModule'
as.raw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raw_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTCell">PTCell</a></code>, <code><a href="#topic+PTTrack">PTTrack</a></code> or
<code><a href="#topic+PTPattern">PTPattern</a></code> object, for which the raw data needs to extracted
or replaced. A <code><a href="#topic+PTModule">PTModule</a></code> object is also allowed, but this
object cannot be replaced.</p>
</td></tr>
<tr><td><code id="as.raw_+3A_value">value</code></td>
<td>
<p><code>raw</code> data with which the <code>raw</code> data in object
<code>x</code> needs to be replaced.
</p>
<p>If <code>x</code> is a <code>PTCell</code> object, <code>value</code>
should be a <code>vector</code> of four <code>raw</code> values (conform specifications
provided at the documentation of the <code><a href="#topic+PTCell-class">PTCell</a></code>).
</p>
<p>If <code>x</code> is a <code>PTTrack</code> object, <code>value</code>
should be a 64 by 4 <code>matrix</code> holding <code>raw</code> values (conform specifications
provided at the documentation of the <code><a href="#topic+PTTrack-class">PTTrack</a></code>).
</p>
<p>If <code>x</code> is a <code>PTPattern</code> object, <code>value</code>
should be a 64 by 16 <code>matrix</code> holding <code>raw</code> values (conform specifications
provided at the documentation of the <code><a href="#topic+PTPattern-class">PTPattern</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+PTCell">PTCell</a></code> is an element of a <code><a href="#topic+PTTrack">PTTrack</a></code> which
in turn is an element of a <code><a href="#topic+PTPattern">PTPattern</a></code>. A <code><a href="#topic+PTPattern">PTPattern</a></code>
tells a tracker which sample to play at which frequency on which of the
four audio channels and with which effects. A <code><a href="#topic+PTCell">PTCell</a></code> in essence
holds all this information as described at the documentation of
the <code><a href="#topic+PTCell-class">PTCell</a></code>.
</p>
<p>Data in these objects are stored in these objects in a <code>raw</code> form,
to save working memory and to comply to the ProTracker file specifications
(see documentation of each of these classes for more details). This method
can be used to extract and replace raw data.
</p>
<p>The <code>PTModule</code> object has a more complex structure but can also be converted
into raw data (the way it would be stored in a ProTracker module file). However,
this object cannot be replaced by raw data.
</p>


<h3>Value</h3>

<p>For <code>as.raw</code>, a length 4 vector, 64 by 4 matrix or a 64 by 16
matrix of <code>raw</code> data is returned, when x is of class <code>PTCell</code>,
<code>PTTrack</code> or <code>PTPattern</code>, respectively.
</p>
<p>If <code>x</code> is a <code>PTModule</code> object, the <code>raw</code> data returned will
have the same format as the ProTracker file format.
</p>
<p>For <code style="white-space: pre;">&#8288;as.raw&lt;-&#8288;</code>, a copy of object <code>x</code> is returned in which the
<code>raw</code> data is replaced by <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Get the raw data of the PTCell at
## pattern #1, track #1 and row #1
## of mod.intro:
as.raw(PTCell(mod.intro, 1, 1, 1))

## idem for PTTrack #1 of pattern #1:
as.raw(PTTrack(mod.intro, 1, 1))

## idem for PTPattern #1:
as.raw(PTPattern(mod.intro, 1))

## replace raw data of PTCell 1, 1, 1
## with that of PTCell 2, 1, 1:
as.raw(PTCell(mod.intro, 1, 1, 1)) &lt;-
  as.raw(PTCell(mod.intro, 2, 1, 1))

</code></pre>

<hr>
<h2 id='clearSamples'>Clear all samples from module</h2><span id='topic+clearSamples'></span><span id='topic+clearSamples+2CPTModule-method'></span>

<h3>Description</h3>

<p>Remove all <code><a href="#topic+PTSample">PTSample</a></code>s from a <code><a href="#topic+PTModule">PTModule</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
clearSamples(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearSamples_+3A_mod">mod</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object from which all samples needs
to be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conform the original ProTracker, this method removes all patterns
<code><a href="#topic+PTSample">PTSample</a></code>s from a module. You keep all patterns
(<code><a href="#topic+PTPattern">PTPattern</a></code>) and <code><a href="#topic+patternOrder">patternOrder</a></code> info.
</p>


<h3>Value</h3>

<p>Returns a copy of object <code>mod</code> in which all samples are removed.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mod.intro)

## 'clear.mod' is a copy of 'mod.intro' without the
## samples. It still holds all pattern tables and
## pattern order info.
clear.mod &lt;- clearSamples(mod.intro)
</code></pre>

<hr>
<h2 id='clearSong'>Clear all pattern info from module</h2><span id='topic+clearSong'></span><span id='topic+clearSong+2CPTModule-method'></span>

<h3>Description</h3>

<p>Remove all patterns (<code><a href="#topic+PTPattern">PTPattern</a></code>) and <code><a href="#topic+patternOrder">patternOrder</a></code>
info from a <code><a href="#topic+PTModule">PTModule</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
clearSong(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearSong_+3A_mod">mod</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object from which all pattern (order)
info needs to be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conform the original ProTracker, this method removes all patterns
(<code><a href="#topic+PTPattern">PTPattern</a></code>) and <code><a href="#topic+patternOrder">patternOrder</a></code>
info from a module. You keep the audio <code><a href="#topic+PTSample">PTSample</a></code>s.
</p>


<h3>Value</h3>

<p>Returns a copy of object <code>mod</code> in which all pattern (order)
info is removed.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mod.intro)

## 'clear.mod' is a copy of 'mod.intro' without the
## pattern (order) info. It still has the audio samples.
clear.mod &lt;- clearSong(mod.intro)
</code></pre>

<hr>
<h2 id='deletePattern'>Remove a PTPattern table from a PTModule object</h2><span id='topic+deletePattern'></span><span id='topic+deletePattern+2CPTModule+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This method removes a <code><a href="#topic+PTPattern">PTPattern</a></code> from a
<code><a href="#topic+PTModule">PTModule</a></code> object and updates the
<code><a href="#topic+patternOrder">patternOrder</a></code> table accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule,numeric'
deletePattern(x, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deletePattern_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> from which a
<code><a href="#topic+PTPattern">PTPattern</a></code> needs to be removed.</p>
</td></tr>
<tr><td><code id="deletePattern_+3A_index">index</code></td>
<td>
<p>A <code>numeric</code> index of the <code><a href="#topic+PTPattern">PTPattern</a></code>
table that needs to be removed. The index should be between 1 and
<code><a href="#topic+patternLength">patternLength</a></code>. It's not possible to delete multiple
patterns simultaneously with this method. A <code><a href="#topic+PTModule">PTModule</a></code>
should always hold at least 1 pattern table, therefore, the last
<code><a href="#topic+PTPattern">PTPattern</a></code> table cannot be deleted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method safely removes a <code><a href="#topic+PTPattern">PTPattern</a></code> from a
<code><a href="#topic+PTModule">PTModule</a></code> object, guarding the validity of the
<code><a href="#topic+PTModule">PTModule</a></code> object. It therefore also updates
the <code><a href="#topic+patternOrder">patternOrder</a></code> table, by renumbering the indices
listed there. The index of the removed object is replaced with a zero
in the <code><a href="#topic+patternOrder">patternOrder</a></code> table.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PTModule">PTModule</a></code> from which the selected
<code><a href="#topic+PTPattern">PTPattern</a></code> is deleted.
</p>


<h3>Note</h3>

<p>As per ProTracker specification, the pattern indices
stored in the <code><a href="#topic+PTModule">PTModule</a></code> and obtained with
<code><a href="#topic+patternOrder">patternOrder</a></code> start at 0. Whereas R starts indexing at 1.
Beware of this discrepancy.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")
print(mod.intro)

## delete pattern #2 from mod.intro:

mod.intro &lt;- deletePattern(mod.intro, 2)
print(mod.intro)

</code></pre>

<hr>
<h2 id='effect'>Extract or replace effect/trigger codes</h2><span id='topic+effect'></span><span id='topic+effect+2CPTCell-method'></span><span id='topic+effect+3C-'></span><span id='topic+effect+3C-+2CPTCell+2Ccharacter-method'></span>

<h3>Description</h3>

<p>The 3 right-hand symbols of a <code>character</code> representation of a
<code><a href="#topic+PTCell">PTCell</a></code> represent an effect or trigger code. This method
can be used to extract or replace this code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
effect(x)

## S4 replacement method for signature 'PTCell,character'
effect(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect_+3A_x">x</code></td>
<td>
<p>A <code>PTCell</code> from which the effect code needs to be extracted.</p>
</td></tr>
<tr><td><code id="effect_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string containing a three hexadecimal digit
effect code. All hexadecimal codes are accepted, not all will produce
meaningful effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a <code><a href="#topic+PTCell">PTCell</a></code> is represented by a <code>character</code> string,
the last three symbols represent a hexadecimal effect or trigger code.
In general the first of the three symbols indicates a type of effect or
trigger, whereas the latter two generally indicate a magnitude or a
position for effects and triggers.
</p>
<p>Effects can for instance be volume or frequency slides. The codes can
also affect the module tempo or cause position jumps.
</p>
<p>When replacing this code, all three digit hexadecimal <code>character</code>
strings are accepted, although not all codes will represent a valid
effect or trigger. See
<a href="https://wiki.openmpt.org/Manual:_Effect_Reference#MOD_Effect_Commands">https://wiki.openmpt.org/Manual:_Effect_Reference#MOD_Effect_Commands</a>
for a valid list of effect codes.
</p>


<h3>Value</h3>

<p>For <code>effect</code>, a <code>character</code> string with the three hexadecimal
digit effect code will be returned.
</p>
<p>For <code style="white-space: pre;">&#8288;effect&lt;-&#8288;</code>, a copy of object <code>x</code> with effect code <code>value</code>
will be returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other cell.operations: 
<code><a href="#topic+PTCell-class">PTCell-class</a></code>,
<code><a href="#topic+PTCell-method">PTCell-method</a></code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+sampleNumber">sampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## the PTCell in row #1, of pattern #1, track #1
## has effect code "A08", which is a volume slide down (0xA)
## with speed 0x8:
effect(PTCell(mod.intro, 1, 1, 1))

## this is how you can change an effect:
cell &lt;- PTCell("C-2 01 000")
effect(cell) &lt;- "C20"

## the above expression sets the volume (effect 0xC)
## to 50% (0x20 which is halve of the maximum 0x40)
</code></pre>

<hr>
<h2 id='fineTune'>Fine tune a PTSample</h2><span id='topic+fineTune'></span><span id='topic+fineTune+2CPTSample-method'></span><span id='topic+fineTune+3C-'></span><span id='topic+fineTune+3C-+2CPTSample+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extract or replace the fine tune value of a <code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
fineTune(sample)

## S4 replacement method for signature 'PTSample,numeric'
fineTune(sample) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fineTune_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> for which the fine tune value
needs to be extracted or replace.</p>
</td></tr>
<tr><td><code id="fineTune_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> value ranging from -8 up to 7, representing
the fine tune.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PTSample">PTSample</a></code>s can be tuned with their fine tune values.
The values range from -8 up to 7 and affect the playback sample rate of
specific notes (see <code><a href="#topic+period_table">period_table</a></code>). This method can be used
to extract this value, or to safely replace it.
</p>


<h3>Value</h3>

<p>For <code>fineTune</code> the fine tune value, represented by an
<code>integer</code> value ranging from -8 up to 7, is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;fineTune&lt;-&#8288;</code> A <code><a href="#topic+PTSample">PTSample</a></code> <code>sample</code>, updated
with the fine tune <code>value</code>, is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the finetune of the first sample of mod.intro:

fineTune(PTSample(mod.intro, 1))

## Let's tweak the finetune of the first sample of
## mod.intro to -1:

fineTune(PTSample(mod.intro, 1)) &lt;- -1

</code></pre>

<hr>
<h2 id='fix.PTModule'>Attempt to fix PTModule to ProTracker specs</h2><span id='topic+fix.PTModule'></span><span id='topic+fix.PTModule+2CPTModule+2Clogical-method'></span><span id='topic+fix.PTModule+2CPTModule+2Cmissing-method'></span>

<h3>Description</h3>

<p>Try to fix non-valid <code><a href="#topic+PTModule">PTModule</a></code> objects in order to meet with
ProTracker specs such that they pass validity tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule,logical'
fix.PTModule(mod, verbose = T)

## S4 method for signature 'PTModule,missing'
fix.PTModule(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.PTModule_+3A_mod">mod</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object which needs fixing.</p>
</td></tr>
<tr><td><code id="fix.PTModule_+3A_verbose">verbose</code></td>
<td>
<p>With the default value of <code>TRUE</code>, the method
prints a progress report to the <code><a href="base.html#topic+sink">sink</a></code>. When set
to <code>FALSE</code>, the progress report is suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost any file can be read as a <code><a href="#topic+PTModule">PTModule</a></code> object (using
<code><a href="#topic+read.module">read.module</a></code>) when validity is ignored and no unexpected end
of file is reached. This package's object validity are very strickly testing
for compliance with ProTracker specifications. As many modules could have
been created with other trackers (which often will play just as well in
ProTracker) it is desirable to convert such object to ProTracker specs.
This method attempts to do so, by fixing each aspect, that is also tested
in the object validity functions. Note that the attempts are no guarantee for success,
and &lsquo;fixed&rsquo; modules may not play as intended.
</p>


<h3>Value</h3>

<p>Returns a copy of object <code>mod</code> in which all non-conformaties are
attempted to be fixed. (Attempted) fixes are listed printed
in the progress report.
</p>


<h3>Note</h3>

<p>In the current version, pattern data itself is not checked for
non-conformaties nor is it fixed.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("mod.intro")

## Let's do something illegal and destroy mod.intro:
mod.intro@pattern.order &lt;- mod.intro@pattern.order[1:9]

## We should have used the 'patternOrder'-method to
## change the pattern order. Now we have broken the
## object:
validObject(mod.intro, TRUE)

## No worries, we can fix it:
mod.intro &lt;- fix.PTModule(mod.intro)

## See, it's all OK again:
validObject(mod.intro, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='funk_table'>ProTracker Funk Table</h2><span id='topic+funk_table'></span>

<h3>Description</h3>

<p>Small list of numbers used by an obscure audio effect in ProTracker
</p>


<h3>Format</h3>

<p>A <code>numeric</code> <code>vector</code> of length 16 holding values to be
used in ProTracker funk repeat effects.
</p>


<h3>Details</h3>

<p>This dataset is included for completeness sake. It is not yet used by any
class, method or function in the <a href="#topic+ProTrackR-package">ProTrackR</a> package. It may
very well be obsolete for recent ProTracker versions.
</p>


<h3>References</h3>

<p><a href="https://fossies.org/linux/uade/amigasrc/players/tracker/eagleplayers/mod32_protracker/PTK_versions.txt">https://fossies.org/linux/uade/amigasrc/players/tracker/eagleplayers/mod32_protracker/PTK_versions.txt</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("funk_table")
</code></pre>

<hr>
<h2 id='loopLength'>The loop length of a PTSample</h2><span id='topic+loopLength'></span><span id='topic+loopLength+2CPTSample-method'></span><span id='topic+loopLength+3C-'></span><span id='topic+loopLength+3C-+2CPTSample-method'></span>

<h3>Description</h3>

<p>Extract or replace the loop length of a <code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
loopLength(sample)

## S4 replacement method for signature 'PTSample'
loopLength(sample) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopLength_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> for which the loop length
needs to be extracted or replace.</p>
</td></tr>
<tr><td><code id="loopLength_+3A_value">value</code></td>
<td>
<p>An even <code>numeric</code> value giving the loop length in
samples ranging from 2 up to 131070 (It can be 0 when the sample is
empty). The sum of the <code><a href="#topic+loopStart">loopStart</a></code> and
<code><a href="#topic+loopLength">loopLength</a></code> should not exceed the <code><a href="#topic+sampleLength">sampleLength</a></code>.
</p>
<p>Use a <code>value</code> of either <code>character</code> <code>"off"</code> or <code>logical</code>
<code>FALSE</code>, in order to turn off the loop all together.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PTSample">PTSample</a></code>s can have loops, marked by a starting position
and length of the loop (in samples), for more details see the
<code><a href="#topic+PTSample-class">PTSample</a></code>. This method can be used to extract
the loop length or safely replace its value.
</p>


<h3>Value</h3>

<p>For <code>loopLength</code> the loop length (in samples), represented by
an even <code>integer</code> value ranging from 0 up to 131070, is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;loopLength&lt;-&#8288;</code> A <code><a href="#topic+PTSample">PTSample</a></code> <code>sample</code>, updated
with the loop length <code>value</code>, is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other loop.methods: 
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>
</p>
<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the loop length of the
## first sample of mod.intro:

loopLength(PTSample(mod.intro, 1))

## Let's change the length of
## the loop to 200

loopLength(PTSample(mod.intro, 1)) &lt;- 200

## Let's turn off the loop all together:

loopLength(PTSample(mod.intro, 1)) &lt;- FALSE

</code></pre>

<hr>
<h2 id='loopSample'>Looped waveform of a sample</h2><span id='topic+loopSample'></span><span id='topic+loopSample+2CPTSample-method'></span>

<h3>Description</h3>

<p>Generate a looped <code><a href="#topic+waveform">waveform</a></code> of a <code><a href="#topic+PTSample">PTSample</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
loopSample(sample, times, n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopSample_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> object that needs to be looped.</p>
</td></tr>
<tr><td><code id="loopSample_+3A_times">times</code></td>
<td>
<p>A positive <code>integer</code> value indicating the number of
times a sample loop should be repeated. This argument is ignored if
<code>n_samples</code> is specified.</p>
</td></tr>
<tr><td><code id="loopSample_+3A_n_samples">n_samples</code></td>
<td>
<p>A positive <code>integer</code> value indicating the desired length
of the looped waveform in number of samples. This argument overrules the
<code>times</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For playing routines, it can be useful to generate repeats of a sample loop.
This method returns the waveform of a <code><a href="#topic+PTSample">PTSample</a></code> where the
loop is repeated <code style="white-space: pre;">&#8288;times`' times or has a length of &#8288;</code>n_samples''.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+waveform">waveform</a></code> represented by a <code>numeric</code>
<code>vector</code> of values ranging from 0 up to 255. Has a length of
<code>n_samples</code> when that argument is specified.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other loop.methods: 
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>
</p>
<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Loop sample number 4 10 times:
wform &lt;- loopSample(PTSample(mod.intro, 4), times = 10)
plot(wform, type = "l")

## Loop sample number 4, such that its
## final length is 5000 samples:
wform &lt;- loopSample(PTSample(mod.intro, 4), n_samples = 5000)
plot(wform, type = "l")

</code></pre>

<hr>
<h2 id='loopStart'>The loop start position of a PTSample</h2><span id='topic+loopStart'></span><span id='topic+loopStart+2CPTSample-method'></span><span id='topic+loopStart+3C-'></span><span id='topic+loopStart+3C-+2CPTSample-method'></span>

<h3>Description</h3>

<p>Extract or replace the loop start position of a <code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
loopStart(sample)

## S4 replacement method for signature 'PTSample'
loopStart(sample) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopStart_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> for which the loop start position
needs to be extracted or replace.</p>
</td></tr>
<tr><td><code id="loopStart_+3A_value">value</code></td>
<td>
<p>An even <code>numeric</code> value giving the loop starting position in
samples ranging from 0 up to 131070. The sum of the <code><a href="#topic+loopStart">loopStart</a></code> and
<code><a href="#topic+loopLength">loopLength</a></code> should not exceed the <code><a href="#topic+sampleLength">sampleLength</a></code>.
</p>
<p>Use a <code>value</code> of either <code>character</code> <code>"off"</code> or <code>logical</code>
<code>FALSE</code>, in order to turn off the loop all together.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PTSample">PTSample</a></code>s can have loops, marked by a starting position
and length of the loop (in samples), for more details see the
<code><a href="#topic+PTSample-class">PTSample</a></code>. This method can be used to extract
the loop starting position or safely replace its value.
</p>


<h3>Value</h3>

<p>For <code>loopStart</code> the loop start position (in samples), represented by
an even <code>integer</code> value ranging from 0 up to 131070, is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;loopStart&lt;-&#8288;</code> A <code><a href="#topic+PTSample">PTSample</a></code> <code>sample</code>, updated
with the loop start position &ldquo;value'', is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>
<p>Other loop.methods: 
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the loop start position of the
## first sample of mod.intro:

loopStart(PTSample(mod.intro, 1))

## Let's change the starting position of
## the loop to 500

loopStart(PTSample(mod.intro, 1)) &lt;- 500

## Let's turn off the loop all together:

loopStart(PTSample(mod.intro, 1)) &lt;- FALSE

</code></pre>

<hr>
<h2 id='loopState'>Get PTSample loop state</h2><span id='topic+loopState'></span><span id='topic+loopState+2CPTSample-method'></span>

<h3>Description</h3>

<p>Determines whether a loop is specified for a <code><a href="#topic+PTSample">PTSample</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
loopState(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopState_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> object for which the loop state needs
to be determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loop state is not explicitly stored in a <code><a href="#topic+PTSample">PTSample</a></code> object.
It can be derived from the <code><a href="#topic+loopStart">loopStart</a></code> position and
<code><a href="#topic+loopLength">loopLength</a></code>. This method is provided as a convenient method
to get the state. Use either <code><a href="#topic+loopStart">loopStart</a></code> or <code><a href="#topic+loopLength">loopLength</a></code>
to change the state.
</p>


<h3>Value</h3>

<p>Returns a <code>logical</code> value indicating whether a loop is (<code>TRUE</code>)
or isn't (<code>FALSE</code>) specified for the <code>sample</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other loop.methods: 
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>
</p>
<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Get the loop status of sample number 1
## (it has a loop):
loopState(PTSample(mod.intro, 1))

## Get the loop status of sample number 2
## (it has no loop):
loopState(PTSample(mod.intro, 2))
</code></pre>

<hr>
<h2 id='mod.intro'>Example of a PTModule object</h2><span id='topic+mod.intro'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+PTModule">PTModule</a></code> object included in the package as example.
</p>


<h3>Format</h3>

<p>A <code><a href="#topic+PTModule">PTModule</a></code> object containing 4
<code><a href="#topic+PTSample">PTSample</a></code> objects (and 27 empty <code>PTSample</code>
objects, adding up to the 31 samples a <code>PTModule</code> should hold) and 4
<code><a href="#topic+PTPattern">PTPattern</a></code> objects.
</p>


<h3>Details</h3>

<p>This PTModule object is based on an original ProTracker module file
I've composed in the late nineteen nineties. It is used as example for many
of the <a href="#topic+ProTrackR-package">ProTrackR</a> methods and you can use it to test your own
code. It can also be exported back to the original ProTracker module file
by using <code><a href="#topic+write.module">write.module</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")
print(mod.intro)
plot(mod.intro)

## Not run: 
playSample(mod.intro)

## Save as an original module file,
## which can be played with ProTracker (or several modern audio players):
write.module(mod.intro, "intro.mod")

## End(Not run)
</code></pre>

<hr>
<h2 id='modArchive'>ModArchive helper functions</h2><span id='topic+modArchive'></span><span id='topic+modArchive.info'></span><span id='topic+modArchive.download'></span><span id='topic+modArchive.search.mod'></span><span id='topic+modArchive.search.genre'></span><span id='topic+modArchive.search.hash'></span><span id='topic+modArchive.search.artist'></span><span id='topic+modArchive.random.pick'></span><span id='topic+modArchive.view.by'></span><span id='topic+modArchive.request.count'></span><span id='topic+modArchive.max.requests'></span>

<h3>Description</h3>

<p><a href="https://ModArchive.org">https://ModArchive.org</a> is on of the largest online archive of module files. These functions
will assist in accessing this archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modArchive.info(mod.id, api.key)

modArchive.download(mod.id, ...)

modArchive.search.mod(
  search.text,
  search.where = c("filename_or_songtitle", "filename_and_songtitle", "filename",
    "songtitle", "module_instruments", "module_comments"),
  format.filter = c("unset", "669", "AHX", "DMF", "HVL", "IT", "MED", "MO3", "MOD",
    "MTM", "OCT", "OKT", "S3M", "STM", "XM"),
  size.filter = c("unset", "0-99", "100-299", "300-599", "600-1025", "1025-2999",
    "3072-6999", "7168-100000"),
  genre.filter = "deprecated",
  page,
  api.key
)

modArchive.request.count(api.key)

modArchive.max.requests(api.key)

modArchive.view.by(
  view.query,
  view.by = c("view_by_list", "view_by_rating_comments", "view_by_rating_reviews",
    "view_modules_by_artistid", "view_modules_by_guessed_artist"),
  format.filter = c("unset", "669", "AHX", "DMF", "HVL", "IT", "MED", "MO3", "MOD",
    "MTM", "OCT", "OKT", "S3M", "STM", "XM"),
  size.filter = c("unset", "0-99", "100-299", "300-599", "600-1025", "1025-2999",
    "3072-6999", "7168-100000"),
  page,
  api.key
)

modArchive.search.genre(
  genre.filter = c("unset", "Alternative", "Gothic", "Grunge", "Metal - Extreme",
    "Metal (general)", "Punk", "Chiptune", "Demo Style", "One Hour Compo", "Chillout",
    "Electronic - Ambient", "Electronic - Breakbeat", "Electronic - Dance",
    "Electronic - Drum and Bass", "Electronic - Gabber", "Electronic - Hardcore",
    "Electronic - House", "Electronic - IDM", "Electronic - Industrial",
    "Electronic - Jungle", "Electronic - Minimal", "Electronic - Other",
    "Electronic - Progressive", "Electronic - Rave", "Electronic - Techno", 
    
    "Electronic (general)", "Trance - Acid", "Trance - Dream", "Trance - Goa",
    "Trance - Hard", "Trance - Progressive", "Trance - Tribal", "Trance (general)",
    "Big Band", "Blues", "Jazz - Acid", "Jazz - Modern", "Jazz (general)", "Swing",
    "Bluegrass", "Classical", "Comedy", "Country", "Experimental", "Fantasy", "Folk",
    "Fusion", "Medieval", "New Ages", "Orchestral", "Other", "Piano", "Religious",
    "Soundtrack", "Spiritual", "Video Game", "Vocal Montage", "World", "Ballad", "Disco",
    "Easy Listening", 
     "Funk", "Pop - Soft", "Pop - Synth", "Pop (general)",
    "Rock - Hard", "Rock - Soft", "Rock (general)", "Christmas", "Halloween", "Hip-Hop",
    "R and B", "Reggae", "Ska", "Soul"),
  format.filter = c("unset", "669", "AHX", "DMF", "HVL", "IT", "MED", "MO3", "MOD",
    "MTM", "OCT", "OKT", "S3M", "STM", "XM"),
  size.filter = c("unset", "0-99", "100-299", "300-599", "600-1025", "1025-2999",
    "3072-6999", "7168-100000"),
  page,
  api.key
)

modArchive.search.artist(search.artist, page, api.key)

modArchive.search.hash(search.hash, api.key)

modArchive.random.pick(
  genre.filter = c("Alternative", "Gothic", "Grunge", "Metal - Extreme",
    "Metal (general)", "Punk", "Chiptune", "Demo Style", "One Hour Compo", "Chillout",
    "Electronic - Ambient", "Electronic - Breakbeat", "Electronic - Dance",
    "Electronic - Drum and Bass", "Electronic - Gabber", "Electronic - Hardcore",
    "Electronic - House", "Electronic - IDM", "Electronic - Industrial",
    "Electronic - Jungle", "Electronic - Minimal", "Electronic - Other",
    "Electronic - Progressive", "Electronic - Rave", "Electronic - Techno",
    "Electronic (general)", 
     "Trance - Acid", "Trance - Dream", "Trance - Goa",
    "Trance - Hard", "Trance - Progressive", "Trance - Tribal", "Trance (general)",
    "Big Band", "Blues", "Jazz - Acid", "Jazz - Modern", "Jazz (general)", "Swing",
    "Bluegrass", "Classical", "Comedy", "Country", "Experimental", "Fantasy", "Folk",
    "Fusion", "Medieval", "New Ages", "Orchestral", "Other", "Piano", "Religious",
    "Soundtrack", "Spiritual", "Video Game", "Vocal Montage", "World", "Ballad", "Disco",
    "Easy Listening", "Funk", "Pop - Soft", 
     "Pop - Synth", "Pop (general)",
    "Rock - Hard", "Rock - Soft", "Rock (general)", "Christmas", "Halloween", "Hip-Hop",
    "R and B", "Reggae", "Ska", "Soul"),
  format.filter = c("unset", "669", "AHX", "DMF", "HVL", "IT", "MED", "MO3", "MOD",
    "MTM", "OCT", "OKT", "S3M", "STM", "XM"),
  size.filter = c("unset", "0-99", "100-299", "300-599", "600-1025", "1025-2999",
    "3072-6999", "7168-100000"),
  api.key
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modArchive_+3A_mod.id">mod.id</code></td>
<td>
<p>An <code>integer</code> code used as module identifier in the ModArchive database.
A <code>mod.id</code> can be obtained by performing a search with <code>modArchive.search.mod</code>.
When downloading a module, make sure that the identifier represents a MOD file, as
other types will result in an error.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_api.key">api.key</code></td>
<td>
<p>Most ModArchive functions require a personal secret API key. This key can
be obtained from the ModArchive forum. See &lsquo;ModArchive API Key&rsquo; section below for instructions
on how to obtain such a key.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_...">...</code></td>
<td>
<p>arguments that are passed on to <code><a href="#topic+read.module">read.module</a></code>.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_search.text">search.text</code></td>
<td>
<p>A <code>character</code> string to be used as terms to search
in the ModArchive.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_search.where">search.where</code></td>
<td>
<p>A <code>character</code> string indicating where in the module files
to search for the <code>search.text</code>. See usage section for the available options.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_format.filter">format.filter</code></td>
<td>
<p>File format filter to be used in a search in the ModArchive.
See the usage section for all possible options. Default is &quot;unset&quot; (meaning that
it will search for any file format). Note that only the &lsquo;MOD&rsquo; format
is supported by this package.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_size.filter">size.filter</code></td>
<td>
<p>File size filter to be used in a search in the ModArchive.
Needs to be a <code>character</code> string representation of a file size
category as specified on ModArchive.org.
See the usage section for all possible options. Default is &quot;unset&quot; (meaning that
it will search for any file size). Note that the maximum file size of a
module is approximately 4068 kilobytes, meaning that the largest file size
category is irrelevant for &lsquo;MOD&rsquo; files. Also note that the category names are
inconsistant, these are the literal catagories used by ModArchive</p>
</td></tr>
<tr><td><code id="modArchive_+3A_genre.filter">genre.filter</code></td>
<td>
<p>Genre filter to be used in some of the overviews from the ModArchive.
Needs to be a <code>character</code> string representation of a genre
as specified on ModArchive.org.
See the usage section for all possible options.
This argument is deprecated in the function <code>modArchive.search</code> since ProTrackR
version 0.3.4, other functions will still accept this argument.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_page">page</code></td>
<td>
<p>Many of the ModArchive returns paginated tables. When this argument
is omitted, the first page is returned. Use an integer value to return a specific
page. The total number of pages of a search or view is returned as an attribute
to the returned <a href="base.html#topic+data.frame">base::data.frame</a>.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_view.query">view.query</code></td>
<td>
<p>A query to be used in combination with the <code>view.by</code>
argument. Use the queries in combination with <code>view.by</code> as follows:
</p>

<ul>
<li> <p><code>view_by_list</code>: Use a single capital starting letter to browse
modules by name
</p>
</li>
<li> <p><code>view_by_rating_comments</code>: Provide a (user) rating by which you
wish to browse the modules
</p>
</li>
<li> <p><code>view_by_rating_reviews</code>: Provide a (reviewer) rating by which you
wish to browse the modules
</p>
</li>
<li> <p><code>view_modules_by_artistid</code>: Provide an artist id number
for whom you wish to browse his/her modules
</p>
</li>
<li> <p><code>view_modules_by_guessed_artist</code>: Provide an artist guessed
name for whom you wish to browser his/her modules
</p>
</li></ul>
</td></tr>
<tr><td><code id="modArchive_+3A_view.by">view.by</code></td>
<td>
<p>Indicate how the <code>modArchive.view.by</code> function should sort
the overview tables of modules. See &lsquo;usage&rsquo; section for the possible options.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_search.artist">search.artist</code></td>
<td>
<p>A character string representing the (guessed) artist name
or id number that you ar looking for in the archive.</p>
</td></tr>
<tr><td><code id="modArchive_+3A_search.hash">search.hash</code></td>
<td>
<p>The MD5 hash code of the specific module you are looking
for. See <a href="https://modarchive.org/?xml-api-usage-level3">https://modarchive.org/?xml-api-usage-level3</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>modArchive.info</code> function will retrieve info on a specific module from the
ModArchive. The <code>modArchive.search.mod</code>, <code>modArchive.search.genre</code> and
<code>modArchive.search.hash</code> functions can be used to find specific modules
in the archive. Use <code>modArchive.random.pick</code> to get module info on a random
module in the archive.
</p>
<p>Use the <code>modArchive.view.by</code>
function to browse the archive by specific aspects.
Note that the ModArchive also contains file formats other than ProTracker's MOD format.
This package can only handle the MOD format.
</p>
<p>The <code>modArchive.download</code> function will download a module from the archive.
</p>
<p>Use <code>modArchive.search.artist</code> to find artist details in the archive.
</p>
<p>Use <code>modArchive.request.count</code> to determine how many request you have
made in the current month with the specified key (see <code style="white-space: pre;">&#8288;ModArchive API key' section for details). Use &#8288;</code>modArchive.max.requests<code style="white-space: pre;">&#8288;to determine how many request you are allowed to make each month with the provided key (see&#8288;</code>ModArchive API key'
section for details).
</p>


<h3>Value</h3>

<p><code>modArchive.info</code>, <code>modArchive.search.genre</code>,
<code>modArchive.search.hash</code>, <code>modArchive.random.pick</code> and
<code>modArchive.view.by</code> will return a <a href="base.html#topic+data.frame">data.frame</a>
containing information on modules in the ModArchive. Note that this
data.frame is formatted differently since ProTrackR 0.3.4, which
may cause backward compatibility issues.
</p>
<p><code>modArchive.download</code> will download a module and return it as a
<code><a href="#topic+PTModule">PTModule</a></code> object.
</p>
<p><code>modArchive.search.artist</code>  will return a <code><a href="base.html#topic+data.frame">data.frame</a></code>
containing information on artists on the ModArchive.
</p>
<p><code>modArchive.request.count</code> returns the number of ModArchive API request
that are left for this month, for the provided key.
</p>
<p><code>modArchive.max.requests</code> returns the maximum monthly requests for the
provided key.
</p>


<h3>ModArchive API key</h3>

<p>Since ProTrackR 0.3.4, the ModArchive helper functions have changed. In earlier
version, a labile html scraper was used, in 0.3.4 and later, this is replaced by
functions that more robustly use the Application Programming Interface (API)
provided by ModArchive. There are some downsides to this new approach: a
personal API key needs to be obtained from the ModArchive team; and the
ProTrackR package relies on yet another package (XML)
to parse the XML files that are returned by the API.
</p>
<p>So why is this switch? Well, first of all, this approach is better supported
by ModArchive. The personal API key is used to avoid excessive access by imposing
a monthly request limit (keep in mind that ModArchive provides free services and is
run by volunteers). The upside is that the XML files are a lot lighter than the
html files returned by the regular website. Therefore, the new functions are faster,
and they reduce the load on the ModArchive servers. The XML files also allow for
easier access to more of the ModArchive functionality as implemented in the
ModArchive helper functions described here.
</p>
<p>So how do you get your personal API key? First, you need to register at the
<a href="https://modarchive.org/forums/">ModArchive Forums</a>. Then follow the
instructions provided in this <a href="https://modarchive.org/forums/index.php?topic=1950.0">topic</a>
on the forum. For more info, see also the <a href="https://modarchive.org/?xml-api">API page</a>
on ModArchive.
</p>
<p>If you want to search for module files without an API key, one could make use of
to the <a href="#topic+modLand">modLand</a> collection instead.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## most of the example below will fail as they require a
## real modArchive API key. The key used in these example
## is just a dummy. See details on how to get a key
## in the section 'ModArchive API Key' in the manual.

## Search for the module that is also used as
## an example in this package:
search.results &lt;- modArchive.search.mod("*_-_intro.mod",
                                        size.filter = "0-99",
                                        format.filter = "MOD",
                                        api.key = "&lt;your key here&gt;")

## apparently there are multiple modules in
## database that have '_-_intro' in their
## file name or title. Select the wanted
## module from the list (the one with the
## word 'protrackr' in the instrument names):
search.select &lt;- subset(search.results,
                        grepl("protrackr", search.results$instruments))

## get the same details, but now only for
## the specific module based on its ModArchive ID:
modArchive.info(search.select$id, api.key = "&lt;your key here&gt;")

## download the selected module from ModArchive.org:
mod &lt;- modArchive.download(search.select$id)

## here's a randomly picked module from the ModArchive:
info.random &lt;- modArchive.random.pick(api.key = "&lt;your key here&gt;")

## use modArchive.view.by to list the 2nd page
## of MOD files that start with the letter 'A'
info.list  &lt;- modArchive.view.by("A", "view_by_list", "MOD",
                                 page = 2,
                                 api.key = "&lt;your key here&gt;")

## list the modules of the artist with id number 89200:
artist.mods &lt;- modArchive.view.by("89200", "view_modules_by_artistid",
                                  format.filter = "MOD",
                                  api.key = "&lt;your key here&gt;")

## here's how you can list MOD files of a
## specific genre:
list.genre  &lt;- modArchive.search.genre("Chiptune", "MOD",
                                       api.key = "&lt;your key here&gt;")

## get module info for a specific hash code
mod.hash    &lt;- modArchive.search.hash("8f80bcab909f700619025bd7f2975749",
                                      "&lt;your key here&gt;")

## find modarchive artist info, search for artist name
## or artist id:
artist.list &lt;- modArchive.search.artist("89200",
                                        api.key = "&lt;your key here&gt;")

## How many requests did I make this month?:
modArchive.request.count("&lt;your key here&gt;")

## How many requests am I allowed to make each month?:
modArchive.max.requests("&lt;your key here&gt;")

## End(Not run)
</code></pre>

<hr>
<h2 id='modLand'>ModLand helper functions</h2><span id='topic+modLand'></span><span id='topic+modLand.search.mod'></span><span id='topic+modLand.download.mod'></span>

<h3>Description</h3>

<p><a href="https://modland.com">https://modland.com</a> is on of the largest online archive of module files. These functions
will assist in accessing this archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modLand.search.mod(search.text)

modLand.download.mod(
  format,
  author,
  title,
  mirror = c("modland.com", "ftp.modland.com", "antarctica.no", "ziphoid.com",
    "exotica.org.uk"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modLand_+3A_search.text">search.text</code></td>
<td>
<p>A single length <code>character</code> vector, containing
search text. Provided search pattern is searched in all fields (mod format,
author and title). Prefixes can be added to keywords for inclusive or exclusive
searches. For details see <a href="https://www.exotica.org.uk/wiki/Modland#Searching">https://www.exotica.org.uk/wiki/Modland#Searching</a>.
Note that modLand contains a wide range of tracker files, only mod-files
are supported by the <code>ProTrackR</code> package. It is therefore advisable to add the
keyword &lsquo;mod&rsquo; to the search string.</p>
</td></tr>
<tr><td><code id="modLand_+3A_format">format</code></td>
<td>
<p>A single length <code>character</code> vector, indicating the
tracker file format. &ldquo;Protracker'' is the option that is most likely to work in this package.</p>
</td></tr>
<tr><td><code id="modLand_+3A_author">author</code></td>
<td>
<p>A single length <code>character</code> vector, indicating the
module author name. Can be obtained from a <code>modLand.search.mod</code>.</p>
</td></tr>
<tr><td><code id="modLand_+3A_title">title</code></td>
<td>
<p>A single length <code>character</code> vector, indicating the
module title. Can be obtained from a <code>modLand.search.mod</code>.</p>
</td></tr>
<tr><td><code id="modLand_+3A_mirror">mirror</code></td>
<td>
<p>A single length <code>character</code> vector. Should contain one of the
mirrors listed in the &lsquo;usage&rsquo; section. Select a mirror site from which
the module file needs to be downloaded.</p>
</td></tr>
<tr><td><code id="modLand_+3A_...">...</code></td>
<td>
<p>Argument that are passed on to <code><a href="#topic+read.module">read.module</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like the <a href="https://modarchive.org">https://modarchive.org</a>, modland provides access to a large collection of module files.
Compared to the <a href="#topic+modArchive">modArchive</a>, modLand provides limited searching features. However, it
does not require an API key.
</p>
<p>The functions documented here are provided as a convenience and depend
on third party services. Note that continuity of these services cannot
be guaranteed.
</p>
<p>Use <code>modLand.search.mod</code> to search through the modLand collection.
</p>
<p>Use <code>modLand.download.mod</code> to download a specific mod file as an S4 object.
</p>


<h3>Value</h3>

<p><code>modLand.search.mod</code> returns a <code>data.frame</code>.
The <code>data.frame</code> contains a search result in each row.
The data.frame contains a number of columns, each containing
<code>character</code> strings. The column <code style="white-space: pre;">&#8288;title' contains the mod file name; The column named &#8288;</code>author' contains the author name; the column named
<code style="white-space: pre;">&#8288;format' contains the tracker file format (only ``Protracker&#8288;</code>'
is supported by this package); The collumn <code style="white-space: pre;">&#8288;collect' contains modLand collections in which the mod is included; the column named &#8288;</code>url' contains a download link for the <code style="white-space: pre;">&#8288;ogg'-file generated on the modLand server from the mod file. Note that ogg-files are not supported by the ProTrackR package. Use &#8288;</code>modLand.download.mod' to download
the mod file.
</p>
<p><code>modLand.download.mod</code> attempts to download the specified mod
file and return it as a <code><a href="#topic+PTModule">PTModule</a></code> object. It will throw
errors when the mod file is not available or when there are network
problems...
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Search for a funky tune:

modland &lt;- modLand.search.mod("elekfunk mod")

## The ogg file can be downloaded (in this case to the tempdir()),
## but it is not supported by the ProTrackR package...

utils::download.file(modland$url[1], tempdir())

## Instead, use the following approach to download the module:

mod &lt;- modLand.download.mod(modland$format[1],
                            modland$author[1],
                            modland$title[1])


## End(Not run)
</code></pre>

<hr>
<h2 id='MODPlugToPTPattern'>Convert MODPlug pattern into a PTPattern object</h2><span id='topic+MODPlugToPTPattern'></span>

<h3>Description</h3>

<p>Convert pattern data from text or clipboard, originating from the modern
MODPlug tracker and convert it into a <code>PTPattern</code> or <code>PTBlock</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MODPlugToPTPattern(text = NULL, what = c("PTPattern", "PTBlock"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MODPlugToPTPattern_+3A_text">text</code></td>
<td>
<p>A <code>vector</code> of <code>character</code>s, representing MOD pattern data
obtained from OpenMPT. If set to <code>NULL</code> (default), the text will be read
from the system's clipboard.</p>
</td></tr>
<tr><td><code id="MODPlugToPTPattern_+3A_what">what</code></td>
<td>
<p>A <code>character</code> string that indicates what type of object
should be returned. Can be &quot;PTPattern&quot; or &quot;PTBlock&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Open MODPlug Tracker (<a href="https://openmpt.org">https://openmpt.org</a>) is a modern
music tracker that is for free. It too can handle ProTracker modules.
This function assists in moving pattern data from Open MPT to R.
</p>
<p>Simply select and copy the pattern data to the system's clipboard
and use this function to import it to R as a <code><a href="#topic+PTPattern">PTPattern</a></code> or
<code><a href="#topic+PTBlock">PTBlock</a></code> object.
</p>


<h3>Value</h3>

<p>Depending on the value of the argument <code>what</code>, it will
return either a <code><a href="#topic+PTPattern">PTPattern</a></code> or <code><a href="#topic+PTBlock">PTBlock</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other MODPlug.operations: 
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>
</p>
<p>Other pattern.operations: 
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This is what Mod Plug Pattern data looks like on
## the system's clipboard:
modPlugPattern &lt;- c("ModPlug Tracker MOD",
                    "|C-601...A08|C-602...C40|A#403...F06|A#504......",
                    "|...01...A08|C-602...C30|........A01|........A02",
                    "|...01...A08|C-602......|........A01|C-604......",
                    "|...........|C-602......|........A02|........A02",
                    "|...01...A08|C-602......|........120|D-604......",
                    "|...........|A#504...C08|........A02|........A02",
                    "|...01...A08|C-602......|........220|D#604......",
                    "|...........|A#504...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|F-604......",
                    "|...........|A#604...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|D#604......",
                    "|...........|G-604...C08|........A01|........A02",
                    "|G-601......|C-602......|........A01|D-604......",
                    "|........A08|F-604...C08|...........|........A02",
                    "|F-601......|C-602......|...........|C-604......",
                    "|........A08|A#504...C08|...........|........A02",
                    "|C-601...A08|C-602...C40|A#403...F06|A#504......",
                    "|...01...A08|C-602...C30|........A01|........A02",
                    "|...01...A08|C-602......|........A01|D-604......",
                    "|...........|C-602......|........A02|........A02",
                    "|...01...A08|C-602......|........120|F-504......",
                    "|...........|A#504...C08|........A02|........A02",
                    "|...01...A08|C-602......|........220|G-504......",
                    "|...........|A#504...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|A#504......",
                    "|...........|A#604...C08|........A01|........A01",
                    "|...01...A08|C-602......|........A01|...........",
                    "|...........|G-604...C08|........A01|........A01",
                    "|G-501......|C-602......|........A01|...........",
                    "|........A08|F-504...C08|...........|........A01",
                    "|A-501......|C-602......|...........|...........",
                    "|........A08|G-504...C08|...........|........A01",
                    "|E-601...A08|C-602...C40|D-503......|D-604......",
                    "|...01...A08|C-602...C30|........A01|........A02",
                    "|...01...A08|C-602......|........A01|E-604......",
                    "|...........|C-602......|........A02|........A02",
                    "|...01...A08|C-602......|........126|F#604......",
                    "|...........|D-604...C08|........A02|........A02",
                    "|...01...A08|C-602......|........226|G-604......",
                    "|...........|E-604...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|A-604......",
                    "|...........|D-604...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|G-604......",
                    "|...........|D-604...C08|........A01|........A02",
                    "|B-601......|C-602......|........A01|F#604......",
                    "|........A08|D-604...C08|...........|........A02",
                    "|A-601......|C-602......|...........|E-604......",
                    "|........A08|E-504...C08|...........|........A02",
                    "|D-601...A08|C-602...C40|C-503......|C-604......",
                    "|...01...A08|C-602...C30|........A01|........A02",
                    "|...01...A08|C-602......|........A01|D-604......",
                    "|...........|C-602......|........A02|........A02",
                    "|...01...A08|C-602......|........12B|E-604......",
                    "|...........|G-604...C08|........A02|........A02",
                    "|...01...A08|C-602......|........22B|F-604......",
                    "|...........|G-604...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|G-604......",
                    "|...........|E-604...C08|........A01|........A02",
                    "|...01...A08|C-602......|........A01|F-604......",
                    "|...........|C-604...C08|........A01|........A02",
                    "|A-601......|C-602......|........A01|E-604......",
                    "|........A08|G-604...C08|...........|........A02",
                    "|G-601......|F-604...C08|...........|D-604......",
                    "|........A08|C-604...C08|...........|........A02")

## You could read it directly from the clipboard,
## by leaving text NULL (default). Here we provide
## the text specified above:
pat &lt;- MODPlugToPTPattern(modPlugPattern, "PTPattern")

## look it is a "PTPattern" object now:
class(pat)

## we can also only import the first 10 lines as a
## PTBlock:
blk &lt;- MODPlugToPTPattern(modPlugPattern[1:10], "PTBlock")

## End(Not run)
</code></pre>

<hr>
<h2 id='modToWave'>Convert a PTModule object into an audio Wave object</h2><span id='topic+modToWave'></span><span id='topic+modToWave+2CPTModule-method'></span>

<h3>Description</h3>

<p>Converts a <code><a href="#topic+PTModule">PTModule</a></code> object into a <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code>
object, which can be played, further analysed, modified and saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
modToWave(
  mod,
  video = c("PAL", "NTSC"),
  target.rate = 44100,
  target.bit = 16,
  stereo.separation = 1,
  low.pass.filter = TRUE,
  tracks = 1:4,
  mix = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modToWave_+3A_mod">mod</code></td>
<td>
<p>An object of class <code><a href="#topic+PTModule">PTModule</a></code></p>
</td></tr>
<tr><td><code id="modToWave_+3A_video">video</code></td>
<td>
<p>The video mode of a Commodore Amiga affects timing routines and
the playback sample rate. This mode can be specified with this argument and
is represented by a <code>character</code> string that can have either the value
'<a href="https://en.wikipedia.org/wiki/PAL">PAL</a>'
or '<a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a>'. PAL is used by default.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_target.rate">target.rate</code></td>
<td>
<p>A positive <code>integer</code> sample rate for the target <code>Wave</code>.
Should be at least 2000.
Default value is 44100 Hz, which is conform CD quality. 22050 Hz will also
produce a decent sound quality and saves you some working memory.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_target.bit">target.bit</code></td>
<td>
<p>Number of bits for the target <code>Wave</code>. Should be a <code>numeric</code>
value of either 8, 16, 24 or 32. Default is 16, which is conform CD quality
(the quality doesn't really improve at higher bit values, as the original
samples are of 8 bit quality).</p>
</td></tr>
<tr><td><code id="modToWave_+3A_stereo.separation">stereo.separation</code></td>
<td>
<p>A <code>numeric</code> value between 0 and 1.
When set to 1 (default), stereo channels (Amiga channels 1 and 4 on left,
and channels 2 and 3 on right) are completely separated. When set to
less than 1, stereo channels are mixed, where the number gives the
fraction of separation of the channels. When set to 0, both channels
are completely mixed and a mono <code>Wave</code> is returned.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_low.pass.filter">low.pass.filter</code></td>
<td>
<p>A <code>logical</code> value indicating whether low pass
filters should be applied when generating wave data. The Commodore Amiga
had hardware audio filters. One (low pass 6 db/Oct tuned at
4.9 kHz) that filters all audio and one (low pass 12 db/Oct tuned at
approximately 3.3 kHz) that can be turned on and off at will with effect
command E00/E01 (see also <a href="#topic+ProTrackR-package">ProTrackR</a> documentation,
section on effect commands). These filters are only applied when the
<code>low.pass.filter</code> argument is set to <code>TRUE</code> and the
<code>target.rate</code> is set to values &gt; 4.9 kHz. If you don't want to simulate
this typical Amiga sound, turn the filters off to save processing time.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_tracks">tracks</code></td>
<td>
<p>Either <code>logical</code> or <code>numeric</code> values indicating
which of the 4 <code><a href="#topic+PTTrack">PTTrack</a></code>s are to be converted. By default
all 4 tracks are selected.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_mix">mix</code></td>
<td>
<p>A logical value indicating whether the 4 Amiga channels should
be mixed to the 2 (stereo) output channels. When set to <code>TRUE</code> (default) a stereo
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object is returned. When set to <code>FALSE</code> a
multi-channel <code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC</a></code> object is returned. The
<code>stereo.separation</code> argument is ignored in the latter case.</p>
</td></tr>
<tr><td><code id="modToWave_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed to <code><a href="#topic+playingtable">playingtable</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before the <code><a href="#topic+PTModule">PTModule</a></code> object can be converted into a
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object, the rows of the
<code><a href="#topic+PTPattern">PTPattern</a></code> objects in the module need to be put
in the right order. This method does that by calling
<code><a href="#topic+playingtable">playingtable</a></code>.
</p>
<p>Once the rows of the pattern tables are in the right order, all selected
<code><a href="#topic+PTTrack">PTTrack</a></code> objects of the module are looped by this function
and the routines described below are applied to each track.
</p>
<p>On the Commodore Amiga the chip responsible for audio output (Paula),
the audio playback of samples can be controlled by the user in two ways:
the playback rate of the sample can be changed by specifying 'period'
values (see e.g. <code><a href="#topic+periodToSampleRate">periodToSampleRate</a></code>) and specifying a
volume which is linearly scaled between 0 (silent) and 64 (maximum).
</p>
<p>So, for each track, the correct period and volume values are determined
based on the note, effect command and sample information in the module.
</p>
<p>Then, the <code><a href="#topic+PTSample">PTSample</a></code> objects are resampled, using the
period values and volume values as determined in the previous step.
</p>
<p>Next audio filters are applied to mimic original Commodore Amiga
sound. Finaly, the wave data for each separate track is mixed to
one (mono) or two (stereo) of the output channels.
</p>
<p>Converting ProTracker modules into wave objects can be time consuming.
The time required to convert an object obviously depends on your
machine's capacities and the length of the module but also the
complexity of the module. To speed up the conversion you could
reduce the target sample rate or turn off the low pass filter.
On modern machines, the time required for conversion should generally
be less than the playback time of the module.
</p>
<p>You can save the resulting <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object by calling
<code><a href="tuneR.html#topic+writeWave">tuneR::writeWave</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object, generated from the
<code>mod</code> object is returned. A <code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC</a></code> object is returned when
the <code>mix</code> argument is set to <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>As audio can be mixed with this package at frequencies much greater than the
Commodore Amiga's audio output rate, some aliasing of the sound could occur.
This results in high frequency audio, that would not be produced on an Amiga.
The current version of this package does not filter out these artefacts.
This should not be a problem if you're not concerned with producing an
accurate Amiga timbre.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mod.intro)
wav &lt;- modToWave(mod.intro)

## End(Not run)
</code></pre>

<hr>
<h2 id='moduleSize'>Get module file size</h2><span id='topic+moduleSize'></span><span id='topic+moduleSize+2CPTModule-method'></span>

<h3>Description</h3>

<p>Get the file size in bytes of a <code><a href="#topic+PTModule">PTModule</a></code> object, when it is to be saved
as an original module file with <code><a href="#topic+write.module">write.module</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
moduleSize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleSize_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the file size is
to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ProTracker module has a 1084 byte sized header containing all (meta)
information on the patterns, their order and the audio samples. Each pattern
holds exactly 1 Kb of information and the length of the audio samples corresponds
with the size in bytes, as they are of 8 bit quality in mono. This function
calculates the file size of the <code><a href="#topic+PTModule">PTModule</a></code> object when it is to
be saved with <code><a href="#topic+write.module">write.module</a></code>.
</p>


<h3>Value</h3>

<p>Returns potential uncompressed module file size in bytes represented
by a number of class <code>object_size</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate the file size for the example module 'mod.intro':

data("mod.intro")
moduleSize(mod.intro)

## Note that this is not the same as the size the object
## requires in R working memory:

object.size(mod.intro)

## In working memory it takes more memory to store the module, than in a
## file. This is because the S4 structure of the object consumes some
## memory. In addition, samples are of 8 bit quality, corresponding with
## a byte per sample. In the PTSample object it is stored as a
## vector of integer values. In R, integer values are 32 bit, which
## costs 4 times as much memory as the original 8 bit.

</code></pre>

<hr>
<h2 id='name'>Obtain or replace the name of a PTModule or PTSample</h2><span id='topic+name'></span><span id='topic+name+2CPTSample-method'></span><span id='topic+name+3C-'></span><span id='topic+name+3C-+2CPTSample+2Ccharacter-method'></span><span id='topic+name+2CPTModule-method'></span><span id='topic+name+3C-+2CPTModule+2Ccharacter-method'></span>

<h3>Description</h3>

<p>The name of both a <code><a href="#topic+PTModule">PTModule</a></code> and
<code><a href="#topic+PTSample">PTSample</a></code> are stored as <code>raw</code> data.
This method returns the name as a <code>character</code> string, or it can
be used to assign a new name to a <code><a href="#topic+PTModule">PTModule</a></code> or
<code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
name(x)

## S4 replacement method for signature 'PTSample,character'
name(x) &lt;- value

## S4 method for signature 'PTModule'
name(x)

## S4 replacement method for signature 'PTModule,character'
name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> or a <code><a href="#topic+PTSample">PTSample</a></code>
object for which to obtain or replace the name.</p>
</td></tr>
<tr><td><code id="name_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string which should be used to replace the
name of <code><a href="#topic+PTModule">PTModule</a></code> or <code><a href="#topic+PTSample">PTSample</a></code> <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of a <code><a href="#topic+PTModule">PTModule</a></code> and
<code><a href="#topic+PTSample">PTSample</a></code> is stored as a <code>vector</code> of
<code>raw</code> data with a length of 20 or 22 respectively. This method
provides the means for getting the name as a <code>character</code> string
or to safely redefine the name of a <code><a href="#topic+PTModule">PTModule</a></code> or
<code><a href="#topic+PTSample">PTSample</a></code> object. To do so,
the provided name (<code>value</code>) is converted to a <code>raw</code> <code>vector</code>
of length 20 or 22 respectively. Long names may therefore get clipped.
</p>


<h3>Value</h3>

<p>For <code>name</code>, the name of the <code><a href="#topic+PTModule">PTModule</a></code> or
<code><a href="#topic+PTSample">PTSample</a></code> object as a <code>character</code> string is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;name&lt;-&#8288;</code>, object <code>x</code> with an updated name is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other character.operations: 
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the name of mod.intro:
name(mod.intro)

## I don't like the name, let's change it:
name(mod.intro) &lt;- "I like this name better"

## Note that the provided name was too long and is truncated:
name(mod.intro)

## print all sample names in the module:
unlist(lapply(as.list(1:31), function(x)
  name(PTSample(mod.intro, x))))

</code></pre>

<hr>
<h2 id='note'>Extract or replace a note</h2><span id='topic+note'></span><span id='topic+note+2Cnumeric-method'></span><span id='topic+note+2CPTCell-method'></span><span id='topic+note+3C-'></span><span id='topic+note+3C-+2CPTCell+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Obtain a note from a period value or extract or replace a note of a
<code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
note(x)

## S4 method for signature 'PTCell'
note(x)

## S4 replacement method for signature 'PTCell,character'
note(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note_+3A_x">x</code></td>
<td>
<p>Either a (<code>vector</code> of) numeric value(s), representing a period
value. It can also be a <code><a href="#topic+PTCell">PTCell</a></code> object.</p>
</td></tr>
<tr><td><code id="note_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string representing the chromatic scale note
with wich the current note needs to be replaced. Should have any of the folling values:
<code>"C-"</code>, <code>"C#"</code>, <code>"D-"</code>, <code>"D#"</code>, <code>"E-"</code>, <code>"F-"</code>,
<code>"F#"</code>, <code>"G-"</code>, <code>"G#"</code>, <code>"A-"</code>, <code>"A#"</code>, <code>"B-"</code>,
or <code>"--"</code>.
Right-hand dashes can be omitted from these strings. Both upper and lower case are
accepted.
</p>
<p>If an <code><a href="#topic+octave">octave</a></code> is not yet specified for <code>PTCell</code> <code>x</code>,
it will be set to 1.
</p>
<p>Assigning a value of <code>"--"</code> will remove both the note and octave from
object <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Period values are used by ProTracker to set a playback sample rate and in
essence determine the key in which a sound is played. This method can be used
to obtain the note (key) associated with a period value (according to the
ProTracker <code><a href="#topic+period_table">period_table</a></code>, assuming zero <code><a href="#topic+fineTune">fineTune</a></code>).
If the period value is not in the <code><a href="#topic+period_table">period_table</a></code>, the note associated
with the period closest to this value in the table is returned.
</p>
<p>The note can also be obtained or replaced for a <code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Value</h3>

<p>For <code>note</code>, a <code>character</code> string representing the note
is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;note&lt;-&#8288;</code>, a copy of <code>PTCell</code> object <code>x</code> in which the
note is replaced by <code>value</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other period.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+period_table">period_table</a></code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other note.and.octave.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+noteUp">noteUp</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other cell.operations: 
<code><a href="#topic+PTCell-class">PTCell-class</a></code>,
<code><a href="#topic+PTCell-method">PTCell-method</a></code>,
<code><a href="#topic+effect">effect</a>()</code>,
<code><a href="#topic+sampleNumber">sampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the note of PTCell at pattern #3, track #2,
## row #1 from mod.intro (which is note "C-"):

note(PTCell(mod.intro, 1, 2, 3))

## replace the note of PTCell at pattern #3, track #2,
## row #1 from mod.intro with "A-":

note(PTCell(mod.intro, 1, 2, 3)) &lt;- "A-"

## get the notes associated with the period
## values 200 up to 400:

note(200:400)

</code></pre>

<hr>
<h2 id='noteToPeriod'>Extract period value for a specific note</h2><span id='topic+noteToPeriod'></span>

<h3>Description</h3>

<p>Extracts the ProTracker period value for a specific note.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noteToPeriod(note = "C-3", finetune = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noteToPeriod_+3A_note">note</code></td>
<td>
<p><code>character</code> string representing a note and octave for which the
ProTracker period value needs to be determined</p>
</td></tr>
<tr><td><code id="noteToPeriod_+3A_finetune">finetune</code></td>
<td>
<p><code>integer</code> value ranging from -8 up to 7. A value used to
tune an audio sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ProTracker uses a <a href="#topic+period_table">period_table</a> to link period values to certain
octaves and notes. This function serves to look up corresponding
period values for specific notes and octaves.
</p>


<h3>Value</h3>

<p>Returns the <code>numeric</code> ProTracker period value for a corresponding
note, octave and <code>fineTune()</code>. Returns 0 if a note could not be found in the
table.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other period.operations: 
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+period_table">period_table</a></code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other note.and.octave.operations: 
<code><a href="#topic+noteUp">noteUp</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Determine the period value corresponding with note 'A-3':
noteToPeriod("A-3")

## get the period values for notes 'A-3' and 'A#3' with finetune at -1:
noteToPeriod(c("A-3", "A#3"), -1)

## get the period values for note 'A-3' with finetune at 0 and 1:
noteToPeriod("A-3", 0:1)

</code></pre>

<hr>
<h2 id='noteUp'>Raise or lower notes and octaves</h2><span id='topic+noteUp'></span><span id='topic+noteUp+2CPTCell-method'></span><span id='topic+noteDown'></span><span id='topic+noteDown+2CPTCell-method'></span><span id='topic+octaveUp'></span><span id='topic+octaveUp+2CPTCell-method'></span><span id='topic+octaveDown'></span><span id='topic+octaveDown+2CPTCell-method'></span><span id='topic+noteUp+2CPTTrack-method'></span><span id='topic+noteDown+2CPTTrack-method'></span><span id='topic+octaveUp+2CPTTrack-method'></span><span id='topic+octaveDown+2CPTTrack-method'></span><span id='topic+noteUp+2CPTPattern-method'></span><span id='topic+noteDown+2CPTPattern-method'></span><span id='topic+octaveUp+2CPTPattern-method'></span><span id='topic+octaveDown+2CPTPattern-method'></span>

<h3>Description</h3>

<p>Methods to raise or lower notes in <code><a href="#topic+PTCell">PTCell</a></code>,
<code><a href="#topic+PTTrack">PTTrack</a></code> and <code><a href="#topic+PTPattern">PTPattern</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
noteUp(x, sample.nr = "all")

## S4 method for signature 'PTCell'
noteDown(x, sample.nr = "all")

## S4 method for signature 'PTCell'
octaveUp(x, sample.nr = "all")

## S4 method for signature 'PTCell'
octaveDown(x, sample.nr = "all")

## S4 method for signature 'PTTrack'
noteUp(x, sample.nr = "all")

## S4 method for signature 'PTTrack'
noteDown(x, sample.nr = "all")

## S4 method for signature 'PTTrack'
octaveUp(x, sample.nr = "all")

## S4 method for signature 'PTTrack'
octaveDown(x, sample.nr = "all")

## S4 method for signature 'PTPattern'
noteUp(x, sample.nr = "all")

## S4 method for signature 'PTPattern'
noteDown(x, sample.nr = "all")

## S4 method for signature 'PTPattern'
octaveUp(x, sample.nr = "all")

## S4 method for signature 'PTPattern'
octaveDown(x, sample.nr = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noteUp_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTCell">PTCell</a></code>, <code><a href="#topic+PTTrack">PTTrack</a></code> or
<code><a href="#topic+PTPattern">PTPattern</a></code> object for which the notes need to be lowered
or raised.</p>
</td></tr>
<tr><td><code id="noteUp_+3A_sample.nr">sample.nr</code></td>
<td>
<p>A single positive <code>integer</code> value, or a <code>vector</code> of
positive <code>integer</code>s, listing the indices of samples, for which the notes
need to be lowered or raised. A <code>character</code> string equal to <code style="white-space: pre;">&#8288;"all&#8288;</code>&quot;
is also allowed (this is in fact the default), in which case notes of all
sample indices are raised or lowered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the same class as object <code>x</code>, in which
the notes for samples selected with <code>sample.nr</code> are raised or lowered.
</p>
<p>In case raised or lowered notes would lead to notes that are out of
ProTracker's range, the returned notes remain unchanged.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other note.and.octave.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## raise note from C-2 to C#2:
noteUp(PTCell("C-2 01 000"))


## lower note from C-2 to B-1:
noteDown(PTCell("C-2 01 000"))


## raise note from octave 2 to octave 3:
octaveUp(PTCell("C-2 01 000"))


## lower note from octave 2 to octave 1:
octaveDown(PTCell("C-2 01 000"))


data("mod.intro")

## Raise the notes of all cells in pattern
## number 2 of mod.intro:
noteUp(PTPattern(mod.intro, 2))

## Raise only the notes of sample number 4
## in pattern number 2 of mod.intro:
noteUp(PTPattern(mod.intro, 2), 4)

## Raise only the notes of samples number 2 and 4
## in pattern number 2 of mod.intro:
noteUp(PTPattern(mod.intro, 2), c(2, 4))

</code></pre>

<hr>
<h2 id='nybble'>Get the high or low nybble of a raw value</h2><span id='topic+nybble'></span><span id='topic+loNybble'></span><span id='topic+hiNybble'></span>

<h3>Description</h3>

<p>Get the high or low nybble of a raw value and return as integer value [0,15].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nybble(raw_dat, which = c("low", "high"))

loNybble(raw_dat)

hiNybble(raw_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nybble_+3A_raw_dat">raw_dat</code></td>
<td>
<p>A vector of class <code>raw</code> from which the high or low nybble value
needs to be extracted.</p>
</td></tr>
<tr><td><code id="nybble_+3A_which">which</code></td>
<td>
<p>A character string indicating whether the high or low nybble should
be returnd. It should either be <code>"low"</code> (default) or <code>"high"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>raw</code> is basically a byte, composed of 8 bits (zeros and ones).
A nybble is a 4 bit value. Hence, a raw value (or byte) is composed of
two nybbles. The leftmost nybble of a raw value is refered to as the
high nybble, the rightmost nybble is referred to as the low nybble.
These functions return either the high or low nybbles of raw data as integer
values [0,15].
As ProTracker stores some information as nybbles this function can be
used to retrieve this info.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>raw_dat</code> holding integer values.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other nybble.functions: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this will return 0x0f:
hiNybble(as.raw(0xf3))

## which is the same as:
nybble(as.raw(0xf3), "high")

## this will return 0x03:
loNybble(as.raw(0xf3))

## which is the same as:
nybble(as.raw(0xf3), "low")
</code></pre>

<hr>
<h2 id='nybbleToSignedInt'>Get signed integer values from nybbles</h2><span id='topic+nybbleToSignedInt'></span>

<h3>Description</h3>

<p>Get signed integer values from one or more nybble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nybbleToSignedInt(raw_dat, which = c("low", "high"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nybbleToSignedInt_+3A_raw_dat">raw_dat</code></td>
<td>
<p><code>raw</code> data (either a single value or a <code>vector</code>),
from which a nybble will be extracted and converted.</p>
</td></tr>
<tr><td><code id="nybbleToSignedInt_+3A_which">which</code></td>
<td>
<p>A <code>character</code> string indicating whether the <code>"low"</code> (default)
or <code>"high"</code> nybble of <code>raw_dat</code> needs to be converted into a signed
<code>integer</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nybbles are 4 bit values, where each byte (8 bits) holds two nybbles.
A high nybble (left-hand side of a byte) and a low nybble (right-hand
side of a byte). This function extracts a nybble from <code>raw</code> data
and converts it into a signed <code>integer</code> value ranging from -8 up to 7.
</p>


<h3>Value</h3>

<p>Returns <code>integer</code> values of the same length as <code>raw_dat</code>,
ranging from -8 up to 7.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other nybble.functions: 
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some raw data:

rdat &lt;- as.raw(255*runif(100))

## get signed integers of low nybbles:

sintl &lt;- nybbleToSignedInt(rdat)

## get signed integers of high nybbles:

sinth &lt;- nybbleToSignedInt(rdat, "high")

</code></pre>

<hr>
<h2 id='octave'>Extract or replace an octave</h2><span id='topic+octave'></span><span id='topic+octave+2Cnumeric-method'></span><span id='topic+octave+2CPTCell-method'></span><span id='topic+octave+3C-'></span><span id='topic+octave+3C-+2CPTCell+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Obtain an octave number from a period value or extract or replace a
note of a <code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
octave(x)

## S4 method for signature 'PTCell'
octave(x)

## S4 replacement method for signature 'PTCell,numeric'
octave(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octave_+3A_x">x</code></td>
<td>
<p>Either a (<code>vector</code> of) numeric value(s), representing a period
value. It can also be a <code><a href="#topic+PTCell">PTCell</a></code> object.</p>
</td></tr>
<tr><td><code id="octave_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> value representing the octave number with which
that of object <code>x</code> needs to be replaced. 0, 1 and 3 are valid octave
numbers. Use zero to disable both the note and octave for object <code>x</code>.
</p>
<p>Note that the octave can only be set for <code><a href="#topic+PTCell">PTCell</a></code>s for which
a note is already defined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Period values are used by ProTracker to set a playback sample rate
and in essence determine the key and octave in which a sound is played.
This method can be used to obtain the octave number associated with a
period value (according to the ProTracker <code><a href="#topic+period_table">period_table</a></code>,
assuming zero <code><a href="#topic+fineTune">fineTune</a></code>). If the period value is not in the
<code><a href="#topic+period_table">period_table</a></code>, the octave number associated with the
period closest to this value in the table is returned.
</p>
<p>The octave number can also be obtained or replaced for a
<code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Value</h3>

<p>For <code>octave</code>, a <code>numeric</code> value representing the octave number
is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;octave&lt;-&#8288;</code>, a copy of <code>PTCell</code> object <code>x</code> in which the
octave number is replaced by <code>value</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other period.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+period_table">period_table</a></code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other note.and.octave.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+noteUp">noteUp</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the octave number of PTCell at pattern #3, track #2,
## row #1 from mod.intro (which is number 3):

octave(PTCell(mod.intro, 1, 2, 3))

## replace the octave number of PTCell at pattern #3, track #2,
## row #1 from mod.intro with 2:

octave(PTCell(mod.intro, 1, 2, 3)) &lt;- 2

## get the octave numbers associated with the period
## values 200 up to 400:

octave(200:400)
</code></pre>

<hr>
<h2 id='pasteBlock'>Paste a block of PTCell data into a PTPattern</h2><span id='topic+pasteBlock'></span><span id='topic+pasteBlock+2CPTPattern+2Cmatrix+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Paste a block of <code><a href="#topic+PTCell">PTCell</a></code> data into a <code><a href="#topic+PTPattern">PTPattern</a></code> at
a specified location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTPattern,matrix,numeric,numeric'
pasteBlock(pattern, block, row.start, track.start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pasteBlock_+3A_pattern">pattern</code></td>
<td>
<p>A <code><a href="#topic+PTPattern">PTPattern</a></code> object into which the <code>block</code>
needs to be pasted.</p>
</td></tr>
<tr><td><code id="pasteBlock_+3A_block">block</code></td>
<td>
<p>A <code><a href="#topic+PTBlock">PTBlock</a></code> holding the <code><a href="#topic+PTCell">PTCell</a></code> data
that needs to be pasted into the <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="pasteBlock_+3A_row.start">row.start</code></td>
<td>
<p>A positive <code>integer</code> value (ranging from 1 up to 64)
indicating the starting position (row) in the <code>pattern</code> to paste the
<code>block</code> into.</p>
</td></tr>
<tr><td><code id="pasteBlock_+3A_track.start">track.start</code></td>
<td>
<p>A positive <code>integer</code> value (ranging from 1 up to 4)
indicating the starting position (track) in the <code>pattern</code> to paste the
<code>block</code> into.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+PTBlock">PTBlock</a></code> is not a formal S4 class. It is a <code>matrix</code> where
each element holds a <code>list</code> of a single <code><a href="#topic+PTCell">PTCell</a></code> object. As
explained at the <code><a href="#topic+PTBlock">PTBlock</a></code> method documentation, this allows for
a flexible approach of manipulating <code><a href="#topic+PTCell">PTCell</a></code> objects. The
<code>pasteBlock</code> method allows you to paste a <code><a href="#topic+PTBlock">PTBlock</a></code> back into
a <code><a href="#topic+PTPattern">PTPattern</a></code>.
</p>
<p>The <code><a href="#topic+PTBlock">PTBlock</a></code> will be pasted at the specified location and will
span the number of tracks and rows that are included in the <code><a href="#topic+PTBlock">PTBlock</a></code>.
The <code><a href="#topic+PTCell">PTCell</a></code>s in the <code>pattern</code> will be replaced by those
of the <code>block</code>. Elements of the <code>bock</code> that are out of the range
of the <code>pattern</code> are not included in the <code>pattern</code>.
</p>


<h3>Value</h3>

<p>Returns a copy of <code>pattern</code> into which <code>block</code> is pasted.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other block.operations: 
<code><a href="#topic+PTBlock">PTBlock</a>()</code>
</p>
<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

block &lt;- PTBlock(PTPattern(mod.intro, 1), 1:16, 1)

## Do some operations using lapply (the effect
## code is set to "C10"):
block &lt;- matrix(lapply(block, function(x) {(effect(x) &lt;- "C10"); x}),
                nrow(block), ncol(block), byrow = TRUE)

## Paste block back on the same position:
PTPattern(mod.intro, 1) &lt;-
  pasteBlock(PTPattern(mod.intro, 1), block, 1, 1)

## You can also paste the block anywhere you like:
PTPattern(mod.intro, 1) &lt;-
  pasteBlock(PTPattern(mod.intro, 1), block, 49, 2)

</code></pre>

<hr>
<h2 id='patternLength'>Get the number of PTPattern tables in a PTModule</h2><span id='topic+patternLength'></span><span id='topic+patternLength+2CPTModule-method'></span>

<h3>Description</h3>

<p>Get the number of <code><a href="#topic+PTPattern">PTPattern</a></code> tables in a <code><a href="#topic+PTModule">PTModule</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
patternLength(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patternLength_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the number of
<code><a href="#topic+PTPattern">PTPattern</a></code> tables need to be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of <code><a href="#topic+PTPattern">PTPattern</a></code> tables in a <code><a href="#topic+PTModule">PTModule</a></code>
object should range from 1 up to either 64 or 100. The maximum depends on the
<code><a href="#topic+trackerFlag">trackerFlag</a></code> of the <code><a href="#topic+PTModule">PTModule</a></code> object.
</p>


<h3>Value</h3>

<p>Returns a <code>numeric</code> value representing the number of
<code><a href="#topic+PTPattern">PTPattern</a></code> tables in object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Get the number of pattern tables in mod.intro:
patternLength(mod.intro)

</code></pre>

<hr>
<h2 id='patternOrder'>Get the pattern order table</h2><span id='topic+patternOrder'></span><span id='topic+patternOrder+2CPTModule-method'></span><span id='topic+patternOrder+3C-'></span><span id='topic+patternOrder+3C-+2CPTModule+2CANY+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The pattern order table is a <code>vector</code> of <code>numeric</code> indices of
<code><a href="#topic+PTPattern">PTPattern</a></code> tables, which determines in which order the patterns
need to be played. This method returns this <code>vector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
patternOrder(x, full = FALSE)

## S4 replacement method for signature 'PTModule,ANY,numeric'
patternOrder(x, full = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patternOrder_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the pattern order table
needs to be returned or modified.</p>
</td></tr>
<tr><td><code id="patternOrder_+3A_full">full</code></td>
<td>
<p>A <code>logical</code> value indicating whether the full (<code>TRUE</code>,
default), or only the visible (<code>FALSE</code>) part of the pattern order table
should be returned. This argument will also affect how new pattern order
tables are assigned (see <code>value</code>).</p>
</td></tr>
<tr><td><code id="patternOrder_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> (maximum length: 128) holding
<code><a href="#topic+PTPattern">PTPattern</a></code> indices minus 1 for the new pattern order table.
</p>
<p>When <code>full = TRUE</code>, the <code>vector</code> will be padded with zeros to a
length of 128, and the <code><a href="#topic+patternOrderLength">patternOrderLength</a></code> will be set to the
length of <code>value</code>. When <code>full = FALSE</code>, <code>value</code> will only
repplace the part of the order table up to the length of <code>value</code>. The
remainder of the table is not changed. The <code><a href="#topic+patternOrderLength">patternOrderLength</a></code>
is also not modified in this case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual length of the <code>vector</code> containing the pattern order is 128
as per ProTracker standards. Only part of this <code>vector</code> is &lsquo;visible&rsquo;
and will be used to determine in which order pattern tables are to be played.
This method can be used to return either the visible or full (all 128) part
of the table. It can also be used to assign a new patter order table.
</p>
<p>Note that <code><a href="#topic+PTPattern">PTPattern</a></code> indices start at 0, as per ProTracker
standards, whereas R start indices at 1. Hence, add 1 to the indices obtained
with <code>patternOrder</code>, in order to extract the correct
<code><a href="#topic+PTPattern">PTPattern</a></code> from a <code><a href="#topic+PTModule">PTModule</a></code>.
</p>
<p>The maximum index plus 1 in the full pattern order table should equal
the number of pattern tables (see <code><a href="#topic+patternLength">patternLength</a></code>) in the
<code><a href="#topic+PTModule">PTModule</a></code>. Is you assign a new pattern order, with a lower
maximum, <code><a href="#topic+PTPattern">PTPattern</a></code> objects will get lost (see also examples)!
</p>


<h3>Value</h3>

<p>For <code>patternOrder</code>, a <code>vector</code> of <code>numeric</code>
<code><a href="#topic+PTPattern">PTPattern</a></code> indices is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;patternOrder&lt;-&#8288;</code>, an updated version of object <code>x</code> is returned,
in which the pattern order table is modified based on <code>value</code>.
</p>


<h3>Note</h3>

<p>The maximum number of <code><a href="#topic+PTPattern">PTPattern</a></code>s cannot exceed either 64 or
100 (depending on the <code><a href="#topic+trackerFlag">trackerFlag</a></code>). This means that values in
the order table should also not exceed these values minus 1.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the visible part of the patternOrder table:
patternOrder(mod.intro)

## get the full patternOrder table:
patternOrder(mod.intro, full = TRUE)

## add 1 to get extract the right PTPattern from
## mod.intro:
first.pattern.played &lt;-
  (PTPattern(mod.intro, patternOrder(mod.intro)[1] + 1))

## set a different playing order:
patternOrder(mod.intro) &lt;- c(0:3, 0:3, 0:3)

## The assignment above uses a value that
## longer than the patternOrderLength.
## This means that a part ends up in the
## 'invisible' part of the order table:
patternOrder(mod.intro)
patternOrder(mod.intro, full = TRUE)

## Let's do the same assignment, but update
## the visible part of the table as well:
patternOrder(mod.intro, full = TRUE) &lt;- c(0:3, 0:3, 0:3)

## note that the maximum of the order table plus 1
## equals the patternLength of mod.intro (always the case
## for a valid PTModule object):
max(patternOrder(mod.intro, full = TRUE) + 1) ==
  patternLength(mod.intro)

## Let's do something dangerous. If the replacement
## indices do not hold a maximum value that equals
## the patternLength minus 1, PTPatterns will get lost,
## in order to maintain the validity of mod.intro:
patternOrder(mod.intro) &lt;- rep(0, 12)

</code></pre>

<hr>
<h2 id='patternOrderLength'>Get the length of the pattern order table</h2><span id='topic+patternOrderLength'></span><span id='topic+patternOrderLength+2CPTModule-method'></span><span id='topic+patternOrderLength+3C-'></span><span id='topic+patternOrderLength+3C-+2CPTModule+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The pattern order table is a <code>vector</code> of <code>numeric</code> indices of
<code>PTPattern</code> tables, which determines in which order the patterns
need to be played. This method returns the visible length of this
<code>vector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
patternOrderLength(x)

## S4 replacement method for signature 'PTModule,numeric'
patternOrderLength(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patternOrderLength_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the length of the
visible part of the pattern order table is to be returned.</p>
</td></tr>
<tr><td><code id="patternOrderLength_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> value which is to be used to set the visible
length of the pattern order table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual length of the <code>vector</code> containing the pattern order is 128
as per ProTracker standards. Only part of this <code>vector</code> is &lsquo;visible&rsquo;
and will be used to determine in which order pattern tables are to be played.
The length returned by this method is the length of this visible part of the
pattern order table. The length of this visible part can also be set with this
method.
</p>


<h3>Value</h3>

<p>For <code>patternOrderLength</code> the visible length of the pattern
order table of <code><a href="#topic+PTModule">PTModule</a></code> <code>x</code> is returned as a <code>numeric</code>
value, ranging from 1 up to 128.
</p>
<p>For <code style="white-space: pre;">&#8288;patternOrderLength&lt;-&#8288;</code> an updated version of object <code>x</code> is
returned, in which the visible length of the pattern order table is set
to <code>value</code>. Note that this does not change the pattern order table
itself, only which part is &lsquo;visible&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the length of the pattern order table:
patternOrderLength(mod.intro)

## set the length of the pattern order table to 1:
patternOrderLength(mod.intro) &lt;- 1

## note that the pattern order table remained intact:
patternOrder(mod.intro, full = TRUE)

</code></pre>

<hr>
<h2 id='paula_clock'>Paula clock table</h2><span id='topic+paula_clock'></span>

<h3>Description</h3>

<p>Table that provides audio output frequencies for the Commodore Amiga
original chipset.
</p>


<h3>Format</h3>

<p>a <code>data.frame</code> with two columns:
</p>

<ul>
<li><p> 'frequency' A <code>numeric</code> value representing Paula's output rate in Hz.
</p>
</li>
<li><p> 'video' A <code>character</code> string representing the two video modes.
</p>
</li></ul>



<h3>Details</h3>

<p>Paula was one of the custom chips on the original Commodore Amiga. This chip
was dedicated (amongst other tasks) to controlling audio playback. The
chip's output rate depended on the video mode used:
either '<a href="https://en.wikipedia.org/wiki/PAL">PAL</a>'
or '<a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a>'. This table provides the
output rate for both video modes that can be used in calculating sample rates.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Original_Chip_Set#Paula">https://en.wikipedia.org/wiki/Original_Chip_Set#Paula</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("paula_clock")
</code></pre>

<hr>
<h2 id='period_table'>ProTracker Period Table</h2><span id='topic+period_table'></span>

<h3>Description</h3>

<p>Table of ProTracker period values and corresponding, octave, tone and fine tune
</p>


<h3>Format</h3>

<p>a <code>data.frame</code> with fourteen columns:
</p>

<ul>
<li><p> The column named 'octave': <code>integer</code> value [1,3]
</p>
</li>
<li><p> The column named 'finetune': <code>integer</code> value [-8, 7] used to tune a sample
</p>
</li>
<li><p> The columns named 'C-' to &lsquo;B-&rsquo;: represent the twelve (semi)tones.
The values in these columns are the period values for the corresponding
tone, octave and finetune.
</p>
</li></ul>



<h3>Details</h3>

<p>Table of ProTracker period values used in calculating the
playback sampling rate of samples for specific tones.
These are the values that are actually used by ProTracker,
they cannot be calculated directly due to
undocumented rounding inconsistencies. This lookup table is therefore
a requirement.
</p>


<h3>See Also</h3>

<p>Other period.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("period_table")
</code></pre>

<hr>
<h2 id='periodToChar'>Get the note and octave from period table</h2><span id='topic+periodToChar'></span>

<h3>Description</h3>

<p>These functions return the note and octave that is closest to the provided period value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodToChar(period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodToChar_+3A_period">period</code></td>
<td>
<p><code>integer</code> value of a period value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ProTracker uses a <a href="#topic+period_table">period_table</a> to link period values to certain
octaves and notes. This function serves to look up corresponding
notes and octaves for specific period values.
</p>


<h3>Value</h3>

<p><code>periodToChar</code> returns a <code>character</code> representing the combination
of octave and note that is closest to
<code>period</code> in the ProTracker period table.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other character.operations: 
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other period.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+period_table">period_table</a></code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other note.and.octave.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+noteUp">noteUp</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note C# in octave 3 is closest to a period of 200 in the table:
periodToChar(200)
## try with a range of period values:
periodToChar(200:400)

</code></pre>

<hr>
<h2 id='playingtable'>Generate a table for playing a PTModule object</h2><span id='topic+playingtable'></span><span id='topic+playingtable+2CPTModule-method'></span>

<h3>Description</h3>

<p>This method generates a table (<code>data.frame</code>) in which information
from the pattern tables are put in the right order and in a comprehensive
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
playingtable(
  mod,
  starting.position = 1,
  max.duration = 2 * 60,
  speed = 6,
  tempo = 125,
  video = c("PAL", "NTSC"),
  play.once = T,
  verbose = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playingtable_+3A_mod">mod</code></td>
<td>
<p>An object of class <code><a href="#topic+PTModule">PTModule</a></code>.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_starting.position">starting.position</code></td>
<td>
<p>A <code>numeric</code> starting position index.
Determines where in the <code><a href="#topic+patternOrder">patternOrder</a></code> table of the module to
start generating the playingtable.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_max.duration">max.duration</code></td>
<td>
<p>A <code>numeric</code> value indicating the maximum
length in seconds of the pattern information returned. By default set
to 120 seconds (2 minutes). As some modules can be very long,
or contain infinite loops or position jumps, the maximum duration
is required to break out of the routine for generating the table.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_speed">speed</code></td>
<td>
<p>Default speed to use when it is not specified in the
pattern data. See <a href="#topic+ProTrackR-package">ProTrackR</a> documentation for more info on
<code style="white-space: pre;">&#8288;speed' and &#8288;</code>tempo'.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_tempo">tempo</code></td>
<td>
<p>Default tempo to use when it is not specified in the
pattern data.  See <a href="#topic+ProTrackR-package">ProTrackR</a> documentation for more info on
<code style="white-space: pre;">&#8288;speed' and &#8288;</code>tempo'.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_video">video</code></td>
<td>
<p>The video mode of a Commodore Amiga affects timing routines.
This mode can be specified with this argument and
is represented by a <code>character</code> string that can have either the value
'<a href="https://en.wikipedia.org/wiki/PAL">PAL</a>'
or '<a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a>'. PAL is used by default.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_play.once">play.once</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code>,
the routine will stop adding data to the table when the starting
position (<code>starting.position</code>) is reach once again. Warning:
may not work correctly when the last pattern contains a pattern
break. Will be overruled when the <code>maximum.duration</code> is reached
before the end of the song.</p>
</td></tr>
<tr><td><code id="playingtable_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value. Suppresses a progress report
from being printed to the <code><a href="base.html#topic+sink">base::sink</a></code> when set to <code>FALSE</code>.
The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method generates a table (<code>data.frame</code>) in which information
from the pattern tables (<code><a href="#topic+PTPattern">PTPattern</a></code>) are put in the right
order, taking into account pattern breaks, position jumps and pattern
loops (see also <a href="#topic+ProTrackR-package">ProTrackR</a> documentation,
section on effect commands). The information is put in
a comprehensive format in a <code>data.frame</code>, with the following columns:
</p>

<dl>
<dt>row</dt><dd><p>Row number index of the original
<code><a href="#topic+PTPattern">PTPattern</a></code> object.</p>
</dd>
<dt>filter</dt><dd><p>A <code>logical</code> value indicating whether the
Amiga hardware audio filter was either turned on or off using
effect command E00/E01 (see also <a href="#topic+ProTrackR-package">ProTrackR</a> documentation,
section on effect commands).</p>
</dd>
<dt>speed</dt><dd><p>Number of 'ticks' per row as set with the Fxy
effect commands in the module.</p>
</dd>
<dt>tempo</dt><dd><p>The tempo as specified by the Fxy commands in the module.</p>
</dd>
<dt>delay</dt><dd><p>The delay that should be applied to the row as
specified with the EEx effect command in the module.</p>
</dd>
<dt>effect.track1..4</dt><dd><p>The effect code (<code>raw</code>) as specified in each of the
4 tracks in the module.</p>
</dd>
<dt>effect.mag.track1..4</dt><dd><p>The effect magnitude (<code>raw</code>) as specified
for each of the 4 tracks in the module.</p>
</dd>
<dt>sample.nr.track1..4</dt><dd><p>The sample index number (<code>numeric</code>) as specified for
each of the 4 tracks in the module.</p>
</dd>
<dt>note.track1..4</dt><dd><p>The note (<code>factor</code>) as specified for each of
the four tracks in the module.</p>
</dd>
<dt>position</dt><dd><p>The positions index number (<code>numeric</code>) from the
<code><a href="#topic+patternOrder">patternOrder</a></code> table in the module.</p>
</dd>
<dt>duration</dt><dd><p>Playback duration of the corresponding row in seconds.</p>
</dd>
<dt>cum_duration</dt><dd><p>Cumulative playback duration of the corresponding row in seconds.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a <code>data.frame</code> with pattern rows put in the right
order. Information contained in the returned table is described in the
'Details' section
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mod.intro)
pt &lt;- playingtable(mod.intro)

## End(Not run)
</code></pre>

<hr>
<h2 id='playMod'>Play PTModule objects</h2><span id='topic+playMod'></span><span id='topic+playMod+2CPTModule-method'></span>

<h3>Description</h3>

<p>Converts <code><a href="#topic+PTModule">PTModule</a></code> objects into audio
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code>s, and plays them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
playMod(mod, wait = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playMod_+3A_mod">mod</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object to be played.</p>
</td></tr>
<tr><td><code id="playMod_+3A_wait">wait</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code> the playing
routine will wait with executing any code until the playing is
finished. When set to <code>FALSE</code>, subsequent R code will be
executed while playing.</p>
</td></tr>
<tr><td><code id="playMod_+3A_...">...</code></td>
<td>
<p>Arguments that are passed on to <code><a href="#topic+modToWave">modToWave</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unfortunately, it was not feasible to create a routine that can directly
interpret <code><a href="#topic+PTModule">PTModule</a></code> objects and play them simultaneously.
Instead, the audio first needs to be rendered after which it can be played.
This method therefore first calls <code><a href="#topic+modToWave">modToWave</a></code> and then
<code><a href="#topic+playWave">playWave</a></code>. Rendering may take some time and requires some
balance between speed, quality and accuracy. See the documentation of the
<code><a href="#topic+modToWave">modToWave</a></code> method for the control you have on these aspects.
</p>


<h3>Value</h3>

<p>A <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object, generated from the
<code>mod</code> object, is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other play.audio.routines: 
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+playWave">playWave</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("mod.intro")

## play the module and capture the audio Wave
wav &lt;- playMod(mod.intro)

## End(Not run)
</code></pre>

<hr>
<h2 id='playSample'>Play audio samples</h2><span id='topic+playSample'></span><span id='topic+playSample+2CPTSample-method'></span><span id='topic+playSample+2CPTModule-method'></span>

<h3>Description</h3>

<p>Method to play <code><a href="#topic+PTSample">PTSample</a></code>s or all such samples from
<code><a href="#topic+PTModule">PTModule</a></code> objects as audio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
playSample(x, silence = 0, wait = T, note = "C-3", loop = 1, ...)

## S4 method for signature 'PTModule'
playSample(x, silence = 0, wait = T, note = "C-3", loop = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playSample_+3A_x">x</code></td>
<td>
<p>Either a <code><a href="#topic+PTSample">PTSample</a></code> or a <code><a href="#topic+PTModule">PTModule</a></code> object.
In the latter case, all samples in the module will be played in order.</p>
</td></tr>
<tr><td><code id="playSample_+3A_silence">silence</code></td>
<td>
<p>Especially for short samples, the <code><a href="audio.html#topic+play">audio::play</a></code> routine
can be a bit buggy: playing audible noise, ticks or parts from other samples at the end of the sample.
By adding silence after the sample, this problem is evaded. Use this argument
to specify the duration of this silence in seconds. When, <code>x</code> is a
<code><a href="#topic+PTModule">PTModule</a></code> object, the silence will also be inserted in
between samples.</p>
</td></tr>
<tr><td><code id="playSample_+3A_wait">wait</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code> the playing
routine will wait with executing any code until the playing is finished.
When set to <code>FALSE</code>, subsequent R code will be executed while playing.</p>
</td></tr>
<tr><td><code id="playSample_+3A_note">note</code></td>
<td>
<p>A <code>character</code> string specifying the note to be used for
calculating the playback sample rate (using <code><a href="#topic+noteToSampleRate">noteToSampleRate</a></code>).
It should start with the note (ranging from <code style="white-space: pre;">&#8288;A' up to &#8288;</code>G') optionally followed
by a hash sign (<code style="white-space: pre;">&#8288;#') if a note is sharp (or a dash (&#8288;</code>-') if it's not) and finally
the octave number (ranging from 1 up to 3). A valid notation would for instance
be 'F#3'.
The <code><a href="#topic+fineTune">fineTune</a></code> as specified for the sample will also be used as
an argument for calculating the playback rate. A custom <code>finetune</code>
can also be passed as an argument to <code><a href="#topic+noteToSampleRate">noteToSampleRate</a></code>.</p>
</td></tr>
<tr><td><code id="playSample_+3A_loop">loop</code></td>
<td>
<p>A positive <code>numeric</code> indicating the duration of a looped
sample in seconds. A looped sample will be played at least once, even if
the specified duration is less than the sum of <code><a href="#topic+loopStart">loopStart</a></code>
position and the <code><a href="#topic+loopLength">loopLength</a></code>.
See <code><a href="#topic+loopStart">loopStart</a></code> and <code><a href="#topic+loopLength">loopLength</a></code> for details on how
to set (or disable) a loop.</p>
</td></tr>
<tr><td><code id="playSample_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+noteToSampleRate">noteToSampleRate</a></code>.
Can be used to change the video mode, or finetune argument for the call to that method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method plays <code><a href="#topic+PTSample">PTSample</a></code>s and such samples from
<code><a href="#topic+PTModule">PTModule</a></code> objects, using the <code><a href="audio.html#topic+play">audio::play</a></code> method
from the audio package. Default <code><a href="#topic+fineTune">fineTune</a></code> and <code><a href="#topic+volume">volume</a></code>
as specified for the <code><a href="#topic+PTSample">PTSample</a></code> will be applied when playing
the sample.
</p>


<h3>Value</h3>

<p>Returns nothing but plays the sample(s) as audio.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>
<p>Other sample.rate.operations: 
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>
<p>Other play.audio.routines: 
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playWave">playWave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("mod.intro")

## play all samples in mod.intro:
playSample(mod.intro, 0.2, loop = 0.5)

## play a chromatic scale using sample number 3:
for (note in c("A-2", "A#2", "B-2", "C-3", "C#3",
               "D-3", "D#3", "E-3", "F-3", "F#3",
               "G-3", "G#3"))
{
  playSample(PTSample(mod.intro, 3), note = note, silence = 0.05, loop = 0.4)
}

## play the sample at a rate based on a specific
## video mode and finetune:
playSample(PTSample(mod.intro, 3), video = "NTSC", finetune = -5)

## End(Not run)

</code></pre>

<hr>
<h2 id='playWave'>Play Wave objects</h2><span id='topic+playWave'></span><span id='topic+playWave+2CWave-method'></span><span id='topic+playWave+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Use the command line <code><a href="audio.html#topic+play">audio::play</a></code> function from the
<code>audio</code> package to play <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wave'
playWave(wave, wait = T)

## S4 method for signature 'WaveMC'
playWave(wave, wait = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playWave_+3A_wave">wave</code></td>
<td>
<p>An object of class <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> or
<code><a href="tuneR.html#topic+WaveMC">tuneR::WaveMC</a></code>. Note that the playing routine implemented
here can only play stereo waves. Multi-channel waves are therefore
converted to stereo before playing.</p>
</td></tr>
<tr><td><code id="playWave_+3A_wait">wait</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code> the playing
routine will wait with executing any code until the playing is
finished. When set to <code>FALSE</code>, subsequent R code will be
executed while playing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the <code><a href="tuneR.html#topic+tuneR">tuneR</a></code> package play-function relies on external
players, this method is provided as a convenient approach to play
samples in the R console, using the <code>audio</code> package. Wave
objects are played at the rate as specified in the object. Of course
you can also play the <code>Wave</code> objects with the <code>tuneR</code> implementation
of <code><a href="tuneR.html#topic+play">tuneR::play</a></code>, by calling <code>tuneR::play(wave)</code>.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="audio.html#topic+audioInstance-methods">audio::$.audioInstance</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other play.audio.routines: 
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playSample">playSample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mod.intro)

## PTSample objects can also be
## played with this function as they
## are a child of the Wave object:
playWave(PTSample(mod.intro, 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot'>Plot a PTModule object</h2><span id='topic+plot'></span><span id='topic+plot+2CPTModule+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots the waveforms of the (non-empty) <code><a href="#topic+PTSample">PTSample</a></code>s in a
<code><a href="#topic+PTModule">PTModule</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule,missing'
plot(x, y, plot.loop.positions = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the
waveforms of the <code><a href="#topic+PTSample">PTSample</a></code>s need to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p><code>missing</code>. Argument from the generic plotting method, don't use.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot.loop.positions">plot.loop.positions</code></td>
<td>
<p>A <code>logical</code> value indicating whether
loop positions need to be visualised. For looped samples, the starting
and ending positions are marked by a vertical green and red line, respectively.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments that are passed on to <code><a href="lattice.html#topic+xyplot">lattice::xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plotting routine based on the <code><a href="lattice.html#topic+xyplot">lattice::xyplot</a></code> from the
lattice-package. Plots each (non-empty) waveform in a separate panel. Use arguments
of the <code><a href="lattice.html#topic+xyplot">lattice::xyplot</a></code> function to customise the plot.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>trellis</code>. See documentation of
<code><a href="lattice.html#topic+xyplot">lattice::xyplot</a></code> for more details.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get the example PTModule provided with the ProTrackR package
data("mod.intro")

## The most basic way to plot the module samples:
plot(mod.intro)

## By using xyplot arguments, we can make it look nicer:
plot(mod.intro, type = "l", layout = c(1,4),
     scales = list(x = list(relation = "free")))
</code></pre>

<hr>
<h2 id='print'>Print ProTrackR objects</h2><span id='topic+print'></span><span id='topic+print+2CPTCell-method'></span><span id='topic+print+2CPTTrack-method'></span><span id='topic+print+2CPTPattern-method'></span><span id='topic+print+2CPTSample-method'></span><span id='topic+print+2CPTModule-method'></span>

<h3>Description</h3>

<p>A method to print <a href="#topic+ProTrackR-package">ProTrackR</a> S4 class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
print(x, ...)

## S4 method for signature 'PTTrack'
print(x, ...)

## S4 method for signature 'PTPattern'
print(x, ...)

## S4 method for signature 'PTSample'
print(x, ...)

## S4 method for signature 'PTModule'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Either a <code><a href="#topic+PTModule">PTModule</a></code>, <code><a href="#topic+PTPattern">PTPattern</a></code>,
<code><a href="#topic+PTTrack">PTTrack</a></code>, <code><a href="#topic+PTCell">PTCell</a></code> or
<code><a href="#topic+PTSample">PTSample</a></code> object.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the class of <code>x</code>, returns either nothing
(<code>NULL</code>) or a <code>character</code> representation
of object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")
print(mod.intro)
print(PTPattern(mod.intro, 1))
print(PTTrack(mod.intro, 1, 1))
print(PTCell   (mod.intro, 1, 1, 1))
print(PTSample (mod.intro, 1))
</code></pre>

<hr>
<h2 id='proTrackerVibrato'>Get the vibrato table used by ProTracker</h2><span id='topic+proTrackerVibrato'></span>

<h3>Description</h3>

<p>Gets the vibrato table as used by ProTracker in vibrato effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proTrackerVibrato(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proTrackerVibrato_+3A_x">x</code></td>
<td>
<p><code>integer</code> representing the table index ranging from 0
up to 31. Values outside this range can be used, but will produce
results that are not valid in the context of ProTracker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the old Commodore Amiga computer didn't have built-in mathematical functions,
many programs on that machine used their own data tables. As did ProTracker
for vibrato effects for which a sine function was used. As there was no sine
function that could be called, sine values were stored in a table.
</p>
<p>This function returns the <code>integer</code> sine values (ranging from 0 up
to 255) as a function of the table index (ranging from 0 up to 31).
</p>


<h3>Value</h3>

<p>Returns an <code>integer</code> sine value ranging from 0 up to 255
when a valid table index (<code>x</code>) is provided. It will otherwise return
a sine value ranging from -255 up to 255.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this will return the table as used in ProTracker
proTrackerVibrato(0:31)
</code></pre>

<hr>
<h2 id='PTBlock'>Select and copy a range of PTCells into a PTBlock</h2><span id='topic+PTBlock'></span><span id='topic+PTBlock+2CPTPattern+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Select and copy a range of <code><a href="#topic+PTCell">PTCell</a></code>s from a
<code><a href="#topic+PTPattern">PTPattern</a></code> into a <code>PTBlock</code>. This
allows a more flexible approach to select and modify
<code><a href="#topic+PTCell">PTCell</a></code>s and paste the modified cells back into
a <code><a href="#topic+PTPattern">PTPattern</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTPattern,numeric,numeric'
PTBlock(pattern, row, track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTBlock_+3A_pattern">pattern</code></td>
<td>
<p>A <code><a href="#topic+PTPattern">PTPattern</a></code> object from which the
<code>PTBlock</code> needs to be selected.</p>
</td></tr>
<tr><td><code id="PTBlock_+3A_row">row</code></td>
<td>
<p>A <code>numeric</code> index or indices of rows that needs to be
copied from the <code>pattern</code> into the PTBlock.</p>
</td></tr>
<tr><td><code id="PTBlock_+3A_track">track</code></td>
<td>
<p>A <code>numeric</code> index or indices of tracks that needs to be
copied from the <code>pattern</code> into the PTBlock.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most objects in this <a href="#topic+ProTrackR-package">ProTrackR</a> package are very strict in the operations
that are allowed, in order to guarantee validity and compatibility with
the original ProTracker. This makes those objects not very flexible.
</p>
<p>This <code><a href="#topic+PTBlock">PTBlock</a></code> is not a formal S4 object, in fact you
can hardly call it an object at all. It is just a <code>matrix</code>, where each
element holds a <code>list</code> with a single <code><a href="#topic+PTCell">PTCell</a></code>.
</p>
<p>This <code>matrix</code> is very flexible and makes it easier to select and modify
the cells. This flexibility comes at a cost as validity is only checked
at the level of the <code><a href="#topic+PTCell">PTCell</a></code>s. The <code>PTBlock</code>
can be pasted back into a <code><a href="#topic+PTPattern">PTPattern</a></code> with the
<code><a href="#topic+pasteBlock">pasteBlock</a></code> method. At which point validity will be checked again. If your modifications
resulted in violation of ProTracker standards, you should not be able to
paste the block into a pattern.
</p>


<h3>Value</h3>

<p>Returns a <code>matrix</code> from the selected <code>row</code>s and <code>track</code>s
from the <code>pattern</code>. Each element in the <code>matrix</code> is a <code>list</code> holding
a single <code><a href="#topic+PTCell">PTCell</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other block.operations: 
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## in most ProTrackR methods you can only select a single row or track.
## with a PTBlock your selection is more flexible.

## select rows 4 up to 8 and tracks 2 up to 4, from the first
## pattern table in mod.intro:

block &lt;- PTBlock(PTPattern(mod.intro, 1), 4:8, 2:4)

## 'block' is now a matrix with in each a list with a PTCell.
## These can now easily be accessed and modified:

cell1 &lt;- block[1, 1][[1]]

print(cell1)
</code></pre>

<hr>
<h2 id='PTCell-class'>The PTCell class</h2><span id='topic+PTCell-class'></span><span id='topic+PTCell'></span>

<h3>Description</h3>

<p>The <code>PTCell</code> class is the smallest possible element of a <code><a href="#topic+PTPattern">PTPattern</a></code>
table. It holds all information on which note to play, at which frequency,
with which effect and what kind of triggers or jumps should be applied.
</p>


<h3>Details</h3>

<p>The <code>PTCell</code> class consists of a <code>vector</code> of four <code>raw</code> values,
as specified in the 'Slots' section. A cell will tell which <code><a href="#topic+PTSample">PTSample</a></code>
is to be played at which frequency (corresponding to a note and octave). If
no octave or note is specified, nothing will be played, or if a sample was
started to play on the same <code><a href="#topic+PTTrack">PTTrack</a></code>, this sample will continue
playing. The <code>PTCell</code> can also hold <code>effect()</code> codes which
can be used to add audio effects to the sample being played, change the
speed/tempo at which patterns are played, or trigger jumps to other positions
within a <code><a href="#topic+PTPattern">PTPattern</a></code> or to other positions in the
<code><a href="#topic+patternOrder">patternOrder</a></code> table.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A <code>vector</code> of class <code>raw</code> of length 4. The <code>raw</code>
data is stored identical to the way it is stored in a ProTracker module
file. The <code>character</code> representation is easier to understand, and
with the <a href="#topic+ProTrackR-package">ProTrackR</a> package it shouldn't be necessary to manipulate
the <code>raw</code> data directly.
</p>
<p>The structure is illustrated with an example. Let's start with a
<code>character</code> representation of a <code>PTCell</code> as an example: <code>"C-3 1B A08"</code>.
The left-hand part of this string shows that this cell will play note &quot;C&quot; in
octave 3. The middle part shows that <code><a href="#topic+PTSample">PTSample</a></code> number <code>0x1B = 27</code>
will be played. The right-hand part of the string shows that effect &quot;A08&quot;
will be applied (which is a volume slide down).
</p>
<p>The <code>raw</code> representation of this example would be <code>"10 d6 ba 08"</code>,
or when I replace the actual values with symbols: <code>"sp pp se ee"</code>. Where
<code>"ss"</code> represents the sample number, <code>"eee"</code> represents the <code><a href="#topic+effect">effect()</a></code>
code and <code>"ppp"</code> represents the period value. The correct note and octave
can be derived by looking up the period value in the <code><a href="#topic+period_table">period_table</a></code>
(which is also implemented in the following methods: <code><a href="#topic+note">note()</a></code>,
<code><a href="#topic+octave">octave()</a></code> and <code><a href="#topic+periodToChar">periodToChar()</a></code>).
The period value <code>0x0d6 = 214</code> corresponds with note &quot;C&quot;
in octave 3.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other cell.operations: 
<code><a href="#topic+PTCell-method">PTCell-method</a></code>,
<code><a href="#topic+effect">effect</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+sampleNumber">sampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the PTCell from mod.intro at
## PTPattern #1, PTTrack #1 and row #1:

cell &lt;- PTCell(mod.intro, 1, 1, 1)

## get the note of this cell:
note(cell)

## get the octave of this cell:
octave(cell)

## get the sampleNumber of this cell:
sampleNumber(cell)

## get the effect code of this cell:
effect(cell)

## get the raw data of this cell:
as.raw(cell)

## get the character representation of this cell:
as.character(cell)
</code></pre>

<hr>
<h2 id='PTCell-method'>Coerce to or replace PTCell</h2><span id='topic+PTCell-method'></span><span id='topic+PTCell+2Craw+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+PTCell+2Ccharacter+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+PTCell+2CPTModule+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+PTCell+3C-'></span><span id='topic+PTCell+3C-+2CPTModule+2Cnumeric+2Cnumeric+2Cnumeric+2CPTCell-method'></span><span id='topic+PTCell+2CPTPattern+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+PTCell+3C-+2CPTPattern+2Cnumeric+2Cnumeric+2Cmissing+2CPTCell-method'></span><span id='topic+PTCell+2CPTTrack+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+PTCell+3C-+2CPTTrack+2Cnumeric+2Cmissing+2Cmissing+2CPTCell-method'></span><span id='topic+PTCell+3C-+2CPTTrack+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>This method will coerce a set of objects to a <code>PTCell</code> object. It can also
be used to select specific cells from <code>PTModule</code>,
<code>PTPattern</code> and <code>PTTrack</code> objects and replace
the selected <code>PTCell</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw,missing,missing,missing'
PTCell(x)

## S4 method for signature 'character,missing,missing,missing'
PTCell(x)

## S4 method for signature 'PTModule,numeric,numeric,numeric'
PTCell(x, row, track, pattern)

## S4 replacement method for signature 'PTModule,numeric,numeric,numeric,PTCell'
PTCell(x, row, track, pattern) &lt;- value

## S4 method for signature 'PTPattern,numeric,numeric,missing'
PTCell(x, row, track)

## S4 replacement method for signature 'PTPattern,numeric,numeric,missing,PTCell'
PTCell(x, row, track) &lt;- value

## S4 method for signature 'PTTrack,numeric,missing,missing'
PTCell(x, row)

## S4 replacement method for signature 'PTTrack,numeric,missing,missing,PTCell'
PTCell(x, row) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTCell-method_+3A_x">x</code></td>
<td>
<p>Object (any of <code>raw</code> data, a <code>character</code> string, a <code>PTTrack</code>,
a <code>PTPattern</code> or a <code>PTModule</code>)
to coerce to a <code><a href="#topic+PTCell">PTCell</a></code>. See details below for the
required format of <code>x</code>.</p>
</td></tr>
<tr><td><code id="PTCell-method_+3A_row">row</code></td>
<td>
<p>When <code>x</code> is a <code>PTTrack</code>, a <code>PTPattern</code>,
or a <code>PTModule</code>, provide an index [1,64] of the row that needs
to be coerced to a <code>PTCell</code>.</p>
</td></tr>
<tr><td><code id="PTCell-method_+3A_track">track</code></td>
<td>
<p>When <code>x</code> is a <code>PTPattern</code>,
or a <code>PTModule</code>, provide an index [1,4] of the track that needs
to be coerced to a <code>PTCell</code>.</p>
</td></tr>
<tr><td><code id="PTCell-method_+3A_pattern">pattern</code></td>
<td>
<p>When <code>x</code> is a <code>PTModule</code>, provide an index
of the pattern that needs to be coerced to a <code>PTCell</code>. Note that
ProTracker uses indices for patterns that start at zero, whereas R uses indices
that start at one. Hence add one to an index obtained from a <code>PTModule</code>
object (e.g., <code>x$pattern.order</code>)</p>
</td></tr>
<tr><td><code id="PTCell-method_+3A_value">value</code></td>
<td>
<p>An object of <code><a href="#topic+PTCell">PTCell</a></code> with which the <code><a href="#topic+PTCell">PTCell</a></code>
object at the specified indices in object <code>x</code> needs to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method to coerce <code>x</code> to class <code><a href="#topic+PTCell">PTCell</a></code>.
</p>
<p>When <code>x</code> is <code>raw</code> data, it should consist of a <code>vector</code> of
4 elements, formatted as specified in the <code><a href="#topic+PTCell-class">PTCell</a></code>.
</p>
<p>When <code>x</code> is a <code>character</code> string, it should be formatted as follows:
&quot;<code style="white-space: pre;">&#8288;NNO SS EEE&#8288;</code>&quot;, where <code>NN</code> is the note (for instance
&quot;C-&quot; or &quot;A#&quot;, where the dash has no particular meaning and may be omitted,
the hash sign indicates a sharp note). Use a dash if the cell holds no note.
<code>O</code> is the octave (with a value of 0, or a dash, if a note
is missing, otherwise any of 1, 2 or 3). <code>SS</code> is the sample index
number, formatted as two hexadecimal digits (for example <code style="white-space: pre;">&#8288;1A&#8288;</code>). <code>EEE</code> is
a three hexadecimal digit <code><a href="#topic+effect">effect</a></code> or trigger code (for more details see the
<code><a href="#topic+PTCell-class">PTCell</a></code>). The method is not case sensitive, so
you can use both upper and lower case. White spaces are ignored, you can use
as many as you would like. A correct <code>character</code> input for <code>x</code>
would be for example: <code>"A#2 01 A0F"</code>. A <code>blank</code> <code>character</code>
representation would look like this: <code>"--- 00 000"</code>.
</p>
<p>When <code>x</code> is of class <code><a href="#topic+PTTrack">PTTrack</a></code>, <code><a href="#topic+PTPattern">PTPattern</a></code>, or
<code><a href="#topic+PTModule">PTModule</a></code>, the <code>PTCell</code> at the specified indices (<code>row</code>,
<code>track</code> and <code>pattern</code>) is returned, or can be replaced.
</p>


<h3>Value</h3>

<p>When <code>PTCell</code> is used, a <code>PTCell</code> object
based on <code>x</code> is returned.
</p>
<p>When <code style="white-space: pre;">&#8288;PTCell&lt;-&#8288;</code> is used, object <code>x</code> is returned in which
the selected <code>PTCell</code> is replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other cell.operations: 
<code><a href="#topic+PTCell-class">PTCell-class</a></code>,
<code><a href="#topic+effect">effect</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+sampleNumber">sampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This will create an empty PTCell (equivalent
## to new("PTCell"):
PTCell(raw(4))

## Use a character representation to create
## a new PTCell object. A cell with note
## B in octave 2, sample number 10 and with
## effect '105':
cell &lt;- PTCell("B-2 0A 105")

data("mod.intro")

## replace PTCell at pattern number 1, track
## number 2, and row number 3:
PTCell(mod.intro, 3, 2, 1) &lt;- cell

</code></pre>

<hr>
<h2 id='PTModule-class'>The PTModule class</h2><span id='topic+PTModule-class'></span><span id='topic+PTModule'></span>

<h3>Description</h3>

<p>The PTModule class provides a container to store and modify and use ProTracker
module files.
</p>


<h3>Details</h3>

<p>MOD is a computer file format used primarily to represent music. A MOD file
contains a set of instruments in the form of samples, a number of patterns
indicating how and when the samples are to be played, and a list of what
patterns to play in what order. The simplified structure of a module class is
visualised in the scheme below. Details are given in the slot descriptions
below.
</p>
<p><img src="../help/figures/protrackerscheme.png" alt="ProTracker conceptual scheme" />

</p>
<p>This class is designed to hold all relevant information of a ProTracker
module (MOD) for which ProTracker 2.3a documentation was used. The ProTrackR
package may be compatible with earlier or later versions, but this was not
tested. Use <code><a href="#topic+read.module">read.module</a></code> and <code><a href="#topic+write.module">write.module</a></code> to import
and export objects of class <code>PTModule</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>A <code>vector</code> of length 20 of class <code>raw</code>, representing
the name of the <code>PTModule</code>. The name
of a module can be extracted or replaced with the <code><a href="#topic+name">name</a></code> method.</p>
</dd>
<dt><code>pattern.order</code></dt><dd><p>A <code>vector</code> of length 128 of class <code>raw</code>. The
<code>raw</code> values represent the indices of <code>PTPattern</code> tables and indicate
in which order these patterns need to be played. Note that the <code>raw</code> values
are conform the indices used in ProTracker, starting at zero. In R, indices of
objects start at one. Users need to compensate for this discrepancy theirselves.
</p>
<p>The pattern order table can be extracted or replaced with the
<code><a href="#topic+patternOrder">patternOrder</a></code> method.</p>
</dd>
<dt><code>pattern.order.length</code></dt><dd><p>A single value of class <code>raw</code>. Indicates
the length of the visible (and playable) part of the pattern order table.
</p>
<p>Use the <code><a href="#topic+patternOrderLength">patternOrderLength</a></code> method to extract or replace the length
of a pattern order table of a module.</p>
</dd>
<dt><code>tracker.byte</code></dt><dd><p>A single <code>raw</code> value. Gives an indication of which
Tracker was used to produce a module file. In ProTracker modules, this byte
is set to 0x7f, which is also used in <code>PTModule</code> objects. This value
should not be changed.</p>
</dd>
<dt><code>tracker.flag</code></dt><dd><p>A <code>vector</code> of length 4 of class <code>raw</code>, indicates
the version of a module, which basically reflects how many patterns the module
can hold. For details, and extracting and replacing this flag see the
<code><a href="#topic+trackerFlag">trackerFlag</a></code> method.</p>
</dd>
<dt><code>samples</code></dt><dd><p>List of length 31 of class &quot;<code><a href="#topic+PTSample">PTSample</a></code>&quot;.</p>
</dd>
<dt><code>patterns</code></dt><dd><p>List of class &quot;<code><a href="#topic+PTPattern">PTPattern</a></code>&quot; (the pattern tables).
The list should have at least 1 element, and can have a maximum of 64 or
100 elements (depending on the state of the <code><a href="#topic+trackerFlag">trackerFlag</a></code>).</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/MOD_(file_format)">https://en.wikipedia.org/wiki/MOD_(file_format)</a>
</p>
<p><a href="https://wiki.multimedia.cx/index.php?title=Protracker_Module">https://wiki.multimedia.cx/index.php?title=Protracker_Module</a>
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an empty PTModule class object:
mod.empty &lt;- new("PTModule")

## get an example PTModule class object
## provided with the ProTrackR package:
data("mod.intro")

</code></pre>

<hr>
<h2 id='PTPattern-class'>The PTPattern class</h2><span id='topic+PTPattern-class'></span><span id='topic+PTPattern'></span>

<h3>Description</h3>

<p>The <code>PTPattern</code> (or simply pattern) is a table that determines which
samples are played at which notes in which octave, in which order and with
which effects.
</p>


<h3>Details</h3>

<p>When a <code>PTPattern</code> table (or simply pattern) is played, each of the 64
rows (see the green mark in the illustration below for an example of a row)
are played subsequently at a specified speed/tempo.
</p>
<p>Note that ProTracker uses row indices that start at zero. However, this package
uses indices starting at one, conform R language definitions.
</p>
<p><img src="../help/figures/patterntable.png" alt="Pattern Table" />

</p>
<p>The table has four columns (see the purple outline in the illustration
above as an example of a column), representing the four audio channels (<code><a href="#topic+PTTrack">PTTrack</a></code>)
of the Commodore Amiga. Samples listed in the same row at different
tracks will be played simultaneously.
</p>
<p>An element at a specific row and track will be referred to as a <code><a href="#topic+PTCell">PTCell</a></code>
(or simply cell). The cell determines which sample needs to be played at
which note and octave and what kind of <code><a href="#topic+effect">effect</a></code> or trigger should
be applied.
</p>
<p>With the <code><a href="#topic+PTPattern-method">PTPattern-method</a></code>, objects can be coerced to a pattern
table. This method can also be used to extract or replace patterns in
<code><a href="#topic+PTModule">PTModule</a></code> objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A <code>matrix</code> (64 rows, 16 columns) of class <code>raw</code>.
Each row contains the <code>raw</code> concatenated data of 4 <code><a href="#topic+PTCell">PTCell</a></code> objects,
representing each of the 4 audio channels/tracks (as each <code><a href="#topic+PTCell">PTCell</a></code> object holds
4 <code>raw</code> values, each row holds 4 x 4 = 16 <code>raw</code>
values). The <code>raw</code> data is formatted conform the specifications given
in the <code><a href="#topic+PTCell">PTCell</a></code> documentation.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>

<hr>
<h2 id='PTPattern-method'>Coerce to or replace PTPattern</h2><span id='topic+PTPattern-method'></span><span id='topic+PTPattern+2Craw+2Cmissing-method'></span><span id='topic+PTPattern+2Cmatrix+2Cmissing-method'></span><span id='topic+PTPattern+2CPTModule+2Cnumeric-method'></span><span id='topic+PTPattern+3C-'></span><span id='topic+PTPattern+3C-+2CPTModule+2Cnumeric+2CPTPattern-method'></span>

<h3>Description</h3>

<p>This method will coerce a set of objects to a <code>PTPattern</code> object. It can also
be used to select specific patterns from <code>PTModule</code> objects and replace
the selected <code>PTPattern</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw,missing'
PTPattern(x)

## S4 method for signature 'matrix,missing'
PTPattern(x)

## S4 method for signature 'PTModule,numeric'
PTPattern(x, pattern)

## S4 replacement method for signature 'PTModule,numeric,PTPattern'
PTPattern(x, pattern) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTPattern-method_+3A_x">x</code></td>
<td>
<p>Object (any of <code>raw</code> data, a 64 by 16 <code>matrix</code> of <code>raw</code> data, a 64 by 4 <code>matrix</code> of <code>character</code> strings,
or a <code>PTModule</code>)
to coerce to a <code><a href="#topic+PTPattern">PTPattern</a></code>. See details below for the
required format of <code>x</code>.</p>
</td></tr>
<tr><td><code id="PTPattern-method_+3A_pattern">pattern</code></td>
<td>
<p>When <code>x</code> is a <code>PTModule</code>, provide an index
of the pattern that needs to be coerced to a <code>PTPattern</code>. Note that
ProTracker uses indices for patterns that start at zero, whereas R uses indices
that start at one. Hence add one to an index obtained from a <code>PTModule</code>
object (e.g., <code>x$pattern.order</code>).</p>
</td></tr>
<tr><td><code id="PTPattern-method_+3A_value">value</code></td>
<td>
<p>An object of <code><a href="#topic+PTPattern">PTPattern</a></code> with which the <code><a href="#topic+PTPattern">PTPattern</a></code>
object at the specified <code>index</code> in object <code>x</code> needs to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method to coerce <code>x</code> to class <code><a href="#topic+PTPattern">PTPattern</a></code>.
</p>
<p>When <code>x</code> is a 64 by 16 <code>matrix</code> of <code>raw</code> data, each row
implicitly represents the <code><a href="#topic+PTCell">PTCell</a></code> objects of each of the
four tracks. Each <code><a href="#topic+PTCell">PTCell</a></code> consists of four <code>raw</code>
values. The values in each row are formatted accordingly, where the values of the
cells of each track are concatenated. See <code><a href="#topic+PTCell-class">PTCell</a></code> documentation for
more details on the <code>raw</code> format of a <code><a href="#topic+PTCell">PTCell</a></code> object.
</p>
<p>When <code>x</code> is a 64 by 16 <code>matrix</code> of <code>character</code> representations
of <code><a href="#topic+PTCell">PTCell</a></code> objects, the <code>character</code> representation must be
conform the specifications as documented at the <code><a href="#topic+PTCell-class">PTCell</a></code>.
</p>
<p>When <code>x</code> is of class <code><a href="#topic+PTModule">PTModule</a></code>, the <code>PTPattern</code> at the
specified index (<code>pattern</code>) is returned, or can be replaced.
</p>


<h3>Value</h3>

<p>When <code>PTPattern</code> is used, a <code>PTPattern</code> object
based on <code>x</code> is returned.
</p>
<p>When <code style="white-space: pre;">&#8288;PTPattern&lt;-&#8288;</code> is used, object <code>x</code> is returned in which
the selected <code>PTPattern</code> is replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPatternToMODPlug">PTPatternToMODPlug</a>()</code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This will create an 'empty' PTPattern with
## all 0x00 values, which is equivalent to
## new("PTPattern"):
PTPattern(as.raw(0x00))

## Create a PTPattern based on repeated
## PTCell character representations:
pat &lt;- PTPattern(matrix("F#2 1A 20A", 64, 4))

data("mod.intro")

## Replace the first pattern in the patternOrder
## table in mod.intro with 'pat' (don't forget to
## add one (+1) to the index):
PTPattern(mod.intro,
          patternOrder(mod.intro)[1] + 1) &lt;- pat
</code></pre>

<hr>
<h2 id='PTPatternToMODPlug'>Convert PTPattern data into a MODPlug pattern</h2><span id='topic+PTPatternToMODPlug'></span>

<h3>Description</h3>

<p>Use a <code><a href="#topic+PTPattern">PTPattern</a></code> or <code><a href="#topic+PTBlock">PTBlock</a></code> to create
a pattern table with a MODPlug flavour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PTPatternToMODPlug(x, to.clipboard = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTPatternToMODPlug_+3A_x">x</code></td>
<td>
<p>Either a <code><a href="#topic+PTPattern">PTPattern</a></code> object or a
<code><a href="#topic+PTBlock">PTBlock</a></code> object from which an Open
MODPlug Tracker pattern should be created.</p>
</td></tr>
<tr><td><code id="PTPatternToMODPlug_+3A_to.clipboard">to.clipboard</code></td>
<td>
<p>A <code>logical</code> value, indicating whether the
result should be copied to the system's clipboard (<code>TRUE</code>) or
should be returned as a <code>vector</code> of <code>character</code>s
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Open MODPlug Tracker (<a href="https://openmpt.org">https://openmpt.org</a>) is a modern
music tracker that is for free. It too can handle ProTracker modules.
This function assists in moving pattern data from R to Open MPT.
</p>


<h3>Value</h3>

<p>Returns an invisible <code>NULL</code> when
argument <code>to.clipboard</code> is set to <code>TRUE</code>.
Returns an Open MODPlug Tracker flavoured pattern table as
a <code>vector</code> of <code>character</code>s when it is set to <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other MODPlug.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>
</p>
<p>Other pattern.operations: 
<code><a href="#topic+MODPlugToPTPattern">MODPlugToPTPattern</a>()</code>,
<code><a href="#topic+PTPattern-class">PTPattern-class</a></code>,
<code><a href="#topic+PTPattern-method">PTPattern-method</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+pasteBlock">pasteBlock</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## get some pattern data

pattern &lt;- PTPattern(mod.intro, 1)

## Now create a MODPlug pattern from this.
## The result is placed on the system clipboard.
## You can check by pasting it into a text
## editor, or better yet, the MODPlug Tracker.

PTPatternToMODPlug(pattern)

## If you want to handle the pattern data
## in R:

patModPlug &lt;- PTPatternToMODPlug(pattern, F)

## We can do the same with a block:

block &lt;- PTBlock(pattern, 1:10, 2:3)
PTPatternToMODPlug(block)

## End(Not run)
</code></pre>

<hr>
<h2 id='PTSample-class'>The PTSample class</h2><span id='topic+PTSample-class'></span><span id='topic+PTSample'></span>

<h3>Description</h3>

<p>This class holds audio fragments with meta-information, to be used in
<code><a href="#topic+PTModule">PTModule</a></code> objects.
</p>


<h3>Details</h3>

<p>This class holds audio fragments with meta-information (so-called samples),
to be used in <code><a href="#topic+PTModule">PTModule</a></code> objects. This class extends
the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class from <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code>. It therewith inherits
all properties and cool methods available from the <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code> package.
This allows you, for instance, to generate power spectra (<code><a href="tuneR.html#topic+powspec">tuneR::powspec</a></code>)
of them. You can also plot the waveform with the <code><a href="tuneR.html#topic+plot-Wave">plot-Wave</a></code> method.
See <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code> for all possibilities with <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code>
objects.
If you want you can also explicitly coerce <code><a href="#topic+PTSample">PTSample</a></code> to
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> objects like this: <code>as(new("PTSample"), "Wave")</code>.
</p>
<p>The <code><a href="#topic+PTSample">PTSample</a></code> class has some slots that are additional to the
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class, as ProTracker requires additional information on
the sample with respect to its name, fine tune, volume and loop positions.
The <code><a href="#topic+PTSample">PTSample</a></code> class restricts the enherited <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code>
class such that it will only hold 8 bit, mono, pcm waves with a maximum of
<code>2*0xffff = 131070</code> samples, as per ProTracker standards. The length should
always be even.
</p>
<p><code>PTSample</code>s can be imported and exported using the
<code><a href="#topic+read.sample">read.sample</a></code> and <code><a href="#topic+write.sample">write.sample</a></code> methods respectively.
<code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> objects and <code>raw</code> data can be coerced to
<code>PTSample</code>s with the <code><a href="#topic+PTSample-method">PTSample-method</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>A <code>vector</code> of length 22 of class <code>raw</code>, representing
the name of the <code>PTSample</code>. It is often used to include
descriptive information in a <code><a href="#topic+PTModule">PTModule</a></code>. The name
of a sample can be extracted or replaced with the <code><a href="#topic+name">name</a></code> method.</p>
</dd>
<dt><code>finetune</code></dt><dd><p>Single value of class <code>raw</code>. The <code><a href="#topic+loNybble">loNybble</a></code>
of the <code>raw</code> value, represents the sample fine tune value ranging from -8 up to
7. This value is used to tweak the playback sample rate, in order to tune it.
Negative values will lower the sample rate of notes, positive values will
increase the sample rate of notes. Period values corresponding to specific
notes and fine tune values are stored in the <code><a href="#topic+period_table">period_table</a></code>.
The fine tune value can be extracted or replace with the <code><a href="#topic+fineTune">fineTune</a></code>
method.</p>
</dd>
<dt><code>volume</code></dt><dd><p>Single value of class <code>raw</code>. The raw data corresponds with
the default playback volume of the sample. It ranges from 0 (silent) up to
64 (maximum volume). The volume value can be extracted or replaced with the
<code><a href="#topic+volume">volume</a></code> method.</p>
</dd>
<dt><code>wloopstart</code></dt><dd><p>A <code>vector</code> of length 2 of class <code>raw</code>. The <code>raw</code>
data represent a single unsigned number representing the starting position of
a loop in the sample. It should have a value of <code>0</code> when there is no loop.
Its value could range from <code>0</code> up to <code>0xffff</code>. To get the actual position
in bytes the value needs to be multiplied with 2 and can therefore only be
can only be even. The sum of the loop start position and the loop length should
not exceed the <code><a href="#topic+sampleLength">sampleLength</a></code>. Its value can be extracted or
replaced with the <code><a href="#topic+loopStart">loopStart</a></code> method.</p>
</dd>
<dt><code>wlooplen</code></dt><dd><p>A <code>vector</code> of length 2 of class <code>raw</code>. The <code>raw</code>
data represent a single unsigned number representing the length of
a loop in the sample. To get the actual length in bytes, this value needs to
be multiplied by 2 and can therefore only be even. It should have a value of
<code>2</code> when there is no loop.
Its value could range from <code>2</code> up to <code>2*0xffff</code> (= <code>131070</code>) and
can only be even (it can be <code>0</code> when the sample is empty). The sum of the
loop start position and the loop length should
not exceed the <code><a href="#topic+sampleLength">sampleLength</a></code>. Its value can be extracted or
replaced with the <code><a href="#topic+loopLength">loopLength</a></code> method.</p>
</dd>
<dt><code>left</code></dt><dd><p>Object of class <code>numeric</code> representing the waveform of the
left channel. Should be <code>integer</code> values ranging from 0 up to 255.
It can be extracted or replaced with the <code><a href="#topic+waveform">waveform</a></code> method.</p>
</dd>
<dt><code>right</code></dt><dd><p>Object of class <code>numeric</code> representing the right channel.
This slot is inherited from the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class and should be
<code>numeric(0)</code> for all <code>PTSample</code>s, as they are all mono.</p>
</dd>
<dt><code>stereo</code></dt><dd><p>Object of class <code>logical</code> whether this is a stereo representation.
This slot is inherited from the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class. As
<code>PTSample</code>s are always mono, this slot should have the value <code>FALSE</code>.</p>
</dd>
<dt><code>samp.rate</code></dt><dd><p>Object of class <code>numeric</code> representing the sampling rate.</p>
</dd>
<dt><code>bit</code></dt><dd><p>Object of class <code>numeric</code> representing the bit-wise quality.
This slot is inherited from the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class. As
<code>PTSample</code>s are always of 8 bit quality, the value of this slot
should always be 8.</p>
</dd>
<dt><code>pcm</code></dt><dd><p>Object of class <code>logical</code> indicating whether wave format is PCM.
This slot is inherited from the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class, for
<code>PTSample</code>s its value should always be <code>TRUE</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>

<hr>
<h2 id='PTSample-method'>Coerce to or replace PTSample</h2><span id='topic+PTSample-method'></span><span id='topic+PTSample+2CWave+2Cmissing-method'></span><span id='topic+PTSample+2Craw+2Cmissing-method'></span><span id='topic+PTSample+2CPTModule+2Cnumeric-method'></span><span id='topic+PTSample+3C-'></span><span id='topic+PTSample+3C-+2CPTModule+2Cnumeric+2CPTSample-method'></span>

<h3>Description</h3>

<p>This method will coerce a set of objects to a <code>PTSample</code> object. It can also
be used to select specific samples from <code>PTModule</code> objects and replace
the selected <code>PTSample</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wave,missing'
PTSample(x)

## S4 method for signature 'raw,missing'
PTSample(x)

## S4 method for signature 'PTModule,numeric'
PTSample(x, index)

## S4 replacement method for signature 'PTModule,numeric,PTSample'
PTSample(x, index) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTSample-method_+3A_x">x</code></td>
<td>
<p>Object (any of class <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code>, a <code>vector</code>
of <code>raw</code> data, or of class <code><a href="#topic+PTModule">PTModule</a></code>) that needs to
be coerced to a <code><a href="#topic+PTSample">PTSample</a></code> object. In the latter case, the
object can also be replaced.</p>
</td></tr>
<tr><td><code id="PTSample-method_+3A_index">index</code></td>
<td>
<p>A positive <code>integer</code> index of the sample in <code><a href="#topic+PTModule">PTModule</a></code>
<code>x</code> that needs to be returned or replaced.</p>
</td></tr>
<tr><td><code id="PTSample-method_+3A_value">value</code></td>
<td>
<p>An object of <code><a href="#topic+PTSample">PTSample</a></code> with which the <code><a href="#topic+PTSample">PTSample</a></code>
object at the specified <code>index</code> in object <code>x</code> needs to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method to coerce <code>x</code> to class <code><a href="#topic+PTSample">PTSample</a></code>.
</p>
<p>When <code>x</code> is a <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> object, this method will not
resample it. However, the sample rate will be adjusted and samples exeeding
the maximum length of <code>2*0xffff</code> = <code>131070</code> will be clipped to this
maximum length. When <code>x</code> is a stereo sample, it will be converted to
mono, by averaging the left and right channel.
</p>
<p>When <code>x</code> is a <code>vector</code> of <code>raw</code> data, it will be truncated
if the maximum length of <code>2*0xffff</code> = <code>131070</code> is exceeded.
The raw will be converted with <code><a href="#topic+rawToSignedInt">rawToSignedInt</a></code> in order
to represent an 8 bit mono <code><a href="#topic+waveform">waveform</a></code>.
</p>
<p>As samples must have an even length (as per ProTracker specifications),
a 0x00 value is appended if the length is odd.
</p>
<p>When <code>x</code> is of class <code><a href="#topic+PTModule">PTModule</a></code>, the <code>PTSample</code> at the
specified <code>index</code> is returned, or will be replaced.
</p>


<h3>Value</h3>

<p>When <code>PTSample</code> is used, a <code>PTSample</code> object
based on <code>x</code> is returned.
</p>
<p>When <code style="white-space: pre;">&#8288;PTSample&lt;-&#8288;</code> is used, object <code>x</code> is returned in which
the selected <code>PTSample</code> is replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a raw data sine wave:
raw_sine &lt;- signedIntToRaw(round(sin(2*pi*(0:275)/276)*127))

data("mod.intro")

## Replace sample number 1 from mod.intro
## with the sine wave:
PTSample(mod.intro, 1) &lt;-
  PTSample(raw_sine)

## Note that the replacement above
## could also (maybe more efficiently)
## be done with the 'waveform' method

## Restore the loop in sample number 1:
loopLength(PTSample(mod.intro, 1)) &lt;- 276

</code></pre>

<hr>
<h2 id='PTTrack-class'>The PTTrack class</h2><span id='topic+PTTrack-class'></span><span id='topic+PTTrack'></span>

<h3>Description</h3>

<p>The four audio channels of the Commodore Amiga are represented as tracks
(the <code>PTTrack</code> class) in a <code><a href="#topic+PTPattern">PTPattern</a></code>.
</p>


<h3>Details</h3>

<p>The Commodore Amiga original chipset supported four audio channels. Meaning
that audio could be played simultaneously and independently on each of these
channels. Two channels (2 and 3) were hardware-mixed fully to the right stereo
outputs and the other two (1 and 4) fully to the left stereo outputs.
</p>
<p>This class represents such a single channel, reffered to as a track. A <code><a href="#topic+PTPattern">PTPattern</a></code> is
composed of four such channels. As a ProTracker pattern consists of 64 rows,
a <code>PTTrack</code> object is also (implicitly) composed of 64
<code><a href="#topic+PTCell">PTCell</a></code> objects.
</p>
<p>Use the <code><a href="#topic+PTTrack-method">PTTrack-method</a></code> to construct or coerce objects to a
<code>PTTrack-class</code> object, or to replace such an object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A <code>matrix</code> (64 rows, 4 columns) of class <code>raw</code>.
Each row implicetely represents a <code><a href="#topic+PTCell">PTCell</a></code> object, where
the raw data is formatted as specified at the <code><a href="#topic+PTCell-class">PTCell</a></code>
documentation. Use the <code><a href="#topic+PTCell-method">PTCell-method</a></code> to make an element of
a <code>PTTrack</code> object explictly of class <code><a href="#topic+PTCell">PTCell</a></code>.
Row numbers correspond with the row numbers of <code><a href="#topic+PTPattern">PTPattern</a></code>
objects.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Get track number 2 from pattern
## number 1 of mod.intro:
chan1 &lt;- PTTrack(mod.intro, 2, 1)

## Create a blank track:
chan2 &lt;- new("PTTrack")

## Get two more tracks:
chan3 &lt;- PTTrack(mod.intro, 1, 2)
chan4 &lt;- PTTrack(mod.intro, 4, 3)

## combine the four tracks in a
## new PTPattern:
patt &lt;- PTPattern(cbind(
  as.character(chan1),
  as.character(chan2),
  as.character(chan3),
  as.character(chan4)
))
</code></pre>

<hr>
<h2 id='PTTrack-method'>Coerce to or replace PTTrack</h2><span id='topic+PTTrack-method'></span><span id='topic+PTTrack+2Craw+2Cmissing+2Cmissing-method'></span><span id='topic+PTTrack+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic+PTTrack+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+PTTrack+2CPTModule+2Cnumeric+2Cnumeric-method'></span><span id='topic+PTTrack+3C-'></span><span id='topic+PTTrack+3C-+2CPTModule+2Cnumeric+2Cnumeric+2CPTTrack-method'></span><span id='topic+PTTrack+2CPTPattern+2Cnumeric+2Cmissing-method'></span><span id='topic+PTTrack+2Cnumeric+2Cmissing-method'></span><span id='topic+PTTrack+3C-+2CPTPattern+2Cnumeric+2Cmissing+2CPTTrack-method'></span><span id='topic+PTTrack+3C-+2Cnumeric+2Cmissing+2CPTTrack-method'></span>

<h3>Description</h3>

<p>This method will coerce a set of objects to a <code>PTTrack</code> object. It can also
be used to select specific tracks from <code>PTModule</code> and
<code>PTPattern</code> objects and replace the selected <code>PTTrack</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw,missing,missing'
PTTrack(x)

## S4 method for signature 'matrix,missing,missing'
PTTrack(x)

## S4 method for signature 'character,missing,missing'
PTTrack(x)

## S4 method for signature 'PTModule,numeric,numeric'
PTTrack(x, track, pattern)

## S4 replacement method for signature 'PTModule,numeric,numeric,PTTrack'
PTTrack(x, track, pattern) &lt;- value

## S4 method for signature 'PTPattern,numeric,missing'
PTTrack(x, track)

## S4 replacement method for signature 'PTPattern,numeric,missing,PTTrack'
PTTrack(x, track) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTTrack-method_+3A_x">x</code></td>
<td>
<p>Object (any of <code>raw</code> data, a 64 by 4 <code>matrix</code> of <code>raw</code>
data, a vector of <code>character</code> strings,
a <code>PTPattern</code> or a <code>PTModule</code>)
to coerce to a <code><a href="#topic+PTTrack">PTTrack</a></code>. See details below for the
required format of <code>x</code></p>
</td></tr>
<tr><td><code id="PTTrack-method_+3A_track">track</code></td>
<td>
<p>When <code>x</code> is a <code>PTPattern</code>,
or a <code>PTModule</code>, provide an index [1,4] of the track that needs
to be coerced to a <code>PTTrack</code>.</p>
</td></tr>
<tr><td><code id="PTTrack-method_+3A_pattern">pattern</code></td>
<td>
<p>When <code>x</code> is a <code>PTModule</code>, provide an index
of the pattern that needs to be coerced to a <code>PTTrack</code>. Note that
ProTracker uses indices for patterns that start at zero, whereas R uses indices
that start at one. Hence add one to an index obtained from a <code>PTModule</code>
object (e.g., <code>x$pattern.order</code>)</p>
</td></tr>
<tr><td><code id="PTTrack-method_+3A_value">value</code></td>
<td>
<p>An object of <code><a href="#topic+PTTrack">PTTrack</a></code> with which the <code><a href="#topic+PTTrack">PTTrack</a></code>
object at the specified indices in object <code>x</code> needs to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method to coerce <code>x</code> to class <code><a href="#topic+PTTrack">PTTrack</a></code>.
</p>
<p>When <code>x</code> is a 64 by 4 <code>matrix</code> of <code>raw</code> data, each row
implicitly represents a <code><a href="#topic+PTCell">PTCell</a></code> object and should
be formatted accordingly. See <code><a href="#topic+PTCell-class">PTCell</a></code> documentation for
more details.
</p>
<p>When <code>x</code> is a 64 element <code>vector</code> of <code>character</code> representation
of <code><a href="#topic+PTCell">PTCell</a></code> objects, the <code>character</code> representation must be
conform the specifications as documented at the <code><a href="#topic+PTCell-class">PTCell</a></code>.
</p>
<p>When <code>x</code> is of class <code><a href="#topic+PTPattern">PTPattern</a></code>, or
<code><a href="#topic+PTModule">PTModule</a></code>, the <code>PTTrack</code> at the specified indices
(<code>track</code> and <code>pattern</code>) is returned, or can be replaced.
</p>


<h3>Value</h3>

<p>When <code>PTTrack</code> is used, a <code>PTTrack</code> object
based on <code>x</code> is returned.
</p>
<p>When <code style="white-space: pre;">&#8288;PTTrack&lt;-&#8288;</code> is used, object <code>x</code> is returned in which
the selected <code>PTTrack</code> is replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other track.operations: 
<code><a href="#topic+as.character">as.character</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This will create an 'empty' PTTrack with all nul
## values, which is equivalent to new("PTTrack"):
PTTrack(as.raw(0x00))

## This will generate a PTTrack from a repeated
## character representation of a PTCell:
chan &lt;- PTTrack(rep("C-3 01 C20", 64))

data("mod.intro")

## This will replace the PTTrack at pattern
## number 1, track number 2 of mod.intro with chan:
PTTrack(mod.intro, 2, 1) &lt;- chan

</code></pre>

<hr>
<h2 id='rawToCharNull'>Convert raw vectors into a character string</h2><span id='topic+rawToCharNull'></span>

<h3>Description</h3>

<p>A function that converts <code>raw</code> data into a <code>character</code> string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToCharNull(raw_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToCharNull_+3A_raw_dat">raw_dat</code></td>
<td>
<p>A vector of class <code>raw</code> to be converted into a <code>character</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rawToChar()</code> will fail on vectors of <code>raw</code> data
with embedded <code>0x00</code> data. This function will not fail on embedded <code>0x00</code> values.
Instead, it will replace embedded <code>0x00</code> data with white spaces. Note that
leading and trailing <code>0x00</code> data will be omitted from the result.
</p>


<h3>Value</h3>

<p>A <code>character</code> string based on the <code>raw</code> data
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other character.operations: 
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+sampleRate">sampleRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some raw data with an embedded 0x00:
some.raw.data &lt;- as.raw(c(0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
                          0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21))
## Not run: 
## this will fail:
try(rawToChar(some.raw.data))

## End(Not run)

## this will succeed:
rawToCharNull(some.raw.data)

</code></pre>

<hr>
<h2 id='rawToPTModule'>Convert a vector of raw data into a PTModule object</h2><span id='topic+rawToPTModule'></span><span id='topic+rawToPTModule+2Craw-method'></span>

<h3>Description</h3>

<p>This method treats a vector of <code>raw</code> data as if it where a
file, and converts it into a <code><a href="#topic+PTModule-class">PTModule</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'raw'
rawToPTModule(x, ignore.validity = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToPTModule_+3A_x">x</code></td>
<td>
<p>A vector of <code>raw</code> data, conform ProTracker file specs.</p>
</td></tr>
<tr><td><code id="rawToPTModule_+3A_ignore.validity">ignore.validity</code></td>
<td>
<p>A <code>logical</code> value. When set as <code>TRUE</code>
this method will attempt to decode the raw data (<code>x</code>), even when it is invalid.
When set to <code>FALSE</code> (default) validity is checked and an error is
thrown when invalidity occurs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data is read from a vector of <code>raw</code> data as if it where a file
and converted into a <code><a href="#topic+PTModule-class">PTModule</a></code> object. This
method can be useful for module files stored on virtual Amiga Disk Files
(adf), which can be read as raw data, using the <code>AmigaFFH</code>
package.
</p>
<p>Use <code><a href="#topic+as.raw">as.raw</a></code> to achieve the inverse.
</p>


<h3>Value</h3>

<p>returns a <code><a href="#topic+PTModule-class">PTModule</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## convert the example mod into raw data
data("mod.intro")
mod.raw &lt;- as.raw(mod.intro)

## restore it as a PTModule-class object
mod.restored &lt;- rawToPTModule(mod.raw)

## In this case the result is identical to the original:
identical(mod.restored, mod.intro)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToSignedInt'>Convert a raw vector into signed integers (short)</h2><span id='topic+rawToSignedInt'></span>

<h3>Description</h3>

<p>This function converts a vector of <code>raw</code> data into signed integer values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToSignedInt(raw_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToSignedInt_+3A_raw_dat">raw_dat</code></td>
<td>
<p>A vector of <code>raw</code> data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a vector of <code>raw</code> data into signed integer values
[-128,127]. To convert unsigned integers into raw data use <code>as.raw()</code>.
For the inverse of this function see <code>signedIntToRaw()</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>raw_dat</code>, holding signed integer values.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some raw data:
some.raw.data &lt;- as.raw(c(0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x90))

## convert the raw data into a vector of signed intgers:
rawToSignedInt(some.raw.data)

</code></pre>

<hr>
<h2 id='rawToUnsignedInt'>Convert raw vector into a single unsigned integer value</h2><span id='topic+rawToUnsignedInt'></span>

<h3>Description</h3>

<p>This function converts <code>raw</code> data into an unsigned integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToUnsignedInt(raw_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToUnsignedInt_+3A_raw_dat">raw_dat</code></td>
<td>
<p>A vector of class <code>raw</code> to be converted into an unsigned integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a vector of raw data into a single unsigned integer.
for conversion of raw data into a vector of unsigned integers <code style="white-space: pre;">&#8288;\[0,255\&#8288;</code>] use
<code>as.integer()</code>. For an inverse of this function
see <code>unsignedIntToRaw()</code>.
</p>


<h3>Value</h3>

<p>A single unsigned integer value based on the provided <code>raw</code> data
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some raw data:
some.raw.data &lt;- as.raw(c(0x01, 0x1e, 0x3f))

## convert raw data into an unsigned integer:
rawToUnsignedInt(some.raw.data)

## note the difference with
as.integer(some.raw.data)

</code></pre>

<hr>
<h2 id='read.module'>Read a ProTracker module file</h2><span id='topic+read.module'></span><span id='topic+read.module+2Ccharacter+2Clogical-method'></span><span id='topic+read.module+2CANY+2Cmissing-method'></span><span id='topic+read.module+2Ccharacter+2Cmissing-method'></span><span id='topic+read.module+2CANY+2Clogical-method'></span>

<h3>Description</h3>

<p>Reads a ProTracker module file and coerces it to a <code><a href="#topic+PTModule">PTModule</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character,logical'
read.module(file, ignore.validity = F)

## S4 method for signature 'ANY,missing'
read.module(file, ignore.validity = F)

## S4 method for signature 'ANY,missing'
read.module(file, ignore.validity = F)

## S4 method for signature 'ANY,logical'
read.module(file, ignore.validity = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.module_+3A_file">file</code></td>
<td>
<p>either a filename or a file connection, that
allows reading binary data (see e.g., <code><a href="base.html#topic+connections">base::file</a></code> or <code><a href="base.html#topic+connections">base::url</a></code>).</p>
</td></tr>
<tr><td><code id="read.module_+3A_ignore.validity">ignore.validity</code></td>
<td>
<p>A <code>logical</code> value indicating whether the
validity of the <code>PTModule</code> should be ignored. When set to
<code>FALSE</code> (default), the validity of the read object is checked; an
error is thrown when the object is not valid. When this argument is set to
<code>TRUE</code>, the validity of the object will not be checked and a potentially
invalid object is returned. As the validity check of <code>PTModule</code>
objects is very strict, it can be useful to ignore this check. This way
you can try to read a broken module file, try to fix it such that it becomes valid and
save (with <code><a href="#topic+write.module">write.module</a></code>) it again.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine to read ProTracker modules is based on the referenced version
of ProTracker 2.3A. This means that the routine may not be able to
read files produced with later ProTracker versions, or earlier versions with
back-compatibility issues. So far I've successfully tested this method
on all modules I've composed with ProTracker version 2.3A (which I believe
was one of the more popular versions of ProTracker back in the days).
</p>
<p>It should also be able to read most of the .mod files in
<a href="https://modarchive.org/">The Mod Archive</a>.
</p>


<h3>Value</h3>

<p>Returns a <code>PTModule</code> object read from the provided ProTracker file
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://wiki.multimedia.cx/index.php?title=Protracker_Module">https://wiki.multimedia.cx/index.php?title=Protracker_Module</a>
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## first create an module file from example data:
data("mod.intro")
write.module(mod.intro, "intro.mod")

## read the module:
mod  &lt;-  read.module("intro.mod")

## or create a connection yourself:
con  &lt;- file("intro.mod", "rb")

## note that you can also read from URL connections!
mod2 &lt;- read.module(con)

## don't forget to close the file:
close(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.sample'>Read an audio file and coerce to a PTSample object</h2><span id='topic+read.sample'></span><span id='topic+read.sample+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Reads audio files from &quot;wav&quot; and &quot;mp3&quot; files, using <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code>
methods. Commodore Amiga native formats &quot;8svx&quot; and &quot;raw&quot; can also be read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
read.sample(filename, what = c("wav", "mp3", "8svx", "raw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.sample_+3A_filename">filename</code></td>
<td>
<p>A <code>character</code> string representing the filename to be read.</p>
</td></tr>
<tr><td><code id="read.sample_+3A_what">what</code></td>
<td>
<p>A <code>character</code> string indicating what type of file is to be
read. Can be one of the following: <code>"wav"</code> (default), <code>"mp3"</code>,
<code>"8svx"</code> or <code>"raw"</code>. The <code>AmigaFFH</code> package needs to be
installed in order to read 8svx files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method provides a wrapper for the <code><a href="tuneR.html#topic+readWave">tuneR::readWave</a></code> and
<code><a href="tuneR.html#topic+readMP3">tuneR::readMP3</a></code> methods from <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code>. It also
provides the means to import audio from file formats native to the Commodore
Amiga. Simple <a href="https://en.wikipedia.org/wiki/8SVX">8svx</a> files (also known
as &quot;iff&quot; files) can be read. This uses the <code><a href="AmigaFFH.html#topic+read.iff">AmigaFFH::read.iff</a></code> method
from the <code><a href="AmigaFFH.html#topic+AmigaFFH-package">AmigaFFH::AmigaFFH</a></code> package.
It was also common practice to store audio samples as raw data on the
Commodore Amiga, where each byte simply represented a signed integer value
of the waveform.
</p>
<p>All audio will be coerced to 8 bit mono with a maximum length of
<code>2*0xffff</code> = <code>131070</code> bytes (= samples) as per ProTracker standards.
</p>


<h3>Value</h3>

<p>Returns a <code>PTSample</code> object based on the file read.
</p>


<h3>Note</h3>

<p>As per ProTracker standards, a sample should have an even length
(in bytes). If a sample file has an odd length, a <code>raw</code> <code>0x00</code> value
is added to the end.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("mod.intro")

## create an audio file which we can then read:
write.sample(PTSample(mod.intro, 2), "snaredrum.iff", "8svx")

## read the created sample:
snare &lt;- read.sample("snaredrum.iff", "8svx")
print(snare)

## End(Not run)

</code></pre>

<hr>
<h2 id='resample'>Resample data</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample <code>numeric</code> data to a different rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, source.rate, target.rate, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> that needs to be resampled.</p>
</td></tr>
<tr><td><code id="resample_+3A_source.rate">source.rate</code></td>
<td>
<p>The rate at which <code>x</code> was sampled in Hz (or
another unit, as long as it is in the same unit as <code>target.rate</code>).</p>
</td></tr>
<tr><td><code id="resample_+3A_target.rate">target.rate</code></td>
<td>
<p>The desired target sampling rate in Hz (or
another unit, as long as it is in the same unit as <code>source.rate</code>).</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="stats.html#topic+approxfun">stats::approx</a></code>.
To simulate the Commodore Amiga hardware, it's best to
use '<code>method = "constant"</code> for resampling 8 bit samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function resamples <code>numeric</code> data (i.e., audio data) from a
source sample rate to a target sample rate. At the core it uses
the <code><a href="stats.html#topic+approxfun">stats::approx</a></code> function.
</p>


<h3>Value</h3>

<p>Returns a resampled <code>numeric</code> <code>vector</code> of length
<code>round(length(x) * target.rate / source.rate)</code> based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>some.data &lt;- 1:100

## assume that the current (sample) rate
## of 'some.data' is 100, and we want to
## resample this data to a rate of 200:
resamp.data &lt;- resample(some.data, 100, 200, method = "constant")
</code></pre>

<hr>
<h2 id='sampleLength'>Get the length of a PTSample</h2><span id='topic+sampleLength'></span><span id='topic+sampleLength+2CPTSample-method'></span>

<h3>Description</h3>

<p>Gets the length (in samples = bytes) of an audio fragment stored as a
<code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
sampleLength(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleLength_+3A_sample">sample</code></td>
<td>
<p>A <code>PTSample</code> object for which the length needs to be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PTSample">PTSample</a></code>s are 8 bit mono audio fragments. This method
returns the length of this fragment expressed as number of samples (which
also equals the number of bytes).
</p>


<h3>Value</h3>

<p>Returns a <code>numeric</code> value representing the number of samples
(bytes) the <code>PTSample</code> object <code>sample</code> is composed of.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Show the length of the second sample in mod.intro
sampleLength(PTSample(mod.intro, 2))

</code></pre>

<hr>
<h2 id='sampleNumber'>Extract or replace a sample number</h2><span id='topic+sampleNumber'></span><span id='topic+sampleNumber+2CPTCell-method'></span><span id='topic+sampleNumber+3C-'></span><span id='topic+sampleNumber+3C-+2CPTCell+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extract or replace a <code><a href="#topic+PTSample">PTSample</a></code> index number from a
<code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTCell'
sampleNumber(x)

## S4 replacement method for signature 'PTCell,numeric'
sampleNumber(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleNumber_+3A_x">x</code></td>
<td>
<p>A <code>PTCell</code> object from which the <code><a href="#topic+PTSample">PTSample</a></code> index
number needs to be be extracted or replaced.</p>
</td></tr>
<tr><td><code id="sampleNumber_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> replacement value for the index. Valid indices
range from 1 up to 31. A value of 0 can also be assigned, but will not play
any sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+PTSample">PTSample</a></code> index number in a <code><a href="#topic+PTCell">PTCell</a></code> object,
indicates which sample from a <code><a href="#topic+PTModule">PTModule</a></code> object needs to be played.
This method can be used to extract or replace this index from a
<code><a href="#topic+PTCell">PTCell</a></code> object.
</p>


<h3>Value</h3>

<p>For <code>sampleNumber</code>, a <code>numeric</code> value representing the
sample index number of object <code>x</code> is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;sampleNumber&lt;-&#8288;</code>, an copy of object <code>x</code> is returned in which
the sample index number is replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other cell.operations: 
<code><a href="#topic+PTCell-class">PTCell-class</a></code>,
<code><a href="#topic+PTCell-method">PTCell-method</a></code>,
<code><a href="#topic+effect">effect</a>()</code>,
<code><a href="#topic+note">note</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the sample index number of PTCell at pattern #3,
## track #2, row #1 from mod.intro (which is 2):

sampleNumber(PTCell(mod.intro, 1, 2, 3))

## replace the sample index number of PTCell at pattern #3,
## track #2, row #1 from mod.intro with 1:

sampleNumber(PTCell(mod.intro, 1, 2, 3)) &lt;- 1
</code></pre>

<hr>
<h2 id='sampleRate'>Calculate the sample rate for a note or period value</h2><span id='topic+sampleRate'></span><span id='topic+noteToSampleRate'></span><span id='topic+periodToSampleRate'></span>

<h3>Description</h3>

<p>Calculate the sample rate for a note or a ProTracker period value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noteToSampleRate(note = "C-3", finetune = 0, video = c("PAL", "NTSC"))

periodToSampleRate(period, video = c("PAL", "NTSC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRate_+3A_note">note</code></td>
<td>
<p>A <code>character</code> string representing a note for which the sample
rate is to be calculated.</p>
</td></tr>
<tr><td><code id="sampleRate_+3A_finetune">finetune</code></td>
<td>
<p>An <code>integer</code> value ranging from -8 up to 7. A value used to
tune an audio sample.</p>
</td></tr>
<tr><td><code id="sampleRate_+3A_video">video</code></td>
<td>
<p>The video mode used to calculate the sample rate. A <code>character</code>
string that can have either the value '<a href="https://en.wikipedia.org/wiki/PAL">PAL</a>'
or '<a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a>'. PAL is used by default.</p>
</td></tr>
<tr><td><code id="sampleRate_+3A_period">period</code></td>
<td>
<p>A ProTracker <code>integer</code> value of a period value for which the sample rate
is to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The timing on a Commodore Amiga depends on the video mode, which could be
either '<a href="https://en.wikipedia.org/wiki/PAL">PAL</a>'
or '<a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a>'. Therefore sample
rates also depend on these modes. As the PAL is mostly used in Europe, and
the Amiga was most popular in Europe, PAL is used by default.
</p>


<h3>Value</h3>

<p>Returns the sample rate in samples per seconds.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other character.operations: 
<code><a href="#topic+as.character">as.character</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>
</p>
<p>Other period.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>,
<code><a href="#topic+period_table">period_table</a></code>
</p>
<p>Other sample.rate.operations: 
<code><a href="#topic+playSample">playSample</a>()</code>
</p>
<p>Other note.and.octave.operations: 
<code><a href="#topic+noteToPeriod">noteToPeriod</a>()</code>,
<code><a href="#topic+noteUp">noteUp</a>()</code>,
<code><a href="#topic+note">note</a>()</code>,
<code><a href="#topic+octave">octave</a>()</code>,
<code><a href="#topic+periodToChar">periodToChar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate the sample rate for a ProTracker period value of 200
periodToSampleRate(200)

## calculate the sample rate for a sample at note 'A-3'
noteToSampleRate("A-3")

## note that the NTSC video system gives a slightly different rate:
noteToSampleRate("A-3", video = "NTSC")

## fine tuning a sample will also give a slightly different rate:
noteToSampleRate("A-3", finetune = -1)

</code></pre>

<hr>
<h2 id='signedIntToNybble'>Convert a signed integer to a nybble in raw data.</h2><span id='topic+signedIntToNybble'></span>

<h3>Description</h3>

<p>This function converts a signed integer ranging from -8 up to 7 into
either the high or low nybble of a byte, represented by <code>raw</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signedIntToNybble(int_dat, which = c("low", "high"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signedIntToNybble_+3A_int_dat">int_dat</code></td>
<td>
<p>A single <code>integer</code> value or a <code>vector</code> of
<code>integer</code> data ranging from -8 up to 7.</p>
</td></tr>
<tr><td><code id="signedIntToNybble_+3A_which">which</code></td>
<td>
<p>A character string indicating whether the nybble should
be set to the <code>"low"</code> (default) or <code>"high"</code> position of the
raw data that is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nybbles are 4 bit values, where each byte (8 bits) holds two nybbles.
A high nybble (left-hand side of a byte) and a low nybble (right-hand
side of a byte). This function converts a signed <code>integer</code> value
ranging from -8 up to 7 to a nybble and sets it as either a high or a low
nybble in <code>raw</code> data.
</p>


<h3>Value</h3>

<p>Returns <code>raw</code> data of the same length as <code>int_dat</code>.
The returned raw data holds either low or high nybbles (as specified
by <code>which</code>) based on the provided signed <code>integer</code>s.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other nybble.functions: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>
</p>
<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some integers in the right range:

dati &lt;- sample(-8:7, 100, replace = TRUE)

## Set the low nybbles of rawl based on dati:

rawl &lt;- signedIntToNybble(dati)

## Set the high nybbles of rawl based on dati:

rawh &lt;- signedIntToNybble(dati, "high")
</code></pre>

<hr>
<h2 id='signedIntToRaw'>Convert signed integers (short) into a raw vector</h2><span id='topic+signedIntToRaw'></span>

<h3>Description</h3>

<p>This function converts signed integer values into a vector of <code>raw</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signedIntToRaw(int_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signedIntToRaw_+3A_int_dat">int_dat</code></td>
<td>
<p>A vector of integer values, ranging from -128 up to 127.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts signed integer values [-128,127] into a vector of
<code>raw</code> data. The function
will fail on values that are out of range (&lt; -128 or &gt; 127). To convert
raw data into a vector of unsigned integers use <code>as.integer()</code>.
For the inverse of this function see <code>rawToSignedInt()</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>int_dat</code>, holding <code>raw</code> data.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some signed integers:
some.integers &lt;- c(-100, 40, 0, 30, -123)

## convert the signed integers into a vector of raw data:
signedIntToRaw(some.integers)

</code></pre>

<hr>
<h2 id='trackerFlag'>Tracker flag indicating version compatibility</h2><span id='topic+trackerFlag'></span><span id='topic+trackerFlag+2CPTModule-method'></span><span id='topic+trackerFlag+3C-'></span><span id='topic+trackerFlag+3C-+2CPTModule-method'></span>

<h3>Description</h3>

<p>Method to obtain a tracker flag, which indicates the version compatibility
of a ProTracker module (<code><a href="#topic+PTModule">PTModule</a></code> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule'
trackerFlag(x)

## S4 replacement method for signature 'PTModule'
trackerFlag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackerFlag_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PTModule">PTModule</a></code> object for which the flag needs to
returned or replaced.</p>
</td></tr>
<tr><td><code id="trackerFlag_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string representing the tracker flag with which
that of object <code>x</code> needs to be replaced with. Should either be <code>"M.K."</code>
or <code>"M!K!"</code>. Note that if a current flag <code>"M!K!"</code> is
replaced by <code>"M.K."</code>, <code><a href="#topic+PTPattern">PTPattern</a></code>s may get lost as the
latter supports less patterns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ProTrackR supports two tracker flags: <code>"M.K."</code> and <code style="white-space: pre;">&#8288;"M!K!&#8288;</code>&quot;. M.K.
are presumably the initials of programmers Mahony and Kaktus, unfortunately
documentation on this matter is ambiguous. In any case, modules with the
flag <code>"M.K."</code> can hold up to 64 patterns, whereas modules with the flag
<code>"M!K!"</code> can hold up to 100 patterns. Use this method to obtain or
replace the tracker flag of a <code><a href="#topic+PTModule">PTModule</a></code>.
</p>


<h3>Value</h3>

<p>For <code>trackerFlag</code>, the tracker flag of object <code>x</code> is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;trackerFlag&lt;-&#8288;</code>, a copy of object <code>x</code> with an updated tracker
flag is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## the current trackerFlag of mod.intro is "M.K.",
## meaning that it can hold a maximum of 64 patterns:
trackerFlag(mod.intro)

patternOrder(mod.intro, full = TRUE) &lt;- 0:63

## If we upgrade the trackerFlag of mod.intro to "M!K!"
## it can hold a maximum of 100 patterns!:
trackerFlag(mod.intro) &lt;- "M!K!"

patternOrder(mod.intro, full = TRUE) &lt;- 0:99

## Now let's do something dangerous:
## current flag is "M!K!", by setting it
## back to "M.K.", patterns 65:100 are lost...
trackerFlag(mod.intro) &lt;- "M.K."

</code></pre>

<hr>
<h2 id='unsignedIntToRaw'>Convert unsigned integer into a raw vector</h2><span id='topic+unsignedIntToRaw'></span>

<h3>Description</h3>

<p>This function converts an unsigned integer into a vector of <code>raw</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsignedIntToRaw(int_dat, length.out = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsignedIntToRaw_+3A_int_dat">int_dat</code></td>
<td>
<p>A single integer value. If a list or vector of values.
is provided, only the first element is evaluated. Input data are converted
to absolute integer values.</p>
</td></tr>
<tr><td><code id="unsignedIntToRaw_+3A_length.out">length.out</code></td>
<td>
<p>Required length of the vector that will hold the resulting.
<code>raw</code> data. Defaults to 1. If the value of <code>int_dat</code> is to large to convert into
<code>raw</code> data of length <code>length.out</code>, data will be clipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an unsigned integer value into a vector (with
a specified length, namely <code>length.out</code>) of <code>raw</code> data. For the
inverse of this function use <code>rawToUnsignedInt()</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>length.out</code>, holding <code>raw</code> data.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+as.raw">as.raw</a>()</code>,
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToCharNull">rawToCharNull</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>
</p>
<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some unsigned integer:
some.integer &lt;- 43251

## convert the unsigned integer into raw data:
unsignedIntToRaw(some.integer, length.out = 4)

## Not run: 
## note that the integer is too large to store as raw with length.out = 1:
unsignedIntToRaw(some.raw.data, length.out = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='volume'>Default playback volume of PTSample</h2><span id='topic+volume'></span><span id='topic+volume+2CPTSample-method'></span><span id='topic+volume+3C-'></span><span id='topic+volume+3C-+2CPTSample+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extract or replace the default volume of a <code><a href="#topic+PTSample">PTSample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
volume(sample)

## S4 replacement method for signature 'PTSample,numeric'
volume(sample) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volume_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> for which the default volume
needs to be extracted or replace.</p>
</td></tr>
<tr><td><code id="volume_+3A_value">value</code></td>
<td>
<p>A <code>numeric</code> value ranging from 0 up to 64, representing
the volume level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+PTSample">PTSample</a></code>s have a default playback volume, ranging from
<code>0</code> (silent) up to 64 (maximum volume). This method can be used
to extract this value, or to safely replace it.
</p>


<h3>Value</h3>

<p>For <code>volume</code> the volume value, represented by an
<code>integer</code> value ranging from 0 up to 64, is returned.
</p>
<p>For <code style="white-space: pre;">&#8288;volume&lt;-&#8288;</code> A <code><a href="#topic+PTSample">PTSample</a></code> <code>sample</code>, updated
with the volume <code>value</code>, is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## get the volume of the first sample of mod.intro:

volume(PTSample(mod.intro, 1))

## Let's lower the volume of this sample to 32
## (or as a hexadecimal: 0x20):

volume(PTSample(mod.intro, 1)) &lt;- 0x20

</code></pre>

<hr>
<h2 id='waveform'>Extract or replace a PTSample waveform</h2><span id='topic+waveform'></span><span id='topic+waveform+2CPTSample-method'></span><span id='topic+waveform+3C-'></span><span id='topic+waveform+3C-+2CPTSample-method'></span>

<h3>Description</h3>

<p>Extract or replace the waveform of a <code><a href="#topic+PTSample">PTSample</a></code> object. The
waveform is represented by a <code>vector</code> of numeric values ranging from
0 up to 255.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample'
waveform(sample, start.pos = 1, stop.pos = sampleLength(sample), loop = TRUE)

## S4 replacement method for signature 'PTSample'
waveform(sample) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waveform_+3A_sample">sample</code></td>
<td>
<p>A <code><a href="#topic+PTSample">PTSample</a></code> object from which the waveform needs to
be extracted or replaced.</p>
</td></tr>
<tr><td><code id="waveform_+3A_start.pos">start.pos</code></td>
<td>
<p>A <code>numeric</code> starting index, giving the starting
position for the waveform to be returned. Default value is <code>1</code>. This
index should be greater than zero.</p>
</td></tr>
<tr><td><code id="waveform_+3A_stop.pos">stop.pos</code></td>
<td>
<p>A <code>numeric</code> stopping index, giving the stopping
position for the waveform to be returned. Default value is
<code>sampleLength(sample)</code> This index should be greater than
<code>start.pos</code>.</p>
</td></tr>
<tr><td><code id="waveform_+3A_loop">loop</code></td>
<td>
<p>A <code>logical</code> value indicating whether the waveform
should be modulated between the specified loop positions
(see <code><a href="#topic+loopStart">loopStart</a></code> and <code><a href="#topic+loopLength">loopLength</a></code>),
or the waveform should stop at the end of the sample (padded with <code>NA</code>
values beyond the sample length). Will do the first
when set to <code>TRUE</code> and the latter when set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="waveform_+3A_value">value</code></td>
<td>
<p>A <code>vector</code> of numeric values ranging from 0 up to 255,
representing the waveform that should be used to replace that of object
<code>sample</code>. The length should be even and not exceed <code>2*0xffff</code> =
<code>131070</code>. <code><a href="#topic+loopStart">loopStart</a></code> and <code><a href="#topic+loopLength">loopLength</a></code> will
be adjusted automatically when they are out of range for the new waveform.
</p>
<p>Use <code>NA</code> to generate an empty/blank <code><a href="#topic+PTSample">PTSample</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample waveforms are stored as 8 bit signed short integer values ranging
from -128 up to +127 in original ProTracker files. However, as the
<code><a href="#topic+PTSample">PTSample</a></code> class extends the <code><a href="tuneR.html#topic+Wave">tuneR::Wave</a></code> class,
the waveforms are represented by integer values ranging from 0 up to 255
in the <a href="#topic+ProTrackR-package">ProTrackR</a> package. As per ProTracker specifications,
samples are of 8 bit mono quality and can only have an even length with
a maximum of <code>2*0xffff</code> = <code>131070</code>. This method can be used to
extract a waveform or replace it.
</p>


<h3>Value</h3>

<p>For <code>waveform</code>, the waveform of <code>sample</code> is returned
as a <code>vector</code> of <code>numeric</code> values ranging from 0 up to 255.
If <code>loop</code> is set to <code>FALSE</code>
and the starting position is beyond the sample length, <code>NA</code> values
are returned. If <code>loop</code> is set to <code>TRUE</code> and the starting
position is beyond the sample loop (if present, see
<code><a href="#topic+loopState">loopState</a></code>), the waveform is modulated between the loop
positions.
</p>
<p>For <code style="white-space: pre;">&#8288;waveform&lt;-&#8288;</code>, a copy of object <code>sample</code> is returned in which
the waveform has been replaced with <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other integer.operations: 
<code><a href="#topic+nybbleToSignedInt">nybbleToSignedInt</a>()</code>,
<code><a href="#topic+nybble">nybble</a>()</code>,
<code><a href="#topic+rawToSignedInt">rawToSignedInt</a>()</code>,
<code><a href="#topic+rawToUnsignedInt">rawToUnsignedInt</a>()</code>,
<code><a href="#topic+signedIntToNybble">signedIntToNybble</a>()</code>,
<code><a href="#topic+signedIntToRaw">signedIntToRaw</a>()</code>,
<code><a href="#topic+unsignedIntToRaw">unsignedIntToRaw</a>()</code>
</p>
<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mod.intro")

## Loop sample #1 of mod.intro beyond it's
## length of 1040 samples:
wav1 &lt;- waveform(PTSample(mod.intro, 1),
                 1, 5000)

## get the waveform from sample #2
## of mod.intro:
wav2 &lt;- waveform(PTSample(mod.intro, 2))

## create an echo effect using
## the extracted waveform:
wav2 &lt;- c(wav2, rep(128, 1000)) +
        c(rep(128, 1000), wav2)*0.25 - 25

## assign this echoed sample to
## sample #2 in mod.intro:
waveform(PTSample(mod.intro, 2)) &lt;- wav2

## Blank out sample #1 in mod.intro:
waveform(PTSample(mod.intro, 1)) &lt;- NA

</code></pre>

<hr>
<h2 id='write.module'>Export an PTModule object as a ProTracker module file</h2><span id='topic+write.module'></span><span id='topic+write.module+2CPTModule+2CANY-method'></span><span id='topic+write.module+2CPTModule+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Export an <code><a href="#topic+PTModule">PTModule</a></code> object as a ProTracker module file,
conform ProTracker 2.3A specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTModule,ANY'
write.module(mod, file)

## S4 method for signature 'PTModule,character'
write.module(mod, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.module_+3A_mod">mod</code></td>
<td>
<p>A valid PTModule object to be saved as a ProTracker *.mod file</p>
</td></tr>
<tr><td><code id="write.module_+3A_file">file</code></td>
<td>
<p>either a filename to write to, or a file connection, that
allows to write binary data (see <code><a href="base.html#topic+connections">base::file</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine to write ProTracker modules is based on the referenced version
of ProTracker 2.3A. This means that the routine may not be able to
write files that ar compatible with later or earlier ProTracker versions.
</p>


<h3>Value</h3>

<p>Writes to a module file but returns nothing.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://wiki.multimedia.cx/index.php?title=Protracker_Module">https://wiki.multimedia.cx/index.php?title=Protracker_Module</a>
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+write.sample">write.sample</a>()</code>
</p>
<p>Other module.operations: 
<code><a href="#topic+PTModule-class">PTModule-class</a></code>,
<code><a href="#topic+appendPattern">appendPattern</a>()</code>,
<code><a href="#topic+clearSamples">clearSamples</a>()</code>,
<code><a href="#topic+clearSong">clearSong</a>()</code>,
<code><a href="#topic+deletePattern">deletePattern</a>()</code>,
<code><a href="#topic+fix.PTModule">fix.PTModule</a>()</code>,
<code><a href="#topic+modToWave">modToWave</a>()</code>,
<code><a href="#topic+moduleSize">moduleSize</a>()</code>,
<code><a href="#topic+patternLength">patternLength</a>()</code>,
<code><a href="#topic+patternOrderLength">patternOrderLength</a>()</code>,
<code><a href="#topic+patternOrder">patternOrder</a>()</code>,
<code><a href="#topic+playMod">playMod</a>()</code>,
<code><a href="#topic+playingtable">playingtable</a>()</code>,
<code><a href="#topic+rawToPTModule">rawToPTModule</a>()</code>,
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+trackerFlag">trackerFlag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## get the PTModule object provided with the ProTrackR package
data("mod.intro")

## save the object as a valid ProTracker module file:
write.module(mod.intro, "intro.mod")

## or create the connection yourself:
con &lt;- file("intro2.mod", "wb")
write.module(mod.intro, con)

## don't forget to close the connection after you're done:
close(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.sample'>Write a PTSample object to an audio file</h2><span id='topic+write.sample'></span><span id='topic+write.sample+2CPTSample+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Write a <code>PTSample</code> as a &quot;wav&quot;, &quot;8svx&quot; or &quot;raw&quot; audio file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PTSample,character'
write.sample(sample, filename, what = c("wav", "8svx", "raw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.sample_+3A_sample">sample</code></td>
<td>
<p>A <code>PTSample</code> object that needs to be exported to an audio
file.</p>
</td></tr>
<tr><td><code id="write.sample_+3A_filename">filename</code></td>
<td>
<p>A <code>character</code> string representing the filename to which
the audio needs to be saved.</p>
</td></tr>
<tr><td><code id="write.sample_+3A_what">what</code></td>
<td>
<p>A <code>character</code> string indicating what type of file is to be
exported. Can be one of the following: <code>"wav"</code> (default),
<code>"8svx"</code> or <code>"raw"</code>. The <code>AmigaFFH</code> package needs to be
installed in order to write 8svx files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method provides a wrapper for the <code><a href="tuneR.html#topic+writeWave">tuneR::writeWave</a></code> method
from <code><a href="tuneR.html#topic+tuneR">tuneR::tuneR</a></code>. It also provides the means to export audio
to file formats native to the Commodore Amiga. <code>PTSample</code>s can be
exported as simple (uncompressed) <a href="https://en.wikipedia.org/wiki/8SVX">8svx</a>
files also known as &quot;iff&quot; files). In addition they can be exported as raw data,
where each byte simply represents a signed integer value of the waveform.
</p>


<h3>Value</h3>

<p>Saves the audio to a file, but returns nothing.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code><a href="#topic+PTSample-class">PTSample-class</a></code>,
<code><a href="#topic+PTSample-method">PTSample-method</a></code>,
<code><a href="#topic+fineTune">fineTune</a>()</code>,
<code><a href="#topic+loopLength">loopLength</a>()</code>,
<code><a href="#topic+loopSample">loopSample</a>()</code>,
<code><a href="#topic+loopStart">loopStart</a>()</code>,
<code><a href="#topic+loopState">loopState</a>()</code>,
<code><a href="#topic+name">name</a></code>,
<code><a href="#topic+playSample">playSample</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+sampleLength">sampleLength</a>()</code>,
<code><a href="#topic+volume">volume</a>()</code>,
<code><a href="#topic+waveform">waveform</a>()</code>
</p>
<p>Other io.operations: 
<code><a href="#topic+read.module">read.module</a>()</code>,
<code><a href="#topic+read.sample">read.sample</a>()</code>,
<code><a href="#topic+write.module">write.module</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("mod.intro")

## Export the second sample of mod.intro as a wav file:
write.sample(PTSample(mod.intro, 2), "snaredrum.wav", "wav")

## Export the second sample of mod.intro as an 8svx file:
write.sample(PTSample(mod.intro, 2), "snaredrum.iff", "8svx")

## Export the second sample of mod.intro as a raw file:
write.sample(PTSample(mod.intro, 2), "snaredrum.raw", "raw")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
