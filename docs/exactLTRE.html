<!DOCTYPE html><html><head><title>Help for package exactLTRE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exactLTRE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_matrix_effects'><p>Effects of matrix parameters</p></a></li>
<li><a href='#calc_matrix_responses'><p>Responses to changing entries of a matrix</p></a></li>
<li><a href='#classicalLTRE'><p>Classical LTRE analysis</p></a></li>
<li><a href='#classicalLTRE_fixed'><p>Classical LTRE analysis: one-way fixed design</p></a></li>
<li><a href='#classicalLTRE_random'><p>Classical LTRE analysis: random design</p></a></li>
<li><a href='#collapse_mat_list'><p>Collapse a list of matrices</p></a></li>
<li><a href='#cov_matrix'><p>The variance-covariance matrix for a set of population projection matrices</p></a></li>
<li><a href='#exactLTRE'><p>Exact LTRE analysis</p></a></li>
<li><a href='#exactLTRE_fixed'><p>Exact LTRE analysis: fixed design</p></a></li>
<li><a href='#exactLTRE_random'><p>Exact LTRE analysis: random design</p></a></li>
<li><a href='#fundamental_matrix'><p>Fundamental matrix</p></a></li>
<li><a href='#generation_time'><p>Generation time</p></a></li>
<li><a href='#lamDiff'><p>Difference in lambda</p></a></li>
<li><a href='#lamDiff_symmetric'><p>Difference in lambda, with the mean as baseline</p></a></li>
<li><a href='#lamVar'><p>Variance in lambda</p></a></li>
<li><a href='#lifespan'><p>Expected lifespan</p></a></li>
<li><a href='#make.Gmatrix'><p>G-matrix</p></a></li>
<li><a href='#mean_matrix'><p>Calculate the mean matrix</p></a></li>
<li><a href='#r_nought'><p>R0, the net reproductive output</p></a></li>
<li><a href='#reMat'><p>Reconstruct a matrix that was collapsed into a row vector</p></a></li>
<li><a href='#run_matrix_checks'><p>Automated checks for a set of matrices</p></a></li>
<li><a href='#variance_complete'><p>A function for variance assuming a complete sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An Exact Method for Life Table Response Experiment (LTRE)
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Life Table Response Experiments (LTREs) are a method of comparative demographic analysis. The purpose is to quantify how the difference or variance in vital rates (stage-specific survival, growth, and fertility) among populations contributes to difference or variance in the population growth rate, "lambda." We provide functions for one-way fixed design and random design LTRE, using either the classical methods that have been in use for several decades, or an fANOVA-based exact method that directly calculates the impact on lambda of changes in matrix elements, for matrix elements and their interactions. The equations and descriptions for the classical methods of LTRE analysis can be found in "Matrix Population Models: Construction, Analysis, and Interpretation (2nd edition)" Caswell (2001, ISBN: 0878930965), and the fANOVA-based exact methods will be published in a forthcoming paper. We also provide some demographic functions, including generation time from Bienvenu and Legendre (2015) &lt;<a href="https://doi.org/10.1086%2F681104">doi:10.1086/681104</a>&gt;. For implementation of exactLTRE where all possible interactions are calculated, we use an operator matrix presented in Poelwijk, Krishna, and Ranganathan (2016) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1004771">doi:10.1371/journal.pcbi.1004771</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixcalc, popdemo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 14:14:39 UTC; cmh352</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Hernandez
    <a href="https://orcid.org/0000-0002-7188-8217"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Hernandez &lt;cmh352@cornell.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-17 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_matrix_effects'>Effects of matrix parameters</h2><span id='topic+calc_matrix_effects'></span>

<h3>Description</h3>

<p>Calculate the effects of differences or variance in vital rate entries in a
set of matrix population models, for a given set of interaction terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_matrix_effects(responses, list_ind_vary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_matrix_effects_+3A_responses">responses</code></td>
<td>
<p>A vector of the responses due to the parameters of a matrix
population model and their interactions.</p>
</td></tr>
<tr><td><code id="calc_matrix_effects_+3A_list_ind_vary">list_ind_vary</code></td>
<td>
<p>A list object, where each entry is a vector
containing the indices (the combinations of the elements of <code>ind_vary</code>, an
input parameter) that varied (were <em>not</em> held fixed) for the corresponding
entry in the <code>responses</code> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of effects, which are the responses due to a given interaction
order, controlling for the lower-level interaction terms. These are the epsilon
terms in an fANOVA decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A_all&lt;- collapse_mat_list(list(A1, A2, A3))
nu_var&lt;- calc_matrix_responses(A_all, c(2,6,7,9), FUN=lamVar, maxint="all")
nu_diff&lt;- calc_matrix_responses(list(A1,A2), c(2,6,7,9), FUN=lamDiff_symmetric, maxint="all")
epsilon_var&lt;- calc_matrix_effects(nu_var$nus, nu_var$list_ind_vary)
epsilon_diff&lt;- calc_matrix_effects(nu_diff$nus, nu_diff$list_ind_vary)
</code></pre>

<hr>
<h2 id='calc_matrix_responses'>Responses to changing entries of a matrix</h2><span id='topic+calc_matrix_responses'></span>

<h3>Description</h3>

<p>Calculate the responses of varying certain entries of a matrix. This function
takes a set of matrix population models, the indices of parameters that vary
in those matrices, and a response function. For example, difference or variance
in lambda (the leading eigenvalue of a population projection matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_matrix_responses(Aobj, ind_vary, FUN, maxint = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_matrix_responses_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix.</p>
</td></tr>
<tr><td><code id="calc_matrix_responses_+3A_ind_vary">ind_vary</code></td>
<td>
<p>A vector containing the column-wise (single-value) indices of
the population projection matrices that vary.</p>
</td></tr>
<tr><td><code id="calc_matrix_responses_+3A_fun">FUN</code></td>
<td>
<p>The name of the function to be used for calculating responses. For
example, <code><a href="#topic+lamVar">lamVar</a></code>, <code><a href="#topic+lamDiff">lamDiff</a></code>, and <code><a href="#topic+lamDiff_symmetric">lamDiff_symmetric</a></code></p>
</td></tr>
<tr><td><code id="calc_matrix_responses_+3A_maxint">maxint</code></td>
<td>
<p>The maximum interaction order to be evaluated. The default input
is &quot;all&quot; but this input can take any integer value. If maxint=3, then the
output will include contributions terms up to 3-way interactions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a list object, with 2 items: (1) a
list of the indices varying for each of the responses terms; and (2)
a vector of responses.
</p>
<p><code>list_ind_vary</code> is a list object, where each entry is a vector
containing the indices (the combinations of the elements of <code>ind_vary</code>, an
input parameter) that varied (were <em>not</em> held fixed) for the corresponding
entry in the <code>nu</code> vector.
</p>
<p><code>nus</code> is a vector of responses, calculated using the function provided
in <code>FUN</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lamVar">lamVar</a></code>, <code><a href="#topic+lamDiff">lamDiff</a></code>, and <code><a href="#topic+lamDiff_symmetric">lamDiff_symmetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A_all&lt;- collapse_mat_list(list(A1, A2, A3))
nu_var&lt;- calc_matrix_responses(A_all, c(2,6,7,9), FUN=lamVar, maxint="all")
nu_diff&lt;- calc_matrix_responses(list(A1,A2), c(2,6,7,9), FUN=lamDiff_symmetric, maxint="all")
</code></pre>

<hr>
<h2 id='classicalLTRE'>Classical LTRE analysis</h2><span id='topic+classicalLTRE'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations
contributes to difference or variance in the population growth rate, &quot;lambda.&quot;
The equations and descriptions for the classical methods of LTRE analysis
can be found in Caswell's 2001 textbook. The function we provide here can
perform a one-way fixed design LTRE, or a random design LTRE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classicalLTRE(Aobj, method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classicalLTRE_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix.
</p>
<p>For one-way fixed design, exactly 2 matrices must be provided, ordered as
<code style="white-space: pre;">&#8288;[reference matrix, treatment matrix&#8288;</code>]. For random design, any set of 2 or
more matrices can be provided. The set of matrices passed in to this
function must all have the same dimensions.</p>
</td></tr>
<tr><td><code id="classicalLTRE_+3A_method">method</code></td>
<td>
<p>Either &quot;random&quot; or &quot;fixed.&quot; The default behavior is &quot;random.&quot;
See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix. A one-way fixed
design LTRE decomposes the difference in lambda due to differences at each
position of the matrices. It should be used when the particular treatment
levels are of interest. For a one-way fixed design LTRE, exactly 2 matrices
must be provided, ordered as <code style="white-space: pre;">&#8288;[reference matrix, treatment matrix&#8288;</code>]. The
matrix of contributions returned from a classical method fixed design LTRE
will have the same shape as the provided matrices.
</p>
<p>A random design LTRE decomposes the variance in lambda due to variance and
covariance in the entries at each position in the matrices. It assumes that
the matrices being analyzed come from a population of similar matrices,
without the particular treatment levels or population conditions being of
interest in themselves. For a random design LTRE, at least 2 matrices must be
provided. The matrix of contributions returned from a classical method
random design LTRE will include both first-order terms (due to variance) and
interaction terms (due to covariance). Therefore, if the provided matrix is
3x3, the matrix of contributions will be 9x9 (the size of the
variance-covariance matrix is the square of the size of the original
matrix). The contributions of variances are found on the diagonal of the
contribution matrix, and the contributions of covariances are symmetric. So
the contribution of covariance between two vital rate parameters is the sum
of the two corresponding off-diagonal terms.
</p>
<p>The equations and descriptions for the classical methods of LTRE analysis
can be found in Caswell's 2001 textbook.
</p>


<h3>Value</h3>

<p>A matrix of contributions to variance (random design) or difference
(one-way fixed design) in lambda. Lambda is the asymptotic population growth
rate, defined as the largest eigenvalue of the population projection matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
cont_diff&lt;- classicalLTRE(list(A1,A2), method='fixed') # contributions to the difference in lambda
cont_var&lt;- classicalLTRE(list(A1,A2,A3), method='random') # contributions to the variance of lambda
</code></pre>

<hr>
<h2 id='classicalLTRE_fixed'>Classical LTRE analysis: one-way fixed design</h2><span id='topic+classicalLTRE_fixed'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations '
contributes to the difference or variance in the population growth rate,
&quot;lambda.&quot; ' The equations and descriptions for the classical methods of LTRE
analysis ' can be found in Caswell's 2001 textbook.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classicalLTRE_fixed(Aref, Atreatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classicalLTRE_fixed_+3A_aref">Aref</code></td>
<td>
<p>The population projection matrix of the reference population.
Depending on the experimental or observational dataset, this may be the
control treatment, the first time period, the unharvested population, etc.</p>
</td></tr>
<tr><td><code id="classicalLTRE_fixed_+3A_atreatment">Atreatment</code></td>
<td>
<p>The population projection matrix of a treatment population.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix. A fixed design LTRE
decomposes the difference in lambda due to differences at each position of
the matrices. For a fixed design LTRE, exactly 2 matrices must be provided,
ordered as <code style="white-space: pre;">&#8288;[reference matrix, treatment matrix&#8288;</code>]. The matrix of contributions
returned from a classical method fixed design LTRE will have the same shape
as the provided matrices.
</p>
<p>In some cases, it may not be obvious how to identify the reference and the
treatment matrix. The sum of contributions will be approximately equal to the
observed difference in lambda between these two matrices, evaluated as
lambda(Atreatment) - lambda(Aref). In cases where it doesn't 'matter' which way
you, as a user, input these matrices, it is important to understand how to
interpret positive and negative contributions.
</p>
<p>The equations and descriptions for the classical methods of LTRE analysis
can be found in Caswell's 2001 textbook.
</p>


<h3>Value</h3>

<p>A matrix of contributions to the difference in lambda. Lambda is the
asymptotic population growth rate, defined as the largest eigenvalue of the
population projection matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
cont_diff&lt;- classicalLTRE_fixed(A1, A2) # contributions to the difference in lambda
</code></pre>

<hr>
<h2 id='classicalLTRE_random'>Classical LTRE analysis: random design</h2><span id='topic+classicalLTRE_random'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations
contributes to the difference or variance in the population growth rate, &quot;lambda.&quot;
The equations and descriptions for the classical methods of LTRE analysis
can be found in Caswell's 2001 textbook.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classicalLTRE_random(Aobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classicalLTRE_random_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix. Any set of 2 or more
matrices can be provided. The set of matrices passed in must all have the
same dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix.
</p>
<p>A random design LTRE decomposes the variance in lambda due to variance and
covariance in the entries at each position in the matrices. For a random
design LTRE, at least 2 matrices must be provided. The matrix of
contributions returned from a classical method random design LTRE will
include both first-order terms (due to variance) and interaction terms (due
to covariance). Therefore, if the provided matrix is 3x3, the matrix of
contributions will be 9x9 (the size of the variance-covariance matrix is the
square of the size of the original matrix). The contributions of variances
are found on the diagonal of the contribution matrix, and the contributions
of covariances are symmetric. So the contribution of covariance between two
vital rate parameters is the sum of the two corresponding off-diagonal terms.
</p>
<p>The equations and descriptions for the classical methods of LTRE analysis
can be found in Caswell's 2001 textbook.
</p>


<h3>Value</h3>

<p>A matrix of contributions to variance in lambda.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
# contributions to the variance of lambda
cont_var&lt;- classicalLTRE(list(A1,A2,A3), method='random')
</code></pre>

<hr>
<h2 id='collapse_mat_list'>Collapse a list of matrices</h2><span id='topic+collapse_mat_list'></span>

<h3>Description</h3>

<p>Collapse a list of square matrices into a matrix where each row contains the
column-wise vectorization of one of the original matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_mat_list(Alist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_mat_list_+3A_alist">Alist</code></td>
<td>
<p>A list of matrices, of any length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each row contains the column-wise vectorization of one
of the original matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A_all&lt;- collapse_mat_list(list(A1, A2, A3))
</code></pre>

<hr>
<h2 id='cov_matrix'>The variance-covariance matrix for a set of population projection matrices</h2><span id='topic+cov_matrix'></span>

<h3>Description</h3>

<p>Calculate the variance-covariance matrix for the vital rates of a series of
population projection matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_matrix(Aobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_matrix_+3A_aobj">Aobj</code></td>
<td>
<p>A matrix where each row is the column-wise vectorization of a
population projection matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagonal entries of the variance-covariance matrix give the
variance of the entries in each index of the matrix. The off-diagonal entries
of the variance-covariance matrix give the covariance of entries in each index
of the matrix. The variance-covariance matrix is symmetrical, and the
covariance of a given pair of vital rates is the sum of the two corresponding
indices.
</p>


<h3>Value</h3>

<p>The variance-covariance matrix for the vital rates of the population
projection matrices. If the dimensions of each matrix in <code>Aobj</code> are n-by-n,
then the variance-covariance matrix will have dimensions n^2-by-n^2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A_all&lt;- collapse_mat_list(list(A1, A2, A3))
covmat&lt;- cov_matrix(A_all)
</code></pre>

<hr>
<h2 id='exactLTRE'>Exact LTRE analysis</h2><span id='topic+exactLTRE'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations
contributes to difference or variance in the population growth rate, &quot;lambda.&quot;
The exact method of LTRE is based on the principles of functional ANOVA.
The equations and descriptions for the exact method will be published in a
forthcoming paper, which we will link to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactLTRE(Aobj, method = "random", maxint = "all", fixed.directional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactLTRE_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix.
</p>
<p>For one-way fixed design, exactly 2 matrices must be provided. For a
&quot;directional&quot; analyses, one of the provided matrices will serve as the
baseline state (for example, a control or standard-of-reference). In this
case, the matrices need to be ordered as <code style="white-space: pre;">&#8288;[baseline matrix, observed matrix&#8288;</code>].
For random design, any set of 2 or more matrices can be provided.
The set of matrices passed in must all have the same dimensions.</p>
</td></tr>
<tr><td><code id="exactLTRE_+3A_method">method</code></td>
<td>
<p>Either &quot;random&quot; or &quot;fixed.&quot; The default behavior is &quot;random.&quot;
See details for more information.</p>
</td></tr>
<tr><td><code id="exactLTRE_+3A_maxint">maxint</code></td>
<td>
<p>The maximum interaction order to be evaluated. The default input
is &quot;all&quot; but this input can take any integer value. If maxint=3, then the
output will include contributions terms up to 3-way interactions.</p>
</td></tr>
<tr><td><code id="exactLTRE_+3A_fixed.directional">fixed.directional</code></td>
<td>
<p>A true/false switch that allows the user to specify
whether a directional LTRE should be used. The default behavior is to calculate
a symmetric LTRE, where the mean matrix is used as the baseline matrix. See
details for more guidance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix.
</p>
<p>In a one-way fixed design LTRE, the particular treatment levels or
conditions faced by a population are of interest, so one-way fixed design
LTRE decomposes the difference in lambda due to differences at each position
of the matrices. For a fixed design LTRE, exactly 2 matrices must be
provided.
</p>
<p>A random design LTRE treats the different matrices being compared as random
samples from a set of population conditions, without specific focus on the
treatments or conditions that each population experienced. This analysis
decomposes the variance in lambda due to variance and covariance in the
entries at each position in the matrices. For a random design LTRE, at least
2 matrices must be provided.
</p>
<p><code>fixed.directional=FALSE</code> is most appropriate for comparisons where
none of the matrices are appropriate for use as a baseline or
standard-of-reference. For example, if we want to ask which vital rates
drive the difference in population growth rate for two populations of fish
in separate but similar lakes, we want to use a <em>symmetric</em> analysis. In
this case, the difference in lambda is decomposed using the mean matrix as
the baseline. The decomposition is symmetric, meaning that if the treatment
and reference matrix are swapped, the contributions from the vital rates
will be equal in magnitude, but positive contributions will become negative
and vice versa. In this case, it does not matter which order you provide the
matrices in <code>Aobj</code>, but interpretation will require that you pay
attention to the fact that the sum of contributions will be equal to the
observed difference in lambda between the two matrices in <code>Aobj</code>,
evaluated as lambda(A1) - lambda(A2).
</p>
<p><code>fixed.directional=TRUE</code> is most appropriate for comparisons between a
control and treatment population in a controlled experiment, or for other
cases where one of the populations can serve as a standard of reference (for
example, the lowest elevation population, or one near the range center). In
this case, the first matrix in <code>Aobj</code> is used as the baseline. This is
a directional analysis, meaning that if the order in which the two matrices
are provided were to be swapped (switching the baseline matrix and other
observed matrix), the contributions of the vital rates would change. If you
choose a directional analysis, be sure to provide the matrices in
<code>Aobj</code> ordered as <code style="white-space: pre;">&#8288;[baseline matrix, observed matrix&#8288;</code>].
</p>
<p>We set <code>fixed.directional=FALSE</code> as the default behavior because most
population projection models are built with field-collected data rather than
controlled experiment data.
</p>


<h3>Value</h3>

<p>This returns a list object, with 3 items: (1) a vector of the matrix
indices where the parameters vary between/among the matrices in Aobj; (2) a
list of the indices varying for each of the contribution terms provided; (3)
a vector of the contribution terms.If the method is &quot;fixed&quot; then these are
contributions to the difference in lambda. If the method is &quot;random&quot; then
these are the contributions to the variance in lambda.
</p>
<p><code>indices.varying</code> is a vector with the indices of parameters that vary. The
numeric indices count down the columns of a given population projection
matrix. For example, in a 3x3 matrix, the (2,2) position would be identified
with a 5.
</p>
<p><code>varying.indices.list</code> is a list object, where each entry is a vector
containing the indices (matching the <code>indices.varying</code> part of the output)
that differed or varied for the corresponding entry in the <code>epsilon</code> vector.
</p>
<p><code>epsilon</code> is a vector of contributions to the variance or difference in
lambda due to the observed values of the various life history parameters.
For example, the contribution of adult survival to the Var(lambda) is
determined by setting all parameters <em>except</em> adult survival to their mean
values, and then calculating the variance of lambda across this manipulated
set of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
cont_diff&lt;- exactLTRE(list(A1,A2), method='fixed') # contributions to the difference in lambda
cont_var&lt;- exactLTRE(list(A1,A2,A3), method='random') # contributions to the variance of lambda
</code></pre>

<hr>
<h2 id='exactLTRE_fixed'>Exact LTRE analysis: fixed design</h2><span id='topic+exactLTRE_fixed'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations
contributes to difference or variance in the population growth rate, &quot;lambda.&quot;
The exact method of LTRE is based on the principles of functional ANOVA.
The equations and descriptions for the exact method will be published in a
forthcoming paper, which we will link to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactLTRE_fixed(Aobj, maxint = "all", fixed.directional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactLTRE_fixed_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix. For fixed design, exactly
2 matrices must be provided, ordered as <code style="white-space: pre;">&#8288;[reference matrix, treatment matrix&#8288;</code>].</p>
</td></tr>
<tr><td><code id="exactLTRE_fixed_+3A_maxint">maxint</code></td>
<td>
<p>The maximum interaction order to be evaluated. The default input
is &quot;all&quot; but this input can take any integer value. If maxint=3, then the
output will include contributions terms up to 3-way interactions.</p>
</td></tr>
<tr><td><code id="exactLTRE_fixed_+3A_fixed.directional">fixed.directional</code></td>
<td>
<p>A true/false switch that allows the user to specify
whether a directional LTRE should be used. The default behavior is to calculate
a symmetric LTRE, where the mean matrix is used as the baseline. See details
for more guidance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix. A fixed design LTRE
decomposes the difference in lambda due to differences at each position of
the matrices. For a fixed design LTRE, exactly 2 matrices must be provided,
ordered as <code style="white-space: pre;">&#8288;[reference matrix, treatment matrix&#8288;</code>].
</p>
<p><code>fixed.directional=FALSE</code> is most appropriate for comparisons where it is
not entirely obvious which population should be the reference and which
should be the treatment (for example, when comparing a wet and a dry year). In
this case, the difference in lambda is decomposed using the mean matrix as
the baseline. The decomposition is symmetric, meaning that if the treatment and
reference matrix are swapped, the contributions from the vital rates will be
equal in magnitude, but positive contributions will become negative and vice
versa.
</p>
<p><code>fixed.directional=TRUE</code> is most appropriate for comparisons between a
control and treatment population in a controlled experiment. In this case,
the reference matrix is treated as the baseline. This is a directional analysis,
meaning that if the reference and treatment matrices were to be swapped, the
contributions of the vital rates would change.
</p>
<p>We set <code>fixed.directional=FALSE</code> as the default behavior because most
population projection models are built with field-collected data rather than
controlled experiment data.
</p>


<h3>Value</h3>

<p>This returns a list object, with 3 items: (1) a vector of the matrix
indices where the parameters vary between/among the matrices in Aobj; (2) a
list of the indices varying for each of the contribution terms provided; (3)
a vector of the contribution terms. For fixed design LTRE these are
contributions to the difference in lambda.
</p>
<p><code>indices.varying</code> is a vector with the indices of parameters that vary. The
numeric indices count down the columns of a given population projection
matrix. For example, in a 3x3 matrix, the (2,2) position would be identified
with a 5.
</p>
<p><code>varying.indices.list</code> is a list object, where each entry is a vector
containing the indices (matching the <code>indices.varying</code> part of the output)
that differed or varied for the corresponding entry in the <code>epsilon</code> vector.
</p>
<p><code>epsilon</code> is a vector of contributions to the difference in lambda due to
the observed values of the various life history parameters. For example, the
contribution to the difference in lambda of adult survival is determined by
setting all parameters <em>except</em> adult survival to their mean values, and
then calculating the difference in lambda in this manipulated set of
matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
cont_diff&lt;- exactLTRE_fixed(list(A1,A2), maxint="all") # contributions to the difference in lambda
cont_diff&lt;- exactLTRE_fixed(list(A1,A2), maxint=2) # only first- and second-order terms

# if A1 represents a control and A2 is a treatment:
cont_diff&lt;- exactLTRE_fixed(list(A1,A2), maxint="all", fixed.directional=TRUE)
</code></pre>

<hr>
<h2 id='exactLTRE_random'>Exact LTRE analysis: random design</h2><span id='topic+exactLTRE_random'></span>

<h3>Description</h3>

<p>Life Table Response Experiments (LTREs) are a method of comparative demographic
analysis. The purpose is to quantify how the difference or variance in vital
rates (stage-specific survival, growth, and fertility) among populations
contributes to difference or variance in the population growth rate, &quot;lambda.&quot;
The exact method of LTRE is based on the principles of functional ANOVA.
The equations and descriptions for the exact method will be published in a
forthcoming paper, which we will link to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactLTRE_random(Aobj, maxint = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactLTRE_random_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix. For random design, any
set of 2 or more matrices can be provided. The set of matrices passed in must
all have the same dimensions.</p>
</td></tr>
<tr><td><code id="exactLTRE_random_+3A_maxint">maxint</code></td>
<td>
<p>The maximum interaction order to be evaluated. The default input
is &quot;all&quot; but this input can take any integer value. If maxint=3, then the
output will include contributions terms up to 3-way interactions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambda is the asymptotic population growth rate, defined as the
largest eigenvalue of the population projection matrix. A random design LTRE
decomposes the variance in lambda due to variance and covariance in the
entries at each position in the matrices. For a random design LTRE, at least
2 matrices must be provided.
</p>


<h3>Value</h3>

<p>This returns a list object, with 3 items: (1) a vector of the matrix
indices where the parameters vary between/among the matrices in Aobj; (2) a
list of the indices varying for each of the contribution terms provided; (3)
a vector of the contribution terms.If the method is &quot;fixed&quot; then these are
contributions to the difference in lambda. If the method is &quot;random&quot; then
these are the contributions to the variance in lambda.
</p>
<p><code>indices.varying</code> is a vector with the indices of parameters that vary. The
numeric indices count down the columns of a given population projection
matrix. For example, in a 3x3 matrix, the (2,2) position would be identified
with a 5.
</p>
<p><code>varying.indices.list</code> is a list object, where each entry is a vector
containing the indices (matching the <code>indices.varying</code> part of the output)
that varied for the corresponding entry in the <code>epsilon</code> vector.
</p>
<p><code>epsilon</code> is a vector of contributions to the variance in lambda due to the
observed values of the various life history parameters. For example, the
contribution to the variance in lambda of adult survival is determined by
setting all parameters <em>except</em> adult survival to their mean values, and
then calculating the variance in lambda in this manipulated set of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
cont_var&lt;- exactLTRE_random(list(A1,A2,A3), maxint='all') # contributions to the variance of lambda
</code></pre>

<hr>
<h2 id='fundamental_matrix'>Fundamental matrix</h2><span id='topic+fundamental_matrix'></span>

<h3>Description</h3>

<p>Calculate the fundamental matrix. The fundamental matrix, generally referred
to as <strong>N</strong>, contains the expected number of timesteps that an individual
will spend in each age, stage, or size class of the matrix throughout their
lifespan, given their current class. In the fundamental matrix, the current
state is the column, and the future states are in the rows. For an
age-classified matrix, this should be lower triangular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fundamental_matrix(Umat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fundamental_matrix_+3A_umat">Umat</code></td>
<td>
<p>The survival components of the population projection matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fundamental matrix, containing the expected number of timesteps
that an individual will spend in each class of the population, given their
current state. This matrix will have the same size as the input matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
U1&lt;- A1
U1[1,3]&lt;- 0
# the upper right corner represents adult fertility in this model. U1, the
# survival matrix, contains all the transitions *except* for fertility.
N1&lt;- fundamental_matrix(U1)
</code></pre>

<hr>
<h2 id='generation_time'>Generation time</h2><span id='topic+generation_time'></span>

<h3>Description</h3>

<p>Generation time has been defined in multiple ways. This calculation comes
from Bienvenu and Legendre (2015, The American Naturalist;
<a href="https://doi.org/10.1086/681104">doi:10.1086/681104</a>). They define the generation time as
the average time between two events in the genealogy of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generation_time(Amat, Fmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generation_time_+3A_amat">Amat</code></td>
<td>
<p>The full population projection matrix</p>
</td></tr>
<tr><td><code id="generation_time_+3A_fmat">Fmat</code></td>
<td>
<p>The fertility elements of the population projection matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generation time, as a single number, given in the same units as
the projection time step. If the projection interval is two weeks, the
generation time will be the number of two-week intervals. You may wish to
convert to a standard time step, like days or years.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
F1&lt;- matrix(0, nrow=3, ncol=3)
F1[1,3]&lt;- A1[1,3]
#F1 is all zeros, except the upper right corner which matches A1 for adult fertility
T&lt;- generation_time(A1, F1)
</code></pre>

<hr>
<h2 id='lamDiff'>Difference in lambda</h2><span id='topic+lamDiff'></span>

<h3>Description</h3>

<p>In population projection matrices, the eigenvalue with the largest magnitude
is the asymptotic population growth rate, referred to as lambda. This
function calculates the difference in lambda between two population
projection matrices, which must have the same dimensions. This function also
has the option to hold some of the vital rates at the value in the baseline
matrix. The resulting calculation is the difference in lambda when all the
non-fixed vital rates are varying. For example, if all the vital rates are
held fixed except for adult fertility, then the output is the difference in
lambda due to difference in adult fertility. The difference is taken as
<code class="reqn">baseline matrix - observed matrix</code>, and the function assumes that the
provided matrices are ordered [baseline, observed].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamDiff(Aobj, which.fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lamDiff_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where
each row is the column-wise vectorization of a matrix. Exactly 2 matrices
should be provided. If more than 2 matrices are provided, the function will
assume that the first is the baseline and the second is the observed matrix
to be compared. Matrices beyond the first two will be ignored.</p>
</td></tr>
<tr><td><code id="lamDiff_+3A_which.fixed">which.fixed</code></td>
<td>
<p>The column-wise indices (single-value index) of the vital
rates to be held at their baseline values across the matrices in <code>Aobj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code>lamDiff_symmetric</code> because it uses the first
matrix in <code>Aobj</code> as the baseline matrix. So fixed parameters are set to
the values in the baseline matrix. In <code>lamDiff_symmetric</code>, the fixed
parameters would be set to their mean values.
</p>
<p><code>lamDiff</code> is most appropriate for comparisons between a control and
treatment population in a controlled experiment or other settings where one
of the populations can be considered as a standard-of-reference.
<code>lamDiff_symmetric</code> is more appropriate for comparisons where none of
the population matrices are obviously suitable as a baseline or
standard-of-reference (for example, when comparing a wet and a dry year).
</p>


<h3>Value</h3>

<p>A single value for the difference in lambda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lamDiff_symmetric">lamDiff_symmetric</a></code> <code><a href="#topic+lamVar">lamVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Abaseline&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
Aobserved&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A_all&lt;- list(Abaseline,Aobserved)
diff_all_vary&lt;- lamDiff(A_all)
diff_fert_vary&lt;- lamDiff(A_all, which.fixed=c(2,6,9))
</code></pre>

<hr>
<h2 id='lamDiff_symmetric'>Difference in lambda, with the mean as baseline</h2><span id='topic+lamDiff_symmetric'></span>

<h3>Description</h3>

<p>In population projection matrices, the eigenvalue with the largest magnitude
is the asymptotic population growth rate, referred to as lambda. This
function calculates the difference in lambda between two population
projection matrices, which must have the same dimensions. This function also
has the option to hold some of the vital rates at their mean values across
the provided matrices. The resulting calculation is the difference in lambda
when all the non-fixed vital rates are varying. For example, if all the vital
rates are held fixed except for adult fertility, then the output is the
difference in lambda due to difference in adult fertility. The difference is
taken as <code class="reqn">observed matrix 1 - observed matrix 2</code>, where the provided
matrices are ordered [observed matrix 1, observed matrix 2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamDiff_symmetric(Aobj, which.fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lamDiff_symmetric_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where
each row is the column-wise vectorization of a matrix. Exactly 2 matrices
should be provided. If more than 2 matrices are provided, the function will
only use the first two.</p>
</td></tr>
<tr><td><code id="lamDiff_symmetric_+3A_which.fixed">which.fixed</code></td>
<td>
<p>The column-wise indices (single-value index) of the vital
rates to be held at their mean values across the matrices in <code>Aobj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code>lamDiff</code> because it uses the mean
matrix as the baseline. So fixed parameters are set to their mean values. In
<code>lamDiff</code>, the fixed parameters would be set to their respective values
given by the baseline matrix.
</p>
<p><code>lamDiff</code> is most appropriate for comparisons between a control and
treatment population in a controlled experiment or other settings where one
of the populations can be considered as a standard-of-reference.
<code>lamDiff_symmetric</code> is more appropriate for comparisons where none of
the population matrices are obviously suitable as a baseline or
standard-of-reference (for example, when comparing a wet and a dry year).
</p>


<h3>Value</h3>

<p>A single value for the difference in lambda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lamDiff">lamDiff</a></code> <code><a href="#topic+lamVar">lamVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Aobs1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
Aobs2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A_all&lt;- list(Aobs1,Aobs2)
diff_all_vary&lt;- lamDiff_symmetric(A_all)
diff_fert_vary&lt;- lamDiff_symmetric(A_all, which.fixed=c(2,6,9))
</code></pre>

<hr>
<h2 id='lamVar'>Variance in lambda</h2><span id='topic+lamVar'></span>

<h3>Description</h3>

<p>In population projection matrices, the eigenvalue with the largest magnitude
is the asymptotic population growth rate, referred to as lambda. This function
calculates the variance in lambda among a group of population projection
matrices, which must all be the same size. This function also has the option
to hold some of the vital rates at their mean values across all the provided
matrices. The resulting calculation is the variance of lambda with all the
non-fixed vital rates are varying. For example, if all the vital rates are
held fixed except for adult fertility, then the output is the variance in
lambda due to variance in adult fertility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamVar(Aobj, which.fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lamVar_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing all the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix.</p>
</td></tr>
<tr><td><code id="lamVar_+3A_which.fixed">which.fixed</code></td>
<td>
<p>The column-wise indices (single-value index) of the vital
rates to be held at their mean values across all matrices in <code>Aobj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value of variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A_all&lt;- collapse_mat_list(list(A1, A2, A3))
var_all_vary&lt;- lamVar(A_all)
var_fert_vary&lt;- lamVar(A_all, which.fixed=c(2,6,9))
</code></pre>

<hr>
<h2 id='lifespan'>Expected lifespan</h2><span id='topic+lifespan'></span>

<h3>Description</h3>

<p>The expected lifespan vector is calculated by multiplying a column
of ones by the fundamental matrix. The fundamental matrix, generally
referred to as <strong>N</strong>, contains the expected number of timesteps that an
individual will spend in each age, stage, or size class of the matrix, given
their current state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lifespan(Umat, all_ages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lifespan_+3A_umat">Umat</code></td>
<td>
<p>The survival components of the population projection matrix</p>
</td></tr>
<tr><td><code id="lifespan_+3A_all_ages">all_ages</code></td>
<td>
<p>User specifies whether the function should return the
expected lifespan remaining for all ages (all_ages=&quot;T&quot;) or only the
expected lifespan at birth (all_ages=&quot;F&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected lifespan vector contains the expected lifespan remaining for
an individual in each age, stage, or size class of the population. If the
user requests only the expected lifespan from birth, then only the first
entry of the expected lifespan vector is returned.
</p>


<h3>Value</h3>

<p>The expected lifespan is either a vector (if all_ages=&quot;T&quot;) or a
single number for the expected lifespan of a newly born individual (if
all_ages=&quot;F&quot;). Expected lifespan is given in the same units as the
projection time step. If the projection interval is two weeks, the lifespan
will be the number of two-week intervals that an individual is expected to
survive. You may wish to convert to a standard time step, like days or
years.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
U1&lt;- A1
U1[1,3]&lt;- 0
# the upper right corner represents adult fertility in this model. U1, the
# survival matrix, contains all the transitions *except* for fertility.
eta&lt;- lifespan(U1, all_ages=TRUE)
eta_1&lt;- lifespan(U1, all_ages=FALSE) # eta_1 should match the first entry of eta
</code></pre>

<hr>
<h2 id='make.Gmatrix'>G-matrix</h2><span id='topic+make.Gmatrix'></span>

<h3>Description</h3>

<p>The G-matrix is the operator used for calculating a vector of effects from a
vector of responses, up to arbitrary interaction order. This recursive function
for building up the G-matrix is presented in a paper about genetic epistasis
from Poelwijk, Krishna, and Ranganathan (2016, PLOS Comp Bio
<a href="https://doi.org/10.1371/journal.pcbi.1004771">doi:10.1371/journal.pcbi.1004771</a>). When the G-matrix is
multiplied on the right by a column vector of the observed responses, it will
produce a column vector of the effects. In other words, the G-matrix adds and
subtracts off the appropriate lower-order terms to arrive at the correct values
of interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.Gmatrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.Gmatrix_+3A_n">n</code></td>
<td>
<p>The number of observed parameters, mutation sites, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that is 2^n-by-2^n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gmat&lt;- make.Gmatrix(3)
</code></pre>

<hr>
<h2 id='mean_matrix'>Calculate the mean matrix</h2><span id='topic+mean_matrix'></span>

<h3>Description</h3>

<p>Calculate the mean matrix from a list of matrices. In the mean matrix, each
element of the matrix is the mean value at that indexed position, across all
the provided matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_matrix(Aobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_matrix_+3A_aobj">Aobj</code></td>
<td>
<p>A list of matrix population models, which must all have the same
dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single population projection matrix, with the same dimensions as
the provided ones, where all vital rate entries are the mean across all
provided matrices at the respective matrix index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
Amean&lt;- mean_matrix(list(A1,A2,A3))
</code></pre>

<hr>
<h2 id='r_nought'>R0, the net reproductive output</h2><span id='topic+r_nought'></span>

<h3>Description</h3>

<p>The net reproductive output, R_0, is the expected number of offspring for one
individual across their expected lifespan. It is calculated as the largest
eigenvalue of the matrix product of the fertility matrix and the fundamental
matrix. The fundamental matrix, generally referred to as <strong>N</strong>, contains the
expected number of timesteps that an individual will spend in each age,
stage, or size class of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_nought(Amat, Fmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_nought_+3A_amat">Amat</code></td>
<td>
<p>The full population projection matrix</p>
</td></tr>
<tr><td><code id="r_nought_+3A_fmat">Fmat</code></td>
<td>
<p>The fertility elements of the population projection matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The net reproductive output, a single value, is the number of
offspring that an individual is expected to have over their lifespan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
F1&lt;- matrix(0, nrow=3, ncol=3)
F1[1,3]&lt;- A1[1,3]
#F1 is all zeros, except the upper right corner which matches A1 for adult fertility
R0&lt;- r_nought(A1, F1)
</code></pre>

<hr>
<h2 id='reMat'>Reconstruct a matrix that was collapsed into a row vector</h2><span id='topic+reMat'></span>

<h3>Description</h3>

<p>Reconstruct a matrix that was collapsed into a row vector. This function
assumes that the matrix is square (as population projection matrices are).
This function also assumes that the matrix was originally collapsed column-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reMat(vecM, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reMat_+3A_vecm">vecM</code></td>
<td>
<p>Either a single row containing a vectorized matrix, or a matrix
where each row is a column-wise vectorized matrix.</p>
</td></tr>
<tr><td><code id="reMat_+3A_j">j</code></td>
<td>
<p>Row-index of the target matrix to re-construct, if <code>vecM</code> is a
matrix. If <code>vecM</code> is a single row vector, then this input can be
neglected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single square matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
A1_remat&lt;- reMat(as.vector(A1))
A_all&lt;- rbind(as.vector(A1), as.vector(A2), as.vector(A3))
A3_remat&lt;- reMat(A_all, j=3)
</code></pre>

<hr>
<h2 id='run_matrix_checks'>Automated checks for a set of matrices</h2><span id='topic+run_matrix_checks'></span>

<h3>Description</h3>

<p>Run automated checks for a set of population projection matrices. This code will
check if the matrices are square, strictly non-negative, ergodic, irreducible,
and primitive. The last check is for whether the column sums are greater than 1
for presumed survival terms. For this portion, the code assumes that the first
row represents only fertility, and that all other matrix entries represent
only survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_matrix_checks(Aobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_matrix_checks_+3A_aobj">Aobj</code></td>
<td>
<p>An object containing the population projection matrices to be
included in the analysis. It should either be a list, or a matrix where each
row is the column-wise vectorization of a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all the checks pass, then nothing is returned. If one of the checks
fails, then an error or warning message will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1&lt;- matrix(data=c(0,0.8,0, 0,0,0.7, 5,0,0.2), nrow=3, ncol=3)
A2&lt;- matrix(data=c(0,0.9,0, 0,0,0.5, 4,0,0.3), nrow=3, ncol=3)
A3&lt;- matrix(data=c(0,0.4,0, 0,0,0.6, 6,0,0.25), nrow=3, ncol=3)
run_matrix_checks(list(A1,A2,A3))
# A couple of examples that would throw errors or warnings:
# run_matrix_checks(c(0,0.8,0, -1,0,0.7, 5,0,0.2)) # has a negative value
# run_matrix_checks(c(0,0.8,0, 0,0.5,0.7, 5,0,0.2)) # has a column-sum greater than 1
</code></pre>

<hr>
<h2 id='variance_complete'>A function for variance assuming a complete sample</h2><span id='topic+variance_complete'></span>

<h3>Description</h3>

<p>The variance, assuming a complete sample, is the mean of the squared
deviations. When you assume an incomplete sample (the standard assumption in
statistics), the variance is calculated as the sum of squared deviations,
divided by (N-1), where N is the number of observations in the sample. As
such, the output of <code>variance_complete</code> will always be smaller than the
output of <code>var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_complete(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_complete_+3A_x">x</code></td>
<td>
<p>A numeric vector that represents a complete sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of the entries of x, calculated with the assumption that
x represents a complete sample. Compare to the output of
<code><a href="stats.html#topic+var">var</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test&lt;- c(5, 6, 8, 10, 25)
Vc&lt;- variance_complete(test)
# compare this output with that of var()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
