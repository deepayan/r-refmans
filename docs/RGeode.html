<!DOCTYPE html><html lang="en"><head><title>Help for package RGeode</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RGeode}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#p'><p>Threshold probability (p(t))</p></a></li>
<li><a href='#randSVD'><p>Randomized Singular Value Decomposition.</p></a></li>
<li><a href='#rexptr'><p>Random generator for a Truncated Exponential distribution.</p></a></li>
<li><a href='#rgammatr'><p>Random generator for a Truncated Gamma distribution.</p></a></li>
<li><a href='#rgeode'><p>GEOmetric Density Estimation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Lorenzo Rimella</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lorenzo Rimella &lt;lorenzo.rimella@hotmail.it&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometric Density Estimation</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the hybrid Bayesian method Geometric Density Estimation. On the one hand, it scales the dimension of our data, on the other it performs inference. The method is fully described in the paper "Scalable Geometric Density Estimation" by Y. Wang, A. Canale, D. Dunson (2016) <a href="http://proceedings.mlr.press/v51/wang16e.pdf">http://proceedings.mlr.press/v51/wang16e.pdf</a>.                   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), Rcpp (&ge; 0.12.11), MASS (&ge; 7.3-47), stats (&ge;
3.4.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-04 13:37:45 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-04 13:51:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='p'>Threshold probability (p(t))</h2><span id='topic+p'></span>

<h3>Description</h3>

<p>The decreasing function for the adptive puning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p(t, c0, c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_+3A_t">t</code></td>
<td>
<p>int <br />
The current iteration at which the probability of an adaption is calculated.</p>
</td></tr>
<tr><td><code id="p_+3A_c0">c0</code></td>
<td>
<p>double <br />
Additive constant at the exponent-</p>
</td></tr>
<tr><td><code id="p_+3A_c1">c1</code></td>
<td>
<p>double <br />
Multiplicative constant at the exponent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>p</code> returns the threshold of interest:
</p>
<table role = "presentation">
<tr><td><code>p(t)</code></td>
<td>
<p>  double <br />
It is p(t)= <code class="reqn">exp{c0+c1*t}</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L. Rimella, <a href="mailto:lorenzo.rimella@hotmail.it">lorenzo.rimella@hotmail.it</a>
</p>


<h3>References</h3>


<ul>
<li><p>   [1] A. Canale, D. Dunson, Y. Wang.
&quot;Scalable Geometric Density Estimation&quot; (2016).<br />
(available at <a href="https://arxiv.org/abs/1410.7692">https://arxiv.org/abs/1410.7692</a>).<br />
The implementation of rgammatr is inspired to the Matlab
implementation of rexptrunc by Ye Wang.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>t = 10
c0= -1
c1= 10

p(t, c0, c1)
</code></pre>

<hr>
<h2 id='randSVD'>Randomized Singular Value Decomposition.</h2><span id='topic+randSVD'></span>

<h3>Description</h3>

<p>Compute the near-optimal low-rank singular value decomposition (SVD) of
a rectangular matrix. The algorithm follows a randomized approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randSVD(A, k = NULL, l = NULL, its = 2, sdist = "unif")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randSVD_+3A_a">A</code></td>
<td>
<p>array_like <br />
a real/complex input matrix (or data frame), with dimensions
<code class="reqn">(m, n)</code>. It is the real/complex matrix being approximated.</p>
</td></tr>
<tr><td><code id="randSVD_+3A_k">k</code></td>
<td>
<p>int, optional <br />
determines the target rank of the low-rank decomposition and should
satisfy <code class="reqn">k &lt;&lt; min(m,n)</code>. Set by default to 6.</p>
</td></tr>
<tr><td><code id="randSVD_+3A_l">l</code></td>
<td>
<p>int, optional <br />
block size of the block Lanczos iterations; <code class="reqn">l</code> must be a
positive integer greater than <code class="reqn">k</code>, and defaults <code class="reqn">l=k+2</code>.</p>
</td></tr>
<tr><td><code id="randSVD_+3A_its">its</code></td>
<td>
<p>int, optional <br />
number of full iterations of a block Lanczos method to conduct;
<code class="reqn">its</code> must be a nonnegative integer, and defaults to 2.</p>
</td></tr>
<tr><td><code id="randSVD_+3A_sdist">sdist</code></td>
<td>
<p>str <code class="reqn">c('normal', 'unif')</code>, optional <br />
Specifies the sampling distribution. <br />
<code class="reqn">'unif'</code> : (default) Uniform '[-1,1]'. <br />
<code class="reqn">'normal</code>' : Normal '~N(0,1)'. <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Randomized SVD (randSVD) is a fast algorithm to compute the approximate low-rank SVD of
a rectangular <code class="reqn">(m,n)</code> matrix <code class="reqn">A</code> using a probabilistic algorithm.
Given the decided rank <code class="reqn">k &lt;&lt; n</code>, <code>rSVD</code> factors the input matrix <code class="reqn">A</code> as
<code class="reqn">A = U * diag(S) * V'</code>, which is the typical SVD form. Precisely, the columns of
U are orthonormal, as are the columns of V, the entries of S are all nonnegative,
and the only nonzero entries of S appear in non-increasing order on its diagonal. The
dimensions are:  U is <code class="reqn">(m,k)</code>, V is <code class="reqn">(n,k)</code>, and S is <code class="reqn">(k,k)</code>, when A
is <code class="reqn">(m,n)</code>.
</p>
<p>Increasing <code class="reqn">its</code> or <code class="reqn">l</code> improves the accuracy of the approximation USV' to A.
</p>
<p>The parameter <code class="reqn">its</code> specifies the number of normalized power iterations
(subspace iterations) to reduce the approximation error. This is recommended
if the the singular values decay slowly. In practice 1 or 2 iterations
achieve good results, however, computing power iterations increases the
computational time. The number of power iterations is set to <code class="reqn">its=2</code> by default.
</p>


<h3>Value</h3>

<p><code>randSVD</code> returns a list containing the following three components:
</p>
<table role = "presentation">
<tr><td><code>d</code></td>
<td>

<p>array_like <br />
<code class="reqn">(k,k)</code> matrix in the rank-k approximation USV' to A, where A is
<code class="reqn">(m,n)</code>; the entries of <code class="reqn">S</code> are all nonnegative, and its only
nonzero entries appear in nonincreasing order on the diagonal.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>

<p>matrix <br />
<code class="reqn">(m, k)</code> matrix in the rank-<code class="reqn">k</code> approximation <code class="reqn">A = U * diag(S) * V'</code>
to A; the columns of U are orthonormal and are called Left singular vect.
We want to remark that this is the transpose matrix, hence
the vectors are on the rows of our matrix.
</p>
</td></tr>
<tr><td><code>v</code></td>
<td>

<p>matrix <br />
<code class="reqn">(n, k)</code> matrix in the rank-<code class="reqn">k</code> approximation <code class="reqn">A = U * diag(S) * V'</code>
to A; the columns of V are orthonormal and are called Right singular vect.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The singular vectors are not unique and only defined up to sign
(a constant of modulus one in the complex case). If a left singular vector
has its sign changed, changing the sign of the corresponding right vector
gives an equivalent decomposition.
</p>


<h3>Author(s)</h3>

<p>L. Rimella, <a href="mailto:lorenzo.rimella@hotmail.it">lorenzo.rimella@hotmail.it</a>
</p>


<h3>References</h3>


<ul>
<li><p>  [1] N. Halko, P. Martinsson, and J. Tropp.<br />
&quot;Finding structure with randomness: probabilistic
algorithms for constructing approximate matrix
decompositions&quot; (2009). <br />
(available at arXiv <a href="http://arxiv.org/abs/0909.4061">http://arxiv.org/abs/0909.4061</a>).
</p>
</li>
<li><p>  [2] S. Voronin and P.Martinsson.<br />
&quot;RSVDPACK: Subroutines for computing partial singular value
decompositions via randomized sampling on single core, multi core,
and GPU architectures&quot; (2015).<br />
(available at 'arXiv <a href="http://arxiv.org/abs/1502.05366">http://arxiv.org/abs/1502.05366</a>).
</p>
</li>
<li><p>   [3] N. Benjamin Erichson.<br />
&quot;Randomized Singular Value Decomposition (rsvd): R package&quot; (2016).<br />
(available in the CRAN).
</p>
</li>
<li><p>   [4] Nathan Halko, Per-Gunnar Martinsson, and Joel Tropp.<br />
&quot;Finding structure with randomness: Stochastic algorithms for
constructing approximate matrix decompositions&quot; (2009).<br />
(available at <a href="http://arxiv.org">http://arxiv.org</a>).
</p>
</li>
<li><p>   [5] V. Rokhlin, A. Szlam, M. Tygert.<br />
&quot;A randomized algorithm for principal component analysis&quot; (2009).<br />
(available at <a href="https://arxiv.org/abs/0809.2274">https://arxiv.org/abs/0809.2274</a>).<br />
The implementation of rand SVD is inspired by the MatLab implementation
of RandPCA by M. Tygert.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a general matrix with 1000 rows and 1000 columns
vy= rnorm(1000*1000,0,1)
y= matrix(vy,1000,1000,byrow=TRUE)

#Compute the randSVD for the first hundred components of the matrix y and measure the time
start.time &lt;- Sys.time()
prova1= randSVD(y,k=100)
Sys.time()- start.time

#Compare with a classical SVD
start.time &lt;- Sys.time()
prova2= svd(y)
Sys.time()- start.time


</code></pre>

<hr>
<h2 id='rexptr'>Random generator for a Truncated Exponential distribution.</h2><span id='topic+rexptr'></span>

<h3>Description</h3>

<p>Simulate random number from a truncated Exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rexptr(n = 1, lambda = 1, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rexptr_+3A_n">n</code></td>
<td>
<p>int, optional <br />
number of simulations.</p>
</td></tr>
<tr><td><code id="rexptr_+3A_lambda">lambda</code></td>
<td>
<p>double, optional <br />
parameter of the distribution.</p>
</td></tr>
<tr><td><code id="rexptr_+3A_range">range</code></td>
<td>
<p>array_like, optional <br />
domain of the distribution, where we truncate our
Exponential. <code class="reqn">range(0)</code> is the min of the range
and <code class="reqn">range(1)</code> is the max of the range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It provide a way to simulate from a truncated Exponential
distribution with given pameter <code class="reqn">\lambda</code> and the range <code class="reqn">range</code>.
This will be used during the posterior sampling in th Gibbs sampler.
</p>


<h3>Value</h3>

<p><code>rexptr</code> returns the simulated value of the
distribution:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>  double <br />
it is the simulated value of the truncated Exponential
distribution. It will be a value in <code class="reqn">(range(0),
           range(1))</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L. Rimella, <a href="mailto:lorenzo.rimella@hotmail.it">lorenzo.rimella@hotmail.it</a>
</p>


<h3>References</h3>


<ul>
<li><p>   [1] Y. Wang, A. Canale, D. Dunson.
&quot;Scalable Geometric Density Estimation&quot; (2016).<br />
The implementation of rgammatr is inspired to the Matlab
implementation of rexptrunc by Ye Wang.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a truncated Exponential with parameters 0.5 in the range
#5,Inf.
#Set the range:
range&lt;- c(1,Inf)

#Simulate the truncated Gamma
set.seed(123)
vars1&lt;-rexptr(1000,0.5,range)

#Look at the histogram
hist(vars1,freq=FALSE,ylim=c(0,2),xlim = c(0,5))
lines(density(vars1))

#Compare with a non truncated Exponential
set.seed(123)
vars2&lt;-rexp(1000,0.5)


#Compare the two results
lines(density(vars2),col='red')

#Observation: simulate without range is equivalent to simulate from
#rexp(1000,0.5)

</code></pre>

<hr>
<h2 id='rgammatr'>Random generator for a Truncated Gamma distribution.</h2><span id='topic+rgammatr'></span>

<h3>Description</h3>

<p>Simulate random number from a truncated Gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgammatr(n = 1, A = 0, B = 1, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgammatr_+3A_n">n</code></td>
<td>
<p>int, optional <br />
number of simulations.</p>
</td></tr>
<tr><td><code id="rgammatr_+3A_a">A</code></td>
<td>
<p>double, optional <br />
shape parameter of the distribution.</p>
</td></tr>
<tr><td><code id="rgammatr_+3A_b">B</code></td>
<td>
<p>double, optional <br />
rate parameter of the distribution.</p>
</td></tr>
<tr><td><code id="rgammatr_+3A_range">range</code></td>
<td>
<p>array_like, optional <br />
domain of the distribution, where we truncate our
Gamma. <code class="reqn">range(0)</code> is the min of the range and
<code class="reqn">range(1)</code> is the max of the range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It provide a way to simulate from a truncated Gamma distribution with
given pameters <code class="reqn">A,B</code> and range <code class="reqn">range</code>. This will be used
during the posterior sampling in th Gibbs sampler.
</p>


<h3>Value</h3>

<p><code>rgammatr</code> returns the simulated value of the distribution:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>  double <br />
it is the simulated value of the truncated Gamma
distribution. It will be a value in <code class="reqn">(range(0),range(1))</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L. Rimella, <a href="mailto:lorenzo.rimella@hotmail.it">lorenzo.rimella@hotmail.it</a>
</p>


<h3>References</h3>


<ul>
<li><p>   [1] Y. Wang, A. Canale, D. Dunson.
&quot;Scalable Geometric Density Estimation&quot; (2016).<br />
The implementation of rgammatr is inspired to the Matlab
implementation of gamrndtruncated by Ye Wang.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Simulate a truncated Gamma with parameters 1,2 in the range
#1,5.
#Set the range:
range&lt;- c(1,5)

#Simulate the truncated Gamma
set.seed(123)
vars1&lt;-rgammatr(1000,1,2,range)

#Look at the histogram
hist(vars1,freq=FALSE,ylim=c(0,2),xlim = c(0,5))
lines(density(vars1))

#Compare with a non truncated Gamma
set.seed(123)
vars2&lt;-rgamma(1000,1,2)


#Compare the two results
lines(density(vars2),col='red')

#Observation: simulate without range is equivalent to simulate from
#rgamma(1000,1,2)

</code></pre>

<hr>
<h2 id='rgeode'>GEOmetric Density Estimation.</h2><span id='topic+rgeode'></span>

<h3>Description</h3>

<p>It selects the principal directions of the data and
performs inference. Moreover GEODE is also able to handle missing
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgeode(Y, d = 6, burn = 1000, its = 2000, tol = 0.01, atau = 1/20,
  asigma = 1/2, bsigma = 1/2, starttime = NULL, stoptime = NULL,
  fast = TRUE, c0 = -1, c1 = -0.005)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgeode_+3A_y">Y</code></td>
<td>
<p>array_like <br />
a real input matrix (or data frame), with dimensions
<code class="reqn">(n, D)</code>. It is the real matrix of data.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_d">d</code></td>
<td>
<p>int, optional <br />
it is the conservative upper bound for the dimension
D. We are confident that the real dimension is smaller
then it.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_burn">burn</code></td>
<td>
<p>int, optional <br />
number of burn-in to perform in our Gibbs sampler. It
represents also the stopping time that stop the choice
of the principal axes.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_its">its</code></td>
<td>
<p>int, optional <br />
number of iterations that must be performed after
the burn-in.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_tol">tol</code></td>
<td>
<p>double, optional <br />
threshold for adaptively removing redundant
dimensions. It is used compared with the ratio:
<code class="reqn">\frac{\alpha_j^2(t)}{\max \alpha_i^2(t)}</code>.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_atau">atau</code></td>
<td>
<p>double, optional <br />
The parameter <code class="reqn">a_\tau</code> of the truncated
Exponential (the prior for <code class="reqn">\tau_j</code>).</p>
</td></tr>
<tr><td><code id="rgeode_+3A_asigma">asigma</code></td>
<td>
<p>double, optional <br />
The shape parameter <code class="reqn">a_\sigma</code> of the
truncated Gamma (the prior for <code class="reqn">\sigma^2</code>).</p>
</td></tr>
<tr><td><code id="rgeode_+3A_bsigma">bsigma</code></td>
<td>
<p>double, optional <br />
The rate parameter <code class="reqn">b_\sigma</code> of the
truncated Gamma (the prior for <code class="reqn">\sigma^2</code>).</p>
</td></tr>
<tr><td><code id="rgeode_+3A_starttime">starttime</code></td>
<td>
<p>int, optional <br />
starting time for adaptive pruning. It must be less
then the number of burn-in.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_stoptime">stoptime</code></td>
<td>
<p>int, optional <br />
stop time for adaptive pruning. It must be less
then the number of burn-in.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_fast">fast</code></td>
<td>
<p>bool, optional <br />
If <code class="reqn">TRUE</code> it is run using fast d-rank SVD.
Otherwise it uses the classical SVD.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_c0">c0</code></td>
<td>
<p>double, optional <br />
Additive constant for the exponent of the pruning step.</p>
</td></tr>
<tr><td><code id="rgeode_+3A_c1">c1</code></td>
<td>
<p>double, optional <br />
Multiplicative constant for the exponent of the pruning step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GEOmetric Density Estimation (rgeode) is a fast algorithm performing
inference on normally distributed data. It is essentially
divided in two principal steps:
</p>

<ul>
<li><p>  Selection of the principal axes of the data.
</p>
</li>
<li><p>  Adaptive Gibbs sampler with the creation of a set of samples from
the full conditional posteriors of the parameters of interest,
which enable us to perform inference.
</p>
</li></ul>

<p>It takes in inputs several quantities. A rectangular
<code class="reqn">(N,D)</code> matrix <code class="reqn">Y</code>, on which we will run a Fast rank
<code class="reqn">d</code> SVD. The conservative upper bound of the true dimension
of our data <code class="reqn">d</code>. A set of tuning parameters. We remark that
the choice of the conservative upper bound <code class="reqn">d</code> must be such
that <code class="reqn">d&gt;p</code>, with <code class="reqn">p</code> real dimension, and <code class="reqn">d &lt;&lt; D</code>.
</p>


<h3>Value</h3>

<p><code>rgeode</code> returns a list containing the following
components:
</p>
<table role = "presentation">
<tr><td><code>InD</code></td>
<td>
<p>  array_like <br />
The chose principal axes.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>       matrix <br />
Containing the sample from the full conditional
posterior of <code class="reqn">u_j</code>s. We store each
iteration on the columns.
</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>     matrix <br />
Containing the sample from the full conditional
posterior of <code class="reqn">tau_j</code>s.
</p>
</td></tr>
<tr><td><code>sigmaS</code></td>
<td>
<p>  array_like <br />
Containing the sample from the full conditional
posterior of <code class="reqn">sigma</code>.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>       matrix <br />
Containing the principal singular vectors.
</p>
</td></tr>
<tr><td><code>Miss</code></td>
<td>
<p>    list <br />
Containing all the informations about missing
data. If there are not missing data this output
is not provide.
</p>

<ul>
<li><p>id_m array <br />
It contains the set of rows with missing data.
</p>
</li>
<li><p>pos_m list <br />
It contains the set of missing data positions for each
row with missing values.
</p>
</li>
<li><p>yms list <br />
The list contained the pseudo-observation substituting our
missing data. Each element of the list represents the simulated
data for that time.
</p>
</li></ul>

</td></tr>
</table>


<h3>Note</h3>

<p>The part related to the missing data is filled only
in the case in which we have missing data.
</p>


<h3>Author(s)</h3>

<p>L. Rimella, <a href="mailto:lorenzo.rimella@hotmail.it">lorenzo.rimella@hotmail.it</a>
</p>


<h3>References</h3>


<ul>
<li><p>    [1] Y. Wang, A. Canale, D. Dunson.
&quot;Scalable Geometric Density Estimation&quot; (2016).<br />
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
library(RGeode)

####################################################################
# WITHOUT MISSING DATA
####################################################################
# Define the dataset
D= 200
n= 500
d= 10
d_true= 3

set.seed(321)

mu_true= runif(d_true, -3, 10)

Sigma_true= matrix(0,d_true,d_true)
diag(Sigma_true)= c(runif(d_true, 10, 100))

W_true = svd(matrix(rnorm(D*d_true, 0, 1), d_true, D))$v

sigma_true = abs(runif(1,0,1))

mu= W_true%*%mu_true
C= W_true %*% Sigma_true %*% t(W_true)+ sigma_true* diag(D)

y= mvrnorm(n, mu, C)

################################
# GEODE: Without missing data
################################

start.time &lt;- Sys.time() 
GEODE= rgeode(Y= y, d)
Sys.time()- start.time

# SIGMAS
#plot(seq(110,3000,by=1),GEODE$sigmaS[110:3000],ty='l',col=2,
#     xlab= 'Iteration', ylab= 'sigma^2', main= 'Simulation of sigma^2')
#abline(v=800,lwd= 2, col= 'blue')
#legend('bottomright',c('Posterior of sigma^2', 'Stopping time'),
#       lwd=c(1,2),col=c(2,4),cex=0.55, border='black', box.lwd=3)
       
       
####################################################################
# WITH MISSING DATA
####################################################################

###########################
#Insert NaN
n_m = 5 #number of data vectors containing missing features
d_m = 1  #number of missing features

data_miss= sample(seq(1,n),n_m)

features= sample(seq(1,D), d_m)
for(i in 2:n_m)
{
  features= rbind(features, sample(seq(1,D), d_m))
}

for(i in 1:length(data_miss))
{
  
  if(i==length(data_miss))
  {
    y[data_miss[i],features[i,][-1]]= NaN
  }
  else
  {
    y[data_miss[i],features[i,]]= NaN
  }
  
}

################################
# GEODE: With missing data
################################
set.seed(321)
start.time &lt;- Sys.time() 
GEODE= rgeode(Y= y, d)
Sys.time()- start.time

# SIGMAS
#plot(seq(110,3000,by=1),GEODE$sigmaS[110:3000],ty='l',col=2,
#     xlab= 'Iteration', ylab= 'sigma^2', main= 'Simulation of sigma^2')
#abline(v=800,lwd= 2, col= 'blue')
#legend('bottomright',c('Posterior of sigma^2', 'Stopping time'),
#       lwd=c(1,2),col=c(2,4),cex=0.55, border='black', box.lwd=3)



####################################################################
####################################################################
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
