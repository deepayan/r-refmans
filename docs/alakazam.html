<!DOCTYPE html><html><head><title>Help for package alakazam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alakazam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alakazam-package'><p>alakazam: Immunoglobulin Clonal Lineage and Diversity Analysis</p></a></li>
<li><a href='#ABBREV_AA'><p>Amino acid abbreviation translations</p></a></li>
<li><a href='#AbundanceCurve-class'><p>S4 class defining a clonal abundance curve</p></a></li>
<li><a href='#alakazam'><p>The Alakazam package</p></a></li>
<li><a href='#aliphatic'><p>Calculates the aliphatic index of amino acid sequences</p></a></li>
<li><a href='#alphaDiversity'><p>Calculate clonal alpha diversity</p></a></li>
<li><a href='#aminoAcidProperties'><p>Calculates amino acid chemical properties for sequence data</p></a></li>
<li><a href='#baseTheme'><p>Standard ggplot settings</p></a></li>
<li><a href='#buildPhylipLineage'><p>Infer an Ig lineage using PHYLIP</p></a></li>
<li><a href='#bulk'><p>Calculates the average bulkiness of amino acid sequences</p></a></li>
<li><a href='#calcCoverage'><p>Calculate sample coverage</p></a></li>
<li><a href='#calcDiversity'><p>Calculate the diversity index</p></a></li>
<li><a href='#ChangeoClone-class'><p>S4 class defining a clone</p></a></li>
<li><a href='#charge'><p>Calculates the net charge of amino acid sequences.</p></a></li>
<li><a href='#checkColumns'><p>Check data.frame for valid columns and issue message if invalid</p></a></li>
<li><a href='#collapseDuplicates'><p>Remove duplicate DNA sequences and combine annotations</p></a></li>
<li><a href='#combineIgphyml'><p>Combine IgPhyML object parameters into a dataframe</p></a></li>
<li><a href='#countClones'><p>Tabulates clones sizes</p></a></li>
<li><a href='#countGenes'><p>Tabulates V(D)J allele, gene or family usage.</p></a></li>
<li><a href='#countPatterns'><p>Count sequence patterns</p></a></li>
<li><a href='#cpuCount'><p>Available CPU cores</p></a></li>
<li><a href='#DEFAULT_COLORS'><p>Default colors</p></a></li>
<li><a href='#DiversityCurve-class'><p>S4 class defining a diversity curve</p></a></li>
<li><a href='#EdgeTest-class'><p>S4 class defining edge significance</p></a></li>
<li><a href='#estimateAbundance'><p>Estimates the complete clonal relative abundance distribution</p></a></li>
<li><a href='#Example10x'><p>Small example 10x Genomics Ig V(D)J sequences from CD19+ B cells isolated from PBMCs of a healthy</p>
human donor. Down-sampled from data provided by 10x Genomics under a Creative Commons Attribute license,
and processed with their Cell Ranger pipeline.</a></li>
<li><a href='#ExampleDb'><p>Example AIRR database</p></a></li>
<li><a href='#ExampleDbChangeo'><p>Example Change-O database</p></a></li>
<li><a href='#ExampleTrees'><p>Example Ig lineage trees</p></a></li>
<li><a href='#extractVRegion'><p>Extracts FWRs and CDRs from IMGT-gapped sequences</p></a></li>
<li><a href='#getAAMatrix'><p>Build an AA distance matrix</p></a></li>
<li><a href='#getDNAMatrix'><p>Build a DNA distance matrix</p></a></li>
<li><a href='#getMRCA'><p>Retrieve the first non-root node of a lineage tree</p></a></li>
<li><a href='#getPathLengths'><p>Calculate path lengths from the tree root</p></a></li>
<li><a href='#getPositionQuality'><p>Get a data.frame with sequencing qualities per position</p></a></li>
<li><a href='#getSegment'><p>Get Ig segment allele, gene and family names</p></a></li>
<li><a href='#graphToPhylo'><p>Convert a tree in igraph <code>graph</code> format to ape <code>phylo</code> format.</p></a></li>
<li><a href='#gravy'><p>Calculates the hydrophobicity of amino acid sequences</p></a></li>
<li><a href='#gridPlot'><p>Plot multiple ggplot objects</p></a></li>
<li><a href='#groupGenes'><p>Group sequences by gene assignment</p></a></li>
<li><a href='#IMGT_REGIONS'><p>IMGT V-segment regions</p></a></li>
<li><a href='#isValidAASeq'><p>Validate amino acid sequences</p></a></li>
<li><a href='#IUPAC_CODES'><p>IUPAC ambiguous characters</p></a></li>
<li><a href='#junctionAlignment'><p>Calculate junction region alignment properties</p></a></li>
<li><a href='#makeChangeoClone'><p>Generate a ChangeoClone object for lineage construction</p></a></li>
<li><a href='#makeTempDir'><p>Create a temporary folder</p></a></li>
<li><a href='#maskPositionsByQuality'><p>Mask sequence positions with low quality</p></a></li>
<li><a href='#maskSeqEnds'><p>Masks ragged leading and trailing edges of aligned DNA sequences</p></a></li>
<li><a href='#maskSeqGaps'><p>Masks gap characters in DNA sequences</p></a></li>
<li><a href='#MRCATest-class'><p>S4 class defining edge significance</p></a></li>
<li><a href='#nonsquareDist'><p>Calculate pairwise distances between sequences</p></a></li>
<li><a href='#padSeqEnds'><p>Pads ragged ends of aligned DNA sequences</p></a></li>
<li><a href='#pairwiseDist'><p>Calculate pairwise distances between sequences</p></a></li>
<li><a href='#pairwiseEqual'><p>Calculate pairwise equivalence between sequences</p></a></li>
<li><a href='#permuteLabels'><p>Permute the node labels of a tree</p></a></li>
<li><a href='#phyloToGraph'><p>Convert a tree in ape <code>phylo</code> format to igraph <code>graph</code> format.</p></a></li>
<li><a href='#plotAbundanceCurve'><p>Plot a clonal abundance distribution</p></a></li>
<li><a href='#plotDiversityCurve'><p>Plot the results of alphaDiversity</p></a></li>
<li><a href='#plotDiversityTest'><p>Plot the results of diversity testing</p></a></li>
<li><a href='#plotEdgeTest'><p>Plot the results of an edge permutation test</p></a></li>
<li><a href='#plotMRCATest'><p>Plot the results of a founder permutation test</p></a></li>
<li><a href='#plotSubtrees'><p>Plots subtree statistics for multiple trees</p></a></li>
<li><a href='#polar'><p>Calculates the average polarity of amino acid sequences</p></a></li>
<li><a href='#progressBar'><p>Standard progress bar</p></a></li>
<li><a href='#rarefyDiversity'><p>Generate a clonal diversity index curve</p></a></li>
<li><a href='#readChangeoDb'><p>Read a Change-O tab-delimited database file</p></a></li>
<li><a href='#readFastqDb'><p>Load sequencing quality scores from a FASTQ file</p></a></li>
<li><a href='#readIgphyml'><p>Read in output from IgPhyML</p></a></li>
<li><a href='#seqDist'><p>Calculate distance between two sequences</p></a></li>
<li><a href='#seqEqual'><p>Test DNA sequences for equality.</p></a></li>
<li><a href='#SingleDb'><p>Single sequence AIRR database</p></a></li>
<li><a href='#sortGenes'><p>Sort V(D)J genes</p></a></li>
<li><a href='#stoufferMeta'><p>Weighted meta-analysis of p-values via Stouffer's method</p></a></li>
<li><a href='#summarizeSubtrees'><p>Generate subtree summary statistics for a tree</p></a></li>
<li><a href='#tableEdges'><p>Tabulate the number of edges between annotations within a lineage tree</p></a></li>
<li><a href='#testDiversity'><p>Pairwise test of the diversity index</p></a></li>
<li><a href='#testEdges'><p>Tests for parent-child annotation enrichment in lineage trees</p></a></li>
<li><a href='#testMRCA'><p>Tests for MRCA annotation enrichment in lineage trees</p></a></li>
<li><a href='#translateDNA'><p>Translate nucleotide sequences to amino acids</p></a></li>
<li><a href='#translateStrings'><p>Translate a vector of strings</p></a></li>
<li><a href='#writeChangeoDb'><p>Write a Change-O tab-delimited database file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Immunoglobulin Clonal Lineage and Diversity Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for high-throughput adaptive immune 
    receptor repertoire sequencing (AIRR-Seq; Rep-Seq) analysis. In 
    particular, immunoglobulin (Ig) sequence lineage reconstruction, 
    lineage topology analysis, diversity profiling, amino acid property 
    analysis and gene usage.
    Citations: 
    Gupta and Vander Heiden, et al (2017) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtv359">doi:10.1093/bioinformatics/btv359</a>&gt;,
    Stern, Yaari and Vander Heiden, et al (2014) &lt;<a href="https://doi.org/10.1126%2Fscitranslmed.3008879">doi:10.1126/scitranslmed.3008879</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alakazam.readthedocs.io/">https://alakazam.readthedocs.io/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/kleinstein/alakazam/issues">https://bitbucket.org/kleinstein/alakazam/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software, AnnotationData</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), ggplot2 (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>airr (&ge; 1.4.1), ape, dplyr (&ge; 1.0), graphics, grid, igraph
(&ge; 1.5.0), Matrix (&ge; 1.3-0), methods, progress, Rcpp (&ge;
0.12.12), readr, rlang, scales, seqinr, stats, stringi, tibble,
tidyr (&ge; 1.0), utils, Biostrings (&ge; 2.56.0),
GenomicAlignments (&ge; 1.24.0), IRanges (&ge; 2.22.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Alakazam.R' 'AminoAcids.R' 'Classes.R' 'Core.R' 'Data.R'
'Diversity.R' 'Deprecated.R' 'Fastq.R' 'Gene.R' 'Lineage.R'
'RcppExports.R' 'Sequence.R' 'Topology.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 13:49:31 UTC; susanna</td>
</tr>
<tr>
<td>Author:</td>
<td>Susanna Marquez [cre, aut],
  Namita Gupta [aut],
  Nima Nouri [aut],
  Ruoyi Jiang [aut],
  Julian Zhou [aut],
  Kenneth Hoehn [aut],
  Daniel Gadala-Maria [ctb],
  Edel Aron [ctb],
  Cole Jensen [ctb],
  Jason Vander Heiden [aut],
  Steven Kleinstein [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susanna Marquez &lt;susanna.marquez@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-30 01:12:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='alakazam-package'>alakazam: Immunoglobulin Clonal Lineage and Diversity Analysis</h2><span id='topic+alakazam-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Provides methods for high-throughput adaptive immune receptor repertoire sequencing (AIRR-Seq; Rep-Seq) analysis. In particular, immunoglobulin (Ig) sequence lineage reconstruction, lineage topology analysis, diversity profiling, amino acid property analysis and gene usage. Citations: Gupta and Vander Heiden, et al (2017) <a href="https://doi.org/10.1093/bioinformatics/btv359">doi:10.1093/bioinformatics/btv359</a>, Stern, Yaari and Vander Heiden, et al (2014) <a href="https://doi.org/10.1126/scitranslmed.3008879">doi:10.1126/scitranslmed.3008879</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Susanna Marquez <a href="mailto:susanna.marquez@yale.edu">susanna.marquez@yale.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Namita Gupta <a href="mailto:namita.gupta@yale.edu">namita.gupta@yale.edu</a>
</p>
</li>
<li><p> Nima Nouri <a href="mailto:nima.nouri@yale.edu">nima.nouri@yale.edu</a>
</p>
</li>
<li><p> Ruoyi Jiang <a href="mailto:ruoyi.jiang@yale.edu">ruoyi.jiang@yale.edu</a>
</p>
</li>
<li><p> Julian Zhou <a href="mailto:julian.zhou@bulldogs.yale.edu">julian.zhou@bulldogs.yale.edu</a>
</p>
</li>
<li><p> Kenneth Hoehn <a href="mailto:kenneth.hoehn@yale.edu">kenneth.hoehn@yale.edu</a>
</p>
</li>
<li><p> Jason Vander Heiden <a href="mailto:jason.vanderheiden@gmail.com">jason.vanderheiden@gmail.com</a>
</p>
</li>
<li><p> Steven Kleinstein <a href="mailto:steven.kleinstein@yale.edu">steven.kleinstein@yale.edu</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Daniel Gadala-Maria <a href="mailto:daniel.gadala-maria@yale.edu">daniel.gadala-maria@yale.edu</a> [contributor]
</p>
</li>
<li><p> Edel Aron <a href="mailto:edel.aron@yale.edu">edel.aron@yale.edu</a> [contributor]
</p>
</li>
<li><p> Cole Jensen <a href="mailto:cole.jensen@yale.edu">cole.jensen@yale.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://alakazam.readthedocs.io/">https://alakazam.readthedocs.io/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://bitbucket.org/kleinstein/alakazam/issues">https://bitbucket.org/kleinstein/alakazam/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ABBREV_AA'>Amino acid abbreviation translations</h2><span id='topic+ABBREV_AA'></span>

<h3>Description</h3>

<p>Mappings of amino acid abbreviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABBREV_AA
</code></pre>


<h3>Format</h3>

<p>Named character vector defining single-letter character codes to 
three-letter abbreviation mappings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c("Ala", "Ile", "Trp")
translateStrings(aa, ABBREV_AA)

</code></pre>

<hr>
<h2 id='AbundanceCurve-class'>S4 class defining a clonal abundance curve</h2><span id='topic+AbundanceCurve-class'></span><span id='topic+AbundanceCurve'></span><span id='topic+print+2CAbundanceCurve-method'></span><span id='topic+AbundanceCurve-method'></span><span id='topic+plot+2CAbundanceCurve+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>AbundanceCurve</code> defines clonal abundance values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AbundanceCurve'
print(x)

## S4 method for signature 'AbundanceCurve,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbundanceCurve-class_+3A_x">x</code></td>
<td>
<p>AbundanceCurve object</p>
</td></tr>
<tr><td><code id="AbundanceCurve-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="AbundanceCurve-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotDiversityCurve">plotDiversityCurve</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>abundance</code></dt><dd><p>data.frame with relative clonal abundance data and confidence intervals,
containing the following columns:
</p>

<ul>
<li>  <p><code>group</code>:  group identifier.
</p>
</li>
<li>  <p><code>clone_id</code> or <code>CLONE</code>:  clone identifier. 
</p>
</li>
<li>  <p><code>p</code>:      relative abundance of the clone.
</p>
</li>
<li>  <p><code>lower</code>:  lower confidence inverval bound.
</p>
</li>
<li>  <p><code>upper</code>:  upper confidence interval bound.
</p>
</li>
<li>  <p><code>rank</code>:   the rank of the clone abundance.
</p>
</li></ul>
</dd>
<dt><code>bootstrap</code></dt><dd><p>data.frame of bootstrapped clonal distributions.</p>
</dd>
<dt><code>clone_by</code></dt><dd><p>string specifying the name of the clone column.</p>
</dd>
<dt><code>group_by</code></dt><dd><p>string specifying the name of the grouping column.</p>
</dd>
<dt><code>groups</code></dt><dd><p>vector specifying the names of unique groups in group column.</p>
</dd>
<dt><code>n</code></dt><dd><p>numeric vector indication the number of sequences sampled in each group.</p>
</dd>
<dt><code>nboot</code></dt><dd><p>numeric specifying the number of bootstrap iterations to use.</p>
</dd>
<dt><code>ci</code></dt><dd><p>confidence interval defining the upper and lower bounds 
(a value between 0 and 1).</p>
</dd>
</dl>

<hr>
<h2 id='alakazam'>The Alakazam package</h2><span id='topic+alakazam'></span>

<h3>Description</h3>

<p><code>alakazam</code> in a member of the Immcantation framework of tools and serves five main 
purposes:
</p>

<ul>
<li><p>  Providing core functionality for other R packages in Immcantation. This
includes common tasks such as file I/O, basic DNA sequence manipulation, and
interacting with V(D)J segment and gene annotations.
</p>
</li>
<li><p>  Providing an R interface for interacting with the output of the pRESTO and 
Change-O tool suites.
</p>
</li>
<li><p>  Performing clonal abundance and diversity analysis on lymphocyte repertoires.
</p>
</li>
<li><p>  Performing lineage reconstruction on clonal populations of immunoglobulin 
(Ig) sequences.
</p>
</li>
<li><p>  Performing physicochemical property analyses of lymphocyte receptor sequences.
</p>
</li></ul>

<p>For additional details regarding the use of the <code>alakazam</code> package see the 
vignettes:<br />
<code>browseVignettes("alakazam")</code>
</p>


<h3>File I/O</h3>


<ul>
<li>  <p><a href="#topic+readChangeoDb">readChangeoDb</a>:        Input Change-O style files.
</p>
</li>
<li>  <p><a href="#topic+writeChangeoDb">writeChangeoDb</a>:       Output Change-O style files.
</p>
</li></ul>



<h3>Sequence cleaning</h3>


<ul>
<li>  <p><a href="#topic+maskSeqEnds">maskSeqEnds</a>:          Mask ragged ends.
</p>
</li>
<li>  <p><a href="#topic+maskSeqGaps">maskSeqGaps</a>:          Mask gap characters.
</p>
</li>
<li>  <p><a href="#topic+collapseDuplicates">collapseDuplicates</a>:   Remove duplicate sequences.
</p>
</li></ul>



<h3>Lineage reconstruction</h3>


<ul>
<li>  <p><a href="#topic+makeChangeoClone">makeChangeoClone</a>:     Clean sequences for lineage reconstruction.
</p>
</li>
<li>  <p><a href="#topic+buildPhylipLineage">buildPhylipLineage</a>:   Perform lineage reconstruction of Ig sequences.
</p>
</li></ul>



<h3>Lineage topology analysis</h3>


<ul>
<li>  <p><a href="#topic+tableEdges">tableEdges</a>:           Tabulate annotation relationships over edges.
</p>
</li>
<li>  <p><a href="#topic+testEdges">testEdges</a>:            Significance testing of annotation edges.
</p>
</li>
<li>  <p><a href="#topic+testMRCA">testMRCA</a>:             Significance testing of MRCA annotations.
</p>
</li>
<li>  <p><a href="#topic+summarizeSubtrees">summarizeSubtrees</a>:    Various summary statistics for subtrees.
</p>
</li>
<li>  <p><a href="#topic+plotSubtrees">plotSubtrees</a>:         Plot distributions of summary statistics 
for a population of trees.
</p>
</li></ul>



<h3>Diversity analysis</h3>


<ul>
<li>  <p><a href="#topic+countClones">countClones</a>:          Calculate clonal abundance.
</p>
</li>
<li>  <p><a href="#topic+estimateAbundance">estimateAbundance</a>:  	 Bootstrap clonal abundance curves.
</p>
</li>
<li>  <p><a href="#topic+alphaDiversity">alphaDiversity</a>:  	 Generate clonal alpha diversity curves.
</p>
</li>
<li>  <p><a href="#topic+plotAbundanceCurve">plotAbundanceCurve</a>:   Plot clone size distribution as a rank-abundance 
</p>
</li>
<li>  <p><a href="#topic+plotDiversityCurve">plotDiversityCurve</a>:   Plot clonal diversity curves.
</p>
</li>
<li>  <p><a href="#topic+plotDiversityTest">plotDiversityTest</a>:    Plot testing at given diversity hill indicex. 
</p>
</li></ul>



<h3>Ig and TCR sequence annotation</h3>


<ul>
<li>  <p><a href="#topic+countGenes">countGenes</a>:           Calculate Ig and TCR allele, gene and family usage.
</p>
</li>
<li>  <p><a href="#topic+extractVRegion">extractVRegion</a>:       Extract CDRs and FWRs sub-sequences.
</p>
</li>
<li>  <p><a href="#topic+getAllele">getAllele</a>:            Get V(D)J allele names.
</p>
</li>
<li>  <p><a href="#topic+getGene">getGene</a>:              Get V(D)J gene names.
</p>
</li>
<li>  <p><a href="#topic+getFamily">getFamily</a>:            Get V(D)J family names.
</p>
</li>
<li>  <p><a href="#topic+junctionAlignment">junctionAlignment</a>: Junction alignment properties 
</p>
</li></ul>



<h3>Sequence distance calculation</h3>


<ul>
<li>  <p><a href="#topic+seqDist">seqDist</a>:        Calculate Hamming distance between two sequences.
</p>
</li>
<li>  <p><a href="#topic+seqEqual">seqEqual</a>:       Test two sequences for equivalence.
</p>
</li>
<li>  <p><a href="#topic+pairwiseDist">pairwiseDist</a>:   Calculate a matrix of pairwise Hamming distances for a 
set of sequences.
</p>
</li>
<li>  <p><a href="#topic+pairwiseEqual">pairwiseEqual</a>:  Calculate a logical matrix of pairwise equivalence for a 
set of sequences.
</p>
</li></ul>



<h3>Amino acid propertes</h3>


<ul>
<li>  <p><a href="#topic+translateDNA">translateDNA</a>:         Translate DNA sequences to amino acid sequences.
</p>
</li>
<li>  <p><a href="#topic+aminoAcidProperties">aminoAcidProperties</a>:  Calculate various physicochemical properties of amino acid 
sequences.
</p>
</li>
<li>  <p><a href="#topic+countPatterns">countPatterns</a>:        Count patterns in sequences.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Vander Heiden JA, Yaari G, et al. pRESTO: a toolkit for processing 
high-throughput sequencing raw reads of lymphocyte receptor repertoires. 
Bioinformatics. 2014 30(13):1930-2.
</p>
</li>
<li><p>  Stern JNH, Yaari G, Vander Heiden JA, et al. B cells populating the multiple 
sclerosis brain mature in the draining cervical lymph nodes. 
Sci Transl Med. 2014 6(248):248ra107.
</p>
</li>
<li><p>  Wu Y-CB, et al. Influence of seasonal exposure to grass pollen on local and 
peripheral blood IgE repertoires in patients with allergic rhinitis. 
J Allergy Clin Immunol. 2014 134(3):604-12.
</p>
</li>
<li><p>  Gupta NT, Vander Heiden JA, et al. Change-O: a toolkit for analyzing 
large-scale B cell immunoglobulin repertoire sequencing data.
Bioinformatics. 2015 Oct 15;31(20):3356-8.
</p>
</li></ol>


<hr>
<h2 id='aliphatic'>Calculates the aliphatic index of amino acid sequences</h2><span id='topic+aliphatic'></span>

<h3>Description</h3>

<p><code>aliphatic</code> calculates the aliphatic index of amino acid sequences using 
the method of Ikai. Non-informative positions are excluded, where non-informative 
is defined as any character in <code>c("X", "-", ".", "*")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliphatic(seq, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliphatic_+3A_seq">seq</code></td>
<td>
<p>vector of strings containing amino acid sequences.</p>
</td></tr>
<tr><td><code id="aliphatic_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code> then divide the aliphatic index of each amino acid 
sequence by the number of informative positions. Non-informative 
position are defined by the presence any character in 
<code>c("X", "-", ".", "*")</code>. If <code>FALSE</code> then return the raw
aliphatic index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the aliphatic indices for the sequence(s).
</p>


<h3>References</h3>


<ol>
<li><p>  Ikai AJ. Thermostability and aliphatic index of globular proteins. 
J Biochem. 88, 1895-1898 (1980).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", NA, "XXTQMYVRT")
aliphatic(seq)

</code></pre>

<hr>
<h2 id='alphaDiversity'>Calculate clonal alpha diversity</h2><span id='topic+alphaDiversity'></span>

<h3>Description</h3>

<p><code>alphaDiversity</code> takes in a data.frame or <a href="#topic+AbundanceCurve">AbundanceCurve</a> and computes
diversity scores (<code class="reqn">D</code>) over an interval of diversity orders (<code class="reqn">q</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaDiversity(data, min_q = 0, max_q = 4, step_q = 0.1, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaDiversity_+3A_data">data</code></td>
<td>
<p>data.frame with Change-O style columns containing clonal assignments or
a <a href="#topic+AbundanceCurve">AbundanceCurve</a> generate by <a href="#topic+estimateAbundance">estimateAbundance</a> object 
containing a previously calculated bootstrap distributions of clonal abundance.</p>
</td></tr>
<tr><td><code id="alphaDiversity_+3A_min_q">min_q</code></td>
<td>
<p>minimum value of <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="alphaDiversity_+3A_max_q">max_q</code></td>
<td>
<p>maximum value of <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="alphaDiversity_+3A_step_q">step_q</code></td>
<td>
<p>value by which to increment <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="alphaDiversity_+3A_ci">ci</code></td>
<td>
<p>confidence interval to calculate; the value must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="alphaDiversity_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <a href="#topic+estimateAbundance">estimateAbundance</a>. Additional arguments
are ignored if a <a href="#topic+AbundanceCurve">AbundanceCurve</a> is provided as input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clonal diversity is calculated using the generalized diversity index (Hill numbers) 
proposed by Hill (Hill, 1973). See <a href="#topic+calcDiversity">calcDiversity</a> for further details.
</p>
<p>To generate a smooth curve, <code class="reqn">D</code> is calculated for each value of <code class="reqn">q</code> from
<code>min_q</code> to <code>max_q</code> incremented by <code>step_q</code>.  When <code>uniform=TRUE</code>
variability in total sequence counts across unique values in the <code>group</code> column 
is corrected by repeated resampling from the estimated complete clonal distribution to a 
common number of sequences. The complete clonal abundance distribution that is resampled 
from is inferred by using the Chao1 estimator to infer the number of unseen clones, 
followed by applying the relative abundance correction and unseen clone frequencies 
described in Chao et al, 2015.
</p>
<p>The diversity index (<code class="reqn">D</code>) for each group is the mean value of over all resampling 
realizations. Confidence intervals are derived using the standard deviation of the 
resampling realizations, as described in Chao et al, 2015.
</p>
<p>Significance of the difference in diversity index (<code>D</code>) between groups is tested by 
constructing a bootstrap delta distribution for each pair of unique values in the 
<code>group</code> column. The bootstrap delta distribution is built by subtracting the diversity 
index <code>Da</code> in group <code>a</code> from the corresponding value <code class="reqn">Db</code> in group <code>b</code>, 
for all bootstrap realizations, yielding a distribution of <code>nboot</code> total deltas; where 
group <code>a</code> is the group with the greater mean <code>D</code>. The p-value for hypothesis 
<code>Da  !=  Db</code> is the value of <code>P(0)</code> from the empirical cumulative distribution 
function of the bootstrap delta distribution, multiplied by 2 for the two-tailed correction.
</p>
<p>Note, this method may inflate statistical significance when clone sizes are uniformly small,
such as when most clones sizes are 1, sample size is small, and <code>max_n</code> is near
the total count of the smallest data group. Use caution when interpreting the results 
in such cases.
</p>


<h3>Value</h3>

<p>A <a href="#topic+DiversityCurve">DiversityCurve</a> object summarizing the diversity scores.
</p>


<h3>References</h3>


<ol>
<li><p>  Hill M. Diversity and evenness: a unifying notation and its consequences. 
Ecology. 1973 54(2):427-32.
</p>
</li>
<li><p>  Chao A. Nonparametric Estimation of the Number of Classes in a Population. 
Scand J Stat. 1984 11, 265270.
</p>
</li>
<li><p>  Chao A, et al. Rarefaction and extrapolation with Hill numbers: 
A framework for sampling and estimation in species diversity studies. 
Ecol Monogr. 2014 84:45-67.
</p>
</li>
<li><p>  Chao A, et al. Unveiling the species-rank abundance distribution by 
generalizing the Good-Turing sample coverage theory. 
Ecology. 2015 96, 11891201.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+calcDiversity">calcDiversity</a> for the basic calculation and 
<a href="#topic+DiversityCurve">DiversityCurve</a> for the return object. 
See <a href="#topic+plotDiversityCurve">plotDiversityCurve</a> for plotting the return object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Group by sample identifier in two steps
abund &lt;- estimateAbundance(ExampleDb, group="sample_id", nboot=100)
div &lt;- alphaDiversity(abund, step_q=1, max_q=10)
plotDiversityCurve(div, legend_title="Sample")
                   
# Grouping by isotype rather than sample identifier in one step
div &lt;- alphaDiversity(ExampleDb, group="c_call", min_n=40, step_q=1, max_q=10, 
                      nboot=100)
plotDiversityCurve(div, legend_title="Isotype")

</code></pre>

<hr>
<h2 id='aminoAcidProperties'>Calculates amino acid chemical properties for sequence data</h2><span id='topic+aminoAcidProperties'></span>

<h3>Description</h3>

<p><code>aminoAcidProperties</code> calculates amino acid sequence physicochemical properties, including
length, hydrophobicity, bulkiness, polarity, aliphatic index, net charge, acidic residue
content, basic residue content, and aromatic residue content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aminoAcidProperties(
  data,
  property = c("length", "gravy", "bulk", "aliphatic", "polarity", "charge", "basic",
    "acidic", "aromatic"),
  seq = "junction",
  nt = TRUE,
  trim = FALSE,
  label = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aminoAcidProperties_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_property">property</code></td>
<td>
<p>vector strings specifying the properties to be calculated. Defaults
to calculating all defined properties.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_seq">seq</code></td>
<td>
<p><code>character</code> name of the column containing input 
sequences.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_nt">nt</code></td>
<td>
<p>boolean, TRUE if the sequences (or sequence) are DNA and will be translated.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_trim">trim</code></td>
<td>
<p>if <code>TRUE</code> remove the first and last codon/amino acids from each
sequence before calculating properties. If <code>FALSE</code> do
not modify input sequences.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_label">label</code></td>
<td>
<p>name of sequence region to add as prefix to output column names.</p>
</td></tr>
<tr><td><code id="aminoAcidProperties_+3A_...">...</code></td>
<td>
<p>additional named arguments to pass to the functions 
<a href="#topic+gravy">gravy</a>, <a href="#topic+bulk">bulk</a>, <a href="#topic+aliphatic">aliphatic</a>, <a href="#topic+polar">polar</a> or <a href="#topic+charge">charge</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all properties except for length, non-informative positions are excluded, 
where non-informative is defined as any character in <code>c("X", "-", ".", "*")</code>.
</p>
<p>The scores for gravy, bulkiness and polarity are calculated as simple averages of the 
scores for each informative positions. The basic, acid and aromatic indices are 
calculated as the fraction of informative positions falling into the given category.
</p>
<p>The aliphatic index is calculated using the Ikai, 1980 method.
</p>
<p>The net charge is calculated using the method of Moore, 1985, excluding the N-terminus and
C-terminus charges, and normalizing by the number of informative positions.  The default 
pH for the calculation is 7.4.
</p>
<p>The following data sources were used for the default property scores:
</p>

<ul>
<li><p>  hydropathy:  Kyte &amp; Doolittle, 1982.  
</p>
</li>
<li><p>  bulkiness:   Zimmerman et al, 1968. 
</p>
</li>
<li><p>  polarity:    Grantham, 1974.
</p>
</li>
<li><p>  pK:          EMBOSS.
</p>
</li></ul>



<h3>Value</h3>

<p>A modified <code>data</code> data.frame with the following columns:
</p>

<ul>
<li>  <p><code>*_aa_length</code>:     number of amino acids.
</p>
</li>
<li>  <p><code>*_aa_gravy</code>:      grand average of hydrophobicity (gravy) index.
</p>
</li>
<li>  <p><code>*_aa_bulk</code>:       average bulkiness of amino acids.
</p>
</li>
<li>  <p><code>*_aa_aliphatic</code>:  aliphatic index.
</p>
</li>
<li>  <p><code>*_aa_polarity</code>:   average polarity of amino acids.
</p>
</li>
<li>  <p><code>*_aa_charge</code>:     net charge.
</p>
</li>
<li>  <p><code>*_aa_basic</code>:      fraction of informative positions that are 
Arg, His or Lys.
</p>
</li>
<li>  <p><code>*_aa_acidic</code>:     fraction of informative positions that are 
Asp or Glu.
</p>
</li>
<li>  <p><code>*_aa_aromatic</code>:   fraction of informative positions that are 
His, Phe, Trp or Tyr.
</p>
</li></ul>

<p>Where <code>*</code> is the value from <code>label</code> or the name specified for 
<code>seq</code> if <code>label=NULL</code>.
</p>


<h3>References</h3>


<ol>
<li><p>  Zimmerman JM, Eliezer N, Simha R. The characterization of amino acid sequences 
in proteins by statistical methods. J Theor Biol 21, 170-201 (1968).
</p>
</li>
<li><p>  Grantham R. Amino acid difference formula to help explain protein evolution. 
Science 185, 862-864 (1974).
</p>
</li>
<li><p>  Ikai AJ. Thermostability and aliphatic index of globular proteins. 
J Biochem 88, 1895-1898 (1980).
</p>
</li>
<li><p>  Kyte J, Doolittle RF. A simple method for displaying the hydropathic character 
of a protein. J Mol Biol 157, 105-32 (1982).
</p>
</li>
<li><p>  Moore DS. Amino acid and peptide net charges: A simple calculational procedure. 
Biochem Educ 13, 10-11 (1985).
</p>
</li>
<li><p>  Wu YC, et al. High-throughput immunoglobulin repertoire analysis distinguishes 
between human IgM memory and switched memory B-cell populations. 
Blood 116, 1070-8 (2010).
</p>
</li>
<li><p>  Wu YC, et al. The relationship between CD27 negative and positive B cell 
populations in human peripheral blood. 
Front Immunol 2, 1-12 (2011).
</p>
</li>
<li>  <p><a href="https://emboss.sourceforge.net/apps/cvs/emboss/apps/iep.html">https://emboss.sourceforge.net/apps/cvs/emboss/apps/iep.html</a>
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+countPatterns">countPatterns</a> for counting the occurance of specific amino acid subsequences.
See <a href="#topic+gravy">gravy</a>, <a href="#topic+bulk">bulk</a>, <a href="#topic+aliphatic">aliphatic</a>, <a href="#topic+polar">polar</a> and <a href="#topic+charge">charge</a> for functions 
that calculate the included properties individually.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data
db &lt;- ExampleDb[c(1,10,100), c("sequence_id", "junction")]

# Calculate default amino acid properties from DNA sequences
aminoAcidProperties(db, seq="junction")
# Calculate default amino acid properties from amino acid sequences
# Use a custom output column prefix
db$junction_aa &lt;- translateDNA(db$junction)
aminoAcidProperties(db, seq="junction_aa", label="junction", nt=FALSE)

# Use the Grantham, 1974 side chain volume scores from the seqinr package
# Set pH=7.0 for the charge calculation
# Calculate only average volume and charge
# Remove the head and tail amino acids from the junction, thus making it the CDR3
library(seqinr)
data(aaindex)
x &lt;- aaindex[["GRAR740103"]]$I
# Rename the score vector to use single-letter codes
names(x) &lt;- translateStrings(names(x), ABBREV_AA)
# Calculate properties
aminoAcidProperties(db, property=c("bulk", "charge"), seq="junction", 
                    trim=TRUE, label="cdr3", bulkiness=x, pH=7.0)

</code></pre>

<hr>
<h2 id='baseTheme'>Standard ggplot settings</h2><span id='topic+baseTheme'></span>

<h3>Description</h3>

<p><code>baseTheme</code> defines common ggplot theme settings for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseTheme(sizing = c("figure", "window"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseTheme_+3A_sizing">sizing</code></td>
<td>
<p>defines the style and sizing of the theme. One of 
<code>c("figure", "window")</code> where <code>sizing="figure"</code> is appropriately
sized for pdf export at 7 to 7.5 inch width, and <code>sizing="window"</code>
is sized for an interactive session.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+theme">theme</a>.
</p>

<hr>
<h2 id='buildPhylipLineage'>Infer an Ig lineage using PHYLIP</h2><span id='topic+buildPhylipLineage'></span>

<h3>Description</h3>

<p><code>buildPhylipLineage</code> reconstructs an Ig lineage via maximum parsimony using the 
dnapars application, or maximum liklihood using the dnaml application of the PHYLIP package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPhylipLineage(
  clone,
  phylip_exec,
  dist_mat = getDNAMatrix(gap = 0),
  rm_temp = FALSE,
  verbose = FALSE,
  temp_path = NULL,
  onetree = FALSE,
  branch_length = c("mutations", "distance")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPhylipLineage_+3A_clone">clone</code></td>
<td>
<p><a href="#topic+ChangeoClone">ChangeoClone</a> object containing clone data.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_phylip_exec">phylip_exec</code></td>
<td>
<p>absolute path to the PHYLIP dnapars executable.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_dist_mat">dist_mat</code></td>
<td>
<p>character distance matrix to use for reassigning edge weights. 
Defaults to a Hamming distance matrix returned by <a href="#topic+getDNAMatrix">getDNAMatrix</a> 
with <code>gap=0</code>. If gap characters, <code>c("-", ".")</code>, are assigned 
a value of -1 in <code>dist_mat</code> then contiguous gaps of any run length,
which are not present in both sequences, will be counted as a 
distance of 1. Meaning, indels of any length will increase
the sequence distance by 1. Gap values other than -1 will 
return a distance that does not consider indels as a special case.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_rm_temp">rm_temp</code></td>
<td>
<p>if <code>TRUE</code> delete the temporary directory after running dnapars;
if <code>FALSE</code> keep the temporary directory.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_verbose">verbose</code></td>
<td>
<p>if <code>FALSE</code> suppress the output of dnapars; 
if <code>TRUE</code> STDOUT and STDERR of dnapars will be passed to 
the console.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_temp_path">temp_path</code></td>
<td>
<p>specific path to temp directory if desired.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_onetree">onetree</code></td>
<td>
<p>if <code>TRUE</code> save only one tree.</p>
</td></tr>
<tr><td><code id="buildPhylipLineage_+3A_branch_length">branch_length</code></td>
<td>
<p>specifies how to define branch lengths; one of <code>"mutations"</code> 
or <code>"distance"</code>. If set to <code>"mutations"</code> (default), then branch 
lengths represent the number of mutations between nodes. 
If set to <code>"distance"</code>, then branch lengths represent
the expected number of mutations per site, unaltered from PHYLIP output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>buildPhylipLineage</code> builds the lineage tree of a set of unique Ig sequences via
maximum parsimony through an external call to the dnapars application of the PHYLIP
package. dnapars is called with default algorithm options, except for the search option, 
which is set to &quot;Rearrange on one best tree&quot;. The germline sequence of the clone is used 
for the outgroup. 
</p>
<p>Following tree construction using dnapars, the dnapars output is modified to allow
input sequences to appear as internal nodes of the tree. Intermediate sequences 
inferred by dnapars are replaced by children within the tree having a Hamming distance 
of zero from their parent node. With the default <code>dist_mat</code>, the distance calculation 
allows IUPAC ambiguous character matches, where an ambiguous character has distance zero 
to any character in the set of characters it represents. Distance calculation and movement of 
child nodes up the tree is repeated until all parent-child pairs have a distance greater than zero 
between them. The germline sequence (outgroup) is moved to the root of the tree and
excluded from the node replacement processes, which permits the trunk of the tree to be
the only edge with a distance of zero. Edge weights of the resultant tree are assigned 
as the distance between each sequence.
</p>


<h3>Value</h3>

<p>An igraph <code>graph</code> object defining the Ig lineage tree. Each unique input 
sequence in <code>clone</code> is a vertex of the tree, with additional vertices being
either the germline (root) sequences or inferred intermediates. The <code>graph</code> 
object has the following attributes.
</p>
<p>Vertex attributes:
</p>

<ul>
<li>  <p><code>name</code>:      value in the <code>sequence_id</code> column of the <code>data</code> 
slot of the input <code>clone</code> for observed sequences. 
The germline (root) vertex is assigned the name 
&quot;Germline&quot; and inferred intermediates are assigned
names with the format &quot;Inferred1&quot;, &quot;Inferred2&quot;, ....
</p>
</li>
<li>  <p><code>sequence</code>:  value in the <code>sequence</code> column of the <code>data</code> 
slot of the input <code>clone</code> for observed sequences.
The germline (root) vertex is assigned the sequence
in the <code>germline</code> slot of the input <code>clone</code>.
The sequence of inferred intermediates are extracted
from the dnapars output.
</p>
</li>
<li>  <p><code>label</code>:     same as the <code>name</code> attribute.
</p>
</li></ul>

<p>Additionally, each other column in the <code>data</code> slot of the input 
<code>clone</code> is added as a vertex attribute with the attribute name set to 
the source column name. For the germline and inferred intermediate vertices,
these additional vertex attributes are all assigned a value of <code>NA</code>.
</p>
<p>Edge attributes:
</p>

<ul>
<li>  <p><code>weight</code>:    Hamming distance between the <code>sequence</code> attributes
of the two vertices.
</p>
</li>
<li>  <p><code>label</code>:     same as the <code>weight</code> attribute.
</p>
</li></ul>

<p>Graph attributes:
</p>

<ul>
<li>  <p><code>clone</code>:     clone identifier from the <code>clone</code> slot of the
input <code>ChangeoClone</code>.
</p>
</li>
<li>  <p><code>v_gene</code>:    V-segment gene call from the <code>v_gene</code> slot of 
the input <code>ChangeoClone</code>.
</p>
</li>
<li>  <p><code>j_gene</code>:    J-segment gene call from the <code>j_gene</code> slot of 
the input <code>ChangeoClone</code>.
</p>
</li>
<li>  <p><code>junc_len</code>:  junction length (nucleotide count) from the 
<code>junc_len</code> slot of the input <code>ChangeoClone</code>.
</p>
<p>Alternatively, this function will return an <code>phylo</code> object, which is compatible
with the ape package. This object will contain reconstructed ancestral sequences in
<code>nodes</code> attribute.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Felsenstein J. PHYLIP - Phylogeny Inference Package (Version 3.2). 
Cladistics. 1989 5:164-166.
</p>
</li>
<li><p>  Stern JNH, Yaari G, Vander Heiden JA, et al. B cells populating the multiple 
sclerosis brain mature in the draining cervical lymph nodes. 
Sci Transl Med. 2014 6(248):248ra107.
</p>
</li></ol>



<h3>See Also</h3>

<p>Takes as input a <a href="#topic+ChangeoClone">ChangeoClone</a>. 
Temporary directories are created with <a href="#topic+makeTempDir">makeTempDir</a>.
Distance is calculated using <a href="#topic+seqDist">seqDist</a>. 
See [igraph](http://www.rdocumentation.org/packages/igraph/topics/aaa-igraph-package) 
and [igraph.plotting](http://www.rdocumentation.org/packages/igraph/topics/plot.common) 
for working  with igraph <code>graph</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preprocess clone
db &lt;- subset(ExampleDb, clone_id == 3138)
clone &lt;- makeChangeoClone(db, text_fields=c("sample_id", "c_call"), 
                          num_fields="duplicate_count")

# Run PHYLIP and process output
phylip_exec &lt;- "~/apps/phylip-3.695/bin/dnapars"
graph &lt;- buildPhylipLineage(clone, phylip_exec, rm_temp=TRUE)

# Plot graph with a tree layout
library(igraph)
plot(graph, layout=layout_as_tree, vertex.label=V(graph)$c_call, 
     vertex.size=50, edge.arrow.mode=0, vertex.color="grey80")

# To consider each indel event as a mutation, change the masking character 
# and distance matrix
clone &lt;- makeChangeoClone(db, text_fields=c("sample_id", "c_call"), 
                          num_fields="duplicate_count", mask_char="-")
graph &lt;- buildPhylipLineage(clone, phylip_exec, dist_mat=getDNAMatrix(gap=-1), 
                            rm_temp=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bulk'>Calculates the average bulkiness of amino acid sequences</h2><span id='topic+bulk'></span>

<h3>Description</h3>

<p><code>bulk</code> calculates the average bulkiness score of amino acid sequences. 
Non-informative positions are excluded, where non-informative is defined as any 
character in <code>c("X", "-", ".", "*")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulk(seq, bulkiness = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulk_+3A_seq">seq</code></td>
<td>
<p>vector of strings containing amino acid sequences.</p>
</td></tr>
<tr><td><code id="bulk_+3A_bulkiness">bulkiness</code></td>
<td>
<p>named numerical vector defining bulkiness scores for 
each amino acid, where names are single-letter amino acid 
character codes. If <code>NULL</code>, then the Zimmerman et al, 1968
scale is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of bulkiness scores for the sequence(s).
</p>


<h3>References</h3>


<ol>
<li><p>  Zimmerman JM, Eliezer N, Simha R. The characterization of amino acid sequences 
in proteins by statistical methods. J Theor Biol 21, 170-201 (1968).
</p>
</li></ol>



<h3>See Also</h3>

<p>For additional size related indices see <a href="seqinr.html#topic+aaindex">aaindex</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default bulkiness scale
seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", "XXTQMYVRT")
bulk(seq)

# Use the Grantham, 1974 side chain volumn scores from the seqinr package
library(seqinr)
data(aaindex)
x &lt;- aaindex[["GRAR740103"]]$I
# Rename the score vector to use single-letter codes
names(x) &lt;- translateStrings(names(x), ABBREV_AA)
# Calculate average volume
bulk(seq, bulkiness=x)

</code></pre>

<hr>
<h2 id='calcCoverage'>Calculate sample coverage</h2><span id='topic+calcCoverage'></span>

<h3>Description</h3>

<p><code>calcCoverage</code> calculates the sample coverage estimate, a measure of sample 
completeness, for varying orders using the method of Chao et al, 2015, falling back 
to the Chao1 method in the first order case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcCoverage(x, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcCoverage_+3A_x">x</code></td>
<td>
<p>numeric vector of abundance counts.</p>
</td></tr>
<tr><td><code id="calcCoverage_+3A_r">r</code></td>
<td>
<p>coverage order to calculate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sample coverage of the given order <code>r</code>.
</p>


<h3>References</h3>


<ol>
<li><p>  Chao A. Nonparametric Estimation of the Number of Classes in a Population. 
Scand J Stat. 1984 11, 265270.
</p>
</li>
<li><p>  Chao A, et al. Unveiling the species-rank abundance distribution by 
generalizing the Good-Turing sample coverage theory. 
Ecology. 2015 96, 11891201.
</p>
</li></ol>



<h3>See Also</h3>

<p>Used by <a href="#topic+alphaDiversity">alphaDiversity</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate clone sizes
clones &lt;- countClones(ExampleDb, groups="sample_id")

# Calculate 1first order coverage for a single sample
calcCoverage(clones$seq_count[clones$sample_id == "+7d"])

</code></pre>

<hr>
<h2 id='calcDiversity'>Calculate the diversity index</h2><span id='topic+calcDiversity'></span>

<h3>Description</h3>

<p><code>calcDiversity</code> calculates the clonal diversity index for a vector of diversity 
orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDiversity(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDiversity_+3A_p">p</code></td>
<td>
<p>numeric vector of clone (species) counts or proportions.</p>
</td></tr>
<tr><td><code id="calcDiversity_+3A_q">q</code></td>
<td>
<p>numeric vector of diversity orders.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method, proposed by Hill (Hill, 1973), quantifies diversity as a smooth function 
(<code class="reqn">D</code>) of a single parameter <code class="reqn">q</code>. Special cases of the generalized diversity 
index correspond to the most popular diversity measures in ecology: species richness 
(<code class="reqn">q = 0</code>), the exponential of the Shannon-Weiner index (<code class="reqn">q</code> approaches <code class="reqn">1</code>), the 
inverse of the Simpson index (<code class="reqn">q = 2</code>), and the reciprocal abundance of the largest 
clone (<code class="reqn">q</code> approaches <code class="reqn">+\infty</code>). At <code class="reqn">q = 0</code> different clones weight equally, 
regardless of their size. As the parameter <code class="reqn">q</code> increase from <code class="reqn">0</code> to <code class="reqn">+\infty</code> 
the diversity index (<code class="reqn">D</code>) depends less on rare clones and more on common (abundant) 
ones, thus encompassing a range of definitions that can be visualized as a single curve. 
</p>
<p>Values of <code class="reqn">q &lt; 0</code> are valid, but are generally not meaningful. The value of <code class="reqn">D</code> 
at <code class="reqn">q=1</code> is estimated by <code class="reqn">D</code> at <code class="reqn">q=0.9999</code>.
</p>


<h3>Value</h3>

<p>A vector of diversity scores <code class="reqn">D</code> for each <code class="reqn">q</code>.
</p>


<h3>References</h3>


<ol>
<li><p>  Hill M. Diversity and evenness: a unifying notation and its consequences. 
Ecology. 1973 54(2):427-32.
</p>
</li></ol>



<h3>See Also</h3>

<p>Used by <a href="#topic+alphaDiversity">alphaDiversity</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># May define p as clonal member counts
p &lt;- c(1, 1, 3, 10)
q &lt;- c(0, 1, 2)
calcDiversity(p, q)

# Or proportional abundance
p &lt;- c(1/15, 1/15, 1/5, 2/3)
calcDiversity(p, q)

</code></pre>

<hr>
<h2 id='ChangeoClone-class'>S4 class defining a clone</h2><span id='topic+ChangeoClone-class'></span><span id='topic+ChangeoClone'></span>

<h3>Description</h3>

<p><code>ChangeoClone</code> defines a common data structure for perform lineage recontruction
from Change-O data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>data.frame containing sequences and annotations. Contains the
columns <code>SEQUENCE_ID</code> and <code>SEQUENCE</code>, as well as any additional 
sequence-specific annotation columns.</p>
</dd>
<dt><code>clone</code></dt><dd><p>string defining the clone identifier.</p>
</dd>
<dt><code>germline</code></dt><dd><p>string containing the germline sequence for the clone.</p>
</dd>
<dt><code>v_gene</code></dt><dd><p>string defining the V segment gene call.</p>
</dd>
<dt><code>j_gene</code></dt><dd><p>string defining the J segment gene call.</p>
</dd>
<dt><code>junc_len</code></dt><dd><p>numeric junction length (nucleotide count).</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+makeChangeoClone">makeChangeoClone</a> and <a href="#topic+buildPhylipLineage">buildPhylipLineage</a> for use.
</p>

<hr>
<h2 id='charge'>Calculates the net charge of amino acid sequences.</h2><span id='topic+charge'></span>

<h3>Description</h3>

<p><code>charge</code> calculates the net charge of amino acid sequences using 
the method of Moore, 1985, with exclusion of the C-terminus and N-terminus charges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charge(seq, pH = 7.4, pK = NULL, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charge_+3A_seq">seq</code></td>
<td>
<p>vector strings defining of amino acid sequences.</p>
</td></tr>
<tr><td><code id="charge_+3A_ph">pH</code></td>
<td>
<p>environmental pH.</p>
</td></tr>
<tr><td><code id="charge_+3A_pk">pK</code></td>
<td>
<p>named vector defining pK values for each charged amino acid,
where names are the single-letter amino acid character codes
<code>c("R", "H", "K", "D", "E", "C", "Y")</code>). If <code>NULL</code>, 
then the EMBOSS scale is used.</p>
</td></tr>
<tr><td><code id="charge_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code> then divide the net charge of each amino acid 
sequence by the number of informative positions. Non-informative 
position are defined by the presence any character in 
<code>c("X", "-", ".", "*")</code>. If <code>FALSE</code> then return the raw
net charge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of net charges for the sequence(s).
</p>


<h3>References</h3>


<ol>
<li><p>  Moore DS. Amino acid and peptide net charges: A simple calculational procedure. 
Biochem Educ. 13, 10-11 (1985).
</p>
</li>
<li>  <p><a href="https://emboss.sourceforge.net/apps/cvs/emboss/apps/iep.html">https://emboss.sourceforge.net/apps/cvs/emboss/apps/iep.html</a>
</p>
</li></ol>



<h3>See Also</h3>

<p>For additional pK scales see <code><a href="seqinr.html#topic+pK">pK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", "XXTQMYVRT") 
# Unnormalized charge
charge(seq)
# Normalized charge
charge(seq, normalize=TRUE)

# Use the Murray et al, 2006 scores from the seqinr package
library(seqinr)
data(pK)
x &lt;- setNames(pK[["Murray"]], rownames(pK))
# Calculate charge
charge(seq, pK=x)

</code></pre>

<hr>
<h2 id='checkColumns'>Check data.frame for valid columns and issue message if invalid</h2><span id='topic+checkColumns'></span>

<h3>Description</h3>

<p>Check data.frame for valid columns and issue message if invalid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkColumns(data, columns, logic = c("all", "any"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkColumns_+3A_data">data</code></td>
<td>
<p>data.frame to check.</p>
</td></tr>
<tr><td><code id="checkColumns_+3A_columns">columns</code></td>
<td>
<p>vector of column names to check.</p>
</td></tr>
<tr><td><code id="checkColumns_+3A_logic">logic</code></td>
<td>
<p>one of <code>"all"</code> or <code>"any"</code> controlling whether all,
or at least one, of the columns must be valid, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if columns are valid and a string message if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(A=1:3, B=4:6, C=rep(NA, 3))
checkColumns(df, c("A", "B"), logic="all")
checkColumns(df, c("A", "B"), logic="any")
checkColumns(df, c("A", "C"), logic="all")
checkColumns(df, c("A", "C"), logic="any")
checkColumns(df, c("A", "D"), logic="all")
checkColumns(df, c("A", "D"), logic="any")

</code></pre>

<hr>
<h2 id='collapseDuplicates'>Remove duplicate DNA sequences and combine annotations</h2><span id='topic+collapseDuplicates'></span>

<h3>Description</h3>

<p><code>collapseDuplicates</code> identifies duplicate DNA sequences, allowing for ambiguous 
characters, removes the duplicate entries, and combines any associated annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseDuplicates(
  data,
  id = "sequence_id",
  seq = "sequence_alignment",
  text_fields = NULL,
  num_fields = NULL,
  seq_fields = NULL,
  add_count = FALSE,
  ignore = c("N", "-", ".", "?"),
  sep = ",",
  dry = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseDuplicates_+3A_data">data</code></td>
<td>
<p>data.frame containing Change-O columns. The data.frame 
must contain, at a minimum, a unique identifier column 
and a column containg a character vector of DNA sequences.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_seq">seq</code></td>
<td>
<p>name of the column containing DNA sequences.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_text_fields">text_fields</code></td>
<td>
<p>character vector of textual columns to collapse. The textual 
annotations of duplicate sequences will be merged into a single 
string with each unique value alphabetized and delimited by 
<code>sep</code>.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_num_fields">num_fields</code></td>
<td>
<p>vector of numeric columns to collapse. The numeric annotations
of duplicate sequences will be summed.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_seq_fields">seq_fields</code></td>
<td>
<p>vector of nucletoide sequence columns to collapse. The sequence 
with the fewest numer of non-informative characters will be 
retained. Where a non-informative character is one of 
<code>c("N", "-", ".", "?")</code>. Note, this is distinct from the 
<code>seq</code> parameter which is used to determine duplicates.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_add_count">add_count</code></td>
<td>
<p>if <code>TRUE</code> add the column <code>collpase_count</code> that 
indicates the number of sequences that were collapsed to build 
each unique entry.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_ignore">ignore</code></td>
<td>
<p>vector of characters to ignore when testing for equality.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_sep">sep</code></td>
<td>
<p>character to use for delimiting collapsed annotations in the 
<code>text_fields</code> columns. Defines both the input and output 
delimiter.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_dry">dry</code></td>
<td>
<p>if <code>TRUE</code> perform dry run. Only labels the sequences without 
collapsing them.</p>
</td></tr>
<tr><td><code id="collapseDuplicates_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> report the number input, discarded and output 
sequences; if <code>FALSE</code> process sequences silently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collapseDuplicates</code> identifies duplicate sequences in the <code>seq</code> column by
testing for character identity, with consideration of IUPAC ambiguous nucleotide codes. 
A cluster of sequences are considered duplicates if they are all equivalent, and no 
member of the cluster is equivalent to a sequence in a different cluster. 
</p>
<p>Textual annotations, specified by <code>text_fields</code>, are collapsed by taking the unique
set of values within in each duplicate cluster and delimiting those values by <code>sep</code>.
Numeric annotations, specified by <code>num_fields</code>, are collapsed by summing all values 
in the duplicate cluster. Sequence annotations, specified by <code>seq_fields</code>, are 
collapsed by retaining the first sequence with the fewest number of N characters.
</p>
<p>Columns that are not specified in either <code>text_fields</code>, <code>num_fields</code>, or 
<code>seq_fields</code> will be retained, but the value will be chosen from a random entry 
amongst all sequences in a cluster of duplicates.
</p>
<p>An ambiguous sequence is one that can be assigned to two different clusters, wherein
the ambiguous sequence is equivalent to two sequences which are themselves 
non-equivalent. Ambiguous sequences arise due to ambiguous characters at positions that
vary across sequences, and are discarded along with their annotations when <code>dry=FALSE</code>. 
Thus, ambiguous sequences are removed as duplicates of some sequence, but do not create a potential
false-positive annotation merger. Ambiguous sequences are not included in the 
<code>collapse_count</code> annotation that is added when <code>add_count=TRUE</code>.
</p>
<p>If <code>dry=TRUE</code> sequences will not be removed from the input. Instead, the following columns
will be appended to the input defining the collapse action that would have been performed in the
<code>dry=FALSE</code> case.
</p>

<ul>
<li>  <p><code>collapse_id</code>:     an identifer for the group of identical sequences.
</p>
</li>
<li>  <p><code>collapse_class</code>:  string defining how the sequence matches to the other in the set.
one of <code>"duplicated"</code> (has duplicates),
<code>"unique"</code> (no duplicates), <code>"ambiguous_duplicate"</code> 
(no duplicates after ambiguous sequences are removed), 
or <code>"ambiguous"</code> (matches multiple non-duplicate sequences).
</p>
</li>
<li>  <p><code>collapse_pass</code>:   <code>TRUE</code> for the sequences that would be retained.
</p>
</li></ul>



<h3>Value</h3>

<p>A modified <code>data</code> data.frame with duplicate sequences removed and 
annotation fields collapsed if <code>dry=FALSE</code>. If <code>dry=TRUE</code>, 
sequences will be labeled with the collapse action, but the input will be
otherwise unmodifed (see Details).
</p>


<h3>See Also</h3>

<p>Equality is tested with <a href="#topic+seqEqual">seqEqual</a> and <a href="#topic+pairwiseEqual">pairwiseEqual</a>. 
For IUPAC ambiguous character codes see <a href="#topic+IUPAC_DNA">IUPAC_DNA</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data.frame
db &lt;- data.frame(sequence_id=LETTERS[1:4],
                 sequence_alignment=c("CCCCTGGG", "CCCCTGGN", "NAACTGGN", "NNNCTGNN"),
                 c_call=c("IGHM", "IGHG", "IGHG", "IGHA"),
                 sample_id=c("S1", "S1", "S2", "S2"),
                 duplicate_count=1:4,
                 stringsAsFactors=FALSE)

# Annotations are not parsed if neither text_fields nor num_fields is specified
# The retained sequence annotations will be random
collapseDuplicates(db, verbose=TRUE)

# Unique text_fields annotations are combined into a single string with ","
# num_fields annotations are summed
# Ambiguous duplicates are discarded
collapseDuplicates(db, text_fields=c("c_call", "sample_id"), num_fields="duplicate_count", 
                   verbose=TRUE)

# Use alternate delimiter for collapsing textual annotations
collapseDuplicates(db, text_fields=c("c_call", "sample_id"), num_fields="duplicate_count", 
                   sep="/", verbose=TRUE)

# Add count of duplicates
collapseDuplicates(db, text_fields=c("c_call", "sample_id"), num_fields="duplicate_count", 
                   add_count=TRUE, verbose=TRUE)

# Masking ragged ends may impact duplicate removal
db$sequence_alignment &lt;- maskSeqEnds(db$sequence_alignment)
collapseDuplicates(db, text_fields=c("c_call", "sample_id"), num_fields="duplicate_count", 
                   add_count=TRUE, verbose=TRUE)

</code></pre>

<hr>
<h2 id='combineIgphyml'>Combine IgPhyML object parameters into a dataframe</h2><span id='topic+combineIgphyml'></span>

<h3>Description</h3>

<p><code>combineIgphyml</code> combines IgPhyML object parameters into a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineIgphyml(iglist, format = c("wide", "long"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineIgphyml_+3A_iglist">iglist</code></td>
<td>
<p>list of igphyml objects returned by <a href="#topic+readIgphyml">readIgphyml</a>. 
Each must have an <code>id</code> column in its <code>param</code> attribute, 
which can be added automatically using the <code>id</code> option of 
<code>readIgphyml</code>.</p>
</td></tr>
<tr><td><code id="combineIgphyml_+3A_format">format</code></td>
<td>
<p>string specifying whether each column of the resulting data.frame
should represent a parameter (<code>wide</code>) or if 
there should only be three columns; i.e. id, varable, and value
(<code>long</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>combineIgphyml</code> combines repertoire-wide parameter estimates from mutliple igphyml
objects produced by readIgphyml into a dataframe that can be easily used for plotting and 
other hypothesis testing analyses.
</p>
<p>All igphyml objects used must have an &quot;id&quot; column in their <code>param</code> attribute, which
can be added automatically from the <code>id</code> flag of <code>readIgphyml</code>.
</p>


<h3>Value</h3>

<p>A data.frame containing HLP model parameter estimates for all igphyml objects.
Only parameters shared among all objects will be returned.
</p>


<h3>References</h3>


<ol>
<li><p>  Hoehn KB, Lunter G, Pybus OG - A Phylogenetic Codon Substitution Model for Antibody 
Lineages. Genetics 2017 206(1):417-427
https://doi.org/10.1534/genetics.116.196303 
</p>
</li>
<li><p>  Hoehn KB, Vander Heiden JA, Zhou JQ, Lunter G, Pybus OG, Kleinstein SHK - 
Repertoire-wide phylogenetic models of B cell molecular evolution reveal 
evolutionary signatures of aging and vaccination. bioRxiv 2019  
https://doi.org/10.1101/558825 
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+readIgphyml">readIgphyml</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Read in and combine two igphyml runs
   s1 &lt;- readIgphyml("IB+7d_lineages_gy.tsv_igphyml_stats_hlp.tab", id="+7d")
   s2 &lt;- readIgphyml("IB+7d_lineages_gy.tsv_igphyml_stats_hlp.tab", id="s2")
   combineIgphyml(list(s1, s2))

## End(Not run)

</code></pre>

<hr>
<h2 id='countClones'>Tabulates clones sizes</h2><span id='topic+countClones'></span>

<h3>Description</h3>

<p><code>countClones</code> determines the number of sequences and total copy number of 
clonal groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countClones(
  data,
  groups = NULL,
  copy = NULL,
  clone = "clone_id",
  remove_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countClones_+3A_data">data</code></td>
<td>
<p>data.frame with columns containing clonal assignments.</p>
</td></tr>
<tr><td><code id="countClones_+3A_groups">groups</code></td>
<td>
<p>character vector defining <code>data</code> columns containing grouping 
variables. If <code>groups=NULL</code>, then do not group data.</p>
</td></tr>
<tr><td><code id="countClones_+3A_copy">copy</code></td>
<td>
<p>name of the <code>data</code> column containing copy numbers for each 
sequence. If this value is specified, then total copy abundance
is determined by the sum of copy numbers within each clonal group.</p>
</td></tr>
<tr><td><code id="countClones_+3A_clone">clone</code></td>
<td>
<p>name of the <code>data</code> column containing clone identifiers.</p>
</td></tr>
<tr><td><code id="countClones_+3A_remove_na">remove_na</code></td>
<td>
<p>removes rows with <code>NA</code> values in the clone column if <code>TRUE</code> and issues a warning. 
Otherwise, keeps those rows and considers <code>NA</code> as a clone in the final counts 
and relative abundances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame summarizing clone counts and frequencies with columns:
</p>

<ul>
<li> <p><code>clone_id</code>:    clone identifier. This is the default column
name, specified with <code>clone='clone_id'</code>.
If the function call uses Change-O 
formatted data and <code>clone='CLONE'</code>, this
column will have name <code>CLONE</code>.
</p>
</li>
<li> <p><code>seq_count</code>:   total number of sequences for the clone.
</p>
</li>
<li> <p><code>seq_freq</code>:    frequency of the clone as a fraction of the total
number of sequences within each group.
</p>
</li>
<li> <p><code>copy_count</code>:  sum of the copy counts in the <code>copy</code> column.
Only present if the <code>copy</code> argument is 
specified.
</p>
</li>
<li> <p><code>copy_freq</code>:   frequency of the clone as a fraction of the total
copy number within each group. Only present if 
the <code>copy</code> argument is specified.
</p>
</li></ul>

<p>Also includes additional columns specified in the <code>groups</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without copy numbers
clones &lt;- countClones(ExampleDb, groups="sample_id")

# With copy numbers and multiple groups
clones &lt;- countClones(ExampleDb, groups=c("sample_id", "c_call"), copy="duplicate_count")

</code></pre>

<hr>
<h2 id='countGenes'>Tabulates V(D)J allele, gene or family usage.</h2><span id='topic+countGenes'></span>

<h3>Description</h3>

<p>Determines the count and relative abundance of V(D)J alleles, genes or families within
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countGenes(
  data,
  gene,
  groups = NULL,
  copy = NULL,
  clone = NULL,
  fill = FALSE,
  mode = c("gene", "allele", "family", "asis"),
  remove_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countGenes_+3A_data">data</code></td>
<td>
<p>data.frame with AIRR-format or Change-O style columns.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_gene">gene</code></td>
<td>
<p>column containing allele assignments. Only the first allele in the
column will be considered when <code>mode</code> is &quot;gene&quot;, &quot;family&quot; or 
&quot;allele&quot;. The value will be used as it is with <code>mode="asis"</code>.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_groups">groups</code></td>
<td>
<p>columns containing grouping variables. If <code>NULL</code> do not group.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_copy">copy</code></td>
<td>
<p>name of the <code>data</code> column containing copy numbers for each 
sequence. If this value is specified, then total copy abundance
is determined by the sum of copy numbers within each gene.
This argument is ignored if <code>clone</code> is specified.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_clone">clone</code></td>
<td>
<p>name of the <code>data</code> column containing clone identifiers for each 
sequence. If this value is specified, then one gene will be considered 
for each clone. Note, this is accomplished by using the most 
common gene within each <code>clone</code> identifier. As such,
ambiguous alleles within a clone will not be accurately represented.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_fill">fill</code></td>
<td>
<p>logical of <code>c(TRUE, FALSE)</code> specifying when if groups (when specified)
lacking a particular gene should be counted as 0 if TRUE or not (omitted)</p>
</td></tr>
<tr><td><code id="countGenes_+3A_mode">mode</code></td>
<td>
<p>one of <code>c("gene", "family", "allele", "asis")</code> defining
the degree of specificity regarding allele calls. Determines whether 
to return counts for genes (calling <code>getGene</code>), 
families (calling <code>getFamily</code>), alleles (calling 
<code>getAllele</code>) or using the value as it is in the column
<code>gene</code>, without any processing.</p>
</td></tr>
<tr><td><code id="countGenes_+3A_remove_na">remove_na</code></td>
<td>
<p>removes rows with <code>NA</code> values in the gene column if <code>TRUE</code> and issues a warning. 
Otherwise, keeps those rows and considers <code>NA</code> as a gene in the final counts 
and relative abundances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame summarizing family, gene or allele counts and frequencies 
with columns:
</p>

<ul>
<li> <p><code>gene</code>:         name of the family, gene or allele.
</p>
</li>
<li> <p><code>seq_count</code>:    total number of sequences for the gene.
</p>
</li>
<li> <p><code>seq_freq</code>:     frequency of the gene as a fraction of the total
number of sequences within each grouping.
</p>
</li>
<li> <p><code>copy_count</code>:   sum of the copy counts in the <code>copy</code> column.
for each gene. Only present if the <code>copy</code> 
argument is specified.
</p>
</li>
<li> <p><code>copy_freq</code>:    frequency of the gene as a fraction of the total
copy number within each group. Only present if 
the <code>copy</code> argument is specified.
</p>
</li>
<li> <p><code>clone_count</code>:  total number of clones for the gene. Only present if 
the <code>clone</code> argument is specified.
</p>
</li>
<li> <p><code>clone_freq</code>:   frequency of the gene as a fraction of the total
number of clones within each grouping. Only present if 
the <code>clone</code> argument is specified.
</p>
</li></ul>

<p>Additional columns defined by the <code>groups</code> argument will also be present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without copy numbers
genes &lt;- countGenes(ExampleDb, gene="v_call", groups="sample_id", mode="family")
genes &lt;- countGenes(ExampleDb, gene="v_call", groups="sample_id", mode="gene")
genes &lt;- countGenes(ExampleDb, gene="v_call", groups="sample_id", mode="allele")

# With copy numbers and multiple groups
genes &lt;- countGenes(ExampleDb, gene="v_call", groups=c("sample_id", "c_call"), 
                    copy="duplicate_count", mode="family")

# Count by clone
genes &lt;- countGenes(ExampleDb, gene="v_call", groups=c("sample_id", "c_call"), 
                    clone="clone_id", mode="family")

# Count absent genes 
genes &lt;- countGenes(ExampleDb, gene="v_call", groups="sample_id", 
                    mode="allele", fill=TRUE)

</code></pre>

<hr>
<h2 id='countPatterns'>Count sequence patterns</h2><span id='topic+countPatterns'></span>

<h3>Description</h3>

<p><code>countPatterns</code> counts the fraction of times a set of character patterns occur 
in a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPatterns(seq, patterns, nt = TRUE, trim = FALSE, label = "region")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countPatterns_+3A_seq">seq</code></td>
<td>
<p>character vector of either DNA or amino acid sequences.</p>
</td></tr>
<tr><td><code id="countPatterns_+3A_patterns">patterns</code></td>
<td>
<p>list of sequence patterns to count in each sequence. If the 
list is named, then names will be assigned as the column names of 
output data.frame.</p>
</td></tr>
<tr><td><code id="countPatterns_+3A_nt">nt</code></td>
<td>
<p>if <code>TRUE</code> then <code>seq</code> are DNA sequences and and will be 
translated before performing the pattern search.</p>
</td></tr>
<tr><td><code id="countPatterns_+3A_trim">trim</code></td>
<td>
<p>if <code>TRUE</code> remove the first and last codon or amino acid from 
each sequence before the pattern search. If <code>FALSE</code> do
not modify the input sequences.</p>
</td></tr>
<tr><td><code id="countPatterns_+3A_label">label</code></td>
<td>
<p>string defining a label to add as a prefix to the output 
column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the fraction of times each sequence pattern was 
found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- c("TGTCAACAGGCTAACAGTTTCCGGACGTTC",
         "TGTCAGCAATATTATATTGCTCCCTTCACTTTC",
         "TGTCAAAAGTATAACAGTGCCCCCTGGACGTTC")
patterns &lt;- c("A", "V", "[LI]")
names(patterns) &lt;- c("arg", "val", "iso_leu")
countPatterns(seq, patterns, nt=TRUE, trim=TRUE, label="cdr3")
            
</code></pre>

<hr>
<h2 id='cpuCount'>Available CPU cores</h2><span id='topic+cpuCount'></span>

<h3>Description</h3>

<p><code>cpuCount</code> determines the number of CPU cores available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpuCount()
</code></pre>


<h3>Value</h3>

<p>Count of available cores. Returns 1 if undeterminable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cpuCount()

</code></pre>

<hr>
<h2 id='DEFAULT_COLORS'>Default colors</h2><span id='topic+DEFAULT_COLORS'></span><span id='topic+DNA_COLORS'></span><span id='topic+IG_COLORS'></span><span id='topic+TR_COLORS'></span>

<h3>Description</h3>

<p>Default color palettes for DNA characters, Ig isotypes, and TCR chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNA_COLORS

IG_COLORS

TR_COLORS
</code></pre>


<h3>Format</h3>

<p>Named character vectors with hexcode colors as values.
</p>

<ul>
<li>  <p><code>DNA_COLORS</code>:  DNA character colors 
<code>c("A", "C", "G", "T")</code>.
</p>
</li>
<li>  <p><code>IG_COLORS</code>:   Ig isotype colors 
<code>c("IGHA", "IGHD", "IGHE", "IGHG", "IGHM", "IGHK", "IGHL")</code>.
</p>
</li>
<li>  <p><code>TR_COLORS</code>:   TCR chain colors 
<code>c("TRA", "TRB", "TRD", "TRG")</code>.
</p>
</li></ul>

<p>An object of class <code>character</code> of length 4.
</p>
<p>An object of class <code>character</code> of length 7.
</p>
<p>An object of class <code>character</code> of length 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># IG_COLORS as an isotype color set for ggplot
isotype &lt;- c("IGHG", "IGHM", "IGHM", "IGHA")
db &lt;- data.frame(x=1:4, y=1:4, iso=isotype)
g1 &lt;- ggplot(db, aes(x=x, y=y, color=iso)) + 
    scale_color_manual(name="Isotype", values=IG_COLORS) +
    geom_point(size=10)
plot(g1)

# DNA_COLORS to translate nucleotide values to a vector of colors 
# for use in base graphics plots
seq &lt;- c("A", "T", "T", "C")
colors &lt;- translateStrings(seq, setNames(names(DNA_COLORS), DNA_COLORS))
plot(1:4, 1:4, col=colors, pch=16, cex=6)

</code></pre>

<hr>
<h2 id='DiversityCurve-class'>S4 class defining a diversity curve</h2><span id='topic+DiversityCurve-class'></span><span id='topic+DiversityCurve'></span><span id='topic+print+2CDiversityCurve-method'></span><span id='topic+DiversityCurve-method'></span><span id='topic+plot+2CDiversityCurve+2Cmissing-method'></span><span id='topic+plot+2CDiversityCurve+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>DiversityCurve</code> defines diversity (<code class="reqn">D</code>) scores over multiple diversity 
orders (<code class="reqn">Q</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DiversityCurve'
print(x)

## S4 method for signature 'DiversityCurve,missing'
plot(x, y, ...)

## S4 method for signature 'DiversityCurve,numeric'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiversityCurve-class_+3A_x">x</code></td>
<td>
<p>DiversityCurve object</p>
</td></tr>
<tr><td><code id="DiversityCurve-class_+3A_y">y</code></td>
<td>
<p>diversity order to plot (q).</p>
</td></tr>
<tr><td><code id="DiversityCurve-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotDiversityCurve">plotDiversityCurve</a> or <a href="#topic+plotDiversityTest">plotDiversityTest</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>diversity</code></dt><dd><p>data.frame defining the diversity curve with the following columns:
</p>

<ul>
<li>  <p><code>group</code>:    group label.
</p>
</li>
<li>  <p><code>q</code>:        diversity order.
</p>
</li>
<li>  <p><code>d</code>:        mean diversity index over all bootstrap 
realizations.
</p>
</li>
<li>  <p><code>d_sd</code>:     standard deviation of the diversity index 
over all bootstrap realizations.
</p>
</li>
<li>  <p><code>d_lower</code>:  diversity lower confidence inverval bound.
</p>
</li>
<li>  <p><code>d_upper</code>:  diversity upper confidence interval bound.
</p>
</li>
<li>  <p><code>e</code>:        evenness index calculated as <code>D</code> 
divided by <code>D</code> at <code>Q=0</code>.
</p>
</li>
<li>  <p><code>e_lower</code>:  evenness lower confidence inverval bound.
</p>
</li>
<li>  <p><code>e_upper</code>:  eveness upper confidence interval bound.
</p>
</li></ul>
</dd>
<dt><code>tests</code></dt><dd><p>data.frame describing the significance test results with columns:
</p>

<ul>
<li>  <p><code>test</code>:        string listing the two groups tested.
</p>
</li>
<li>  <p><code>delta_mean</code>:  mean of the <code class="reqn">D</code> bootstrap delta 
distribution for the test.
</p>
</li>
<li>  <p><code>delta_sd</code>:    standard deviation of the <code class="reqn">D</code> 
bootstrap delta distribution for the test.
</p>
</li>
<li>  <p><code>pvalue</code>:      p-value for the test.
</p>
</li></ul>
</dd>
<dt><code>group_by</code></dt><dd><p>string specifying the name of the grouping column in diversity calculation.</p>
</dd>
<dt><code>groups</code></dt><dd><p>vector specifying the names of unique groups in group column in diversity calculation.</p>
</dd>
<dt><code>method</code></dt><dd><p>string specifying the type of diversity calculated.</p>
</dd>
<dt><code>q</code></dt><dd><p>vector of diversity hill diversity indices used for computing diversity.</p>
</dd>
<dt><code>n</code></dt><dd><p>numeric vector indication the number of sequences sampled in each group.</p>
</dd>
<dt><code>ci</code></dt><dd><p>confidence interval defining the upper and lower bounds 
(a value between 0 and 1).</p>
</dd>
</dl>

<hr>
<h2 id='EdgeTest-class'>S4 class defining edge significance</h2><span id='topic+EdgeTest-class'></span><span id='topic+EdgeTest'></span><span id='topic+print+2CEdgeTest-method'></span><span id='topic+EdgeTest-method'></span><span id='topic+plot+2CEdgeTest+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>EdgeTest</code> defines the significance of parent-child annotation enrichment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EdgeTest'
print(x)

## S4 method for signature 'EdgeTest,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeTest-class_+3A_x">x</code></td>
<td>
<p>EdgeTest object.</p>
</td></tr>
<tr><td><code id="EdgeTest-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="EdgeTest-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotEdgeTest">plotEdgeTest</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>tests</code></dt><dd><p>data.frame describing the significance test results with columns:
</p>

<ul>
<li>  <p><code>parent</code>:    parent node annotation.
</p>
</li>
<li>  <p><code>child</code>:     child node annotation
</p>
</li>
<li>  <p><code>count</code>:     count of observed edges with the given 
parent-child annotation set.
</p>
</li>
<li>  <p><code>expected</code>:  mean count of expected edges for the 
given parent-child relationship.
</p>
</li>
<li>  <p><code>pvalue</code>:    one-sided p-value for the hypothesis that 
the observed edge abundance is greater 
than expected.
</p>
</li></ul>
</dd>
<dt><code>permutations</code></dt><dd><p>data.frame containing the raw permutation test data with columns:
</p>

<ul>
<li>  <p><code>parent</code>:  parent node annotation.
</p>
</li>
<li>  <p><code>child</code>:   child node annotation
</p>
</li>
<li>  <p><code>count</code>:   count of edges with the given parent-child 
annotation set.
</p>
</li>
<li>  <p><code>iter</code>:    numerical index define which permutation
realization each observation corresponds 
to.
</p>
</li></ul>
</dd>
<dt><code>nperm</code></dt><dd><p>number of permutation realizations.</p>
</dd>
</dl>

<hr>
<h2 id='estimateAbundance'>Estimates the complete clonal relative abundance distribution</h2><span id='topic+estimateAbundance'></span>

<h3>Description</h3>

<p><code>estimateAbundance</code> estimates the complete clonal relative abundance distribution 
and confidence intervals on clone sizes using bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAbundance(
  data,
  clone = "clone_id",
  copy = NULL,
  group = NULL,
  min_n = 30,
  max_n = NULL,
  uniform = TRUE,
  ci = 0.95,
  nboot = 200,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateAbundance_+3A_data">data</code></td>
<td>
<p>data.frame with Change-O style columns containing clonal assignments.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_clone">clone</code></td>
<td>
<p>name of the <code>data</code> column containing clone identifiers.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_copy">copy</code></td>
<td>
<p>name of the <code>data</code> column containing copy numbers for each 
sequence. If <code>copy=NULL</code> (the default), then clone abundance
is determined by the number of sequences. If a <code>copy</code> column
is specified, then clone abundances is determined by the sum of 
copy numbers within each clonal group.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_group">group</code></td>
<td>
<p>name of the <code>data</code> column containing group identifiers. 
If <code>NULL</code> then no grouping is performed and the <code>group</code> 
column of the output will contain the value <code>NA</code> for each row.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_min_n">min_n</code></td>
<td>
<p>minimum number of observations to sample.
A group with less observations than the minimum is excluded.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_max_n">max_n</code></td>
<td>
<p>maximum number of observations to sample. If <code>NULL</code> then no 
maximum is set.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_uniform">uniform</code></td>
<td>
<p>if <code>TRUE</code> then uniformly resample each group to the same 
number of observations. If <code>FALSE</code> then allow each group to
be resampled to its original size or, if specified, <code>max_size</code>.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_ci">ci</code></td>
<td>
<p>confidence interval to calculate; the value must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap realizations to generate.</p>
</td></tr>
<tr><td><code id="estimateAbundance_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> show a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+AbundanceCurve">AbundanceCurve</a> object summarizing the abundances.
</p>


<h3>References</h3>


<ol>
<li><p>  Chao A. Nonparametric Estimation of the Number of Classes in a Population. 
Scand J Stat. 1984 11, 265270.
</p>
</li>
<li><p>  Chao A, et al. Rarefaction and extrapolation with Hill numbers: 
A framework for sampling and estimation in species diversity studies. 
Ecol Monogr. 2014 84:45-67.
</p>
</li>
<li><p>  Chao A, et al. Unveiling the species-rank abundance distribution by 
generalizing the Good-Turing sample coverage theory. 
Ecology. 2015 96, 11891201.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+plotAbundanceCurve">plotAbundanceCurve</a> for plotting of the abundance distribution.
See <a href="#topic+alphaDiversity">alphaDiversity</a> for a similar application to clonal diversity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abund &lt;- estimateAbundance(ExampleDb, group="sample_id", nboot=100)

</code></pre>

<hr>
<h2 id='Example10x'>Small example 10x Genomics Ig V(D)J sequences from CD19+ B cells isolated from PBMCs of a healthy 
human donor. Down-sampled from data provided by 10x Genomics under a Creative Commons Attribute license,
and processed with their Cell Ranger pipeline.</h2><span id='topic+Example10x'></span>

<h3>Description</h3>

<p>Small example 10x Genomics Ig V(D)J sequences from CD19+ B cells isolated from PBMCs of a healthy 
human donor. Down-sampled from data provided by 10x Genomics under a Creative Commons Attribute license,
and processed with their Cell Ranger pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Example10x
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following AIRR style columns:
</p>

<ul>
<li>  <p><code>sequence_id</code>:                Sequence identifier
</p>
</li>
<li>  <p><code>sequence_alignment</code>:         IMGT-gapped observed sequence.
</p>
</li>
<li>  <p><code>germline_alignment</code>:         IMGT-gapped germline sequence.
</p>
</li>
<li>  <p><code>v_call</code>:                     V region allele assignments.
</p>
</li>
<li>  <p><code>d_call</code>:                     D region allele assignments.
</p>
</li>
<li>  <p><code>j_call</code>:                     J region allele assignments.
</p>
</li>
<li>  <p><code>c_call</code>:                     Isotype (C region) assignment.
</p>
</li>
<li>  <p><code>junction</code>:                   Junction region sequence.
</p>
</li>
<li>  <p><code>junction_length</code>:            Length of the junction region in nucleotides.
</p>
</li>
<li>  <p><code>np1_length</code>:                 Combined length of the N and P regions proximal
to the V region.
</p>
</li>
<li>  <p><code>np2_length</code>:                 Combined length of the N and P regions proximal
to the J region.
</p>
</li>
<li>  <p><code>umi_count</code>:                  Number of unique molecular identifies atttributed to sequence.
</p>
</li>
<li>  <p><code>cell_id</code>:                    Cell identifier.
</p>
</li>
<li>  <p><code>locus</code>:                      Genomic locus of sequence.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Data source: https://support.10xgenomics.com/single-cell-vdj/datasets/2.2.0/vdj_v1_hs_cd19_b
</p>
</li>
<li><p>  License: https://creativecommons.org/licenses/by/4.0/
</p>
</li></ol>


<hr>
<h2 id='ExampleDb'>Example AIRR database</h2><span id='topic+ExampleDb'></span>

<h3>Description</h3>

<p>A small example database subset from Laserson and Vigneault et al, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleDb
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following AIRR style columns:
</p>

<ul>
<li>  <p><code>sequence_id</code>:                Sequence identifier
</p>
</li>
<li>  <p><code>sequence_alignment</code>:         IMGT-gapped observed sequence.
</p>
</li>
<li>  <p><code>germline_alignment</code>:         IMGT-gapped germline sequence.
</p>
</li>
<li>  <p><code>germline_alignment_d_mask</code>:  IMGT-gapped germline sequence with N, P and 
D regions masked.
</p>
</li>
<li>  <p><code>v_call</code>:                     V region allele assignments.
</p>
</li>
<li>  <p><code>v_call_genotyped</code>:           TIgGER corrected V region allele assignment.
</p>
</li>
<li>  <p><code>d_call</code>:                     D region allele assignments.
</p>
</li>
<li>  <p><code>j_call</code>:                     J region allele assignments.
</p>
</li>
<li>  <p><code>c_call</code>:                     Isotype (C region) assignment.
</p>
</li>
<li>  <p><code>junction</code>:                   Junction region sequence.
</p>
</li>
<li>  <p><code>junction_length</code>:            Length of the junction region in nucleotides.
</p>
</li>
<li>  <p><code>np1_length</code>:                 Combined length of the N and P regions proximal
to the V region.
</p>
</li>
<li>  <p><code>np2_length</code>:                 Combined length of the N and P regions proximal
to the J region.
</p>
</li>
<li>  <p><code>duplicate_count</code>:            Copy count (number of duplicates) of the sequence.
</p>
</li>
<li>  <p><code>clone_id</code>:                   Change-O assignment clonal group identifier.
</p>
</li>
<li>  <p><code>sample_id</code>:                  Sample identifier. Time in relation to vaccination.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Laserson U and Vigneault F, et al. High-resolution antibody dynamics of 
vaccine-induced immune responses. 
Proc Natl Acad Sci USA. 2014 111:4928-33.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ExampleDbChangeo">ExampleDbChangeo</a> <a href="#topic+ExampleTrees">ExampleTrees</a>
</p>

<hr>
<h2 id='ExampleDbChangeo'>Example Change-O database</h2><span id='topic+ExampleDbChangeo'></span>

<h3>Description</h3>

<p>A small example database subset from Laserson and Vigneault et al, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleDbChangeo
</code></pre>


<h3>Format</h3>

<p>A data.frame with the following Change-O style columns:
</p>

<ul>
<li>  <p><code>SEQUENCE_ID</code>:           Sequence identifier
</p>
</li>
<li>  <p><code>SEQUENCE_IMGT</code>:         IMGT-gapped observed sequence.
</p>
</li>
<li>  <p><code>GERMLINE_IMGT_D_MASK</code>:  IMGT-gapped germline sequence with N, P and 
D regions masked.
</p>
</li>
<li>  <p><code>V_CALL</code>:                V region allele assignments.
</p>
</li>
<li>  <p><code>V_CALL_GENOTYPED</code>:      TIgGER corrected V region allele assignment.
</p>
</li>
<li>  <p><code>D_CALL</code>:                D region allele assignments.
</p>
</li>
<li>  <p><code>J_CALL</code>:                J region allele assignments.
</p>
</li>
<li>  <p><code>JUNCTION</code>:              Junction region sequence.
</p>
</li>
<li>  <p><code>JUNCTION_LENGTH</code>:       Length of the junction region in nucleotides.
</p>
</li>
<li>  <p><code>NP1_LENGTH</code>:            Combined length of the N and P regions proximal
to the V region.
</p>
</li>
<li>  <p><code>NP2_LENGTH</code>:            Combined length of the N and P regions proximal
to the J region.
</p>
</li>
<li>  <p><code>SAMPLE</code>:                Sample identifier. Time in relation to vaccination.
</p>
</li>
<li>  <p><code>ISOTYPE</code>:               Isotype assignment.
</p>
</li>
<li>  <p><code>DUPCOUNT</code>:              Copy count (number of duplicates) of the sequence.
</p>
</li>
<li>  <p><code>CLONE</code>:                 Change-O assignment clonal group identifier.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Laserson U and Vigneault F, et al. High-resolution antibody dynamics of 
vaccine-induced immune responses. 
Proc Natl Acad Sci USA. 2014 111:4928-33.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ExampleDb">ExampleDb</a> <a href="#topic+ExampleTrees">ExampleTrees</a>
</p>

<hr>
<h2 id='ExampleTrees'>Example Ig lineage trees</h2><span id='topic+ExampleTrees'></span>

<h3>Description</h3>

<p>A set of Ig lineage trees generated from the <code>ExampleDb</code> file, subset to
only those trees with at least four nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleTrees
</code></pre>


<h3>Format</h3>

<p>A list of igraph objects output by <a href="#topic+buildPhylipLineage">buildPhylipLineage</a>.
Each node of each tree has the following annotations (vertex attributes):
</p>

<ul>
<li>  <p><code>sample_id</code>:          Sample identifier(s). Time in relation to vaccination.
</p>
</li>
<li>  <p><code>c_call</code>:             Isotype assignment(s). 
</p>
</li>
<li>  <p><code>duplication_count</code>:  Copy count (number of duplicates) of the sequence.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+ExampleTrees">ExampleTrees</a>
</p>

<hr>
<h2 id='extractVRegion'>Extracts FWRs and CDRs from IMGT-gapped sequences</h2><span id='topic+extractVRegion'></span>

<h3>Description</h3>

<p><code>extractVRegion</code> extracts the framework and complementarity determining regions of 
the V segment for IMGT-gapped immunoglobulin (Ig) nucleotide sequences according to the 
IMGT numbering scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractVRegion(sequences, region = c("fwr1", "cdr1", "fwr2", "cdr2", "fwr3"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractVRegion_+3A_sequences">sequences</code></td>
<td>
<p>character vector of IMGT-gapped nucleotide sequences.</p>
</td></tr>
<tr><td><code id="extractVRegion_+3A_region">region</code></td>
<td>
<p>string defining the region(s) of the V segment to extract. 
May be a single region or multiple regions (as a vector) from
<code>c("fwr1", "cdr1", "fwr2", "cdr2" ,"fwr3")</code>.  By default, all
regions will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only one region is specified in the <code>region</code> argument, a character 
vector of the extracted sub-sequences will be returned. If multiple regions 
are specified, then a character matrix will be returned with columns 
corresponding to the specified regions and a row for each entry in 
<code>sequences</code>.
</p>


<h3>References</h3>


<ol>
<li><p>  Lefranc M-P, et al. IMGT unique numbering for immunoglobulin and T cell 
receptor variable domains and Ig superfamily V-like domains.
Dev Comp Immunol. 2003 27(1):55-77.
</p>
</li></ol>



<h3>See Also</h3>

<p>IMGT-gapped region boundaries are defined in <a href="#topic+IMGT_REGIONS">IMGT_REGIONS</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assign example clone
clone &lt;- subset(ExampleDb, clone_id == 3138)

# Get all regions
extractVRegion(clone$sequence_alignment)

# Get single region
extractVRegion(clone$sequence_alignment, "fwr1")

# Get all CDRs
extractVRegion(clone$sequence_alignment, c("cdr1", "cdr2"))

# Get all FWRs
extractVRegion(clone$sequence_alignment, c("fwr1", "fwr2", "fwr3"))

</code></pre>

<hr>
<h2 id='getAAMatrix'>Build an AA distance matrix</h2><span id='topic+getAAMatrix'></span>

<h3>Description</h3>

<p><code>getAAMatrix</code> returns a Hamming distance matrix for IUPAC ambiguous
amino acid characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAAMatrix(gap = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAAMatrix_+3A_gap">gap</code></td>
<td>
<p>value to assign to characters in the set <code>c("-", ".")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of amino acid character distances with row and column names 
indicating the character pair.
</p>


<h3>See Also</h3>

<p>Creates an amino acid distance matrix for <a href="#topic+seqDist">seqDist</a>.
See <a href="#topic+getDNAMatrix">getDNAMatrix</a> for nucleotide distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAAMatrix()

</code></pre>

<hr>
<h2 id='getDNAMatrix'>Build a DNA distance matrix</h2><span id='topic+getDNAMatrix'></span>

<h3>Description</h3>

<p><code>getDNAMatrix</code> returns a Hamming distance matrix for IUPAC ambiguous
DNA characters with modifications for gap, <code>c("-", ".")</code>, and missing, 
<code>c("?")</code>, character values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDNAMatrix(gap = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDNAMatrix_+3A_gap">gap</code></td>
<td>
<p>value to assign to characters in the set <code>c("-", ".")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of DNA character distances with row and column names 
indicating the character pair. By default, distances will be either 0 
(equivalent), 1 (non-equivalent or missing), or -1 (gap).
</p>


<h3>See Also</h3>

<p>Creates DNA distance matrix for <a href="#topic+seqDist">seqDist</a>.
See <a href="#topic+getAAMatrix">getAAMatrix</a> for amino acid distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set gap characters to Inf distance
# Distinguishes gaps from Ns
getDNAMatrix()

# Set gap characters to 0 distance
# Makes gap characters equivalent to Ns
getDNAMatrix(gap=0)

</code></pre>

<hr>
<h2 id='getMRCA'>Retrieve the first non-root node of a lineage tree</h2><span id='topic+getMRCA'></span>

<h3>Description</h3>

<p><code>getMRCA</code> returns the set of lineage tree nodes with the minimum weighted or 
unweighted path length from the root (germline) of the lineage tree, allowing for 
exclusion of specific groups of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMRCA(
  graph,
  path = c("distance", "steps"),
  root = "Germline",
  field = NULL,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMRCA_+3A_graph">graph</code></td>
<td>
<p>igraph object containing an annotated lineage tree.</p>
</td></tr>
<tr><td><code id="getMRCA_+3A_path">path</code></td>
<td>
<p>string defining whether to use unweighted (steps) or weighted (distance) 
measures for determining the founder node set..</p>
</td></tr>
<tr><td><code id="getMRCA_+3A_root">root</code></td>
<td>
<p>name of the root (germline) node.</p>
</td></tr>
<tr><td><code id="getMRCA_+3A_field">field</code></td>
<td>
<p>annotation field to use for both unweighted path length exclusion and
consideration as an MRCA node. If <code>NULL</code> do not exclude any nodes.</p>
</td></tr>
<tr><td><code id="getMRCA_+3A_exclude">exclude</code></td>
<td>
<p>vector of annotation values in <code>field</code> to exclude from the potential 
MRCA set. If <code>NULL</code> do not exclude any nodes. Has no effect if 
<code>field=NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of the MRCA node(s) containing the columns:
</p>

<ul>
<li>  <p><code>name</code>:      node name
</p>
</li>
<li>  <p><code>steps</code>:     path length as the number of nodes traversed
</p>
</li>
<li>  <p><code>distance</code>:  path length as the sum of edge weights
</p>
</li></ul>

<p>Along with additional columns corresponding to the 
annotations of the input graph.
</p>


<h3>See Also</h3>

<p>Path lengths are determined with <a href="#topic+getPathLengths">getPathLengths</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example graph
graph &lt;- ExampleTrees[[23]]

# Use unweighted path length and do not exclude any nodes
getMRCA(graph, path="steps", root="Germline")

# Exclude nodes without an isotype annotation and use weighted path length
getMRCA(graph, path="distance", root="Germline", field="c_call", exclude=NA)

</code></pre>

<hr>
<h2 id='getPathLengths'>Calculate path lengths from the tree root</h2><span id='topic+getPathLengths'></span>

<h3>Description</h3>

<p><code>getPathLengths</code> calculates the unweighted (number of steps) and weighted (distance) 
path lengths from the root of a lineage tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPathLengths(graph, root = "Germline", field = NULL, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPathLengths_+3A_graph">graph</code></td>
<td>
<p>igraph object containing an annotated lineage tree.</p>
</td></tr>
<tr><td><code id="getPathLengths_+3A_root">root</code></td>
<td>
<p>name of the root (germline) node.</p>
</td></tr>
<tr><td><code id="getPathLengths_+3A_field">field</code></td>
<td>
<p>annotation field to use for exclusion of nodes from step count.</p>
</td></tr>
<tr><td><code id="getPathLengths_+3A_exclude">exclude</code></td>
<td>
<p>annotation values specifying which nodes to exclude from step count. 
If <code>NULL</code> consider all nodes. This does not affect the weighted
(distance) path length calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns:
</p>

<ul>
<li>  <p><code>name</code>:      node name
</p>
</li>
<li>  <p><code>steps</code>:     path length as the number of nodes traversed
</p>
</li>
<li>  <p><code>distance</code>:  path length as the sum of edge weights
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+buildPhylipLineage">buildPhylipLineage</a> for generating input trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example graph
graph &lt;- ExampleTrees[[24]]

# Consider all nodes
getPathLengths(graph, root="Germline")

# Exclude nodes without an isotype annotation from step count
getPathLengths(graph, root="Germline", field="c_call", exclude=NA)

</code></pre>

<hr>
<h2 id='getPositionQuality'>Get a data.frame with sequencing qualities per position</h2><span id='topic+getPositionQuality'></span>

<h3>Description</h3>

<p><code>getPositionQuality</code> takes a data.frame with sequence quality scores 
in the form of a strings of comma separated numeric values, split the quality 
scores values by <code>","</code>,  and returns a data.frame with the values
for each position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPositionQuality(
  data,
  sequence_id = "sequence_id",
  sequence = "sequence_alignment",
  quality_num = "quality_alignment_num"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPositionQuality_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="getPositionQuality_+3A_sequence_id">sequence_id</code></td>
<td>
<p>column in <code>data</code> with sequence identifiers.</p>
</td></tr>
<tr><td><code id="getPositionQuality_+3A_sequence">sequence</code></td>
<td>
<p>column in <code>data</code> with sequence data.</p>
</td></tr>
<tr><td><code id="getPositionQuality_+3A_quality_num">quality_num</code></td>
<td>
<p>column in <code>data</code> with quality scores (as
strings of numeric values, comma separated) for <code>sequence</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> with one additional field with masked sequences. The 
name of this field is created concatenating <code>sequence</code> 
and '_masked'.
</p>


<h3>See Also</h3>

<p><a href="#topic+readFastqDb">readFastqDb</a> and <a href="#topic+maskPositionsByQuality">maskPositionsByQuality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- airr::read_rearrangement(system.file("extdata", "example_quality.tsv", package="alakazam"))
fastq_file &lt;- system.file("extdata", "example_quality.fastq", package="alakazam")
db &lt;- readFastqDb(db, fastq_file, quality_offset=-33)
head(getPositionQuality(db))
</code></pre>

<hr>
<h2 id='getSegment'>Get Ig segment allele, gene and family names</h2><span id='topic+getSegment'></span><span id='topic+getAllele'></span><span id='topic+getGene'></span><span id='topic+getFamily'></span><span id='topic+getLocus'></span><span id='topic+getChain'></span>

<h3>Description</h3>

<p><code>getSegment</code> performs generic matching of delimited segment calls with a custom 
regular expression. <a href="#topic+getAllele">getAllele</a>, <a href="#topic+getGene">getGene</a> and <a href="#topic+getFamily">getFamily</a> extract 
the allele, gene and family names, respectively, from a character vector of 
immunoglobulin (Ig) or TCR segment allele calls in IMGT format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSegment(
  segment_call,
  segment_regex,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)

getAllele(
  segment_call,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)

getGene(
  segment_call,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)

getFamily(
  segment_call,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)

getLocus(
  segment_call,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)

getChain(
  segment_call,
  first = TRUE,
  collapse = TRUE,
  strip_d = TRUE,
  omit_nl = FALSE,
  sep = ","
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegment_+3A_segment_call">segment_call</code></td>
<td>
<p>character vector containing segment calls delimited by commas.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_segment_regex">segment_regex</code></td>
<td>
<p>string defining the segment match regular expression.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_first">first</code></td>
<td>
<p>if <code>TRUE</code> return only the first call in 
<code>segment_call</code>; if <code>FALSE</code> return all calls 
delimited by commas.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_collapse">collapse</code></td>
<td>
<p>if <code>TRUE</code> check for duplicates and return only unique 
segment assignments; if <code>FALSE</code> return all assignments 
(faster). Has no effect if <code>first=TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_strip_d">strip_d</code></td>
<td>
<p>if <code>TRUE</code> remove the &quot;D&quot; from the end of gene annotations 
(denoting a duplicate gene in the locus); 
if <code>FALSE</code> do not alter gene names.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_omit_nl">omit_nl</code></td>
<td>
<p>if <code>TRUE</code> remove non-localized (NL) genes from the result.
Only applies at the gene or allele level.</p>
</td></tr>
<tr><td><code id="getSegment_+3A_sep">sep</code></td>
<td>
<p>character defining both the input and output segment call 
delimiter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing allele, gene or family names.
</p>


<h3>References</h3>

<p><a href="https://www.imgt.org/">https://www.imgt.org/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+countGenes">countGenes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Light chain examples
kappa_call &lt;- c("Homsap IGKV1D-39*01 F,Homsap IGKV1-39*02 F,Homsap IGKV1-39*01",
                "Homsap IGKJ5*01 F")

getAllele(kappa_call)
getAllele(kappa_call, first=FALSE)
getAllele(kappa_call, first=FALSE, strip_d=FALSE)

getGene(kappa_call)
getGene(kappa_call, first=FALSE)
getGene(kappa_call, first=FALSE, strip_d=FALSE)

getFamily(kappa_call)
getFamily(kappa_call, first=FALSE)
getFamily(kappa_call, first=FALSE, collapse=FALSE)
getFamily(kappa_call, first=FALSE, strip_d=FALSE)

getLocus(kappa_call)
getChain(kappa_call)

# Heavy chain examples
heavy_call &lt;- c("Homsap IGHV1-69*01 F,Homsap IGHV1-69D*01 F", 
                "Homsap IGHD1-1*01 F", 
                "Homsap IGHJ1*01 F")

getAllele(heavy_call, first=FALSE)
getAllele(heavy_call, first=FALSE, strip_d=FALSE)

getGene(heavy_call, first=FALSE)
getGene(heavy_call, first=FALSE, strip_d=FALSE)

getFamily(heavy_call)
getLocus(heavy_call)
getChain(heavy_call)

# Filtering non-localized genes
nl_call &lt;- c("IGHV3-NL1*01,IGHV3-30-3*01,IGHV3-30*01", 
             "Homosap IGHV3-30*01 F,Homsap IGHV3-NL1*01 F",
             "IGHV1-NL1*01")
             
getAllele(nl_call, first=FALSE, omit_nl=TRUE)
getGene(nl_call, first=FALSE, omit_nl=TRUE)
getFamily(nl_call, first=FALSE, omit_nl=TRUE)

# Temporary designation examples
tmp_call &lt;- c("IGHV9S3*01", "IGKV10S12*01")

getAllele(tmp_call)
getGene(tmp_call)
getFamily(tmp_call)

</code></pre>

<hr>
<h2 id='graphToPhylo'>Convert a tree in igraph <code>graph</code> format to ape <code>phylo</code> format.</h2><span id='topic+graphToPhylo'></span>

<h3>Description</h3>

<p><code>graphToPhylo</code> a tree in igraph <code>graph</code> format to ape <code>phylo</code> 
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphToPhylo(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphToPhylo_+3A_graph">graph</code></td>
<td>
<p>An igraph <code>graph</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert from igraph <code>graph</code> object to ape <code>phylo</code> object. If <code>graph</code> object
was previously rooted with the germline as the direct ancestor, this will re-attach the 
germline as a descendant node with a zero branch length to a new universal common ancestor (UCA) 
node and store the germline node ID in the <code>germid</code> attribute and UCA node number in 
the <code>uca</code> attribute. Otherwise these attributes will not be specified in the <code>phylo</code> object. 
Using <code>phyloToGraph(phylo, germline=phylo$germid)</code> creates a <code>graph</code> object with the germline 
back as the direct ancestor. Tip and internal node names are 
stored in the <code>tip.label</code> and <code>node.label</code> vectors, respectively.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object representing the input tree. Tip and internal node names are 
stored in the <code>tip.label</code> and <code>node.label</code> vectors, respectively.
</p>


<h3>References</h3>


<ol>
<li><p>  Hoehn KB, Lunter G, Pybus OG - A Phylogenetic Codon Substitution Model for Antibody 
Lineages. Genetics 2017 206(1):417-427
https://doi.org/10.1534/genetics.116.196303 
</p>
</li>
<li><p>  Hoehn KB, Vander Heiden JA, Zhou JQ, Lunter G, Pybus OG, Kleinstein SHK - 
Repertoire-wide phylogenetic models of B cell molecular evolution reveal 
evolutionary signatures of aging and vaccination. bioRxiv 2019  
https://doi.org/10.1101/558825 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   library(igraph)
   library(ape)

   #convert to phylo
   phylo = graphToPhylo(graph)
   
   #plot tree using ape
   plot(phylo,show.node.label=TRUE)
   
   #store as newick tree
   write.tree(phylo,file="tree.newick")
   
   #read in tree from newick file
   phylo_r = read.tree("tree.newick")
   
   #convert to igraph
   graph_r = phyloToGraph(phylo_r,germline="Germline")
   
   #plot graph - same as before, possibly rotated
   plot(graph_r,layout=layout_as_tree)

## End(Not run)

</code></pre>

<hr>
<h2 id='gravy'>Calculates the hydrophobicity of amino acid sequences</h2><span id='topic+gravy'></span>

<h3>Description</h3>

<p><code>gravy</code> calculates the Grand Average of Hydrophobicity (gravy) index 
of amino acid sequences using the method of Kyte &amp; Doolittle. Non-informative
positions are excluded, where non-informative is defined as any character in 
<code>c("X", "-", ".", "*")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gravy(seq, hydropathy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gravy_+3A_seq">seq</code></td>
<td>
<p>vector of strings containing amino acid sequences.</p>
</td></tr>
<tr><td><code id="gravy_+3A_hydropathy">hydropathy</code></td>
<td>
<p>named numerical vector defining hydropathy index values for 
each amino acid, where names are single-letter amino acid 
character codes. If <code>NULL</code>, then the Kyte &amp; Doolittle
scale is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of gravy scores for the sequence(s).
</p>


<h3>References</h3>


<ol>
<li><p>  Kyte J, Doolittle RF. A simple method for displaying the hydropathic character 
of a protein. J Mol Biol. 157, 105-32 (1982).
</p>
</li></ol>



<h3>See Also</h3>

<p>For additional hydrophobicity indices see <code><a href="seqinr.html#topic+aaindex">aaindex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default scale
seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", "XXTQMYVRT")
gravy(seq)

# Use the Kidera et al, 1985 scores from the seqinr package
library(seqinr)
data(aaindex)
x &lt;- aaindex[["KIDA850101"]]$I
# Rename the score vector to use single-letter codes
names(x) &lt;- translateStrings(names(x), ABBREV_AA)
# Calculate hydrophobicity
gravy(seq, hydropathy=x)

</code></pre>

<hr>
<h2 id='gridPlot'>Plot multiple ggplot objects</h2><span id='topic+gridPlot'></span>

<h3>Description</h3>

<p>Plots multiple ggplot objects in an equally sized grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridPlot(..., ncol = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridPlot_+3A_...">...</code></td>
<td>
<p>ggplot objects to plot.</p>
</td></tr>
<tr><td><code id="gridPlot_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the plot.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Modified from:
http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)
</p>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+ggplot">ggplot</a>.
</p>

<hr>
<h2 id='groupGenes'>Group sequences by gene assignment</h2><span id='topic+groupGenes'></span>

<h3>Description</h3>

<p><code>groupGenes</code> will group rows by shared V and J gene assignments, 
and optionally also by junction lengths. IGH:IGK/IGL, TRB:TRA, and TRD:TRG 
paired single-cell BCR/TCR sequencing and unpaired bulk sequencing 
(IGH, TRB, TRD chain only) are supported. In the case of ambiguous (multiple) 
gene assignments, the grouping may be specified to be a union across all 
ambiguous V and J gene pairs, analogous to single-linkage clustering 
(i.e., allowing for chaining).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupGenes(
  data,
  v_call = "v_call",
  j_call = "j_call",
  junc_len = NULL,
  cell_id = NULL,
  locus = "locus",
  only_heavy = TRUE,
  first = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupGenes_+3A_data">data</code></td>
<td>
<p>data.frame containing sequence data.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing the heavy/long chain 
V-segment allele calls.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing the heavy/long chain 
J-segment allele calls.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_junc_len">junc_len</code></td>
<td>
<p>name of column containing the junction length.
If <code>NULL</code> then 1-stage partitioning is perform
considering only the V and J genes is performed. 
See Details for further clarification.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_cell_id">cell_id</code></td>
<td>
<p>name of the column containing cell identifiers or barcodes. 
If specified, grouping will be performed in single-cell mode
with the behavior governed by the <code>locus</code> and 
<code>only_heavy</code> arguments. If set to <code>NULL</code> then the 
bulk sequencing data is assumed.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_locus">locus</code></td>
<td>
<p>name of the column containing locus information. 
Only applicable to single-cell data.
Ignored if <code>cell_id=NULL</code>.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_only_heavy">only_heavy</code></td>
<td>
<p>use only the IGH (BCR) or TRB/TRD (TCR) sequences 
for grouping. Only applicable to single-cell data.
Ignored if <code>cell_id=NULL</code>.</p>
</td></tr>
<tr><td><code id="groupGenes_+3A_first">first</code></td>
<td>
<p>if <code>TRUE</code> only the first call of the gene assignments 
is used. if <code>FALSE</code> the union of ambiguous gene 
assignments is used to group all sequences with any 
overlapping gene calls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To invoke single-cell mode the <code>cell_id</code> argument must be specified and the <code>locus</code> 
column must be correct. Otherwise, <code>groupGenes</code> will be run with bulk sequencing assumptions, 
using all input sequences regardless of the values in the <code>locus</code> column.
</p>
<p>Values in the <code>locus</code> column must be one of <code>c("IGH", "IGI", "IGK", "IGL")</code> for BCR 
or <code>c("TRA", "TRB", "TRD", "TRG")</code> for TCR sequences. Otherwise, the function returns an 
error message and stops.
</p>
<p>Under single-cell mode with paired chained sequences, there is a choice of whether 
grouping should be done by (a) using IGH (BCR) or TRB/TRD (TCR) sequences only or
(b) using IGH plus IGK/IGL (BCR) or TRB/TRD plus TRA/TRG (TCR). 
This is governed by the <code>only_heavy</code> argument.
</p>
<p>Specifying <code>junc_len</code> will force <code>groupGenes</code> to perform a 1-stage partitioning of the 
sequences/cells based on V gene, J gene, and junction length simultaneously. 
If <code>junc_len=NULL</code> (no column specified), then <code>groupGenes</code> performs only the first 
stage of a 2-stage partitioning in which sequences/cells are partitioned in the first stage 
based on V gene and J gene, and then in the second stage further splits the groups based on 
junction length (the second stage must be performed independently, as this only returns the
first stage results).
</p>
<p>In the input <code>data</code>, the <code>v_call</code>, <code>j_call</code>, <code>cell_id</code>, and <code>locus</code> 
columns, if present, must be of type <code>character</code> (as opposed to <code>factor</code>). 
</p>
<p>It is assumed that ambiguous gene assignments are separated by commas.
</p>
<p>All rows containing <code>NA</code> values in any of the <code>v_call</code>, <code>j_call</code>, and <code>junc_len</code> 
(if <code>junc_len != NULL</code>) columns will be removed. A warning will be issued when a row 
containing an <code>NA</code> is removed.
</p>


<h3>Value</h3>

<p>Returns a modified data.frame with disjoint union indices 
in a new <code>vj_group</code> column. 
</p>
<p>If <code>junc_len</code> is supplied, the grouping this <code>vj_group</code> 
will have been based on V, J, and junction length simultaneously. However, 
the output column name will remain <code>vj_group</code>.
</p>
<p>The output <code>v_call</code>, <code>j_call</code>, <code>cell_id</code>, and <code>locus</code>
columns will be converted to type <code>character</code> if they were of type 
<code>factor</code> in the input <code>data</code>.
</p>


<h3>Expectations for single-cell data</h3>

<p>Single-cell paired chain data assumptions:
</p>

<ul>
<li><p> every row represents a sequence (chain).
</p>
</li>
<li><p> heavy/long and light/short chains of the same cell are linked by <code>cell_id</code>.
</p>
</li>
<li><p> the value in <code>locus</code> column indicates whether the chain is the heavy/long or light/short chain.
</p>
</li>
<li><p> each cell possibly contains multiple heavy/long and/or light/short chains.
</p>
</li>
<li><p> every chain has its own V(D)J annotation, in which ambiguous V(D)J 
annotations, if any, are separated by a comma.
</p>
</li></ul>

<p>Single-cell example:
</p>

<ul>
<li><p> A cell has 1 heavy chain and 2 light chains.
</p>
</li>
<li><p> There should be 3 rows corresponding to this cell.
</p>
</li>
<li><p> One of the light chains may have an ambiguous V annotation which looks like <code>"Homsap IGKV1-39*01 F,Homsap IGKV1D-39*01 F"</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Group by genes
db &lt;- groupGenes(ExampleDb)
head(db$vj_group)
 
</code></pre>

<hr>
<h2 id='IMGT_REGIONS'>IMGT V-segment regions</h2><span id='topic+IMGT_REGIONS'></span>

<h3>Description</h3>

<p>A list defining the boundaries of V-segment framework regions (FWRs) and complementarity 
determining regions (CDRs) for IMGT-gapped immunoglobulin (Ig) nucleotide sequences 
according to the IMGT numbering scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMGT_REGIONS
</code></pre>


<h3>Format</h3>

<p>A list with regions named one of <code>c("fwr1", "cdr1", "fwr2", "cdr2", "fwr3")</code> 
with values containing a numeric vector of length two defining the 
<code>c(start, end)</code> positions of the named region.
</p>


<h3>References</h3>

<p><a href="https://www.imgt.org/">https://www.imgt.org/</a>
</p>

<hr>
<h2 id='isValidAASeq'>Validate amino acid sequences</h2><span id='topic+isValidAASeq'></span>

<h3>Description</h3>

<p><code>isValidAASeq</code> checks that a set of sequences are valid non-ambiguous 
amino acid sequences. A sequence is considered valid if it contains only 
characters in the the non-ambiguous IUPAC character set or any characters in 
<code>c("X", ".", "-", "*")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidAASeq(seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidAASeq_+3A_seq">seq</code></td>
<td>
<p>character vector of sequences to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with <code>TRUE</code> for each valid amino acid sequences 
and <code>FALSE</code> for each invalid sequence.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+ABBREV_AA">ABBREV_AA</a> for the set of non-ambiguous amino acid characters.
See <a href="#topic+IUPAC_AA">IUPAC_AA</a> for the full set of ambiguous amino acid characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", "XXTQMYVR--XX", "CARJ", "10") 
isValidAASeq(seq)

</code></pre>

<hr>
<h2 id='IUPAC_CODES'>IUPAC ambiguous characters</h2><span id='topic+IUPAC_CODES'></span><span id='topic+IUPAC_DNA'></span><span id='topic+IUPAC_AA'></span><span id='topic+DNA_IUPAC'></span>

<h3>Description</h3>

<p>A translation list mapping IUPAC ambiguous characters code to corresponding nucleotide
amino acid characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IUPAC_DNA

IUPAC_AA

DNA_IUPAC
</code></pre>


<h3>Format</h3>

<p>A list with single character codes as names and values containing character 
vectors that define the set of standard characters that match to each each 
ambiguous character.
</p>

<ul>
<li>  <p><code>IUPAC_DNA</code>:  DNA ambiguous character translations.
</p>
</li>
<li>  <p><code>IUPAC_AA</code>:   Amino acid ambiguous character translations.
</p>
</li>
<li>  <p><code>DNA_IUPAC</code>:  Ordered DNA to ambiguous characters
</p>
</li></ul>

<p>An object of class <code>list</code> of length 15.
</p>
<p>An object of class <code>list</code> of length 25.
</p>
<p>An object of class <code>list</code> of length 15.
</p>

<hr>
<h2 id='junctionAlignment'>Calculate junction region alignment properties</h2><span id='topic+junctionAlignment'></span>

<h3>Description</h3>

<p><code>junctionAlignment</code> determines the number of deleted germline nucleotides in the 
junction region and the number of V gene and J gene nucleotides in the CDR3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>junctionAlignment(
  data,
  germline_db,
  v_call = "v_call",
  d_call = "d_call",
  j_call = "j_call",
  v_germline_start = "v_germline_start",
  v_germline_end = "v_germline_end",
  d_germline_start = "d_germline_start",
  d_germline_end = "d_germline_end",
  j_germline_start = "j_germline_start",
  j_germline_end = "j_germline_end",
  np1_length = "np1_length",
  np2_length = "np2_length",
  junction = "junction",
  junction_length = "junction_length",
  sequence_alignment = "sequence_alignment"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="junctionAlignment_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_germline_db">germline_db</code></td>
<td>
<p>reference germline database for the V, D and J genes.
in <code>data</code></p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_v_call">v_call</code></td>
<td>
<p>V gene assignment column.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_d_call">d_call</code></td>
<td>
<p>D gene assignment column.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_j_call">j_call</code></td>
<td>
<p>J gene assignment column.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_v_germline_start">v_germline_start</code></td>
<td>
<p>column containing the start position of the alignment 
in the V reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_v_germline_end">v_germline_end</code></td>
<td>
<p>column containing the end position of the alignment in the 
V reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_d_germline_start">d_germline_start</code></td>
<td>
<p>column containing the start position of the alignment 
in the D reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_d_germline_end">d_germline_end</code></td>
<td>
<p>column containing the start position of the alignment 
in the D reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_j_germline_start">j_germline_start</code></td>
<td>
<p>column containing the start position of the alignment 
in the J reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_j_germline_end">j_germline_end</code></td>
<td>
<p>column containing the start position of the alignment 
in the J reference germline.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_np1_length">np1_length</code></td>
<td>
<p>combined length of the N and P regions between the 
V and D regions (heavy chain) or V and J regions (light chain).</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_np2_length">np2_length</code></td>
<td>
<p>combined length of the N and P regions between the 
D and J regions (heavy chain).</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_junction">junction</code></td>
<td>
<p>column containing the junction sequence.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_junction_length">junction_length</code></td>
<td>
<p>column containing the length of the junction region in nucleotides.</p>
</td></tr>
<tr><td><code id="junctionAlignment_+3A_sequence_alignment">sequence_alignment</code></td>
<td>
<p>column containing the aligned sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified input <code>data.frame</code> with the following additional columns storing 
junction alignment information:
</p>

<ol>
<li>  <p><code>e3v_length</code>:     number of 3' V germline nucleotides deleted.
</p>
</li>
<li>  <p><code>e5d_length</code>:     number of 5' D germline nucleotides deleted.
</p>
</li>
<li>  <p><code>e3d_length</code>:     number of 3' D germline nucleotides deleted.
</p>
</li>
<li>  <p><code>e5j_length</code>:     number of 5' J germline nucleotides deleted.
</p>
</li>
<li>  <p><code>v_cdr3_length</code>:  number of sequence_alignment V nucleotides in the CDR3.
</p>
</li>
<li>  <p><code>j_cdr3_length</code>:  number of sequence_alignment J nucleotides in the CDR3.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>germline_db &lt;- list(
"IGHV3-11*05"="CAGGTGCAGCTGGTGGAGTCTGGGGGA...GGCTTGGTCAAGCCTGGAGGGTCCCTGAGACT
CTCCTGTGCAGCCTCTGGATTCACCTTC............AGTGACTACTACATGAGCTGGATCCGCCAGGCTCCAG
GGAAGGGGCTGGAGTGGGTTTCATACATTAGTAGTAGT......AGTAGTTACACAAACTACGCAGACTCTGTGAAG
...GGCCGATTCACCATCTCCAGAGACAACGCCAAGAACTCACTGTATCTGCAAATGAACAGCCTGAGAGCCGAGGA
CACGGCCGTGTATTACTGTGCGAGAGA",
"IGHD3-10*01"="GTATTACTATGGTTCGGGGAGTTATTATAAC",
"IGHJ5*02"="ACAACTGGTTCGACCCCTGGGGCCAGGGAACCCTGGTCACCGTCTCCTCAG"
)

db &lt;- junctionAlignment(SingleDb, germline_db)

</code></pre>

<hr>
<h2 id='makeChangeoClone'>Generate a ChangeoClone object for lineage construction</h2><span id='topic+makeChangeoClone'></span>

<h3>Description</h3>

<p><code>makeChangeoClone</code> takes a data.frame with AIRR or Change-O style columns as input and 
masks gap positions, masks ragged ends, removes duplicates sequences, and merges 
annotations associated with duplicate sequences. It returns a <code>ChangeoClone</code> 
object which serves as input for lineage reconstruction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeChangeoClone(
  data,
  id = "sequence_id",
  seq = "sequence_alignment",
  germ = "germline_alignment",
  v_call = "v_call",
  j_call = "j_call",
  junc_len = "junction_length",
  clone = "clone_id",
  mask_char = "N",
  locus = "locus",
  max_mask = 0,
  pad_end = FALSE,
  text_fields = NULL,
  num_fields = NULL,
  seq_fields = NULL,
  add_count = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeChangeoClone_+3A_data">data</code></td>
<td>
<p>data.frame containing the AIRR or Change-O data for a clone. See Details
for the list of required columns and their default values.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_id">id</code></td>
<td>
<p>name of the column containing sequence identifiers.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_seq">seq</code></td>
<td>
<p>name of the column containing observed DNA sequences. All 
sequences in this column must be multiple aligned.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_germ">germ</code></td>
<td>
<p>name of the column containing germline DNA sequences. All entries 
in this column should be identical for any given clone, and they
must be multiple aligned with the data in the <code>seq</code> column.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_v_call">v_call</code></td>
<td>
<p>name of the column containing V-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_j_call">j_call</code></td>
<td>
<p>name of the column containing J-segment allele assignments. All 
entries in this column should be identical to the gene level.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_junc_len">junc_len</code></td>
<td>
<p>name of the column containing the length of the junction as a 
numeric value. All entries in this column should be identical 
for any given clone.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_clone">clone</code></td>
<td>
<p>name of the column containing the identifier for the clone. All 
entries in this column should be identical.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_mask_char">mask_char</code></td>
<td>
<p>character to use for masking and padding.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_locus">locus</code></td>
<td>
<p>name of the column containing locus specification. Must be present
and only contain the value &quot;IGH&quot;, representing heavy chains.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_max_mask">max_mask</code></td>
<td>
<p>maximum number of characters to mask at the leading and trailing
sequence ends. If <code>NULL</code> then the upper masking bound will 
be automatically determined from the maximum number of observed 
leading or trailing Ns amongst all sequences. If set to <code>0</code> 
(default) then masking will not be performed.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_pad_end">pad_end</code></td>
<td>
<p>if <code>TRUE</code> pad the end of each sequence with <code>mask_char</code>
to make every sequence the same length.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_text_fields">text_fields</code></td>
<td>
<p>text annotation columns to retain and merge during duplicate removal.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_num_fields">num_fields</code></td>
<td>
<p>numeric annotation columns to retain and sum during duplicate removal.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_seq_fields">seq_fields</code></td>
<td>
<p>sequence annotation columns to retain and collapse during duplicate 
removal. Note, this is distinct from the <code>seq</code> and <code>germ</code> 
arguments, which contain the primary sequence data for the clone
and should not be repeated in this argument.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_add_count">add_count</code></td>
<td>
<p>if <code>TRUE</code> add an additional annotation column called 
<code>collapse_count</code> during duplicate removal that indicates the 
number of sequences that were collapsed.</p>
</td></tr>
<tr><td><code id="makeChangeoClone_+3A_verbose">verbose</code></td>
<td>
<p>passed on to <code>collapseDuplicates</code>. If <code>TRUE</code>, report the 
numbers of input, discarded and output sequences; otherwise, process
sequences silently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data.frame (<code>data</code>) must columns for each of the required column name 
arguments: <code>id</code>, <code>seq</code>, <code>germ</code>, <code>v_call</code>, <code>j_call</code>, 
<code>junc_len</code>, and <code>clone</code>.  The default values are as follows:
</p>

<ul>
<li>  <p><code>id       = "sequence_id"</code>:         unique sequence identifier.
</p>
</li>
<li>  <p><code>seq      = "sequence_alignment"</code>:  IMGT-gapped sample sequence.
</p>
</li>
<li>  <p><code>germ     = "germline_alignment"</code>:  IMGT-gapped germline sequence.
</p>
</li>
<li>  <p><code>v_call   = "v_call"</code>:              V segment allele call.
</p>
</li>
<li>  <p><code>j_call   = "j_call"</code>:              J segment allele call.
</p>
</li>
<li>  <p><code>junc_len = "junction_length"</code>:     junction sequence length.
</p>
</li>
<li>  <p><code>clone    = "clone_id"</code>:            clone identifier.
</p>
</li></ul>

<p>Additional annotation columns specified in the <code>text_fields</code>, <code>num_fields</code> 
or <code>seq_fields</code> arguments will be retained in the <code>data</code> slot of the return 
object, but are not required. If the input data.frame <code>data</code> already contains a 
column named <code>sequence</code>, which is not used as the <code>seq</code> argument, then that 
column will not be retained.
</p>
<p>The default columns are IMGT-gapped sequence columns, but this is not a requirement. 
However, all sequences (both observed and germline) must be multiple aligned using
some scheme for both proper duplicate removal and lineage reconstruction. 
</p>
<p>The value for the germline sequence, V-segment gene call, J-segment gene call, 
junction length, and clone identifier are determined from the first entry in the 
<code>germ</code>, <code>v_call</code>, <code>j_call</code>, <code>junc_len</code> and <code>clone</code> columns, 
respectively. For any given clone, each value in these columns should be identical.
</p>


<h3>Value</h3>

<p>A <a href="#topic+ChangeoClone">ChangeoClone</a> object containing the modified clone.
</p>


<h3>See Also</h3>

<p>Executes in order <a href="#topic+maskSeqGaps">maskSeqGaps</a>, <a href="#topic+maskSeqEnds">maskSeqEnds</a>, 
<a href="#topic+padSeqEnds">padSeqEnds</a>, and <a href="#topic+collapseDuplicates">collapseDuplicates</a>. 
Returns a <a href="#topic+ChangeoClone">ChangeoClone</a> object which serves as input to
<a href="#topic+buildPhylipLineage">buildPhylipLineage</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data
db &lt;- data.frame(sequence_id=LETTERS[1:4],
                 sequence_alignment=c("CCCCTGGG", "CCCCTGGN", "NAACTGGN", "NNNCTGNN"),
                 germline_alignment="CCCCAGGG",
                 v_call="Homsap IGKV1-39*01 F",
                 j_call="Homsap IGKJ5*01 F",
                 junction_length=2,
                 clone_id=1,
                 locus=rep("IGH", length=4),
                 c_call=c("IGHM", "IGHG", "IGHG", "IGHA"),
                 duplicate_count=1:4,
                 stringsAsFactors=FALSE)


 # Without end masking
 makeChangeoClone(db, text_fields="c_call", num_fields="duplicate_count")

 # With end masking
 makeChangeoClone(db, max_mask=3, text_fields="c_call", num_fields="duplicate_count")

</code></pre>

<hr>
<h2 id='makeTempDir'>Create a temporary folder</h2><span id='topic+makeTempDir'></span>

<h3>Description</h3>

<p><code>makeTempDir</code> creates a randomly named temporary folder in the 
system temp location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTempDir(prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTempDir_+3A_prefix">prefix</code></td>
<td>
<p>prefix name for the folder.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the temporary folder.
</p>


<h3>See Also</h3>

<p>This is just a wrapper for <a href="base.html#topic+tempfile">tempfile</a> and 
<a href="base.html#topic+dir.create">dir.create</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeTempDir("Clone50")

</code></pre>

<hr>
<h2 id='maskPositionsByQuality'>Mask sequence positions with low quality</h2><span id='topic+maskPositionsByQuality'></span>

<h3>Description</h3>

<p><code>maskPositionsByQuality</code> will replace positions that 
have a sequencing quality score lower that <code>min_quality</code> with an
<code>"N"</code> character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskPositionsByQuality(
  data,
  min_quality = 70,
  sequence = "sequence_alignment",
  quality_num = "quality_alignment_num"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskPositionsByQuality_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="maskPositionsByQuality_+3A_min_quality">min_quality</code></td>
<td>
<p>minimum quality score. Positions with sequencing quality 
less than <code>min_qual</code> will be masked.</p>
</td></tr>
<tr><td><code id="maskPositionsByQuality_+3A_sequence">sequence</code></td>
<td>
<p>column in <code>data</code> with sequence data to be masked.</p>
</td></tr>
<tr><td><code id="maskPositionsByQuality_+3A_quality_num">quality_num</code></td>
<td>
<p>column in <code>data</code> with quality scores (a
string of numeric values, comma separated) that can
be used to mask <code>sequence</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>data</code> data.frame with an additional field containing 
quality masked sequences. The  name of this field is created 
concatenating the <code>sequence</code> name and <code>"_masked"</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+readFastqDb">readFastqDb</a> and <a href="#topic+getPositionQuality">getPositionQuality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- airr::read_rearrangement(system.file("extdata", "example_quality.tsv", package="alakazam"))
fastq_file &lt;- system.file("extdata", "example_quality.fastq", package="alakazam")
db &lt;- readFastqDb(db, fastq_file, quality_offset=-33)
maskPositionsByQuality(db, min_quality=90, quality_num="quality_alignment_num")

</code></pre>

<hr>
<h2 id='maskSeqEnds'>Masks ragged leading and trailing edges of aligned DNA sequences</h2><span id='topic+maskSeqEnds'></span>

<h3>Description</h3>

<p><code>maskSeqEnds</code> takes a vector of DNA sequences, as character strings,
and replaces the leading and trailing characters with <code>"N"</code> characters to create 
a sequence vector with uniformly masked outer sequence segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskSeqEnds(seq, mask_char = "N", max_mask = NULL, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskSeqEnds_+3A_seq">seq</code></td>
<td>
<p>character vector of DNA sequence strings.</p>
</td></tr>
<tr><td><code id="maskSeqEnds_+3A_mask_char">mask_char</code></td>
<td>
<p>character to use for masking.</p>
</td></tr>
<tr><td><code id="maskSeqEnds_+3A_max_mask">max_mask</code></td>
<td>
<p>the maximum number of characters to mask. If set to 0 then
no masking will be performed. If set to <code>NULL</code> then the upper 
masking bound will be automatically determined from the maximum 
number of observed leading or trailing <code>"N"</code> characters amongst 
all strings in <code>seq</code>.</p>
</td></tr>
<tr><td><code id="maskSeqEnds_+3A_trim">trim</code></td>
<td>
<p>if <code>TRUE</code> leading and trailing characters will be cut rather 
than masked with <code>"N"</code> characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>seq</code> vector with masked (or optionally trimmed) sequences.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+maskSeqGaps">maskSeqGaps</a> for masking internal gaps.
See <a href="#topic+padSeqEnds">padSeqEnds</a> for padding sequence of unequal length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default behavior uniformly masks ragged ends
seq &lt;- c("CCCCTGGG", "NAACTGGN", "NNNCTGNN")
maskSeqEnds(seq)

# Does nothing
maskSeqEnds(seq, max_mask=0)

# Cut ragged sequence ends
maskSeqEnds(seq, trim=TRUE)

# Set max_mask to limit extent of masking and trimming
maskSeqEnds(seq, max_mask=1)
maskSeqEnds(seq, max_mask=1, trim=TRUE)

# Mask dashes instead of Ns
seq &lt;- c("CCCCTGGG", "-AACTGG-", "---CTG--")
maskSeqEnds(seq, mask_char="-")

</code></pre>

<hr>
<h2 id='maskSeqGaps'>Masks gap characters in DNA sequences</h2><span id='topic+maskSeqGaps'></span>

<h3>Description</h3>

<p><code>maskSeqGaps</code> substitutes gap characters, <code>c("-", ".")</code>, with <code>"N"</code> 
in a vector of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskSeqGaps(seq, mask_char = "N", outer_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskSeqGaps_+3A_seq">seq</code></td>
<td>
<p>character vector of DNA sequence strings.</p>
</td></tr>
<tr><td><code id="maskSeqGaps_+3A_mask_char">mask_char</code></td>
<td>
<p>character to use for masking.</p>
</td></tr>
<tr><td><code id="maskSeqGaps_+3A_outer_only">outer_only</code></td>
<td>
<p>if <code>TRUE</code> replace only contiguous leading and trailing gaps;
if <code>FALSE</code> replace all gap characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>seq</code> vector with <code>"N"</code> in place of <code>c("-", ".")</code> 
characters.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+maskSeqEnds">maskSeqEnds</a> for masking ragged edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mask with Ns
maskSeqGaps(c("ATG-C", "CC..C"))
maskSeqGaps("--ATG-C-")
maskSeqGaps("--ATG-C-", outer_only=TRUE)

# Mask with dashes
maskSeqGaps(c("ATG-C", "CC..C"), mask_char="-")

</code></pre>

<hr>
<h2 id='MRCATest-class'>S4 class defining edge significance</h2><span id='topic+MRCATest-class'></span><span id='topic+MRCATest'></span><span id='topic+print+2CMRCATest-method'></span><span id='topic+MRCATest-method'></span><span id='topic+plot+2CMRCATest+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>MRCATest</code> defines the significance of enrichment for annotations appearing at
the MRCA of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MRCATest'
print(x)

## S4 method for signature 'MRCATest,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRCATest-class_+3A_x">x</code></td>
<td>
<p>MRCATest object.</p>
</td></tr>
<tr><td><code id="MRCATest-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="MRCATest-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotMRCATest">plotMRCATest</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>tests</code></dt><dd><p>data.frame describing the significance test results with columns:
</p>

<ul>
<li>  <p><code>annotation</code>:  annotation value.
</p>
</li>
<li>  <p><code>count</code>:       observed count of MRCA positions 
with the given annotation.
</p>
</li>
<li>  <p><code>expected</code>:    expected mean count of MRCA occurance
for the annotation.
</p>
</li>
<li>  <p><code>pvalue</code>:      one-sided p-value for the hypothesis that 
the observed annotation abundance is greater 
than expected.
</p>
</li></ul>
</dd>
<dt><code>permutations</code></dt><dd><p>data.frame containing the raw permutation test data with columns:
</p>

<ul>
<li>  <p><code>annotation</code>:  annotation value.
</p>
</li>
<li>  <p><code>count</code>:       count of MRCA positions with the 
given annotation.
</p>
</li>
<li>  <p><code>iter</code>:        numerical index define which 
permutation realization each 
observation corresponds to.
</p>
</li></ul>
</dd>
<dt><code>nperm</code></dt><dd><p>number of permutation realizations.</p>
</dd>
</dl>

<hr>
<h2 id='nonsquareDist'>Calculate pairwise distances between sequences</h2><span id='topic+nonsquareDist'></span>

<h3>Description</h3>

<p><code>nonsquareDist</code> calculates all pairwise distance between a set of sequences and a subset of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonsquareDist(seq, indx, dist_mat = getDNAMatrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonsquareDist_+3A_seq">seq</code></td>
<td>
<p>character vector containing a DNA sequences. The sequence vector needs to
be named.</p>
</td></tr>
<tr><td><code id="nonsquareDist_+3A_indx">indx</code></td>
<td>
<p>numeric vector contating the indices (a subset of indices of <code>seq</code>).</p>
</td></tr>
<tr><td><code id="nonsquareDist_+3A_dist_mat">dist_mat</code></td>
<td>
<p>Character distance matrix. Defaults to a Hamming distance 
matrix returned by <a href="#topic+getDNAMatrix">getDNAMatrix</a>. If gap 
characters, <code>c("-", ".")</code>, are assigned a value of -1 
in <code>dist_mat</code> then contiguous gaps of any run length,
which are not present in both sequences, will be counted as a 
distance of 1. Meaning, indels of any length will increase
the sequence distance by 1. Gap values other than -1 will 
return a distance that does not consider indels as a special case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of numerical distance between each entry in <code>seq</code> and 
sequences specified by <code>indx</code> indices. 
</p>
<p>Note that the input subsampled indices will be ordered ascendingly. Therefore, 
it is necassary to assign unique names to the input sequences, <code>seq</code>, 
to recover the input order later. Row and columns names will be added accordingly.
</p>
<p>Amino acid distance matrix may be built with <a href="#topic+getAAMatrix">getAAMatrix</a>. 
Uses <a href="#topic+seqDist">seqDist</a> for calculating distances between pairs.
See <a href="#topic+pairwiseEqual">pairwiseEqual</a> for generating an equivalence matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaps will be treated as Ns with a gap=0 distance matrix
seq &lt;- c(A="ATGGC", B="ATGGG", C="ATGGG", D="AT--C")
pairwiseDist(seq, 
             dist_mat=getDNAMatrix(gap=0))

nonsquareDist(seq, indx=c(1,3), 
             dist_mat=getDNAMatrix(gap=0))

</code></pre>

<hr>
<h2 id='padSeqEnds'>Pads ragged ends of aligned DNA sequences</h2><span id='topic+padSeqEnds'></span>

<h3>Description</h3>

<p><code>padSeqEnds</code> takes a vector of DNA sequences, as character strings,
and appends the ends of each sequence with an appropriate number of <code>"N"</code> 
characters to create a sequence vector with uniform lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padSeqEnds(seq, len = NULL, start = FALSE, pad_char = "N", mod3 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padSeqEnds_+3A_seq">seq</code></td>
<td>
<p>character vector of DNA sequence strings.</p>
</td></tr>
<tr><td><code id="padSeqEnds_+3A_len">len</code></td>
<td>
<p>length to pad to. Only applies if longer than the maximum length of
the data in <code>seq</code>.</p>
</td></tr>
<tr><td><code id="padSeqEnds_+3A_start">start</code></td>
<td>
<p>if <code>TRUE</code> pad the beginning of each sequence instead of the end.</p>
</td></tr>
<tr><td><code id="padSeqEnds_+3A_pad_char">pad_char</code></td>
<td>
<p>character to use for padding.</p>
</td></tr>
<tr><td><code id="padSeqEnds_+3A_mod3">mod3</code></td>
<td>
<p>if <code>TRUE</code> pad sequences to be of length multiple three.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>seq</code> vector with padded sequences.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+maskSeqEnds">maskSeqEnds</a> for creating uniform masking from existing masking.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default behavior uniformly pads ragged ends
seq &lt;- c("CCCCTGGG", "ACCCTG", "CCCC")
padSeqEnds(seq)

# Pad to fixed length
padSeqEnds(seq, len=15)

# Add padding to the beginning of the sequences instead of the ends
padSeqEnds(seq, start=TRUE)
padSeqEnds(seq, len=15, start=TRUE)

</code></pre>

<hr>
<h2 id='pairwiseDist'>Calculate pairwise distances between sequences</h2><span id='topic+pairwiseDist'></span>

<h3>Description</h3>

<p><code>pairwiseDist</code> calculates all pairwise distance between a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseDist(seq, dist_mat = getDNAMatrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseDist_+3A_seq">seq</code></td>
<td>
<p>character vector containing a DNA sequences.</p>
</td></tr>
<tr><td><code id="pairwiseDist_+3A_dist_mat">dist_mat</code></td>
<td>
<p>Character distance matrix. Defaults to a Hamming distance 
matrix returned by <a href="#topic+getDNAMatrix">getDNAMatrix</a>. If gap 
characters, <code>c("-", ".")</code>, are assigned a value of -1 
in <code>dist_mat</code> then contiguous gaps of any run length,
which are not present in both sequences, will be counted as a 
distance of 1. Meaning, indels of any length will increase
the sequence distance by 1. Gap values other than -1 will 
return a distance that does not consider indels as a special case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of numerical distance between each entry in <code>seq</code>. 
If <code>seq</code> is a named vector, row and columns names will be added 
accordingly.
</p>
<p>Amino acid distance matrix may be built with <a href="#topic+getAAMatrix">getAAMatrix</a>. 
Uses <a href="#topic+seqDist">seqDist</a> for calculating distances between pairs.
See <a href="#topic+pairwiseEqual">pairwiseEqual</a> for generating an equivalence matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaps will be treated as Ns with a gap=0 distance matrix
pairwiseDist(c(A="ATGGC", B="ATGGG", C="ATGGG", D="AT--C"), 
             dist_mat=getDNAMatrix(gap=0))

# Gaps will be treated as universally non-matching characters with gap=1
pairwiseDist(c(A="ATGGC", B="ATGGG", C="ATGGG", D="AT--C"), 
             dist_mat=getDNAMatrix(gap=1))

# Gaps of any length will be treated as single mismatches with a gap=-1 distance matrix
pairwiseDist(c(A="ATGGC", B="ATGGG", C="ATGGG", D="AT--C"), 
             dist_mat=getDNAMatrix(gap=-1))

</code></pre>

<hr>
<h2 id='pairwiseEqual'>Calculate pairwise equivalence between sequences</h2><span id='topic+pairwiseEqual'></span>

<h3>Description</h3>

<p><code>pairwiseEqual</code> determined pairwise equivalence between a pairs in a 
set of sequences, excluding ambiguous positions (Ns and gaps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseEqual(seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseEqual_+3A_seq">seq</code></td>
<td>
<p>character vector containing a DNA sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix of equivalence between each entry in <code>seq</code>. 
Values are <code>TRUE</code> when sequences are equivalent and <code>FALSE</code>
when they are not.
</p>


<h3>See Also</h3>

<p>Uses <a href="#topic+seqEqual">seqEqual</a> for testing equivalence between pairs.
See <a href="#topic+pairwiseDist">pairwiseDist</a> for generating a sequence distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaps and Ns will match any character
seq &lt;- c(A="ATGGC", B="ATGGG", C="ATGGG", D="AT--C", E="NTGGG")
d &lt;- pairwiseEqual(seq)
rownames(d) &lt;- colnames(d) &lt;- seq
d

</code></pre>

<hr>
<h2 id='permuteLabels'>Permute the node labels of a tree</h2><span id='topic+permuteLabels'></span>

<h3>Description</h3>

<p><code>permuteLabels</code> permutes the node annotations of a lineage tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteLabels(graph, field, exclude = c("Germline", NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteLabels_+3A_graph">graph</code></td>
<td>
<p>igraph object containing an annotated lineage tree.</p>
</td></tr>
<tr><td><code id="permuteLabels_+3A_field">field</code></td>
<td>
<p>string defining the annotation field to permute.</p>
</td></tr>
<tr><td><code id="permuteLabels_+3A_exclude">exclude</code></td>
<td>
<p>vector of strings defining <code>field</code> values to exclude 
from permutation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified igraph object with vertex annotations permuted.
</p>


<h3>See Also</h3>

<p><a href="#topic+testEdges">testEdges</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define and plot example graph
library(igraph)
graph &lt;- ExampleTrees[[23]]
plot(graph, layout=layout_as_tree, vertex.label=V(graph)$c_call, 
     vertex.size=50, edge.arrow.mode=0, vertex.color="grey80")

# Permute annotations and plot new tree
g &lt;- permuteLabels(graph, "c_call")
plot(g, layout=layout_as_tree, vertex.label=V(g)$c_call,
     vertex.size=50, edge.arrow.mode=0, vertex.color="grey80")

</code></pre>

<hr>
<h2 id='phyloToGraph'>Convert a tree in ape <code>phylo</code> format to igraph <code>graph</code> format.</h2><span id='topic+phyloToGraph'></span>

<h3>Description</h3>

<p><code>phyloToGraph</code> converts a tree in <code>phylo</code> format to and 
<code>graph</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloToGraph(phylo, germline = "Germline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloToGraph_+3A_phylo">phylo</code></td>
<td>
<p>An ape <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phyloToGraph_+3A_germline">germline</code></td>
<td>
<p>If specified, places specified tip sequence as the direct 
ancestor of the tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert from phylo to graph object. Uses the node.label vector to label internal nodes. Nodes 
may rotate but overall topology will remain constant.
</p>


<h3>Value</h3>

<p>A <code>graph</code> object representing the input tree.
</p>


<h3>References</h3>


<ol>
<li><p>  Hoehn KB, Lunter G, Pybus OG - A Phylogenetic Codon Substitution Model for Antibody 
Lineages. Genetics 2017 206(1):417-427
https://doi.org/10.1534/genetics.116.196303 
</p>
</li>
<li><p>  Hoehn KB, Vander Heiden JA, Zhou JQ, Lunter G, Pybus OG, Kleinstein SHK - 
Repertoire-wide phylogenetic models of B cell molecular evolution reveal 
evolutionary signatures of aging and vaccination. bioRxiv 2019  
https://doi.org/10.1101/558825 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   library(igraph)
   library(ape)

   #convert to phylo
   phylo = graphToPhylo(graph)
   
   #plot tree using ape
   plot(phylo,show.node.label=TRUE)
   
   #store as newick tree
   write.tree(phylo,file="tree.newick")
   
   #read in tree from newick file
   phylo_r = read.tree("tree.newick")
   
   #convert to igraph
   graph_r = phyloToGraph(phylo_r,germline="Germline")
   
   #plot graph - same as before, possibly rotated
   plot(graph_r,layout=layout_as_tree)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotAbundanceCurve'>Plot a clonal abundance distribution</h2><span id='topic+plotAbundanceCurve'></span>

<h3>Description</h3>

<p><code>plotAbundanceCurve</code> plots the results from estimating the complete clonal 
relative abundance distribution. The distribution is plotted as a log rank abundance 
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAbundanceCurve(
  data,
  colors = NULL,
  main_title = "Rank Abundance",
  legend_title = NULL,
  xlim = NULL,
  ylim = NULL,
  annotate = c("none", "depth"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAbundanceCurve_+3A_data">data</code></td>
<td>
<p><a href="#topic+AbundanceCurve">AbundanceCurve</a> object returned by <a href="#topic+estimateAbundance">estimateAbundance</a>.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_colors">colors</code></td>
<td>
<p>named character vector whose names are values in the 
<code>group</code> column of <code>data</code> and whose values are 
colors to assign to those group names.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_legend_title">legend_title</code></td>
<td>
<p>string specifying the legend title.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of two values specifying the 
<code>c(lower, upper)</code> x-axis limits. The lower x-axis 
value must be &gt;=1.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of two values specifying the 
<code>c(lower, upper)</code> y-axis limits. The limits on the 
abundance values are expressed as fractions of 1: use
c(0,1) to set the lower and upper limits to 0% and 100%.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_annotate">annotate</code></td>
<td>
<p>string defining whether to added values to the group labels 
of the legend. When <code>"none"</code> (default) is specified no
annotations are added. Specifying (<code>"depth"</code>) adds 
sequence counts to the labels.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotAbundanceCurve_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+AbundanceCurve">AbundanceCurve</a> for the input object and <a href="#topic+estimateAbundance">estimateAbundance</a> for
generating the input abundance distribution. Plotting is performed with <a href="ggplot2.html#topic+ggplot">ggplot</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate abundance by sample and plot
abund &lt;- estimateAbundance(ExampleDb, group="sample_id", nboot=100)
plotAbundanceCurve(abund, legend_title="Sample")

</code></pre>

<hr>
<h2 id='plotDiversityCurve'>Plot the results of alphaDiversity</h2><span id='topic+plotDiversityCurve'></span>

<h3>Description</h3>

<p><code>plotDiversityCurve</code> plots a <code>DiversityCurve</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiversityCurve(
  data,
  colors = NULL,
  main_title = "Diversity",
  legend_title = "Group",
  log_x = FALSE,
  log_y = FALSE,
  xlim = NULL,
  ylim = NULL,
  annotate = c("none", "depth"),
  score = c("diversity", "evenness"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiversityCurve_+3A_data">data</code></td>
<td>
<p><a href="#topic+DiversityCurve">DiversityCurve</a> object returned by 
<a href="#topic+alphaDiversity">alphaDiversity</a>.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_colors">colors</code></td>
<td>
<p>named character vector whose names are values in the 
<code>group</code> column of the <code>data</code> slot of <code>data</code>,
and whose values are colors to assign to those group names.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_legend_title">legend_title</code></td>
<td>
<p>string specifying the legend title.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_log_x">log_x</code></td>
<td>
<p>if <code>TRUE</code> then plot <code class="reqn">q</code> on a log scale;
if <code>FALSE</code> plot on a linear scale.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_log_y">log_y</code></td>
<td>
<p>if <code>TRUE</code> then plot the diversity/evenness scores 
on a log scale; if <code>FALSE</code> plot on a linear scale.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of two values specifying the 
<code>c(lower, upper)</code> x-axis limits.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of two values specifying the 
<code>c(lower, upper)</code> y-axis limits.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_annotate">annotate</code></td>
<td>
<p>string defining whether to added values to the group labels 
of the legend. When <code>"none"</code> (default) is specified no
annotations are added. Specifying (<code>"depth"</code>) adds 
sequence counts to the labels.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_score">score</code></td>
<td>
<p>one of <code>"diversity"</code> or <code>"evenness"</code> specifying which
score to plot on the y-asis.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotDiversityCurve_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+alphaDiversity">alphaDiversity</a> and <a href="#topic+alphaDiversity">alphaDiversity</a> for generating 
<a href="#topic+DiversityCurve">DiversityCurve</a> objects for input. Plotting is performed with <a href="ggplot2.html#topic+ggplot">ggplot</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate diversity
div &lt;- alphaDiversity(ExampleDb, group="sample_id", nboot=100)

# Plot diversity
plotDiversityCurve(div, legend_title="Sample")

# Plot diversity
plotDiversityCurve(div, legend_title="Sample", score="evenness")

</code></pre>

<hr>
<h2 id='plotDiversityTest'>Plot the results of diversity testing</h2><span id='topic+plotDiversityTest'></span>

<h3>Description</h3>

<p><code>plotDiversityTest</code> plots summary data for a <code>DiversityCurve</code> object 
with mean and a line range indicating plus/minus one standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiversityTest(
  data,
  q,
  colors = NULL,
  main_title = "Diversity",
  legend_title = "Group",
  log_d = FALSE,
  annotate = c("none", "depth"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiversityTest_+3A_data">data</code></td>
<td>
<p><a href="#topic+DiversityCurve">DiversityCurve</a> object returned by 
<a href="#topic+alphaDiversity">alphaDiversity</a>.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_q">q</code></td>
<td>
<p>diversity order to plot the test for.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_colors">colors</code></td>
<td>
<p>named character vector whose names are values in the 
<code>group</code> column of the <code>data</code> slot of <code>data</code>,
and whose values are colors to assign to those group names.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_legend_title">legend_title</code></td>
<td>
<p>string specifying the legend title.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_log_d">log_d</code></td>
<td>
<p>if <code>TRUE</code> then plot the diversity scores <code class="reqn">D</code> 
on a log scale; if <code>FALSE</code> plot on a linear scale.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_annotate">annotate</code></td>
<td>
<p>string defining whether to added values to the group labels 
of the legend. When <code>"none"</code> (default) is specified no
annotations are added. Specifying (<code>"depth"</code>) adds 
sequence counts to the labels.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotDiversityTest_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+alphaDiversity">alphaDiversity</a> for generating input.
Plotting is performed with <a href="ggplot2.html#topic+ggplot">ggplot</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate diversity
div &lt;- alphaDiversity(ExampleDb, group="sample_id", min_q=0, max_q=2, step_q=1, nboot=100)

# Plot results at q=0 (equivalent to species richness)
plotDiversityTest(div, 0, legend_title="Sample")

# Plot results at q=2 (equivalent to Simpson's index)
plotDiversityTest(div, q=2, legend_title="Sample")

</code></pre>

<hr>
<h2 id='plotEdgeTest'>Plot the results of an edge permutation test</h2><span id='topic+plotEdgeTest'></span>

<h3>Description</h3>

<p><code>plotEdgeTest</code> plots the results of an edge permutation test performed with 
<code>testEdges</code> as either a histogram or cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEdgeTest(
  data,
  color = "black",
  main_title = "Edge Test",
  style = c("histogram", "cdf"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEdgeTest_+3A_data">data</code></td>
<td>
<p><a href="#topic+EdgeTest">EdgeTest</a> object returned by <a href="#topic+testEdges">testEdges</a>.</p>
</td></tr>
<tr><td><code id="plotEdgeTest_+3A_color">color</code></td>
<td>
<p>color of the histogram or lines.</p>
</td></tr>
<tr><td><code id="plotEdgeTest_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotEdgeTest_+3A_style">style</code></td>
<td>
<p>type of plot to draw. One of:
</p>

<ul>
<li> <p><code>"histogram"</code>:  histogram of the edge count 
distribution with a red dotted line
denoting the observed value.
</p>
</li>
<li> <p><code>"cdf"</code>:        cumulative distribution function 
of edge counts with a red dotted 
line denoting the observed value and
a blue dotted line indicating the 
p-value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotEdgeTest_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotEdgeTest_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+testEdges">testEdges</a> for performing the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define example tree set
graphs &lt;- ExampleTrees[6:10]

# Perform edge test on isotypes
x &lt;- testEdges(graphs, "c_call", nperm=6)

# Plot
plotEdgeTest(x, color="steelblue", style="hist")
plotEdgeTest(x, style="cdf")


</code></pre>

<hr>
<h2 id='plotMRCATest'>Plot the results of a founder permutation test</h2><span id='topic+plotMRCATest'></span>

<h3>Description</h3>

<p><code>plotMRCATest</code> plots the results of a founder permutation test performed with 
<code>testMRCA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMRCATest(
  data,
  color = "black",
  main_title = "MRCA Test",
  style = c("histogram", "cdf"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMRCATest_+3A_data">data</code></td>
<td>
<p><a href="#topic+MRCATest">MRCATest</a> object returned by <a href="#topic+testMRCA">testMRCA</a>.</p>
</td></tr>
<tr><td><code id="plotMRCATest_+3A_color">color</code></td>
<td>
<p>color of the histogram or lines.</p>
</td></tr>
<tr><td><code id="plotMRCATest_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotMRCATest_+3A_style">style</code></td>
<td>
<p>type of plot to draw. One of:
</p>

<ul>
<li> <p><code>"histogram"</code>:  histogram of the annotation count 
distribution with a red dotted line
denoting the observed value.
</p>
</li>
<li> <p><code>"cdf"</code>:        cumulative distribution function 
of annotation counts with a red dotted 
line denoting the observed value and
a blue dotted line indicating the 
p-value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotMRCATest_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotMRCATest_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+testEdges">testEdges</a> for performing the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define example tree set
graphs &lt;- ExampleTrees[1:10]

# Perform MRCA test on isotypes
x &lt;- testMRCA(graphs, "c_call", nperm=10)

# Plot
plotMRCATest(x, color="steelblue", style="hist")
plotMRCATest(x, style="cdf")


</code></pre>

<hr>
<h2 id='plotSubtrees'>Plots subtree statistics for multiple trees</h2><span id='topic+plotSubtrees'></span>

<h3>Description</h3>

<p><code>plotSubtree</code> plots distributions of normalized subtree statistics for a 
set of lineage trees, broken down by annotation value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSubtrees(
  graphs,
  field,
  stat,
  root = "Germline",
  exclude = c("Germline", NA),
  colors = NULL,
  main_title = "Subtrees",
  legend_title = "Annotation",
  style = c("box", "violin"),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSubtrees_+3A_graphs">graphs</code></td>
<td>
<p>list of igraph objects containing annotated lineage trees.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_field">field</code></td>
<td>
<p>string defining the annotation field.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_stat">stat</code></td>
<td>
<p>string defining the subtree statistic to plot. One of:
</p>

<ul>
<li>  <p><code>outdegree</code>:   distribution of normalized node 
outdegrees.
</p>
</li>
<li>  <p><code>size</code>:        distribution of normalized subtree sizes.
</p>
</li>
<li>  <p><code>depth</code>:       distribution of subtree depths.
</p>
</li>
<li>  <p><code>pathlength</code>:  distribution of maximum pathlength 
beneath nodes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_root">root</code></td>
<td>
<p>name of the root (germline) node.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_exclude">exclude</code></td>
<td>
<p>vector of strings defining <code>field</code> values to exclude from
plotting.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_colors">colors</code></td>
<td>
<p>named vector of colors for values in <code>field</code>, with 
names defining annotation names <code>field</code> column and values
being colors. Also controls the order in which values appear on the
plot. If <code>NULL</code> alphabetical ordering and a default color palette 
will be used.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_main_title">main_title</code></td>
<td>
<p>string specifying the plot title.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_legend_title">legend_title</code></td>
<td>
<p>string specifying the legend title.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_style">style</code></td>
<td>
<p>string specifying the style of plot to draw. One of:
</p>

<ul>
<li> <p><code>"histogram"</code>:  histogram of the annotation count 
distribution with a red dotted line
denoting the observed value.
</p>
</li>
<li> <p><code>"cdf"</code>:        cumulative distribution function 
of annotation counts with a red 
dotted line denoting the observed 
value and a blue dotted line 
indicating the p-value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotSubtrees_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object defining the plot.
</p>


<h3>See Also</h3>

<p>Subtree statistics are calculated with <a href="#topic+summarizeSubtrees">summarizeSubtrees</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example tree set
graphs &lt;- ExampleTrees[1:10]

# Violin plots of node outdegree by sample
plotSubtrees(graphs, "sample_id", "out", style="v")

# Violin plots of subtree size by sample
plotSubtrees(graphs, "sample_id", "size", style="v")

# Boxplot of node depth by isotype
plotSubtrees(graphs, "c_call", "depth", style="b")

</code></pre>

<hr>
<h2 id='polar'>Calculates the average polarity of amino acid sequences</h2><span id='topic+polar'></span>

<h3>Description</h3>

<p><code>polar</code> calculates the average polarity score of amino acid sequences. 
Non-informative positions are excluded, where non-informative is defined as any 
character in <code>c("X", "-", ".", "*")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar(seq, polarity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polar_+3A_seq">seq</code></td>
<td>
<p>vector of strings containing amino acid sequences.</p>
</td></tr>
<tr><td><code id="polar_+3A_polarity">polarity</code></td>
<td>
<p>named numerical vector defining polarity scores for 
each amino acid, where names are single-letter amino acid 
character codes. If <code>NULL</code>, then the Grantham, 1974
scale is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of bulkiness scores for the sequence(s).
</p>


<h3>References</h3>


<ol>
<li><p>  Grantham R. Amino acid difference formula to help explain protein evolution. 
Science 185, 862-864 (1974).
</p>
</li></ol>



<h3>See Also</h3>

<p>For additional size related indices see <code><a href="seqinr.html#topic+aaindex">aaindex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default scale
seq &lt;- c("CARDRSTPWRRGIASTTVRTSW", "XXTQMYVRT")
polar(seq)

# Use the Zimmerman et al, 1968 polarity scale from the seqinr package
library(seqinr)
data(aaindex)
x &lt;- aaindex[["ZIMJ680103"]]$I
# Rename the score vector to use single-letter codes
names(x) &lt;- translateStrings(names(x), ABBREV_AA)
# Calculate polarity
polar(seq, polarity=x)

</code></pre>

<hr>
<h2 id='progressBar'>Standard progress bar</h2><span id='topic+progressBar'></span>

<h3>Description</h3>

<p><code>progressBar</code> defines a common progress bar format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progressBar(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progressBar_+3A_n">n</code></td>
<td>
<p>maximum number of ticks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="progress.html#topic+progress_bar">progress_bar</a> object.
</p>

<hr>
<h2 id='rarefyDiversity'>Generate a clonal diversity index curve</h2><span id='topic+rarefyDiversity'></span>

<h3>Description</h3>

<p><code>rarefyDiversity</code> divides a set of clones by a group annotation,
resamples the sequences from each group, and calculates diversity
scores (<code class="reqn">D</code>) over an interval of diversity orders (<code class="reqn">q</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarefyDiversity(
  data,
  group,
  clone = "CLONE",
  copy = NULL,
  min_q = 0,
  max_q = 4,
  step_q = 0.05,
  min_n = 30,
  max_n = NULL,
  ci = 0.95,
  nboot = 2000,
  uniform = TRUE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarefyDiversity_+3A_data">data</code></td>
<td>
<p>data.frame with Change-O style columns containing clonal assignments.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_group">group</code></td>
<td>
<p>name of the <code>data</code> column containing group identifiers.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_clone">clone</code></td>
<td>
<p>name of the <code>data</code> column containing clone identifiers.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_copy">copy</code></td>
<td>
<p>name of the <code>data</code> column containing copy numbers for each 
sequence. If <code>copy=NULL</code> (the default), then clone abundance
is determined by the number of sequences. If a <code>copy</code> column
is specified, then clone abundances is determined by the sum of 
copy numbers within each clonal group.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_min_q">min_q</code></td>
<td>
<p>minimum value of <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_max_q">max_q</code></td>
<td>
<p>maximum value of <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_step_q">step_q</code></td>
<td>
<p>value by which to increment <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_min_n">min_n</code></td>
<td>
<p>minimum number of observations to sample.
A group with less observations than the minimum is excluded.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_max_n">max_n</code></td>
<td>
<p>maximum number of observations to sample. If <code>NULL</code> then no 
maximum is set.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_ci">ci</code></td>
<td>
<p>confidence interval to calculate; the value must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap realizations to generate.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_uniform">uniform</code></td>
<td>
<p>if <code>TRUE</code> then uniformly resample each group to the same 
number of observations. If <code>FALSE</code> then allow each group to
be resampled to its original size or, if specified, <code>max_size</code>.</p>
</td></tr>
<tr><td><code id="rarefyDiversity_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> show a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clonal diversity is calculated using the generalized diversity index (Hill numbers) 
proposed by Hill (Hill, 1973). See <a href="#topic+calcDiversity">calcDiversity</a> for further details.
</p>
<p>Diversity is calculated on the estimated complete clonal abundance distribution.
This distribution is inferred by using the Chao1 estimator to estimate the number
of seen clones, and applying the relative abundance correction and unseen clone
frequency described in Chao et al, 2015.
</p>
<p>To generate a smooth curve, <code class="reqn">D</code> is calculated for each value of <code class="reqn">q</code> from
<code>min_q</code> to <code>max_q</code> incremented by <code>step_q</code>.  When <code>uniform=TRUE</code>
variability in total sequence counts across unique values in the <code>group</code> column 
is corrected by repeated resampling from the estimated complete clonal distribution to a 
common number of sequences.
</p>
<p>The diversity index (<code class="reqn">D</code>) for each group is the mean value of over all resampling 
realizations. Confidence intervals are derived using the standard deviation of the 
resampling realizations, as described in Chao et al, 2015.
</p>


<h3>Value</h3>

<p>A <a href="#topic+DiversityCurve">DiversityCurve</a> object summarizing the diversity scores.
</p>


<h3>References</h3>


<ol>
<li><p>  Hill M. Diversity and evenness: a unifying notation and its consequences. 
Ecology. 1973 54(2):427-32.
</p>
</li>
<li><p>  Chao A. Nonparametric Estimation of the Number of Classes in a Population. 
Scand J Stat. 1984 11, 265270.
</p>
</li>
<li><p>  Chao A, et al. Rarefaction and extrapolation with Hill numbers: 
A framework for sampling and estimation in species diversity studies. 
Ecol Monogr. 2014 84:45-67.
</p>
</li>
<li><p>  Chao A, et al. Unveiling the species-rank abundance distribution by 
generalizing the Good-Turing sample coverage theory. 
Ecology. 2015 96, 11891201.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+alphaDiversity">alphaDiversity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Group by sample identifier
div &lt;- rarefyDiversity(ExampleDb, "sample_id", step_q=1, max_q=10, nboot=100)
plotDiversityCurve(div, legend_title="Sample")
                   
# Grouping by isotype rather than sample identifier
div &lt;- rarefyDiversity(ExampleDb, "c_call", min_n=40, step_q=1, max_q=10, 
                       nboot=100)
plotDiversityCurve(div, legend_title="Isotype")

## End(Not run)
</code></pre>

<hr>
<h2 id='readChangeoDb'>Read a Change-O tab-delimited database file</h2><span id='topic+readChangeoDb'></span>

<h3>Description</h3>

<p><code>readChangeoDb</code> reads a tab-delimited database file created by a Change-O tool 
into a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readChangeoDb(file, select = NULL, drop = NULL, seq_upper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readChangeoDb_+3A_file">file</code></td>
<td>
<p>tab-delimited database file output by a Change-O tool.</p>
</td></tr>
<tr><td><code id="readChangeoDb_+3A_select">select</code></td>
<td>
<p>columns to select from database file.</p>
</td></tr>
<tr><td><code id="readChangeoDb_+3A_drop">drop</code></td>
<td>
<p>columns to drop from database file.</p>
</td></tr>
<tr><td><code id="readChangeoDb_+3A_seq_upper">seq_upper</code></td>
<td>
<p>if <code>TRUE</code> convert sequence columns to upper case;
if <code>FALSE</code> do not alter sequence columns. See Value 
for a list of which columns are effected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of the database file. Columns will be imported as is, except for 
the following columns which will be explicitly converted into character 
values:
</p>

<ul>
<li><p>  SEQUENCE_ID
</p>
</li>
<li><p>  CLONE
</p>
</li>
<li><p>  SAMPLE
</p>
</li></ul>

<p>And the following sequence columns which will converted to upper case if
<code>seq_upper=TRUE</code> (default).
</p>

<ul>
<li><p>  SEQUENCE_INPUT
</p>
</li>
<li><p>  SEQUENCE_VDJ
</p>
</li>
<li><p>  SEQUENCE_IMGT
</p>
</li>
<li><p>  JUNCTION
</p>
</li>
<li><p>  GERMLINE_IMGT
</p>
</li>
<li><p>  GERMLINE_IMGT_D_MASK
</p>
</li></ul>



<h3>See Also</h3>

<p>Wraps <a href="readr.html#topic+read_delim">read_delim</a>. 
See <a href="#topic+writeChangeoDb">writeChangeoDb</a> for writing to Change-O files.
See <a href="airr.html#topic+read_rearrangement">read_rearrangement</a> and <a href="airr.html#topic+write_rearrangement">write_rearrangement</a>
to read and write AIRR-C Standard formatted repertoires.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read all columns in and convert sequence fields to upper case
    db &lt;- readChangeoDb("changeo.tsv")

    # Subset columns and convert sequence fields to upper case
    db &lt;- readChangeoDb("changeo.tsv", select=c("SEQUENCE_ID", "SEQUENCE_IMGT"))

    # Drop columns and do not alter sequence field case
    db &lt;- readChangeoDb("changeo.tsv", drop=c("D_CALL", "DUPCOUNT"), 
                        seq_upper=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='readFastqDb'>Load sequencing quality scores from a FASTQ file</h2><span id='topic+readFastqDb'></span>

<h3>Description</h3>

<p><code>readFastqDb</code> adds the sequencing quality scores to a data.frame
from a FASTQ file. Matching is done by 'sequence_id'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFastqDb(
  data,
  fastq_file,
  quality_offset = -33,
  header = c("presto", "asis"),
  sequence_id = "sequence_id",
  sequence = "sequence",
  sequence_alignment = "sequence_alignment",
  v_cigar = "v_cigar",
  d_cigar = "d_cigar",
  j_cigar = "j_cigar",
  np1_length = "np1_length",
  np2_length = "np2_length",
  v_sequence_end = "v_sequence_end",
  d_sequence_end = "d_sequence_end",
  style = c("num", "ascii", "both"),
  quality_sequence = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFastqDb_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_fastq_file">fastq_file</code></td>
<td>
<p>path to the fastq file</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_quality_offset">quality_offset</code></td>
<td>
<p>offset value to be used by ape::read.fastq. It is 
the value to be added to the quality scores 
(the default -33 applies to the Sanger format and 
should work for most recent FASTQ files).</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_header">header</code></td>
<td>
<p>FASTQ file header format; one of <code>"presto"</code> or 
<code>"asis"</code>. Use <code>"presto"</code> to specify 
that the fastq file headers are using the pRESTO
format and can be parsed to extract 
the <code>sequence_id</code>. Use <code>"asis"</code> to skip 
any processing and use the sequence names as they are.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_sequence_id">sequence_id</code></td>
<td>
<p>column in <code>data</code> that contains sequence 
identifiers to be matched to sequence identifiers in 
<code>fastq_file</code>.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_sequence">sequence</code></td>
<td>
<p>column in <code>data</code> that contains sequence data.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_sequence_alignment">sequence_alignment</code></td>
<td>
<p>column in <code>data</code> that contains IMGT aligned sequence data.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_v_cigar">v_cigar</code></td>
<td>
<p>column in <code>data</code> that contains CIGAR 
strings for the V gene alignments.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_d_cigar">d_cigar</code></td>
<td>
<p>column in <code>data</code> that contains CIGAR 
strings for the D gene alignments.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_j_cigar">j_cigar</code></td>
<td>
<p>column in <code>data</code> that contains CIGAR 
strings for the J gene alignments.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_np1_length">np1_length</code></td>
<td>
<p>column in <code>data</code> that contains the number
of nucleotides between the V gene and first D gene 
alignments or between the V gene and J gene alignments.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_np2_length">np2_length</code></td>
<td>
<p>column in <code>data</code> that contains the number
of nucleotides between either the first D gene and J 
gene alignments or the first D gene and second D gene
alignments.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_v_sequence_end">v_sequence_end</code></td>
<td>
<p>column in <code>data</code> that contains the 
end position of the V gene in <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_d_sequence_end">d_sequence_end</code></td>
<td>
<p>column in <code>data</code> that contains the 
end position of the D gene in <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_style">style</code></td>
<td>
<p>how the sequencing quality should be returned;
one of <code>"num"</code>, <code>"phred"</code>, or <code>"both"</code>.
Specify <code>"num"</code> to store the quality scores as strings of 
comma separated numeric values. Use <code>"phred"</code> to have
the function return the scores as Phred (ASCII) scores. 
Use <code>"both"</code> to retrieve both.</p>
</td></tr>
<tr><td><code id="readFastqDb_+3A_quality_sequence">quality_sequence</code></td>
<td>
<p>specify <code>TRUE</code> to keep the quality scores for 
<code>sequence</code>. If false, only the quality score
for <code>sequence_alignment</code> will be added to <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>data</code> with additional fields:
</p>

<ol>
<li> <p><code>quality_alignment</code>:     A character vector with ASCII Phred 
scores for <code>sequence_alignment</code>.
</p>
</li>
<li> <p><code>quality_alignment_num</code>: A character vector, with comma separated 
numerical quality values for each 
position in <code>sequence_alignment</code>.
</p>
</li>
<li> <p><code>quality</code>:      A character vector with ASCII Phred 
scores for <code>sequence</code>.
</p>
</li>
<li> <p><code>quality_num</code>:  A character vector, with comma separated 
numerical quality values for each 
position in <code>sequence</code>.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+maskPositionsByQuality">maskPositionsByQuality</a> and <a href="#topic+getPositionQuality">getPositionQuality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- airr::read_rearrangement(system.file("extdata", "example_quality.tsv", package="alakazam"))
fastq_file &lt;- system.file("extdata", "example_quality.fastq", package="alakazam")
db &lt;- readFastqDb(db, fastq_file, quality_offset=-33)

</code></pre>

<hr>
<h2 id='readIgphyml'>Read in output from IgPhyML</h2><span id='topic+readIgphyml'></span>

<h3>Description</h3>

<p><code>readIgphyml</code> reads output from the IgPhyML phylogenetics inference package for 
B cell repertoires
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIgphyml(
  file,
  id = NULL,
  format = c("graph", "phylo"),
  collapse = FALSE,
  branches = c("mutations", "distance")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readIgphyml_+3A_file">file</code></td>
<td>
<p>IgPhyML output file (.tab).</p>
</td></tr>
<tr><td><code id="readIgphyml_+3A_id">id</code></td>
<td>
<p>ID to assign to output object.</p>
</td></tr>
<tr><td><code id="readIgphyml_+3A_format">format</code></td>
<td>
<p>if <code>"graph"</code> return trees as igraph <code>graph</code> objects. 
if <code>"phylo"</code> return trees as ape <code>phylo</code> objects.</p>
</td></tr>
<tr><td><code id="readIgphyml_+3A_collapse">collapse</code></td>
<td>
<p>if <code>TRUE</code> transform branch lengths to units of substitutions, 
rather than substitutions per site, and collapse internal nodes
separated by branches &lt; 0.1 substitutions. Will also remove all
internal node labels, as it makes them inconsistent.</p>
</td></tr>
<tr><td><code id="readIgphyml_+3A_branches">branches</code></td>
<td>
<p>if <code>"distance"</code> branch lengths are in expected mutations per
site. If <code>"mutations"</code> branches are in expected mutations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readIgphyml</code> reads output from the IgPhyML repertoire phylogenetics inference package. 
The resulting object is divded between parameter estimates (usually under the HLP19 model),
which provide information about mutation and selection pressure operating on the sequences.
</p>
<p>Trees returned from this function are either igraph objects or phylo objects, and each may be 
visualized accordingly. Futher, branch lengths in tree may represent either the expected number of
substitutions per site (codon, if estimated under HLP or GY94 models), or the total number of 
expected substitutions per site. If the latter, internal nodes - but not tips - separated by branch
lengths less than 0.1 are collapsed to simplify viewing.
</p>


<h3>Value</h3>

<p>A list containing IgPhyML model parameters and estimated lineage trees. 
</p>
<p>Object attributes:
</p>

<ul>
<li>  <p><code>param</code>:     Data.frame of parameter estimates for each clonal 
lineage. Columns include: <code>CLONE</code>, which is the 
clone id; <code>NSEQ</code>, the total number of sequences in 
the lineage; <code>NSITE</code>, the number of codon sites;
<code>TREE_LENGTH</code>, the sum of all branch lengths in 
the estimated lineage tree; and <code>LHOOD</code>, the log 
likelihood of the clone's sequences given the tree and
parameters. Subsequent columns are parameter estimates 
from IgPhyML, which will depend on the model used. 
Parameter columns ending with <code>_MLE</code> are maximum 
likelihood estimates; those ending with <code>_LCI</code> are 
the lower 95
with <code>_UCI</code> are the upper 95
estimate. The first line of <code>param</code> is for clone 
<code>REPERTOIRE</code>, 
which is a summary of all lineages within the repertoire.
For this row, <code>NSEQ</code> is the total number of sequences, 
<code>NSITE</code> is the average number of sites, and
<code>TREE_LENGTH</code> is the mean tree length. For most 
applications, parameter values will be the same for all 
lineages within the repertoire, so access them simply by:
<code>&lt;object&gt;$param$OMEGA_CDR_MLE[1]</code> to, for instance,
get the estimate of dN/dS on the CDRs at the repertoire level.
</p>
</li>
<li>  <p><code>trees</code>:     List of tree objects estimated by IgPhyML. If 
<code>format="graph"</code> these are igraph <code>graph</code> objects. 
If <code>format="phylo"</code>, these are ape <code>phylo</code> objects.
</p>
</li>
<li>  <p><code>command</code>:   Command used to run IgPhyML.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Hoehn KB, Lunter G, Pybus OG - A Phylogenetic Codon Substitution Model for Antibody 
Lineages. Genetics 2017 206(1):417-427
https://doi.org/10.1534/genetics.116.196303 
</p>
</li>
<li><p>  Hoehn KB, Vander Heiden JA, Zhou JQ, Lunter G, Pybus OG, Kleinstein SHK - 
Repertoire-wide phylogenetic models of B cell molecular evolution reveal 
evolutionary signatures of aging and vaccination. bioRxiv 2019  
https://doi.org/10.1101/558825 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Read in and plot a tree from an igphyml run
   library(igraph)
   s1 &lt;- readIgphyml("IB+7d_lineages_gy.tsv_igphyml_stats_hlp.tab", id="+7d")
   print(s1$param$OMEGA_CDR_MLE[1])
   plot(s1$trees[[1]], layout=layout_as_tree, edge.label=E(s1$trees[[1]])$weight)

## End(Not run)

</code></pre>

<hr>
<h2 id='seqDist'>Calculate distance between two sequences</h2><span id='topic+seqDist'></span>

<h3>Description</h3>

<p><code>seqDist</code> calculates the distance between two DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqDist(seq1, seq2, dist_mat = getDNAMatrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqDist_+3A_seq1">seq1</code></td>
<td>
<p>character string containing a DNA sequence.</p>
</td></tr>
<tr><td><code id="seqDist_+3A_seq2">seq2</code></td>
<td>
<p>character string containing a DNA sequence.</p>
</td></tr>
<tr><td><code id="seqDist_+3A_dist_mat">dist_mat</code></td>
<td>
<p>Character distance matrix. Defaults to a Hamming distance 
matrix returned by <a href="#topic+getDNAMatrix">getDNAMatrix</a>. If gap 
characters, <code>c("-", ".")</code>, are assigned a value of -1 
in <code>dist_mat</code> then contiguous gaps of any run length,
which are not present in both sequences, will be counted as a 
distance of 1. Meaning, indels of any length will increase
the sequence distance by 1. Gap values other than -1 will 
return a distance that does not consider indels as a special case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical distance between <code>seq1</code> and <code>seq2</code>.
</p>


<h3>See Also</h3>

<p>Nucleotide distance matrix may be built with 
<a href="#topic+getDNAMatrix">getDNAMatrix</a>. Amino acid distance matrix may be built
with <a href="#topic+getAAMatrix">getAAMatrix</a>. Used by <a href="#topic+pairwiseDist">pairwiseDist</a> for generating
distance matrices. See <a href="#topic+seqEqual">seqEqual</a> for testing sequence equivalence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ungapped examples
seqDist("ATGGC", "ATGGG")
seqDist("ATGGC", "ATG??")

# Gaps will be treated as Ns with a gap=0 distance matrix
seqDist("ATGGC", "AT--C", dist_mat=getDNAMatrix(gap=0))

# Gaps will be treated as universally non-matching characters with gap=1
seqDist("ATGGC", "AT--C", dist_mat=getDNAMatrix(gap=1))

# Gaps of any length will be treated as single mismatches with a gap=-1 distance matrix
seqDist("ATGGC", "AT--C", dist_mat=getDNAMatrix(gap=-1))

# Gaps of equivalent run lengths are not counted as gaps
seqDist("ATG-C", "ATG-C", dist_mat=getDNAMatrix(gap=-1))

# Overlapping runs of gap characters are counted as a single gap
seqDist("ATG-C", "AT--C", dist_mat=getDNAMatrix(gap=-1))
seqDist("A-GGC", "AT--C", dist_mat=getDNAMatrix(gap=-1))
seqDist("AT--C", "AT--C", dist_mat=getDNAMatrix(gap=-1))

# Discontiguous runs of gap characters each count as separate gaps
seqDist("-TGGC", "AT--C", dist_mat=getDNAMatrix(gap=-1))

</code></pre>

<hr>
<h2 id='seqEqual'>Test DNA sequences for equality.</h2><span id='topic+seqEqual'></span>

<h3>Description</h3>

<p><code>seqEqual</code> checks if two DNA sequences are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqEqual(seq1, seq2, ignore = as.character(c("N", "-", ".", "?")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqEqual_+3A_seq1">seq1</code></td>
<td>
<p>character string containing a DNA sequence.</p>
</td></tr>
<tr><td><code id="seqEqual_+3A_seq2">seq2</code></td>
<td>
<p>character string containing a DNA sequence.</p>
</td></tr>
<tr><td><code id="seqEqual_+3A_ignore">ignore</code></td>
<td>
<p>vector of characters to ignore when testing for equality.
Default is to ignore c(&quot;N&quot;,&quot;.&quot;,&quot;-&quot;,&quot;?&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if sequences are equal and <code>FALSE</code> if they are not.
Sequences of unequal length will always return <code>FALSE</code> regardless of
their character values.
</p>


<h3>See Also</h3>

<p>Used by <a href="#topic+pairwiseEqual">pairwiseEqual</a> within <a href="#topic+collapseDuplicates">collapseDuplicates</a>.
See <a href="#topic+seqDist">seqDist</a> for calculation Hamming distances between sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ignore gaps
seqEqual("ATG-C", "AT--C")
seqEqual("ATGGC", "ATGGN")
seqEqual("AT--T", "ATGGC")

# Ignore only Ns
seqEqual("ATG-C", "AT--C", ignore="N")
seqEqual("ATGGC", "ATGGN", ignore="N")
seqEqual("AT--T", "ATGGC", ignore="N")

</code></pre>

<hr>
<h2 id='SingleDb'>Single sequence AIRR database</h2><span id='topic+SingleDb'></span>

<h3>Description</h3>

<p>A database with just one sequence from <code>ExampleDb</code> and additional AIRR Rearrangement fields 
containing alignment information. The sequence was reanalyzed with a recent versions of 
alignment software (IgBLAST 1.16.0) and reference germlines (IMGT 2020-08-12).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleDb
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 1 rows and 32 columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+ExampleDb">ExampleDb</a>
</p>

<hr>
<h2 id='sortGenes'>Sort V(D)J genes</h2><span id='topic+sortGenes'></span>

<h3>Description</h3>

<p><code>sortGenes</code> sorts a vector of V(D)J gene names by either lexicographic ordering 
or locus position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortGenes(genes, method = c("name", "position"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortGenes_+3A_genes">genes</code></td>
<td>
<p>vector of strings respresenting V(D)J gene names.</p>
</td></tr>
<tr><td><code id="sortGenes_+3A_method">method</code></td>
<td>
<p>string defining the method to use for sorting genes. One of:
</p>

<ul>
<li> <p><code>"name"</code>:      sort in lexicographic order. Order is by 
family first, then gene, and then allele. 
</p>
</li>
<li> <p><code>"position"</code>:  sort by position in the locus, as
determined by the final two numbers 
in the gene name. Non-localized genes 
are assigned to the highest positions.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted character vector of gene names.
</p>


<h3>See Also</h3>

<p>See <code>getAllele</code>, <code>getGene</code> and <code>getFamily</code> for parsing
gene names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a list of allele names
genes &lt;- c("IGHV1-69D*01","IGHV1-69*01","IGHV4-38-2*01","IGHV1-69-2*01",
           "IGHV2-5*01","IGHV1-NL1*01", "IGHV1-2*01,IGHV1-2*05", 
           "IGHV1-2", "IGHV1-2*02", "IGHV1-69*02")

# Sort genes by name
sortGenes(genes)

# Sort genes by position in the locus
sortGenes(genes, method="pos")

</code></pre>

<hr>
<h2 id='stoufferMeta'>Weighted meta-analysis of p-values via Stouffer's method</h2><span id='topic+stoufferMeta'></span>

<h3>Description</h3>

<p><code>stoufferMeta</code> combines multiple weighted p-values into a meta-analysis p-value
using Stouffer's Z-score method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoufferMeta(p, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoufferMeta_+3A_p">p</code></td>
<td>
<p>numeric vector of p-values.</p>
</td></tr>
<tr><td><code id="stoufferMeta_+3A_w">w</code></td>
<td>
<p>numeric vector of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector with the combined Z-score and p-value in the form
<code>c(Z, pvalue)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define p-value and weight vectors
p &lt;- c(0.1, 0.05, 0.3)
w &lt;- c(5, 10, 1)

# Unweighted
stoufferMeta(p)

# Weighted
stoufferMeta(p, w)

</code></pre>

<hr>
<h2 id='summarizeSubtrees'>Generate subtree summary statistics for a tree</h2><span id='topic+summarizeSubtrees'></span>

<h3>Description</h3>

<p><code>summarizeSubtrees</code> calculates summary statistics for each node of a tree. Includes
both node properties and subtree properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeSubtrees(graph, fields = NULL, root = "Germline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeSubtrees_+3A_graph">graph</code></td>
<td>
<p>igraph object containing an annotated lineage tree.</p>
</td></tr>
<tr><td><code id="summarizeSubtrees_+3A_fields">fields</code></td>
<td>
<p>annotation fields to add to the output.</p>
</td></tr>
<tr><td><code id="summarizeSubtrees_+3A_root">root</code></td>
<td>
<p>name of the root (germline) node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns: 
</p>

<ul>
<li>  <p><code>name</code>:             node name.
</p>
</li>
<li>  <p><code>parent</code>:           name of the parent node.
</p>
</li>
<li>  <p><code>outdegree</code>:        number of edges leading from the node.
</p>
</li>
<li>  <p><code>size</code>:             total number of nodes within the subtree rooted 
at the node.
</p>
</li>
<li>  <p><code>depth</code>:            the depth of the subtree that is rooted at 
the node.
</p>
</li>
<li>  <p><code>pathlength</code>:       the maximum pathlength beneath the node.
</p>
</li>
<li>  <p><code>outdegree_norm</code>:   <code>outdegree</code> normalized by the total 
number of edges.
</p>
</li>
<li>  <p><code>size_norm</code>:        <code>size</code> normalized by the largest
subtree size (the germline).
</p>
</li>
<li>  <p><code>depth_norm</code>:       <code>depth</code> normalized by the largest
subtree depth (the germline).
</p>
</li>
<li>  <p><code>pathlength_norm</code>:  <code>pathlength</code> normalized by the largest
subtree pathlength (the germline).
</p>
</li></ul>

<p>An additional column corresponding to the value of <code>field</code> is added when
specified.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+buildPhylipLineage">buildPhylipLineage</a> for generating input trees. 
See <a href="#topic+getPathLengths">getPathLengths</a> for calculating path length to nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Summarize a tree
graph &lt;- ExampleTrees[[23]]
summarizeSubtrees(graph, fields="c_call", root="Germline")

</code></pre>

<hr>
<h2 id='tableEdges'>Tabulate the number of edges between annotations within a lineage tree</h2><span id='topic+tableEdges'></span>

<h3>Description</h3>

<p><code>tableEdges</code> creates a table of the total number of connections (edges) for each 
unique pair of annotations within a tree over all nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableEdges(graph, field, indirect = FALSE, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableEdges_+3A_graph">graph</code></td>
<td>
<p>igraph object containing an annotated lineage tree.</p>
</td></tr>
<tr><td><code id="tableEdges_+3A_field">field</code></td>
<td>
<p>string defining the annotation field to count.</p>
</td></tr>
<tr><td><code id="tableEdges_+3A_indirect">indirect</code></td>
<td>
<p>if <code>FALSE</code> count direct connections (edges) only. If 
<code>TRUE</code> walk through any nodes with annotations specified in 
the <code>argument</code> to count indirect connections. Specifying
<code>indirect=TRUE</code> with <code>exclude=NULL</code> will have no effect.</p>
</td></tr>
<tr><td><code id="tableEdges_+3A_exclude">exclude</code></td>
<td>
<p>vector of strings defining <code>field</code> values to exclude from counts.
Edges that either start or end with the specified annotations will not
be counted. If <code>NULL</code> count all edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame defining total annotation connections in the tree with columns:
</p>

<ul>
<li>  <p><code>parent</code>:  parent annotation
</p>
</li>
<li>  <p><code>child</code>:   child annotation
</p>
</li>
<li>  <p><code>count</code>:   count of edges for the parent-child relationship
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+testEdges">testEdges</a> for performed a permutation test on edge relationships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example graph
graph &lt;- ExampleTrees[[23]]

# Count direct edges between isotypes including inferred nodes
tableEdges(graph, "c_call")

# Count direct edges excluding edges to and from germline and inferred nodes
tableEdges(graph, "c_call", exclude=c("Germline", NA))

# Count indirect edges walking through germline and inferred nodes
tableEdges(graph, "c_call", indirect=TRUE, exclude=c("Germline", NA))

</code></pre>

<hr>
<h2 id='testDiversity'>Pairwise test of the diversity index</h2><span id='topic+testDiversity'></span>

<h3>Description</h3>

<p><code>testDiversity</code> performs pairwise significance tests of the diversity index 
(<code class="reqn">D</code>) at a given diversity order (<code class="reqn">q</code>) for a set of annotation groups via
rarefaction and bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDiversity(
  data,
  q,
  group,
  clone = "CLONE",
  copy = NULL,
  min_n = 30,
  max_n = NULL,
  nboot = 2000,
  progress = FALSE,
  ci = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDiversity_+3A_data">data</code></td>
<td>
<p>data.frame with Change-O style columns containing clonal assignments.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_q">q</code></td>
<td>
<p>diversity order to test.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_group">group</code></td>
<td>
<p>name of the <code>data</code> column containing group identifiers.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_clone">clone</code></td>
<td>
<p>name of the <code>data</code> column containing clone identifiers.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_copy">copy</code></td>
<td>
<p>name of the <code>data</code> column containing copy numbers for each 
sequence. If <code>copy=NULL</code> (the default), then clone abundance
is determined by the number of sequences. If a <code>copy</code> column
is specified, then clone abundances is determined by the sum of 
copy numbers within each clonal group.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_min_n">min_n</code></td>
<td>
<p>minimum number of observations to sample.
A group with less observations than the minimum is excluded.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_max_n">max_n</code></td>
<td>
<p>maximum number of observations to sample. If <code>NULL</code> the maximum
if automatically determined from the size of the largest group.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap realizations to perform.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> show a progress bar.</p>
</td></tr>
<tr><td><code id="testDiversity_+3A_ci">ci</code></td>
<td>
<p>confidence interval to calculate; the value must be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clonal diversity is calculated using the generalized diversity index proposed by 
Hill (Hill, 1973). See <a href="#topic+calcDiversity">calcDiversity</a> for further details.
</p>
<p>Diversity is calculated on the estimated complete clonal abundance distribution.
This distribution is inferred by using the Chao1 estimator to estimate the number
of seen clones, and applying the relative abundance correction and unseen clone
frequency described in Chao et al, 2014.
</p>
<p>Variability in total sequence counts across unique values in the <code>group</code> column is 
corrected by repeated resampling from the estimated complete clonal distribution to 
a common number of sequences. The diversity index estimate (<code class="reqn">D</code>) for each group is 
the mean value of over all bootstrap realizations. 
</p>
<p>Significance of the difference in diversity index (<code class="reqn">D</code>) between groups is tested by 
constructing a bootstrap delta distribution for each pair of unique values in the 
<code>group</code> column. The bootstrap delta distribution is built by subtracting the diversity 
index <code class="reqn">Da</code> in <code class="reqn">group-a</code> from the corresponding value <code class="reqn">Db</code> in <code class="reqn">group-b</code>, 
for all bootstrap realizations, yeilding a distribution of <code>nboot</code> total deltas; where 
<code class="reqn">group-a</code> is the group with the greater mean <code class="reqn">D</code>. The p-value for hypothesis 
<code class="reqn">Da  !=  Db</code> is the value of <code class="reqn">P(0)</code> from the empirical cumulative distribution 
function of the bootstrap delta distribution, multiplied by 2 for the two-tailed correction.
</p>


<h3>Value</h3>

<p>A <a href="#topic+DiversityCurve">DiversityCurve</a> object containing slot test with p-values and summary 
statistics.
</p>


<h3>Note</h3>

<p>This method may inflate statistical significance when clone sizes are uniformly small,
such as when most clones sizes are 1, sample size is small, and <code>max_n</code> is near
the total count of the smallest data group. Use caution when interpreting the results 
in such cases. We are currently investigating this potential problem.
</p>


<h3>References</h3>


<ol>
<li><p>  Hill M. Diversity and evenness: a unifying notation and its consequences. 
Ecology. 1973 54(2):427-32.
</p>
</li>
<li><p>  Chao A. Nonparametric Estimation of the Number of Classes in a Population. 
Scand J Stat. 1984 11, 265270.
</p>
</li>
<li><p>  Wu Y-CB, et al. Influence of seasonal exposure to grass pollen on local and 
peripheral blood IgE repertoires in patients with allergic rhinitis. 
J Allergy Clin Immunol. 2014 134(3):604-12.
</p>
</li>
<li><p>  Chao A, et al. Rarefaction and extrapolation with Hill numbers: 
A framework for sampling and estimation in species diversity studies. 
Ecol Monogr. 2014 84:45-67.
</p>
</li>
<li><p>  Chao A, et al. Unveiling the species-rank abundance distribution by 
generalizing the Good-Turing sample coverage theory. 
Ecology. 2015 96, 11891201.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+alphaDiversity">alphaDiversity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
# Groups under the size threshold are excluded and a warning message is issued.
testDiversity(ExampleDb, "sample_id", q=0, min_n=30, nboot=100)

## End(Not run)

</code></pre>

<hr>
<h2 id='testEdges'>Tests for parent-child annotation enrichment in lineage trees</h2><span id='topic+testEdges'></span>

<h3>Description</h3>

<p><code>testEdges</code> performs a permutation test on a set of lineage trees to determine
the significance of an annotation's association with parent-child relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testEdges(
  graphs,
  field,
  indirect = FALSE,
  exclude = c("Germline", NA),
  nperm = 200,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testEdges_+3A_graphs">graphs</code></td>
<td>
<p>list of igraph objects with vertex annotations.</p>
</td></tr>
<tr><td><code id="testEdges_+3A_field">field</code></td>
<td>
<p>string defining the annotation field to permute.</p>
</td></tr>
<tr><td><code id="testEdges_+3A_indirect">indirect</code></td>
<td>
<p>if <code>FALSE</code> count direct connections (edges) only. If 
<code>TRUE</code> walk through any nodes with annotations specified in 
the <code>argument</code> to count indirect connections. Specifying
<code>indirect=TRUE</code> with <code>exclude=NULL</code> will have no effect.</p>
</td></tr>
<tr><td><code id="testEdges_+3A_exclude">exclude</code></td>
<td>
<p>vector of strings defining <code>field</code> values to exclude from 
permutation.</p>
</td></tr>
<tr><td><code id="testEdges_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations to perform.</p>
</td></tr>
<tr><td><code id="testEdges_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> show a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+EdgeTest">EdgeTest</a> object containing the test results and permutation
realizations.
</p>


<h3>See Also</h3>

<p>Uses <a href="#topic+tableEdges">tableEdges</a> and <a href="#topic+permuteLabels">permuteLabels</a>. 
See <a href="#topic+plotEdgeTest">plotEdgeTest</a> for plotting the permutation distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define example tree set
graphs &lt;- ExampleTrees[1:10]

# Perform edge test on isotypes
x &lt;- testEdges(graphs, "c_call", nperm=10)
print(x)


</code></pre>

<hr>
<h2 id='testMRCA'>Tests for MRCA annotation enrichment in lineage trees</h2><span id='topic+testMRCA'></span>

<h3>Description</h3>

<p><code>testMRCA</code> performs a permutation test on a set of lineage trees to determine
the significance of an annotation's association with the MRCA position of the lineage
trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMRCA(
  graphs,
  field,
  root = "Germline",
  exclude = c("Germline", NA),
  nperm = 200,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMRCA_+3A_graphs">graphs</code></td>
<td>
<p>list of igraph object containing annotated lineage trees.</p>
</td></tr>
<tr><td><code id="testMRCA_+3A_field">field</code></td>
<td>
<p>string defining the annotation field to test.</p>
</td></tr>
<tr><td><code id="testMRCA_+3A_root">root</code></td>
<td>
<p>name of the root (germline) node.</p>
</td></tr>
<tr><td><code id="testMRCA_+3A_exclude">exclude</code></td>
<td>
<p>vector of strings defining <code>field</code> values to exclude from the
set of potential founder annotations.</p>
</td></tr>
<tr><td><code id="testMRCA_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations to perform.</p>
</td></tr>
<tr><td><code id="testMRCA_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> show a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+MRCATest">MRCATest</a> object containing the test results and permutation
realizations.
</p>


<h3>See Also</h3>

<p>Uses <a href="#topic+getMRCA">getMRCA</a> and <a href="#topic+getPathLengths">getPathLengths</a>. 
See <a href="#topic+plotMRCATest">plotMRCATest</a> for plotting the permutation distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define example tree set
graphs &lt;- ExampleTrees[1:10]

# Perform MRCA test on isotypes
x &lt;- testMRCA(graphs, "c_call", nperm=10)
print(x)


</code></pre>

<hr>
<h2 id='translateDNA'>Translate nucleotide sequences to amino acids</h2><span id='topic+translateDNA'></span>

<h3>Description</h3>

<p><code>translateDNA</code> translates nucleotide sequences to amino acid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translateDNA(seq, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translateDNA_+3A_seq">seq</code></td>
<td>
<p>vector of strings defining DNA sequence(s) to be converted to translated.</p>
</td></tr>
<tr><td><code id="translateDNA_+3A_trim">trim</code></td>
<td>
<p>boolean flag to remove 3 nts from both ends of seq
(converts IMGT junction to CDR3 region).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of translated sequence strings.
</p>


<h3>See Also</h3>

<p><code><a href="seqinr.html#topic+translate">translate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Translate a single sequence
translateDNA("ACTGACTCGA")

# Translate a vector of sequences
translateDNA(ExampleDb$junction[1:3])

# Remove the first and last codon from the translation
translateDNA(ExampleDb$junction[1:3], trim=TRUE)

</code></pre>

<hr>
<h2 id='translateStrings'>Translate a vector of strings</h2><span id='topic+translateStrings'></span>

<h3>Description</h3>

<p><code>translateStrings</code> modifies a character vector by substituting one or more 
strings with a replacement string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translateStrings(strings, translation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translateStrings_+3A_strings">strings</code></td>
<td>
<p>vector of character strings to modify.</p>
</td></tr>
<tr><td><code id="translateStrings_+3A_translation">translation</code></td>
<td>
<p>named character vector or a list of character vectors specifying 
the strings to replace (values) and their replacements (names).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not perform partial replacements. Each translation value must match a complete 
<code>strings</code> value or it will not be replaced.  Values that do not have a replacement
named in the <code>translation</code> parameter will not be modified.
</p>
<p>Replacement is accomplished using <a href="base.html#topic+gsub">gsub</a>.
</p>


<h3>Value</h3>

<p>A modified <code>strings</code> vector.
</p>


<h3>See Also</h3>

<p>See <a href="base.html#topic+gsub">gsub</a> for single value replacement in the base package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a vector translation
strings &lt;- LETTERS[1:5]
translation &lt;- c("POSITION1"="A", "POSITION5"="E")
translateStrings(strings, translation)

# Using a list translation
strings &lt;- LETTERS[1:5]
translation &lt;- list("1-3"=c("A","B","C"), "4-5"=c("D","E"))
translateStrings(strings, translation)

</code></pre>

<hr>
<h2 id='writeChangeoDb'>Write a Change-O tab-delimited database file</h2><span id='topic+writeChangeoDb'></span>

<h3>Description</h3>

<p><code>writeChangeoDb</code> is a simple wrapper around <a href="readr.html#topic+write_delim">write_delim</a> with defaults 
appropriate for writing a Change-O tab-delimited database file from a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeChangeoDb(data, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeChangeoDb_+3A_data">data</code></td>
<td>
<p>data.frame of Change-O data.</p>
</td></tr>
<tr><td><code id="writeChangeoDb_+3A_file">file</code></td>
<td>
<p>output file name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Wraps <a href="readr.html#topic+write_delim">write_delim</a>. See <a href="#topic+readChangeoDb">readChangeoDb</a> for reading to Change-O files.
See <a href="airr.html#topic+read_rearrangement">read_rearrangement</a> and <a href="airr.html#topic+write_rearrangement">write_rearrangement</a>
to read and write AIRR-C Standard formatted repertoires.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Write a database
  writeChangeoDb(data, "changeo.tsv")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
