<!DOCTYPE html><html lang="en"><head><title>Help for package psm3mkv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psm3mkv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psm3mkv-package'><p>psm3mkv: Evaluate Partitioned Survival and State Transition Models</p></a></li>
<li><a href='#calc_allrmds'><p>Calculate restricted mean durations for each health state and all three models</p></a></li>
<li><a href='#calc_haz_psm'><p>Derive pre and post-progression hazards of death under PSM</p></a></li>
<li><a href='#calc_likes'><p>Calculate likelihoods for three three-state model structures</p></a></li>
<li><a href='#calc_rmd'><p>Calculate restricted mean durations</p></a></li>
<li><a href='#calc_surv_psmpps'><p>Derive PPS survival function under a PSM</p></a></li>
<li><a href='#check_consistent_pfs'><p>Check consistency of PFS definition</p>
Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares <code>pfs.durn</code> with the lower of <code>ttp.durn</code> and <code>os.durn</code>, and checks that the event field <code>pfs.flag</code> is consistent with <code>ttp.flag</code> and <code>os.flag</code> (is 1 when either <code>ttp.flag</code> or <code>os.flag</code> is one).</a></li>
<li><a href='#compare_psm_likes'><p>Compare likelihoods of PSMs</p></a></li>
<li><a href='#constrain_survprob'><p>Constrain survival probabilities according to hazards in a lifetable</p>
Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years).</a></li>
<li><a href='#create_dummydata'><p>Create dummy dataset for illustration</p></a></li>
<li><a href='#create_extrafields'><p>Create the additional time-to-event endpoints, adjusting for cutpoint</p></a></li>
<li><a href='#find_bestfit'><p>Find the &quot;best&quot; survival regression from a list of model fits</p></a></li>
<li><a href='#fit_ends_mods_par'><p>Fit multiple parametric survival regressions to the multiple required endpoints</p></a></li>
<li><a href='#fit_ends_mods_spl'><p>Fit multiple spline regressions to the multiple required endpoints</p></a></li>
<li><a href='#graph_psm_hazards'><p>Graph the PSM hazard functions</p></a></li>
<li><a href='#graph_psm_survs'><p>Graph the PSM survival functions</p></a></li>
<li><a href='#graph_survs'><p>Graph the observed and fitted state membership probabilities</p></a></li>
<li><a href='#prob_os_psm'><p>Calculate probability of being alive in a partitioned survival model</p></a></li>
<li><a href='#prob_os_stm_cf'><p>Calculate probability of being alive under the state transition clock forward model</p></a></li>
<li><a href='#prob_os_stm_cr'><p>Calculate probability of being alive under the state transition clock reset model</p></a></li>
<li><a href='#prob_pd_psm'><p>Calculate membership probability of progressed disease state in a partitioned survival model</p></a></li>
<li><a href='#prob_pd_stm_cf'><p>Calculate probability of having progressed disease under the state transition clock forward model</p></a></li>
<li><a href='#prob_pd_stm_cr'><p>Calculate probability of having progressed disease under the state transition clock reset model</p></a></li>
<li><a href='#prob_pf_psm'><p>Calculate probability of being progression free in partitioned survival model</p></a></li>
<li><a href='#prob_pf_stm'><p>Calculate probability of being progression free in either state transition model (clock forward or clock reset)</p></a></li>
<li><a href='#prob_pps_cf'><p>Calculate probability of post progression survival under the state transition clock forward model</p></a></li>
<li><a href='#prob_pps_cr'><p>Calculate probability of post progression survival under the state transition clock reset model</p></a></li>
<li><a href='#vlookup'><p>VLOOKUP function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Evaluate Partitioned Survival and State Transition Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits and evaluates three-state partitioned survival analyses
    (PartSAs) and Markov models (clock forward or clock reset) to
    progression and overall survival data typically collected in oncology clinical trials. These model structures are typically considered in
    cost-effectiveness modeling in advanced/metastatic cancer indications.
    Muston (2024). "Informing structural assumptions for three state oncology cost-effectiveness models through model efficiency and fit". Applied Health Economics and Health Policy. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://merck.github.io/psm3mkv/">https://merck.github.io/psm3mkv/</a>, <a href="https://github.com/Merck/psm3mkv">https://github.com/Merck/psm3mkv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Merck/psm3mkv/issues">https://github.com/Merck/psm3mkv/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>admiral, dplyr, flexsurv, ggplot2, pharmaverseadam, purrr,
rlang, SimplicialCubature, stats, survival, stringr, tibble,
tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, covr, ggsci, HMDHFDplus, knitr, rmarkdown, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-07 19:39:15 UTC; dom</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Muston <a href="https://orcid.org/0000-0003-4876-7940"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Muston &lt;dominic.muston@merck.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-07 20:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='psm3mkv-package'>psm3mkv: Evaluate Partitioned Survival and State Transition Models</h2><span id='topic+psm3mkv'></span><span id='topic+psm3mkv-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Fits and evaluates three-state partitioned survival analyses (PartSAs) and Markov models (clock forward or clock reset) to progression and overall survival data typically collected in oncology clinical trials. These model structures are typically considered in cost-effectiveness modeling in advanced/metastatic cancer indications. Muston (2024). &quot;Informing structural assumptions for three state oncology cost-effectiveness models through model efficiency and fit&quot;. Applied Health Economics and Health Policy.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dominic Muston <a href="mailto:dominic.muston@merck.com">dominic.muston@merck.com</a> (<a href="https://orcid.org/0000-0003-4876-7940">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://merck.github.io/psm3mkv/">https://merck.github.io/psm3mkv/</a>
</p>
</li>
<li> <p><a href="https://github.com/Merck/psm3mkv">https://github.com/Merck/psm3mkv</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Merck/psm3mkv/issues">https://github.com/Merck/psm3mkv/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calc_allrmds'>Calculate restricted mean durations for each health state and all three models</h2><span id='topic+calc_allrmds'></span>

<h3>Description</h3>

<p>Calculate restricted mean durations for each health state (progression free and progressed disease) for all three models (partitioned survival, clock forward state transition model, clock reset state transition model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_allrmds(
  ptdata,
  inclset = 0,
  dpam,
  psmtype = "simple",
  cuttime = 0,
  Ty = 10,
  lifetable = NA,
  discrate = 0,
  rmdmethod = "int",
  timestep = 1,
  boot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_allrmds_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_inclset">inclset</code></td>
<td>
<p>Vector to indicate which patients to include in analysis</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_dpam">dpam</code></td>
<td>
<p>List of statistical fits to each endpoint required in PSM, STM-CF and STM-CR models.</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_psmtype">psmtype</code></td>
<td>
<p>Either &quot;simple&quot; or &quot;complex&quot; PSM formulation</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_cuttime">cuttime</code></td>
<td>
<p>Time cutoff - this is nonzero for two-piece models.</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_ty">Ty</code></td>
<td>
<p>Time duration over which to calculate. Assumes input is in years, and patient-level data is recorded in weeks.</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_lifetable">lifetable</code></td>
<td>
<p>Optional, a life table. Columns must include <code>lttime</code> (time in years, or 52.18 times shorter than the time index elsewhere, starting from zero) and <code>lx</code></p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_discrate">discrate</code></td>
<td>
<p>Discount rate (% per year)</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_rmdmethod">rmdmethod</code></td>
<td>
<p>can be &quot;int&quot; (default for full integral calculations) or &quot;disc&quot; for approximate discretized calculations</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_timestep">timestep</code></td>
<td>
<p>required if method==&quot;int&quot;, default being 1</p>
</td></tr>
<tr><td><code id="calc_allrmds_+3A_boot">boot</code></td>
<td>
<p>logical flag to indicate whether abbreviated output is required (default = FALSE), for example for bootstrapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of detailed numeric results
</p>

<ul>
<li><p> cutadj indicates the survival function and area under the curves for PFS and OS up to the cutpoint
</p>
</li>
<li><p> results provides results of the restricted means calculations, by model and state.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create dataset and fit survival models (splines)
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_par(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
# RMD using default "int" method, no lifetable constraint
calc_allrmds(bosonc, dpam=params)
# RMD using discretized ("disc") method, no lifetable constraint
calc_allrmds(bosonc, dpam=params, rmdmethod="disc", timestep=1, boot=TRUE)

</code></pre>

<hr>
<h2 id='calc_haz_psm'>Derive pre and post-progression hazards of death under PSM</h2><span id='topic+calc_haz_psm'></span>

<h3>Description</h3>

<p>Derive the hazards of death pre- and post-progression under either simple or complex PSM formulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_haz_psm(timevar, ptdata, dpam, psmtype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_haz_psm_+3A_timevar">timevar</code></td>
<td>
<p>Vector of times at which to calculate the hazards</p>
</td></tr>
<tr><td><code id="calc_haz_psm_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>

<p>Survival data for all other endpoints (time to progression, pre-progression death, post-progression survival) are derived from PFS and OS.</p>
</td></tr>
<tr><td><code id="calc_haz_psm_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for each endpoint:
</p>

<ul>
<li><p> pre-progression death (PPD)
</p>
</li>
<li><p> time to progression (TTP)
</p>
</li>
<li><p> progression-free survival (PFS)
</p>
</li>
<li><p> overall survival (OS)
</p>
</li>
<li><p> post-progression survival clock forward (PPS-CF) and
</p>
</li>
<li><p> post-progression survival clock reset (PPS-CR).
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_haz_psm_+3A_psmtype">psmtype</code></td>
<td>
<p>Either &quot;simple&quot; or &quot;complex&quot; PSM formulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of pre, the pre-progression hazard, and post, the post-progression hazard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
  )
calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype="simple")
calc_haz_psm(0:10, ptdata=bosonc, dpam=params, psmtype="complex")

</code></pre>

<hr>
<h2 id='calc_likes'>Calculate likelihoods for three three-state model structures</h2><span id='topic+calc_likes'></span>

<h3>Description</h3>

<p>Calculate likelihood values and other summary output for the following three state models structures: partitioned survival, clock forward state transition, and clock reset state transition. The function requires appropriately formatted patient-level data, a set of fitted survival regressions, and the time cut-off (if two-piece modeling is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_likes(ptdata, dpam, cuttime = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_likes_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li> <p><code>ptid</code>: patient identifier
</p>
</li>
<li> <p><code>pfs.durn</code>: duration of PFS from baseline
</p>
</li>
<li> <p><code>pfs.flag</code>: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>os.durn</code>: duration of OS from baseline
</p>
</li>
<li> <p><code>os.flag</code>: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>ttp.durn</code>: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li> <p><code>ttp.flag</code>: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>

<p>Survival data for all other endpoints (time to progression, pre-progression death, post-progression survival) are derived from PFS and OS.</p>
</td></tr>
<tr><td><code id="calc_likes_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for each endpoint:
</p>

<ul>
<li><p> pre-progression death (PPD)
</p>
</li>
<li><p> time to progression (TTP)
</p>
</li>
<li><p> progression-free survival (PFS)
</p>
</li>
<li><p> overall survival (OS)
</p>
</li>
<li><p> post-progression survival clock forward (PPS-CF) and
</p>
</li>
<li><p> post-progression survival clock reset (PPS-CR).
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_likes_+3A_cuttime">cuttime</code></td>
<td>
<p>Time cutoff - this is nonzero for two-piece models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three tibbles:
<code>all</code> is a tibble of results for all patients:
</p>

<ul>
<li> <p><code>methname</code>: the model structure or method.
</p>
</li>
<li> <p><code>npar</code>: is the number of parameters used by that method.
</p>
</li>
<li> <p><code>npts_1</code> to <code>npts_4</code> are the number of patients experiencing outcomes 1-4 respectively (see below), and <code>npts_tot</code> the total.
</p>
</li>
<li> <p><code>ll_1</code> to <code>ll_4</code> are the log-likelihood values for patients experiencing outcomes 1-4 respectively (see below), and <code>ll_tot</code> the total.
<code>valid</code> is a tibble of the same design as <code>all</code> but only in patients with valid likelihoods for all 4 methods
<code>sum</code> is a tibble in respect of patients with valid likelihoods for all 4 methods providing:
</p>
</li>
<li> <p><code>npts</code>: number of patients contributing results for this method.
</p>
</li>
<li> <p><code>npar</code>: number of parameters used by that method.
</p>
</li>
<li> <p><code>ll</code>: total log-likelihood
</p>
</li>
<li> <p><code>AIC</code>: Akaike Information Criterion value for this model
</p>
</li>
<li> <p><code>BIC</code>: Bayesian Information Criterion value for this model
</p>
</li></ul>

<p>The four outcomes are as follows:
</p>

<ul>
<li><p> (1) refers to patients who remain alive and progression-free during the follow-up;
</p>
</li>
<li><p> (2) refers to patients who die without prior progression during the follow-up;
</p>
</li>
<li><p> (3) refers to patients who progress and then remain alive for the remaining follow-up, and
</p>
</li>
<li><p> (4) refers to patients who progress and die within the follow-up.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
  )
calc_likes(bosonc, dpam=params)

</code></pre>

<hr>
<h2 id='calc_rmd'>Calculate restricted mean durations</h2><span id='topic+calc_rmd'></span>

<h3>Description</h3>

<p>Calculates the restricted mean duration, given the form of a parametric distribution of Royston-Parmar splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rmd(Tw, type = NA, spec = NA, survobj = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rmd_+3A_tw">Tw</code></td>
<td>
<p>is the time horizon (weeks) over which the mean should be calculated.</p>
</td></tr>
<tr><td><code id="calc_rmd_+3A_type">type</code></td>
<td>
<p>is either &quot;par&quot; for regular parametric form (exponential, weibull etc) or &quot;spl&quot; for Royston-Parmar splines.</p>
</td></tr>
<tr><td><code id="calc_rmd_+3A_spec">spec</code></td>
<td>
<p>is a list comprising:
If type==&quot;par&quot;: <code>dist</code> is the statistical distribution (named per <a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg</a>) and <code>pars</code> is a vector of the parameters for that distribution.
</p>

<ul>
<li><p> Exponential distribution (<code>exp</code>) requires the rate parameter.
</p>
</li>
<li><p> Weibull distribution (both <code>weibullPH</code> and <code>weibull</code> formulations) requires the shape and scale parameters.
</p>
</li>
<li><p> Log-logistic distribution (<code>llogis</code>) requires the shape and scale parameters.
</p>
</li>
<li><p> Log-normal distribution (<code>lnorm</code>) requires the meanlog and sdlog parameters.
</p>
</li>
<li><p> Gamma and Gompertz distributions (<code>gamma</code> and <code>gompertz</code>) require the shape and rate parameters.
</p>
</li>
<li><p> Generalized Gamma requires the mu, sigma and Q parameters if using the standard parameterization (<code>gengamma</code>) or shape, scale and k parameters if using the original parameterization (<code>gengamma.orig</code>).
If type==&quot;spl&quot;:
</p>
</li>
<li> <p><code>gamma</code> - Vector of parameters describing the baseline spline function, as described in <a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline</a>. This may be supplied as a vector with number of elements equal to the length of knots, in which case the parameters are common to all times. Alternatively a matrix may be supplied, with rows corresponding to different times, and columns corresponding to knots.
</p>
</li>
<li> <p><code>knots</code> - Vector of locations of knots on the axis of log time, supplied in increasing order. Unlike in <a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline</a>, these include the two boundary knots.
</p>
</li>
<li> <p><code>scale</code> - Either &quot;hazard&quot;, &quot;odds&quot;, or &quot;normal&quot;, as described in <a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline</a>. With the default of no knots in addition to the boundaries, this model reduces to the Weibull, log-logistic and log-normal respectively. The scale must be common to all times.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_rmd_+3A_survobj">survobj</code></td>
<td>
<p>is a survival fit object from <a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline</a> or <a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the restricted mean duration, a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_rmd(Tw=200,
    type="spl",
    spec=list(gamma=c(0.1,0.2,0.1), knots=c(-5,2,4), scale="normal")
    )
calc_rmd(Tw=250,
    type="par",
    spec=list(dist="lnorm", pars=c(3,1))
    )
</code></pre>

<hr>
<h2 id='calc_surv_psmpps'>Derive PPS survival function under a PSM</h2><span id='topic+calc_surv_psmpps'></span>

<h3>Description</h3>

<p>Derive the post-progression survival (PPS) function under the simple or complex PSM formulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_surv_psmpps(totime, fromtime = 0, ptdata, dpam, psmtype = "simple")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_surv_psmpps_+3A_totime">totime</code></td>
<td>
<p>Vector of times to which the survival function is calculated</p>
</td></tr>
<tr><td><code id="calc_surv_psmpps_+3A_fromtime">fromtime</code></td>
<td>
<p>Vector of times from which the survival function is calculated</p>
</td></tr>
<tr><td><code id="calc_surv_psmpps_+3A_ptdata">ptdata</code></td>
<td>
<p>Patient-level dataset</p>
</td></tr>
<tr><td><code id="calc_surv_psmpps_+3A_dpam">dpam</code></td>
<td>
<p>List of fitted survival models for each endpoint</p>
</td></tr>
<tr><td><code id="calc_surv_psmpps_+3A_psmtype">psmtype</code></td>
<td>
<p>Either &quot;simple&quot; or &quot;complex&quot; PSM formulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of PPS survival function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
  )
calc_surv_psmpps(totime=1:10,
  fromtime=rep(1,10),
  ptdata=bosonc,
  dpam=params,
  psmtype="simple")

</code></pre>

<hr>
<h2 id='check_consistent_pfs'>Check consistency of PFS definition
Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares <code>pfs.durn</code> with the lower of <code>ttp.durn</code> and <code>os.durn</code>, and checks that the event field <code>pfs.flag</code> is consistent with <code>ttp.flag</code> and <code>os.flag</code> (is 1 when either <code>ttp.flag</code> or <code>os.flag</code> is one).</h2><span id='topic+check_consistent_pfs'></span>

<h3>Description</h3>

<p>Check consistency of PFS definition
Check that PFS is defined consistently with TTP and OS in a dataset. This convenience function compares <code>pfs.durn</code> with the lower of <code>ttp.durn</code> and <code>os.durn</code>, and checks that the event field <code>pfs.flag</code> is consistent with <code>ttp.flag</code> and <code>os.flag</code> (is 1 when either <code>ttp.flag</code> or <code>os.flag</code> is one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_consistent_pfs(ds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_consistent_pfs_+3A_ds">ds</code></td>
<td>
<p>Tibble of complete patient-level dataset
</p>

<ul>
<li> <p><code>ttp.durn</code>, <code>pfs.durn</code>, and <code>os.durn</code> are the durations of TTP (time to progression), PFS (progression-free survival), and OS (overall survival).
</p>
</li>
<li> <p><code>ttp.flag</code>, <code>pfs.flag</code>, and <code>os.flag</code>, and <code>pps.flag</code> are event flag indicators for TTP, PFS, and OS respectively (1=event, 0=censoring).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ul>
<li> <p><code>durn</code>: Logical vector comparing expected and actual PFS durations
</p>
</li>
<li> <p><code>flag</code>: Logical vector comparing expected and actual PFS event flags
</p>
</li>
<li> <p><code>all</code>: Single logical value of TRUE if all durations and flags match as expected, FALSE otherwise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ponc &lt;- create_dummydata("pharmaonc")
check_consistent_pfs(ponc)
</code></pre>

<hr>
<h2 id='compare_psm_likes'>Compare likelihoods of PSMs</h2><span id='topic+compare_psm_likes'></span>

<h3>Description</h3>

<p>Compare the total log-likelihood values for the patient-level dataset after fitting PSM-simple and PSM-complex models to each combination of endpoint distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_psm_likes(ptdata, fitslist, cuttime = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_psm_likes_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>
</td></tr>
<tr><td><code id="compare_psm_likes_+3A_fitslist">fitslist</code></td>
<td>
<p>List of distribution fits to relevant endpoints, after calling <code>fit_ends_mods_par()</code> or <code>fit_ends_mods_spl()</code></p>
</td></tr>
<tr><td><code id="compare_psm_likes_+3A_cuttime">cuttime</code></td>
<td>
<p>Time cutoff - this is nonzero for two-piece models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>

<ul>
<li> <p><code>results</code>: Dataset of calculation results for each model
</p>
</li>
<li> <p><code>bests</code>: Tibble indicating which is the best fitting model individually or jointly, to each endpoint, according to AIC or BIC
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Fit parametric distributions to a dataset
bosonc &lt;- create_dummydata("flexbosms")
parfits &lt;- fit_ends_mods_par(bosonc)

splfits &lt;- fit_ends_mods_spl(bosonc)
# Present comparison of likelihood calculations
compare_psm_likes(bosonc, parfits)
compare_psm_likes(bosonc, splfits)

</code></pre>

<hr>
<h2 id='constrain_survprob'>Constrain survival probabilities according to hazards in a lifetable
Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years).</h2><span id='topic+constrain_survprob'></span>

<h3>Description</h3>

<p>Constrain survival probabilities according to hazards in a lifetable
Recalculated constrained survival probabilities (by week) as the lower of the original unadjusted survival probability and the survival implied by the given lifetable (assumed indexed as years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain_survprob(
  survprob1,
  survprob2 = NA,
  lifetable = NA,
  timevec = 0:(length(survprob1) - 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrain_survprob_+3A_survprob1">survprob1</code></td>
<td>
<p>(Unconstrained) survival probability value or vector</p>
</td></tr>
<tr><td><code id="constrain_survprob_+3A_survprob2">survprob2</code></td>
<td>
<p>Optional survival probability value or vector to constrain on (default = NA)</p>
</td></tr>
<tr><td><code id="constrain_survprob_+3A_lifetable">lifetable</code></td>
<td>
<p>Lifetable (default = NA)</p>
</td></tr>
<tr><td><code id="constrain_survprob_+3A_timevec">timevec</code></td>
<td>
<p>Vector of times corresponding with survival probabilities above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of constrained survival probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ltable &lt;- tibble::tibble(lttime=0:20, lx=c(1,0.08,0.05,0.03,0.01,rep(0,16)))
survprob &lt;- c(1,0.5,0.4,0.2,0)
constrain_survprob(survprob, lifetable=ltable)
timevec &lt;- 100*(0:4)
constrain_survprob(survprob, lifetable=ltable, timevec=timevec)
survprob2 &lt;- c(1,0.45,0.35,0.15,0)
constrain_survprob(survprob, survprob2)
</code></pre>

<hr>
<h2 id='create_dummydata'>Create dummy dataset for illustration</h2><span id='topic+create_dummydata'></span>

<h3>Description</h3>

<p>Create dummy dataset to illustrate <a href="#topic+psm3mkv">psm3mkv</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dummydata(dsname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_dummydata_+3A_dsname">dsname</code></td>
<td>
<p>Dataset name, as follows:
</p>

<ul>
<li> <p><code>flexbosms</code> provides a dataset based on <code><a href="flexsurv.html#topic+bos">flexsurv::bosms3()</a></code>. This contains all the fields necessary for <a href="#topic+psm3mkv">psm3mkv</a>. Durations have been converted from months in the original dataset to weeks.
</p>
</li>
<li> <p><code>pharmaonc</code> provides a dataset based on <a href="pharmaverseadam.html#topic+adsl">pharmaverseadam::adsl</a> and <a href="pharmaverseadam.html#topic+adrs_onco">pharmaverseadam::adrs_onco</a> to demonstrate how this package can be used with ADaM ADTTE datasets.
</p>
</li>
<li> <p><code>survcan</code> provides a dataset based on <code><a href="survival.html#topic+lung">survival::cancer()</a></code>. This contains the necessary ID and overall survival fields only. Durations have been converted from days in the original dataset to weeks. You will additionally need to supply PFS and TTP data (fields pfs.durn, pfs.flag, ttp.durn and ttp.flag) to use <a href="#topic+psm3mkv">psm3mkv</a>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble dataset, for use with <a href="#topic+psm3mkv">psm3mkv</a> functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_dummydata("survcan") |&gt; head()
create_dummydata("flexbosms") |&gt; head()
create_dummydata("pharmaonc") |&gt; head()
</code></pre>

<hr>
<h2 id='create_extrafields'>Create the additional time-to-event endpoints, adjusting for cutpoint</h2><span id='topic+create_extrafields'></span>

<h3>Description</h3>

<p>Create the additional time-to-event endpoints, adjusting for cutpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_extrafields(ds, cuttime = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_extrafields_+3A_ds">ds</code></td>
<td>
<p>Patient-level dataset</p>
</td></tr>
<tr><td><code id="create_extrafields_+3A_cuttime">cuttime</code></td>
<td>
<p>Time cutpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of complete patient-level dataset, adjusted for cutpoint
<code>ttp.durn</code>, <code>pfs.durn</code>, <code>ppd.durn</code> and <code>os.durn</code> are the durations of TTP (time to progression), PFS (progression-free survival), PPD (pre-progression death) and OS (overall survival) respectively beyond the cutpoint.
<code>pps.durn</code> is the duration of survival beyond progression, irrespective of the cutpoint.
<code>pps.odurn</code> is the difference between <code>ttp.durn</code> and <code>os.durn</code> (which may be different to <code>pps.durn</code>).
<code>ttp.flag</code>, <code>pfs.flag</code>, <code>ppd.flag</code>, <code>os.flag</code>, and <code>pps.flag</code> are event flag indicators for TTP, PFS, PPD, OS and PPS respectively (1=event, 0=censoring).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bosonc &lt;- create_dummydata("flexbosms")
create_extrafields(bosonc, cuttime=10)
</code></pre>

<hr>
<h2 id='find_bestfit'>Find the &quot;best&quot; survival regression from a list of model fits</h2><span id='topic+find_bestfit'></span>

<h3>Description</h3>

<p>When there are multiple survival regressions fitted to the same endpoint and dataset, it is necessary to identify the preferred model. This function reviews the fitted regressions and selects that with the minimum Akaike or Bayesian Information Criterion (AIC, BIC), depending on user choice. Model fits must be all parametric or all splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_bestfit(reglist, crit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_bestfit_+3A_reglist">reglist</code></td>
<td>
<p>List of fitted survival regressions to an endpoint and dataset.</p>
</td></tr>
<tr><td><code id="find_bestfit_+3A_crit">crit</code></td>
<td>
<p>Criterion to be used in selection of best fit, either &quot;aic&quot; (Akaike Information Criterion) or &quot;bic&quot; (Bayesian Information Criterion).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the single survival regression with the best fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bosonc &lt;- create_dummydata("flexbosms")
# Parametric modeling
fits_par &lt;- fit_ends_mods_par(bosonc)
find_bestfit(fits_par$ttp, "aic")

# Splines modeling
fits_spl &lt;- fit_ends_mods_spl(bosonc)
find_bestfit(fits_spl$ttp, "bic")

</code></pre>

<hr>
<h2 id='fit_ends_mods_par'>Fit multiple parametric survival regressions to the multiple required endpoints</h2><span id='topic+fit_ends_mods_par'></span>

<h3>Description</h3>

<p>Fits multiple parametric survival regressions, according to the distributions stipulated, to the multiple endpoints required in fitting partitioned survival analysis, clock forward and clock reset semi-markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ends_mods_par(
  simdat,
  cuttime = 0,
  ppd.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  ttp.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  pfs.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  os.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  pps_cf.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  pps_cr.dist = c("exp", "weibullPH", "llogis", "lnorm", "gamma", "gompertz"),
  expvar = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_ends_mods_par_+3A_simdat">simdat</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>

<p>Survival data for all other endpoints (time to progression, pre-progression death, post-progression survival) are derived from PFS and OS.</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_cuttime">cuttime</code></td>
<td>
<p>Cut-off time for a two-piece model, equals zero for one-piece models.</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_ppd.dist">ppd.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Pre-Progression Death (PPD).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_ttp.dist">ttp.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Time To Progression (TTP).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_pfs.dist">pfs.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Progression-Free Survival (PFS).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_os.dist">os.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Overall Survival (OS).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_pps_cf.dist">pps_cf.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Post Progression Survival, where time is from baseline (clock forward).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_pps_cr.dist">pps_cr.dist</code></td>
<td>
<p>Vector of distributions (named per <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>) to be fitted to Post Progression Survival, where time is from progression (clock reset).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_par_+3A_expvar">expvar</code></td>
<td>
<p>Explanatory variable for modeling of PPS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list by endpoint, then distribution, each containing two components:
</p>

<ul>
<li><p> result: A list of class <em>flexsurvreg</em> containing information about the fitted model.
</p>
</li>
<li><p> error: Any error message returned on fitting the regression (NULL indicates no error).
</p>
</li></ul>



<h3>See Also</h3>

<p>Spline modeling is handled by <code><a href="#topic+fit_ends_mods_spl">fit_ends_mods_spl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bosonc &lt;- create_dummydata("flexbosms")
fit_ends_mods_par(bosonc, expvar=bosonc$ttp.durn)
</code></pre>

<hr>
<h2 id='fit_ends_mods_spl'>Fit multiple spline regressions to the multiple required endpoints</h2><span id='topic+fit_ends_mods_spl'></span>

<h3>Description</h3>

<p>Fits multiple survival regressions, according to the distributions stipulated, to the multiple endpoints required in fitting partitioned survival analysis, clock forward and clock reset semi-markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ends_mods_spl(
  simdat,
  knot_set = 1:3,
  scale_set = c("hazard", "odds", "normal"),
  expvar = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_ends_mods_spl_+3A_simdat">simdat</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>

<p>Survival data for all other endpoints (time to progression, pre-progression death, post-progression survival) are derived from PFS and OS.</p>
</td></tr>
<tr><td><code id="fit_ends_mods_spl_+3A_knot_set">knot_set</code></td>
<td>
<p>is a vector of the numbers of knots to consider, following <code><a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline()</a></code>).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_spl_+3A_scale_set">scale_set</code></td>
<td>
<p>is a vector of the spline scales to consider, following <code><a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline()</a></code>).</p>
</td></tr>
<tr><td><code id="fit_ends_mods_spl_+3A_expvar">expvar</code></td>
<td>
<p>Explanatory variable for modeling of PPS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list by endpoint, then distribution, each containing two components:
</p>

<ul>
<li><p> result: A list of class <a href="flexsurv.html#topic+flexsurvspline">flexsurv::flexsurvspline</a> containing information about the fitted model.
</p>
</li>
<li><p> error: Any error message returned on fitting the regression (NULL indicates no error).
Also, the given cuttime.
</p>
</li></ul>



<h3>See Also</h3>

<p>Parametric modeling is handled by <code><a href="#topic+fit_ends_mods_par">fit_ends_mods_par()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create dataset in suitable form using bos dataset from the flexsurv package
bosonc &lt;- create_dummydata("flexbosms")
fit_ends_mods_spl(bosonc, expvar=bosonc$ttp.durn)

</code></pre>

<hr>
<h2 id='graph_psm_hazards'>Graph the PSM hazard functions</h2><span id='topic+graph_psm_hazards'></span>

<h3>Description</h3>

<p>Graph the PSM hazard functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_psm_hazards(timevar, endpoint, ptdata, dpam, psmtype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_psm_hazards_+3A_timevar">timevar</code></td>
<td>
<p>Vector of times at which to calculate the hazards</p>
</td></tr>
<tr><td><code id="graph_psm_hazards_+3A_endpoint">endpoint</code></td>
<td>
<p>Endpoint for which hazard is required (TTP, PPD, PFS, OS or PPS)</p>
</td></tr>
<tr><td><code id="graph_psm_hazards_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li> <p><code>ptid</code>: patient identifier
</p>
</li>
<li> <p><code>pfs.durn</code>: duration of PFS from baseline
</p>
</li>
<li> <p><code>pfs.flag</code>: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>os.durn</code>: duration of OS from baseline
</p>
</li>
<li> <p><code>os.flag</code>: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>ttp.durn</code>: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li> <p><code>ttp.flag</code>: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_psm_hazards_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for each endpoint:
</p>

<ul>
<li><p> pre-progression death (PPD)
</p>
</li>
<li><p> time to progression (TTP)
</p>
</li>
<li><p> progression-free survival (PFS)
</p>
</li>
<li><p> overall survival (OS)
</p>
</li>
<li><p> post-progression survival clock forward (PPS-CF) and
</p>
</li>
<li><p> post-progression survival clock reset (PPS-CR).
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_psm_hazards_+3A_psmtype">psmtype</code></td>
<td>
<p>Either &quot;simple&quot; or &quot;complex&quot; PSM formulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ul>
<li> <p><code>adj</code> is the hazard adjusted for constraints
</p>
</li>
<li> <p><code>unadj</code> is the unadjusted hazard
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_par(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
# Create graphics
# psmh_simple &lt;- graph_psm_hazards(
#   timerange=(0:10)*6,
#   endpoint="OS",
#   dpam=params,
#   psmtype="simple")
# psmh_simple$graph
</code></pre>

<hr>
<h2 id='graph_psm_survs'>Graph the PSM survival functions</h2><span id='topic+graph_psm_survs'></span>

<h3>Description</h3>

<p>Graph the PSM survival functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_psm_survs(timevar, endpoint, ptdata, dpam, psmtype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_psm_survs_+3A_timevar">timevar</code></td>
<td>
<p>Vector of times at which to calculate the hazards</p>
</td></tr>
<tr><td><code id="graph_psm_survs_+3A_endpoint">endpoint</code></td>
<td>
<p>Endpoint for which hazard is required (TTP, PPD, PFS, OS or PPS)</p>
</td></tr>
<tr><td><code id="graph_psm_survs_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li> <p><code>ptid</code>: patient identifier
</p>
</li>
<li> <p><code>pfs.durn</code>: duration of PFS from baseline
</p>
</li>
<li> <p><code>pfs.flag</code>: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>os.durn</code>: duration of OS from baseline
</p>
</li>
<li> <p><code>os.flag</code>: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li> <p><code>ttp.durn</code>: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li> <p><code>ttp.flag</code>: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_psm_survs_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for each endpoint:
</p>

<ul>
<li><p> pre-progression death (PPD)
</p>
</li>
<li><p> time to progression (TTP)
</p>
</li>
<li><p> progression-free survival (PFS)
</p>
</li>
<li><p> overall survival (OS)
</p>
</li>
<li><p> post-progression survival clock forward (PPS-CF) and
</p>
</li>
<li><p> post-progression survival clock reset (PPS-CR).
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_psm_survs_+3A_psmtype">psmtype</code></td>
<td>
<p>Either &quot;simple&quot; or &quot;complex&quot; PSM formulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ul>
<li> <p><code>adj</code> is the hazard adjusted for constraints
</p>
</li>
<li> <p><code>unadj</code> is the unadjusted hazard
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_par(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
# Graphic illustrating effect of constraints on OS model
psms_simple &lt;- graph_psm_survs(
  timevar=6*(0:10),
  endpoint="OS",
  ptdata=bosonc,
  dpam=params,
  psmtype="simple"
)
psms_simple$graph

</code></pre>

<hr>
<h2 id='graph_survs'>Graph the observed and fitted state membership probabilities</h2><span id='topic+graph_survs'></span>

<h3>Description</h3>

<p>Graph the observed and fitted state membership probabilities for PF, PD, OS and PPS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_survs(ptdata, dpam, cuttime = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_survs_+3A_ptdata">ptdata</code></td>
<td>
<p>Dataset of patient level data. Must be a tibble with columns named:
</p>

<ul>
<li><p> ptid: patient identifier
</p>
</li>
<li><p> pfs.durn: duration of PFS from baseline
</p>
</li>
<li><p> pfs.flag: event flag for PFS (=1 if progression or death occurred, 0 for censoring)
</p>
</li>
<li><p> os.durn: duration of OS from baseline
</p>
</li>
<li><p> os.flag: event flag for OS (=1 if death occurred, 0 for censoring)
</p>
</li>
<li><p> ttp.durn: duration of TTP from baseline (usually should be equal to pfs.durn)
</p>
</li>
<li><p> ttp.flag: event flag for TTP (=1 if progression occurred, 0 for censoring).
</p>
</li></ul>

<p>Survival data for all other endpoints (time to progression, pre-progression death, post-progression survival) are derived from PFS and OS.</p>
</td></tr>
<tr><td><code id="graph_survs_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for each endpoint:
</p>

<ul>
<li><p> pre-progression death (PPD)
</p>
</li>
<li><p> time to progression (TTP)
</p>
</li>
<li><p> progression-free survival (PFS)
</p>
</li>
<li><p> overall survival (OS)
</p>
</li>
<li><p> post-progression survival clock forward (PPS-CF) and
</p>
</li>
<li><p> post-progression survival clock reset (PPS-CR).
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_survs_+3A_cuttime">cuttime</code></td>
<td>
<p>is the cut-off time for a two-piece model (default 0, indicating a one-piece model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two items as follows.
<code>data</code> is a tibble containing data derived and used in the derivation of the graphics.
<code>graph</code> is a list of four graphics as follows:
</p>

<ul>
<li> <p><code>pf</code>: Membership probability in PF (progression-free) state versus time since baseline, by method
</p>
</li>
<li> <p><code>pd</code>: Membership probability in PD (progressive disease) state versus time since baseline, by method
</p>
</li>
<li> <p><code>os</code>: Probability alive versus time since baseline, by method
</p>
</li>
<li> <p><code>pps</code>: Probability alive versus time since progression, by method
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_par(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
# Create graphics
gs &lt;- graph_survs(ptdata=bosonc, dpam=params)
gs$graph$pd

</code></pre>

<hr>
<h2 id='prob_os_psm'>Calculate probability of being alive in a partitioned survival model</h2><span id='topic+prob_os_psm'></span>

<h3>Description</h3>

<p>Calculates membership probability of being alive at a particular time (vectorized), given either state transition model (clock forward or clock reset) with given statistical distributions and parameters. This is the sum of membership probabilities in the progression free and progressed disease states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_os_psm(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_os_psm_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized)</p>
</td></tr>
<tr><td><code id="prob_os_psm_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include overall survival (OS).</p>
</td></tr>
<tr><td><code id="prob_os_psm_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_os_psm(0:100, params)

</code></pre>

<hr>
<h2 id='prob_os_stm_cf'>Calculate probability of being alive under the state transition clock forward model</h2><span id='topic+prob_os_stm_cf'></span>

<h3>Description</h3>

<p>Calculates membership probability of being alive at a given time (vectorized). This probability is from the state transition clock forward model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_os_stm_cf(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_os_stm_cf_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized) from baseline.</p>
</td></tr>
<tr><td><code id="prob_os_stm_cf_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include pre-progression death (PPD), time to progression (TTP) and post progression survival calculated under the clock forward model (PPS-CF).</p>
</td></tr>
<tr><td><code id="prob_os_stm_cf_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_os_stm_cf(0:100, params)

</code></pre>

<hr>
<h2 id='prob_os_stm_cr'>Calculate probability of being alive under the state transition clock reset model</h2><span id='topic+prob_os_stm_cr'></span>

<h3>Description</h3>

<p>Calculates membership probability of being alive at a given time (vectorized). This probability is from the state transition clock reset model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_os_stm_cr(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_os_stm_cr_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized) from baseline.</p>
</td></tr>
<tr><td><code id="prob_os_stm_cr_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include pre-progression death (PPD), time to progression (TTP) and post progression survival calculated under the clock reset model (PPS-CR).</p>
</td></tr>
<tr><td><code id="prob_os_stm_cr_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_os_stm_cr(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pd_psm'>Calculate membership probability of progressed disease state in a partitioned survival model</h2><span id='topic+prob_pd_psm'></span>

<h3>Description</h3>

<p>Calculates membership probability of having progressed disease at a particular time (vectorized), given the partitioned survival model with certain statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pd_psm(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pd_psm_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized)</p>
</td></tr>
<tr><td><code id="prob_pd_psm_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include progression-free survival (PFS) and overall survival (OS).</p>
</td></tr>
<tr><td><code id="prob_pd_psm_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pd_psm(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pd_stm_cf'>Calculate probability of having progressed disease under the state transition clock forward model</h2><span id='topic+prob_pd_stm_cf'></span>

<h3>Description</h3>

<p>Calculates membership probability of the progressed disease state at a given time (vectorized). This probability is from the state transition clock forward model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pd_stm_cf(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pd_stm_cf_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized) from baseline.</p>
</td></tr>
<tr><td><code id="prob_pd_stm_cf_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include pre-progression death (PPD), time to progression (TTP) and post progression survival calculated under the clock forward model (PPS-CF).</p>
</td></tr>
<tr><td><code id="prob_pd_stm_cf_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pd_stm_cf(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pd_stm_cr'>Calculate probability of having progressed disease under the state transition clock reset model</h2><span id='topic+prob_pd_stm_cr'></span>

<h3>Description</h3>

<p>Calculates membership probability of the progressed disease state at a given time (vectorized). This probability is from the state transition clock reset model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pd_stm_cr(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pd_stm_cr_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized) from baseline.</p>
</td></tr>
<tr><td><code id="prob_pd_stm_cr_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include pre-progression death (PPD), time to progression (TTP) and post progression survival calculated under the clock reset model (PPS-CR).</p>
</td></tr>
<tr><td><code id="prob_pd_stm_cr_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pd_stm_cr(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pf_psm'>Calculate probability of being progression free in partitioned survival model</h2><span id='topic+prob_pf_psm'></span>

<h3>Description</h3>

<p>Calculates membership probability for the progression free state, at a particular time (vectorized), given a partitioned survival model with given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pf_psm(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pf_psm_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized)</p>
</td></tr>
<tr><td><code id="prob_pf_psm_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include progression-free survival (PFS).</p>
</td></tr>
<tr><td><code id="prob_pf_psm_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pf_psm(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pf_stm'>Calculate probability of being progression free in either state transition model (clock forward or clock reset)</h2><span id='topic+prob_pf_stm'></span>

<h3>Description</h3>

<p>Calculates membership probability for the progression free state, at a particular time (vectorized), given either state transition model (clock forward or clock reset) with given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pf_stm(time, dpam, starting = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pf_stm_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized)</p>
</td></tr>
<tr><td><code id="prob_pf_stm_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include pre-progression death (PPD) and time to progression (TTP).</p>
</td></tr>
<tr><td><code id="prob_pf_stm_+3A_starting">starting</code></td>
<td>
<p>Vector of membership probabilities (PF, PD, death) at time zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pf_stm(0:100, params)

</code></pre>

<hr>
<h2 id='prob_pps_cf'>Calculate probability of post progression survival under the state transition clock forward model</h2><span id='topic+prob_pps_cf'></span>

<h3>Description</h3>

<p>Calculates probability of post progression survival at a given time from progression (vectorized). This probability is from the state transition clock forward model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pps_cf(ttptimes, ppstimes, dpam)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pps_cf_+3A_ttptimes">ttptimes</code></td>
<td>
<p>Time (numeric and vectorized) from progression - not time from baseline.</p>
</td></tr>
<tr><td><code id="prob_pps_cf_+3A_ppstimes">ppstimes</code></td>
<td>
<p>Time (numeric and vectorized) of progression</p>
</td></tr>
<tr><td><code id="prob_pps_cf_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include post progression survival calculated under the clock forward state transition model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the mean probabilities of post-progression survival at each PPS time, averaged over TTP times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pps_cf(0:100, 0:100, params)

</code></pre>

<hr>
<h2 id='prob_pps_cr'>Calculate probability of post progression survival under the state transition clock reset model</h2><span id='topic+prob_pps_cr'></span>

<h3>Description</h3>

<p>Calculates probability of post progression survival at a given time from progression (vectorized). This probability is from the state transition clock reset model, according to the given statistical distributions and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pps_cr(time, dpam)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_pps_cr_+3A_time">time</code></td>
<td>
<p>Time (numeric and vectorized) from baseline - not time from progression.</p>
</td></tr>
<tr><td><code id="prob_pps_cr_+3A_dpam">dpam</code></td>
<td>
<p>List of survival regressions for model endpoints. This must include post progression survival calculated under the clock reset state transition model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bosonc &lt;- create_dummydata("flexbosms")
fits &lt;- fit_ends_mods_spl(bosonc)
# Pick out best distribution according to min AIC
params &lt;- list(
  ppd = find_bestfit(fits$ppd, "aic")$fit,
  ttp = find_bestfit(fits$ttp, "aic")$fit,
  pfs = find_bestfit(fits$pfs, "aic")$fit,
  os = find_bestfit(fits$os, "aic")$fit,
  pps_cf = find_bestfit(fits$pps_cf, "aic")$fit,
  pps_cr = find_bestfit(fits$pps_cr, "aic")$fit
)
prob_pps_cr(0:100, params)

</code></pre>

<hr>
<h2 id='vlookup'>VLOOKUP function</h2><span id='topic+vlookup'></span>

<h3>Description</h3>

<p>Function to lookup values according to an index. Aims to behave similarly to VLOOKUP in Microsoft Excel, however several lookups can be made at once (<code>indexval</code> can be a vector) and interpolation is available where lookups are inexact (choice of 4 methods).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlookup(indexval, indexvec, valvec, method = "geom")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vlookup_+3A_indexval">indexval</code></td>
<td>
<p>The index value to be looked-up (may be a vector of multiple values)</p>
</td></tr>
<tr><td><code id="vlookup_+3A_indexvec">indexvec</code></td>
<td>
<p>The vector of indices to look-up within</p>
</td></tr>
<tr><td><code id="vlookup_+3A_valvec">valvec</code></td>
<td>
<p>The vector of values corresponding to the vector of indices</p>
</td></tr>
<tr><td><code id="vlookup_+3A_method">method</code></td>
<td>
<p>Method may be <code>floor</code>, <code>ceiling</code>, <code>arith</code> or <code>geom</code> (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or vector, depending on the lookup/interpolation method chosen:
</p>

<ul>
<li> <p><code>floor</code>: Floor (minimum) value, where interpolation is required between measured values
</p>
</li>
<li> <p><code>ceiling</code>: Ceiling (maximum) value, where interpolation is required between measured values
</p>
</li>
<li> <p><code>arith</code>: Arithmetic mean, where interpolation is required between measured values
</p>
</li>
<li> <p><code>geom</code>: Geometric mean, where interpolation is required between measured values
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="HMDHFDplus.html#topic+readHMDweb">HMDHFDplus::readHMDweb</a> can be used to obtain lifetables from the Human Mortality Database
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose we have survival probabilities at times 0 to 20
times &lt;- 0:20
survival &lt;- 1-times*0.04
# We would like to look-up the survival probability at time 7
vlookup(7, times, survival)
# In this case, the floor, ceiling, arith and geom values are identical
# because survival time 7 is known, and no interpolation is necessary
vlookup(c(7, 7.5), times, survival)
# The second row of the returned tibble reveal different estimates of the survival at time 7.5.
# The values vary according to the interpolation method between
# observed survival values at times 7 and 8.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
