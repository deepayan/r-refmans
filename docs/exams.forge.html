<!DOCTYPE html><html><head><title>Help for package exams.forge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exams.forge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#exams.forge-package'><p>exams.forge: A brief description the package</p></a></li>
<li><a href='#add_data'><p>Vector Data Addition</p></a></li>
<li><a href='#affix'><p>Quote and Prefix and/or Suffix Manipulation</p></a></li>
<li><a href='#all_different'><p>Difference Testing</p></a></li>
<li><a href='#as_result'><p>Results with Rounding</p></a></li>
<li><a href='#as_string'><p>Vector to String Conversion</p></a></li>
<li><a href='#as_table'><p>Conversion to Table</p></a></li>
<li><a href='#as_ts'><p>Time Series</p></a></li>
<li><a href='#assoc_data'><p>Frequency Optimization</p></a></li>
<li><a href='#binom_param'><p>Binomial Parameters</p></a></li>
<li><a href='#breaks'><p>Breaks</p></a></li>
<li><a href='#calledBy'><p>Function Calling</p></a></li>
<li><a href='#catif'><p>Condition <code>cat</code></p></a></li>
<li><a href='#CImu_data'><p>Confidence Intervals</p></a></li>
<li><a href='#CImulen_data'><p>Confidence Interval and Sample Size for the Population Mean Value</p></a></li>
<li><a href='#CIpilen_data'><p>Confidence Interval and Sample Size for the Population Proportion</p></a></li>
<li><a href='#combinatorics'><p>Combinatorics</p></a></li>
<li><a href='#cor_data'><p>Correlation and Data Generation</p></a></li>
<li><a href='#data_n'><p>Number of Observations</p></a></li>
<li><a href='#data_prob2'><p>Probability/Frequency Matrix Generation</p></a></li>
<li><a href='#ddiscrete'><p>Discrete Probability Function</p></a></li>
<li><a href='#ddiscrete2'><p>Bivariate Discrete Probability Function</p></a></li>
<li><a href='#ddunif2'><p>Sum of Two Independent Discrete Uniform Distributions</p></a></li>
<li><a href='#distribution'><p>Class Distribution</p></a></li>
<li><a href='#distributions'><p>Distributions</p></a></li>
<li><a href='#divisor_25'><p>Number Properties</p></a></li>
<li><a href='#equal'><p>Conditional Value Matching</p></a></li>
<li><a href='#equations'><p>Equations and Variables</p></a></li>
<li><a href='#exams2call'><p>Traceback for <code>exams2</code> Functions</p></a></li>
<li><a href='#exercise'><p>Data Exercise Structure</p></a></li>
<li><a href='#extremes'><p>Extremes</p></a></li>
<li><a href='#fcvt'><p>Number to String Conversion (Floating Point / Fractional Number)</p></a></li>
<li><a href='#firstmatch'><p>Firstmatch</p></a></li>
<li><a href='#fractions'><p>Fractions</p></a></li>
<li><a href='#gapply'><p>Apply Grid</p></a></li>
<li><a href='#grade'><p>Grades</p></a></li>
<li><a href='#grouped_data'><p>Central Tendency Measures' Computation of Grouped Data</p></a></li>
<li><a href='#gsimplify'><p>Simplified <code>hyperloop</code> Object</p></a></li>
<li><a href='#histbreaks'><p>Histogram Breakpoints</p></a></li>
<li><a href='#histdata'><p>Histogram Data</p></a></li>
<li><a href='#histwidth'><p>Histogram Widths</p></a></li>
<li><a href='#histx'><p>Midpoint-Based Data Creation for a Histogram</p></a></li>
<li><a href='#hm_cell'><p><code>html_mmatrix</code> Modification</p></a></li>
<li><a href='#html_e2m'><p>HTML <code>exams.forge</code></p></a></li>
<li><a href='#html_matrix'><p>HTML Representation</p></a></li>
<li><a href='#html_matrix_sk'><p><code>html_matrix</code> Object Creation</p></a></li>
<li><a href='#hyper_param'><p>Parameters for Hypergeometric Distributions</p></a></li>
<li><a href='#hyperloop'><p>Hyperloop</p></a></li>
<li><a href='#hypothesis_latex'><p>Latex Hypothesis</p></a></li>
<li><a href='#incomplete_table'><p>Relative Contingency Table Fill</p></a></li>
<li><a href='#inline'><p>Text Knitting</p></a></li>
<li><a href='#is.prob'><p>Interval Checker</p></a></li>
<li><a href='#knitif'><p>Knitting a Text Argument</p></a></li>
<li><a href='#latexdef'><p>Exam PDF with LaTeX</p></a></li>
<li><a href='#lcmval'><p>Least Common Multiple</p></a></li>
<li><a href='#lm1_data'><p>Simple Linear Regression and Data Generation</p></a></li>
<li><a href='#lmr_data'><p><code>lm</code> Simple Linear Regression</p></a></li>
<li><a href='#lsumprod'><p>Supporting Functions for Math LaTeX Output</p></a></li>
<li><a href='#makekey'><p>Character Key Generation</p></a></li>
<li><a href='#mcval'><p>Most Common Value</p></a></li>
<li><a href='#meanint_data'><p>Integer Observations and Mean</p></a></li>
<li><a href='#means_choice'><p>Means</p></a></li>
<li><a href='#mime_image'><p>MIME Image</p></a></li>
<li><a href='#monomial'><p>Monomial</p></a></li>
<li><a href='#moodle_m2s'><p>Moodle Multiple-Choice</p></a></li>
<li><a href='#nearest_arg'><p>Nearest Candidate Value</p></a></li>
<li><a href='#nom.cc'><p>Association and Correlation</p></a></li>
<li><a href='#nosanitize'><p>Sanitization</p></a></li>
<li><a href='#now'><p>Current Time</p></a></li>
<li><a href='#nsprintf'><p>sprintf with template depending on integer valued <code>n</code></p></a></li>
<li><a href='#num_result'><p>Numeric Rounding List</p></a></li>
<li><a href='#num_solve'><p>Target Variable Value</p></a></li>
<li><a href='#num2str'><p>Number to String Conversion</p></a></li>
<li><a href='#pdensity'><p>Density Function</p></a></li>
<li><a href='#pearson_data'><p>Pearson Data</p></a></li>
<li><a href='#pminimum'><p>Polynomial Minimum</p></a></li>
<li><a href='#pos'><p>Interval Ranges</p></a></li>
<li><a href='#pprobability'><p>Polynomial Probability</p></a></li>
<li><a href='#print.equations'><p>print.equations</p></a></li>
<li><a href='#print.html_matrix'><p>Print <code>html_matrix</code></p></a></li>
<li><a href='#prob_solve'><p>Total or Conditional Probability Computation</p></a></li>
<li><a href='#proptest_data'><p>Binomial Test Data Creation</p></a></li>
<li><a href='#proptest_num'><p>Proportion Tests</p></a></li>
<li><a href='#proptests'><p>Proportion Tests</p></a></li>
<li><a href='#q2norm'><p>Mean and Standard Deviation for Normal Distribution</p></a></li>
<li><a href='#random'><p>Random</p></a></li>
<li><a href='#refer'><p>Generate Vector Element Names</p></a></li>
<li><a href='#replace_fmt'><p>Replace</p></a></li>
<li><a href='#rv'><p>Random Variable</p></a></li>
<li><a href='#sample_size_freq'><p>Sample Size Consistency Checker</p></a></li>
<li><a href='#scale_to'><p>Rescaling</p></a></li>
<li><a href='#skalenniveau'><p>Skalenniveau</p></a></li>
<li><a href='#solution'><p>Solutions</p></a></li>
<li><a href='#sos100'><p>Precomputed Sum of Squared Data</p></a></li>
<li><a href='#spell'><p>RMarkdown Spell Check</p></a></li>
<li><a href='#sqrtnp'><p>Calculating Square Roots of n<em>p</em>(1-p) Combinations</p></a></li>
<li><a href='#sumofsquares'><p>Sum of Squared Integers</p></a></li>
<li><a href='#sumofsquares1'><p>sumofsquares1</p></a></li>
<li><a href='#t2norm'><p>Approximations</p></a></li>
<li><a href='#table_data'><p>Frequency Table</p></a></li>
<li><a href='#template'><p>Template</p></a></li>
<li><a href='#to_choice'><p>Questions and Solutions List Generation</p></a></li>
<li><a href='#toHTML.html_matrix'><p>HTML and LaTeX Matrix Representations</p></a></li>
<li><a href='#toLatex.polynomial'><p>LaTeX Representation of a Polynomial</p></a></li>
<li><a href='#tooltip'><p>Tooltip</p></a></li>
<li><a href='#toRMarkdown'><p>toRMarkdown</p></a></li>
<li><a href='#toString.polynomial'><p>Text Representation of a Polynomial</p></a></li>
<li><a href='#transformif'><p>Transformation</p></a></li>
<li><a href='#ts_data'><p>Time Series</p></a></li>
<li><a href='#ts_moving_average'><p>Moving Average</p></a></li>
<li><a href='#ts_trend_season'><p>Trend and Season Model</p></a></li>
<li><a href='#ttest_data'><p>T-tests and Data Creation</p></a></li>
<li><a href='#ttest_num'><p>T-tests</p></a></li>
<li><a href='#ttests'><p>T-tests</p></a></li>
<li><a href='#unique_elem'><p>Unique Elements</p></a></li>
<li><a href='#unique_max'><p>Unique Maximum</p></a></li>
<li><a href='#vec2mat'><p>Vector to Matrix Conversion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Support for Compiling Examination Tasks using the 'exams'
Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-08</td>
</tr>
<tr>
<td>Description:</td>
<td>The main aim is to further facilitate the creation of exercises based on the package 'exams' 
    by Gr√ºn, B., and Zeileis, A. (2009) &lt;<a href="https://doi.org/10.18637%2Fjss.v029.i10">doi:10.18637/jss.v029.i10</a>&gt;. Creating effective student exercises 
    involves challenges such as creating appropriate data sets and ensuring access to intermediate values 
    for accurate explanation of solutions. The functionality includes the generation of univariate and 
    bivariate data including simple time series, functions for theoretical distributions and their approximation, 
    statistical and mathematical calculations for tasks in basic statistics courses as well as general tasks 
    such as string manipulation, LaTeX/HTML formatting and the editing of XML task files for 'Moodle'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), tools, polynom</td>
</tr>
<tr>
<td>Imports:</td>
<td>base64enc, extraDistr, exams, knitr, MASS, methods, magrittr,
psych, rjson, rstudioapi, spelling, stringdist, stringr,
stranslate, tinytex, utils, xml2, xtable, yaml</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 09:29:52 UTC; sigbert</td>
</tr>
<tr>
<td>Author:</td>
<td>Sigbert Klinke [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sigbert Klinke &lt;sigbert@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-10 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='exams.forge-package'>exams.forge: A brief description the package</h2><span id='topic+exams.forge'></span><span id='topic+exams.forge-package'></span>

<h3>Description</h3>

<p>The <code>exams.forge</code> package was created with the main goal of &quot;forging&quot; exam
tasks in combination with the <code>exams</code> package, and it includes additional
functions to simplify the creation of Moodle exercises.
The package features various functions categorized into seven groups based on
their characteristics. These categories are named:
Data Conversion and Modification, Statistical Analysis,
Mathematical Computations, Exercise Generation, String Manipulation,
LaTeX and HTML Functions, and General Purpose Functions.
</p>


<h3>Details</h3>

<p>This package is designed for educators who need to develop examination materials
in the field of statistics, particularly for introductory courses like Statistics I and II,
using the R programming language. The aim is to streamline the process of creating a
large number of assessment items, enabling instructors to focus on improving the quality
of the tasks themselves.
</p>
<p>We would like to acknowledge the support provided by the Multimedia Funding Program.
Their assistance has been invaluable to our project, and we extend our sincere gratitude
for their contributions.
</p>


<h3>Features of the package</h3>


<ul>
<li><p> Feature 1: <code>exams.forge</code> simplifies the generation of examination tasks by providing tools to
create a diverse array of statistical exercises, ensuring unique problem sets for each student.
</p>
</li>
<li><p> Feature 2:  It includes functions for precise data conversion, statistical analysis,
and mathematical computations, enhancing the accuracy and relevance of generated exercises.
</p>
</li>
<li><p> Feature 3: The package supports multi-format rendering, allowing the seamless creation of
LaTeX and HTML documents suitable for various educational platforms, such as Moodle.
</p>
</li></ul>



<h3>Functions</h3>

<p>Examples of functions included in the package:
</p>

<ul>
<li> <p><code><a href="#topic+ts_data">ts_data</a></code>: Creates a univariate time series by combining elements of a
linear or exponential trend, additive or multiplicative seasonal adjustment, and white noise.
The resulting time series is structured as a <code style="white-space: pre;">&#8288;ts_data object&#8288;</code>, allowing for further analysis and exploration.
</p>
</li>
<li> <p><code><a href="#topic+lmatrix">lmatrix</a></code>: Creates a LaTeX or HTML representation of a matrix.
This function is useful for integrating well-formatted matrices into LaTeX or HTML documents.
</p>
</li>
<li> <p><code><a href="#topic+as_obs">as_obs</a></code>: Creates a string representing observations with optional sorting
and LaTeX formatting, useful for generating readable data representations in educational materials.
</p>
</li></ul>



<h3>Usage</h3>

<p>Example usage of the package and its functions.
</p>
<p><code>
library(exams.forge)
# Generate a time series with specified parameters
ts_eg &lt;- ts_data(end = 20, trend = TRUE, trend.coeff = c(1, 0.5), season = TRUE, season.coeff = c(0.2, 0.1), error = TRUE, error.coeff = 0.1, digits = 2)
print(ts_eg)
</code>
</p>
<p><code>
# Create a matrix
mx_data &lt;- matrix(1:6, ncol = 2)
# Generate a LaTeX representation of the matrix with tooltip
eg_matrix &lt;- lmatrix(
 m = mx_data,
 title = "Example LaTeX Matrix",
 fmt = "
 byrow = TRUE,
 tooltip = "Die Tabelle hat 
cat(eg_matrix)
</code>
</p>
<p><code>
# Create a string representation of observations
observations &lt;- c(10, 20, 30, 40, 50)
observation_string &lt;- as_obs(observations, last = " and ")
print(observation_string)
</code>
</p>


<h3>Installation</h3>

<p>To install this package please use the following command:
<code>install.packages("exams.forge")</code>
</p>


<h3>Author(s)</h3>

<p>Sigbert Klinke, Affiliation: Humboldt University of Berlin, School of Business and Economics, Chair of Statistics.
</p>


<h3>Maintainer</h3>

<p>Sigbert Klinke <a href="mailto:sigbert@wiwi.hu-berlin.de">sigbert@wiwi.hu-berlin.de</a>
</p>


<h3>License</h3>

<p>Gnu General Public License 3.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sigbert Klinke <a href="mailto:sigbert@hu-berlin.de">sigbert@hu-berlin.de</a>
</p>

<hr>
<h2 id='add_data'>Vector Data Addition</h2><span id='topic+add_data'></span>

<h3>Description</h3>

<p>Adds data values to a given data vector <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data(x, box, n = c(0, 1), range = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_data_+3A_x">x</code></td>
<td>
<p>numeric: data vector</p>
</td></tr>
<tr><td><code id="add_data_+3A_box">box</code></td>
<td>
<p>character or numeric: a basic box is used</p>
</td></tr>
<tr><td><code id="add_data_+3A_n">n</code></td>
<td>
<p>numeric: number of  data values on the left, the right, or both sides of <code>x</code> (default: <code>c(0,1)</code>)</p>
</td></tr>
<tr><td><code id="add_data_+3A_range">range</code></td>
<td>
<p>numeric: determines the range where the additional data values will be drawn from (default: <code>c(0,1)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the data <code>x</code>, or the <code>range(box)</code>, a box is computed.
The length of the box gives the multiplier for the <code>range</code>.
Then a left and right interval, from which the additional values are drawn uniformly, is computed:
<code class="reqn">[left box value-range[2]*box length; left box value-range[1]*box length]</code> (left interval) and
<code class="reqn">[right box value+range[1]*box length; right box value+range[2]*box length]</code> (right interval).
</p>
<p>For <code>box</code>, <code>"boxplot"</code> can be also used and <code>quantile(x, c(0.25, 0.75), na.rm=TRUE)</code> can be used instead of
<code>range(x, na.rm=TRUE)</code>.
</p>
<p><code>n</code> can be a single number which will add <code>n</code> data values at the right side of <code>x</code>.
If <code>n</code> is a vector of length two, then <code>n[1]</code> data values will be added at the left side of <code>x</code> and
<code>n[2]</code> data values will be added at the right side of <code>x</code>.
</p>


<h3>Value</h3>

<p>a data vector with new values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(8)
# add one value to the right
add_data(x, "box", range=1.5)
add_data(x, "range", range=0.1)
add_data(x, "box", range=c(1.5, 3))
# add two values to the right
add_data(x, "range", n=2, range=0.1)
# add two values to the left and three to the right
add_data(x, "range", n=c(2,3), range=0.1)
</code></pre>

<hr>
<h2 id='affix'>Quote and Prefix and/or Suffix Manipulation</h2><span id='topic+affix'></span><span id='topic+add_affix'></span><span id='topic+add_math'></span><span id='topic+lmath'></span><span id='topic+add_bracket'></span><span id='topic+brkt'></span><span id='topic+add_cdata'></span><span id='topic+remove_affix'></span><span id='topic+remove_quotes'></span><span id='topic+remove_cdata'></span><span id='topic+math'></span><span id='topic+bracket'></span><span id='topic+unaffix'></span><span id='topic+unquote'></span><span id='topic+uncdata'></span><span id='topic+cdata'></span>

<h3>Description</h3>

<p><code>affix</code> adds a prefix and/or a suffix to a (character) vector
</p>
<p><code>math</code> adds a <code>$</code> as pre- and suffix to a (character) vector
</p>
<p><code>bracket</code> adds a <code>(</code> as prefix and <code>)</code> as suffix to a (character) vector
</p>
<p><code>unaffix</code> deletes a pre- and/or suffix to a (character) vector
</p>
<p><code>unquote</code> deletes double quotes at the beginning and the ending of a (character) vector
</p>
<p><code>uncdata</code> deletes a <code>&lt;![CDATA[</code> as prefix and <code>]]&gt;</code> as suffix
</p>
<p><code>cdata</code> adds a <code>&lt;![CDATA[</code> as prefix and <code>]]&gt;</code> as suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affix(txt, prefix = "", suffix = "")

math(txt)

bracket(txt)

unaffix(txt, prefix = "", suffix = "")

unquote(txt)

uncdata(txt)

cdata(txt)

add_affix(txt, prefix = "", suffix = "")

add_cdata(txt)

add_math(txt)

lmath(txt)

add_bracket(txt)

brkt(txt)

remove_affix(txt, prefix = "", suffix = "")

remove_quotes(txt)

remove_cdata(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affix_+3A_txt">txt</code></td>
<td>
<p>vector: (character) vector to add a prefix and/or a suffix</p>
</td></tr>
<tr><td><code id="affix_+3A_prefix">prefix</code></td>
<td>
<p>character: prefix to add or delete (default: <code>""</code>)</p>
</td></tr>
<tr><td><code id="affix_+3A_suffix">suffix</code></td>
<td>
<p>character: suffix to add or delete (default: <code>""</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
affix(x, "$", "$")
math(x)
</code></pre>

<hr>
<h2 id='all_different'>Difference Testing</h2><span id='topic+all_different'></span>

<h3>Description</h3>

<p>Tests if the differences between the entries in <code>obj</code> are larger than <code>tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_different(obj, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_different_+3A_obj">obj</code></td>
<td>
<p>object: numeric R object that can be converted to a vector</p>
</td></tr>
<tr><td><code id="all_different_+3A_tol">tol</code></td>
<td>
<p>numeric: minimum value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10)
all_different(x, 0.0001)
all_different(x, 1)
</code></pre>

<hr>
<h2 id='as_result'>Results with Rounding</h2><span id='topic+as_result'></span><span id='topic+as_res'></span><span id='topic+tolerance'></span><span id='topic+tol'></span><span id='topic+rounded'></span><span id='topic+val'></span><span id='topic+digits'></span>

<h3>Description</h3>

<p>Rounds <code>x</code> according to <code>digits</code>, <code>FUN</code> and sets a tolerance for the result.
If the tolerance is not stated, consider it the maximum of <code>2*10^(-digits)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_result(x, digits, tol = NA, FUN = round2)

tol(x)

rounded(x)

val(x)

digits(x)

as_res(x, digits, tol = NA, FUN = round2)

tolerance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_result_+3A_x">x</code></td>
<td>
<p>numeric: value to round</p>
</td></tr>
<tr><td><code id="as_result_+3A_digits">digits</code></td>
<td>
<p>integer or character: Digits that should be used for rounding or <code>"integer"</code> for <code>digits=0</code>, <code>"%"</code> for <code>digits=2</code>,  or  <code>"probability"</code> for <code>digits=4</code>. Abbreviations for the names can be used</p>
</td></tr>
<tr><td><code id="as_result_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for result</p>
</td></tr>
<tr><td><code id="as_result_+3A_fun">FUN</code></td>
<td>
<p>function: rounding function (default: <code>round2</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the original and a rounded value, digits used and tolerance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_result(1/3, "prob")
tol(x)
rounded(x)
tol(x)
digits(x)
</code></pre>

<hr>
<h2 id='as_string'>Vector to String Conversion</h2><span id='topic+as_string'></span><span id='topic+lstring'></span><span id='topic+as_obs'></span><span id='topic+lobs'></span><span id='topic+as_sum'></span><span id='topic+as_fraction'></span><span id='topic+lfrac'></span>

<h3>Description</h3>

<p>Converts a character vector into a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_string(txt, collapse = ", ", last = ", and ")

as_sum(txt)

as_obs(txt, name = "x", sorted = FALSE, ...)

as_fraction(val, latex = FALSE, sorted = FALSE, ...)

lobs(txt, name = "x", sorted = FALSE, ...)

lstring(txt, collapse = ", ", last = ", and ")

lfrac(val, latex = FALSE, sorted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_string_+3A_txt">txt</code></td>
<td>
<p>vector: (character) vector to merge</p>
</td></tr>
<tr><td><code id="as_string_+3A_collapse">collapse</code></td>
<td>
<p>character: glues text between elements (default: <code>", "</code>)</p>
</td></tr>
<tr><td><code id="as_string_+3A_last">last</code></td>
<td>
<p>character: glues text between the two last elements (default: <code>", and "</code>)</p>
</td></tr>
<tr><td><code id="as_string_+3A_name">name</code></td>
<td>
<p>character: observation name (default: <code>"x"</code>)</p>
</td></tr>
<tr><td><code id="as_string_+3A_sorted">sorted</code></td>
<td>
<p>logical: sorted or not sorted observations  (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="as_string_+3A_...">...</code></td>
<td>
<p>further parameters (given from <code>as_obs</code> to <code>as_string</code>)</p>
</td></tr>
<tr><td><code id="as_string_+3A_val">val</code></td>
<td>
<p>numeric: values to convert into fractions</p>
</td></tr>
<tr><td><code id="as_string_+3A_latex">latex</code></td>
<td>
<p>logical use of LaTeX <code>\frac{.}{.}</code> or not (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
y &lt;- c(TRUE, FALSE, NA) 
as_string(x)
as_string(y)
# toString
as_string(as.character(x))
as_string(as.character(y))
#
as_obs(x)
as_obs(sort(x), sorted=TRUE)
#
x &lt;- round(runif(5), 2)
as_fraction(x)
as_fraction(x, TRUE)
#
y &lt;- round(runif(5), 2)
as_sum(x)
</code></pre>

<hr>
<h2 id='as_table'>Conversion to Table</h2><span id='topic+as_table'></span><span id='topic+toTable'></span>

<h3>Description</h3>

<p>Converts a vector into a horizontal table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_table(
  x,
  caption = NULL,
  label = NULL,
  align = NULL,
  digits = NULL,
  display = NULL,
  auto = FALSE,
  ...
)

toTable(
  x,
  caption = NULL,
  label = NULL,
  align = NULL,
  digits = NULL,
  display = NULL,
  auto = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_table_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class found among <code>methods(xtable)</code>.  See
below on how to write additional method functions for <code>xtable</code>.</p>
</td></tr>
<tr><td><code id="as_table_+3A_caption">caption</code></td>
<td>
<p>Character vector of length 1 or 2 containing the
table's caption or title.  If length is 2, the second item is the
&quot;short caption&quot; used when LaTeX generates a &quot;List of Tables&quot;. Set to
<code>NULL</code> to suppress the caption.  Default value is <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="as_table_+3A_label">label</code></td>
<td>
<p>Character vector of length 1 containing the LaTeX label
or HTML anchor. Set to <code>NULL</code> to suppress the label.  Default
value is <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="as_table_+3A_align">align</code></td>
<td>
<p>Character vector of length equal to the number of columns
of the resulting table, indicating the alignment of the corresponding
columns.  Also, <code>"|"</code> may be used to produce vertical lines
between columns in LaTeX tables, but these are effectively ignored
when considering the required length of the supplied vector.  If a
character vector of length one is supplied, it is split as
<code>strsplit(align, "")[[1]]</code> before processing. Since the row
names are printed in the first column, the length of <code>align</code> is
one greater than <code>ncol(x)</code> if <code>x</code> is a
<code>data.frame</code>. Use <code>"l"</code>, <code>"r"</code>, and <code>"c"</code> to
denote left, right, and center alignment, respectively.  Use
<code>"p{3cm}"</code> etc. for a LaTeX column of the specified width. For
HTML output the <code>"p"</code> alignment is interpreted as <code>"l"</code>,
ignoring the width request. Default depends on the class of
<code>x</code>. </p>
</td></tr>
<tr><td><code id="as_table_+3A_digits">digits</code></td>
<td>

<p>Numeric vector of length equal to one (in which case it will be
replicated as necessary) or to the number of columns of the
resulting table <b>or</b> matrix of the same size as the resulting
table, indicating the number of digits to display in the
corresponding columns. Since the row names are printed in the first
column, the length of the vector <code>digits</code> or the number of
columns of the matrix <code>digits</code> is one greater than
<code>ncol(x)</code> if <code>x</code> is a <code>data.frame</code>. Default depends
on the class of <code>x</code>. If values of <code>digits</code> are negative, the
corresponding values of <code>x</code> are displayed in scientific format
with <code>abs(digits)</code> digits.</p>
</td></tr>
<tr><td><code id="as_table_+3A_display">display</code></td>
<td>

<p>Character vector of length equal to the number of columns of the
resulting table, indicating the format for the corresponding columns.
Since the row names are printed in the first column, the length of
<code>display</code> is one greater than <code>ncol(x)</code> if <code>x</code> is a
<code>data.frame</code>.  These values are passed to the <code>formatC</code>
function.  Use <code>"d"</code> (for integers), <code>"f"</code>, <code>"e"</code>,
<code>"E"</code>, <code>"g"</code>, <code>"G"</code>, <code>"fg"</code> (for reals), or
<code>"s"</code> (for strings).  <code>"f"</code> gives numbers in the usual
<code>xxx.xxx</code> format; <code>"e"</code> and <code>"E"</code> give
<code>n.ddde+nn</code> or <code>n.dddE+nn</code> (scientific format); <code>"g"</code>
and <code>"G"</code> put <code>x[i]</code> into scientific format only if it
saves space to do so.  <code>"fg"</code> uses fixed format as <code>"f"</code>,
but <code>digits</code> as number of <em>significant</em> digits.  Note that
this can lead to quite long result strings.  Default depends on the
class of <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_table_+3A_auto">auto</code></td>
<td>

<p>Logical, indicating whether to apply automatic format when no value
is passed to <code>align</code>, <code>digits</code>, or <code>display</code>. This
&lsquo;autoformat&rsquo; (based on <code>xalign</code>, <code>xdigits</code>, and
<code>xdisplay</code>) can be useful to quickly format a typical
<code>matrix</code> or <code>data.frame</code>. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as_table_+3A_...">...</code></td>
<td>
<p>further parameters for <code>print.xtable</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
tab &lt;- vec2mat(x, colnames=1:length(x))
as_table(tab)
</code></pre>

<hr>
<h2 id='as_ts'>Time Series</h2><span id='topic+as_ts'></span>

<h3>Description</h3>

<p>Converts a <code>ts_data</code> object into a time series object (<code>ts</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ts(ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_ts_+3A_ts">ts</code></td>
<td>
<p><code>ts_data</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time series from linear trend
ts &lt;- ts_data(12, trend.coeff= c(sample(0:10, 1), sample(1+(1:10)/20, 1)))
as_ts(ts)
</code></pre>

<hr>
<h2 id='assoc_data'>Frequency Optimization</h2><span id='topic+assoc_data'></span><span id='topic+reorder_association_data'></span><span id='topic+dassoc'></span>

<h3>Description</h3>

<p>Given a frequency table, the function reorders the observations such that the given <code>target</code> association will be approximated and the marginal
frequencies remain unchanged. Note that the <code>target</code> association may not be reached!
<code>zero</code> allows for zero entries in the common distribution.
If <code>target</code> is <code>NA</code> then the table is simply returned. <code>FUN</code> computes the association (or correlation) measure based on a
frequency table. <code>tol</code> gives the maximal deviation of the association (or correlation) measure
and the <code>target</code> value. <code>maxit</code> limits the number of steps.
Please note that a solution is not guaranteed, especially for extreme values of <code>target</code>, for example
for <code class="reqn">+1</code>, <code class="reqn">-1</code> or nearby values.
If <code>attr(joint, "iterations")== maxit</code> then you need either to increase <code>maxit</code>, to decrease <code>tol</code>, or
check if you have chosen an appropriate <code>target</code> value (for a nominal measure in <code class="reqn">0 &lt;= target &lt;= 1</code>, for ordinal measure in <code class="reqn">-1 &lt;= target &lt;= +1</code>).
<code>attr(joint, "target")</code> contains the achieved association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assoc_data(
  tab,
  zero = FALSE,
  FUN = nom.cc,
  target = NA,
  tol = 0.001,
  maxit = 500,
  ...
)

reorder_association_data(
  tab,
  zero = FALSE,
  FUN = nom.cc,
  target = NA,
  tol = 0.001,
  maxit = 500,
  ...
)

dassoc(
  tab,
  zero = FALSE,
  FUN = nom.cc,
  target = NA,
  tol = 0.001,
  maxit = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assoc_data_+3A_tab">tab</code></td>
<td>
<p>table: table of absolute frequencies</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_zero">zero</code></td>
<td>
<p>logical: zeros are allowed in the final probabilities (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_fun">FUN</code></td>
<td>
<p>function: association or correlation function (default: <code>nom.cc</code>)</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_target">target</code></td>
<td>
<p>numeric: target association or correlation (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for target association or correlation (default: <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_maxit">maxit</code></td>
<td>
<p>integer: maximal number of iterations (default: <code>100</code>)</p>
</td></tr>
<tr><td><code id="assoc_data_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified frequency table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- table_data(3, 2)
tab
tab2 &lt;- assoc_data(tab, target=0.5)
tab2
</code></pre>

<hr>
<h2 id='binom_param'>Binomial Parameters</h2><span id='topic+binom_param'></span>

<h3>Description</h3>

<p>Generates a data frame with potential values for <code>size</code> and <code>prob</code>,
and is subjected to specific conditions:
</p>

<ul>
<li><p> If <code>length(mean) == 1</code> and it's an integer, it signifies the desired number of digits for the mean.
</p>
</li>
<li><p> If <code>mean</code> is set to <code>NA</code> (the default), all means are permissible.
</p>
</li>
<li><p> When <code>length(mean) &gt; 1</code>, the product <code>size * prob</code> must be one of the valid means.
</p>
</li>
<li><p> The same rules applies to <code>sd</code>.
</p>
</li></ul>

<p>The parameters <code>norm</code> and <code>pois</code> can take on values of <code>NA</code>, <code>TRUE</code>, <code>FALSE</code>,
or be defined as a function in the format: <code style="white-space: pre;">&#8288;function(size, prob)&#8288;</code>.
These values determine which <code style="white-space: pre;">&#8288;(size, prob)&#8288;</code> combinations are eligible:
</p>

<ul>
<li><p> For <code>NA</code>, all combinations of <code style="white-space: pre;">&#8288;(size, prob)&#8288;</code> are acceptable.
</p>
</li>
<li><p> If specified as a function, only those combinations for which the function returns <code>TRUE</code> are considered valid.
</p>
</li>
<li><p> If set to <code>TRUE</code>, combinations are accepted only if they satisfy either the condition <code>size * prob * (1 - prob) &gt; 9</code>
(for <code>norm</code>, indicating a normal distribution approximation), or the conditions <code>prob &lt; 0.05</code> and <code>n &gt; 10</code>
(for <code>pois</code>, implying a Poisson distribution approximation).
</p>
</li>
<li><p> If set to <code>FALSE</code>, the approximations should not hold for any combination.
</p>
</li></ul>

<p>Please be aware that there is no guarantee that the resulting data frame will include a valid solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom_param(n, p, mean = NA, sd = NA, norm = NA, pois = NA, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom_param_+3A_n">n</code></td>
<td>
<p>integer: vector number of observations</p>
</td></tr>
<tr><td><code id="binom_param_+3A_p">p</code></td>
<td>
<p>numeric: vector of probabilities</p>
</td></tr>
<tr><td><code id="binom_param_+3A_mean">mean</code></td>
<td>
<p>integer or numeric: number of digits the mean should have</p>
</td></tr>
<tr><td><code id="binom_param_+3A_sd">sd</code></td>
<td>
<p>integer or numeric: number of digits the standard deviation should have</p>
</td></tr>
<tr><td><code id="binom_param_+3A_norm">norm</code></td>
<td>
<p>logical or function: normal approximation possible</p>
</td></tr>
<tr><td><code id="binom_param_+3A_pois">pois</code></td>
<td>
<p>logical or function: poisson approximation possible</p>
</td></tr>
<tr><td><code id="binom_param_+3A_tol">tol</code></td>
<td>
<p>numeric: the tolerance for numerical comparison (default: '1e-6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with possible choices of <code>n</code> , <code>p</code>, <code>mean</code> and <code>sd</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binom_param(1000:50000, (5:25)/100, 0, 0)
</code></pre>

<hr>
<h2 id='breaks'>Breaks</h2><span id='topic+breaks'></span><span id='topic+add_breaks'></span><span id='topic+dbreaks'></span>

<h3>Description</h3>

<p>Creates a number of equidistant or non-equidistant breaks for given data <code>x</code>.
If <code>width</code> is not given then it will be set to <code>diff(pretty(x))[1]</code>.
<code>probs</code> can either be a single integer, giving the number of quantiles, or a vector of probabilities with values in <code class="reqn">[0,1]</code>.
Please note that if <code>width</code> is too large, then using <code>probs</code> may result in equidistant breaks too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaks(x, width = NULL, probs = NULL)

add_breaks(x, width = NULL, probs = NULL)

dbreaks(x, width = NULL, probs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breaks_+3A_x">x</code></td>
<td>
<p>numeric: data</p>
</td></tr>
<tr><td><code id="breaks_+3A_width">width</code></td>
<td>
<p>numeric: class width (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="breaks_+3A_probs">probs</code></td>
<td>
<p>numeric: number of non-equidistant classes (default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of breaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, mean=1.8, sd=0.1)
breaks(x)
breaks(x, 0.1)
breaks(x, 0.1, probs=4)
</code></pre>

<hr>
<h2 id='calledBy'>Function Calling</h2><span id='topic+calledBy'></span><span id='topic+called_by'></span>

<h3>Description</h3>

<p>Checks if the result from <a href="base.html#topic+sys.parent">base::sys.calls</a> contains a call from <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calledBy(fun = "exams2pdf")

called_by(fun = "exams2pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calledBy_+3A_fun">fun</code></td>
<td>
<p>character: name of the calling function (default: <code>exams2pdf</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>funb &lt;- function() { calledBy('funa') }
funa &lt;- function() { funb() }
funa()
</code></pre>

<hr>
<h2 id='catif'>Condition <code>cat</code></h2><span id='topic+catif'></span><span id='topic+condition_cat'></span>

<h3>Description</h3>

<p>Calls <code>cat</code> if <code>cond==TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catif(cond, ...)

condition_cat(cond, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catif_+3A_cond">cond</code></td>
<td>
<p>logical: condition, if true then <code>cat</code> is called, otherwise not</p>
</td></tr>
<tr><td><code id="catif_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly <code>cond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catif(TRUE, "PDF")      # Should appear
catif(FALSE, "Moodle")  # Should not appear
</code></pre>

<hr>
<h2 id='CImu_data'>Confidence Intervals</h2><span id='topic+CImu_data'></span><span id='topic+dcimu'></span>

<h3>Description</h3>

<p>The <code>CImu_data</code> function is designed for the generation of confidence intervals pertaining to a population mean <code>mu</code>.
The function accommodates scenarios in which a dataset <code>x</code> is either provided or generated through a random sampling process
from a normal distribution, with user-specified parameters such as a mean <code>mu</code> and a standard deviation <code>sigma</code>.
Subsequently, the function computes essential statistical measures, including the sample mean <code>xbar</code> and the standard deviation <code>sd</code>.
Confidence intervals for the population mean are then calculated at user-defined confidence levels (<code>conf.level</code>).
The output is a structured list containing pertinent statistics, encompassing the mean, sample standard deviation,
confidence intervals, and other relevant details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CImu_data(
  x = NULL,
  n = length(x),
  xbar = NULL,
  sd = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  mu = NULL,
  sigma = NULL
)

dcimu(
  x = NULL,
  n = length(x),
  xbar = NULL,
  sd = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  mu = NULL,
  sigma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CImu_data_+3A_x">x</code></td>
<td>
<p>numeric: vector of data values</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_n">n</code></td>
<td>
<p>numeric: length of the vector x (if <code>n&lt;1</code> then <code>n=5</code> is used)</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_xbar">xbar</code></td>
<td>
<p>numeric: sample mean</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_sd">sd</code></td>
<td>
<p>numeric: sample standard deviation</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric: vector of confidence levels of the interval (default: <code>c(0.9, 0.95, 0.99)</code>)</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_mu">mu</code></td>
<td>
<p>numeric: true value of the mean</p>
</td></tr>
<tr><td><code id="CImu_data_+3A_sigma">sigma</code></td>
<td>
<p>numeric: vector of possible variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>

<ul>
<li> <p><code>a</code> with <code>1-(1-conf.level)/2</code>
</p>
</li>
<li> <p><code>n</code> number observations if given
</p>
</li>
<li> <p><code>xbar</code> mean of observations if not given
</p>
</li>
<li> <p><code>mu</code> theoretical mean if given
</p>
</li>
<li> <p><code>sd</code> standard deviation of observations
</p>
</li>
<li> <p><code>sigma</code> theoretical standard deviation if given
</p>
</li>
<li> <p><code>df</code> degrees of freedom if a <code>t</code> distribution is used
</p>
</li>
<li> <p><code>q</code> if <code>sigma=NULL</code>
</p>
</li>
<li> <p><code>ss</code> either <code>sd</code> or <code>sigma</code>
</p>
</li>
<li> <p><code>e</code> margin of error (half of the length of the confidence interval(s))
</p>
</li>
<li> <p><code>l</code> length of the confidence interval(s)
</p>
</li>
<li> <p><code>v</code> endpoints of the confidence interval(s)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># with data
x &lt;- rnorm(100)
CImu_data(x, conf.level=0.95)
# simulate data internally
CImu_data(n=100, conf.level=0.95, mu=0, sigma=1)
</code></pre>

<hr>
<h2 id='CImulen_data'>Confidence Interval and Sample Size for the Population Mean Value</h2><span id='topic+CImulen_data'></span><span id='topic+dcimulen'></span>

<h3>Description</h3>

<p>Data generation for the necessary sample size of a confidence interval, for the population mean value.
Either the estimation error <code class="reqn">e</code> or the length of the interval <code class="reqn">l</code> must be given (<code class="reqn">l=2*e</code>).
It is ensured that the computed <code>s</code> deviates from <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CImulen_data(
  sigma,
  e = NULL,
  l = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  nmin = 30,
  size = NA,
  u = c(seq(0.1, 0.4, 0.001), seq(0.6, 0.9, 0.001)),
  full = FALSE
)

dcimulen(
  sigma,
  e = NULL,
  l = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  nmin = 30,
  size = NA,
  u = c(seq(0.1, 0.4, 0.001), seq(0.6, 0.9, 0.001)),
  full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CImulen_data_+3A_sigma">sigma</code></td>
<td>
<p>numeric: vector of possible variance</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_e">e</code></td>
<td>
<p>numeric: vector of estimation errors</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_l">l</code></td>
<td>
<p>numeric: vector of lengths of the interval</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric: vector of confidence levels of the interval (default: <code>c(0.9, 0.95, 0.99)</code>)</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_nmin">nmin</code></td>
<td>
<p>numeric: minimal value of necessary observation (default: <code>30</code>)</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_size">size</code></td>
<td>
<p>numeric: sample size for computing a sample standard deviation. Default <code>NA</code> means that the solution of the estimation is used</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_u">u</code></td>
<td>
<p>numeric: vector of quantiles used to sample the sample standard deviation (default: <code>c(seq(0.15, 0.45, 0.001), seq(0.55, 0.85, 0.001))</code>)</p>
</td></tr>
<tr><td><code id="CImulen_data_+3A_full">full</code></td>
<td>
<p>logical: if <code>TRUE</code> then a data frame with possible solution is returned, otherwise a list with a randomly chosen solution is returned (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or a list with:
</p>

<ul>
<li> <p><code class="reqn">e</code>: estimation error
</p>
</li>
<li> <p><code>sigma</code>: population variance
</p>
</li>
<li> <p><code>conf.level</code>: confidence level
</p>
</li>
<li> <p><code class="reqn">l</code>: interval length
</p>
</li>
<li> <p><code>x</code>: <code class="reqn">1-alpha/2</code>
</p>
</li>
<li> <p><code>q</code>: <code class="reqn">z_{1-alpha/2}</code>
</p>
</li>
<li> <p><code>q2</code>: <code class="reqn">z^2_{1-alpha/2}</code>
</p>
</li>
<li> <p><code>n</code>: computed minimal sample size
</p>
</li>
<li> <p><code>N</code>: the smallest integer, no less than <code>n</code>
</p>
</li>
<li> <p><code>s</code>: sample standard deviation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># one solution
CImulen_data (1:10, e=(1:10)/10)
# all solutions
mul &lt;- CImulen_data (1:10, e=(1:10)/10, full=TRUE)
str(mul)
</code></pre>

<hr>
<h2 id='CIpilen_data'>Confidence Interval and Sample Size for the Population Proportion</h2><span id='topic+CIpilen_data'></span><span id='topic+dcipilen'></span>

<h3>Description</h3>

<p>Data generation for the necessary sample size of a confidence interval, for the population proportion, using <code class="reqn">z^2/l^2)</code>.
Either the estimation error <code class="reqn">e</code> or the length of the interval <code class="reqn">l</code> must be given (<code class="reqn">l=2*e</code>).
It is ensured that the computed <code>p</code> deviates from <code>pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIpilen_data(
  pi,
  e = NULL,
  l = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  nmin = 30,
  size = NA,
  u = c(seq(0.1, 0.4, 0.001), seq(0.6, 0.9, 0.001)),
  full = FALSE
)

dcipilen(
  pi,
  e = NULL,
  l = NULL,
  conf.level = c(0.9, 0.95, 0.99),
  nmin = 30,
  size = NA,
  u = c(seq(0.1, 0.4, 0.001), seq(0.6, 0.9, 0.001)),
  full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIpilen_data_+3A_pi">pi</code></td>
<td>
<p>numeric: vector of possible population proportions</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_e">e</code></td>
<td>
<p>numeric: vector of estimation errors</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_l">l</code></td>
<td>
<p>numeric: vector of lengths of the interval</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric: vector of confidence levels of the interval (default: <code>c(0.9, 0.95, 0.99)</code>)</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_nmin">nmin</code></td>
<td>
<p>numeric: minimal value of necessary observation (default: <code>30</code>)</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_size">size</code></td>
<td>
<p>numeric: sample size for computing a sample standard deviation. Default <code>NA</code> means that the solution of the estimation is used</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_u">u</code></td>
<td>
<p>numeric: vector of quantiles used to sample the sample standard deviation (default: <code>c(seq(0.15, 0.45, 0.001), seq(0.55, 0.85, 0.001))</code>)</p>
</td></tr>
<tr><td><code id="CIpilen_data_+3A_full">full</code></td>
<td>
<p>logical: if <code>TRUE</code> then a data frame with possible solution is returned, otherwise a list with a randomly chosen solution is returned (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or a list with:
</p>

<ul>
<li> <p><code class="reqn">e</code> estimation error
</p>
</li>
<li> <p><code>pi</code> population proportion
</p>
</li>
<li> <p><code>conf.level</code> confidence level
</p>
</li>
<li> <p><code class="reqn">l</code> interval length
</p>
</li>
<li> <p><code>x</code> <code class="reqn">1-alpha/2</code>
</p>
</li>
<li> <p><code>q</code> <code class="reqn">z_{1-alpha/2}</code>
</p>
</li>
<li> <p><code>q2</code> <code class="reqn">z^2_{1-alpha/2}</code>
</p>
</li>
<li> <p><code>n</code> computed minimal sample size
</p>
</li>
<li> <p><code>N</code> the smallest integer, no less than <code>n</code>
</p>
</li>
<li> <p><code>p</code> sample proportion
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># one solution
CIpilen_data((1:9/10), (1:9)/10)
# all solutions
pil &lt;- CIpilen_data((1:9/10), (1:9)/10, full=TRUE)
str(pil)
</code></pre>

<hr>
<h2 id='combinatorics'>Combinatorics</h2><span id='topic+combinatorics'></span><span id='topic+combs'></span><span id='topic+combo'></span><span id='topic+fact'></span><span id='topic+factquot'></span><span id='topic+binom'></span><span id='topic+variation'></span><span id='topic+combination'></span><span id='topic+permutation'></span><span id='topic+lfact'></span><span id='topic+lfactquot'></span><span id='topic+lbinom'></span>

<h3>Description</h3>


<ul>
<li> <p><code>permutation</code> computes the number of permutations
</p>
</li>
<li> <p><code>variation</code> computes the number of variations with and without replication
</p>
</li>
<li> <p><code>combination</code> computes the number of combinations with and without replication
</p>
</li>
<li> <p><code>combinatorics</code> computes all combinatorics results for <code>k &lt; n</code> and returns it as list of:
</p>

<dl>
<dt><code>permutation.n</code></dt><dd><p><code class="reqn">P(n)</code></p>
</dd>
<dt><code>permutation.k</code></dt><dd><p><code class="reqn">P(k)</code></p>
</dd>
<dt><code>permutation.nk</code></dt><dd><p><code class="reqn">P(n; k)</code></p>
</dd>
<dt><code>variation</code></dt><dd><p><code class="reqn">V(n;k)</code></p>
</dd>
<dt><code>variation.rep</code></dt><dd><p><code class="reqn">V^W(n;k)</code></p>
</dd>
<dt><code>combination</code></dt><dd><p><code class="reqn">K(n;k)</code></p>
</dd>
<dt><code>combination.rep</code></dt><dd><p><code class="reqn">K^W(n;k)</code></p>
</dd>
</dl>

</li>
<li> <p><code>lfact</code> computes the natural logarithm of the factorial of a given number <code>n</code>
</p>
</li>
<li> <p><code>lfactquot</code> calculates the natural logarithm of the quotient of factorials
</p>
</li>
<li> <p><code>lbinom</code> computes the natural logarithm of the binomial coefficient, &quot;<code>n</code> choose <code>k</code>&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>combinatorics(n, k)

variation(n, k, repl = FALSE)

combination(n, k, repl = FALSE)

permutation(n, k = rep(1, n))

lfact(n)

lfactquot(n, ...)

lbinom(n, k)

combo(n, k, repl = FALSE)

combs(n, k)

fact(n)

factquot(n, ...)

binom(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinatorics_+3A_n">n</code></td>
<td>
<p>numeric: total number of elements</p>
</td></tr>
<tr><td><code id="combinatorics_+3A_k">k</code></td>
<td>
<p>numeric: number of elements to choose</p>
</td></tr>
<tr><td><code id="combinatorics_+3A_repl">repl</code></td>
<td>
<p>logical: with repetition (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="combinatorics_+3A_...">...</code></td>
<td>
<p>numeric: further arguments for <code>lfactquot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permutation(8)
permutation(8, c(1,3,2,2))
combination(8, 4)
combination(8, 4, TRUE)
variation(8, 4)
variation(8, 4, TRUE)
combinatorics(8, 4)
</code></pre>

<hr>
<h2 id='cor_data'>Correlation and Data Generation</h2><span id='topic+cor_data'></span><span id='topic+dcorr'></span>

<h3>Description</h3>

<p>Generates a data set based on <code>x</code> and <code>y</code> for a given target correlation <code>r</code> according to <code><a href="stats.html#topic+cor">stats::cor()</a></code>.
The algorithm modifies the order of the <code>y</code>'s, therefore is guaranteed that the (marginal) distribution of <code>x</code>
and <code>y</code> will not be modified. Please note that it is not guaranteed that the final correlation will be the desired correlation;
the algorithm interactively modifies the order. If you are unsatisfied with the result, it might help to increase <code>maxit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_data(
  x,
  y,
  r,
  method = c("pearson", "kendall", "spearman"),
  ...,
  maxit = 1000
)

dcorr(x, y, r, method = c("pearson", "kendall", "spearman"), ..., maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_data_+3A_x">x</code></td>
<td>
<p>numeric: given <code>x</code> values</p>
</td></tr>
<tr><td><code id="cor_data_+3A_y">y</code></td>
<td>
<p>numeric: given <code>y</code> values</p>
</td></tr>
<tr><td><code id="cor_data_+3A_r">r</code></td>
<td>
<p>numeric: desired correlation</p>
</td></tr>
<tr><td><code id="cor_data_+3A_method">method</code></td>
<td>
<p>character: indicates which correlation coefficient is to be computed (default: '&quot;pearson&quot;)</p>
</td></tr>
<tr><td><code id="cor_data_+3A_...">...</code></td>
<td>
<p>further parameters given to <code><a href="stats.html#topic+cor">stats::cor()</a></code></p>
</td></tr>
<tr><td><code id="cor_data_+3A_maxit">maxit</code></td>
<td>
<p>numeric: maximal number of iterations (default: <code>1000</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns and an attribute <code>interim</code> for intermediate values as matrix.
The rows of the matrix contain:
</p>

<ul>
<li><p> if <code>method=="pearson"</code>: <code class="reqn">x_i</code>, <code class="reqn">y_i</code>,  <code class="reqn">x_i-bar{x}</code>, <code class="reqn">y_i-\bar{y}</code>,
<code class="reqn">(x_i-bar{x})^2</code>, <code class="reqn">(y_i-\bar{y})^2</code>, and <code class="reqn">(x_i-bar{x})((y_i-\bar{y})</code>.
</p>
</li>
<li><p> if <code>method=="kendall"</code>:
</p>

<ul>
<li> <p><code class="reqn">x_i</code>: The original x values.
</p>
</li>
<li> <p><code class="reqn">y_i</code>: The original y values.
</p>
</li>
<li> <p><code class="reqn">p_i</code>: The number of concordant pairs.
</p>
</li>
<li> <p><code class="reqn">q_i</code>: The number of discordant pairs.
</p>
</li></ul>

</li>
<li><p> if <code>method=="spearman"</code>: <code class="reqn">x_i</code>, <code class="reqn">y_i</code>, <code class="reqn">p_i</code> (concordant pairs), and <code class="reqn">q_i</code> (disconcordant pairs).
In a final step a vector with the row <code>sums</code> is appended as further column.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(6)
y &lt;- runif(6)
xy &lt;- cor_data(x, y, r=0.6)
cbind(x, y, xy)
</code></pre>

<hr>
<h2 id='data_n'>Number of Observations</h2><span id='topic+data_n'></span><span id='topic+data_n25'></span><span id='topic+data_nsq'></span><span id='topic+dn'></span><span id='topic+dn25'></span><span id='topic+dnsq'></span>

<h3>Description</h3>

<p>Generates a sequence of sample sizes in a range from <code>min=5</code> to a <code>max</code>:
</p>

<ul>
<li><p> whose root is an integer (<code>data_nsq</code>), and
</p>
</li>
<li><p> that are divisible only by 2 and 5 (<code>data_n25</code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data_n(max, min = 5)

data_nsq(max, min = 5)

data_n25(max, min = 5)

dn(max, min = 5)

dn25(max, min = 5)

dnsq(max, min = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_n_+3A_max">max</code></td>
<td>
<p>integer: maximum sample size</p>
</td></tr>
<tr><td><code id="data_n_+3A_min">min</code></td>
<td>
<p>integer: minimum sample size (default: <code>5</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_n(10)
data_nsq(1000)
data_n25(1000)
</code></pre>

<hr>
<h2 id='data_prob2'>Probability/Frequency Matrix Generation</h2><span id='topic+data_prob2'></span><span id='topic+prob_mx'></span><span id='topic+dprob2'></span>

<h3>Description</h3>

<p>Generates a <code>nrow</code> √ó <code>ncol</code> matrix with probabilities / frequencies.
If <code>data</code> is given it will be normalized such that <code>sum(data[is.finite(data)])==1</code>.
If no <code>rownames</code> or <code>colnames</code> are given then event names from <code>LETTERS</code> are used.
The returned matrix will have the following attributes:
</p>

<ul>
<li> <p><code>marginals</code> a list of the row and column marginal distributions
</p>
</li>
<li> <p><code>byrow</code> a matrix with conditional probabilities by row
</p>
</li>
<li> <p><code>bycol</code> a matrix with conditional probabilities by column
</p>
</li>
<li> <p><code>expected</code> a matrix with the expected probabilities under independence
</p>
</li>
<li> <p><code>prob</code> a vector of all the probabilities computed (except the expected ones)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data_prob2(
  data = NULL,
  nrow = 2,
  ncol = 2,
  colnames = NULL,
  rownames = NULL,
  ...
)

prob_mx(data = NULL, nrow = 2, ncol = 2, colnames = NULL, rownames = NULL, ...)

dprob2(data = NULL, nrow = 2, ncol = 2, colnames = NULL, rownames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_prob2_+3A_data">data</code></td>
<td>
<p>an optional data vector. Non-atomic classed R objects are coerced
by <code>as.vector</code> and all attributes are discarded.</p>
</td></tr>
<tr><td><code id="data_prob2_+3A_nrow">nrow</code></td>
<td>
<p>numeric: desired number of rows (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="data_prob2_+3A_ncol">ncol</code></td>
<td>
<p>numeric: desired number of columns (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="data_prob2_+3A_colnames">colnames</code></td>
<td>
<p>character: names of column events</p>
</td></tr>
<tr><td><code id="data_prob2_+3A_rownames">rownames</code></td>
<td>
<p>character: names of row events</p>
</td></tr>
<tr><td><code id="data_prob2_+3A_...">...</code></td>
<td>
<p>further parameters given to <code><a href="#topic+ddiscrete">ddiscrete()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix and some attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data_prob2()
str(x)
data_prob2(colnames="E")
data_prob2(nrow=3)
</code></pre>

<hr>
<h2 id='ddiscrete'>Discrete Probability Function</h2><span id='topic+ddiscrete'></span>

<h3>Description</h3>

<p>Creates a discrete probability function based on <code>x</code> with a resolution <code>unit</code>.
If <code>unit</code> is not given then <code>unit</code> will be 10, 100, 1000, ... depending
on the length of the discrete probability function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddiscrete(x, unit = NULL, zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddiscrete_+3A_x">x</code></td>
<td>
<p>numeric: number of elements of vector of initial probabilities</p>
</td></tr>
<tr><td><code id="ddiscrete_+3A_unit">unit</code></td>
<td>
<p>integer: reciprocal of the smallest non-zero probability (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete_+3A_zero">zero</code></td>
<td>
<p>logical: zeros are allowed in the final probabilities (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A discrete probability function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddiscrete(runif(6))
ddiscrete(6)
ddiscrete(6, 20)
ddiscrete(c(1,0,0,0), zero=TRUE)
</code></pre>

<hr>
<h2 id='ddiscrete2'>Bivariate Discrete Probability Function</h2><span id='topic+ddiscrete2'></span><span id='topic+biv_discrete_prob'></span>

<h3>Description</h3>

<p>Creates a bivariate discrete probability function based on the marginal probability functions
<code>row</code> and <code>col</code>. If <code>unit</code> is not given then <code>unit</code> will be the product of the units
used in <code>row</code> and <code>col</code>, otherwise it will appear as the least common multiple <code>unit</code> product of
the units used in <code>row</code> and <code>col</code>.
If <code>target</code> is <code>NA</code> then the common distribution of two independent random variables
is returned, otherwise an iterative algorithm is run to approach a <code>target</code> association or
correlation measure, see also <code><a href="#topic+assoc_data">assoc_data()</a></code> (called internally).
<code>zero</code> allows for zero entries in the common distribution.
<code>FUN</code> computes the association or correlation measures based on a
frequency table. <code>tol</code> gives the maximal deviation of the association or correlation measure
and the <code>target</code> value. <code>maxit</code> limits the number of steps.
Please note that a solution is not guaranteed, especially for extreme values for <code>target</code>, for example
for <code class="reqn">+1</code>, <code class="reqn">-1</code> or nearby values.
If <code>attr(joint, "iterations")==maxit</code> then you need
either to increase <code>maxit</code>, to decrease <code>tol</code> or to check if you have chosen an
appropriate <code>target</code> value (for a nominal measure in <code class="reqn">0 &lt;= target &lt;= 1</code>, for ordinal measure in <code class="reqn">-1 &lt;= target &lt;= +1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddiscrete2(
  row,
  col,
  unit = NULL,
  zero = FALSE,
  FUN = nom.cc,
  target = NA,
  tol = 0.001,
  maxit = 500,
  ...
)

biv_discrete_prob(
  row,
  col,
  unit = NULL,
  zero = FALSE,
  FUN = nom.cc,
  target = NA,
  tol = 0.001,
  maxit = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddiscrete2_+3A_row">row</code></td>
<td>
<p>numeric: marginal <code>row</code> distribution</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_col">col</code></td>
<td>
<p>numeric: marginal <code>col</code> distribution</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_unit">unit</code></td>
<td>
<p>integer: reciprocal of the smallest non-zero probability (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_zero">zero</code></td>
<td>
<p>logical: zeros are allowed in the final probabilities (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_fun">FUN</code></td>
<td>
<p>function: association or correlation function (default: <code>nom.cc</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_target">target</code></td>
<td>
<p>numeric: target association or correlation (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for target association or correlation (default: <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_maxit">maxit</code></td>
<td>
<p>integer: maximal number of iterations (default: <code>100</code>)</p>
</td></tr>
<tr><td><code id="ddiscrete2_+3A_...">...</code></td>
<td>
<p>further parameters for <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bivariate discrete probability function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>row &lt;- ddiscrete(runif(5))
col &lt;- ddiscrete(runif(3))
joint &lt;- ddiscrete2(row, col)
joint
joint &lt;- ddiscrete2(row, col, target=0.5)
joint
nom.cc(joint*attr(joint, "unit"))
</code></pre>

<hr>
<h2 id='ddunif2'>Sum of Two Independent Discrete Uniform Distributions</h2><span id='topic+ddunif2'></span><span id='topic+sum_discrete_unif_cdf'></span><span id='topic+sum_discrete_unif_pmf'></span><span id='topic+sum_discrete_unif_rand'></span><span id='topic+sum_discrete_unif_quantile'></span><span id='topic+pdunif2'></span><span id='topic+qdunif2'></span><span id='topic+rdunif2'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function, quantile function and random generation
for the sum of two independent discrete uniform distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddunif2(x, min = 1, max = 6)

pdunif2(q, min = 1, max = 6)

qdunif2(p, min = 1, max = 6)

rdunif2(n, min = 1, max = 6)

sum_discrete_unif_cdf(x, min = 1, max = 6)

sum_discrete_unif_pmf(q, min = 1, max = 6)

sum_discrete_unif_quantile(p, min = 1, max = 6)

sum_discrete_unif_rand(n, min = 1, max = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddunif2_+3A_x">x</code>, <code id="ddunif2_+3A_q">q</code></td>
<td>
<p>numeric: vector of quantiles</p>
</td></tr>
<tr><td><code id="ddunif2_+3A_min">min</code></td>
<td>
<p>numeric: lower limit of the distribution (default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="ddunif2_+3A_max">max</code></td>
<td>
<p>numeric: upper limit of the distribution (default: <code>6</code>)</p>
</td></tr>
<tr><td><code id="ddunif2_+3A_p">p</code></td>
<td>
<p>numeric: vector of probabilities</p>
</td></tr>
<tr><td><code id="ddunif2_+3A_n">n</code></td>
<td>
<p>numeric: number of observations. If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddunif2(1:13)
pdunif2(1:13)
qdunif2((0:4)/4)
rdunif2(10)
</code></pre>

<hr>
<h2 id='distribution'>Class Distribution</h2><span id='topic+distribution'></span><span id='topic+compute_cdf'></span><span id='topic+compute_pmdf'></span><span id='topic+compute_probability'></span><span id='topic+point_probability'></span><span id='topic+pprob'></span><span id='topic+is_distribution'></span><span id='topic+distribution.default'></span><span id='topic+quantile.distribution'></span><span id='topic+cdf'></span><span id='topic+print.distribution'></span><span id='topic+summary.distribution'></span><span id='topic+pmdf'></span><span id='topic+toLatex.distribution'></span><span id='topic+is.distribution'></span><span id='topic+prob'></span><span id='topic+prob1'></span>

<h3>Description</h3>

<p>Holds an univariate distribution including its parameters. The name of the distribution is used to determine the right use of the function.
For example, in the case of function for quantiles: <code>paste0("q", name)</code>. Usually the full name has to be used; some abbreviated names are possible:
</p>

<ul>
<li><p><code>binom</code> binomial distribution, parameters: <code>size</code>, <code>prob</code>
</p>
</li>
<li><p><code>hyper</code> hypergeometric distribution, parameters: <code>m</code>, <code>n</code>, <code>k</code>
</p>
</li>
<li><p><code>geom</code> geometric distribution, parameters: <code>prob</code>
</p>
</li>
<li><p><code>pois</code> Poisson distribution, parameters: <code>lambda</code>
</p>
</li>
<li><p><code>unif</code> continuous uniform  distribution, parameters: <code>min</code>, <code>max</code>
</p>
</li>
<li><p><code>dunif</code> discrete uniform  distribution, parameters: <code>min</code>, <code>max</code>
</p>
</li>
<li><p><code>dunif2</code> continuous uniform  distribution, parameters: <code>min</code>, <code>max</code>
</p>
</li>
<li><p><code>exp</code> exponential distribution, parameter: <code>rate</code>
</p>
</li>
<li><p><code>norm</code> normal distribution, parameters: <code>mean</code>, <code>sd</code>
</p>
</li>
<li><p><code>lnorm</code> log-normal distribution, parameters: <code>meanlog</code>, <code>sdlog</code>
</p>
</li>
<li><p><code>t</code> Student t distribution, parameter: <code>df</code>
</p>
</li>
<li><p><code>chisq</code> chi-squared distribution, parameter: <code>df</code>
</p>
</li>
<li><p><code>f</code> F distribution, parameters: <code>df1</code>,  <code>df2</code>
</p>
</li></ul>

<p>Note that a probability mass/density, quantile and a cumulative distribution function must exist.
</p>
<p>The following functions exists for <code>disributions</code>:
</p>

<ul>
<li><p><code>distribution</code> creates a distribution with <code>name</code> and parameters
</p>
</li>
<li><p><code>quantile</code> computes the quantiles of a distribution using <code>paste0('q', name)</code>
</p>
</li>
<li><p><code>cdf</code> computes the cumulative distribution function of a distribution using <code>paste0('p', name)</code>
</p>
</li>
<li><p><code>pmdf</code> computes the probability mass/density function of a distribution using <code>paste0('d', name)</code>
</p>
</li>
<li><p><code>prob</code> computes the probability for a interval between <code>min</code> and <code>max</code> (<code>max</code> included, <code>min</code> excluded)
</p>
</li>
<li><p><code>prob1</code> computes the point probability f
</p>
</li>
<li><p><code>is.distribution</code> checks if <code>object</code> is distribution object. If <code>name</code> is given then it checks whether the distribution type is the same
</p>
</li>
<li><p><code>toLatex</code> generates a LaTeX representation of the distribution an its parameter
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>distribution(name, ...)

## Default S3 method:
distribution(name, ..., discrete = NA)

## S3 method for class 'distribution'
quantile(x, probs = seq(0, 1, 0.25), ...)

cdf(x, q, ...)

## S3 method for class 'distribution'
print(x, ...)

## S3 method for class 'distribution'
summary(object, ...)

pmdf(d, x, ...)

## S3 method for class 'distribution'
toLatex(object, name = NULL, param = NULL, digits = 4, ...)

is.distribution(object, name = NULL)

prob(d, min = -Inf, max = +Inf, tol = 1e-06)

prob1(d, x, tol = 1e-06)

compute_cdf(x, q, ...)

compute_pmdf(d, x, ...)

compute_probability(d, min = -Inf, max = +Inf, tol = 1e-06)

point_probability(d, x, tol = 1e-06)

pprob(d, x, tol = 1e-06)

is_distribution(object, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_name">name</code></td>
<td>
<p>character: a replacement of the name of the distribution type</p>
</td></tr>
<tr><td><code id="distribution_+3A_...">...</code></td>
<td>
<p>further named distribution parameters</p>
</td></tr>
<tr><td><code id="distribution_+3A_discrete">discrete</code></td>
<td>
<p>logical: is the distribution discrete? (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="distribution_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="distribution_+3A_probs">probs</code></td>
<td>
<p>numeric: vector of probabilities with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_q">q</code></td>
<td>
<p>numeric: vector of quantiles</p>
</td></tr>
<tr><td><code id="distribution_+3A_object">object</code></td>
<td>
<p>distribution object</p>
</td></tr>
<tr><td><code id="distribution_+3A_d">d</code></td>
<td>
<p>distribution</p>
</td></tr>
<tr><td><code id="distribution_+3A_param">param</code></td>
<td>
<p>character: names for the distribution parameters</p>
</td></tr>
<tr><td><code id="distribution_+3A_digits">digits</code></td>
<td>
<p>integer: number of digits used in <code>signif</code></p>
</td></tr>
<tr><td><code id="distribution_+3A_min">min</code></td>
<td>
<p>numeric: left border of interval</p>
</td></tr>
<tr><td><code id="distribution_+3A_max">max</code></td>
<td>
<p>numeric: right border of interval</p>
</td></tr>
<tr><td><code id="distribution_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for <code>max==min</code> (default: <code>1e-6</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distribution object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- distribution("norm", mean=0, sd=1)
quantile(d)
quantile(d, c(0.025, 0.975))
cdf(d, 0)
is.distribution(d)
is.distribution(d, "t")
toLatex(d)
</code></pre>

<hr>
<h2 id='distributions'>Distributions</h2><span id='topic+distributions'></span>

<h3>Description</h3>

<p>A data frame with the R function names, LaTeX names, discreteness and package origin of a distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(distributions)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns <code>r</code>, <code>latex</code>, <code>discret</code> and <code>package</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(distributions)
distributions
</code></pre>

<hr>
<h2 id='divisor_25'>Number Properties</h2><span id='topic+divisor_25'></span><span id='topic+denominator_25'></span><span id='topic+deonom_25'></span><span id='topic+is_terminal'></span><span id='topic+round_25'></span><span id='topic+prime_numbers'></span><span id='topic+primes'></span><span id='topic+has_digits'></span><span id='topic+all_integer'></span><span id='topic+only_digits'></span><span id='topic+is_term'></span><span id='topic+denom_25'></span>

<h3>Description</h3>


<ul>
<li> <p><code>is_terminal</code> checks whether <code>x</code>'s can be expressed as a terminal fraction, basically <code>divisor_25(denominator(x))</code>
</p>
</li>
<li> <p><code>divisor_25</code> checks whether all <code>x</code>'s can be expressed as <code class="reqn">2^x 5^y</code>
</p>
</li>
<li> <p><code>prime_numbers</code> returns all prime numbers up to a limit
</p>
</li>
<li> <p><code>primes</code> prime factorization of <code>x</code>, returns a matrix with the power of each prime number
</p>
</li>
<li> <p><code>has_digits</code> checks whether the <code>x</code>'s have only <code>digits</code> after the decimal point, basically <code>abs(x-round(x, digits))&lt;tol</code>
</p>
</li>
<li> <p><code>all_integer</code> checks whether all <code>x</code>'s are integer, basically <code>all(has_digits(x,0))</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>divisor_25(x)

denominator_25(x)

is_terminal(x)

round_25(x)

prime_numbers(n, sieve = FALSE)

primes(x, min = 2)

has_digits(
  x,
  digits = 2,
  tol = 10^{
     -digits - 6
 }
)

all_integer(x)

only_digits(
  x,
  digits = 2,
  tol = 10^{
     -digits - 6
 }
)

is_term(x)

denom_25(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisor_25_+3A_x">x</code></td>
<td>
<p>numeric: values to test/check</p>
</td></tr>
<tr><td><code id="divisor_25_+3A_n">n</code></td>
<td>
<p>integer: find all prime numbers up to n</p>
</td></tr>
<tr><td><code id="divisor_25_+3A_sieve">sieve</code></td>
<td>
<p>logical: should in any case the Sieve of Eratosthenes be used to compute prime numbers (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="divisor_25_+3A_min">min</code></td>
<td>
<p>integer: the minimum prime number used (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="divisor_25_+3A_digits">digits</code></td>
<td>
<p>numeric: number of digits to check (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="divisor_25_+3A_tol">tol</code></td>
<td>
<p>numeric: max. deviation from the rounded <code>x</code> (default: <code>1e-6</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_terminal(2/3)   # 0.6666... non-terminal
is_terminal(1/5)   # 0.2       terminal
divisor_25(1:25)
prime_numbers(100) # all prime numbers less equal 100
primes(1:20)       # prime factorization of 1 to twenty
</code></pre>

<hr>
<h2 id='equal'>Conditional Value Matching</h2><span id='topic+equal'></span><span id='topic+approx_equal'></span>

<h3>Description</h3>

<p>It performs a comparison by checking if either <code>abs(x - y) &lt; tol</code> when <code>outer == FALSE</code>,
or if an <code>a</code> exists or a  <code>y[j]</code> for each <code>x[i]</code> such that the condition <code>abs(x[i] - y[j]) &lt; tol</code> is satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal(x, y, tol = 1e-06, outer = FALSE)

approx_equal(x, y, tol = 1e-06, outer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equal_+3A_x">x</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="equal_+3A_y">y</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="equal_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance (default: <code>1e-6</code>)</p>
</td></tr>
<tr><td><code id="equal_+3A_outer">outer</code></td>
<td>
<p>logical: compares directly or verifies whether <code>x</code> is present within <code>y</code> (default: FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>equal(9*1/9, 1)
</code></pre>

<hr>
<h2 id='equations'>Equations and Variables</h2><span id='topic+equations'></span><span id='topic+variables'></span>

<h3>Description</h3>

<p><strong><code>equations</code></strong> defines a set of equations using the formula interface including a LaTeX representation of the formulae.
</p>
<p><strong><code>variables</code></strong> sets the variable values, the LaTeX representation and the solution interval. The first argument must be
the <code>equations</code> object. A named parameter starts the setting for a specific variable, e.g. <code style="white-space: pre;">&#8288;..., s=1, pos(5), "s^2",...&#8288;</code>
sets for the variable <code>s</code> first its numerical value, second the solution interval and finally the LaTeX representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equations(...)

variables(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equations_+3A_...">...</code></td>
<td>
<p>For <code>equations</code>, an even number of parameters: formula, LaTeX representation, formula, LaTeX representation, etc.<br /> <br />
For <code>variables</code>, parameters to set one or more variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(for <code>equations</code>) An <code>equations</code> object.
</p>
<p>(for <code>variables</code>) The modified <code>equations</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The equations describe the formulae for an confidence interval of the mean
e &lt;- equations(o~x+c*s/sqrt(n), "v_o=\\bar{x}+c\\cdot\\frac{s^2}{n}", 
               u~x-c*s/sqrt(n), "v_u=\\bar{x}-c\\cdot\\frac{s^2}{n}", 
               e~c*s/sqrt(n),   "e  =c\\cdot\\frac{s^2}{\\sqrt{n}}",
               l~2*e,           "l  =2\\cdot e"                   
               )
print(e)
e &lt;- variables(e, 
               x=0,    "\\bar{x}",
               c=2.58, dbl(2), 
               s=1,    pos(5), "s^2",
               n=25,   pos(5),
               l=pos(5), 
               e=pos(5),
               u="v_u", o="v_o")
print(e)
</code></pre>

<hr>
<h2 id='exams2call'>Traceback for <code>exams2</code> Functions</h2><span id='topic+exams2call'></span>

<h3>Description</h3>

<p>Returns a list with the functions' names and parameters called from <code>.traceback()</code>.
The function name must start with <code>"exams2"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exams2call(prefix = "exams2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exams2call_+3A_prefix">prefix</code></td>
<td>
<p>character: start of the function name (default: <code>"exams2"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the function name and its valuated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exams2call()                 # access current call stack
</code></pre>

<hr>
<h2 id='exercise'>Data Exercise Structure</h2><span id='topic+exercise'></span><span id='topic+exercise_data'></span><span id='topic+exercise.default'></span>

<h3>Description</h3>

<p>Data structure for exercise data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exercise(exer, ...)

## Default S3 method:
exercise(exer = NULL, ...)

exercise_data(exer, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exercise_+3A_exer">exer</code></td>
<td>
<p>an exercise object (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="exercise_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An exercise object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exer &lt;- exercise()           # new exercise
exer &lt;- exercise(exer, x=3)  # add x to the exercise
</code></pre>

<hr>
<h2 id='extremes'>Extremes</h2><span id='topic+extremes'></span>

<h3>Description</h3>

<p>Computes the real valued extremes (minima, maxima, and saddle points) for a univariate polynomial.
The computation can be limited to a specific type of extremes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extremes(p, type = c("all", "minimum", "maximum", "saddle"), tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremes_+3A_p">p</code></td>
<td>
<p>a polynomial</p>
</td></tr>
<tr><td><code id="extremes_+3A_type">type</code></td>
<td>
<p>character: either <code>all</code> (default), <code>minimum</code>, <code>maximum</code>, or <code>saddle</code></p>
</td></tr>
<tr><td><code id="extremes_+3A_tol">tol</code></td>
<td>
<p>numeric: if the absolute value of the imaginary part of the zeroes of the derivative of <code>p</code> is
smaller than <code>tol</code>, it will be considered as zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- polynomial(c(0,0,0,1))
extremes(p)
p &lt;- integral(poly.calc(-1:1))
extremes(p)
</code></pre>

<hr>
<h2 id='fcvt'>Number to String Conversion (Floating Point / Fractional Number)</h2><span id='topic+fcvt'></span>

<h3>Description</h3>

<p>Converts a number to a string containing either a floating point or a fractional number.
Note that a repeating or recurring decimal, which is a number whose decimal representation becomes periodic,
can also be expressed as a rational number. For example, <code class="reqn">\frac{1}{3}=0.333333333...=0.\overline{3}</code>.
It is the workhorse used in <code>num2str</code>.
</p>

<ul>
<li><p> If <code>denom</code> is negative then always decimal point numbers are used (default).
</p>
</li>
<li><p> If <code>denom</code> is zero then a mix of decimal point and fractional numbers are used (whatever is shorter).
</p>
</li>
<li><p> If <code>denom</code> is one then fractional numbers are used except for integers.
</p>
</li>
<li><p> If <code>denom</code> is larger than one, then the denominator is set to <code>denom</code> if possible.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>fcvt(x, nsmall = 15, plus = FALSE, denom = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcvt_+3A_x">x</code></td>
<td>
<p>numeric: numbers to convert</p>
</td></tr>
<tr><td><code id="fcvt_+3A_nsmall">nsmall</code></td>
<td>
<p>integer: number of significant digits for the mantissa/significand (default: <code>16</code>)</p>
</td></tr>
<tr><td><code id="fcvt_+3A_plus">plus</code></td>
<td>
<p>logical: for positive numbers a plus sign should be used (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="fcvt_+3A_denom">denom</code></td>
<td>
<p>integer: denominator for a fractional number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(NA, NaN, -Inf, Inf, 0, pi*10^(-20:20))
fcvt(x1)
x2 &lt;- c(-0.36, 3.6, -30.6, 0.36)
fcvt(x2)
x3 &lt;- c((0:16)/8, 1/3)
fcvt(x3)           # as floating point number, equals denom=-1
fcvt(x3, denom=0)  # as floating point or fractional number
fcvt(x3, denom=1)  # as fractional number except for integers
fcvt(x3, denom=8)  # as fractional number with denominator denom if possible
</code></pre>

<hr>
<h2 id='firstmatch'>Firstmatch</h2><span id='topic+firstmatch'></span>

<h3>Description</h3>

<p><code>firstmatch</code> seeks matches for the elements of its first argument among those of its second.
For further details please check <code><a href="base.html#topic+charmatch">base::charmatch()</a></code>. <code>charmatch</code> returns a zero if multiple matches are found, whereas <code>firstmatch</code>
returns the first partial match if multiple matches are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstmatch(x, table, nomatch = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstmatch_+3A_x">x</code></td>
<td>
<p>character: the values to be matched; converted to a character vector if necessary</p>
</td></tr>
<tr><td><code id="firstmatch_+3A_table">table</code></td>
<td>
<p>character: the values to be matched against; converted to a character vector if necessary</p>
</td></tr>
<tr><td><code id="firstmatch_+3A_nomatch">nomatch</code></td>
<td>
<p>integer: the value to be returned at non-matching positions (default: <code>NA_integer_</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>firstmatch("d", c("chisq", "cauchy"))
charmatch("c", c("chisq", "cauchy"))
firstmatch("c", c("chisq", "cauchy"))
firstmatch("ca", c("chisq", "cauchy"))
</code></pre>

<hr>
<h2 id='fractions'>Fractions</h2><span id='topic+fractions'></span><span id='topic+approx_rational'></span>

<h3>Description</h3>

<p>Finds rational approximations to the components of a real numeric object, using a standard continued fraction method.
Calls <code><a href="MASS.html#topic+fractions">MASS::fractions()</a></code> (Please refer to that for further details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractions(x, cycles = 10, max.denominator = 2000, ...)

approx_rational(x, cycles = 10, max.denominator = 2000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractions_+3A_x">x</code></td>
<td>
<p>any object of the numeric mode (missing values are allowed)</p>
</td></tr>
<tr><td><code id="fractions_+3A_cycles">cycles</code></td>
<td>
<p>the maximum number of steps to be used in the continued fraction approximation process</p>
</td></tr>
<tr><td><code id="fractions_+3A_max.denominator">max.denominator</code></td>
<td>
<p>an early termination criterion. If any partial denominator exceeds <code>max.denominator</code>, the continued fraction stops at that point</p>
</td></tr>
<tr><td><code id="fractions_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>fractions</code>. A structure with a <code>.Data</code> component, the same as the numeric <code>x</code> input,
but with the rational approximations held as the character vector attribute <code>fracs</code>. Arithmetic operations on <code>fractions</code> objects are possible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(runif(25), 5, 5)
fractions(X) #;)
fractions(solve(X, X/5))
fractions(solve(X, X/5)) + 1
</code></pre>

<hr>
<h2 id='gapply'>Apply Grid</h2><span id='topic+gapply'></span><span id='topic+apply_grid'></span>

<h3>Description</h3>

<p>Runs all combinations of elements in <code>...</code> as parameters of <code>FUN</code> (grid apply).
<code>I(.)</code> can be used to avoid that an element is interpreted as a grid value.
If an error occurs, then the result of <code>FUN</code> will not be stored. You may notice missing indices
in the returning list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapply(FUN, ..., .simplify = TRUE)

apply_grid(FUN, ..., .simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapply_+3A_fun">FUN</code></td>
<td>
<p>function or character: a string naming the function to be called</p>
</td></tr>
<tr><td><code id="gapply_+3A_...">...</code></td>
<td>
<p>list: of arguments of the function to be called. The <code>names</code> attribute of <code>args</code> returns the argument <code>names</code></p>
</td></tr>
<tr><td><code id="gapply_+3A_.simplify">.simplify</code></td>
<td>
<p>logical: should the result be simplified to a data frame (if possible)? (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or a data frame with the function results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 8 function calls: sum(1,3,5), sum(1,3,6), ..., sum(2,4,6)
gapply("sum", 1:2, 3:4, 5:6)
# 4 function calls: sum(1,3,5:6), sum(1,4,5:66), ..., sum(2,4,5:6)
gapply("sum", 1:2, 3:4, I(5:6))
</code></pre>

<hr>
<h2 id='grade'>Grades</h2><span id='topic+grade'></span><span id='topic+hu_grade'></span>

<h3>Description</h3>

<p>Computes a grade based on the points of the grade scheme by the Humboldt University of Berlin. (See
¬ß96c and ¬ß102 in the <a href="https://gremien.hu-berlin.de/de/amb/2020/11/11_2020_zsp-hu_2013_ae08-2020_2020-05-29_druck.pdf#page=5">Achte √Ñnderung der F√§cher√ºbergreifenden Satzung zur Regelung von Zulassung, Studium und Pr√ºfung der Humboldt-Universit√§t zu Berlin (ZSP-HU)</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade(points, maxpts = max(points), fixed = TRUE)

hu_grade(points, maxpts = max(points), fixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_+3A_points">points</code></td>
<td>
<p>numeric: points achieved in exam</p>
</td></tr>
<tr><td><code id="grade_+3A_maxpts">maxpts</code></td>
<td>
<p>numeric: maximal number of achievable points in an exam (default: <code>max(points)</code>)</p>
</td></tr>
<tr><td><code id="grade_+3A_fixed">fixed</code></td>
<td>
<p>logical: a fixed or relative grade scheme (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Grades as a function of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- round(runif(100, 0, 22.4))
grade(x, 22)
</code></pre>

<hr>
<h2 id='grouped_data'>Central Tendency Measures' Computation of Grouped Data</h2><span id='topic+grouped_data'></span><span id='topic+grouped_stats'></span><span id='topic+dgrouped'></span>

<h3>Description</h3>

<p>Computes mean, mode or quantile/median of grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_data(x, n, compute = c("mean", "fine", "coarse"), tol = 1e-06)

grouped_stats(x, n, compute = c("mean", "fine", "coarse"), tol = 1e-06)

dgrouped(x, n, compute = c("mean", "fine", "coarse"), tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_data_+3A_x">x</code></td>
<td>
<p>numeric: borders</p>
</td></tr>
<tr><td><code id="grouped_data_+3A_n">n</code></td>
<td>
<p>numeric: absolute frequencies for each group</p>
</td></tr>
<tr><td><code id="grouped_data_+3A_compute">compute</code></td>
<td>
<p>numeric/character: coefficient to compute</p>
</td></tr>
<tr><td><code id="grouped_data_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for numerical comparison</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the class, result and a table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
n &lt;- ddiscrete(runif(3))
grouped_data(x, n)
</code></pre>

<hr>
<h2 id='gsimplify'>Simplified <code>hyperloop</code> Object</h2><span id='topic+gsimplify'></span><span id='topic+simplify_hyperloop'></span><span id='topic+simple_hloop'></span>

<h3>Description</h3>

<p>Simplifies a <code>hyperloop</code> object if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsimplify(ga, exclude = NULL, subset = NULL)

simplify_hyperloop(ga, exclude = NULL, subset = NULL)

simple_hloop(ga, exclude = NULL, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsimplify_+3A_ga">ga</code></td>
<td>
<p>list: of a <code>hyperloop</code> object</p>
</td></tr>
<tr><td><code id="gsimplify_+3A_exclude">exclude</code></td>
<td>
<p>character or integer: elements to exclude in each list element of <code>ga</code> (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="gsimplify_+3A_subset">subset</code></td>
<td>
<p>indices specifying elements of <code>ga</code> to extract (default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame if possible, otherwise a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calls: t.test(x, -1), t.test(x, 0), t.test(x, 1)
ga &lt;- gapply(t.test, x=I(rnorm(100)), mu=-1:1)
# no simplication since `data.name` and `conf.int` have lengths larger  than one
gsimplify(ga)
#' simplification is now possible
gsimplify(ga, exclude=c("conf.int", "data.name"))
</code></pre>

<hr>
<h2 id='histbreaks'>Histogram Breakpoints</h2><span id='topic+histbreaks'></span><span id='topic+rand_breaks'></span><span id='topic+dhistbreaks'></span>

<h3>Description</h3>

<p>Randomly selects <code>size</code> breakpoints from <code>breaks</code>. If <code>outer</code> is <code>TRUE</code>, then
the first and last element of <code>breaks</code> is always included into the returned break points.
If <code>size</code> is a vector, the number of breakpoints is first sampled from <code>size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histbreaks(breaks, size, outer = TRUE, ...)

rand_breaks(breaks, size, outer = TRUE, ...)

dhistbreaks(breaks, size, outer = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histbreaks_+3A_breaks">breaks</code></td>
<td>
<p>numeric: a vector of possible break points</p>
</td></tr>
<tr><td><code id="histbreaks_+3A_size">size</code></td>
<td>
<p>integer: number of break points</p>
</td></tr>
<tr><td><code id="histbreaks_+3A_outer">outer</code></td>
<td>
<p>logical: should be the first and last element of the included breaks (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="histbreaks_+3A_...">...</code></td>
<td>
<p>further parameters given if sampling of <code>size</code> is necessary, see <a href="base.html#topic+sample">base::sample</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of breakpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Always includes 100 and 200
histbreaks(seq(100, 200, by=10), 4)
# Always includes 100 and 200 and chooses randomly between 3 to 5 break points  
histbreaks(seq(100, 200, by=10), 3:5)           
# May not include 100 and 200
histbreaks(seq(100, 200, by=10), 4, outer=FALSE) 
</code></pre>

<hr>
<h2 id='histdata'>Histogram Data</h2><span id='topic+histdata'></span><span id='topic+dhist'></span><span id='topic+quantile.histogram'></span><span id='topic+median.histogram'></span><span id='topic+mean.histogram'></span>

<h3>Description</h3>

<p>Returns data for a histogram. Calls internally <code>hist(..., plot=FALSE)</code>.
</p>

<ul>
<li> <p><code>mean</code> returns the mean of the data.
</p>
</li>
<li> <p><code>quantile</code> and <code>median</code> return the quantile(s) or median with an attribute <code>pos</code>, the class number of the quantile(s), or the median.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>histdata(x, breaks = "Sturges", probs = seq(0, 1, 0.25), ...)

## S3 method for class 'histogram'
quantile(x, probs = seq(0, 1, 0.25), ...)

## S3 method for class 'histogram'
median(x, ...)

## S3 method for class 'histogram'
mean(x, ...)

dhist(x, breaks = "Sturges", probs = seq(0, 1, 0.25), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histdata_+3A_x">x</code></td>
<td>
<p>numeric data or histogram data</p>
</td></tr>
<tr><td><code id="histdata_+3A_breaks">breaks</code></td>
<td>
<p>one of:
</p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> a function to compute the vector of breakpoints,
</p>
</li>
<li><p> a single number giving the number of cells for the histogram,
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells (see &lsquo;Details&rsquo;),
</p>
</li>
<li><p> a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the
breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values, the number
is limited to <code>1e6</code> (with a warning if it was larger).  If
<code>breaks</code> is a function, the <code>x</code> vector is supplied to it
as the only argument (and the number of breaks is only limited by
the amount of available memory).
</p>
</td></tr>
<tr><td><code id="histdata_+3A_probs">probs</code></td>
<td>
<p>numeric: probabilities to use if <code>breaks="Quantile"</code> (default: <code>seq(0, 1, 0.25)</code>)</p>
</td></tr>
<tr><td><code id="histdata_+3A_...">...</code></td>
<td>
<p>further parameters used in <a href="graphics.html#topic+hist">graphics::hist</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like in <a href="graphics.html#topic+hist">graphics::hist</a>, but with this additional list of elements:
</p>

<ul>
<li> <p><code>lower</code> lower class borders,
</p>
</li>
<li> <p><code>upper</code> upper class borders,
</p>
</li>
<li> <p><code>width</code> class widths,
</p>
</li>
<li> <p><code>relfreq</code> the relative class frequency,
</p>
</li>
<li> <p><code>cumfbrk</code> the cumulated relative frequency of the <code>breaks</code>,
</p>
</li>
<li> <p><code>maxdens</code> the indices of the maximal <code>density</code> values,
</p>
</li>
<li> <p><code>maxcount</code> the indices of the maximal <code>count</code> values
</p>
</li>
<li> <p><code>x</code> the original finite data, and
</p>
</li>
<li> <p><code>class</code> the class number for each value in <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#1
x &lt;- seq(0, 1, by=0.25)
print(hist(x, plot=FALSE))
histdata(x)
#2
x &lt;- seq(0, 1, by=0.25)
print(hist(x, x, plot=FALSE))
histdata(x, x)
#3
print(hist(x, x, right=FALSE, plot=FALSE))
histdata(x, x, right=FALSE)
</code></pre>

<hr>
<h2 id='histwidth'>Histogram Widths</h2><span id='topic+histwidth'></span><span id='topic+width_breaks'></span><span id='topic+dhistwidth'></span>

<h3>Description</h3>

<p>Creates a set of breaks and absolute frequencies in the range from '<code>from</code>' to '<code>to</code>'. The class widths are
sampled from <code>widths</code>. The resulting numbers could be multiplied with an integer, if the <code>sum(n)</code> is too small.
Additionally, it is checked whether the generated densities are terminating decimals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histwidth(from, to, widths, dmax = 100)

width_breaks(from, to, widths, dmax = 100)

dhistwidth(from, to, widths, dmax = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histwidth_+3A_from">from</code></td>
<td>
<p>numeric: start value</p>
</td></tr>
<tr><td><code id="histwidth_+3A_to">to</code></td>
<td>
<p>numeric: end value</p>
</td></tr>
<tr><td><code id="histwidth_+3A_widths">widths</code></td>
<td>
<p>numeric: a vector of width to sample from</p>
</td></tr>
<tr><td><code id="histwidth_+3A_dmax">dmax</code></td>
<td>
<p>numeric: max. denominator value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>breaks</code>, <code>n</code>'s for each class and <code>decimal</code> if all densities are terminating decimals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- histwidth(1.6, 2.1, widths=c(0.05, 0.1, 0.15, 0.2))
l
x &lt;- histx(l$breaks, l$n)
histdata(x, l$breaks)
</code></pre>

<hr>
<h2 id='histx'>Midpoint-Based Data Creation for a Histogram</h2><span id='topic+histx'></span><span id='topic+gen_mid'></span><span id='topic+dhistx'></span>

<h3>Description</h3>

<p>Given the breaks and the number of observations, a data set is generated with <code><a href="stats.html#topic+Uniform">stats::runif()</a></code>, using
the class mids: <code class="reqn">x_i = class\_mid_j + alpha*class\_width_j/2</code>. The default <code>alpha=0.99</code> ensures that
generated observations do not lie on the class borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histx(breaks, n, alpha = 0.99)

gen_mid(breaks, n, alpha = 0.99)

dhistx(breaks, n, alpha = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histx_+3A_breaks">breaks</code></td>
<td>
<p>numeric: class borders</p>
</td></tr>
<tr><td><code id="histx_+3A_n">n</code></td>
<td>
<p>numeric: number of observations in each class</p>
</td></tr>
<tr><td><code id="histx_+3A_alpha">alpha</code></td>
<td>
<p>numeric: how far the generated observations can be away from the class mids (default: <code>0.99</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q  &lt;- sort(sample(seq(0.1, 0.9, by=0.1), 4))
qx &lt;- pnorm(q)
histx(qx, diff(q))
</code></pre>

<hr>
<h2 id='hm_cell'><code>html_mmatrix</code> Modification</h2><span id='topic+hm_cell'></span><span id='topic+hm_index'></span><span id='topic+hm_row'></span><span id='topic+hm_col'></span><span id='topic+hm_title'></span><span id='topic+hm_tr'></span><span id='topic+hm_table'></span><span id='topic+modify_cell'></span><span id='topic+mod_cell'></span><span id='topic+modify_col'></span><span id='topic+mod_col'></span><span id='topic+modify_index'></span><span id='topic+mod_ind'></span><span id='topic+modify_row'></span><span id='topic+mod_row'></span><span id='topic+modify_table'></span><span id='topic+mod_t'></span><span id='topic+modify_title'></span><span id='topic+mod_title'></span><span id='topic+modify_tr'></span><span id='topic+mod_tr'></span>

<h3>Description</h3>


<ul>
<li> <p><code>hm_cell</code> or <code>hm_index</code> modify a data cell format (<code>fmt="%s"</code>), value (unnamed parameter) or style (<code>text_align="left"</code>)
</p>
</li>
<li> <p><code>hm_col</code> or <code>hm_row</code> modify a row or column format (<code>fmt="%s"</code>), value (unnamed parameter) or style (<code>text_align="left"</code>)
</p>
</li>
<li> <p><code>hm_title</code> modifies the title attribute of an <code>html_matrix</code> based on specific arguments
</p>
</li>
<li> <p><code>hm_table</code> modifies the properties of the entire HTML table within an <code>html_matrix</code>
</p>
</li>
<li> <p><code>hm_tr</code> modifies the properties of one or more table rows (tr elements) in an <code>html_matrix</code>. Row indices for modification (<code>ind</code>) can be specified along with additional parameters to customize the row format, values, or style
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hm_cell(x, row = NULL, col = NULL, ..., byrow = FALSE)

hm_index(x, ind, ...)

hm_title(x, ...)

hm_table(x, ...)

hm_row(x, ind, ...)

hm_col(x, ind, ...)

hm_tr(x, ind, ...)

modify_cell(x, row = NULL, col = NULL, ..., byrow = FALSE)

mod_cell(x, row = NULL, col = NULL, ..., byrow = FALSE)

modify_col(x, ind, ...)

mod_col(x, ind, ...)

modify_index(x, ind, ...)

mod_ind(x, ind, ...)

modify_row(x, ind, ...)

mod_row(x, ind, ...)

modify_table(x, ...)

mod_t(x, ...)

modify_title(x, ...)

mod_title(x, ...)

modify_tr(x, ind, ...)

mod_tr(x, ind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hm_cell_+3A_x">x</code></td>
<td>
<p>an <code>html_matrix</code> object</p>
</td></tr>
<tr><td><code id="hm_cell_+3A_row">row</code></td>
<td>
<p>integer: row(s) to access</p>
</td></tr>
<tr><td><code id="hm_cell_+3A_col">col</code></td>
<td>
<p>integer: column(s) to access</p>
</td></tr>
<tr><td><code id="hm_cell_+3A_...">...</code></td>
<td>
<p>further elements</p>
</td></tr>
<tr><td><code id="hm_cell_+3A_byrow">byrow</code></td>
<td>
<p>logical: order indices by row or column (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="hm_cell_+3A_ind">ind</code></td>
<td>
<p>integer vector or matrix: has access to various (row and columns) elements (first column: row, second column: column)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>html_matrix</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- html_matrix(matrix(1:6, ncol=2))
# replace l[1,1] by NA
hm_cell(l, 1, 1, NA)
# replace l[1,1] by NA and set the text_align to center
hm_cell(l, 1, 1, NA, text_align="center")
# replace l[1,3] and l[2,1] by NA
rcind &lt;- cbind(c(1,3), c(2, 1))
hm_index(l, rcind, NA)
# set a new title
hm_title(l, "new title")
# set a new row or column title
hm_row(l, 2, "row 2")
hm_col(l, 1, "col 1")
# set fmt by column or row
print(hm_cell(l, fmt=c("%.0f", "%.1f", "%.2f"), byrow=FALSE), which="fmt")
print(hm_cell(l, fmt=c("%.0f", "%.1f"), byrow=TRUE), which="fmt")
</code></pre>

<hr>
<h2 id='html_e2m'>HTML <code>exams.forge</code></h2><span id='topic+html_e2m'></span><span id='topic+toHTML_XML'></span>

<h3>Description</h3>

<p>Creates an HTML page with all the contents of the XML tags whose names match <code>pattern</code>.<br /><br />
The default is to show the contents of all XML tags. The HTML page is stored in the HTML file <code>name</code>.<br /><br />
The default <code>name=NULL</code> creates a temporary file. If the name does not end in <code>.html</code>, then a <code>.html</code> is appended.
</p>
<p>If <code>browseURL=TRUE</code> (default) then the HTML page will be displayed in the browser.
</p>
<p>If necessary the contents of XML tags are concatenated with <code>"\n"</code>.
For single XML tags this can be changed, e.g. <code>merge=list("questionlist"="&lt;br&gt;"</code> leads to the XML tag
<code>&lt;questionlist&gt;...&lt;/questionlist&gt;)</code> <code>"&lt;br&gt;"</code> being used ,instead of the <code>"\n"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_e2m(
  exam,
  name = NULL,
  pattern = ".",
  mathjax = TRUE,
  browseURL = TRUE,
  overwrite = FALSE,
  header = 2,
  merge = list(questionlist = "&lt;br&gt;"),
  png = TRUE
)

toHTML_XML(
  exam,
  name = NULL,
  pattern = ".",
  mathjax = TRUE,
  browseURL = TRUE,
  overwrite = FALSE,
  header = 2,
  merge = list(questionlist = "&lt;br&gt;"),
  png = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_e2m_+3A_exam">exam</code></td>
<td>
<p>list: returns a list from <code>exams.forge</code></p>
</td></tr>
<tr><td><code id="html_e2m_+3A_name">name</code></td>
<td>
<p>character: name of the HTML file (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_pattern">pattern</code></td>
<td>
<p>character: string containing a regular expression to match the list elements (default: <code>.</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_mathjax">mathjax</code></td>
<td>
<p>logical: should MathJax be loaded? (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_browseurl">browseURL</code></td>
<td>
<p>logical: should the generated HTML be shown? (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_overwrite">overwrite</code></td>
<td>
<p>logical: should the HTML file be overwritten (if it exists)? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_header">header</code></td>
<td>
<p>integer: at which level of the list a <code>&lt;h2&gt;...&lt;/h2&gt;</code> element should be included? (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_merge">merge</code></td>
<td>
<p>list: should elements with <code>.XXXXnn</code> at the end be merged? (default: <code>list('questionlist'="&lt;br&gt;")</code>)</p>
</td></tr>
<tr><td><code id="html_e2m_+3A_png">png</code></td>
<td>
<p>logical: if a entry ends with <code>.png</code> then the function will try to embed the PNG in the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the names of listed elements in the HTML file.
</p>


<h3>See Also</h3>

<p>The aim is similar to <code>exams:::exams:::browse_exercise</code>, however, <code>html_e2m</code> takes the information form
the XML file generated by the <code>exams.forge</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  resexams &lt;- readRDS(system.file("xml", "klausur-test.rds", package="exams.moodle"))
  html_e2m(resexams) # opens HTML file into browser
}
</code></pre>

<hr>
<h2 id='html_matrix'>HTML Representation</h2><span id='topic+html_matrix'></span><span id='topic+html_mx'></span><span id='topic+html_matrix.default'></span>

<h3>Description</h3>

<p>Creates from a vector, a matrix, an array, or a table, an HTML representation of it. The HTML representation has one column and one row more
than the data. The additional row and column are used in order to have a title (top left), the column names (top), and the row names (left).
</p>
<p>You can set the style attributes (<code style="white-space: pre;">&#8288;&lt;td style="..."&gt;&#8288;</code>) via <code>hm_cell</code>, <code>hm_title</code>, <code>hm_col</code>, and <code>hm_row</code>.
For example: <code>hm_cell(hm, 1, 1, text_align="right")</code> will lead to (<code style="white-space: pre;">&#8288;&lt;td style="text-align:right;"&gt;&#8288;</code>) for the cell (1,1), and any
unnamed element will change the cell value.
Note: since <code>-</code> is an operator in R, we use <code style="white-space: pre;">&#8288;_&#8288;</code> instead. Of course, someone could use <code>"text-align"="right"</code>, but I am lazy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_matrix(x, ...)

## Default S3 method:
html_matrix(
  x,
  ...,
  byrow = FALSE,
  numeric = list(text_align = "right"),
  integer = list(text_align = "right"),
  char = list(text_align = "left"),
  logical = list(text_align = "right"),
  border = "#999999"
)

html_mx(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_matrix_+3A_x">x</code></td>
<td>
<p>vector, matrix, array, table or html_matrix: input.</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_byrow">byrow</code></td>
<td>
<p>logical: creates a row or column matrix if <code>x</code> is one-dimensional (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_numeric">numeric</code></td>
<td>
<p>list: of HTML style properties for a cell if <code>class(x[i,j])=="numeric"</code> (default: <code>list(text_align="right")</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_integer">integer</code></td>
<td>
<p>list: of HTML style properties for a cell if <code>class(x[i,j])=="integer"</code> (default: <code>list(text_align="right")</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_char">char</code></td>
<td>
<p>list: of HTML style properties for a cell if <code>class(x[i,j])=="character"</code> (default: <code>list(text_align="left")</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_logical">logical</code></td>
<td>
<p>list: of HTML style properties for a cell if <code>class(x[i,j])=="logical"</code> (default: <code>list(text_align="right")</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_+3A_border">border</code></td>
<td>
<p>character: vector of background color for a border cell (default: <code>"#999999")</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>html_matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:6, ncol=2)
m
l &lt;- html_matrix(m)
l
</code></pre>

<hr>
<h2 id='html_matrix_sk'><code>html_matrix</code> Object Creation</h2><span id='topic+html_matrix_sk'></span><span id='topic+lmatrix'></span>

<h3>Description</h3>

<p>My personal pipe creating an <code>html_matrix</code> object. Note that the length of <code>fmt</code>
must be either <code>nrow(m)</code> or <code>ncol(m)</code> depending on <code>byrow</code>.
</p>
<pre>
   html_matrix(m) 
     tooltip(sprintf(tooltip, nrow(m), ncol(m))) 
     hm_cell(fmt=fmt, byrow=byrow)
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>html_matrix_sk(
  m,
  title,
  fmt,
  byrow = TRUE,
  tooltip = "Die Tabelle hat %.0f Zeilen und %.0f Spalten",
  ...
)

lmatrix(
  m,
  title,
  fmt,
  byrow = TRUE,
  tooltip = "Die Tabelle hat %.0f Zeilen und %.0f Spalten",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_matrix_sk_+3A_m">m</code></td>
<td>
<p>vector, matrix, array, table or html_matrix: input</p>
</td></tr>
<tr><td><code id="html_matrix_sk_+3A_title">title</code></td>
<td>
<p>character: text for the upper left entry</p>
</td></tr>
<tr><td><code id="html_matrix_sk_+3A_fmt">fmt</code></td>
<td>
<p>character: text format for rows (or columns)</p>
</td></tr>
<tr><td><code id="html_matrix_sk_+3A_byrow">byrow</code></td>
<td>
<p>logical: <code>fmt</code> by row or by column (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_sk_+3A_tooltip">tooltip</code></td>
<td>
<p>character: text for tooltip with column and row numbers (default: <code>"Die Tabelle hat %.0f Zeilen und %.0f Spalten"</code>)</p>
</td></tr>
<tr><td><code id="html_matrix_sk_+3A_...">...</code></td>
<td>
<p>further parameters given to <code>html_matrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>html_matrix</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:6, ncol=2)
html_matrix_sk(m, title="", fmt=c("%.0f", "%.1f"))
</code></pre>

<hr>
<h2 id='hyper_param'>Parameters for Hypergeometric Distributions</h2><span id='topic+hyper_param'></span>

<h3>Description</h3>

<p>Generates a data frame with potential values for <code>m</code>, <code>n</code> and <code>k</code>. If <code>hyper2</code> is <code>FALSE</code> then the
parametrization of <code><a href="stats.html#topic+Hypergeometric">stats::dhyper()</a></code> is used, otherwise <code>n+m</code>, <code>m</code> and <code>k</code> is used and transformed to <code>m</code>, <code>n</code> and <code>k</code>.
In accordance with specific conditions it holds that:
</p>

<ul>
<li><p> if <code>length(mean)==1</code> and it's an integer, it signifies the desired number of digits for the mean
</p>
</li>
<li><p> if <code>mean</code> is set to <code>NA</code> (the default), all means are permissible
</p>
</li>
<li><p> when <code>length(mean) &gt; 1</code>, the product <code class="reqn">k*m/(n+m)</code> must be one of the valid means
</p>
</li>
<li><p> the same rules apply to <code>sd</code>
</p>
</li></ul>

<p>The parameters <code>norm</code>, <code>pois</code> and <code>binom</code> can take on the values <code>NA</code>, <code>TRUE</code>, <code>FALSE</code>,
or be defined as a function of the format: <code style="white-space: pre;">&#8288;function(m, n, k)&#8288;</code>.
These values determine which <code style="white-space: pre;">&#8288;(m, n, k)&#8288;</code> combinations are eligible:
</p>

<ul>
<li><p> for <code>NA</code>, all combinations of <code style="white-space: pre;">&#8288;(m, n, k)&#8288;</code> are acceptable
</p>
</li>
<li><p> if specified as a function, only those combinations for which the function evaluates to <code>TRUE</code> are considered valid
</p>
</li>
<li><p> if set to <code>TRUE</code>, combinations are accepted only if they satisfy either the condition <code class="reqn">k*m/(m+n)*(1-m/(m+n))&gt;=9</code>
(for <code>norm</code>, indicating a normal distribution approximation), the conditions <code class="reqn">k/(n+m) &lt; 0.05</code>, <code class="reqn">m/(n+m) &lt; 0.05</code> and <code class="reqn">k&gt;10</code>
(for <code>pois</code>, implying a Poisson distribution approximation) and the condition <code class="reqn">k/(n+m) &lt; 0.05</code> (for <code>binom</code>,
implying a binomial distribution approximation)
</p>
</li>
<li><p> if set to <code>FALSE</code>, the approximations should not hold for any combination.
</p>
</li></ul>

<p>Please be aware that there is no guarantee that the resulting data frame will include a valid solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_param(
  m,
  n,
  k,
  mean = NA,
  sd = NA,
  norm = NA,
  pois = NA,
  binom = NA,
  tol = 1e-06,
  hyper2 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper_param_+3A_m">m</code></td>
<td>
<p>numeric: the number of white balls in the urn</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_n">n</code></td>
<td>
<p>numeric: the number of black balls in the urn</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_k">k</code></td>
<td>
<p>numeric: the number of balls drawn from the urn, hence must be in <code class="reqn">0, 1, ..., m+n</code></p>
</td></tr>
<tr><td><code id="hyper_param_+3A_mean">mean</code></td>
<td>
<p>integer or numeric: number of digits the mean should have</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_sd">sd</code></td>
<td>
<p>integer or numeric: number of digits the standard deviation should have</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_norm">norm</code></td>
<td>
<p>logical or function: normal approximation possible</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_pois">pois</code></td>
<td>
<p>logical or function: poisson approximation possible</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_binom">binom</code></td>
<td>
<p>logical or function: binomial approximation possible</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_tol">tol</code></td>
<td>
<p>numeric: the tolerance for numerical comparison (default: '1e-6)</p>
</td></tr>
<tr><td><code id="hyper_param_+3A_hyper2">hyper2</code></td>
<td>
<p>logical: should the standard R parametrization <code style="white-space: pre;">&#8288;(m, n, k)&#8288;</code> be used or <code style="white-space: pre;">&#8288;(n+m, m, k)&#8288;</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with possible the choices of <code>n</code> , <code>p</code>, <code>mean</code> and <code>sd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hyper_param(7:14, 1:13, 3:10, norm=FALSE, pois=FALSE, binom=FALSE, hyper2=TRUE)
</code></pre>

<hr>
<h2 id='hyperloop'>Hyperloop</h2><span id='topic+hyperloop'></span><span id='topic+hloop'></span>

<h3>Description</h3>

<p>Runs a function several times with all parameter combinations, and checks:
</p>

<ul>
<li><p> if an argument is not a list, then it will be converted to an one element list
</p>
</li>
<li><p> if an error occurs then the result of <code>FUN</code> will not be stored
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hyperloop(FUN, ..., .simplify = FALSE)

hloop(FUN, ..., .simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperloop_+3A_fun">FUN</code></td>
<td>
<p>function with named parameter(s)</p>
</td></tr>
<tr><td><code id="hyperloop_+3A_...">...</code></td>
<td>
<p>named parameters which contain lists with possible parameter values</p>
</td></tr>
<tr><td><code id="hyperloop_+3A_.simplify">.simplify</code></td>
<td>
<p>logical: should the result be simplified to a data frame (if possible)? (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>hyperloop</code> object as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x   &lt;- rnorm(100)
trm &lt;- hyperloop(mean, x=list(x), trim=as.list(seq(0, 0.5, by=0.05)))
# automatic conversion of x to list(x)
trm &lt;- hyperloop(mean, x=x, trim=as.list(seq(0, 0.5, by=0.05))) 
unlist(trm)
</code></pre>

<hr>
<h2 id='hypothesis_latex'>Latex Hypothesis</h2><span id='topic+hypothesis_latex'></span><span id='topic+lhypo'></span>

<h3>Description</h3>

<p>Creates a data frame for a test hypothesis with various columns:
</p>

<ul>
<li> <p><code>h0.left</code> left value of the null hypothesis, usually <code style="white-space: pre;">&#8288;\mu&#8288;</code> or <code style="white-space: pre;">&#8288;\pi&#8288;</code>
</p>
</li>
<li> <p><code>h0.operator</code> operator of the null hypothesis, one of the following: <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>
</p>
</li>
<li> <p><code>h0.right</code> right value of the null hypothesis, usually <code style="white-space: pre;">&#8288;\mu_0&#8288;</code>, <code style="white-space: pre;">&#8288;\pi_0&#8288;</code>, or a hypothetical value
</p>
</li>
<li> <p><code>h1.left</code> left value of the alternative hypothesis, usually <code style="white-space: pre;">&#8288;\mu&#8288;</code> or <code style="white-space: pre;">&#8288;\pi&#8288;</code>
</p>
</li>
<li> <p><code>h1.operator</code> operator of the alternative hypothesis, one of the following: <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>
</p>
</li>
<li> <p><code>h1.right</code> right value of the alternative hypothesis, usually <code style="white-space: pre;">&#8288;\mu_0&#8288;</code>, <code style="white-space: pre;">&#8288;\pi_0&#8288;</code>, or a hypothetical value
</p>
</li>
<li> <p><code>H0</code> latex representation of the null hypothesis
</p>
</li>
<li> <p><code>H1</code> latex representation of the alternative hypothesis
</p>
</li>
<li> <p><code>match.left</code> do the left value in the null and the alternative hypothesis match?
</p>
</li>
<li> <p><code>match.right</code>  do the right value in the null and the alternative hypothesis match?
</p>
</li>
<li> <p><code>match.operator</code> do the operators in the null and the alternative hypothesis cover all real numbers?
</p>
</li>
<li> <p><code>match.right</code>  do the right value in the null and alternative hypothesis match?
</p>
</li>
<li> <p><code>match.type</code> either <code>wrong</code>, <code>left.sided</code>, <code>right.sided</code>, <code>two.sided</code>, <code>greater</code>, or <code>less</code>.
</p>
</li></ul>

<p>If <code>null</code> is not given then it is determined from <code>alternative</code>. Otherwise hypotheses pairs are generated by
all combinations from <code>alternative</code> and <code>null</code>.
Valid values for <code>alternative</code>and <code>null</code> are <code>two.sided</code>, <code>greater</code>, <code>less</code>,  <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypothesis_latex(
  left,
  alternative = NULL,
  null = NULL,
  right = paste0(left, "_0")
)

lhypo(left, alternative = NULL, null = NULL, right = paste0(left, "_0"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypothesis_latex_+3A_left">left</code></td>
<td>
<p>character: symbol, for example <code>"\mu"</code> or <code>"\pi"</code></p>
</td></tr>
<tr><td><code id="hypothesis_latex_+3A_alternative">alternative</code></td>
<td>
<p>character: alternative hypotheses</p>
</td></tr>
<tr><td><code id="hypothesis_latex_+3A_null">null</code></td>
<td>
<p>character: null hypotheses (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="hypothesis_latex_+3A_right">right</code></td>
<td>
<p>character: a symbol (default: <code>paste0(left, "_0")</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with hypothesis pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create one hypotheses pair
hypothesis_latex("\\mu")
hypothesis_latex("\\pi")
hypothesis_latex("\\mu", alternative="two.sided")
hypothesis_latex("\\mu", alternative="two.sided", null="lt")
hypothesis_latex("\\mu", alternative="ne", null="eq")
hypothesis_latex("\\mu", right=c(0,1))
hypothesis_latex("\\mu", alternative=c("eq", "ne", "lt", "le", "gt", "ge"))
hypothesis_latex("\\mu", alternative=c("eq", "ne", "lt", "le", "gt", "ge"), 
                         null=c("eq", "ne", "lt", "le", "gt", "ge"))
</code></pre>

<hr>
<h2 id='incomplete_table'>Relative Contingency Table Fill</h2><span id='topic+incomplete_table'></span><span id='topic+cont_table_fill'></span>

<h3>Description</h3>

<p>Fills a relative contingency table with <code>n</code> missing values, such that the table entries can be
recomputed. In case that no solution can be found, an error is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incomplete_table(tab, n, maxit = 1000)

cont_table_fill(tab, n, maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incomplete_table_+3A_tab">tab</code></td>
<td>
<p>table: a contingency table</p>
</td></tr>
<tr><td><code id="incomplete_table_+3A_n">n</code></td>
<td>
<p>integer: number of missing values</p>
</td></tr>
<tr><td><code id="incomplete_table_+3A_maxit">maxit</code></td>
<td>
<p>integer: number of maximal iterations (default: <code>1000</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contingency table including marginal values and total sum with missing values.
The attribute <code>fillin</code> gives the necessary information about the order in which the entries can be calculated,
while the attribute <code>full</code> presents the contingency table, including marginal values and total sum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- rbind(c(0.02, 0.04, 0.34), c(0.02, 0.28, 0.3))
incomplete_table(tab, 7)
</code></pre>

<hr>
<h2 id='inline'>Text Knitting</h2><span id='topic+inline'></span><span id='topic+txt_knit'></span>

<h3>Description</h3>

<p>Knits <code>txt</code> within an R code chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inline(txt)

txt_knit(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inline_+3A_txt">txt</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- inline("2 + 2")
</code></pre>

<hr>
<h2 id='is.prob'>Interval Checker</h2><span id='topic+is.prob'></span><span id='topic+is_prob_interval'></span><span id='topic+is_prob'></span><span id='topic+in_range'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> is in an opened or closed interval between <code>min</code> and <code>max</code>.
The default is set as such, that the chosen interval is an interval of <code class="reqn">(0,1)</code>.
For example, in the case of <code>x</code> being a probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.prob(x, open = TRUE, min = 0, max = 1)

is_prob_interval(x, open = TRUE, min = 0, max = 1)

is_prob(x, open = TRUE, min = 0, max = 1)

in_range(x, open = TRUE, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.prob_+3A_x">x</code></td>
<td>
<p>numeric: values to check</p>
</td></tr>
<tr><td><code id="is.prob_+3A_open">open</code></td>
<td>
<p>logical: checks if the left and right borders are open or closed (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="is.prob_+3A_min">min</code></td>
<td>
<p>numeric: minimal value (default: <code>0</code>)</p>
</td></tr>
<tr><td><code id="is.prob_+3A_max">max</code></td>
<td>
<p>numeric: maximal value (default: <code>1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.prob(runif(1))
</code></pre>

<hr>
<h2 id='knitif'>Knitting a Text Argument</h2><span id='topic+knitif'></span><span id='topic+knit_select'></span>

<h3>Description</h3>

<p>Selects a text argument and returns the knitted result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knitif(n, ..., envir = knit_global())

knit_select(n, ..., envir = knit_global())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knitif_+3A_n">n</code></td>
<td>
<p>character: text argument to use</p>
</td></tr>
<tr><td><code id="knitif_+3A_...">...</code></td>
<td>
<p>character: arguments to choose from</p>
</td></tr>
<tr><td><code id="knitif_+3A_envir">envir</code></td>
<td>
<p>environment: in which code chunks are to be evaluated (default: <code style="white-space: pre;">&#8288;[knitr::knit_global]&#8288;</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knitif(runif(1)&lt;0.5, 'TRUE'="`r pi`", 'FALSE'="$\\pi=`r pi`$")
</code></pre>

<hr>
<h2 id='latexdef'>Exam PDF with LaTeX</h2><span id='topic+latexdef'></span><span id='topic+answercol'></span><span id='topic+add_answercol_def'></span>

<h3>Description</h3>

<p>If exams is called by <code>exams2pdf</code>,
</p>

<ul>
<li> <p><code>latexdef</code> adds a TeX macro by <code style="white-space: pre;">&#8288;\def\name{body}&#8288;</code> and
</p>
</li>
<li> <p><code>answercol</code> adds a <code style="white-space: pre;">&#8288;\def\answercol{n}&#8288;</code> to modify the number of output columns for multiple-choice answers
to the LaTeX file.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>latexdef(name, body)

answercol(n)

add_answercol_def(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latexdef_+3A_name">name</code></td>
<td>
<p>character: macro name</p>
</td></tr>
<tr><td><code id="latexdef_+3A_body">body</code>, <code id="latexdef_+3A_n">n</code></td>
<td>
<p>character: macro body</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>answercol(2)
</code></pre>

<hr>
<h2 id='lcmval'>Least Common Multiple</h2><span id='topic+lcmval'></span><span id='topic+lcm_vector'></span>

<h3>Description</h3>

<p>Computes the least common multiple for a numeric vector <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcmval(x)

lcm_vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcmval_+3A_x">x</code></td>
<td>
<p>integer: numbers to find the least common multiple</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The least common multiple.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lcmval(c(144, 160))      # = 1440
lcmval(c(144, 160, 175)) # = 50.400
</code></pre>

<hr>
<h2 id='lm1_data'>Simple Linear Regression and Data Generation</h2><span id='topic+lm1_data'></span><span id='topic+slr_data'></span>

<h3>Description</h3>

<p>Creates data suitable for a simple linear regression. In the first step, data is computed using <code><a href="#topic+pearson_data">pearson_data()</a></code>,
satisfying the conditions <code class="reqn">\sum_{i=1}^{nmax} x_i^2 = n</code> and  <code class="reqn">\sum_{i=1}^{nmax} x_i = 0</code> (similar conditions apply to <code class="reqn">y</code>.
The data are then rescaled with <code class="reqn">x' = center[1]+scale[1]*x</code> and
<code class="reqn">y' = center[2]+scale[2]*y</code>.
Finally, a simple linear regression is performed on the transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm1_data(
  r,
  n = 100,
  nmax = 6,
  maxt = 30,
  xsos = NULL,
  ysos = NULL,
  center = numeric(0),
  scale = numeric(0),
  ...
)

slr_data(
  r,
  n = 100,
  nmax = 6,
  maxt = 30,
  xsos = NULL,
  ysos = NULL,
  center = numeric(0),
  scale = numeric(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm1_data_+3A_r">r</code></td>
<td>
<p>numeric: desired correlation</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_n">n</code></td>
<td>
<p>integer: number to decompose as sum of squares, see <code><a href="#topic+pearson_data">pearson_data()</a></code>.</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_nmax">nmax</code></td>
<td>
<p>integer: maximal number of squares in the sum, see <code><a href="#topic+pearson_data">pearson_data()</a></code>.</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_maxt">maxt</code></td>
<td>
<p>numeric: maximal number of seconds the routine should run, see <code><a href="#topic+pearson_data">pearson_data()</a></code>.</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_xsos">xsos</code></td>
<td>
<p>sos matrix: precomputed matrix, see <code><a href="#topic+pearson_data">pearson_data()</a></code>.</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_ysos">ysos</code></td>
<td>
<p>sos matrix: precomputed matrix, see <code><a href="#topic+pearson_data">pearson_data()</a></code>.</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_center">center</code></td>
<td>
<p>numeric(2): center of <code>x</code> and <code>y</code> data</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_scale">scale</code></td>
<td>
<p>numeric(2): standard deviation for <code>x</code> and <code>y</code> data</p>
</td></tr>
<tr><td><code id="lm1_data_+3A_...">...</code></td>
<td>
<p>further named parameters given to <code><a href="stats.html#topic+lm">stats::lm()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an extended <code>lm</code> object and the additional list elements:
</p>

<ul>
<li> <p><code>inter</code> contains intermediate results (the last column contains the row sums), and
</p>
</li>
<li> <p><code>xy</code> the generated <code class="reqn">x</code>- and <code class="reqn">y</code>-values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(sos)
n   &lt;- sample(5:10, 1)
lm1 &lt;- lm1_data(0.6, nmax=n, xsos=sos100)
str(lm1)
</code></pre>

<hr>
<h2 id='lmr_data'><code>lm</code> Simple Linear Regression</h2><span id='topic+lmr_data'></span><span id='topic+lm_regression_data'></span>

<h3>Description</h3>

<p>Computes an <code>lm</code> object for a simple linear regression from a range of <code>x</code> and <code>y</code> values,
including intermediate values. If <code>r</code> is not given then zero correlation is used (with <code>cor_data</code>).
<code>digits</code> determines the rounding for the <code>x</code> and <code>y</code> values. If only one value is given, then
it will be used for <code>x</code> and <code>y</code>. If no value is given then it will be determined from
the <code>x</code> and <code>y</code> values by <code>3+ceiling(-log10(diff(range(.))))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmr_data(xr, yr, n, r = 0, digits = NULL, ...)

lm_regression_data(xr, yr, n, r = 0, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmr_data_+3A_xr">xr</code></td>
<td>
<p>numeric: range of x values</p>
</td></tr>
<tr><td><code id="lmr_data_+3A_yr">yr</code></td>
<td>
<p>numeric: range of y values</p>
</td></tr>
<tr><td><code id="lmr_data_+3A_n">n</code></td>
<td>
<p>numeric: number of observations to generate</p>
</td></tr>
<tr><td><code id="lmr_data_+3A_r">r</code></td>
<td>
<p>numeric: desired correlation, uses <code>cor_data</code></p>
</td></tr>
<tr><td><code id="lmr_data_+3A_digits">digits</code></td>
<td>
<p>numeric(2): digits for rounding, for x <code>digits[1]</code> is used, for y <code>digits[2]</code> is used (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="lmr_data_+3A_...">...</code></td>
<td>
<p>further parameters used in <code>cor_data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>lm</code> with the additional components:
</p>

<ul>
<li> <p><code>x</code> the generated x values
</p>
</li>
<li> <p><code>y</code> the generated y values
</p>
</li>
<li> <p><code>sumx</code> <code class="reqn">\sum_{i=1}^n x_i</code>
</p>
</li>
<li> <p><code>sumy</code> <code class="reqn">\sum_{i=1}^n y_i</code>
</p>
</li>
<li> <p><code>sumx2</code> <code class="reqn">\sum_{i=1}^n x_i^2</code>
</p>
</li>
<li> <p><code>sumy2</code> <code class="reqn">\sum_{i=1}^n y_i^2</code>
</p>
</li>
<li> <p><code>sumxy</code> <code class="reqn">\sum_{i=1}^n x_i y_i</code>
</p>
</li>
<li> <p><code>meanx</code> the mean of x: <code class="reqn">1/n \sum_{i=1}^n x_i</code>
</p>
</li>
<li> <p><code>meany</code> the mean of y: <code class="reqn">1/n \sum_{i=1}^n y_i</code>
</p>
</li>
<li> <p><code>varx</code> the variation of x: <code class="reqn">\sum_{i=1}^n (x_i-\bar{x})^2</code>
</p>
</li>
<li> <p><code>vary</code> the variation of y: <code class="reqn">\sum_{i=1}^n (y_i-\bar{y})^2</code>
</p>
</li>
<li> <p><code>varxy</code> the common variation of x and y:<code class="reqn">\sum_{i=1}^n (x_i-\bar{x})(y_i-\bar{y})</code>
</p>
</li>
<li> <p><code>sxy</code> the covariance of x and y
</p>
</li>
<li> <p><code>rxy</code> the correlation of x and y
</p>
</li>
<li> <p><code>b0</code> the intercept of the linear regression
</p>
</li>
<li> <p><code>b1</code> the slope of the linear regression
</p>
</li>
<li> <p><code>r2</code> the coefficient of determination of the linear regression
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Engine displacement typically ranges from 500 to 2000 cm^3
# Fuel economy typically ranges from 2 to 8 liter/100 km
lmr &lt;- lmr_data(c(500, 2000), c(2, 8), n=8)
str(lmr)
</code></pre>

<hr>
<h2 id='lsumprod'>Supporting Functions for Math LaTeX Output</h2><span id='topic+lsumprod'></span><span id='topic+latex_sumprod'></span><span id='topic+latex_sum'></span><span id='topic+latex_product'></span><span id='topic+latex_mean'></span><span id='topic+latex_var'></span><span id='topic+latex_bracket'></span><span id='topic+latex_pmsign'></span><span id='topic+lsum'></span><span id='topic+lprod'></span><span id='topic+lvec'></span><span id='topic+lmean'></span><span id='topic+lvar'></span><span id='topic+lbr'></span><span id='topic+lsgn'></span>

<h3>Description</h3>

<p><code>lsumprod</code> creates a latex printout of <code class="reqn">\sum_i x_i y_i</code> with brackets if <code class="reqn">x_i</code> or <code class="reqn">y_i</code> starts with a <code>-</code>.
</p>
<p><code>lsum</code> creates a latex printout of <code class="reqn">x</code> as sum.
</p>
<p><code>lprod</code> creates a latex printout of <code class="reqn">x</code> as product.
</p>
<p><code>lvec</code> creates a latex printout of <code class="reqn">x</code> as vector.
</p>
<p><code>lmean</code> creates a latex printout as <code class="reqn">\frac{x_1+...+x_n}{n}</code>.
</p>
<p><code>lvar</code> creates a latex printout as <code class="reqn">\frac{(x_1-xbar)^2+...+(x_n-xbar)^2}{n}</code>.
</p>
<p><code>lbr</code> creates a latex printout of <code class="reqn">x</code> with brackets if <code class="reqn">x</code> starts with a <code>-</code>.
</p>
<p><code>lsgn</code> creates a latex printout of <code class="reqn">x</code> with a plus or minus at the beginning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsumprod(..., br = "(")

lsum(x)

lprod(x)

lvec(
  x,
  left = c("(", "[", "{", "|", "||", "&lt;", "a", "c", "f"),
  right = NULL,
  collapse = ", "
)

lmean(x)

lvar(x, mu = NULL, br = "(")

lbr(x, br = c("(", "[", "{", "|", "||", "&lt;", "a", "c", "f"), subset = NULL)

lsgn(x)

latex_sumprod(..., br = "(")

latex_sum(x)

latex_product(x)

latex_mean(x)

latex_var(x, mu = NULL, br = "(")

latex_bracket(
  x,
  br = c("(", "[", "{", "|", "||", "&lt;", "a", "c", "f"),
  subset = NULL
)

latex_pmsign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsumprod_+3A_...">...</code></td>
<td>
<p>further input values</p>
</td></tr>
<tr><td><code id="lsumprod_+3A_br">br</code>, <code id="lsumprod_+3A_left">left</code>, <code id="lsumprod_+3A_right">right</code></td>
<td>
<p>character: which brackets to use. The possibilities are:
</p>

<ul>
<li> <p><code>(</code> (default) uses <code style="white-space: pre;">&#8288;\left(&#8288;</code> and <code style="white-space: pre;">&#8288;\right(&#8288;</code>,
</p>
</li>
<li> <p><code>[</code> use <code style="white-space: pre;">&#8288;\left[&#8288;</code> and <code style="white-space: pre;">&#8288;\right]&#8288;</code>,
</p>
</li>
<li> <p><code>{</code> use <code style="white-space: pre;">&#8288;\left\{&#8288;</code> and <code style="white-space: pre;">&#8288;\right\}&#8288;</code>,
</p>
</li>
<li> <p><code>|</code>  use <code style="white-space: pre;">&#8288;\left|&#8288;</code> and <code style="white-space: pre;">&#8288;\right|&#8288;</code>,
</p>
</li>
<li> <p><code>||</code>  uses <code style="white-space: pre;">&#8288;\left\|&#8288;</code> and <code style="white-space: pre;">&#8288;\right\|&#8288;</code>,
</p>
</li>
<li> <p><code>&lt;</code>, <code>a</code> use <code style="white-space: pre;">&#8288;\left\langle&#8288;</code> and <code style="white-space: pre;">&#8288;\right\rangle&#8288;</code>,
</p>
</li>
<li> <p><code>c</code>  use <code style="white-space: pre;">&#8288;\left\lceil&#8288;</code> and <code style="white-space: pre;">&#8288;\right\rceil&#8288;</code>, and
</p>
</li>
<li> <p><code>f</code>  use <code style="white-space: pre;">&#8288;\left\lfloor&#8288;</code> and <code style="white-space: pre;">&#8288;\right\rfloor&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lsumprod_+3A_x">x</code></td>
<td>
<p>numeric: input values</p>
</td></tr>
<tr><td><code id="lsumprod_+3A_collapse">collapse</code></td>
<td>
<p>character: an optional character string to separate the results (default: ', ')</p>
</td></tr>
<tr><td><code id="lsumprod_+3A_mu">mu</code></td>
<td>
<p>numeric: population mean (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="lsumprod_+3A_subset">subset</code></td>
<td>
<p>logical: indicates which elements have brackets added (default: <code>NULL</code> = all elements starting with <code>-</code>); missing values are taken as false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lsumprod(-2:2, (1:5)/10)
lbr(-2:2)
lsum(-2:2)
lmean(-2:2)
lvec(-2:2)
lvec(-2:2, '[')
lvec(0:1, '(', ']')
</code></pre>

<hr>
<h2 id='makekey'>Character Key Generation</h2><span id='topic+makekey'></span><span id='topic+make_key'></span>

<h3>Description</h3>

<p>Generates a character key from a vector of integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makekey(index)

make_key(index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makekey_+3A_index">index</code></td>
<td>
<p>integer: vector of integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makekey(1)
makekey(1:2)
makekey(pi) # ;)
makekey(c(5,4))
</code></pre>

<hr>
<h2 id='mcval'>Most Common Value</h2><span id='topic+mcval'></span><span id='topic+compute_modes'></span><span id='topic+mcv'></span><span id='topic+mcval.default'></span><span id='topic+mcval.histogram'></span>

<h3>Description</h3>

<p>Computes all modes (most common value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcval(x, ...)

## Default S3 method:
mcval(x, ...)

## S3 method for class 'histogram'
mcval(x, exact = FALSE, ...)

compute_modes(x, ...)

mcv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcval_+3A_x">x</code></td>
<td>
<p>data object</p>
</td></tr>
<tr><td><code id="mcval_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="mcval_+3A_exact">exact</code></td>
<td>
<p>logical: either compute the exact mode or use class mids (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of modes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:5, 15, replace=TRUE)
mcval(x)
</code></pre>

<hr>
<h2 id='meanint_data'>Integer Observations and Mean</h2><span id='topic+meanint_data'></span>

<h3>Description</h3>

<p>The <code>meanint_data</code> function generates a set of integer observations with a specified integer mean.
It takes the number of observations or <code>x</code> values  and an optional range parameter, <code>r</code>, that defines the permissible range
of x values (defaulting to the range of <code>x</code>). Additional parameters are passed to the <code>mean</code> function.
The function employs a iterative process, adjusting individual observations to achieve an integer mean.
It uses a random selection approach, modifying a randomly chosen observation and checking if the resulting mean is closer to an integer.
The process continues until the mean becomes an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanint_data(x, r = range(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanint_data_+3A_x">x</code></td>
<td>
<p>numeric: number of observations or x values</p>
</td></tr>
<tr><td><code id="meanint_data_+3A_r">r</code></td>
<td>
<p>numeric: the range in which the x values allowed (default: <code>range(x)</code>)</p>
</td></tr>
<tr><td><code id="meanint_data_+3A_...">...</code></td>
<td>
<p>further parameters given to <code>mean</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of integer observations with an integer mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- meanint_data(10, c(1, 10))
mean(x)
</code></pre>

<hr>
<h2 id='means_choice'>Means</h2><span id='topic+means_choice'></span><span id='topic+means'></span>

<h3>Description</h3>

<p>Computes the means of <code>x</code>. The list returned has an attribute <code>"mindiff"</code> which contains
the smallest distance between two mean values before rounding.
If <code>winsor</code> and/or <code>trim</code> is set to <code>NA</code> then the trimmed and/or winsorized means are not computed.
Currently implemented are:
</p>

<dl>
<dt><code>mean</code></dt><dd><p>arithmetic mean</p>
</dd>
<dt><code>median</code></dt><dd><p>median</p>
</dd>
<dt><code>harmonic</code></dt><dd><p>harmonic mean</p>
</dd>
<dt><code>geometric</code></dt><dd><p>geometric mean</p>
</dd>
<dt><code>mode</code></dt><dd><p>(first) mode</p>
</dd>
<dt><code>trim</code></dt><dd><p>trimmed mean</p>
</dd>
<dt><code>winsor</code></dt><dd><p>winsorized mean</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>means_choice(x, digits, na.rm = TRUE, trim = 0.2, winsor = 0.2)

means(x, digits, na.rm = TRUE, trim = 0.2, winsor = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="means_choice_+3A_x">x</code></td>
<td>
<p>numeric: data values</p>
</td></tr>
<tr><td><code id="means_choice_+3A_digits">digits</code></td>
<td>
<p>numeric:    integer indicating the number of decimal points for rounding (negative values are allowed)</p>
</td></tr>
<tr><td><code id="means_choice_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: should <code>NA</code>s be removed before?</p>
</td></tr>
<tr><td><code id="means_choice_+3A_trim">trim</code></td>
<td>
<p>numeric: the fraction (0 to 0.5) of observations to be trimmed from each end of <code>x</code></p>
</td></tr>
<tr><td><code id="means_choice_+3A_winsor">winsor</code></td>
<td>
<p>numeric: the fraction (0 to 0.5) of observations to be moved from each end of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with mean values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(runif(9), 3)
means_choice(x, 2)
</code></pre>

<hr>
<h2 id='mime_image'>MIME Image</h2><span id='topic+mime_image'></span><span id='topic+mime_img'></span>

<h3>Description</h3>

<p>Returns the MIME type of an image based on the <code>filename</code> extension.
If a MIME type for a file extension cannot not found, then the extension itself will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mime_image(filename)

mime_img(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mime_image_+3A_filename">filename</code></td>
<td>
<p>character: file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mime_image("support.png")
mime_image("support.jpg")
</code></pre>

<hr>
<h2 id='monomial'>Monomial</h2><span id='topic+monomial'></span><span id='topic+monom'></span>

<h3>Description</h3>

<p>Creates a polynomial of the form <code class="reqn">c*x^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monomial(degree = 1, coefficient = 1)

monom(degree = 1, coefficient = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monomial_+3A_degree">degree</code></td>
<td>
<p>integer: degree of the polynomial (default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="monomial_+3A_coefficient">coefficient</code></td>
<td>
<p>numeric: coefficient of the polynomial (default: <code>1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polynomial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monomial()     # equivalent to polynomial()
monomial(3)    # x^3
monomial(3, 2) # 2*x^3
</code></pre>

<hr>
<h2 id='moodle_m2s'>Moodle Multiple-Choice</h2><span id='topic+moodle_m2s'></span><span id='topic+mchoice_moodle'></span>

<h3>Description</h3>

<p>The <code>exams</code> package does not support multiple-choice questions with multiple correct answers; it only allows for one answer to be chosen.
However, Moodle does support such questions. The function reads the XML file generated by <code>exams.forge</code> and makes changes
for all <code>mchoice</code> questions:
</p>

<ul>
<li> <p><code>&lt;single&gt;...&lt;/single&gt;</code> to <code>&lt;single&gt;true&lt;/single&gt;</code>, and
</p>
</li>
<li><p> modifies the attribute <code>fraction</code> in the tags <code>&lt;answer fraction="..."&gt;...&lt;/answer&gt;</code>.
If <code>fraction</code> is less than 0, it is set to zero, and if <code>fraction</code> is greater than 0, it is set to 100.
</p>
</li></ul>

<p>If the <code>file</code> does not end with <code>.xml</code>, then <code>.xml</code> is appended. At the end, the modified XML code is stored in <code>newfile</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moodle_m2s(file, newfile = NULL, verbose = 1)

mchoice_moodle(file, newfile = NULL, verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moodle_m2s_+3A_file">file</code></td>
<td>
<p>character: Moodle XML file with exercises to read from</p>
</td></tr>
<tr><td><code id="moodle_m2s_+3A_newfile">newfile</code></td>
<td>
<p>character:  Moodle XML file to write in (default: <code>file</code>)</p>
</td></tr>
<tr><td><code id="moodle_m2s_+3A_verbose">verbose</code></td>
<td>
<p>integer: output generation (default: <code>1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the written file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  newfile &lt;- tempfile(fileext=".xml")
  moodle_m2s(system.file("xml", "klausur-test.xml", package="exams.moodle"), newfile=newfile)
  file.edit(newfile)
}
</code></pre>

<hr>
<h2 id='nearest_arg'>Nearest Candidate Value</h2><span id='topic+nearest_arg'></span>

<h3>Description</h3>

<p>It determines the nearest candidate value for each value in <code>arg</code>.
As a replacement for <code style="white-space: pre;">&#8288;[base::match.arg]&#8288;</code>, it is more error-tolerant, but detecting a wrong choice can be proven challenging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_arg(arg, choices, method = "cosine", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_arg_+3A_arg">arg</code></td>
<td>
<p>character: vector or NULL</p>
</td></tr>
<tr><td><code id="nearest_arg_+3A_choices">choices</code></td>
<td>
<p>character: vector of candidate values</p>
</td></tr>
<tr><td><code id="nearest_arg_+3A_method">method</code></td>
<td>
<p>character: method for distance calculation (default: <code>cosine</code>)</p>
</td></tr>
<tr><td><code id="nearest_arg_+3A_...">...</code></td>
<td>
<p>further parameters for <a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each value in <code>arg</code> the (first) nearest element of <code>choices</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># match.arg("tow.sided", c("two.sided", "less", "greater")) # will fail
nearest_arg("tow.sided", c("two.sided", "less", "greater")) 
nearest_arg(c("two.sided", "less", "greater"), c("two.sided", "less", "greater"))
nearest_arg(c("two", "two", "ded", "ss", "ea"), c("two.sided", "less", "greater"))
</code></pre>

<hr>
<h2 id='nom.cc'>Association and Correlation</h2><span id='topic+nom.cc'></span><span id='topic+cc_coef'></span><span id='topic+cramer_vf'></span><span id='topic+cramer_coef'></span><span id='topic+kendall_corr'></span><span id='topic+spearman_corr'></span><span id='topic+rs_corr'></span><span id='topic+nom.cramer'></span><span id='topic+ord.spearman'></span><span id='topic+ord.kendall'></span>

<h3>Description</h3>

<p>Computation of the following association and correlation measures:
</p>

<ul>
<li> <p><code>nom.cc</code> (corrected) contingency coefficient
</p>
</li>
<li> <p><code>nom.cramer</code> Cramer's V or Phi
</p>
</li>
<li> <p><code>ord.spearman</code> Spearman's rank correlation
</p>
</li>
<li> <p><code>ord.kendall</code> Kendall's rank correlation
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>nom.cc(tab, correct = FALSE)

nom.cramer(tab, ...)

ord.spearman(tab, ...)

ord.kendall(tab, ...)

cc_coef(tab, correct = FALSE)

cramer_vf(tab, ...)

cramer_coef(tab, ...)

kendall_corr(tab, ...)

spearman_corr(tab, ...)

rs_corr(tab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nom.cc_+3A_tab">tab</code></td>
<td>
<p>table: contingency table with absolute frequencies</p>
</td></tr>
<tr><td><code id="nom.cc_+3A_correct">correct</code></td>
<td>
<p>logical: if a correction should be applied (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="nom.cc_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- matrix(round(10*runif(15)), ncol=5)
nom.cc(tab)
nom.cc(tab, correct=TRUE)
nom.cramer(tab)
ord.spearman(tab)
ord.kendall(tab)
</code></pre>

<hr>
<h2 id='nosanitize'>Sanitization</h2><span id='topic+nosanitize'></span>

<h3>Description</h3>

<p><code>nosanitize</code> makes no sanitization on the strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nosanitize(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nosanitize_+3A_str">str</code></td>
<td>
<p>character: vector to sanitize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sanitized character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nosanitize("Test")
</code></pre>

<hr>
<h2 id='now'>Current Time</h2><span id='topic+now'></span>

<h3>Description</h3>

<p>Returns a time stamp based on the current time. <code>now</code> basically calls
<code>gsub('.', '', sprintf('%.20f', as.numeric(Sys.time())), fixed=TRUE)</code>.
To ensure that at each call a different time stamp is delivered <code>now</code>
may call <code>gsub(...)</code> several times until two different results are delivered.
The last one is then returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>now(last = 35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="now_+3A_last">last</code></td>
<td>
<p>integer: the amount of digits that should be returned (default: <code>35</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>now()   # returns all digits
now(3)  # returns only the first three digits
</code></pre>

<hr>
<h2 id='nsprintf'>sprintf with template depending on integer valued <code>n</code></h2><span id='topic+nsprintf'></span><span id='topic+round_de'></span><span id='topic+schoice_de'></span><span id='topic+print_de'></span>

<h3>Description</h3>

<p><code>nsprintf</code> creates a text dependent on the value(s) in <code>n</code>. In particular, we have
</p>

<ul>
<li> <p><code>round_de</code>, it returns either <code style="white-space: pre;">&#8288;Runden Sie Ihr Ergebnis auf eine ganze Zahl&#8288;</code>,
<code style="white-space: pre;">&#8288;Runden Sie Ihr Ergebnis auf eine Stelle nach dem Komma&#8288;</code>,  or
<code style="white-space: pre;">&#8288;Runden Sie Ihr Ergebnis auf n Stellen nach dem Komma&#8288;</code>
</p>
</li>
<li> <p><code>schoice_de</code> returns <code style="white-space: pre;">&#8288;Es kann eine oder mehrere Antworten richtig sein. Es ist ausreichend, eine richtige Antwort anzugeben. Geben Sie mehrere Antworten an und eine ist falsch, dann ist die Aufgabe falsch beantwortet&#8288;</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>nsprintf(n, ...)

round_de(n)

schoice_de()

print_de(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsprintf_+3A_n">n</code></td>
<td>
<p>integer: number(s) to be used</p>
</td></tr>
<tr><td><code id="nsprintf_+3A_...">...</code></td>
<td>
<p>character: format strings to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sprintf</code>ed strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsprintf(0, '0' = "keine Netzunterbrechung", '1' = "eine Netzunterbrechung", 
            "%i Netzunterbrechungen")
nsprintf(0:3, `0` = "keine Netzunterbrechung", `1` = "eine Netzunterbrechung", 
              "%i Netzunterbrechungen")
</code></pre>

<hr>
<h2 id='num_result'>Numeric Rounding List</h2><span id='topic+num_result'></span><span id='topic+num_res'></span><span id='topic+int_result'></span><span id='topic+int_res'></span>

<h3>Description</h3>

<p><code>num_result</code> creates a list with the following elements:
</p>

<ul>
<li> <p><code>x</code> the original values
</p>
</li>
<li> <p><code>fx</code> the rounded values with <code><a href="exams.html#topic+fmt">exams::fmt()</a></code> as a character
</p>
</li>
<li> <p><code>tolerance</code> the tolerance
</p>
</li>
<li> <p><code>digits</code> the digits used for rounding
</p>
</li></ul>

<p>Note that <code>x</code> may contain more than one numeric value to determine the rounding and tolerance.
Make sure that you use for numeric exercises <code>...$x[1]</code>.
</p>
<p>If <code>digits</code> are not given and <code>length(x)&gt;1</code> then <code>ceiling(-log10(min(diff(sort(x)), na.rm=TRUE)))</code> is used.
If <code>digits</code> are not given and <code>length(x)==1</code> then <code>3+ceiling(-log10(abs(x)))</code> is used.
If no <code>tolerance</code> is given then <code>tolmult*10^(1-digits)</code> is used.
</p>
<p><code>int_result</code> can be used if the result is an integer number and calls <code>num_result(x, 0, 0.1, 1, ...)</code> with
a tolerance of 0.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_result(x, digits = NULL, tolerance = NULL, tolmult = 2, ...)

int_result(x, ...)

num_res(x, digits = NULL, tolerance = NULL, tolmult = 2, ...)

int_res(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_result_+3A_x">x</code></td>
<td>
<p>numeric: rounded data</p>
</td></tr>
<tr><td><code id="num_result_+3A_digits">digits</code></td>
<td>
<p>numeric: number of digits of rounding (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="num_result_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric: tolerance for rounded data (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="num_result_+3A_tolmult">tolmult</code></td>
<td>
<p>numeric: multiplier for tolerance</p>
</td></tr>
<tr><td><code id="num_result_+3A_...">...</code></td>
<td>
<p>further parameters from <code><a href="exams.html#topic+fmt">exams::fmt()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># height for german man (in meter)
x &lt;- rnorm(10, mean=1.8, sd =0.25)
num_result(c(mean(x), x), digits=2)
int_result(mean(x))
#
str(num_result(pi, 3))
str(num_result(pi, 6))
str(num_result(pi, 6, tolmult=5))
str(num_result(pi, 6, tolmult=5, tolerance=1e-6))
</code></pre>

<hr>
<h2 id='num_solve'>Target Variable Value</h2><span id='topic+num_solve'></span><span id='topic+sequation'></span><span id='topic+toLatex.equation_solve'></span>

<h3>Description</h3>

<p>Given a set of equations and some variables, <code>num_solve</code> tries to compute the value of the <code>target</code> variable.
The equations <code class="reqn">y=f(x)</code> are transformed to <code class="reqn">f(x)-y</code> and the functions try to compute the roots of the equations
using [<code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code>].
If the computation fails, then, <code>numeric(0)</code> is returned, otherwise the &quot;original&quot; value. If <code>target==''</code> then all computed values
and steps are returned. The attribute <code>compute</code> contains a data frame.
</p>
<p><code>toLatex.equation_solve</code> returns a LaTeX representation of the solution way found by <code>num_solve()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_solve(target, eqs, tol = 1e-06)

## S3 method for class 'equation_solve'
toLatex(object, ...)

sequation(target, eqs, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_solve_+3A_target">target</code></td>
<td>
<p>character: name of the variable value to compute</p>
</td></tr>
<tr><td><code id="num_solve_+3A_eqs">eqs</code></td>
<td>
<p>an <code>equations</code> object</p>
</td></tr>
<tr><td><code id="num_solve_+3A_tol">tol</code></td>
<td>
<p>numeric: maximal tolerance for <code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code></p>
</td></tr>
<tr><td><code id="num_solve_+3A_object">object</code></td>
<td>
<p>object of a class for which a <code>toBibtex</code> or
<code>toLatex</code> method exists.</p>
</td></tr>
<tr><td><code id="num_solve_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(for <code>num_solve</code>) Returns <code>numeric(0)</code>, <code>numeric(1)</code>, or a list of all (computed) values.
</p>
<p>(For <code>toLatex.equation_solve</code>) A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The equations describe the formulae for an confidence interval of the mean
e &lt;- equations(o~x+c*s/sqrt(n), "v_o=\\bar{x}+c\\cdot\\frac{s^2}{n}", 
               u~x-c*s/sqrt(n), "v_u=\\bar{x}-c\\cdot\\frac{s^2}{n}", 
               e~c*s/sqrt(n),   "e  =c\\cdot\\frac{s^2}{\\sqrt{n}}",
               l~2*e,           "l  =2\\cdot e"                   
               )
e &lt;- variables(e, 
               x=0,    "\\bar{x}",
               c=2.58, dbl(2), 
               s=1,    pos(5), "s^2",
               n=25,   pos(5),
               l=pos(5), 
               e=pos(5),
               u="v_u", o="v_o")
print(e)
# Find the confidence interval length
ns &lt;- num_solve('l', e)
# Compute everything that is possible
 ns &lt;- num_solve('', e)
toLatex(ns)

</code></pre>

<hr>
<h2 id='num2str'>Number to String Conversion</h2><span id='topic+num2str'></span>

<h3>Description</h3>

<p>Converts a set of numeric variables to a list as string representation, either as decimal or as a fractional number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num2str(..., denom = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num2str_+3A_...">...</code></td>
<td>
<p>numeric variables</p>
</td></tr>
<tr><td><code id="num2str_+3A_denom">denom</code></td>
<td>
<p>integer: denominator for fractional number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1
l &lt;- num2str(x)         # returns in l$x the string representation
l &lt;- num2str(x, y=x+1)  # returns in l$x and l$y the string representations
</code></pre>

<hr>
<h2 id='pdensity'>Density Function</h2><span id='topic+pdensity'></span><span id='topic+sample_density'></span>

<h3>Description</h3>

<p>Creates a linear (<code>power=1</code>) or constant (<code>power=0</code>) density function in a interval </p>
<p style="text-align: center;"><code class="reqn">[a, b]</code>
</p>
<p> where
<code>a</code> and <code>b</code> are sampled from <code>x</code>. It samples <code>size</code> elements without replacement and computes
the value of the distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdensity(x, size = 3, power = 1, tol = 1e-06)

sample_density(x, size = 3, power = 1, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdensity_+3A_x">x</code></td>
<td>
<p>numeric: range of density with <code class="reqn">a=min(x, na.rm=TRUE)</code> and <code class="reqn">b=max(x, na.rm=TRUE)</code></p>
</td></tr>
<tr><td><code id="pdensity_+3A_size">size</code></td>
<td>
<p>numeric: number of elements to be sampled (without replacement) from x</p>
</td></tr>
<tr><td><code id="pdensity_+3A_power">power</code></td>
<td>
<p>numeric: constant or linear density function</p>
</td></tr>
<tr><td><code id="pdensity_+3A_tol">tol</code></td>
<td>
<p>numeric: disallow for density coefficients near zero (default: <code>1e-6</code>). A negative value will permit zero coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>a</code> the minimum of the interval
</p>
</li>
<li> <p><code>i</code> the maximum of the interval
</p>
</li>
<li> <p><code>x</code> the <code>size</code> sampled values
</p>
</li>
<li> <p><code>fx</code> the distribution function at <code>x</code>
</p>
</li>
<li> <p><code>pcoeff</code> a polynomial (intercept = first value)
</p>
</li>
<li> <p><code>qcoeff</code> indefinite integral of the polynomial (intercept = first value)
</p>
</li>
<li> <p><code>pint</code> result of the <code>integral(pcoeff, c(a,b), 0:2)</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pdensity(-5:5)
pdensity(-5:5, power=1)
</code></pre>

<hr>
<h2 id='pearson_data'>Pearson Data</h2><span id='topic+pearson_data'></span><span id='topic+dpearson'></span>

<h3>Description</h3>

<p>Generates an integer data set for computing a correlation using <code><a href="#topic+sumofsquares">sumofsquares()</a></code>.
If <code>n&gt;100</code> and <code>nmax&gt;6</code> it is better to use one of the precomputed solutions. Otherwise it may take
up to <code>maxt</code> seconds. Please note that the correlation of the generated data set may differ from the desired
correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pearson_data(r, n = 100, nmax = 6, maxt = 30, xsos = NULL, ysos = NULL)

dpearson(r, n = 100, nmax = 6, maxt = 30, xsos = NULL, ysos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pearson_data_+3A_r">r</code></td>
<td>
<p>numeric: desired correlation</p>
</td></tr>
<tr><td><code id="pearson_data_+3A_n">n</code></td>
<td>
<p>integer: number to decompose as sum of squares, see <code><a href="#topic+sumofsquares">sumofsquares()</a></code>.</p>
</td></tr>
<tr><td><code id="pearson_data_+3A_nmax">nmax</code></td>
<td>
<p>integer: maximal number of squares in the sum, see <code><a href="#topic+sumofsquares">sumofsquares()</a></code>.</p>
</td></tr>
<tr><td><code id="pearson_data_+3A_maxt">maxt</code></td>
<td>
<p>numeric: maximal number of seconds the routine should run, see <code><a href="#topic+sumofsquares">sumofsquares()</a></code>.</p>
</td></tr>
<tr><td><code id="pearson_data_+3A_xsos">xsos</code></td>
<td>
<p>sos matrix: precomputed matrix</p>
</td></tr>
<tr><td><code id="pearson_data_+3A_ysos">ysos</code></td>
<td>
<p>sos matrix: precomputed matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns and an attribute <code>interim</code> for intermediate values as matrix.
The rows of the matrix contain : <code class="reqn">x_i</code>, <code class="reqn">y_i</code>,  <code class="reqn">x_i-bar{x}</code>, <code class="reqn">y_i-\bar{y}</code>,
<code class="reqn">(x_i-bar{x})^2</code>, <code class="reqn">(y_i-\bar{y})^2</code>, and <code class="reqn">(x_i-bar{x})((y_i-\bar{y})</code>.
In a final step, a vector with the row of sums is appended as a further column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sos)
xy &lt;- pearson_data(0.7, xsos=sos100)
colSums(xy)
colSums(xy^2)
sum(xy[,1]*xy[,2])
# my data
x &lt;- 100+5*xy[,1]
y &lt;- 100+5*xy[,2]
cor(x, y)
</code></pre>

<hr>
<h2 id='pminimum'>Polynomial Minimum</h2><span id='topic+pminimum'></span><span id='topic+polynomial_minimum'></span>

<h3>Description</h3>

<p>Computes the minimum of a polynomial in the interval <code class="reqn">[lower, upper]</code>. The values and the interval borders of the
polynomial <code>p</code> are evaluated and the minimum value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pminimum(
  p,
  interval,
  lower = min(interval),
  upper = max(interval),
  tol = 1e-09
)

polynomial_minimum(
  p,
  interval,
  lower = min(interval),
  upper = max(interval),
  tol = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pminimum_+3A_p">p</code></td>
<td>
<p>polynomial</p>
</td></tr>
<tr><td><code id="pminimum_+3A_interval">interval</code></td>
<td>
<p>numeric:    a vector containing the end-points of the interval to be searched for the minimum</p>
</td></tr>
<tr><td><code id="pminimum_+3A_lower">lower</code></td>
<td>
<p>numeric: the lower end point of the interval to be searched (default: <code>min(interval)</code>)</p>
</td></tr>
<tr><td><code id="pminimum_+3A_upper">upper</code></td>
<td>
<p>numeric: the upper end point of the interval to be searched (default: <code>max(interval)</code>)</p>
</td></tr>
<tr><td><code id="pminimum_+3A_tol">tol</code></td>
<td>
<p>numeric: the desired accuracy (default: <code>1e-9</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimal function value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- polynomial(c(-5, 3, -3, 1))
pminimum(p, -3, 3)
</code></pre>

<hr>
<h2 id='pos'>Interval Ranges</h2><span id='topic+pos'></span><span id='topic+dbl'></span><span id='topic+idbl'></span><span id='topic+ipos'></span><span id='topic+neg'></span><span id='topic+ineg'></span>

<h3>Description</h3>

<p>Generates intervals based on powers of ten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos(pow)

neg(pow)

dbl(pow)

idbl(pow)

ipos(pow)

ineg(pow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_+3A_pow">pow</code></td>
<td>
<p>numeric: power of ten to create intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbl(2)
dbl(3)
pos(3)
neg(3)
</code></pre>

<hr>
<h2 id='pprobability'>Polynomial Probability</h2><span id='topic+pprobability'></span><span id='topic+polynomial_probability'></span>

<h3>Description</h3>

<p>Creates for each value of a discrete random variable, a polynomial and estimates the least squares and the maximum likelihood solution.
The following conditions stand:
</p>

<ul>
<li><p> If <code>sample</code> is not given then the sample contains each <code>x</code> value once.
</p>
</li>
<li><p> If <code>sample</code> is an integer, then it is interpreted as the sample size and a sample is generated by <code>rmultinom(1, sample, ddiscrete(runif(length(x))))</code>.
</p>
</li>
<li><p> If <code>sample</code> is a vector, it is interpreted in such a way that the corresponding <code>x[i]</code> value occurs <code>i</code> times in the sample. Thus, <code>sum(sample)</code> is the sample size.
</p>
</li>
<li><p> If <code>coeff</code> is a <code>polylist</code> of <code>length(x)</code>, then these polynomials are taken.
</p>
</li>
<li><p> If <code>coeff</code> is a <code>matrix</code> with <code>length(x)</code>, columns and <code>power+1</code> rows, then the columns are interpreted as the coefficients of a polynomial.
</p>
</li>
<li><p> Otherwise <code>coeff</code> is interpreted as a vector from which the coefficient is sampled. The intercepts are sampled via <code>ddiscrete(runif(length(x)), zero=zero)</code>.
If <code>coeff</code> is not given then it is ensured that the least squares and the maximum likelihood solution exists and the estimated probabilities are between zero and one.
Otherwise, the results may contain <code>NA</code> or the estimated probabilities are outside the interval <code class="reqn">[0;1]</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pprobability(
  x,
  power = 1,
  zero = FALSE,
  coef = round(seq(-1, 1, by = 0.1), 1),
  sample = rep(1, length(x)),
  pl = NULL,
  tol = 1e-09
)

polynomial_probability(
  x,
  power = 1,
  zero = FALSE,
  coef = round(seq(-1, 1, by = 0.1), 1),
  sample = rep(1, length(x)),
  pl = NULL,
  tol = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pprobability_+3A_x">x</code></td>
<td>
<p>numeric: values of a discrete random variable</p>
</td></tr>
<tr><td><code id="pprobability_+3A_power">power</code></td>
<td>
<p>integer: the degree for the polynomials (default: <code>1</code>), must be larger 0</p>
</td></tr>
<tr><td><code id="pprobability_+3A_zero">zero</code></td>
<td>
<p>logical: are zero coefficients and zero samples allowed? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="pprobability_+3A_coef">coef</code></td>
<td>
<p>matrix: for each degree coefficients to sample from (default: <code>seq(-1, 1, by=0.1)</code>)</p>
</td></tr>
<tr><td><code id="pprobability_+3A_sample">sample</code></td>
<td>
<p>integer: number of <code class="reqn">x</code> values in the sample or sample size (default: <code>rep(1, length(x))</code>)</p>
</td></tr>
<tr><td><code id="pprobability_+3A_pl">pl</code></td>
<td>
<p>polylist: a list of polynomials which describes the probability for <code class="reqn">x</code> (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="pprobability_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance to detect zero values (default: <code>1e-9</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li> <p><code>p</code>: the polynomials for the probabilities
</p>
</li>
<li> <p><code>ep</code>: the expected value as polynomial
</p>
</li>
<li> <p><code>x</code>: the values for the discrete random variable, the same as the input <code>x</code>
</p>
</li>
<li> <p><code>sample</code>: the sample given or generated
</p>
</li>
<li> <p><code>LS$pi</code>: the summands for the least squares problem
</p>
</li>
<li> <p><code>LS$pl</code>: the summands for the least squares problem in LaTeX
</p>
</li>
<li> <p><code>LS$pf</code>: the sum of <code>LS$pi</code>
</p>
</li>
<li> <p><code>LS$df</code>: the derivative of <code>LS$pf</code>
</p>
</li>
<li> <p><code>LS$pest</code>: the estimated parameter, minimum of <code>LS$pf</code>
</p>
</li>
<li> <p><code>LS$p</code>: the estimated probabilities
</p>
</li>
<li> <p><code>ML$pi</code>: the factors for the maximum likelihood problem
</p>
</li>
<li> <p><code>ML$pl</code>: the summands for the maximum likelihood problem in LaTeX
</p>
</li>
<li> <p><code>ML$pf</code>: the product of <code>ML$pi</code>
</p>
</li>
<li> <p><code>ML$df</code>: the derivative of <code>ML$pf</code>
</p>
</li>
<li> <p><code>ML$pest</code>: the estimated parameter, maximum of <code>ML$pf</code>
</p>
</li>
<li> <p><code>ML$p</code>: the estimated probabilities
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># linear polynomials
pprobability(0:2)
pprobability(0:2, power=1)
# constant polynomials, some NAs are generated
pprobability(0:3, power=0)
# polynomials generated from a different set
pprobability(0:2, coef=seq(-2, 2, by=0.1))
pprobability(0:2, 0, coef=seq(-2, 2, by=0.1))
# polynomials (x, x, 1-2*x) are used
pprobability(0:2, 0, coef=matrix(c(0.4, 0.4, 0.3), ncol=3))
pprobability(0:2, 1, coef=polylist(c(0,1), c(0,1), c(1, -2)))
</code></pre>

<hr>
<h2 id='print.equations'>print.equations</h2><span id='topic+print.equations'></span>

<h3>Description</h3>

<p>Prints an <code>equations</code> object with equations and variables. Internally, a data frame is generated, created and printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equations'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.equations_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.equations_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame invisibly generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The equations describe the formulae for an confidence interval of the mean
e &lt;- equations(o~x+c*s/sqrt(n), "v_o=\\bar{x}+c\\cdot\\frac{s^2}{n}", 
               u~x-c*s/sqrt(n), "v_u=\\bar{x}-c\\cdot\\frac{s^2}{n}", 
               e~c*s/sqrt(n),   "e  =c\\cdot\\frac{s^2}{\\sqrt{n}}",
               l~2*e,           "l  =2\\cdot e"                   
               )
print(e)
</code></pre>

<hr>
<h2 id='print.html_matrix'>Print <code>html_matrix</code></h2><span id='topic+print.html_matrix'></span>

<h3>Description</h3>

<p>Prints an HTML matrix content or its components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'html_matrix'
print(x, ..., which = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.html_matrix_+3A_x">x</code></td>
<td>
<p>an html_matrix object</p>
</td></tr>
<tr><td><code id="print.html_matrix_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="print.html_matrix_+3A_which">which</code></td>
<td>
<p>character: which component to print (default: <code>""</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible character matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:6, ncol=2)
l &lt;- html_matrix_sk(m, title="1 to 6", fmt=rep("%f",ncol(m)))
print(l, which=NA)      # returns full style information
print(l, which="fmt")   # returns format information
print(l, which="value") # identical to print(l)
</code></pre>

<hr>
<h2 id='prob_solve'>Total or Conditional Probability Computation</h2><span id='topic+prob_solve'></span><span id='topic+latex_prob'></span><span id='topic+probability_solution'></span><span id='topic+sprob'></span><span id='topic+prob_solve.default'></span><span id='topic+lprob'></span><span id='topic+toLatex.prob_solve'></span><span id='topic+print.prob_solve'></span>

<h3>Description</h3>

<p>The following functions are available:
</p>

<ul>
<li> <p><code>prob_solve</code> given a set of events it computes the total or conditional probability of the given event or
<code>NA</code> if no solution could be found. For the naming of the events upper case letters must be used and
the available operators are <code>!</code> (complementary event), <code>|</code> (conditional event), and <code>^</code> (intersection of events).
The attribute <code>latex</code> of the return value contains the necessary computation steps for computation of the given event.
If <code>getprob</code> is <code>TRUE</code> then additionally the attribute <code>prob</code>, a vector with all computed probabilities, and <code>compute</code>,
which includes all computational steps, are generated.
</p>
</li>
<li> <p><code>print</code> shows the solution way in ASCII.
</p>
</li>
<li> <p><code>toLatex</code> shows the solution way in LaTeX/MathJax with an <code>align</code> environment.
</p>
</li>
<li> <p><code>lprob</code> converts <code>!A</code> to <code style="white-space: pre;">&#8288;\\bar{A}&#8288;</code> and <code>A^B</code> to <code style="white-space: pre;">&#8288;A \\cap B&#8288;</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prob_solve(target, ...)

## Default S3 method:
prob_solve(target, ..., partition = NULL, getprob = FALSE, quiet = TRUE)

lprob(txt)

## S3 method for class 'prob_solve'
toLatex(object, ...)

## S3 method for class 'prob_solve'
print(x, type = c("numeric", "latex", "prob", "compute"), ...)

latex_prob(txt)

probability_solution(target, ...)

sprob(target, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_solve_+3A_target">target</code></td>
<td>
<p>character: target event</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_...">...</code></td>
<td>
<p>numeric: named events with given probabilities</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_partition">partition</code></td>
<td>
<p>character or list: set of events which form a partition</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_getprob">getprob</code></td>
<td>
<p>logical: return all computed probabilities and used computation steps (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_quiet">quiet</code></td>
<td>
<p>logical: show all computation steps (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_txt">txt</code></td>
<td>
<p>character: vector to convert <code>!</code> to <code style="white-space: pre;">&#8288;\\bar&#8288;</code> and <code>^</code> to &lsquo;\cap&rsquo;</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_object">object</code>, <code id="prob_solve_+3A_x">x</code></td>
<td>
<p><code>prob_solve</code> object</p>
</td></tr>
<tr><td><code id="prob_solve_+3A_type">type</code></td>
<td>
<p>character: what to print, either <code>numeric</code> (solution, default), <code>latex</code> (solution steps in ASCII format),
<code>prob</code> (optional: all probabilities computed), or <code>compute</code> (optional: all rules used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program applies iteratively the following rules to find a solution:
</p>

<ul>
<li> <p><code class="reqn">P(A) = 1-P(!A)</code>,
</p>
</li>
<li> <p><code class="reqn">P(A|B) = 1-P(!A|B)</code>,
</p>
</li>
<li> <p><code class="reqn">P(A^B) = P(B^A)</code>,
</p>
</li>
<li> <p><code class="reqn">P(B) = P(A^B)+P(!A^B)</code>,
</p>
</li>
<li> <p><code class="reqn">P(A|B) = P(A^B)/P(B)</code>, and
</p>
</li>
<li> <p><code class="reqn">P(A) = P(A|P1)+P(A|P2)+...+ P(A|Pn)</code> for a partition <code class="reqn">P1, P2, ..., Pn</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the class <code>prob_solve</code> with the resulting probability, including the steps for computing.
If <code>NA</code> is returned then no solution could be found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_solve("!A", "A"=0.3)
prob_solve("!A|B", "A|B"=0.3)
prob_solve("B^A", "A^B"=0.3)
# P(B)   = P(A^B)+P(!A^B)
prob_solve("B", "A^B"=0.3, "!A^B"= 0.4)
prob_solve("A^B", "B"=0.7, "!A^B"= 0.4)
prob_solve("!A^B", "B"=0.7, "A^B"= 0.3)
# P(A|B) = P(A^B)/P(B)
prob_solve("A|B", "A^B"=0.3, "B"= 0.6)
prob_solve("A^B", "B"=0.6, "A|B"= 0.5)
prob_solve("B", "A|B"=0.5, "A^B"= 0.3)
#' latex, prob and compute attributes
pmt &lt;- prob_solve("M|T", "M"=0.6, "T|M"=0.75, "T|!M"=0.39, quiet=FALSE, getprob=TRUE)
toLatex(pmt)
attr(pmt, "latex")
pmt &lt;- prob_solve("M|T", "M"=0.6, "T|M"=0.75, "T|!M"=0.39, quiet=FALSE, getprob=TRUE)
attr(pmt, "prob")
print(pmt, "latex") 
print(pmt, "prob")    # only if getprob=TRUE   
print(pmt, "compute") # only if getprob=TRUE   
# bayes theorem and total probability
prob_solve("Z", "Z|A"=0.1, "Z|B"=0.2, "Z|C"=0.3, partition=c("A", "B", "C"))
prob_solve("Z|A", "Z"=0.6, "Z|B"=0.2, "Z|C"=0.3, partition=c("A", "B", "C"))
prob_solve('A|K', "A"=0.55, "B"=0.35, "C"=0.1, "K|A"=0.4, "K|B"=0.1, "K|C"=0.1, 
           partition=c("A", "B", "C"))
prob_solve('K', "A"=0.55, "B"=0.35, "C"=0.1, "K|A"=0.4, "K|B"=0.1, "K|C"=0.1, 
           partition=c("A", "B", "C"))
</code></pre>

<hr>
<h2 id='proptest_data'>Binomial Test Data Creation</h2><span id='topic+proptest_data'></span><span id='topic+prop_binomtest_data'></span><span id='topic+dbinomtest'></span>

<h3>Description</h3>

<p>Creates data for a binomial test based on the properties for the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proptest_data(
  size = 10:100,
  prob = seq(0.05, 0.45, by = 0.05),
  reject = TRUE,
  alternative = c("two.sided", "less", "greater"),
  alpha = c(0.01, 0.05, 0.1),
  norm.approx = NA,
  maxit = 1000
)

prop_binomtest_data(
  size = 10:100,
  prob = seq(0.05, 0.45, by = 0.05),
  reject = TRUE,
  alternative = c("two.sided", "less", "greater"),
  alpha = c(0.01, 0.05, 0.1),
  norm.approx = NA,
  maxit = 1000
)

dbinomtest(
  size = 10:100,
  prob = seq(0.05, 0.45, by = 0.05),
  reject = TRUE,
  alternative = c("two.sided", "less", "greater"),
  alpha = c(0.01, 0.05, 0.1),
  norm.approx = NA,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proptest_data_+3A_size">size</code></td>
<td>
<p>numeric: vector of sample sizes (default <code>10:100</code>)</p>
</td></tr>
<tr><td><code id="proptest_data_+3A_prob">prob</code></td>
<td>
<p>numeric: vector of probabilities for the hypothetical proportion <code class="reqn">\pi_0</code> (default <code>=seq(0.05, 0.45, by=0.05)</code>)</p>
</td></tr>
<tr><td><code id="proptest_data_+3A_reject">reject</code></td>
<td>
<p>logical: should <code>x</code> generate a lead for the rejection of the null hypothesis (default <code>TRUE</code>), if equals <code>NA</code> then this will be ignored</p>
</td></tr>
<tr><td><code id="proptest_data_+3A_alternative">alternative</code></td>
<td>
<p>character: a character string specifying the alternative hypothesis, must be one of <code>two.sided</code> (default), <code>greater</code> or <code>less</code></p>
</td></tr>
<tr><td><code id="proptest_data_+3A_alpha">alpha</code></td>
<td>
<p>numeric: vector of significance levels (default <code>c(0.01, 0.05, 0.1)</code>)</p>
</td></tr>
<tr><td><code id="proptest_data_+3A_norm.approx">norm.approx</code></td>
<td>
<p>logical: should a normal approximation be possible (<code class="reqn">size*prob*(1-prob)&gt;9</code>)</p>
</td></tr>
<tr><td><code id="proptest_data_+3A_maxit">maxit</code></td>
<td>
<p>integer: maximal numbers of trials to find a solution (default <code>1000</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li> <p><code>pi0</code> hypothetical proportion
</p>
</li>
<li> <p><code>x</code> counts of successes in the sample
</p>
</li>
<li> <p><code>n</code> sample size
</p>
</li>
<li> <p><code>alpha</code> significance level
</p>
</li>
<li> <p><code>alternative</code> specifying the alternative hypothesis (either <code>two.sided</code>, <code>greater</code> or <code>less</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>proptest_data()
</code></pre>

<hr>
<h2 id='proptest_num'>Proportion Tests</h2><span id='topic+proptest_num'></span><span id='topic+prop_binomtest_num'></span><span id='topic+nbinomtest'></span>

<h3>Description</h3>

<p>Computes all results for test on proportion using either <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>, or
a normal approximation without continuity correction.
Either named parameters can be given or an <code>arglist</code> with the following parameters:
</p>

<ul>
<li> <p><code>x</code> number of successes
</p>
</li>
<li> <p><code>n</code> sample size (default: <code>sd(x)</code>)
</p>
</li>
<li> <p><code>pi0</code> true value of the proportion (default: <code>0.5</code>)
</p>
</li>
<li> <p><code>alternative</code> a string specifying the alternative hypothesis (default: <code>"two.sided"</code>), otherwise <code>"greater"</code> or <code>"less"</code> can be used
</p>
</li>
<li> <p><code>alpha</code> significance level (default: <code>0.05</code>)
</p>
</li>
<li> <p><code>binom2norm</code> can the binomial distribution be approximated by a normal distribution? (default: <code>NA</code> = use <code>binom2norm</code> function)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>proptest_num(..., arglist = NULL)

prop_binomtest_num(..., arglist = NULL)

nbinomtest(..., arglist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proptest_num_+3A_...">...</code></td>
<td>
<p>named input parameters</p>
</td></tr>
<tr><td><code id="proptest_num_+3A_arglist">arglist</code></td>
<td>
<p>list: named input parameters, if given <code>...</code> will be ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of <code>proptest_num</code> may differ from <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>. <code>proptest_num</code> is designed to return results
when you compute a binomial test by hand. For example, for computing the test statistic the approximation <code class="reqn">t_n \approx N(0; 1)</code>
is used if <code class="reqn">n&gt;n.tapprox</code>. The <code>p.value</code> is computed by <a href="stats.html#topic+binom.test">stats::binom.test</a> and may not be reliable, for Details see Note!
</p>


<h3>Value</h3>

<p>A list with the input parameters and the following:
</p>

<ul>
<li> <p><code>X</code> distribution of the random sampling function
</p>
</li>
<li> <p><code>Statistic</code> distribution of the test statistics
</p>
</li>
<li> <p><code>statistic</code> test value
</p>
</li>
<li> <p><code>critical</code> critical value(s)
</p>
</li>
<li> <p><code>criticalx</code> critical value(s) in x range
</p>
</li>
<li> <p><code>acceptance0</code> acceptance interval for H0
</p>
</li>
<li> <p><code>acceptance0x</code> acceptance interval for H0 in x range
</p>
</li>
<li> <p><code>accept1</code> is H1 accepted?
</p>
</li>
<li> <p><code>p.value</code> p value for test (note: the p-value may not be reliable see Notes!)
</p>
</li>
<li> <p><code>alphaexact</code> exact significance level
</p>
</li>
<li> <p><code>stderr</code> standard error of the proportion used as denominator
</p>
</li></ul>



<h3>Note</h3>

<p>The computation of a p-value for non-symmetric distribution is not well defined, see <a href="https://stats.stackexchange.com/questions/140107/p-value-in-a-two-tail-test-with-asymmetric-null-distribution">https://stats.stackexchange.com/questions/140107/p-value-in-a-two-tail-test-with-asymmetric-null-distribution</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- sum(runif(n)&lt;0.4)
proptest_num(x=x, n=n)
</code></pre>

<hr>
<h2 id='proptests'>Proportion Tests</h2><span id='topic+proptests'></span>

<h3>Description</h3>

<p><code>proptests</code> runs a bunch of modifications of the input parameters of <code>proptest</code> to generate all possible proportion tests.
See under &quot;Details&quot; the detailed parameter values which are used. Note that not giving the parameter <code>hyperloop</code> will
results in several hundred tests generated.
Only the distinct tests will be returned, with the first element being <code>proptest</code>. If only a specific element of a <code>proptests</code> is of interest,
provide the name of the element in <code>elem</code>. All <code>proptests</code> will then be returned where the value of <code>elem</code> is different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proptests(proptest, elem = NULL, hyperloop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proptests_+3A_proptest">proptest</code></td>
<td>
<p>proptest: the base result from a valid t-test generated by <code><a href="#topic+proptest_num">proptest_num()</a></code></p>
</td></tr>
<tr><td><code id="proptests_+3A_elem">elem</code></td>
<td>
<p>character: element to extract (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="proptests_+3A_hyperloop">hyperloop</code></td>
<td>
<p>named list: parameter values to run over (default: see above)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>hyperloop</code> is:
</p>
<div class="sourceCode"><pre>list(x           = c(proptest$x, proptest$n-proptest$x)
     pi0         = c(proptest$pi0, 1-proptest$pi0, proptest$x/proptest$n, 1-proptest$x/proptest$n)
     alpha       = unique(c(proptest$alpha, 0.01, 0.05, 0.1)),
     alternative = c("two.sided", "greater", "less")
   )
</pre></div>


<h3>Value</h3>

<p>list of <code>proptest</code> objects is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basetest  &lt;- proptest_num(x=3, n=8, alternative="greater")
# vary the number of observations
hyperloop &lt;- list(pi0 = c(basetest$pi0, 1-basetest$pi0, 
                          basetest$x/basetest$n, 1-basetest$x/basetest$n))
# return all different tests
tts       &lt;- proptests(basetest, hyperloop=hyperloop)
# return all different random sampling functions
proptests(basetest, "X", hyperloop)
</code></pre>

<hr>
<h2 id='q2norm'>Mean and Standard Deviation for Normal Distribution</h2><span id='topic+q2norm'></span>

<h3>Description</h3>

<p>Given two (or more) quantiles it computes an (approximate) mean and standard deviation for a corresponding normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q2norm(x, probs = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q2norm_+3A_x">x</code></td>
<td>
<p>numeric(2): the quantiles</p>
</td></tr>
<tr><td><code id="q2norm_+3A_probs">probs</code></td>
<td>
<p>numeric(2): probabilities with values in <code class="reqn">[0,1]</code> (default: <code>c(0.025, 0.975)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a component <code>mean</code> and <code>sd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q2norm(c(100,200))
</code></pre>

<hr>
<h2 id='random'>Random</h2><span id='topic+random'></span><span id='topic+rand'></span>

<h3>Description</h3>

<p>Returns a index from <code>1:length(v)</code> randomly ordered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(v)

rand(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_v">v</code></td>
<td>
<p>vector: vector with elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random(-3:3)
</code></pre>

<hr>
<h2 id='refer'>Generate Vector Element Names</h2><span id='topic+refer'></span><span id='topic+refer2vector'></span>

<h3>Description</h3>

<p>Creates names for elements of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refer(x, fmt = "%s_{%.0f}", to = deparse(substitute(x)), index = 1:length(x))

refer2vector(
  x,
  fmt = "%s_{%.0f}",
  to = deparse(substitute(x)),
  index = 1:length(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refer_+3A_x">x</code></td>
<td>
<p>vector: a vector to create the names for</p>
</td></tr>
<tr><td><code id="refer_+3A_fmt">fmt</code></td>
<td>
<p>character: format string for <code>sprintf</code> (default: <code>"%s_{%.0f}"</code></p>
</td></tr>
<tr><td><code id="refer_+3A_to">to</code></td>
<td>
<p>character: base name of elements</p>
</td></tr>
<tr><td><code id="refer_+3A_index">index</code></td>
<td>
<p>numeric: vector with indices  (default: <code>1:length(x)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
refer(x)                  # LaTeX default
refer(x, fmt="%s[%.0f]")  # R default
</code></pre>

<hr>
<h2 id='replace_fmt'>Replace</h2><span id='topic+replace_fmt'></span>

<h3>Description</h3>

<p>In a text it replaces names with:
</p>

<ul>
<li><p> values which are formatted with <code><a href="exams.html#topic+fmt">exams::fmt()</a></code>, or
</p>
</li>
<li><p> strings
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>replace_fmt(txt, digits = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_fmt_+3A_txt">txt</code></td>
<td>
<p>character: text where the replacement is done</p>
</td></tr>
<tr><td><code id="replace_fmt_+3A_digits">digits</code></td>
<td>
<p>numeric or list: number of digits to round</p>
</td></tr>
<tr><td><code id="replace_fmt_+3A_...">...</code></td>
<td>
<p>names to replace with values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character with replaced names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replace_fmt("\\frac{x}{y}", x=2, y=3)
replace_fmt("\\frac{x}{y}", x=2, y=3, digits=0)
replace_fmt("\\frac{x}{y}", x=2, y=3, digits=list(0))
replace_fmt("\\frac{x}{y}", x=2, y=3, digits=list(2, y=0))
replace_fmt("\\frac{x}{y}", x="\\\\sum_{i=1}^n x_i", y="\\\\sum_{i=1}^n y_i")
</code></pre>

<hr>
<h2 id='rv'>Random Variable</h2><span id='topic+rv'></span><span id='topic+rmdFormatRV+2C'></span><span id='topic+lrv'></span><span id='topic+rmdFormatRV'></span>

<h3>Description</h3>

<p>Formats a random variable and its meaning for R Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rv(symbol, explanation)

rmdFormatRV(symbol, explanation)

lrv(symbol, explanation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rv_+3A_symbol">symbol</code></td>
<td>
<p>character: symbol</p>
</td></tr>
<tr><td><code id="rv_+3A_explanation">explanation</code></td>
<td>
<p>character: meaning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rv("X", "Waiting time in minutes until next event")
</code></pre>

<hr>
<h2 id='sample_size_freq'>Sample Size Consistency Checker</h2><span id='topic+sample_size_freq'></span><span id='topic+dnsizefreq'></span>

<h3>Description</h3>

<p>Checks if a vector of possible sample sizes and relative frequencies create integer absolute frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_size_freq(n, f, which = NA)

dnsizefreq(n, f, which = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_size_freq_+3A_n">n</code></td>
<td>
<p>numeric: vector of sample size(s) to check</p>
</td></tr>
<tr><td><code id="sample_size_freq_+3A_f">f</code></td>
<td>
<p>numeric: vector of relative frequencies</p>
</td></tr>
<tr><td><code id="sample_size_freq_+3A_which">which</code></td>
<td>
<p>numeric: if several <code>n</code>'s are possible then <code>which</code> is returned (default: <code>NA</code> = choose a random one)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- ddiscrete(runif(5), unit=100)
sample_size_freq(seq(10, 200, 1), f)
sample_size_freq(seq(10, 200, 1), f, which=200)
</code></pre>

<hr>
<h2 id='scale_to'>Rescaling</h2><span id='topic+scale_to'></span>

<h3>Description</h3>

<p>Rescales <code>x</code> such that for the rescaled data it holds: <code>mean(scale_to(x, mean=target))==target</code> and
<code>sd(scale_to(x, sd=target)==abs(target)</code>. A negative value of <code>sd</code> will change the sign of the <code>x</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_to(x, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_to_+3A_x">x</code></td>
<td>
<p>numeric: vector of values</p>
</td></tr>
<tr><td><code id="scale_to_+3A_mean">mean</code></td>
<td>
<p>numeric: mean of the rescaled <code>x</code> (default: <code>0</code>)</p>
</td></tr>
<tr><td><code id="scale_to_+3A_sd">sd</code></td>
<td>
<p>numeric: standard deviation of the transformed <code>x</code> (default: <code>1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rescaled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(50)
y &lt;- scale_to(x, mean=0.1, sd=0.2)
mean(y)
sd(y)
y &lt;- scale_to(x, mean=0.1, sd=-0.2)
mean(y)
sd(y)
</code></pre>

<hr>
<h2 id='skalenniveau'>Skalenniveau</h2><span id='topic+skalenniveau'></span>

<h3>Description</h3>

<p>A data frame with the variables and level of measurement type. The names are in German.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(skalenniveau)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns <code>var</code>, and <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skalenniveau)
head(skalenniveau)
</code></pre>

<hr>
<h2 id='solution'>Solutions</h2><span id='topic+solution'></span><span id='topic+sol_num'></span><span id='topic+sol_int'></span><span id='topic+sol_mc'></span><span id='topic+sol_info'></span><span id='topic+sol_mc_ans'></span><span id='topic+sol_meta'></span><span id='topic+sol_mc_tf'></span><span id='topic+solution.default'></span><span id='topic+sol_ans'></span><span id='topic+sol_tf'></span>

<h3>Description</h3>

<p>Creates a <code>solution</code> object and prints a meta information block for the following:
</p>

<ul>
<li> <p><code>solution</code> the default is <code>sol_num</code>
</p>
</li>
<li> <p><code>sol_num</code> for a numerical solution
</p>
</li>
<li> <p><code>sol_int</code> for an integer solution
</p>
</li>
<li> <p><code>sol_mc</code> for a multiple choice solution
</p>
</li>
<li> <p><code>sol_ans</code> for the answer list of a multiple choice solution
</p>
</li>
<li> <p><code>sol_tf</code> for the solution list (True or False) of a multiple choice solution
</p>
</li>
<li> <p><code>sol_info</code> for creating a Meta-Information block
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>solution(x, ...)

## Default S3 method:
solution(x, ...)

sol_int(x, tol = NA, digits = NA)

sol_num(x, tol = NA, digits = NA)

sol_mc(x, y, sample = NULL, shuffle = order, none = NULL)

sol_ans(x, ...)

sol_tf(x, ...)

sol_info(x, ...)

sol_mc_ans(x, ...)

sol_meta(x, ...)

sol_mc_tf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solution_+3A_x">x</code></td>
<td>
<p>numeric solution or false MC solutions</p>
</td></tr>
<tr><td><code id="solution_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="solution_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance for a numeric solution (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="solution_+3A_digits">digits</code></td>
<td>
<p>integer: number of digits for rounding (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="solution_+3A_y">y</code></td>
<td>
<p>true MC solutions</p>
</td></tr>
<tr><td><code id="solution_+3A_sample">sample</code></td>
<td>
<p>integer: sampling numbers for false and/or true solutions (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="solution_+3A_shuffle">shuffle</code></td>
<td>
<p>logical or function: shuffling or ordering of solutions (default <code>order</code>)</p>
</td></tr>
<tr><td><code id="solution_+3A_none">none</code></td>
<td>
<p>character: if you do not wish to choose any of the false and/or true solutions offered (default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numerical solutions you can set <code>tol</code> and/or <code>digits</code>.
If they are not set, they are automatically selected.
If <code>tol</code> is not set and <code>length(x)&gt;1</code> then the tolerance is chosen as <code>min(diff(sort(x)))/2</code>.
Otherwise, as <code>max(0.001, 0.001*abs(x))</code>. I
If <code>tol</code> is negative, <code>tolerance</code> is set to <code>10^tol</code>, otherwise it is used as it is.
If <code>digits</code> is not set, <code>ceiling(-log10(tolerance))</code> is used.
</p>


<h3>Value</h3>

<p>A <code>solution</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- sol_num(pi)
sol_info(s)
# set same tolerances, e.g. for a probability
sol_num(0.1)
sol_num(0.1, tol=0.001)
sol_num(0.1, tol=-3)
# MC: Which are prime numbers?
prime &lt;- c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
nonprime &lt;- setdiff(2:30, prime)
# choose five false and two correct solutions
s &lt;- sol_mc(nonprime, prime, sample=c(5,2), none="There are no prime numbers in the list")  
sol_ans(s)
sol_tf(s)
sol_info(s)
</code></pre>

<hr>
<h2 id='sos100'>Precomputed Sum of Squared Data</h2><span id='topic+sos100'></span><span id='topic+sos200'></span><span id='topic+sos400'></span><span id='topic+sos800'></span><span id='topic+sos1000'></span>

<h3>Description</h3>

<p>Five data matrices with precomputed results from <code>sumofsquares(n, 10, zerosum=TRUE, maxt=Inf)</code> for
<code>n=100</code>, <code>n=200</code>, <code>n=400</code>,<code>n=800</code>, and <code>n=1000</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sos)

sos200

sos400

sos800

sos1000
</code></pre>


<h3>Format</h3>

<p>For each line of a matrix it holds <code class="reqn">\sum_{i=1}^k x_i^2=n</code> and <code class="reqn">\sum_{i=1}^k x_i=0</code>.
It contains all integer solutions up to <code>k&lt;=10</code>. <code>NA</code> means that this entry is not used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sos)
head(sos100)
rowSums(sos100^2, na.rm=TRUE)
rowSums(sos100, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='spell'>RMarkdown Spell Check</h2><span id='topic+spell'></span><span id='topic+rm_spell_check'></span>

<h3>Description</h3>

<p>Performs a spell check on RMarkdown files ignoring some <code>exams</code> keywords using <code><a href="spelling.html#topic+spell_check_files">spelling::spell_check_files()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spell(
  path,
  ignore = c("Meta", "information", "extype", "num", "mchoice", "schoice", "Solution",
    "exsolution", "extol", "exname", "Question", "align", "begin", "bigg", "cases",
    "cdot", "end", "frac", "infty", "int", "left", "left.", "leq", "mu", "qquad",
    "right", "sum", "text", "vert"),
  lang = Sys.getenv("LANG")
)

rm_spell_check(
  path,
  ignore = c("Meta", "information", "extype", "num", "mchoice", "schoice", "Solution",
    "exsolution", "extol", "exname", "Question", "align", "begin", "bigg", "cases",
    "cdot", "end", "frac", "infty", "int", "left", "left.", "leq", "mu", "qquad",
    "right", "sum", "text", "vert"),
  lang = Sys.getenv("LANG")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spell_+3A_path">path</code></td>
<td>
<p>path to file or to spell check</p>
</td></tr>
<tr><td><code id="spell_+3A_ignore">ignore</code></td>
<td>
<p>character vector with words which will be added to the <a href="hunspell.html#topic+hunspell">hunspell::dictionary</a></p>
</td></tr>
<tr><td><code id="spell_+3A_lang">lang</code></td>
<td>
<p>set <code>Language</code> field in <code>DESCRIPTION</code> e.g. <code>"en-US"</code> or <code>"en-GB"</code>.
For supporting other languages, see the <a href="https://docs.ropensci.org/hunspell/articles/intro.html#hunspell-dictionaries">hunspell vignette</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with problematic words.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># none
</code></pre>

<hr>
<h2 id='sqrtnp'>Calculating Square Roots of n<em>p</em>(1-p) Combinations</h2><span id='topic+sqrtnp'></span>

<h3>Description</h3>

<p>Computes <code>sqrt(n*p*(1-p))</code> for all combinations of <code>n</code> and <code>p</code>.
If the result has only <code>digits</code> after the decimal point, then <code>n</code>, <code>p</code>,
and <code>sqrt(n*p*(1-p))</code> are returned in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrtnp(n, p, digits = 2, tol = 10^(-digits - 4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrtnp_+3A_n">n</code></td>
<td>
<p>numeric: vector of observations numbers</p>
</td></tr>
<tr><td><code id="sqrtnp_+3A_p">p</code></td>
<td>
<p>numeric: vector of probabilities</p>
</td></tr>
<tr><td><code id="sqrtnp_+3A_digits">digits</code></td>
<td>
<p>numeric: number of digits to check (default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="sqrtnp_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance (default: <code>10^(-digits-4)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>abs(v-round(v, digits))&lt;tol</code> then a number <code>v</code> is considered as a number
with only <code>digits</code> after the decimal point.
</p>


<h3>Value</h3>

<p>A data frame with the columns <code>n</code>, <code>p</code>, <code>np</code> (<code class="reqn">=np</code>) and <code>snp</code> (<code class="reqn">=sqrt(np(1-p))</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30:250
p &lt;- (10:40)/100
sqrtnp(n, p)
</code></pre>

<hr>
<h2 id='sumofsquares'>Sum of Squared Integers</h2><span id='topic+sumofsquares'></span><span id='topic+sum_sq'></span>

<h3>Description</h3>

<p>Decomposes an integer <code>n</code> into a sum of squared integers (<code class="reqn">n = \sum_{i=1}^k x_i^2</code>; <code class="reqn">1\leq x_i &lt;n</code>)
with <code class="reqn">k\leq nmax</code>.
If <code>zerosum</code> is true then it is ensured that <code class="reqn">\sum_{i=1}^k c_i x_i = 0</code> with <code class="reqn">c_i=-1</code> or <code class="reqn">c_i=+1</code>.
The computation of the <code class="reqn">x_i</code>'s is limited by <code>maxt</code> seconds, which may result that not all possible
solutions are found. To reduce computing time, <code>rbind</code>'s in the function are replaced by allocating
matrices with <code>size</code> rows to fill in the results.
Note that the following data sets are available:
</p>

<ul>
<li> <p><code>sos100=sumofsquares(100, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos200=sumofsquares(200, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos400=sumofsquares(400, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos800=sumofsquares(800, 10, zerosum=TRUE, maxt=Inf)</code>, and
</p>
</li>
<li> <p><code>sos1000=sumofsquares(100, 10, zerosum=TRUE, maxt=Inf)</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sumofsquares(n, nmax = 10, zerosum = FALSE, maxt = 30, size = 100000L)

sum_sq(n, nmax = 10, zerosum = FALSE, maxt = 30, size = 100000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumofsquares_+3A_n">n</code></td>
<td>
<p>integer: number to decompose as sum of squares</p>
</td></tr>
<tr><td><code id="sumofsquares_+3A_nmax">nmax</code></td>
<td>
<p>integer: maximum number of squares in the sum</p>
</td></tr>
<tr><td><code id="sumofsquares_+3A_zerosum">zerosum</code></td>
<td>
<p>logical: should the solution sum up to one (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sumofsquares_+3A_maxt">maxt</code></td>
<td>
<p>numeric: maximal number of seconds the routine should run</p>
</td></tr>
<tr><td><code id="sumofsquares_+3A_size">size</code></td>
<td>
<p>numeric: length of additional matrix size (default: <code>100000L</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>nmax</code> column with <code class="reqn">x_i</code>'s. <code>NA</code> means number has not been used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sos &lt;- sumofsquares(100, 6) # 23 solutions
head(sos)
table(rowSums(!is.na(sos))) 
# one solution with one or two x_i
# five solutions with four x_i
# six solutions with five x_i
# ten solutions with six x_i
rowSums(sos^2, na.rm=TRUE)  # all 100
sos &lt;- sumofsquares(100, 6, zerosum=TRUE)
head(sos)
rowSums(sos^2, na.rm=TRUE)  # all 100
rowSums(sos, na.rm=TRUE)    # all 0 
</code></pre>

<hr>
<h2 id='sumofsquares1'>sumofsquares1</h2><span id='topic+sumofsquares1'></span>

<h3>Description</h3>

<p>Decomposes an integer <code>n2</code> into a sum of squared integers (<code class="reqn">n2 = \sum_{i=1}^{nobs} x_i^2</code>).
If <code>n</code> is not <code>NA</code> then it is ensured that <code class="reqn">\sum_{i=1}^{nobs} x_i = 0</code>.
Note if <code>nobs&lt;=10</code> then the following data sets are available:
</p>

<ul>
<li> <p><code>sos100=sumofsquares(100, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos200=sumofsquares(200, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos400=sumofsquares(400, 10, zerosum=TRUE, maxt=Inf)</code>,
</p>
</li>
<li> <p><code>sos800=sumofsquares(800, 10, zerosum=TRUE, maxt=Inf)</code>, and
</p>
</li>
<li> <p><code>sos1000=sumofsquares(100, 10, zerosum=TRUE, maxt=Inf)</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sumofsquares1(n2, nobs = 10, n = 0, x = runif(nobs), maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumofsquares1_+3A_n2">n2</code></td>
<td>
<p>integer: number to decompose as sum of squares</p>
</td></tr>
<tr><td><code id="sumofsquares1_+3A_nobs">nobs</code></td>
<td>
<p>integer: length of return values</p>
</td></tr>
<tr><td><code id="sumofsquares1_+3A_n">n</code></td>
<td>
<p>integer: additional sum condition (default: <code>0</code>)</p>
</td></tr>
<tr><td><code id="sumofsquares1_+3A_x">x</code></td>
<td>
<p>numeric: vector of <code>nobs</code> starting values (default: <code>runif(nobs)</code>)</p>
</td></tr>
<tr><td><code id="sumofsquares1_+3A_maxit">maxit</code></td>
<td>
<p>integer: maximal number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A integer vector of length <code>nobs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sumofsquares1(100, 20)
sumofsquares1(100, 20)
</code></pre>

<hr>
<h2 id='t2norm'>Approximations</h2><span id='topic+t2norm'></span><span id='topic+approx_binom2norm'></span><span id='topic+approx_clt2norm'></span><span id='topic+approx_t2norm'></span><span id='topic+binom2norm'></span><span id='topic+clt2norm'></span>

<h3>Description</h3>

<p>Functions which deliver <code>TRUE</code> or <code>FALSE</code> if any approximation if possible.
The approximation parameter <code>c</code> can be set directly, or it can be given via <code>getOption</code>. The approximation functions deliver <code>TRUE</code> in the following scenarios:
</p>

<ul>
<li> <p><code>t2norm</code>: <code>n&gt;c</code> with <code>c=30</code>
</p>
</li>
<li> <p><code>binom2norm</code>: if the <code>type</code> is <code>"single"</code> (default) then it checks <code style="white-space: pre;">&#8288;size √ó prob (1-prob)&gt;c&#8288;</code>, or else it checks <code style="white-space: pre;">&#8288;size √ó prob&gt;c&#8288;</code> and <code style="white-space: pre;">&#8288;size √ó (1-prob)&gt;c&#8288;</code> with <code>c=9</code>
</p>
</li>
<li> <p><code>clt2norm</code>: <code>n&gt;c</code> with <code>c=30</code>. Note that the existence of the expectation and variance, which are required by the Central Limit Theorem, cannot be checked.
&ldquo;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>t2norm(n, c = getOption("distribution.t2norm", 30))

binom2norm(
  size,
  prob,
  c = getOption("distribution.binom2norm", 9),
  type = c("single", "double")
)

clt2norm(n, c = getOption("distribution.clt2norm", 30))

approx_binom2norm(
  size,
  prob,
  c = getOption("distribution.binom2norm", 9),
  type = c("single", "double")
)

approx_clt2norm(n, c = getOption("distribution.clt2norm", 30))

approx_t2norm(n, c = getOption("distribution.t2norm", 30))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t2norm_+3A_n">n</code></td>
<td>
<p>integer: number of observations</p>
</td></tr>
<tr><td><code id="t2norm_+3A_c">c</code></td>
<td>
<p>numeric: approximation parameter (default: <code style="white-space: pre;">&#8288;getOption("distribution.APPROXFUN)&#8288;</code> or a default value)</p>
</td></tr>
<tr><td><code id="t2norm_+3A_size">size</code></td>
<td>
<p>integer: number of observations</p>
</td></tr>
<tr><td><code id="t2norm_+3A_prob">prob</code></td>
<td>
<p>numeric: probability of success on each trial</p>
</td></tr>
<tr><td><code id="t2norm_+3A_type">type</code></td>
<td>
<p>character: approximation condition used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical if the approximation would be possible
</p>


<h3>Examples</h3>

<pre><code class='language-R'># check for 5 observations
t2norm(n=c(5,50))
binom2norm(size=c(5,50), prob=0.5)
binom2norm(size=c(5,50), prob=0.5, type="double")
</code></pre>

<hr>
<h2 id='table_data'>Frequency Table</h2><span id='topic+table_data'></span><span id='topic+freq_table'></span><span id='topic+dtable'></span>

<h3>Description</h3>

<p>Creates a frequency table where all entries can be written as <code class="reqn">2^{p_{ij}} 5^{q_{ij}}</code>. It holds that <code class="reqn">p_{ij}&lt;m2</code> and  <code class="reqn">q_{ij}&lt;m5</code>.
If the algorithm does not find a solution, then an error is thrown. Try to increase <code>unit</code> to 20, 50, 100 and so on.
Once a table is found, the table is normalized by dividing all entries by a number such that the entries are still integer.
Finally, a multiplicator of the form <code class="reqn">2^p 5^5</code> is randomly chosen, ensuring that the sum of the entries is less than, or equal to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_data(
  nrow,
  ncol,
  unit = 10,
  maxit = 1000,
  n = 100,
  m2 = ceiling(log(n)/log(2)),
  m5 = ceiling(log(n)/log(5))
)

freq_table(
  nrow,
  ncol,
  unit = 10,
  maxit = 1000,
  n = 100,
  m2 = ceiling(log(n)/log(2)),
  m5 = ceiling(log(n)/log(5))
)

dtable(
  nrow,
  ncol,
  unit = 10,
  maxit = 1000,
  n = 100,
  m2 = ceiling(log(n)/log(2)),
  m5 = ceiling(log(n)/log(5))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_data_+3A_nrow">nrow</code></td>
<td>
<p>integer: number of rows</p>
</td></tr>
<tr><td><code id="table_data_+3A_ncol">ncol</code></td>
<td>
<p>integer: number of columns</p>
</td></tr>
<tr><td><code id="table_data_+3A_unit">unit</code></td>
<td>
<p>integer: reciprocal of smallest non-zero probability (default: <code>10</code>)</p>
</td></tr>
<tr><td><code id="table_data_+3A_maxit">maxit</code></td>
<td>
<p>integer: maximal number of iterations (default: <code>1000</code>)</p>
</td></tr>
<tr><td><code id="table_data_+3A_n">n</code></td>
<td>
<p>integer: maximal sum of table entries (default: <code>100</code>)</p>
</td></tr>
<tr><td><code id="table_data_+3A_m2">m2</code></td>
<td>
<p>integer: maximal power of two used on normalized the table (default: <code>ceiling(log(n)/log(2))</code>)</p>
</td></tr>
<tr><td><code id="table_data_+3A_m5">m5</code></td>
<td>
<p>integer: maximal power of five used on normalized the table  (default: <code>ceiling(log(n)/log(5))</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A frequency table where all entries can be written as <code class="reqn">2^{p_{ij}} 5^{q_{ij}}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab22 &lt;- table(2, 2)
tab22
divisor_25(tab22)
nom.cc(tab22)         # Should be zero
#
table(3, 2)
table(4, 2)
</code></pre>

<hr>
<h2 id='template'>Template</h2><span id='topic+template'></span>

<h3>Description</h3>

<p>A text template where R code can be embedded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template(tmpl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_+3A_tmpl">tmpl</code></td>
<td>
<p>character: template</p>
</td></tr>
<tr><td><code id="template_+3A_...">...</code></td>
<td>
<p>named parameter used in the template</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character where the R code is replaced by its evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpl &lt;- "`r a`+`r b`"
template(tmpl, a=1, b=2)
</code></pre>

<hr>
<h2 id='to_choice'>Questions and Solutions List Generation</h2><span id='topic+to_choice'></span><span id='topic+choice_list'></span>

<h3>Description</h3>

<p>Creates a list with the elements <code>questions</code> and <code>solutions</code> values. A value can be either an entry in a vector or
a row in a data frame. <code>correct</code> is a logical vector which contains <code>TRUE</code> if its value represents a correct answer
and <code>FALSE</code> if it represents a wrong answer. The values can be shuffled or ordered (default).
</p>
<p>If <code>shuffle</code> is a integer of length 1 then one correct answer is chosen, and <code>shuffle</code> wrong answers are chosen.
If <code>shuffle</code> is a integer of length larger than 1, then <code>shuffle[1]</code> correct answers are chosen and <code>shuffle[2]</code> wrong answers are chosen.
If any <code>shuffle</code> entry is zero or negative, then no shuffling will be done.
If <code>order</code> is a function then it is expected that the function delivers an index for the reordering of the values.
Otherwise a <code>shuffle</code> for all values is applied.
</p>
<p>The shuffling works in two steps:
</p>

<ol>
<li><p> Sample within the correct and wrong value according to <code>shuffle</code>
</p>
</li>
<li><p> Apply shuffling (<code>order=NULL</code>) or ordering (default: <code>order=order</code>) of all selected answers
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>to_choice(
  df,
  correct,
  shuffle = c(NA_integer_, NA_integer_),
  orderfun = order,
  ...
)

choice_list(
  df,
  correct,
  shuffle = c(NA_integer_, NA_integer_),
  orderfun = order,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_choice_+3A_df">df</code></td>
<td>
<p>vector or data frame: values, in a data frame each row holds one value</p>
</td></tr>
<tr><td><code id="to_choice_+3A_correct">correct</code></td>
<td>
<p>logical: answer is correct (<code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="to_choice_+3A_shuffle">shuffle</code></td>
<td>
<p>integer: the numbers of correct and wrong values to shuffle (default: <code>c(NA,NA)</code>). <code>NA</code> means no shuffling</p>
</td></tr>
<tr><td><code id="to_choice_+3A_orderfun">orderfun</code></td>
<td>
<p>function: ordering of the shuffled values (default: <code>order</code>)</p>
</td></tr>
<tr><td><code id="to_choice_+3A_...">...</code></td>
<td>
<p>further named parameters used in <code>shuffle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with questions and solutions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>answer   &lt;- runif(5)
correct  &lt;- (1:5)==3 # Third answer is correct, the rest wrong
sc       &lt;- to_choice(answer, correct)
str(sc)           # Answers are ordered by size
sc$questions &lt;- c(format(sc$questions, nsmall=2), "No answer is correct") # Additional answer
sc$solutions &lt;- c(sc$solutions, FALSE)                                    # TRUE or FALSE?
sc           &lt;- to_choice(answer, correct, shuffle=2)
str(sc)      # One correct answer and two wrong answers selected
</code></pre>

<hr>
<h2 id='toHTML.html_matrix'>HTML and LaTeX Matrix Representations</h2><span id='topic+toHTML.html_matrix'></span><span id='topic+toLatex'></span><span id='topic+toHTMLorLatex'></span><span id='topic+toLatex.html_matrix'></span>

<h3>Description</h3>


<ul>
<li> <p><code>toHTML</code> returns an HTML representation of a matrix and, optionally, shows the result in the browser.
If you decide to view the result in a browser then the HTML will be written to a temporary file and
<code><a href="utils.html#topic+browseURL">utils::browseURL()</a></code> will be called
</p>
</li>
<li> <p><code>toLatex</code> returns a LaTeX representation of a matrix, but supports just a small subset of style options
</p>
</li>
<li> <p><code>toHTMLorLatex</code> returns an HTML or LaTeX representation of a matrix, depending if <code>exams2pdf</code> is in the call list or not
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'html_matrix'
toHTML(x, browser = FALSE, ...)

## S3 method for class 'html_matrix'
toLatex(object, ...)

toHTMLorLatex(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toHTML.html_matrix_+3A_x">x</code>, <code id="toHTML.html_matrix_+3A_object">object</code></td>
<td>
<p>html_matrix object</p>
</td></tr>
<tr><td><code id="toHTML.html_matrix_+3A_browser">browser</code></td>
<td>
<p>logical: show the HTML in a browser (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="toHTML.html_matrix_+3A_...">...</code></td>
<td>
<p>further parameters to <code><a href="utils.html#topic+browseURL">utils::browseURL()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("tools")
m    &lt;- matrix(1:12, ncol=4)
hm   &lt;- html_matrix(m)
if (interactive()) html &lt;- toHTML(hm, browser=TRUE)
toHTML(hm)
toLatex(hm)
</code></pre>

<hr>
<h2 id='toLatex.polynomial'>LaTeX Representation of a Polynomial</h2><span id='topic+toLatex.polynomial'></span>

<h3>Description</h3>

<p>Returns a LaTeX representation of the polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polynomial'
toLatex(
  object,
  digits = TRUE,
  decreasing = FALSE,
  variable = "x",
  simplify = TRUE,
  tol = 1e-09,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatex.polynomial_+3A_object">object</code></td>
<td>
<p>polynomial</p>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_digits">digits</code></td>
<td>
<p>numeric or logical: how to convert to text (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_decreasing">decreasing</code></td>
<td>
<p>logical:  order of the terms by increasing or decreasing powers (default:  <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_variable">variable</code></td>
<td>
<p>character: name of variable used (default: <code>"x"</code>)</p>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_simplify">simplify</code></td>
<td>
<p>logical: should the polynomial representation be simplified (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance (default: <code>1e-9</code>). A negative value will keep zeros and ones too, but:
</p>

<ul>
<li><p> If a coefficient is smaller than <code>tol</code> then zero terms are not kept
</p>
</li>
<li><p> If a absolute value of coefficient minus one is smaller than <code>tol</code> then coefficient is not kept
</p>
</li></ul>
</td></tr>
<tr><td><code id="toLatex.polynomial_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- polynomial(c(-1,0,2)/3)
toLatex(p, 4)
toLatex(p, FALSE)
toLatex(p, TRUE)
toLatex(p, variable="z")
toLatex(p, decreasing=TRUE)
p &lt;- polynomial(c(0,1,2)/3)
toLatex(p)
toLatex(p, tol=-1)
</code></pre>

<hr>
<h2 id='tooltip'>Tooltip</h2><span id='topic+tooltip'></span><span id='topic+add_tooltip'></span>

<h3>Description</h3>

<p>Adds a text tooltip to the HTML matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tooltip(x, tooltip = NULL)

add_tooltip(x, tooltip = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tooltip_+3A_x">x</code></td>
<td>
<p>an html_matrix object</p>
</td></tr>
<tr><td><code id="tooltip_+3A_tooltip">tooltip</code></td>
<td>
<p>character: text to show (default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An html_matrix object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("magrittr")
library("tools")
m    &lt;- matrix(1:12, ncol=4)
hm   &lt;- html_matrix_sk(m, title='', fmt=rep("%f", ncol(m))) %&gt;% 
          add_tooltip(sprintf("Table has %0.f rows and %0.f columns", nrow(.), ncol(.)))
if (interactive()) html &lt;- toHTML(hm, browser=TRUE)
</code></pre>

<hr>
<h2 id='toRMarkdown'>toRMarkdown</h2><span id='topic+toRMarkdown'></span>

<h3>Description</h3>

<p>Conversion to R Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toRMarkdown(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toRMarkdown_+3A_txt">txt</code></td>
<td>
<p>character: vector with lines of Moodle Markdown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines with RMarkdown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt &lt;- c("[image]\n",
         "Ein Paar hat 8 gute Bekannte, von denen die beiden 5 zum Essen einladen m√∂chten.",
         "Wie viele verschiedene Reihenfolgen des Eintreffens der eingeladenen 5 G√§ste gibt es?\n",
         ": 56",
         "; 120",
         "; 336",
         "; 2002",
         "; 6720",
         "; 32768",
         "; 40320",
         "; Keine Antwort ist richtig")
toRMarkdown(txt)          
</code></pre>

<hr>
<h2 id='toString.polynomial'>Text Representation of a Polynomial</h2><span id='topic+toString.polynomial'></span>

<h3>Description</h3>

<p>Creates a text representation for a polynomial, in the following scenarios:
</p>

<ul>
<li><p> if <code>digits</code> is <code>TRUE</code> then <code>as.character(.)</code> is used
</p>
</li>
<li><p> if <code>digits</code> is <code>FALSE</code> then <code>./.</code> is used
</p>
</li>
<li><p> if <code>digits</code> is numeric then <code>as.character(round(., digits))</code> is used
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polynomial'
toString(
  x,
  digits = TRUE,
  decreasing = FALSE,
  variable = "x",
  simplify = TRUE,
  tol = 1e-09,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toString.polynomial_+3A_x">x</code></td>
<td>
<p>polynomial: vector of coefficients (first is intercept)</p>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_digits">digits</code></td>
<td>
<p>numeric or logical: how to convert to text (default: <code>NA</code>)</p>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_decreasing">decreasing</code></td>
<td>
<p>logical:  order of the terms by increasing or decreasing powers (default:  <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_variable">variable</code></td>
<td>
<p>character: name of the variable used (default: <code>"x"</code>)</p>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_simplify">simplify</code></td>
<td>
<p>logical: should the polynomial representation be simplified (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_tol">tol</code></td>
<td>
<p>numeric: tolerance (default: <code>1e-9</code>). A negative value will keep zeros and ones too, but:
</p>

<ul>
<li><p> If a coefficient is smaller than <code>tol</code> then zero terms are not kept.
</p>
</li>
<li><p> If a absolute value of coefficient minus one is smaller than <code>tol</code> then coefficient is not kept
</p>
</li></ul>
</td></tr>
<tr><td><code id="toString.polynomial_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- polynomial(c(-1,0,2)/3)
toString(p, 4)
toString(p, FALSE)
toString(p, TRUE)
toString(p, variable="z")
toString(p, decreasing=TRUE)
p &lt;- polynomial(c(0,1,2)/3)
toString(p)
toString(p, tol=-1)
</code></pre>

<hr>
<h2 id='transformif'>Transformation</h2><span id='topic+transformif'></span>

<h3>Description</h3>

<p>Transforms <code>x</code> if <code>cond</code> is <code>TRUE</code> by <code class="reqn">\log(a+b*x)</code> if <code>p==0</code> and <code class="reqn">(a+b*x)^p)</code>.
Otherwise the transformation can be either applied to each element of <code>x</code>, or to all elements of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformif(x, cond, a = -abs(min(x)), b = 1, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformif_+3A_x">x</code></td>
<td>
<p>vector: values</p>
</td></tr>
<tr><td><code id="transformif_+3A_cond">cond</code></td>
<td>
<p>logical: condition if transformation should be applied</p>
</td></tr>
<tr><td><code id="transformif_+3A_a">a</code></td>
<td>
<p>numeric: shift (default: <code>-abs(min(x))</code>)</p>
</td></tr>
<tr><td><code id="transformif_+3A_b">b</code></td>
<td>
<p>numeric: scale (default: <code>1</code>))</p>
</td></tr>
<tr><td><code id="transformif_+3A_p">p</code></td>
<td>
<p>numeric: power (default: <code>1</code>))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(5)
transformif(x, min(x)&lt;0)  # all transformed elements &gt; 0
transformif(x, x&lt;0)       # only negative elements are transformed
</code></pre>

<hr>
<h2 id='ts_data'>Time Series</h2><span id='topic+ts_data'></span><span id='topic+dts'></span>

<h3>Description</h3>

<p>Creates an univariate time series based on a linear or an exponential trend,
an additive or multiplicative seasonal adjustment and with white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_data(
  end,
  trend = TRUE,
  trend.coeff = c(1, 1),
  season = TRUE,
  season.coeff = NULL,
  error = TRUE,
  error.coeff = NULL,
  digits = NA
)

dts(
  end,
  trend = TRUE,
  trend.coeff = c(1, 1),
  season = TRUE,
  season.coeff = NULL,
  error = TRUE,
  error.coeff = NULL,
  digits = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_data_+3A_end">end</code></td>
<td>
<p>integer: length of time series</p>
</td></tr>
<tr><td><code id="ts_data_+3A_trend">trend</code></td>
<td>
<p>logical: if <code>TRUE</code> a linear trend otherwise a exponential trend (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="ts_data_+3A_trend.coeff">trend.coeff</code></td>
<td>
<p>numeric: coefficients for a linear model (default: <code>c(1,1)</code>)</p>
</td></tr>
<tr><td><code id="ts_data_+3A_season">season</code></td>
<td>
<p>logical: if <code>TRUE</code> an additive seasonal adjustment is done otherwise, a multiplicative seasonal adjustment  (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="ts_data_+3A_season.coeff">season.coeff</code></td>
<td>
<p>numeric: coefficients for the adjustment (default: <code>NULL</code>). If <code>NULL</code> then no seasonal adjustment is made.</p>
</td></tr>
<tr><td><code id="ts_data_+3A_error">error</code></td>
<td>
<p>logical: if <code>TRUE</code> an additive error term is used, otherwise, a multiplicative error term (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ts_data_+3A_error.coeff">error.coeff</code></td>
<td>
<p>numeric: standard deviation(s) for white noise error (default: <code>NULL</code>). If <code>NULL</code> then no error is added.</p>
</td></tr>
<tr><td><code id="ts_data_+3A_digits">digits</code></td>
<td>
<p>integer: number of digits to round the time series (default: <code>NA</code>). If <code>NA</code> then no rounding is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ts_data object with the following list of elements:
</p>

<ul>
<li> <p><code>t</code> the time points
</p>
</li>
<li> <p><code>s</code> the season for the time points
</p>
</li>
<li> <p><code>xt</code> the time series values
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Time series from linear trend
ts &lt;- ts_data(12, trend.coeff= c(sample(0:10, 1), sample(1+(1:10)/20, 1)))
ts
# Time series from exponential trend
ts &lt;- ts_data(12, trend.coeff= c(sample(0:10, 1), sample(1+(1:10)/20, 1)), trend=FALSE)
ts   
# Time series from linear trend and additive seasonal adjustment (quartely data)
ts &lt;- ts_data(12, trend.coeff=c(sample(0:10, 1), sample(1+(1:10)/20, 1)),
                  season.coeff=sample((-20:20)/20, 4))
ts   
# Time series from linear trend and additive seasonal adjustment (half-yearly data)
ts &lt;- ts_data(12, trend.coeff=c(sample(0:10, 1), sample(1+(1:10)/20, 1)),
                  season.coeff=sample((-20:20)/20, 2))
ts   
# Time series from linear trend and mutliplicative seasonal adjustment (quartely data)
ts &lt;- ts_data(12, trend.coeff=c(sample(0:10, 1), sample(1+(1:10)/20, 1)),
                  season.coeff=sample((-20:20)/20, 4), season=FALSE)
ts   
</code></pre>

<hr>
<h2 id='ts_moving_average'>Moving Average</h2><span id='topic+ts_moving_average'></span><span id='topic+ts_ma'></span>

<h3>Description</h3>

<p>Computes the moving average for a <code>ts_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_moving_average(ts, order)

ts_ma(ts, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_moving_average_+3A_ts">ts</code></td>
<td>
<p>a <code>ts_data</code> object</p>
</td></tr>
<tr><td><code id="ts_moving_average_+3A_order">order</code></td>
<td>
<p>integer: order of the moving average</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an extended <code>ts_data</code> object with list elements:
</p>

<ul>
<li> <p><code>filter</code> the filter used
</p>
</li>
<li> <p><code>moving.average</code> the computed moving average
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># trend from a quadratic model
ts &lt;- ts_data(12, trend.coeff=c(sample(0:10, 1), sample(1+(1:10)/20, 1), 0.5))
ts_moving_average(ts, 3)
</code></pre>

<hr>
<h2 id='ts_trend_season'>Trend and Season Model</h2><span id='topic+ts_trend_season'></span><span id='topic+ts_ts'></span>

<h3>Description</h3>

<p>Estimate a trend and season model from a <code>ts_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_trend_season(ts, trend = NULL, season = NULL)

ts_ts(ts, trend = NULL, season = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_trend_season_+3A_ts">ts</code></td>
<td>
<p><code>ts_data</code> object</p>
</td></tr>
<tr><td><code id="ts_trend_season_+3A_trend">trend</code></td>
<td>
<p>numeric or logical: if <code>trend</code> is TRUE then a linear trend will be estimated, otherwise an exponential trend. If <code>trend</code> is numeric this is considered as trend value</p>
</td></tr>
<tr><td><code id="ts_trend_season_+3A_season">season</code></td>
<td>
<p>numeric or logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an extended <code>ts_data</code> object with the following list of elements:
</p>

<ul>
<li> <p><code>t</code> the time points
</p>
</li>
<li> <p><code>s</code> the season for the time points
</p>
</li>
<li> <p><code>xt</code> the time series values
</p>
</li>
<li> <p><code>trend</code> the fitted trend values
</p>
</li>
<li> <p><code>trend.coeff</code> the trend coefficients
</p>
</li>
<li> <p><code>trend.linear</code> the trend type, if <code>NA</code> then it is unknown
</p>
</li>
<li> <p><code>season</code> the fitted season values
</p>
</li>
<li> <p><code>season.t</code> the fitted season values for the time series
</p>
</li>
<li> <p><code>trend.season</code> the fitted values for trend and season
</p>
</li>
<li> <p><code>trend.linear</code> the trend type, if <code>NA</code> then it is unknown
</p>
</li>
<li> <p><code>var</code> the variance of the residuals
</p>
</li>
<li> <p><code>r.square</code> the <code class="reqn">R^2</code> of the final model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts_data(12, trend.coeff= c(sample(0:10, 1), sample(1+(1:10)/20, 1)))
ts_trend_season(ts)
</code></pre>

<hr>
<h2 id='ttest_data'>T-tests and Data Creation</h2><span id='topic+ttest_data'></span><span id='topic+dt1'></span>

<h3>Description</h3>

<p>Creates data for a t-test, for one mean, based on the test's properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttest_data(
  size = (3:20)^2,
  mean = -5:5,
  sd = seq(0.1, 1, by = 0.1),
  reject = NA,
  alternative = c("two.sided", "less", "greater"),
  alpha = c(0.01, 0.05, 0.1),
  z = seq(-4.49, 4.49, by = 0.01),
  use.sigma = TRUE
)

dt1(
  size = (3:20)^2,
  mean = -5:5,
  sd = seq(0.1, 1, by = 0.1),
  reject = NA,
  alternative = c("two.sided", "less", "greater"),
  alpha = c(0.01, 0.05, 0.1),
  z = seq(-4.49, 4.49, by = 0.01),
  use.sigma = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttest_data_+3A_size">size</code></td>
<td>
<p>numeric: vector of possible sample sizes (default <code>(3:20)^2,</code>)</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_mean">mean</code></td>
<td>
<p>numeric: vector of possible means (default <code>-5:5</code>)</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_sd">sd</code></td>
<td>
<p>numeric: vector of possible standard deviations (default <code>sd=seq(0.1, 1, by=0.1</code>)</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_reject">reject</code></td>
<td>
<p>logical: should <code>x</code> generate a lead for the rejection of the null hypothesis (default <code>TRUE</code>), if equals <code>NA</code> then this will be ignored</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_alternative">alternative</code></td>
<td>
<p>character: a character string specifying the alternative hypothesis, must be one of <code>two.sided</code> (default), <code>greater</code> or <code>less</code></p>
</td></tr>
<tr><td><code id="ttest_data_+3A_alpha">alpha</code></td>
<td>
<p>numeric: vector of significance levels (default <code>c(0.01, 0.05, 0.1)</code>)</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_z">z</code></td>
<td>
<p>numeric: vector of possible <code class="reqn">z</code> values (default <code>seq(-4.49, 4.49, by=0.01)</code>)</p>
</td></tr>
<tr><td><code id="ttest_data_+3A_use.sigma">use.sigma</code></td>
<td>
<p>logical: should the standard deviation of the population (default) or the sample be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li> <p><code>mu0</code> hypothetical mean
</p>
</li>
<li> <p><code>sigma</code> standard deviation in the population
</p>
</li>
<li> <p><code>sd</code> vector of possible standard deviations in the sample
</p>
</li>
<li> <p><code>xbar</code> mean in the sample
</p>
</li>
<li> <p><code>n</code> sample size
</p>
</li>
<li> <p><code>alpha</code> significance level
</p>
</li>
<li> <p><code>alternative</code> specifying the alternative hypothesis (either <code>two.sided</code>, <code>greater</code> or <code>less</code>)
</p>
</li>
<li> <p><code>altsd</code> alternative values usable for <code>sd</code> (if <code>use.sigma==TRUE</code>) or <code>sigma</code> (if <code>use.sigma==FALSE</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ttest_data()
</code></pre>

<hr>
<h2 id='ttest_num'>T-tests</h2><span id='topic+ttest_num'></span>

<h3>Description</h3>

<p>Computes all results for a t-test. Note that the results may differ from <code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, see the &quot;Details&quot;.
Either named parameters can be given, or a <code>list</code> with the parameters.
You must provide either <code>x</code> or <code>mean</code>, <code>sd</code> and <code>n</code>. If <code>x</code> is given then any values
given for <code>mean</code>, <code>sd</code> and <code>n</code> will be overwritten. Also either <code>sd</code> or <code>sigma</code> or both must be given.
</p>

<ul>
<li> <p><code>x</code> sample (default: <code>numeric(0)</code>)
</p>
</li>
<li> <p><code>mean</code> sample mean (default: <code>mean(x)</code>)
</p>
</li>
<li> <p><code>n</code> sample size (default: <code>length(x)</code>)
</p>
</li>
<li> <p><code>sd</code> sample standard deviation (default: <code>sd(x)</code>)
</p>
</li>
<li> <p><code>sigma</code> population standard deviation (default: <code>NA</code> = unknown)
</p>
</li>
<li> <p><code>mu0</code> true value of the mean (default: <code>0</code>)
</p>
</li>
<li> <p><code>alternative</code> a string specifying the alternative hypothesis (default: <code>"two.sided"</code>), otherwise <code>"greater"</code> or <code>"less"</code> can be used
</p>
</li>
<li> <p><code>alpha</code> significance level (default: <code>0.05</code>)
</p>
</li>
<li> <p><code>norm</code> is the population normal distributed? (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>n.clt</code> when the central limit theorem holds (default: <code>getOption("n.clt", 30)</code>)
</p>
</li>
<li> <p><code>t2norm</code> does the approximation <code class="reqn">t_n \approx N(0;1)</code> hold? <code style="white-space: pre;">&#8288;(default: &#8288;</code>NA<code style="white-space: pre;">&#8288;= use&#8288;</code>t2norm' function)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ttest_num(..., arglist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttest_num_+3A_...">...</code></td>
<td>
<p>named input parameters</p>
</td></tr>
<tr><td><code id="ttest_num_+3A_arglist">arglist</code></td>
<td>
<p>list: named input parameters, if given <code>...</code> will be ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of <code>ttest_num</code> may differ from <code><a href="stats.html#topic+t.test">stats::t.test()</a></code>. <code>ttest_num</code> is designed to return results
when you compute a t-test by hand. For example, for computing the test statistic the approximation <code class="reqn">t_n \approx N(0; 1)</code>
is used if <code class="reqn">n&gt;n.tapprox</code>. The <code>p.value</code> is computed from the cumulative distribution function of the normal or
the t distribution.
</p>


<h3>Value</h3>

<p>A list with the input parameters and the following:
</p>

<ul>
<li> <p><code>Xbar</code> distribution of the random sampling function <code class="reqn">\bar{X}</code>, only available if <code>sigma</code> given
</p>
</li>
<li> <p><code>Statistic</code> distribution of the test statistics
</p>
</li>
<li> <p><code>statistic</code> test value
</p>
</li>
<li> <p><code>critical</code> critical value(s)
</p>
</li>
<li> <p><code>criticalx</code> critical value(s) in x range
</p>
</li>
<li> <p><code>acceptance0</code> acceptance interval for H0
</p>
</li>
<li> <p><code>acceptance0x</code> acceptance interval for H0 in x range
</p>
</li>
<li> <p><code>accept1</code> is H1 accepted?
</p>
</li>
<li> <p><code>p.value</code> p value for test
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
ttest_num(x=x)
ttest_num(mean=mean(x), sd=sd(x), n=length(x))
ret &lt;- ttest_num(x=x)
ret$alternative &lt;- "less"
ttest_num(arglist=ret)
</code></pre>

<hr>
<h2 id='ttests'>T-tests</h2><span id='topic+ttests'></span>

<h3>Description</h3>

<p><code>ttests</code> runs a variety of modifications to the input parameters of <code>ttest</code>, in order to generate all possible t-tests.
See under &quot;Details&quot; the detailed parameter values which are used. Note that not giving the parameter <code>hyperloop</code> will
results in approx. 5000 t-tests generated.
Returned will be only the different t-tests with the first element being <code>ttest</code>. If only a specific element of a <code>ttest</code>
is of interest then just give the name of the element in <code>elem</code> and then all <code>ttest</code>s will be returned where <code>elem</code> is different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttests(ttest, elem = NULL, hyperloop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttests_+3A_ttest">ttest</code></td>
<td>
<p>ttest: the base result from a valid t-test generated by <code><a href="#topic+ttest_num">ttest_num()</a></code></p>
</td></tr>
<tr><td><code id="ttests_+3A_elem">elem</code></td>
<td>
<p>character: element to extract (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ttests_+3A_hyperloop">hyperloop</code></td>
<td>
<p>named list: parameter values to run over (default: see above)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>hyperloop</code> is:
</p>
<div class="sourceCode"><pre>list(n           = c(1, ttest$n, ttest$n+1),
     mu0         = c(ttest$mu0, ttest$mean),
     mean        = c(ttest$mu0, ttest$mean), 
     sigma       = c(ttest$sigma, ttest$sd, sqrt(ttest$sigma), sqrt(ttest$sd)),
     sd          = c(ttest$sigma, ttest$sd, sqrt(ttest$sigma), sqrt(ttest$sd)),
     norm        = c(TRUE, FALSE),
     alpha       = unique(c(ttest$alpha, 0.01, 0.05, 0.1)),
     alternative = c("two.sided", "greater", "less")
    )
</pre></div>


<h3>Value</h3>

<p>A list of <code>ttest</code> objects is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basetest  &lt;- ttest_num(mean=0.5, sd=1.25, n=50, sigma=1)
# vary the number of observations
hyperloop &lt;- list(n=c(1, basetest$n, basetest$n^2))
# return all different t-tests
tts       &lt;- ttests(basetest, hyperloop=hyperloop)
# return all different random sampling functions
ttests(basetest, "Xbar", hyperloop)
</code></pre>

<hr>
<h2 id='unique_elem'>Unique Elements</h2><span id='topic+unique_elem'></span>

<h3>Description</h3>

<p>Deletes all elements from a <code>hyperloop</code> object that are identical.
Since the result in each run can be a list itself, only specific list elements can be used for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_elem(x, elem = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_elem_+3A_x">x</code></td>
<td>
<p>a <code>hyperloop</code> object</p>
</td></tr>
<tr><td><code id="unique_elem_+3A_elem">elem</code></td>
<td>
<p>character: list elements which are used to check if <code>hyperloop</code> results are identical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reduced <code>hyperloop</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
# 6 results: 3 different mu's, 2 var.equals
hl &lt;- hyperloop(t.test, x=x, mu=list(-1, 0, 1), var.equal=list(TRUE, FALSE))
# reduction to 3 elements since var.equal does not play any role
length(unique_elem(hl))    
# reduction to 1 element since the mean of x always the same
length(unique_elem(hl, "estimate"))
</code></pre>

<hr>
<h2 id='unique_max'>Unique Maximum</h2><span id='topic+unique_max'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> has a unique maximum. The largest and the second largest value must have at least a distance of <code>tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_max(x, tol = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_max_+3A_x">x</code></td>
<td>
<p>numeric: values to check</p>
</td></tr>
<tr><td><code id="unique_max_+3A_tol">tol</code></td>
<td>
<p>numeric: minimum distance between the largest and the second largest value (default: <code>1e-3</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-runif(100)
unique_max(x)
unique_max(x, tol=0.1)
</code></pre>

<hr>
<h2 id='vec2mat'>Vector to Matrix Conversion</h2><span id='topic+vec2mat'></span><span id='topic+to_mat'></span>

<h3>Description</h3>

<p>Converts a vector to a horizontal or vertical matrix and sets <code style="white-space: pre;">&#8288;row-&#8288;</code> or <code>colnames</code>.
If <code>rownames</code> or <code>colnames</code> are given, then existing row names or column names are overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2mat(x, colnames = NULL, rownames = NULL, horizontal = TRUE)

to_mat(x, colnames = NULL, rownames = NULL, horizontal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2mat_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_colnames">colnames</code></td>
<td>
<p>character: vector of new column names (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_rownames">rownames</code></td>
<td>
<p>character: vector of new row names (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_horizontal">horizontal</code></td>
<td>
<p>logical: horizontal or vertical matrix (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
vec2mat(x)
vec2mat(x, horizontal=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
