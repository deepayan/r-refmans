<!DOCTYPE html><html><head><title>Help for package restoptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {restoptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_available_areas_constraint'><p>Add available areas constraint</p></a></li>
<li><a href='#add_compactness_constraint'><p>Add constraint to limit compactness</p></a></li>
<li><a href='#add_components_constraint'><p>Add constraint to limit the number of connected components</p></a></li>
<li><a href='#add_connected_constraint'><p>Add constraint to ensure that the selected planning units for restoration</p>
are connected.</a></li>
<li><a href='#add_locked_out_constraint'><p>Add locked out constraint</p></a></li>
<li><a href='#add_min_iic_constraint'><p>Add constraint to enforce a minimum integral index of connectivity (IIC) value</p></a></li>
<li><a href='#add_min_mesh_constraint'><p>Add constraint to enforce a minimum effective mesh size (MESH) value</p></a></li>
<li><a href='#add_restorable_constraint'><p>Add constraint to specify the available amount of surface for restoration</p></a></li>
<li><a href='#add_settings'><p>Add settings</p></a></li>
<li><a href='#area_to_nb_cells'><p>Compute the number of cells corresponding to a given area.</p></a></li>
<li><a href='#cell_area'><p>Compute the area of a cell</p></a></li>
<li><a href='#cell_width'><p>Compute the width of a cell</p></a></li>
<li><a href='#get_aggregation_factor'><p>Retrieve the aggregation factor of a restopt problem.</p></a></li>
<li><a href='#get_cell_area'><p>Retrieve the aggregated cell area of a restopt problem.</p></a></li>
<li><a href='#get_constraints'><p>Retrieve the constraints of a restopt problem.</p></a></li>
<li><a href='#get_existing_habitat'><p>Retrieve the existing (i.e. aggregated) habitat data.</p></a></li>
<li><a href='#get_habitat_threshold'><p>Retrieve the habitat threshold parameter of a restopt problem.</p></a></li>
<li><a href='#get_locked_out_areas'><p>Retrieve the locked out areas of a restopt problem.</p></a></li>
<li><a href='#get_metadata'><p>Restopt solution metadata</p></a></li>
<li><a href='#get_objective'><p>Retrieve the optimization objective of a restopt problem.</p></a></li>
<li><a href='#get_original_habitat'><p>Retrieve the original (i.e. not aggregated) habitat data.</p></a></li>
<li><a href='#get_restorable_habitat'><p>Retrieve the restorable habitat (aggregated) data.</p></a></li>
<li><a href='#get_settings'><p>Retrieve the settings of a restopt problem.</p></a></li>
<li><a href='#invert_vector'><p>Invert a vector layer according to the extent of a restopt problem.</p></a></li>
<li><a href='#is_java_available'><p>Is Java is available?</p></a></li>
<li><a href='#nb_cell_to_area'><p>Compute the area corresponding to a given number of cells.</p></a></li>
<li><a href='#preprocess_input'><p>Restopr input preprocessing function.</p></a></li>
<li><a href='#print.RestoptProblem'><p>Print a restoration optimization problem</p></a></li>
<li><a href='#restopt_problem'><p>Restoration optimization problem</p></a></li>
<li><a href='#restopt_solution'><p>Restopt solution</p></a></li>
<li><a href='#restoptr'><p><code>restoptr</code>: Ecological Restoration Planning</p></a></li>
<li><a href='#set_max_iic_objective'><p>Set an objective to maximize the integral index of connectivity</p></a></li>
<li><a href='#set_max_mesh_objective'><p>Set an objective to maximize effective mesh size</p></a></li>
<li><a href='#set_max_nb_pus_objective'><p>Set an objective to maximize the number of planning units</p></a></li>
<li><a href='#set_max_restore_objective'><p>Set an objective to maximize the amount restoration area.</p></a></li>
<li><a href='#set_min_nb_pus_objective'><p>Set an objective to minimize the number of planning units</p></a></li>
<li><a href='#set_min_restore_objective'><p>Set an objective to minimize the amount restoration area.</p></a></li>
<li><a href='#set_no_objective'><p>Configure the solver to only satisfy the constraints, without optimization</p>
objective</a></li>
<li><a href='#solve.RestoptProblem'><p>Solve a restoration optimization problem</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ecological Restoration Planning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Flexible framework for ecological restoration planning. It aims to identify priority areas for restoration efforts using optimization algorithms (based on Justeau-Allaire et al. 2021 &lt;<a href="https://doi.org/10.1111%2F1365-2664.13803">doi:10.1111/1365-2664.13803</a>&gt;). Priority areas can be identified by maximizing landscape indices, such as the effective mesh size (Jaeger 2000 &lt;<a href="https://doi.org/10.1023%2FA%3A1008129329289">doi:10.1023/A:1008129329289</a>&gt;), or the integral index of connectivity (Pascual-Hortal &amp; Saura 2006 &lt;<a href="https://doi.org/10.1007%2Fs10980-006-0013-z">doi:10.1007/s10980-006-0013-z</a>&gt;). Additionally, constraints can be used to ensure that priority areas exhibit particular characteristics (e.g., ensure that particular places are not selected for restoration, ensure that priority areas form a single contiguous network). Furthermore, multiple near-optimal solutions can be generated to explore multiple options in restoration planning. The package leverages the 'Choco-solver' software to perform optimization using constraint programming (CP) techniques (<a href="https://choco-solver.org/">https://choco-solver.org/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dimitri-justeau.github.io/restoptr/">https://dimitri-justeau.github.io/restoptr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dimitri-justeau/restoptr/issues">https://github.com/dimitri-justeau/restoptr/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 11.0.12)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, assertthat (&ge; 0.2.1), magrittr, crayon (&ge; 1.4.1),
methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), terra (&ge; 1.6-17), rJava (&ge; 1.0.6), units (&ge;
0.8-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.1), knitr (&ge; 1.2.0), roxygen2 (&ge; 6.1.1),
rmarkdown (&ge; 1.10), landscapemetrics (&ge; 1.5.4), vegan (&ge;
2.5.7), cluster (&ge; 2.1.2), ggthemes, paletteer</td>
</tr>
<tr>
<td>Collate:</td>
<td>'internal.R' 'add_available_areas_constraint.R'
'add_compactness_constraint.R' 'add_components_constraint.R'
'add_connected_constraint.R' 'add_locked_out_constraint.R'
'add_min_iic_constraint.R' 'add_min_mesh_constraint.R'
'add_restorable_constraint.R' 'add_settings.R'
'is_java_available.R' 'package.R' 'preprocessing.R'
'restopt_component.R' 'restopt_problem.R' 'restopt_solution.R'
'set_max_iic_objective.R' 'set_max_mesh_objective.R'
'set_max_nb_pus_objective.R' 'set_max_restore_objective.R'
'set_min_nb_pus_objective.R' 'set_min_restore_objective.R'
'set_no_objective.R' 'solve.R' 'terra_io.R' 'terra_utils.R'
'utils-pipe.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-17 14:31:52 UTC; justeau-allaire</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitri Justeau-Allaire
    <a href="https://orcid.org/0000-0003-4129-0764"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jeffrey O Hanson <a href="https://orcid.org/0000-0002-4716-6134"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ghislain Vieilledent
    <a href="https://orcid.org/0000-0002-1685-4997"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Philippe Vismara [aut],
  Xavier Lorca [aut],
  Philippe Birnbaum [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitri Justeau-Allaire &lt;dimitri.justeau@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-18 08:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_available_areas_constraint'>Add available areas constraint</h2><span id='topic+add_available_areas_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify that only certain planning units can be selected for restoration
activities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_available_areas_constraint(problem, data, touches = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_available_areas_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_available_areas_constraint_+3A_data">data</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>  or <code><a href="terra.html#topic+vect">terra::vect()</a></code> Either a raster object
containing binary values hat indicate which planning units can be selected
for restoration (i.e., only cells with a value equal one are available),
or a vector object whose features correspond to the available areas.</p>
</td></tr>
<tr><td><code id="add_available_areas_constraint_+3A_touches">touches</code></td>
<td>
<p><code>logical</code> If the available area data is a vector, define wether
the rasterization must include all pixels touching the polygons.
(see <code>terra::rasterize()</code>). Useless if the data is raster data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available areas constraints can be used to incorporate a wide range of
criteria into restoration planning problems.
They can be used to account for existing land-use practices,
feasibility of restoration activities, and stakeholder preferences.
For example, available areas constraints can be used to
ensure that urban areas are not selected for restoration.
Additionally, if restoration activities can only be implemented depending
on certain conditions &ndash; such as places where landscape slope is not
too steep &ndash; then available areas constraints could be used to ensure
restoration activities are not prioritized for places where they
could not be implemented.
Furthermore, if stakeholders require solutions that do not prioritize
particular places for restoration, then available areas constraints
can also be used to achieve this.
See <code>add_locked_out_constraint()</code>, which achieve the same as available
areas constraint by defining areas that are NOT available for restoration.
<strong>Note</strong>: The locked out constraint and the available are the same constraints,
with a different input data. Thus, from a modelling perspective,
<code>add_available_areas_constraint()</code> is just a pre processing layer in front of
<code>add_locked_out_constraint()</code>. This is why if you print a restopt problem
with an available areas constraint, you will see a locked out constraint.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

available &lt;- vect(
system.file("extdata", "accessible_areas.gpkg", package = "restoptr")
)

# plot data
plot(habitat_data)
plot(available, add=TRUE)

# create problem with available areas constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_iic_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_available_areas_constraint(available) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_compactness_constraint'>Add constraint to limit compactness</h2><span id='topic+add_compactness_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify the compactness of a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_compactness_constraint(problem, max_diameter, unit = "m")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_compactness_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_compactness_constraint_+3A_max_diameter">max_diameter</code></td>
<td>
<p><code>numeric</code> Maximum diameter value.</p>
</td></tr>
<tr><td><code id="add_compactness_constraint_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to an area
unit (see <code>unit</code> package), or &quot;cells&quot; for cell width of aggregated
habitat raster. Corresponds to the unit of the maximum diameter. If the
input habitat raster does not use a projected coordinate system, only &quot;cells&quot;
is available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The compactness constraint is defined according to the diameter of
the smallest enclosing circle which contains the center of selected planning
units for restoration (see https://w.wiki/4vfg). The unit of the diameter
corresponds either to a unit available in the <code>unit</code> package, or to planning
unit width (&quot;cells&quot;). Note that, as the computation occurs on aggregated cells,
if <code>max_diameter</code> is used with a different unit than &quot;cells&quot;, it will be rounded
to the closest corresponding number of cells. For example, a diameter of 4 cells
means that no more than 4 cells can be found in line in the solution. In practice,
this constraint is useful to ensure the feasibility of a restoration project,
and to integrate economies of scale. Compact restoration areas are usually
associated with lower costs and easier management, because it ensures that
restoration sites are not too far away from each other (e.g. lower travel costs
between sites, less areas to monitor, etc.).
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_restorable_constraint(
    min_restore = 200,
    max_restore = 300,
  ) %&gt;%
  add_compactness_constraint(1800, unit = "m")

# plot preprocessed data
plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)

# print problem
print(p)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_components_constraint'>Add constraint to limit the number of connected components</h2><span id='topic+add_components_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify the number of connected components that can be
present within a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_components_constraint(problem, min_nb_components, max_nb_components)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_components_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_components_constraint_+3A_min_nb_components">min_nb_components</code></td>
<td>
<p><code>integer</code> Minimum number of connected components.</p>
</td></tr>
<tr><td><code id="add_components_constraint_+3A_max_nb_components">max_nb_components</code></td>
<td>
<p><code>integer</code> Maximum number of connected components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A connected component is a spatially continuous set of planning
units. This constraints applies on the set of planning units that are
selected for restoration, and allows to specify a minimum and maximum
number of connected components. In practice, this constraint is useful
to ensure the feasibility of a restoration project, and to integrate
economies of scale. Continuous restoration areas (i.e. less connected
components) are usually associated with lower costs, because it ensures that
restoration sites are not too far away from each other (e.g. lower travel
costs between sites, less areas to monitor, etc.). On the other hand,
it can be useful to enforce several disconnected restoration areas to
ensure that hazards (e.g. fire) do not strike all planning units at the
same time.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_restorable_constraint(
    min_restore = 10,
    max_restore = 100,
  ) %&gt;%
  add_components_constraint(1, 1)

# plot preprocessed data
plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)

# print problem
print(p)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_connected_constraint'>Add constraint to ensure that the selected planning units for restoration
are connected.</h2><span id='topic+add_connected_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify the selected planning units are connected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_connected_constraint(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_connected_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A connected area is such that there is a path between any to
planning units within the area. This constraints applies on the set of
planning units that are selected for restoration. In practice, this
constraint is useful to ensure the feasibility of a restoration project,
and to integrate economies of scale. Connected restoration areas are
usually associated with lower costs, because it ensures that restoration
sites are not too far away from each other (e.g. lower travel
costs between sites, less areas to monitor, etc.). <strong>Note</strong> This constraint
relies on the add_components_constraint(), with parameters set to enforce
exactly one connected component. Also see <a href="#topic+add_components_constraint">add_components_constraint</a>
and <a href="#topic+add_compactness_constraint">add_compactness_constraint</a>.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_restorable_constraint(
    min_restore = 10,
    max_restore = 100,
  ) %&gt;%
  add_connected_constraint()

# plot preprocessed data
plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)

# print problem
print(p)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_locked_out_constraint'>Add locked out constraint</h2><span id='topic+add_locked_out_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify that certain planning units cannot be selected
for restoration activities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_locked_out_constraint(problem, data, touches = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_locked_out_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_locked_out_constraint_+3A_data">data</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>  or <code><a href="terra.html#topic+vect">terra::vect()</a></code> Either a raster object
containing binary values hat indicate which planning units cannot be selected
for any restoration (i.e., cells with a value equal one are locked out from
the solution), or a vector object whose features correspond to the locked
out areas. See the function <code>add_available_areas_constraint()</code> to get a locked
out constraint from allowed restoration areas.</p>
</td></tr>
<tr><td><code id="add_locked_out_constraint_+3A_touches">touches</code></td>
<td>
<p><code>logical</code> If the locked out data is a vector, define wether
the rasterization must include all pixels touching the polygons.
(see <code>terra::rasterize()</code>). Useless if the data is raster data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locked out constraints can be used to incorporate a wide range of
criteria into restoration planning problems.
They can be used to account for existing land-use practices,
feasibility of restoration activities, and stakeholder preferences.
For example, locked out constraints can be used to
ensure that urban areas are not selected for restoration.
Additionally, if restoration activities can only be implemented depending
on certain conditions &ndash; such as places where landscape slope is not
too steep &ndash; then locked out constraints could be used to ensure
restoration activities are not prioritized for places where they
could not be implemented.
Furthermore, if stakeholders require solutions that do not prioritize
particular places for restoration, then locked out constraints
can also be used to achieve this.
See <code>add_available_areas_constraint()</code>, which achieve the same as the locked
out constraint by defining areas that ARE available for restoration.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_iic_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)

</code></pre>

<hr>
<h2 id='add_min_iic_constraint'>Add constraint to enforce a minimum integral index of connectivity (IIC) value</h2><span id='topic+add_min_iic_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify the minimum integral index of connectivity of a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_min_iic_constraint(
  problem,
  min_iic,
  distance_threshold = -1,
  unit = "m",
  precision = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_min_iic_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_min_iic_constraint_+3A_min_iic">min_iic</code></td>
<td>
<p><code>numeric</code> Minimum IIC value (between 0 and 1).</p>
</td></tr>
<tr><td><code id="add_min_iic_constraint_+3A_distance_threshold">distance_threshold</code></td>
<td>
<p><code>numeric</code> greater than 0. Minimum distance (in
<code>unit</code>) between two patches to consider them connected in the computation of
the IIC. The default value -1 causes the function to use 1 aggregated cell as
the distance threshold.</p>
</td></tr>
<tr><td><code id="add_min_iic_constraint_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a distance
unit (see <code>unit</code> package), or &quot;cells&quot; for cell width of aggregated
habitat raster. Units of the <code>distance_threshold</code> parameter. If the input
habitat raster does not use a projected coordinate system, only &quot;cells&quot; is
available. Meters by default, expected if <code>distance_threshold</code> is set to its
default value (-1), which causes the function to use 1 cell by default.</p>
</td></tr>
<tr><td><code id="add_min_iic_constraint_+3A_precision">precision</code></td>
<td>
<p><code>integer</code> Precision for calculations.
Defaults to 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integral index of connectivity (IIC) is a graph-based inter-patch
connectivity index based on a binary connection model (Pascual-Hortal &amp;
Saura, 2006). Its maximization in the context of restoration favours
restoring the structural connectivity between large patches. IIC is unitless
and comprised between 0 (no connectivity) and 1 (all the landscape is
habitat, thus fully connected). The <code>distance_threshold</code> parameter indicates
to the solver how to construct the habitat graph, i.e. what is the minimum
distance between two patches to consider them as connected. Note that, as
the computation occurs on aggregated cells, if <code>distance_threshold</code> is used
with a different unit than &quot;cells&quot;, it will be rounded to the closest
corresponding number of cells.
</p>
<p>The effective mesh size (MESH) is a measure of landscape fragmentation
based on the probability that two randomly chosen points are located in the
same patch (Jaeger, 2000). Maximizing it in the context of restoration
favours fewer and larger patches.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>References</h3>

<p>Pascual-Hortal, L., &amp; Saura, S. (2006).
Comparison and development of new graph-based landscape connectivity indices:
Towards the priorization of habitat patches and corridors for conservation.
Landscape Ecology, 21(7), 959‑967. https://doi.org/10.1007/s10980-006-0013-z
</p>


<h3>See Also</h3>

<p><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>
</p>
<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_min_iic_constraint(0.2) %&gt;%
  add_restorable_constraint(
    min_restore = 200,
    max_restore = 300,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_compactness_constraint(2500, unit = "m") %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_min_mesh_constraint'>Add constraint to enforce a minimum effective mesh size (MESH) value</h2><span id='topic+add_min_mesh_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify the minimum effective mesh size of a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_min_mesh_constraint(problem, min_mesh, precision = 4, unit = "ha")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_min_mesh_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_min_mesh_constraint_+3A_min_mesh">min_mesh</code></td>
<td>
<p><code>numeric</code> Minimum MESH value.</p>
</td></tr>
<tr><td><code id="add_min_mesh_constraint_+3A_precision">precision</code></td>
<td>
<p><code>integer</code> Precision for calculations.
Defaults to 4.</p>
</td></tr>
<tr><td><code id="add_min_mesh_constraint_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to an area
unit (see <code>unit</code> package), or &quot;cells&quot; for cell width of aggregated
habitat raster. Corresponds to the unit of the minimum mesh value If the
input habitat raster does not use a projected coordinate system, only &quot;cells&quot;
is available. Defaults to &quot;ha&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective mesh size (MESH) is a measure of landscape fragmentation
based on the probability that two randomly chosen points are located in the
same patch (Jaeger, 2000). Maximizing it in the context of restoration
favours fewer and larger patches.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>References</h3>

<p>Jaeger, J. A. G. (2000). Landscape division, splitting index, and effective
mesh size: New measures of landscape fragmentation. Landscape Ecology, 15(2),
115‑130. https://doi.org/10.1023/A:1008129329289
</p>


<h3>See Also</h3>

<p><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>
</p>
<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_restorable_constraint">add_restorable_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_restorable_constraint(
    min_restore = 200,
    max_restore = 300,
  ) %&gt;%
  add_min_mesh_constraint(min_mesh = 2500, unit = "ha")

# plot preprocessed data
plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)

# print problem
print(p)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_restorable_constraint'>Add constraint to specify the available amount of surface for restoration</h2><span id='topic+add_restorable_constraint'></span>

<h3>Description</h3>

<p>Add constraint to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to specify specify the available amount of surface for restoration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_restorable_constraint(
  problem,
  min_restore,
  max_restore,
  min_proportion = 1,
  unit = "ha"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_restorable_constraint_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_restorable_constraint_+3A_min_restore">min_restore</code></td>
<td>
<p><code>numeric</code> Minimum allowed area to restore in the solution.</p>
</td></tr>
<tr><td><code id="add_restorable_constraint_+3A_max_restore">max_restore</code></td>
<td>
<p><code>numeric</code> Maximum allowed area to restore in the solution</p>
</td></tr>
<tr><td><code id="add_restorable_constraint_+3A_min_proportion">min_proportion</code></td>
<td>
<p><code>float</code> Minimum habitat proportion to consider a cell
as restored.</p>
</td></tr>
<tr><td><code id="add_restorable_constraint_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to an area
unit (see <code>unit</code> package), or &quot;cells&quot; for number of cells from the original
habitat raster). If the input habitat raster does not use a projected
coordinate system, only &quot;cells&quot; is available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the <code>restorable_habitat</code> input raster in <a href="#topic+restopt_problem">restopt_problem</a>,
this constraint ensures that the total amount of restorable habitat in
selected planning units is at least <code>min_restore</code> and at most <code>max_restore</code>.
The unit of <code>min_restore</code> and <code>max_restore</code> can be either in a surface unit handled
by the <code>unit</code> package, or in number of cells from the original habitat input raster
(&quot;cells&quot;). The <code>min_proportion</code> parameter is a numeric between 0 and 1, and
correspond to the minimum proportion of habitat area that needs to be restored
in the planning unit to consider the planning unit as restored. This proportion
is relative to the area of a planning unit, which is computed automatically
from the input habitat raster. Note that planning unit area is considered
uniform, and the distortion is not corrected. It could be using the <code>cellSize</code>
function of the <code>terra</code> package, but this function is currently pretty slow
for large rasters. If your problem is at regional scale, the distortion
should be negligible. However, at larger scales, the best is to use an
equal-area projected coordinate system.
</p>
<p>Note that when a solution is found, the &quot;maximum restorable habitat&quot; is
displayed, this value does not correspond to the <code>max_restore</code> parameter,
but to the total area that can be restored in the selected planning units.
The <code>max_restore</code> parameter is actually an upper bound of the minimum habitat
that needs to be restored to reach the <code>min_proportion</code> of habitat in every
selected planning units.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_available_areas_constraint">add_available_areas_constraint</a>()</code>,
<code><a href="#topic+add_compactness_constraint">add_compactness_constraint</a>()</code>,
<code><a href="#topic+add_components_constraint">add_components_constraint</a>()</code>,
<code><a href="#topic+add_connected_constraint">add_connected_constraint</a>()</code>,
<code><a href="#topic+add_locked_out_constraint">add_locked_out_constraint</a>()</code>,
<code><a href="#topic+add_min_iic_constraint">add_min_iic_constraint</a>()</code>,
<code><a href="#topic+add_min_mesh_constraint">add_min_mesh_constraint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_restorable_constraint(
    min_restore = 200,
    max_restore = 300,
    min_proportion = 0.7
  ) %&gt;%
  add_compactness_constraint(5, unit = "cells")

# print problem
print(p)

# plot preprocessed data
plot(rast(list(get_existing_habitat(p),
               get_restorable_habitat(p),
               get_locked_out_areas(p))), nc = 3)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='add_settings'>Add settings</h2><span id='topic+add_settings'></span>

<h3>Description</h3>

<p>Add settings to a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object
to customize the optimization procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_settings(
  problem,
  precision = 4,
  time_limit = 0,
  nb_solutions = 1,
  optimality_gap = 0,
  solution_name_prefix = "Solution "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_settings_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="add_settings_+3A_precision">precision</code></td>
<td>
<p><code>integer</code> Precision for calculations.
Defaults to 4.</p>
</td></tr>
<tr><td><code id="add_settings_+3A_time_limit">time_limit</code></td>
<td>
<p><code>integer</code> Maximum permitted run time for optimization
(seconds).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="add_settings_+3A_nb_solutions">nb_solutions</code></td>
<td>
<p><code>integer</code> Number of desired solutions. Defaults to 1.</p>
</td></tr>
<tr><td><code id="add_settings_+3A_optimality_gap">optimality_gap</code></td>
<td>
<p><code>numeric</code> Optimality gap (between 0 and 1).
For example, an argument of 0.1 means that solutions should be within 10%
of optimality.
Defaults to 0, such that optimal solutions are returned.</p>
</td></tr>
<tr><td><code id="add_settings_+3A_solution_name_prefix">solution_name_prefix</code></td>
<td>
<p><code>character</code> Prefix for the name of solutions.
Defaults to &quot;Solution &quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  add_settings(time_limit = 1, precision = 4, nb_solutions = 2)
# print problem
print(p)

</code></pre>

<hr>
<h2 id='area_to_nb_cells'>Compute the number of cells corresponding to a given area.</h2><span id='topic+area_to_nb_cells'></span>

<h3>Description</h3>

<p>Compute the number of cells corresponding to a given area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_to_nb_cells(raster_layer, area, unit = "ha")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_to_nb_cells_+3A_raster_layer">raster_layer</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object.</p>
</td></tr>
<tr><td><code id="area_to_nb_cells_+3A_area">area</code></td>
<td>
<p><code>numeric</code> Area.</p>
</td></tr>
<tr><td><code id="area_to_nb_cells_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a unit
(see <code>unit</code> package). Must be an area unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input raster must have a projected coordinate system. The distortion is
not corrected. It could be using the <code>cellSize</code> function of the <code>terra</code>
package, but this function is currently pretty slow for large rasters. If
your problem is at regional scale, the distortion should be negligible.
However, at larger scales, the best is to use an equal-area projected
coordinate system.
</p>


<h3>Value</h3>

<p><code>numeric</code> The number of raster cell correspond to the given area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
area_to_nb_cells(habitat_data, 20, unit = "ha")


</code></pre>

<hr>
<h2 id='cell_area'>Compute the area of a cell</h2><span id='topic+cell_area'></span>

<h3>Description</h3>

<p>Compute the area of a cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_area(raster_layer, unit = "ha")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_area_+3A_raster_layer">raster_layer</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object.</p>
</td></tr>
<tr><td><code id="cell_area_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a unit
(see <code>unit</code> package). Must be an area unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input raster must have a projected coordinate system. The distortion is
not corrected. It could be using the <code>cellSize</code> function of the <code>terra</code>
package, but this function is currently pretty slow for large rasters. If
your problem is at regional scale, the distortion should be negligible.
However, at larger scales, the best is to use an equal-area projected
coordinate system.
</p>


<h3>Value</h3>

<p><code>numeric</code> The area of a cell in the desired unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
cell_area(habitat_data, "ha")


</code></pre>

<hr>
<h2 id='cell_width'>Compute the width of a cell</h2><span id='topic+cell_width'></span>

<h3>Description</h3>

<p>Compute the width of a cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_width(raster_layer, unit = "m")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_width_+3A_raster_layer">raster_layer</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object.</p>
</td></tr>
<tr><td><code id="cell_width_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a unit
(see <code>unit</code> package). Must be an length unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input raster must have a projected coordinate system. The distortion is
not corrected. It could be using the <code>cellSize</code> function of the <code>terra</code>
package, but this function is currently pretty slow for large rasters. If
your problem is at regional scale, the distortion should be negligible.
However, at larger scales, the best is to use an equal-area projected
coordinate system.
</p>


<h3>Value</h3>

<p><code>numeric</code> The width of a cell in the desired unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
cell_width(habitat_data, "m")


</code></pre>

<hr>
<h2 id='get_aggregation_factor'>Retrieve the aggregation factor of a restopt problem.</h2><span id='topic+get_aggregation_factor'></span>

<h3>Description</h3>

<p>Retrieve the aggregation factor of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_aggregation_factor(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_aggregation_factor_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> The aggregation factor of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_aggregation_factor(problem)


</code></pre>

<hr>
<h2 id='get_cell_area'>Retrieve the aggregated cell area of a restopt problem.</h2><span id='topic+get_cell_area'></span>

<h3>Description</h3>

<p>Retrieve the aggregated cell area of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cell_area(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cell_area_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> The aggregated cell area of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_cell_area(problem)


</code></pre>

<hr>
<h2 id='get_constraints'>Retrieve the constraints of a restopt problem.</h2><span id='topic+get_constraints'></span>

<h3>Description</h3>

<p>Retrieve the constraints of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_constraints(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_constraints_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> The constraints of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_constraints(problem)


</code></pre>

<hr>
<h2 id='get_existing_habitat'>Retrieve the existing (i.e. aggregated) habitat data.</h2><span id='topic+get_existing_habitat'></span>

<h3>Description</h3>

<p>Retrieve the existing (i.e. aggregated) habitat data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_existing_habitat(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_existing_habitat_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> The existing (aggregated) habitat data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

plot(get_existing_habitat(problem))


</code></pre>

<hr>
<h2 id='get_habitat_threshold'>Retrieve the habitat threshold parameter of a restopt problem.</h2><span id='topic+get_habitat_threshold'></span>

<h3>Description</h3>

<p>Retrieve the habitat threshold parameter of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_habitat_threshold(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_habitat_threshold_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> The habitat threshold parameter of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_habitat_threshold(problem)


</code></pre>

<hr>
<h2 id='get_locked_out_areas'>Retrieve the locked out areas of a restopt problem.</h2><span id='topic+get_locked_out_areas'></span>

<h3>Description</h3>

<p>Retrieve the locked out areas of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_locked_out_areas(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_locked_out_areas_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> The locked out areas of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_locked_out_areas(problem)


</code></pre>

<hr>
<h2 id='get_metadata'>Restopt solution metadata</h2><span id='topic+get_metadata'></span>

<h3>Description</h3>

<p>Return the metadata associated with a restopt solution, which contains
the characteristics of the solution. The unit for area characteristics
can be chosen among &quot;ha&quot; (hectares), &quot;m&quot; (square meters), &quot;km&quot; (square
kilometers), and &quot;cells&quot; (cells from the original input habitat raster).
Note that the solving time is expressed in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata(restopt_solution, area_unit = "ha", distance_unit = "m")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metadata_+3A_restopt_solution">restopt_solution</code></td>
<td>
<p><code><a href="#topic+restopt_solution">restopt_solution()</a></code> Restopt solution
to this solution.</p>
</td></tr>
<tr><td><code id="get_metadata_+3A_area_unit">area_unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to an area
unit (see <code>unit</code> package), or &quot;cells&quot; for number of cells from the original
habitat raster). Unit for areas. If the input habitat raster does not use a projected
coordinate system, only &quot;cells&quot; is available. Default is &quot;ha&quot;</p>
</td></tr>
<tr><td><code id="get_metadata_+3A_distance_unit">distance_unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to an area
unit (see <code>unit</code> package), or &quot;cells&quot; for number of cell width from the original
habitat raster). Unit for distances. If the input habitat raster does not use a projected
coordinate system, only &quot;cells&quot; is available. Default is &quot;m&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the characteristics of the restopt solution.
</p>

<hr>
<h2 id='get_objective'>Retrieve the optimization objective of a restopt problem.</h2><span id='topic+get_objective'></span>

<h3>Description</h3>

<p>Retrieve the optimization objective of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RestoptObjectve</code> The optimization objective of the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_objective(problem)


</code></pre>

<hr>
<h2 id='get_original_habitat'>Retrieve the original (i.e. not aggregated) habitat data.</h2><span id='topic+get_original_habitat'></span>

<h3>Description</h3>

<p>Retrieve the original (i.e. not aggregated) habitat data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_original_habitat(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_original_habitat_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> The original (i.e. not aggregated) habitat data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

plot(get_original_habitat(problem))


</code></pre>

<hr>
<h2 id='get_restorable_habitat'>Retrieve the restorable habitat (aggregated) data.</h2><span id='topic+get_restorable_habitat'></span>

<h3>Description</h3>

<p>Retrieve the restorable habitat (aggregated) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_restorable_habitat(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_restorable_habitat_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> The restorable habitat (aggregated) data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

plot(get_restorable_habitat(problem))


</code></pre>

<hr>
<h2 id='get_settings'>Retrieve the settings of a restopt problem.</h2><span id='topic+get_settings'></span>

<h3>Description</h3>

<p>Retrieve the settings of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_settings(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_settings_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> The settings associated with the restopt problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
problem &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

get_settings(problem)


</code></pre>

<hr>
<h2 id='invert_vector'>Invert a vector layer according to the extent of a restopt problem.</h2><span id='topic+invert_vector'></span>

<h3>Description</h3>

<p>Invert a vector layer according to the extent of a restopt problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_vector(vector_layer, extent = NULL, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_vector_+3A_vector_layer">vector_layer</code></td>
<td>
<p><code><a href="terra.html#topic+vect">terra::vect()</a></code> Vector layer.</p>
</td></tr>
<tr><td><code id="invert_vector_+3A_extent">extent</code></td>
<td>
<p><code><a href="terra.html#topic+SpatExtent">SpatExtent</a></code> Optional: you can specify another extent as the
input vector layer extent for the inversion.</p>
</td></tr>
<tr><td><code id="invert_vector_+3A_filter">filter</code></td>
<td>
<p>Optional: filter to apply to <code>x</code>. Leave NULL for no filtering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invert a vector layer according to its extent, or a user-specified extent.
This function is useful to derive locked out areas from accessible areas,
e.g. buffer around tracks.
</p>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+vect">terra::vect()</a></code> Vector object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
available &lt;- vect(
  system.file("extdata", "accessible_areas.gpkg", package = "restoptr")
)
locked_out &lt;- invert_vector(
  vector_layer = available,
  extent = ext(habitat_data),
  filter = available$ID==2
)


</code></pre>

<hr>
<h2 id='is_java_available'>Is Java is available?</h2><span id='topic+is_java_available'></span>

<h3>Description</h3>

<p>The <span class="pkg">restoptr</span> package uses Java to perform optimization procedures.
As such, it is important that Java is installed correctly when using this
package. This function verifies if Java is available on the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_java_available()
</code></pre>


<h3>Value</h3>

<p>A <code>logical</code> (<code>TRUE</code> or <code>FALSE</code>) value indicating if Java is available
for usage.
</p>

<hr>
<h2 id='nb_cell_to_area'>Compute the area corresponding to a given number of cells.</h2><span id='topic+nb_cell_to_area'></span>

<h3>Description</h3>

<p>Compute the area corresponding to a given number of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_cell_to_area(raster_layer, nb_cells, unit = "ha")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_cell_to_area_+3A_raster_layer">raster_layer</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object.</p>
</td></tr>
<tr><td><code id="nb_cell_to_area_+3A_nb_cells">nb_cells</code></td>
<td>
<p><code>numeric</code> Number of raster cells.</p>
</td></tr>
<tr><td><code id="nb_cell_to_area_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a unit
(see <code>unit</code> package). Must be an area unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input raster must have a projected coordinate system. The distortion is
not corrected. It could be using the <code>cellSize</code> function of the <code>terra</code>
package, but this function is currently pretty slow for large rasters. If
your problem is at regional scale, the distortion should be negligible.
However, at larger scales, the best is to use an equal-area projected
coordinate system.
</p>


<h3>Value</h3>

<p><code>numeric</code> The area corresponding to <code>nb_cells</code> in the desired unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
nb_cell_to_area(habitat_data, 20, unit = "ha")


</code></pre>

<hr>
<h2 id='preprocess_input'>Restopr input preprocessing function.</h2><span id='topic+preprocess_input'></span>

<h3>Description</h3>

<p>From a binary, possibly high resolution, habitat raster, this function
produces three input rasters for restopt:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_input(habitat, habitat_threshold = 1, aggregation_factor = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_input_+3A_habitat">habitat</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object containing binary
values that indicate if each planning unit contains habitat or not. Cells
with the value <code>1</code> must correspond to existing habitat. Cells with the value
<code>0</code> must correspond to degraded (or simply non-habitat) areas. Finally,
<code>NA</code> (or <code>NO_DATA</code>) cells are considered to be outside of the landscape.</p>
</td></tr>
<tr><td><code id="preprocess_input_+3A_habitat_threshold">habitat_threshold</code></td>
<td>
<p><code>numeric</code> Number between 0 and 1 indicating, when the habitat
raster is downsampled, the minimum proportion of habitat cells (from the
original raster) are required within the downsampled raster to be considered
as habitat.</p>
</td></tr>
<tr><td><code id="preprocess_input_+3A_aggregation_factor">aggregation_factor</code></td>
<td>
<p><code>integer</code> positive integer corresponding to the level of
downsampling that will be applied to the habitat. This parameter is
important to ensure the tractability of a problem.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The binary habitat raster (existing_habitat), which can be the same as
the input (aggregation factor = 1), but most often is a downsampled
version of it, to ensure the tractability of the problem.
</p>
</li>
<li><p> The restorable habitat raster (restorable_habitat), which is a raster
indicating how much habitat can be restored. If the aggregation factor = 1,
the the restorable habitat raster is binary and the inverse of the habitat
raster. Else, the surface of habitat is computed according to the spatial
resolution, and the number of habitat pixel present in one larger
aggregated cell.
</p>
</li>
<li><p> The cell area raster (cell_area), which correspond for each aggregated
cell to the number of number of cells in the input raster. This is
necessary because the cell area can be less than expected if the
aggregated cell lies in the boundary of study area.
</p>
</li></ul>

<p>This preprocessing function produces the necessary inputs of a
restopt problem from a single binary habitat raster (<code>habitat</code>), which can
be at high resolution. Restopt solves a hard constrained combinatorial problem
(it can be reduced to a constrained 0/1 knapsack problem, which is know to
be NP-Complete), thus the input resolution might need to be reduced to
ensure a tractable problem. Performing this downsampling in a systematic
and reproducible way is the aim of this function, which relies on the
<code>terra::aggregate()</code> function to do it. The <code>aggregation_factor</code> parameter
indicates how much the resolution must be reduced. An aggregated pixel
will contain at most <code>aggregation_factor^2</code> pixels from the input <code>habitat</code>
raster (<code>cell_area</code> raster in this function outputs). If an aggregated pixel
is close to the spatial boundaries of the problem (i.e. NA cells), it can
contain less than <code>aggregation_factor^2</code> fine grained pixels. The
<code>habitat_threshold</code> parameter indicates the minimum proportion of <code>habitat</code>
pixels (relative to <code>cell_area</code>) whose value is 1 to consider an aggregated
pixel as habitat (<code>downsampled_habitat</code> output raster). The <code>restorable_area</code>
output raster correspond to the number of pixel with value 0 in aggregated pixels.
</p>


<h3>Value</h3>

<p>A list : list(
existing_habitat=downsampled_habitat,
restorable_habitat=restorable_habitat,
cell_area=cell_area
)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr"))
data &lt;- preprocess_input(
    habitat = habitat_data,
    habitat_threshold = 0.7,
    aggregation_factor = 16
)


</code></pre>

<hr>
<h2 id='print.RestoptProblem'>Print a restoration optimization problem</h2><span id='topic+print.RestoptProblem'></span>

<h3>Description</h3>

<p>Display information about a restoration optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RestoptProblem'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.RestoptProblem_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="print.RestoptProblem_+3A_...">...</code></td>
<td>
<p>Arguments not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#' # load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

# print problem
print(p)


</code></pre>

<hr>
<h2 id='restopt_problem'>Restoration optimization problem</h2><span id='topic+restopt_problem'></span>

<h3>Description</h3>

<p>Create a new restoration optimization problem (<code>RestoptProblem</code>) using data
that describe the spatial distribution of existing habitat (potentially at
high resolution), and parameters to derive a downsampled existing habitat
raster, suitable for a tractable optimization, and a restorable habitat
raster. Constraints can be added to a restopt problem using
<code style="white-space: pre;">&#8288;add_****_constraint()&#8288;</code> functions, and an optimization objective can be set
using <code style="white-space: pre;">&#8288;set_****_objective()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restopt_problem(
  existing_habitat,
  habitat_threshold = 1,
  aggregation_factor = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restopt_problem_+3A_existing_habitat">existing_habitat</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Raster object containing binary
values that indicate if each planning unit contains habitat or not. Cells
with the value <code>1</code> must correspond to existing habitat. Cells with the value
<code>0</code> must correspond to degraded (or simply non-habitat) areas. Finally,
<code>NA</code> (or <code>NO_DATA</code>) cells are considered to be outside of the landscape.
This raster can have a high resolution, the <code>aggregation_factor</code> and the
<code>habitat_threshold</code> parameters, described below, will be used to down sample
the habitat raster to a tractable resolution for the optimization engine, and
automatically derive the restorable habitat raster.</p>
</td></tr>
<tr><td><code id="restopt_problem_+3A_habitat_threshold">habitat_threshold</code></td>
<td>
<p><code>numeric</code> number between 0 and 1, which corresponds to the
minimum proportion of habitat that must be present within an aggregated pixel
to consider it as an habitat pixel.</p>
</td></tr>
<tr><td><code id="restopt_problem_+3A_aggregation_factor">aggregation_factor</code></td>
<td>
<p><code>integer</code> Integer greater than 1, which corresponds to the
aggregation factor for down sampling the data. For example, if
<code>aggregation_factor = 2</code>, aggregated pixel will contain 4 original pixel.
See <code>terra::aggregate()</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates the base restoration optimization problem
object, that can be further extended with constraints and optimization
objectives. One input rasters is necessary to instantiate a restopt problem:
the <code>existing_habitat</code> raster (potentially with high resolution). This raster
must contains data about where are habitat areas (raster value <code>1</code>),
non-habitat areas (raster value <code>0</code>), and areas that must not be considered
during the solving procedure (<code>NA</code> or <code>NO_DATA</code>). The <code>aggregation_factor</code>
parameter is used to down sample the <code>existing_habitat</code> to a resolution that
will be tractable for the optimization engine, and the <code>habitat_threshold</code>
parameter indicates the minimum proportion of habitat required in aggregated
habitat pixels to consider them as habitat. Note that An aggregated pixel
will contain at most <code>aggregation_factor^2</code> pixels from the input <code>habitat</code>
raster (<code>cell_area</code> raster in this function outputs). If an aggregated pixel
is close to the spatial boundaries of the problem (i.e. NA cells), it can
contain less than <code>aggregation_factor^2</code> fine grained pixel. You can get
the results of this preprocessing phase using the following methods:
<code>get_original_habitat()</code> (original habitat), <code>get_existing_habitat()</code>
(aggregated habitat), <code>get_cell_area()</code> (number of pixels in each aggregated
cells), and <code>get_restorable_area()</code> (amount of restorable area &ndash; in number
of original raster pixels).
</p>


<h3>Value</h3>

<p>A new restoration problem (<code>RestoptProblem</code>) object.
</p>
<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
       existing_habitat = habitat_data,
       aggregation_factor = 4,
       habitat_threshold = 0.7
)

# Plot down sampled data
plot(c(p$data$existing_habitat, p$data$restorable_habitat))

# print problem
print(p)


</code></pre>

<hr>
<h2 id='restopt_solution'>Restopt solution</h2><span id='topic+restopt_solution'></span>

<h3>Description</h3>

<p>An object representing a restopt problem solution. It is basically a
SpatRaster with a few metadata attributes added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restopt_solution(restopt_problem, solution_raster, metadata, id_solution = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restopt_solution_+3A_restopt_problem">restopt_problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Reference to the problem corresponding
to this solution.</p>
</td></tr>
<tr><td><code id="restopt_solution_+3A_solution_raster">solution_raster</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> Solution raster.</p>
</td></tr>
<tr><td><code id="restopt_solution_+3A_metadata">metadata</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> List containing metadata attributes of the solution.</p>
</td></tr>
<tr><td><code id="restopt_solution_+3A_id_solution">id_solution</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code> Identifier of the solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new restoration problem solution (<code>restopt_solution()</code>).
</p>

<hr>
<h2 id='restoptr'><code>restoptr</code>: Ecological Restoration Planning</h2><span id='topic+restoptr'></span>

<h3>Description</h3>

<p>The <code>restoptr</code> package relies on Constraint Programming (CP) to build and
solve ecological restoration planning problems. A <code>restoptr</code> problem starts
from an existing habitat (raster), where the aim is to identify optimal areas
that are suitable for restoration. Several constraints are available to define
what is expected for a suitable area for (e.g. it must be connected, compact,
must respect a budget, etc). Several optimization objective are also available
to define what is a good restoration area (e.g. it must reduce fragmentation,
increase ecological connectivity, minimize costs, etc.). <code>restoptr</code> relies on
advanced landscape indices such as the effective mesh size (Jaeger, 2000),
or the integral index of connectivity (Pascual-Hortal &amp; Saura, 2006) to address
complex restoration planning problems.
</p>


<h3>Details</h3>

<p><code>restoptr</code> relies on Choco-solver (https://choco-solver.org/), an open-source
Java CP solver (Prud'homme et al., 2017). The computationally intensive solving
part is thus delegated to Java (see <code>restopt</code>, https://github.com/dimitri-justeau/restopt),
and the communication between R and Java is handled with the <code>rJava</code> package.
Therefore, a Java Runtime Environment (&gt;= 8) is necessary to use <code>restopt</code>.
</p>
<p>Note that the methodology used in <code>restoptr</code> was first described in
Justeau-Allaire et al. (2021), but <code>restoptr</code> provides much more flexibility,
new features (e.g. reliable and consistent data preprocessing), new constraints,
new optimization objectives, and an improved computational efficiency. Also
note that the API was inspired by the <code>prioritizr</code> package.
</p>
<p>This package contains several vignettes to detail its usage and
showcase its features. You can explore these vignettes using
<code>browseVignettes("restoptr")</code>
</p>


<h3>References</h3>

<p>Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts ME,
Arcese P, Bennett J, Possingham HP (2022). prioritizr: Systematic Conservation
Prioritization in R. R package version 7.1.1. Available at
https://CRAN.R-project.org/package=prioritizr.
</p>
<p>Jaeger, J. A. G. (2000). Landscape division, splitting index, and effective
mesh size: New measures of landscape fragmentation. Landscape Ecology, 15(2),
115‑130.
</p>
<p>Justeau-Allaire, D., Vieilledent, G., Rinck, N., Vismara, P., Lorca, X.,
&amp; Birnbaum, P. (2021). Constrained optimization of landscape indices in
conservation planning to support ecological restoration in New Caledonia.
Journal of Applied Ecology, 58(4), 744‑754.
</p>
<p>Pascual-Hortal, L., &amp; Saura, S. (2006).
Comparison and development of new graph-based landscape connectivity indices:
Towards the priorization of habitat patches and corridors for conservation.
Landscape Ecology, 21(7), 959‑967.
</p>
<p>Prud'homme, C., Fages, J.-G., &amp; Lorca, X. (2017). Choco documentation.
</p>

<hr>
<h2 id='set_max_iic_objective'>Set an objective to maximize the integral index of connectivity</h2><span id='topic+set_max_iic_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should
the integral index of connectivity (IIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_max_iic_objective(problem, distance_threshold = -1, unit = "m")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_max_iic_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="set_max_iic_objective_+3A_distance_threshold">distance_threshold</code></td>
<td>
<p><code>numeric</code> greater than 0. Minimum distance (in
<code>unit</code>) between two patches to consider them connected in the computation of
the IIC. The default value -1 causes the function to use 1 aggregated cell as
the distance threshold.</p>
</td></tr>
<tr><td><code id="set_max_iic_objective_+3A_unit">unit</code></td>
<td>
<p><code>unit</code> object or a <code>character</code> that can be coerced to a distance
unit (see <code>unit</code> package), or &quot;cells&quot; for cell width of aggregated
habitat raster. Units of the <code>distance_threshold</code> parameter. If the input
habitat raster does not use a projected coordinate system, only &quot;cells&quot; is
available. Meters by default, expected if <code>distance_threshold</code> is set to its
default value (-1), which causes the function to use 1 cell by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integral index of connectivity (IIC) is a graph-based inter-patch
connectivity index based on a binary connection model (Pascual-Hortal &amp;
Saura, 2006). Its maximization in the context of restoration favours
restoring the structural connectivity between large patches. IIC is unitless
and comprised between 0 (no connectivity) and 1 (all the landscape is
habitat, thus fully connected). The <code>distance_threshold</code> parameter indicates
to the solver how to construct the habitat graph, i.e. what is the minimum
distance between two patches to consider them as connected. Note that, as
the computation occurs on aggregated cells, if <code>distance_threshold</code> is used
with a different unit than &quot;cells&quot;, it will be rounded to the closest
corresponding number of cells.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code> object.
</p>


<h3>References</h3>

<p>Pascual-Hortal, L., &amp; Saura, S. (2006).
Comparison and development of new graph-based landscape connectivity indices:
Towards the priorization of habitat patches and corridors for conservation.
Landscape Ecology, 21(7), 959‑967. https://doi.org/10.1007/s10980-006-0013-z
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_iic_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_max_mesh_objective'>Set an objective to maximize effective mesh size</h2><span id='topic+set_max_mesh_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should
maximize effective mesh size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_max_mesh_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_max_mesh_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective mesh size (MESH) is a measure of landscape fragmentation
based on the probability that two randomly chosen points are located in the
same patch (Jaeger, 2000). Maximizing it in the context of restoration
favours fewer and larger patches.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>References</h3>

<p>Jaeger, J. A. G. (2000). Landscape division, splitting index, and effective
mesh size: New measures of landscape fragmentation. Landscape Ecology, 15(2),
115‑130. https://doi.org/10.1023/A:1008129329289
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_mesh_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_max_nb_pus_objective'>Set an objective to maximize the number of planning units</h2><span id='topic+set_max_nb_pus_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should
maximize the number of planning units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_max_nb_pus_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_max_nb_pus_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Planning units correspond to aggregated cells from the original
dataset. Maximizing the number of planning units increased the spatial extent
of the restoration area. This can be useful when the budget is limited and
the aim is to restore the larget possible extent.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_nb_pus_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_max_restore_objective'>Set an objective to maximize the amount restoration area.</h2><span id='topic+set_max_restore_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should maximize
the restoration area needed to reach the habitat proportion threshold
specified in the problem description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_max_restore_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_max_restore_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The restoration area corresponds to the minimum amount of area that
must be restored in the selected planning units to reach the minimum habitat
proportion threshold specified in the problem description,
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_restore_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_min_nb_pus_objective'>Set an objective to minimize the number of planning units</h2><span id='topic+set_min_nb_pus_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should
minimize the number of planning units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_min_nb_pus_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_min_nb_pus_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Planning units correspond to aggregated cells from the original
dataset. Minimizing the number of planning units reduces the spatial extent
of the restoration area.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_min_nb_pus_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_min_restore_objective'>Set an objective to minimize the amount restoration area.</h2><span id='topic+set_min_restore_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should minimize
the restoration area needed to reach the habitat proportion threshold
specified in the problem description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_min_restore_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_min_restore_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The restoration area corresponds to the minimum amount of area that
must be restored in the selected planning units to reach the minimum habitat
proportion threshold specified in the problem description,
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_no_objective">set_no_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

locked_out_data &lt;- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)

# plot data
plot(rast(list(habitat_data, locked_out_data)), nc = 2)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_min_restore_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_locked_out_constraint(data = locked_out_data) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='set_no_objective'>Configure the solver to only satisfy the constraints, without optimization
objective</h2><span id='topic+set_no_objective'></span>

<h3>Description</h3>

<p>Specify that a restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) should satisfy
the constraints without optimization objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_no_objective(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_no_objective_+3A_problem">problem</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using set_no_objective() in a restopt problem, the solver will
return the first solution found satisfying the constraint, without any
optimization objective. This &quot;no objective&quot; setting is set by default
when creating a restopt problem.
</p>


<h3>Value</h3>

<p>An updated restoration problem (<code><a href="#topic+restopt_problem">restopt_problem()</a></code>) object.
</p>


<h3>See Also</h3>

<p>Other objectives: 
<code><a href="#topic+set_max_iic_objective">set_max_iic_objective</a>()</code>,
<code><a href="#topic+set_max_mesh_objective">set_max_mesh_objective</a>()</code>,
<code><a href="#topic+set_max_nb_pus_objective">set_max_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_max_restore_objective">set_max_restore_objective</a>()</code>,
<code><a href="#topic+set_min_nb_pus_objective">set_min_nb_pus_objective</a>()</code>,
<code><a href="#topic+set_min_restore_objective">set_min_restore_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

# create problem
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;% set_no_objective()

# print problem
print(p)

# Solve problem
s &lt;- solve(p)
# plot solution
plot(s)


</code></pre>

<hr>
<h2 id='solve.RestoptProblem'>Solve a restoration optimization problem</h2><span id='topic+solve.RestoptProblem'></span>

<h3>Description</h3>

<p>Solve a restoration optimization problem to generate a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RestoptProblem'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve.RestoptProblem_+3A_a">a</code></td>
<td>
<p><code><a href="#topic+restopt_problem">restopt_problem()</a></code> Restoration problem object.</p>
</td></tr>
<tr><td><code id="solve.RestoptProblem_+3A_b">b</code></td>
<td>
<p>Argument not used.</p>
</td></tr>
<tr><td><code id="solve.RestoptProblem_+3A_...">...</code></td>
<td>
<p>Additional arguments:
<code>verbose</code>: if TRUE, output solver logs. (FALSE by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on the Choco-solver (https://choco-solver.org/)
to solve a restoration optimization problem. If the solver finds a solution,
it outputs a raster with 5 possible values:
NA : NA (or NO_DATA) areas from the input habitat raster.
0 : non-habitat areas that were locked out.
1 : non-habitat areas that were available for selection.
2 : habitat areas.
3 : selected planning units for restoration.
If the solve function return a no-solution error, it is either because the
solver could not find a solution within the time limit that was set
(see <a href="#topic+add_settings">add_settings</a>), or because the solver has detected that this is
not possible to satisfy the constraints (the constraints are contradictory).
In the first case, you can try to increase the time limit.
In the second case, you should modify your targets.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+restopt_solution">restopt_solution()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
habitat_data &lt;- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)

available &lt;- vect(
  system.file("extdata", "accessible_areas.gpkg", package = "restoptr")
)

# create problem with locked out constraints
p &lt;- restopt_problem(
    existing_habitat = habitat_data,
    aggregation_factor = 16,
    habitat_threshold = 0.7
  ) %&gt;%
  set_max_mesh_objective() %&gt;%
  add_restorable_constraint(
    min_restore = 5,
    max_restore = 5,
  ) %&gt;%
  add_available_areas_constraint(available) %&gt;%
  add_settings(time_limit = 1)

# print problem
print(p)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
