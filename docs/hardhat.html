<!DOCTYPE html><html lang="en"><head><title>Help for package hardhat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hardhat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hardhat-package'><p>hardhat: Construct Modeling Packages</p></a></li>
<li><a href='#add_intercept_column'><p>Add an intercept column to <code>data</code></p></a></li>
<li><a href='#check_quantile_levels'><p>Check levels of quantiles</p></a></li>
<li><a href='#contr_one_hot'><p>Contrast function for one-hot encodings</p></a></li>
<li><a href='#default_formula_blueprint'><p>Default formula blueprint</p></a></li>
<li><a href='#default_recipe_blueprint'><p>Default recipe blueprint</p></a></li>
<li><a href='#default_xy_blueprint'><p>Default XY blueprint</p></a></li>
<li><a href='#delete_response'><p>Delete the response from a terms object</p></a></li>
<li><a href='#extract_ptype'><p>Extract a prototype</p></a></li>
<li><a href='#fct_encode_one_hot'><p>Encode a factor as a one-hot indicator matrix</p></a></li>
<li><a href='#forge'><p>Forge prediction-ready data</p></a></li>
<li><a href='#frequency_weights'><p>Frequency weights</p></a></li>
<li><a href='#get_data_classes'><p>Extract data classes from a data frame or matrix</p></a></li>
<li><a href='#get_levels'><p>Extract factor levels from a data frame</p></a></li>
<li><a href='#hardhat-example-data'><p>Example data for hardhat</p></a></li>
<li><a href='#hardhat-extract'><p>Generics for object extraction</p></a></li>
<li><a href='#importance_weights'><p>Importance weights</p></a></li>
<li><a href='#is_blueprint'><p>Is <code>x</code> a preprocessing blueprint?</p></a></li>
<li><a href='#is_case_weights'><p>Is <code>x</code> a case weights vector?</p></a></li>
<li><a href='#is_frequency_weights'><p>Is <code>x</code> a frequency weights vector?</p></a></li>
<li><a href='#is_importance_weights'><p>Is <code>x</code> an importance weights vector?</p></a></li>
<li><a href='#model_frame'><p>Construct a model frame</p></a></li>
<li><a href='#model_matrix'><p>Construct a design matrix</p></a></li>
<li><a href='#model_offset'><p>Extract a model offset</p></a></li>
<li><a href='#modeling-usethis'><p>Create a modeling package</p></a></li>
<li><a href='#mold'><p>Mold data for modeling</p></a></li>
<li><a href='#new_case_weights'><p>Extend case weights</p></a></li>
<li><a href='#new_default_formula_blueprint'><p>Create a new default blueprint</p></a></li>
<li><a href='#new_formula_blueprint'><p>Create a new preprocessing blueprint</p></a></li>
<li><a href='#new_frequency_weights'><p>Construct a frequency weights vector</p></a></li>
<li><a href='#new_importance_weights'><p>Construct an importance weights vector</p></a></li>
<li><a href='#new_model'><p>Constructor for a base model</p></a></li>
<li><a href='#quantile_pred'><p>Create a vector containing sets of quantiles</p></a></li>
<li><a href='#recompose'><p>Recompose a data frame into another form</p></a></li>
<li><a href='#refresh_blueprint'><p>Refresh a preprocessing blueprint</p></a></li>
<li><a href='#run-forge'><p><code>forge()</code> according to a blueprint</p></a></li>
<li><a href='#run-mold'><p><code>mold()</code> according to a blueprint</p></a></li>
<li><a href='#scream'><p>Scream</p></a></li>
<li><a href='#shrink'><p>Subset only required columns</p></a></li>
<li><a href='#spruce'><p>Spruce up predictions</p></a></li>
<li><a href='#spruce-multiple'><p>Spruce up multi-outcome predictions</p></a></li>
<li><a href='#standardize'><p>Standardize the outcome</p></a></li>
<li><a href='#tune'><p>Mark arguments for tuning</p></a></li>
<li><a href='#update_blueprint'><p>Update a preprocessing blueprint</p></a></li>
<li><a href='#validate_column_names'><p>Ensure that <code>data</code> contains required column names</p></a></li>
<li><a href='#validate_no_formula_duplication'><p>Ensure no duplicate terms appear in <code>formula</code></p></a></li>
<li><a href='#validate_outcomes_are_binary'><p>Ensure that the outcome has binary factors</p></a></li>
<li><a href='#validate_outcomes_are_factors'><p>Ensure that the outcome has only factor columns</p></a></li>
<li><a href='#validate_outcomes_are_numeric'><p>Ensure outcomes are all numeric</p></a></li>
<li><a href='#validate_outcomes_are_univariate'><p>Ensure that the outcome is univariate</p></a></li>
<li><a href='#validate_prediction_size'><p>Ensure that predictions have the correct number of rows</p></a></li>
<li><a href='#validate_predictors_are_numeric'><p>Ensure predictors are all numeric</p></a></li>
<li><a href='#weighted_table'><p>Weighted table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Construct Modeling Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Building modeling packages is hard. A large amount of effort
    generally goes into providing an implementation for a new method that
    is efficient, fast, and correct, but often less emphasis is put on the
    user interface. A good interface requires specialized knowledge about
    S3 methods and formulas, which the average package developer might not
    have. The goal of 'hardhat' is to reduce the burden around building
    new modeling packages by providing functionality for preprocessing,
    predicting, and validating input.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/hardhat">https://github.com/tidymodels/hardhat</a>,
<a href="https://hardhat.tidymodels.org">https://hardhat.tidymodels.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/hardhat/issues">https://github.com/tidymodels/hardhat/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.0), glue (&ge; 1.6.2), rlang (&ge; 1.1.0), sparsevctrs
(&ge; 0.2.0), tibble (&ge; 3.2.1), vctrs (&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, devtools, knitr, Matrix, modeldata (&ge; 0.0.2),
recipes (&ge; 1.0.5), rmarkdown (&ge; 2.3), roxygen2, testthat (&ge;
3.0.0), usethis (&ge; 2.1.5), withr (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 15:09:25 UTC; hannah</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Frick <a href="https://orcid.org/0000-0002-6049-5258"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Davis Vaughan [aut],
  Max Kuhn [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah Frick &lt;hannah@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 15:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='hardhat-package'>hardhat: Construct Modeling Packages</h2><span id='topic+hardhat'></span><span id='topic+hardhat-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Building modeling packages is hard. A large amount of effort generally goes into providing an implementation for a new method that is efficient, fast, and correct, but often less emphasis is put on the user interface. A good interface requires specialized knowledge about S3 methods and formulas, which the average package developer might not have. The goal of 'hardhat' is to reduce the burden around building new modeling packages by providing functionality for preprocessing, predicting, and validating input.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hannah Frick <a href="mailto:hannah@posit.co">hannah@posit.co</a> (<a href="https://orcid.org/0000-0002-6049-5258">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
</li>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/hardhat">https://github.com/tidymodels/hardhat</a>
</p>
</li>
<li> <p><a href="https://hardhat.tidymodels.org">https://hardhat.tidymodels.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/hardhat/issues">https://github.com/tidymodels/hardhat/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_intercept_column'>Add an intercept column to <code>data</code></h2><span id='topic+add_intercept_column'></span>

<h3>Description</h3>

<p>This function adds an integer column of <code>1</code>'s to <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_intercept_column(data, name = "(Intercept)", ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_intercept_column_+3A_data">data</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="add_intercept_column_+3A_name">name</code></td>
<td>
<p>The name for the intercept column. Defaults to <code>"(Intercept)"</code>,
which is the same name that <code><a href="stats.html#topic+lm">stats::lm()</a></code> uses.</p>
</td></tr>
<tr><td><code id="add_intercept_column_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="add_intercept_column_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a column named <code>name</code> already exists in <code>data</code>, then <code>data</code> is returned
unchanged and a warning is issued.
</p>


<h3>Value</h3>

<p><code>data</code> with an intercept column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_intercept_column(mtcars)

add_intercept_column(mtcars, "intercept")

add_intercept_column(as.matrix(mtcars))
</code></pre>

<hr>
<h2 id='check_quantile_levels'>Check levels of quantiles</h2><span id='topic+check_quantile_levels'></span>

<h3>Description</h3>

<p>Check levels of quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_quantile_levels(levels, call = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_quantile_levels_+3A_levels">levels</code></td>
<td>
<p>The quantile levels.</p>
</td></tr>
<tr><td><code id="check_quantile_levels_+3A_call">call</code></td>
<td>
<p>Call shown in the error messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks the levels for their data type, range, uniqueness, order and missingness.
</p>


<h3>Value</h3>

<p>Invisible <code>TRUE</code>
</p>

<hr>
<h2 id='contr_one_hot'>Contrast function for one-hot encodings</h2><span id='topic+contr_one_hot'></span>

<h3>Description</h3>

<p>This contrast function produces a model matrix that has indicator columns for
each level of each factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr_one_hot(n, contrasts = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr_one_hot_+3A_n">n</code></td>
<td>
<p>A vector of character factor levels (of length &gt;=1) or the number
of unique levels (&gt;= 1).</p>
</td></tr>
<tr><td><code id="contr_one_hot_+3A_contrasts">contrasts</code></td>
<td>
<p>This argument is for backwards compatibility and only the
default of <code>TRUE</code> is supported.</p>
</td></tr>
<tr><td><code id="contr_one_hot_+3A_sparse">sparse</code></td>
<td>
<p>This argument is for backwards compatibility and only the
default of <code>FALSE</code> is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>model.matrix()</code> generates binary indicator variables for
factor predictors. When the formula does not remove an intercept, an
incomplete set of indicators are created; no indicator is made for the
first level of the factor.
</p>
<p>For example, <code>species</code> and <code>island</code> both have three levels but
<code>model.matrix()</code> creates two indicator variables for each:
</p>
<div class="sourceCode r"><pre>library(dplyr)
library(modeldata)
data(penguins)

levels(penguins$species)
</pre></div>
<div class="sourceCode"><pre>## [1] "Adelie"    "Chinstrap" "Gentoo"
</pre></div>
<div class="sourceCode r"><pre>levels(penguins$island)
</pre></div>
<div class="sourceCode"><pre>## [1] "Biscoe"    "Dream"     "Torgersen"
</pre></div>
<div class="sourceCode r"><pre>model.matrix(~ species + island, data = penguins) %&gt;% 
  colnames()
</pre></div>
<div class="sourceCode"><pre>## [1] "(Intercept)"      "speciesChinstrap" "speciesGentoo"    "islandDream"     
## [5] "islandTorgersen"
</pre></div>
<p>For a formula with no intercept, the first factor is expanded to
indicators for <em>all</em> factor levels but all other factors are expanded to
all but one (as above):
</p>
<div class="sourceCode r"><pre>model.matrix(~ 0 + species + island, data = penguins) %&gt;% 
  colnames()
</pre></div>
<div class="sourceCode"><pre>## [1] "speciesAdelie"    "speciesChinstrap" "speciesGentoo"    "islandDream"     
## [5] "islandTorgersen"
</pre></div>
<p>For inference, this hybrid encoding can be problematic.
</p>
<p>To generate all indicators, use this contrast:
</p>
<div class="sourceCode r"><pre># Switch out the contrast method
old_contr &lt;- options("contrasts")$contrasts
new_contr &lt;- old_contr
new_contr["unordered"] &lt;- "contr_one_hot"
options(contrasts = new_contr)

model.matrix(~ species + island, data = penguins) %&gt;% 
  colnames()
</pre></div>
<div class="sourceCode"><pre>## [1] "(Intercept)"      "speciesAdelie"    "speciesChinstrap" "speciesGentoo"   
## [5] "islandBiscoe"     "islandDream"      "islandTorgersen"
</pre></div>
<div class="sourceCode r"><pre>options(contrasts = old_contr)
</pre></div>
<p>Removing the intercept here does not affect the factor encodings.
</p>


<h3>Value</h3>

<p>A diagonal matrix that is <code>n</code>-by-<code>n</code>.
</p>

<hr>
<h2 id='default_formula_blueprint'>Default formula blueprint</h2><span id='topic+default_formula_blueprint'></span><span id='topic+mold.formula'></span>

<h3>Description</h3>

<p>This pages holds the details for the formula preprocessing blueprint. This
is the blueprint used by default from <code>mold()</code> if <code>x</code> is a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_formula_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  indicators = "traditional",
  composition = "tibble"
)

## S3 method for class 'formula'
mold(formula, data, ..., blueprint = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_formula_blueprint_+3A_intercept">intercept</code></td>
<td>
<p>A logical. Should an intercept be included in the
processed data? This information is used by the <code>process</code> function
in the <code>mold</code> and <code>forge</code> function list.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>A logical. Should novel factor levels be allowed at
prediction time? This information is used by the <code>clean</code> function in the
<code>forge</code> function list, and is passed on to <code><a href="#topic+scream">scream()</a></code>.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_indicators">indicators</code></td>
<td>
<p>A single character string. Control how factors are
expanded into dummy variable indicator columns. One of:
</p>

<ul>
<li> <p><code>"traditional"</code> - The default. Create dummy variables using the
traditional <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code> infrastructure. Generally this creates
<code>K - 1</code> indicator columns for each factor, where <code>K</code> is the number of
levels in that factor.
</p>
</li>
<li> <p><code>"none"</code> - Leave factor variables alone. No expansion is done.
</p>
</li>
<li> <p><code>"one_hot"</code> - Create dummy variables using a one-hot encoding approach
that expands unordered factors into all <code>K</code> indicator columns, rather than
<code>K - 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, or &quot;dgCMatrix&quot; for the format
of the processed predictors. If &quot;matrix&quot; or &quot;dgCMatrix&quot; are chosen, all of
the predictors must be numeric after the preprocessing method has been
applied; otherwise an error is thrown.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the predictors and the outcomes.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the outcomes and predictors.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="default_formula_blueprint_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code>. If left as <code>NULL</code>, then a
<code><a href="#topic+default_formula_blueprint">default_formula_blueprint()</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While not different from base R, the behavior of expanding factors into
dummy variables when <code>indicators = "traditional"</code> and an intercept is <em>not</em>
present is not always intuitive and should be documented.
</p>

<ul>
<li><p> When an intercept is present, factors are expanded into <code>K-1</code> new columns,
where <code>K</code> is the number of levels in the factor.
</p>
</li>
<li><p> When an intercept is <em>not</em> present, the first factor is expanded into
all <code>K</code> columns (one-hot encoding), and the remaining factors are expanded
into <code>K-1</code> columns. This behavior ensures that meaningful predictions can
be made for the reference level of the first factor, but is not the exact
&quot;no intercept&quot; model that was requested. Without this behavior, predictions
for the reference level of the first factor would always be forced to <code>0</code>
when there is no intercept.
</p>
</li></ul>

<p>Offsets can be included in the formula method through the use of the inline
function <code><a href="stats.html#topic+offset">stats::offset()</a></code>. These are returned as a tibble with 1 column
named <code>".offset"</code> in the <code style="white-space: pre;">&#8288;$extras$offset&#8288;</code> slot of the return value.
</p>


<h3>Value</h3>

<p>For <code>default_formula_blueprint()</code>, a formula blueprint.
</p>


<h3>Mold</h3>

<p>When <code>mold()</code> is used with the default formula blueprint:
</p>

<ul>
<li><p> Predictors
</p>

<ul>
<li><p> The RHS of the <code>formula</code> is isolated, and converted to its own
1 sided formula: <code>~ RHS</code>.
</p>
</li>
<li><p> Runs <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> on the RHS formula and uses <code>data</code>.
</p>
</li>
<li><p> If <code>indicators = "traditional"</code>, it then runs <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>
on the result.
</p>
</li>
<li><p> If <code>indicators = "none"</code>, factors are removed before <code>model.matrix()</code>
is run, and then added back afterwards. No interactions or inline
functions involving factors are allowed.
</p>
</li>
<li><p> If <code>indicators = "one_hot"</code>, it then runs <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> on the
result using a contrast function that creates indicator columns for all
levels of all factors.
</p>
</li>
<li><p> If any offsets are present from using <code>offset()</code>, then they are
extracted with <code><a href="#topic+model_offset">model_offset()</a></code>.
</p>
</li>
<li><p> If <code>intercept = TRUE</code>, adds an intercept column.
</p>
</li>
<li><p> Coerces the result of the above steps to a tibble.
</p>
</li></ul>

</li>
<li><p> Outcomes
</p>

<ul>
<li><p> The LHS of the <code>formula</code> is isolated, and converted to its own
1 sided formula: <code>~ LHS</code>.
</p>
</li>
<li><p> Runs <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> on the LHS formula and uses <code>data</code>.
</p>
</li>
<li><p> Coerces the result of the above steps to a tibble.
</p>
</li></ul>

</li></ul>



<h3>Forge</h3>

<p>When <code>forge()</code> is used with the default formula blueprint:
</p>

<ul>
<li><p> It calls <code><a href="#topic+shrink">shrink()</a></code> to trim <code>new_data</code> to only the required columns and
coerce <code>new_data</code> to a tibble.
</p>
</li>
<li><p> It calls <code><a href="#topic+scream">scream()</a></code> to perform validation on the structure of the columns
of <code>new_data</code>.
</p>
</li>
<li><p> Predictors
</p>

<ul>
<li><p> It runs <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> on <code>new_data</code> using the stored terms
object corresponding to the <em>predictors</em>.
</p>
</li>
<li><p> If, in the original <code><a href="#topic+mold">mold()</a></code> call, <code>indicators = "traditional"</code> was
set, it then runs <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> on the result.
</p>
</li>
<li><p> If, in the original <code><a href="#topic+mold">mold()</a></code> call, <code>indicators = "none"</code> was set, it
runs <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> on the result without the factor columns,
and then adds them on afterwards.
</p>
</li>
<li><p> If, in the original <code><a href="#topic+mold">mold()</a></code> call, <code>indicators = "one_hot"</code> was set, it
runs <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> on the result with a contrast function that
includes indicators for all levels of all factor columns.
</p>
</li>
<li><p> If any offsets are present from using <code>offset()</code> in the original call
to <code><a href="#topic+mold">mold()</a></code>, then they are extracted with <code><a href="#topic+model_offset">model_offset()</a></code>.
</p>
</li>
<li><p> If <code>intercept = TRUE</code> in the original call to <code><a href="#topic+mold">mold()</a></code>, then an
intercept column is added.
</p>
</li>
<li><p> It coerces the result of the above steps to a tibble.
</p>
</li></ul>

</li>
<li><p> Outcomes
</p>

<ul>
<li><p> It runs <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> on <code>new_data</code> using the
stored terms object corresponding to the <em>outcomes</em>.
</p>
</li>
<li><p> Coerces the result to a tibble.
</p>
</li></ul>

</li></ul>



<h3>Differences From Base R</h3>

<p>There are a number of differences from base R regarding how formulas are
processed by <code>mold()</code> that require some explanation.
</p>
<p>Multivariate outcomes can be specified on the LHS using syntax that is
similar to the RHS (i.e. <code>outcome_1 + outcome_2 ~ predictors</code>).
If any complex calculations are done on the LHS and they return matrices
(like <code><a href="stats.html#topic+poly">stats::poly()</a></code>), then those matrices are flattened into multiple
columns of the tibble after the call to <code>model.frame()</code>. While this is
possible, it is not recommended, and if a large amount of preprocessing is
required on the outcomes, then you are better off
using a <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>.
</p>
<p>Global variables are <em>not</em> allowed in the formula. An error will be thrown
if they are included. All terms in the formula should come from <code>data</code>. If
you need to use inline functions in the formula, the safest way to do so is
to prefix them with their package name, like <code>pkg::fn()</code>. This ensures that
the function will always be available at <code>mold()</code> (fit) and <code>forge()</code>
(prediction) time. That said, if the package is <em>attached</em>
(i.e. with <code>library()</code>), then you should be able to use the inline function
without the prefix.
</p>
<p>By default, intercepts are <em>not</em> included in the predictor output from the
formula. To include an intercept, set
<code>blueprint = default_formula_blueprint(intercept = TRUE)</code>. The rationale
for this is that many packages either always require or never allow an
intercept (for example, the <code>earth</code> package), and they do a large amount of
extra work to keep the user from supplying one or removing it. This
interface standardizes all of that flexibility in one place.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------

data("hardhat-example-data")

# ---------------------------------------------------------------------------
# Formula Example

# Call mold() with the training data
processed &lt;- mold(
  log(num_1) ~ num_2 + fac_1,
  example_train,
  blueprint = default_formula_blueprint(intercept = TRUE)
)

# Then, call forge() with the blueprint and the test data
# to have it preprocess the test data in the same way
forge(example_test, processed$blueprint)

# Use `outcomes = TRUE` to also extract the preprocessed outcome
forge(example_test, processed$blueprint, outcomes = TRUE)

# ---------------------------------------------------------------------------
# Factors without an intercept

# No intercept is added by default
processed &lt;- mold(num_1 ~ fac_1 + fac_2, example_train)

# So, for factor columns, the first factor is completely expanded into all
# `K` columns (the number of levels), and the subsequent factors are expanded
# into `K - 1` columns.
processed$predictors

# In the above example, `fac_1` is expanded into all three columns,
# `fac_2` is not. This behavior comes from `model.matrix()`, and is somewhat
# known in the R community, but can lead to a model that is difficult to
# interpret since the corresponding p-values are testing wildly different
# hypotheses.

# To get all indicators for all columns (irrespective of the intercept),
# use the `indicators = "one_hot"` option
processed &lt;- mold(
  num_1 ~ fac_1 + fac_2,
  example_train,
  blueprint = default_formula_blueprint(indicators = "one_hot")
)

processed$predictors

# It is not possible to construct a no-intercept model that expands all
# factors into `K - 1` columns using the formula method. If required, a
# recipe could be used to construct this model.

# ---------------------------------------------------------------------------
# Global variables

y &lt;- rep(1, times = nrow(example_train))

# In base R, global variables are allowed in a model formula
frame &lt;- model.frame(fac_1 ~ y + num_2, example_train)
head(frame)

# mold() does not allow them, and throws an error
try(mold(fac_1 ~ y + num_2, example_train))

# ---------------------------------------------------------------------------
# Dummy variables and interactions

# By default, factor columns are expanded
# and interactions are created, both by
# calling `model.matrix()`. Some models (like
# tree based models) can take factors directly
# but still might want to use the formula method.
# In those cases, set `indicators = "none"` to not
# run `model.matrix()` on factor columns. Interactions
# are still allowed and are run on numeric columns.

bp_no_indicators &lt;- default_formula_blueprint(indicators = "none")

processed &lt;- mold(
  ~ fac_1 + num_1:num_2,
  example_train,
  blueprint = bp_no_indicators
)

processed$predictors

# An informative error is thrown when `indicators = "none"` and
# factors are present in interaction terms or in inline functions
try(mold(num_1 ~ num_2:fac_1, example_train, blueprint = bp_no_indicators))
try(mold(num_1 ~ paste0(fac_1), example_train, blueprint = bp_no_indicators))

# ---------------------------------------------------------------------------
# Multivariate outcomes

# Multivariate formulas can be specified easily
processed &lt;- mold(num_1 + log(num_2) ~ fac_1, example_train)
processed$outcomes

# Inline functions on the LHS are run, but any matrix
# output is flattened (like what happens in `model.matrix()`)
# (essentially this means you don't wind up with columns
# in the tibble that are matrices)
processed &lt;- mold(poly(num_2, degree = 2) ~ fac_1, example_train)
processed$outcomes

# TRUE
ncol(processed$outcomes) == 2

# Multivariate formulas specified in mold()
# carry over into forge()
forge(example_test, processed$blueprint, outcomes = TRUE)

# ---------------------------------------------------------------------------
# Offsets

# Offsets are handled specially in base R, so they deserve special
# treatment here as well. You can add offsets using the inline function
# `offset()`
processed &lt;- mold(num_1 ~ offset(num_2) + fac_1, example_train)

processed$extras$offset

# Multiple offsets can be included, and they get added together
processed &lt;- mold(
  num_1 ~ offset(num_2) + offset(num_3),
  example_train
)

identical(
  processed$extras$offset$.offset,
  example_train$num_2 + example_train$num_3
)

# Forging test data will also require
# and include the offset
forge(example_test, processed$blueprint)

# ---------------------------------------------------------------------------
# Intercept only

# Because `1` and `0` are intercept modifying terms, they are
# not allowed in the formula and are instead controlled by the
# `intercept` argument of the blueprint. To use an intercept
# only formula, you should supply `NULL` on the RHS of the formula.
mold(
  ~NULL,
  example_train,
  blueprint = default_formula_blueprint(intercept = TRUE)
)

# ---------------------------------------------------------------------------
# Matrix output for predictors

# You can change the `composition` of the predictor data set
bp &lt;- default_formula_blueprint(composition = "dgCMatrix")
processed &lt;- mold(log(num_1) ~ num_2 + fac_1, example_train, blueprint = bp)
class(processed$predictors)
</code></pre>

<hr>
<h2 id='default_recipe_blueprint'>Default recipe blueprint</h2><span id='topic+default_recipe_blueprint'></span><span id='topic+mold.recipe'></span>

<h3>Description</h3>

<p>This pages holds the details for the recipe preprocessing blueprint. This
is the blueprint used by default from <code>mold()</code> if <code>x</code> is a recipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_recipe_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  fresh = TRUE,
  strings_as_factors = TRUE,
  composition = "tibble"
)

## S3 method for class 'recipe'
mold(x, data, ..., blueprint = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_recipe_blueprint_+3A_intercept">intercept</code></td>
<td>
<p>A logical. Should an intercept be included in the
processed data? This information is used by the <code>process</code> function
in the <code>mold</code> and <code>forge</code> function list.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>A logical. Should novel factor levels be allowed at
prediction time? This information is used by the <code>clean</code> function in the
<code>forge</code> function list, and is passed on to <code><a href="#topic+scream">scream()</a></code>.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_fresh">fresh</code></td>
<td>
<p>Should already trained operations be re-trained when <code>prep()</code> is
called?</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_strings_as_factors">strings_as_factors</code></td>
<td>
<p>Should character columns be converted to factors
when <code>prep()</code> is called?</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, or &quot;dgCMatrix&quot; for the format
of the processed predictors. If &quot;matrix&quot; or &quot;dgCMatrix&quot; are chosen, all of
the predictors must be numeric after the preprocessing method has been
applied; otherwise an error is thrown.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_x">x</code></td>
<td>
<p>An unprepped recipe created from <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the outcomes and predictors.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="default_recipe_blueprint_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code>. If left as <code>NULL</code>, then a
<code><a href="#topic+default_recipe_blueprint">default_recipe_blueprint()</a></code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>default_recipe_blueprint()</code>, a recipe blueprint.
</p>


<h3>Mold</h3>

<p>When <code>mold()</code> is used with the default recipe blueprint:
</p>

<ul>
<li><p> It calls <code><a href="recipes.html#topic+prep">recipes::prep()</a></code> to prep the recipe.
</p>
</li>
<li><p> It calls <code><a href="recipes.html#topic+juice">recipes::juice()</a></code> to extract the outcomes and predictors. These
are returned as tibbles.
</p>
</li>
<li><p> If <code>intercept = TRUE</code>, adds an intercept column to the predictors.
</p>
</li></ul>



<h3>Forge</h3>

<p>When <code>forge()</code> is used with the default recipe blueprint:
</p>

<ul>
<li><p> It calls <code><a href="#topic+shrink">shrink()</a></code> to trim <code>new_data</code> to only the required columns and
coerce <code>new_data</code> to a tibble.
</p>
</li>
<li><p> It calls <code><a href="#topic+scream">scream()</a></code> to perform validation on the structure of the columns
of <code>new_data</code>.
</p>
</li>
<li><p> It calls <code><a href="recipes.html#topic+bake">recipes::bake()</a></code> on the <code>new_data</code> using the prepped recipe
used during training.
</p>
</li>
<li><p> It adds an intercept column onto <code>new_data</code> if <code>intercept = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# example code

library(recipes)

# ---------------------------------------------------------------------------
# Setup

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

# ---------------------------------------------------------------------------
# Recipes example

# Create a recipe that logs a predictor
rec &lt;- recipe(Species ~ Sepal.Length + Sepal.Width, train) %&gt;%
  step_log(Sepal.Length)

processed &lt;- mold(rec, train)

# Sepal.Length has been logged
processed$predictors

processed$outcomes

# The underlying blueprint is a prepped recipe
processed$blueprint$recipe

# Call forge() with the blueprint and the test data
# to have it preprocess the test data in the same way
forge(test, processed$blueprint)

# Use `outcomes = TRUE` to also extract the preprocessed outcome!
# This logged the Sepal.Length column of `new_data`
forge(test, processed$blueprint, outcomes = TRUE)

# ---------------------------------------------------------------------------
# With an intercept

# You can add an intercept with `intercept = TRUE`
processed &lt;- mold(rec, train, blueprint = default_recipe_blueprint(intercept = TRUE))

processed$predictors

# But you also could have used a recipe step
rec2 &lt;- step_intercept(rec)

mold(rec2, iris)$predictors

# ---------------------------------------------------------------------------
# Matrix output for predictors

# You can change the `composition` of the predictor data set
bp &lt;- default_recipe_blueprint(composition = "dgCMatrix")
processed &lt;- mold(rec, train, blueprint = bp)
class(processed$predictors)

# ---------------------------------------------------------------------------
# Non standard roles

# If you have custom recipes roles, they are assumed to be required at
# `bake()` time when passing in `new_data`. This is an assumption that both
# recipes and hardhat makes, meaning that those roles are required at
# `forge()` time as well.
rec_roles &lt;- recipe(train) %&gt;%
  update_role(Sepal.Width, new_role = "predictor") %&gt;%
  update_role(Species, new_role = "outcome") %&gt;%
  update_role(Sepal.Length, new_role = "id") %&gt;%
  update_role(Petal.Length, new_role = "important")

processed_roles &lt;- mold(rec_roles, train)

# The custom roles will be in the `mold()` result in case you need
# them for modeling.
processed_roles$extras

# And they are in the `forge()` result
forge(test, processed_roles$blueprint)$extras

# If you remove a column with a custom role from the test data, then you
# won't be able to `forge()` even though this recipe technically didn't
# use that column in any steps
test2 &lt;- test
test2$Petal.Length &lt;- NULL
try(forge(test2, processed_roles$blueprint))

# Most of the time, if you find yourself in the above scenario, then we
# suggest that you remove `Petal.Length` from the data that is supplied to
# the recipe. If that isn't an option, you can declare that that column
# isn't required at `bake()` time by using `update_role_requirements()`
rec_roles &lt;- update_role_requirements(rec_roles, "important", bake = FALSE)
processed_roles &lt;- mold(rec_roles, train)
forge(test2, processed_roles$blueprint)

</code></pre>

<hr>
<h2 id='default_xy_blueprint'>Default XY blueprint</h2><span id='topic+default_xy_blueprint'></span><span id='topic+mold.data.frame'></span><span id='topic+mold.matrix'></span>

<h3>Description</h3>

<p>This pages holds the details for the XY preprocessing blueprint. This
is the blueprint used by default from <code>mold()</code> if <code>x</code> and <code>y</code> are provided
separately (i.e. the XY interface is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_xy_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  composition = "tibble"
)

## S3 method for class 'data.frame'
mold(x, y, ..., blueprint = NULL)

## S3 method for class 'matrix'
mold(x, y, ..., blueprint = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_xy_blueprint_+3A_intercept">intercept</code></td>
<td>
<p>A logical. Should an intercept be included in the
processed data? This information is used by the <code>process</code> function
in the <code>mold</code> and <code>forge</code> function list.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>A logical. Should novel factor levels be allowed at
prediction time? This information is used by the <code>clean</code> function in the
<code>forge</code> function list, and is passed on to <code><a href="#topic+scream">scream()</a></code>.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, or &quot;dgCMatrix&quot; for the format
of the processed predictors. If &quot;matrix&quot; or &quot;dgCMatrix&quot; are chosen, all of
the predictors must be numeric after the preprocessing method has been
applied; otherwise an error is thrown.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_x">x</code></td>
<td>
<p>A data frame or matrix containing the predictors.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_y">y</code></td>
<td>
<p>A data frame, matrix, or vector containing the outcomes.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="default_xy_blueprint_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code>. If left as <code>NULL</code>, then a
<code><a href="#topic+default_xy_blueprint">default_xy_blueprint()</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As documented in <code><a href="#topic+standardize">standardize()</a></code>, if <code>y</code> is a <em>vector</em>, then the returned
outcomes tibble has 1 column with a standardized name of <code>".outcome"</code>.
</p>
<p>The one special thing about the XY method's forge function is the behavior of
<code>outcomes = TRUE</code> when a <em>vector</em> <code>y</code> value was provided to the original
call to <code><a href="#topic+mold">mold()</a></code>. In that case, <code>mold()</code> converts <code>y</code> into a tibble, with
a default name of <code>.outcome</code>. This is the column that <code>forge()</code> will look
for in <code>new_data</code> to preprocess. See the examples section for a
demonstration of this.
</p>


<h3>Value</h3>

<p>For <code>default_xy_blueprint()</code>, an XY blueprint.
</p>


<h3>Mold</h3>

<p>When <code>mold()</code> is used with the default xy blueprint:
</p>

<ul>
<li><p> It converts <code>x</code> to a tibble.
</p>
</li>
<li><p> It adds an intercept column to <code>x</code> if <code>intercept = TRUE</code>.
</p>
</li>
<li><p> It runs <code><a href="#topic+standardize">standardize()</a></code> on <code>y</code>.
</p>
</li></ul>



<h3>Forge</h3>

<p>When <code>forge()</code> is used with the default xy blueprint:
</p>

<ul>
<li><p> It calls <code><a href="#topic+shrink">shrink()</a></code> to trim <code>new_data</code> to only the required columns and
coerce <code>new_data</code> to a tibble.
</p>
</li>
<li><p> It calls <code><a href="#topic+scream">scream()</a></code> to perform validation on the structure of the columns
of <code>new_data</code>.
</p>
</li>
<li><p> It adds an intercept column onto <code>new_data</code> if <code>intercept = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Setup

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

train_x &lt;- train["Sepal.Length"]
train_y &lt;- train["Species"]

test_x &lt;- test["Sepal.Length"]
test_y &lt;- test["Species"]

# ---------------------------------------------------------------------------
# XY Example

# First, call mold() with the training data
processed &lt;- mold(train_x, train_y)

# Then, call forge() with the blueprint and the test data
# to have it preprocess the test data in the same way
forge(test_x, processed$blueprint)

# ---------------------------------------------------------------------------
# Intercept

processed &lt;- mold(train_x, train_y, blueprint = default_xy_blueprint(intercept = TRUE))

forge(test_x, processed$blueprint)

# ---------------------------------------------------------------------------
# XY Method and forge(outcomes = TRUE)

# You can request that the new outcome columns are preprocessed as well, but
# they have to be present in `new_data`!

processed &lt;- mold(train_x, train_y)

# Can't do this!
try(forge(test_x, processed$blueprint, outcomes = TRUE))

# Need to use the full test set, including `y`
forge(test, processed$blueprint, outcomes = TRUE)

# With the XY method, if the Y value used in `mold()` is a vector,
# then a column name of `.outcome` is automatically generated.
# This name is what forge() looks for in `new_data`.

# Y is a vector!
y_vec &lt;- train_y$Species

processed_vec &lt;- mold(train_x, y_vec)

# This throws an informative error that tell you
# to include an `".outcome"` column in `new_data`.
try(forge(iris, processed_vec$blueprint, outcomes = TRUE))

test2 &lt;- test
test2$.outcome &lt;- test2$Species
test2$Species &lt;- NULL

# This works, and returns a tibble in the $outcomes slot
forge(test2, processed_vec$blueprint, outcomes = TRUE)

# ---------------------------------------------------------------------------
# Matrix output for predictors

# You can change the `composition` of the predictor data set
bp &lt;- default_xy_blueprint(composition = "dgCMatrix")
processed &lt;- mold(train_x, train_y, blueprint = bp)
class(processed$predictors)
</code></pre>

<hr>
<h2 id='delete_response'>Delete the response from a terms object</h2><span id='topic+delete_response'></span>

<h3>Description</h3>

<p><code>delete_response()</code> is exactly the same as <code>delete.response()</code>, except
that it fixes a long standing bug by also removing the part of the
<code>"dataClasses"</code> attribute corresponding to the response, if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_response(terms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_response_+3A_terms">terms</code></td>
<td>
<p>A terms object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bug is described here:
</p>
<p><a href="https://stat.ethz.ch/pipermail/r-devel/2012-January/062942.html">https://stat.ethz.ch/pipermail/r-devel/2012-January/062942.html</a>
</p>


<h3>Value</h3>

<p><code>terms</code> with the response sections removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
framed &lt;- model_frame(Species ~ Sepal.Width, iris)

attr(delete.response(framed$terms), "dataClasses")

attr(delete_response(framed$terms), "dataClasses")
</code></pre>

<hr>
<h2 id='extract_ptype'>Extract a prototype</h2><span id='topic+extract_ptype'></span>

<h3>Description</h3>

<p><code>extract_ptype()</code> extracts a tibble with 0 rows from <code>data</code>. This contains
all of the required information about column names, classes, and factor
levels that are required to check the structure of new data at prediction
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ptype(data, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_ptype_+3A_data">data</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="extract_ptype_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="extract_ptype_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extract_ptype()</code> is useful when creating a new preprocessing <code>blueprint</code>. It
extracts the required information that will be used by the validation checks
at prediction time.
</p>


<h3>Value</h3>

<p>A 0 row slice of <code>data</code> after converting it to a tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hardhat:::extract_ptype(iris)
</code></pre>

<hr>
<h2 id='fct_encode_one_hot'>Encode a factor as a one-hot indicator matrix</h2><span id='topic+fct_encode_one_hot'></span>

<h3>Description</h3>

<p><code>fct_encode_one_hot()</code> encodes a factor as a one-hot indicator matrix.
</p>
<p>This matrix consists of <code>length(x)</code> rows and <code>length(levels(x))</code> columns.
Every value in row <code>i</code> of the matrix is filled with <code>0L</code> except for the
column that has the same name as <code>x[[i]]</code>, which is instead filled with <code>1L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_encode_one_hot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_encode_one_hot_+3A_x">x</code></td>
<td>
<p>A factor.
</p>
<p><code>x</code> can't contain missing values.
</p>
<p><code>x</code> is allowed to be an ordered factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns are returned in the same order as <code>levels(x)</code>.
</p>
<p>If <code>x</code> has names, the names are propagated onto the result as the row names.
</p>


<h3>Value</h3>

<p>An integer matrix with <code>length(x)</code> rows and <code>length(levels(x))</code>
columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct_encode_one_hot(factor(letters))

fct_encode_one_hot(factor(letters[1:2], levels = letters))

set.seed(1234)
fct_encode_one_hot(factor(sample(letters[1:4], 10, TRUE)))
</code></pre>

<hr>
<h2 id='forge'>Forge prediction-ready data</h2><span id='topic+forge'></span>

<h3>Description</h3>

<p><code>forge()</code> applies the transformations requested by the specific <code>blueprint</code>
on a set of <code>new_data</code>. This <code>new_data</code> contains new predictors
(and potentially outcomes) that will be used to generate predictions.
</p>
<p>All blueprints have consistent return values with the others, but each is
unique enough to have its own help page. Click through below to learn
how to use each one in conjunction with <code>forge()</code>.
</p>

<ul>
<li><p> XY Method - <code><a href="#topic+default_xy_blueprint">default_xy_blueprint()</a></code>
</p>
</li>
<li><p> Formula Method - <code><a href="#topic+default_formula_blueprint">default_formula_blueprint()</a></code>
</p>
</li>
<li><p> Recipes Method - <code><a href="#topic+default_recipe_blueprint">default_recipe_blueprint()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>forge(new_data, blueprint, ..., outcomes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forge_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or matrix of predictors to process. If
<code>outcomes = TRUE</code>, this should also contain the outcomes to process.</p>
</td></tr>
<tr><td><code id="forge_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code>.</p>
</td></tr>
<tr><td><code id="forge_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="forge_+3A_outcomes">outcomes</code></td>
<td>
<p>A logical. Should the outcomes be processed and returned
as well?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the outcomes are present in <code>new_data</code>, they can optionally be processed
and returned in the <code>outcomes</code> slot of the returned list by setting
<code>outcomes = TRUE</code>. This is very useful when doing cross validation where
you need to preprocess the outcomes of a test set before computing
performance.
</p>


<h3>Value</h3>

<p>A named list with 3 elements:
</p>

<ul>
<li> <p><code>predictors</code>: A tibble containing the preprocessed
<code>new_data</code> predictors.
</p>
</li>
<li> <p><code>outcomes</code>: If <code>outcomes = TRUE</code>, a tibble containing the preprocessed
outcomes found in <code>new_data</code>. Otherwise, <code>NULL</code>.
</p>
</li>
<li> <p><code>extras</code>: Either <code>NULL</code> if the blueprint returns no extra information,
or a named list containing the extra information.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># See the blueprint specific documentation linked above
# for various ways to call forge with different
# blueprints.

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

# Formula
processed &lt;- mold(
  log(Sepal.Width) ~ Species,
  train,
  blueprint = default_formula_blueprint(indicators = "none")
)

forge(test, processed$blueprint, outcomes = TRUE)
</code></pre>

<hr>
<h2 id='frequency_weights'>Frequency weights</h2><span id='topic+frequency_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>frequency_weights()</code> creates a vector of frequency weights which allow you
to compactly repeat an observation a set number of times. Frequency weights
are supplied as a non-negative integer vector, where only whole numbers are
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequency_weights(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frequency_weights_+3A_x">x</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frequency weights are integers that denote how many times a particular row of
the data has been observed. They help compress redundant rows into a single
entry.
</p>
<p>In tidymodels, frequency weights are used for all parts of the preprocessing,
model fitting, and performance estimation operations.
</p>


<h3>Value</h3>

<p>A new frequency weights vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importance_weights">importance_weights()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Record that the first observation has 10 replicates, the second has 12
# replicates, and so on
frequency_weights(c(10, 12, 2, 1))

# Fractional values are not allowed
try(frequency_weights(c(1.5, 2.3, 10)))
</code></pre>

<hr>
<h2 id='get_data_classes'>Extract data classes from a data frame or matrix</h2><span id='topic+get_data_classes'></span>

<h3>Description</h3>

<p>When predicting from a model, it is often important for the <code>new_data</code> to
have the same classes as the original data used to fit the model.
<code>get_data_classes()</code> extracts the classes from the original training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_classes(data, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_classes_+3A_data">data</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="get_data_classes_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="get_data_classes_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. The names are the column names of <code>data</code> and the values are
character vectors containing the class of that column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_data_classes(iris)

get_data_classes(as.matrix(mtcars))

# Unlike .MFclass(), the full class
# vector is returned
data &lt;- data.frame(col = ordered(c("a", "b")))

.MFclass(data$col)

get_data_classes(data)
</code></pre>

<hr>
<h2 id='get_levels'>Extract factor levels from a data frame</h2><span id='topic+get_levels'></span><span id='topic+get_outcome_levels'></span>

<h3>Description</h3>

<p><code>get_levels()</code> extracts the levels from any factor columns in <code>data</code>. It is
mainly useful for extracting the original factor levels from the predictors
in the training set. <code>get_outcome_levels()</code> is a small wrapper around
<code>get_levels()</code> for extracting levels from a factor outcome
that first calls <code><a href="#topic+standardize">standardize()</a></code> on <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_levels(data)

get_outcome_levels(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_levels_+3A_data">data</code></td>
<td>
<p>A data.frame to extract levels from.</p>
</td></tr>
<tr><td><code id="get_levels_+3A_y">y</code></td>
<td>
<p>The outcome. This can be:
</p>

<ul>
<li><p> A factor vector
</p>
</li>
<li><p> A numeric vector
</p>
</li>
<li><p> A 1D numeric array
</p>
</li>
<li><p> A numeric matrix with column names
</p>
</li>
<li><p> A 2D numeric array with column names
</p>
</li>
<li><p> A data frame with numeric or factor columns
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with as many elements as there are factor columns in <code>data</code>
or <code>y</code>. The names are the names of the factor columns, and the values
are character vectors of the levels.
</p>
<p>If there are no factor columns, <code>NULL</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+checkMFClasses">stats::.getXlevels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Factor columns are returned with their levels
get_levels(iris)

# No factor columns
get_levels(mtcars)

# standardize() is first run on `y`
# which converts the input to a data frame
# with an automatically named column, `".outcome"`
get_outcome_levels(y = factor(letters[1:5]))
</code></pre>

<hr>
<h2 id='hardhat-example-data'>Example data for hardhat</h2><span id='topic+hardhat-example-data'></span><span id='topic+example_train'></span><span id='topic+example_test'></span>

<h3>Description</h3>

<p>Example data for hardhat
</p>


<h3>Details</h3>

<p>Data objects for a training and test set with the same variables:
three numeric and two factor columns.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>example_train</code>, <code>example_test</code></td>
<td>
<p>tibbles</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("hardhat-example-data")
</code></pre>

<hr>
<h2 id='hardhat-extract'>Generics for object extraction</h2><span id='topic+hardhat-extract'></span><span id='topic+extract_workflow'></span><span id='topic+extract_recipe'></span><span id='topic+extract_spec_parsnip'></span><span id='topic+extract_fit_parsnip'></span><span id='topic+extract_fit_engine'></span><span id='topic+extract_mold'></span><span id='topic+extract_preprocessor'></span><span id='topic+extract_postprocessor'></span><span id='topic+extract_parameter_dials'></span><span id='topic+extract_parameter_set_dials'></span><span id='topic+extract_fit_time'></span>

<h3>Description</h3>

<p>These generics are used to extract elements from various model
objects. Methods are defined in other packages, such as tune,
workflows, and workflowsets, but the returned object is always the same.
</p>

<ul>
<li> <p><code>extract_fit_engine()</code> returns the engine specific fit embedded within
a parsnip model fit. For example, when using <code>parsnip::linear_reg()</code>
with the <code>"lm"</code> engine, this returns the underlying <code>lm</code> object.
</p>
</li>
<li> <p><code>extract_fit_parsnip()</code> returns a parsnip model fit.
</p>
</li>
<li> <p><code>extract_mold()</code> returns the preprocessed &quot;mold&quot; object returned
from <code><a href="#topic+mold">mold()</a></code>. It contains information about the preprocessing,
including either the prepped recipe, the formula terms object, or
variable selectors.
</p>
</li>
<li> <p><code>extract_spec_parsnip()</code> returns a parsnip model specification.
</p>
</li>
<li> <p><code>extract_preprocessor()</code> returns the formula, recipe, or variable
expressions used for preprocessing.
</p>
</li>
<li> <p><code>extract_recipe()</code> returns a recipe, possibly estimated.
</p>
</li>
<li> <p><code>extract_workflow()</code> returns a workflow, possibly fit.
</p>
</li>
<li> <p><code>extract_parameter_dials()</code> returns a single dials parameter object.
</p>
</li>
<li> <p><code>extract_parameter_set_dials()</code> returns a set of dials parameter objects.
</p>
</li>
<li> <p><code>extract_fit_time()</code> returns a tibble with fit times.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extract_workflow(x, ...)

extract_recipe(x, ...)

extract_spec_parsnip(x, ...)

extract_fit_parsnip(x, ...)

extract_fit_engine(x, ...)

extract_mold(x, ...)

extract_preprocessor(x, ...)

extract_postprocessor(x, ...)

extract_parameter_dials(x, ...)

extract_parameter_set_dials(x, ...)

extract_fit_time(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hardhat-extract_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="hardhat-extract_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See packages where methods are defined for examples, such as `parsnip` or
# `workflows`.
</code></pre>

<hr>
<h2 id='importance_weights'>Importance weights</h2><span id='topic+importance_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>importance_weights()</code> creates a vector of importance weights which allow you
to apply a context dependent weight to your observations. Importance weights
are supplied as a non-negative double vector, where fractional values are
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance_weights(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importance_weights_+3A_x">x</code></td>
<td>
<p>A double vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Importance weights focus on how much each row of the data set should
influence model estimation. These can be based on data or arbitrarily set to
achieve some goal.
</p>
<p>In tidymodels, importance weights only affect the model estimation and
<em>supervised</em> recipes steps. They are not used with yardstick functions for
calculating measures of model performance.
</p>


<h3>Value</h3>

<p>A new importance weights vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frequency_weights">frequency_weights()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>importance_weights(c(1.5, 2.3, 10))
</code></pre>

<hr>
<h2 id='is_blueprint'>Is <code>x</code> a preprocessing blueprint?</h2><span id='topic+is_blueprint'></span>

<h3>Description</h3>

<p><code>is_blueprint()</code> checks if <code>x</code> inherits from <code>"hardhat_blueprint"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_blueprint(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_blueprint_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_blueprint(default_xy_blueprint())
</code></pre>

<hr>
<h2 id='is_case_weights'>Is <code>x</code> a case weights vector?</h2><span id='topic+is_case_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>is_case_weights()</code> checks if <code>x</code> inherits from <code>"hardhat_case_weights"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_case_weights(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_case_weights_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_case_weights(1)
is_case_weights(frequency_weights(1))
</code></pre>

<hr>
<h2 id='is_frequency_weights'>Is <code>x</code> a frequency weights vector?</h2><span id='topic+is_frequency_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>is_frequency_weights()</code> checks if <code>x</code> inherits from
<code>"hardhat_frequency_weights"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_frequency_weights(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_frequency_weights_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_frequency_weights(1)
is_frequency_weights(frequency_weights(1))
is_frequency_weights(importance_weights(1))
</code></pre>

<hr>
<h2 id='is_importance_weights'>Is <code>x</code> an importance weights vector?</h2><span id='topic+is_importance_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>is_importance_weights()</code> checks if <code>x</code> inherits from
<code>"hardhat_importance_weights"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_importance_weights(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_importance_weights_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_importance_weights(1)
is_importance_weights(frequency_weights(1))
is_importance_weights(importance_weights(1))
</code></pre>

<hr>
<h2 id='model_frame'>Construct a model frame</h2><span id='topic+model_frame'></span>

<h3>Description</h3>

<p><code>model_frame()</code> is a stricter version of <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>. There are
a number of differences, with the main being that rows are <em>never</em> dropped
and the return value is a list with the frame and terms separated into
two distinct objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_frame(formula, data, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_frame_+3A_formula">formula</code></td>
<td>
<p>A formula or terms object representing the terms of the
model frame.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the terms of <code>formula</code>.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following explains the rationale for some of the difference in arguments
compared to <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>:
</p>

<ul>
<li> <p><code>subset</code>: Not allowed because the number of rows before and after
<code>model_frame()</code> has been run should always be the same.
</p>
</li>
<li> <p><code>na.action</code>: Not allowed and is forced to <code>"na.pass"</code> because the
number of rows before and after <code>model_frame()</code> has been run should always
be the same.
</p>
</li>
<li> <p><code>drop.unused.levels</code>: Not allowed because it seems inconsistent for
<code>data</code> and the result of <code>model_frame()</code> to ever have the same factor column
but with different levels, unless specified though <code>original_levels</code>. If
this is required, it should be done through a recipe step explicitly.
</p>
</li>
<li> <p><code>xlev</code>: Not allowed because this check should have been done ahead of
time. Use <code><a href="#topic+scream">scream()</a></code> to check the integrity of <code>data</code> against a training
set if that is required.
</p>
</li>
<li> <p><code>...</code>: Not exposed because offsets are handled separately, and
it is not necessary to pass weights here any more because rows are never
dropped (so weights don't have to be subset alongside the rest of the
design matrix). If other non-predictor columns are required, use the
&quot;roles&quot; features of recipes.
</p>
</li></ul>

<p>It is important to always use the results of <code>model_frame()</code> with
<code><a href="#topic+model_matrix">model_matrix()</a></code> rather than <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> because the tibble
in the result of <code>model_frame()</code> does <em>not</em> have a terms object attached.
If <code style="white-space: pre;">&#8288;model.matrix(&lt;terms&gt;, &lt;tibble&gt;)&#8288;</code> is called directly, then a call to
<code>model.frame()</code> will be made automatically, which can give faulty results.
</p>


<h3>Value</h3>

<p>A named list with two elements:
</p>

<ul>
<li> <p><code>"data"</code>: A tibble containing the model frame.
</p>
</li>
<li> <p><code>"terms"</code>: A terms object containing the terms for the model frame.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Example usage

framed &lt;- model_frame(Species ~ Sepal.Width, iris)

framed$data

framed$terms

# ---------------------------------------------------------------------------
# Missing values never result in dropped rows

iris2 &lt;- iris
iris2$Sepal.Width[1] &lt;- NA

framed2 &lt;- model_frame(Species ~ Sepal.Width, iris2)

head(framed2$data)

nrow(framed2$data) == nrow(iris2)
</code></pre>

<hr>
<h2 id='model_matrix'>Construct a design matrix</h2><span id='topic+model_matrix'></span>

<h3>Description</h3>

<p><code>model_matrix()</code> is a stricter version of <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>. Notably,
<code>model_matrix()</code> will <em>never</em> drop rows, and the result will be a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix(terms, data, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_matrix_+3A_terms">terms</code></td>
<td>
<p>A terms object to construct a model matrix with. This is
typically the terms object returned from the corresponding call to
<code><a href="#topic+model_frame">model_frame()</a></code>.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_data">data</code></td>
<td>
<p>A tibble to construct the design matrix with. This is
typically the tibble returned from the corresponding call to
<code><a href="#topic+model_frame">model_frame()</a></code>.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following explains the rationale for some of the difference in arguments
compared to <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>:
</p>

<ul>
<li> <p><code>contrasts.arg</code>: Set the contrasts argument, <code>options("contrasts")</code>
globally, or assign a contrast to the factor of interest directly using
<code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code>. See the examples section.
</p>
</li>
<li> <p><code>xlev</code>: Not allowed because <code>model.frame()</code> is never called, so it is
unnecessary.
</p>
</li>
<li> <p><code>...</code>: Not allowed because the default method of <code>model.matrix()</code> does
not use it, and the <code>lm</code> method uses it to pass potential offsets and
weights through, which are handled differently in hardhat.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble containing the design matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Example usage

framed &lt;- model_frame(Sepal.Width ~ Species, iris)

model_matrix(framed$terms, framed$data)

# ---------------------------------------------------------------------------
# Missing values never result in dropped rows

iris2 &lt;- iris
iris2$Species[1] &lt;- NA

framed2 &lt;- model_frame(Sepal.Width ~ Species, iris2)

model_matrix(framed2$terms, framed2$data)

# ---------------------------------------------------------------------------
# Contrasts

# Default contrasts
y &lt;- factor(c("a", "b"))
x &lt;- data.frame(y = y)
framed &lt;- model_frame(~y, x)

# Setting contrasts directly
y_with_contrast &lt;- y
contrasts(y_with_contrast) &lt;- contr.sum(2)
x2 &lt;- data.frame(y = y_with_contrast)
framed2 &lt;- model_frame(~y, x2)

# Compare!
model_matrix(framed$terms, framed$data)
model_matrix(framed2$terms, framed2$data)

# Also, can set the contrasts globally
global_override &lt;- c(unordered = "contr.sum", ordered = "contr.poly")

rlang::with_options(
  .expr = {
    model_matrix(framed$terms, framed$data)
  },
  contrasts = global_override
)
</code></pre>

<hr>
<h2 id='model_offset'>Extract a model offset</h2><span id='topic+model_offset'></span>

<h3>Description</h3>

<p><code>model_offset()</code> extracts a numeric offset from a model frame. It is
inspired by <code><a href="stats.html#topic+model.extract">stats::model.offset()</a></code>, but has nicer error messages and
is slightly stricter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_offset(terms, data, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_offset_+3A_terms">terms</code></td>
<td>
<p>A <code>"terms"</code> object corresponding to <code>data</code>, returned from a
call to <code>model_frame()</code>.</p>
</td></tr>
<tr><td><code id="model_offset_+3A_data">data</code></td>
<td>
<p>A data frame returned from a call to <code>model_frame()</code>.</p>
</td></tr>
<tr><td><code id="model_offset_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="model_offset_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a column that has been tagged as an offset is not numeric, a nice error
message is thrown telling you exactly which column was problematic.
</p>
<p><code><a href="stats.html#topic+model.extract">stats::model.offset()</a></code> also allows for a column named <code>"(offset)"</code> to be
considered an offset along with any others that have been tagged by
<code><a href="stats.html#topic+offset">stats::offset()</a></code>. However, <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> does not recognize
these columns as offsets (so it doesn't remove them as it should). Because
of this inconsistency, columns named <code>"(offset)"</code> are <em>not</em> treated specially
by <code>model_offset()</code>.
</p>


<h3>Value</h3>

<p>A numeric vector representing the offset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- model.frame(Species ~ offset(Sepal.Width), iris)

model_offset(terms(x), x)

xx &lt;- model.frame(Species ~ offset(Sepal.Width) + offset(Sepal.Length), iris)

model_offset(terms(xx), xx)

# Problematic columns are caught with intuitive errors
tryCatch(
  expr = {
    x &lt;- model.frame(~ offset(Species), iris)
    model_offset(terms(x), x)
  },
  error = function(e) {
    print(e$message)
  }
)
</code></pre>

<hr>
<h2 id='modeling-usethis'>Create a modeling package</h2><span id='topic+modeling-usethis'></span><span id='topic+create_modeling_package'></span><span id='topic+use_modeling_deps'></span><span id='topic+use_modeling_files'></span>

<h3>Description</h3>

<p><code>create_modeling_package()</code> will:
</p>

<ul>
<li><p> Call <code>usethis::create_package()</code> to set up a new R package.
</p>
</li>
<li><p> Call <code>use_modeling_deps()</code>.
</p>
</li>
<li><p> Call <code>use_modeling_files()</code>.
</p>
</li></ul>

<p><code>use_modeling_deps()</code> will:
</p>

<ul>
<li><p> Add hardhat, rlang, and stats to Imports
</p>
</li>
<li><p> Add recipes to Suggests
</p>
</li>
<li><p> If roxygen2 is available, use roxygen markdown
</p>
</li></ul>

<p><code>use_modeling_files()</code> will:
</p>

<ul>
<li><p> Add a package documentation file
</p>
</li>
<li><p> Generate and populate 3 files in <code style="white-space: pre;">&#8288;R/&#8288;</code>:
</p>

<ul>
<li> <p><code>{{model}}-constructor.R</code>
</p>
</li>
<li> <p><code>{{model}}-fit.R</code>
</p>
</li>
<li> <p><code>{{model}}-predict.R</code>
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>create_modeling_package(path, model, fields = NULL, open = interactive())

use_modeling_deps()

use_modeling_files(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modeling-usethis_+3A_path">path</code></td>
<td>
<p>A path. If it exists, it is used. If it does not exist,
it is created, provided that the parent path exists.</p>
</td></tr>
<tr><td><code id="modeling-usethis_+3A_model">model</code></td>
<td>
<p>A string. The name of the high level modeling function that
users will call. For example, <code>"linear_regression"</code>. This will be used to
populate the skeleton. Spaces are not allowed.</p>
</td></tr>
<tr><td><code id="modeling-usethis_+3A_fields">fields</code></td>
<td>
<p>A named list of fields to add to DESCRIPTION,
potentially overriding default values. See <code>usethis::use_description()</code> for
how you can set personalized defaults using package options.</p>
</td></tr>
<tr><td><code id="modeling-usethis_+3A_open">open</code></td>
<td>
<p>If TRUE, activates the new project:
</p>

<ul>
<li><p> If RStudio desktop, the package is opened in a new session.
</p>
</li>
<li><p> If on RStudio server, the current RStudio project is activated.
</p>
</li>
<li><p> Otherwise, the working directory and active project is changed.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>create_modeling_package()</code> returns the project path invisibly.
</p>
<p><code>use_modeling_deps()</code> returns invisibly.
</p>
<p><code>use_modeling_files()</code> return <code>model</code> invisibly.
</p>

<hr>
<h2 id='mold'>Mold data for modeling</h2><span id='topic+mold'></span>

<h3>Description</h3>

<p><code>mold()</code> applies the appropriate processing steps required to get training
data ready to be fed into a model. It does this through the use of various
<em>blueprints</em> that understand how to preprocess data that come in various
forms, such as a formula or a recipe.
</p>
<p>All blueprints have consistent return values with the others, but each is
unique enough to have its own help page. Click through below to learn
how to use each one in conjunction with <code>mold()</code>.
</p>

<ul>
<li><p> XY Method - <code><a href="#topic+default_xy_blueprint">default_xy_blueprint()</a></code>
</p>
</li>
<li><p> Formula Method - <code><a href="#topic+default_formula_blueprint">default_formula_blueprint()</a></code>
</p>
</li>
<li><p> Recipes Method - <code><a href="#topic+default_recipe_blueprint">default_recipe_blueprint()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mold(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mold_+3A_x">x</code></td>
<td>
<p>An object. See the method specific implementations linked in the
Description for more information.</p>
</td></tr>
<tr><td><code id="mold_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing 4 elements:
</p>

<ul>
<li> <p><code>predictors</code>: A tibble containing the molded predictors to be used in the
model.
</p>
</li>
<li> <p><code>outcomes</code>: A tibble containing the molded outcomes to be used in the
model.
</p>
</li>
<li> <p><code>blueprint</code>: A method specific <code>"hardhat_blueprint"</code> object for use when
making predictions.
</p>
</li>
<li> <p><code>extras</code>: Either <code>NULL</code> if the blueprint returns no extra information,
or a named list containing the extra information.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# See the method specific documentation linked in Description
# for the details of each blueprint, and more examples.

# XY
mold(iris["Sepal.Width"], iris$Species)

# Formula
mold(Species ~ Sepal.Width, iris)

# Recipe
library(recipes)
mold(recipe(Species ~ Sepal.Width, iris), iris)

</code></pre>

<hr>
<h2 id='new_case_weights'>Extend case weights</h2><span id='topic+new_case_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>new_case_weights()</code> is a developer oriented function for constructing a new
case weights type. The <code style="white-space: pre;">&#8288;&lt;case_weights&gt;&#8288;</code> type itself is an <em>abstract</em> type
with very little functionality. Because of this, <code>class</code> is a required
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_case_weights(x, ..., class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_case_weights_+3A_x">x</code></td>
<td>
<p>An integer or double vector.</p>
</td></tr>
<tr><td><code id="new_case_weights_+3A_...">...</code></td>
<td>
<p>Name-value pairs defining attributes</p>
</td></tr>
<tr><td><code id="new_case_weights_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new subclassed case weights vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_case_weights(1:5, class = "my_weights")
</code></pre>

<hr>
<h2 id='new_default_formula_blueprint'>Create a new default blueprint</h2><span id='topic+new_default_formula_blueprint'></span><span id='topic+new_default_recipe_blueprint'></span><span id='topic+new-default-blueprint'></span><span id='topic+new_default_xy_blueprint'></span>

<h3>Description</h3>

<p>This page contains the constructors for the default blueprints. They can be
extended if you want to add extra behavior on top of what the default
blueprints already do, but generally you will extend the non-default versions
of the constructors found in the documentation for <code><a href="#topic+new_blueprint">new_blueprint()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_default_formula_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  ptypes = NULL,
  formula = NULL,
  indicators = "traditional",
  composition = "tibble",
  terms = list(predictors = NULL, outcomes = NULL),
  levels = NULL,
  ...,
  subclass = character()
)

new_default_recipe_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  fresh = TRUE,
  strings_as_factors = TRUE,
  composition = "tibble",
  ptypes = NULL,
  recipe = NULL,
  extra_role_ptypes = NULL,
  ...,
  subclass = character()
)

new_default_xy_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  composition = "tibble",
  ptypes = NULL,
  ...,
  subclass = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_default_formula_blueprint_+3A_intercept">intercept</code></td>
<td>
<p>A logical. Should an intercept be included in the
processed data? This information is used by the <code>process</code> function
in the <code>mold</code> and <code>forge</code> function list.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>A logical. Should novel factor levels be allowed at
prediction time? This information is used by the <code>clean</code> function in the
<code>forge</code> function list, and is passed on to <code><a href="#topic+scream">scream()</a></code>.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_ptypes">ptypes</code></td>
<td>
<p>Either <code>NULL</code>, or a named list with 2 elements, <code>predictors</code>
and <code>outcomes</code>, both of which are 0-row tibbles. <code>ptypes</code> is generated
automatically at <code><a href="#topic+mold">mold()</a></code> time and is used to validate <code>new_data</code> at
prediction time.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_formula">formula</code></td>
<td>
<p>Either <code>NULL</code>, or a formula that specifies how the
predictors and outcomes should be preprocessed. This argument is set
automatically at <code><a href="#topic+mold">mold()</a></code> time.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_indicators">indicators</code></td>
<td>
<p>A single character string. Control how factors are
expanded into dummy variable indicator columns. One of:
</p>

<ul>
<li> <p><code>"traditional"</code> - The default. Create dummy variables using the
traditional <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code> infrastructure. Generally this creates
<code>K - 1</code> indicator columns for each factor, where <code>K</code> is the number of
levels in that factor.
</p>
</li>
<li> <p><code>"none"</code> - Leave factor variables alone. No expansion is done.
</p>
</li>
<li> <p><code>"one_hot"</code> - Create dummy variables using a one-hot encoding approach
that expands unordered factors into all <code>K</code> indicator columns, rather than
<code>K - 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, or &quot;dgCMatrix&quot; for the format
of the processed predictors. If &quot;matrix&quot; or &quot;dgCMatrix&quot; are chosen, all of
the predictors must be numeric after the preprocessing method has been
applied; otherwise an error is thrown.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_terms">terms</code></td>
<td>
<p>A named list of two elements, <code>predictors</code> and <code>outcomes</code>. Both
elements are <code>terms</code> objects that describe the terms for the outcomes and
predictors separately. This argument is set automatically at <code><a href="#topic+mold">mold()</a></code> time.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_levels">levels</code></td>
<td>
<p>Either <code>NULL</code> or a named list of character vectors that
correspond to the levels observed when converting character predictor columns
to factors during <code><a href="#topic+mold">mold()</a></code>. This argument is set automatically at <code><a href="#topic+mold">mold()</a></code>
time.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_...">...</code></td>
<td>
<p>Name-value pairs for additional elements of blueprints that
subclass this blueprint.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_subclass">subclass</code></td>
<td>
<p>A character vector. The subclasses of this blueprint.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_fresh">fresh</code></td>
<td>
<p>Should already trained operations be re-trained when <code>prep()</code> is
called?</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_strings_as_factors">strings_as_factors</code></td>
<td>
<p>Should character columns be converted to factors
when <code>prep()</code> is called?</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_recipe">recipe</code></td>
<td>
<p>Either <code>NULL</code>, or an unprepped recipe. This argument is set
automatically at <code><a href="#topic+mold">mold()</a></code> time.</p>
</td></tr>
<tr><td><code id="new_default_formula_blueprint_+3A_extra_role_ptypes">extra_role_ptypes</code></td>
<td>
<p>A named list. The names are the unique non-standard
recipe roles (i.e. everything except <code>"predictors"</code> and <code>"outcomes"</code>). The
values are prototypes of the original columns with that role. These are
used for validation in <code>forge()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='new_formula_blueprint'>Create a new preprocessing blueprint</h2><span id='topic+new_formula_blueprint'></span><span id='topic+new_recipe_blueprint'></span><span id='topic+new_xy_blueprint'></span><span id='topic+new-blueprint'></span><span id='topic+new_blueprint'></span>

<h3>Description</h3>

<p>These are the base classes for creating new preprocessing blueprints. All
blueprints inherit from the one created by <code>new_blueprint()</code>, and the default
method specific blueprints inherit from the other three here.
</p>
<p>If you want to create your own processing blueprint for a specific method,
generally you will subclass one of the method specific blueprints here. If
you want to create a completely new preprocessing blueprint for a totally new
preprocessing method (i.e. not the formula, xy, or recipe method) then
you should subclass <code>new_blueprint()</code>.
</p>
<p>In addition to creating a blueprint subclass, you will likely also need to
provide S3 methods for <code><a href="#topic+run_mold">run_mold()</a></code> and <code><a href="#topic+run_forge">run_forge()</a></code> for your subclass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_formula_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  ptypes = NULL,
  formula = NULL,
  indicators = "traditional",
  composition = "tibble",
  ...,
  subclass = character()
)

new_recipe_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  fresh = TRUE,
  strings_as_factors = TRUE,
  composition = "tibble",
  ptypes = NULL,
  recipe = NULL,
  ...,
  subclass = character()
)

new_xy_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  composition = "tibble",
  ptypes = NULL,
  ...,
  subclass = character()
)

new_blueprint(
  intercept = FALSE,
  allow_novel_levels = FALSE,
  composition = "tibble",
  ptypes = NULL,
  ...,
  subclass = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_formula_blueprint_+3A_intercept">intercept</code></td>
<td>
<p>A logical. Should an intercept be included in the
processed data? This information is used by the <code>process</code> function
in the <code>mold</code> and <code>forge</code> function list.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>A logical. Should novel factor levels be allowed at
prediction time? This information is used by the <code>clean</code> function in the
<code>forge</code> function list, and is passed on to <code><a href="#topic+scream">scream()</a></code>.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_ptypes">ptypes</code></td>
<td>
<p>Either <code>NULL</code>, or a named list with 2 elements, <code>predictors</code>
and <code>outcomes</code>, both of which are 0-row tibbles. <code>ptypes</code> is generated
automatically at <code><a href="#topic+mold">mold()</a></code> time and is used to validate <code>new_data</code> at
prediction time.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_formula">formula</code></td>
<td>
<p>Either <code>NULL</code>, or a formula that specifies how the
predictors and outcomes should be preprocessed. This argument is set
automatically at <code><a href="#topic+mold">mold()</a></code> time.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_indicators">indicators</code></td>
<td>
<p>A single character string. Control how factors are
expanded into dummy variable indicator columns. One of:
</p>

<ul>
<li> <p><code>"traditional"</code> - The default. Create dummy variables using the
traditional <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code> infrastructure. Generally this creates
<code>K - 1</code> indicator columns for each factor, where <code>K</code> is the number of
levels in that factor.
</p>
</li>
<li> <p><code>"none"</code> - Leave factor variables alone. No expansion is done.
</p>
</li>
<li> <p><code>"one_hot"</code> - Create dummy variables using a one-hot encoding approach
that expands unordered factors into all <code>K</code> indicator columns, rather than
<code>K - 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, or &quot;dgCMatrix&quot; for the format
of the processed predictors. If &quot;matrix&quot; or &quot;dgCMatrix&quot; are chosen, all of
the predictors must be numeric after the preprocessing method has been
applied; otherwise an error is thrown.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_...">...</code></td>
<td>
<p>Name-value pairs for additional elements of blueprints that
subclass this blueprint.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_subclass">subclass</code></td>
<td>
<p>A character vector. The subclasses of this blueprint.</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_fresh">fresh</code></td>
<td>
<p>Should already trained operations be re-trained when <code>prep()</code> is
called?</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_strings_as_factors">strings_as_factors</code></td>
<td>
<p>Should character columns be converted to factors
when <code>prep()</code> is called?</p>
</td></tr>
<tr><td><code id="new_formula_blueprint_+3A_recipe">recipe</code></td>
<td>
<p>Either <code>NULL</code>, or an unprepped recipe. This argument is set
automatically at <code><a href="#topic+mold">mold()</a></code> time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A preprocessing blueprint, which is a list containing the inputs used as
arguments to the function, along with a class specific to the type
of blueprint being created.
</p>

<hr>
<h2 id='new_frequency_weights'>Construct a frequency weights vector</h2><span id='topic+new_frequency_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>new_frequency_weights()</code> is a developer oriented function for constructing
a new frequency weights vector. Generally, you should use
<code><a href="#topic+frequency_weights">frequency_weights()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_frequency_weights(x = integer(), ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_frequency_weights_+3A_x">x</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="new_frequency_weights_+3A_...">...</code></td>
<td>
<p>Name-value pairs defining attributes</p>
</td></tr>
<tr><td><code id="new_frequency_weights_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new frequency weights vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_frequency_weights()
new_frequency_weights(1:5)
</code></pre>

<hr>
<h2 id='new_importance_weights'>Construct an importance weights vector</h2><span id='topic+new_importance_weights'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>new_importance_weights()</code> is a developer oriented function for constructing
a new importance weights vector. Generally, you should use
<code><a href="#topic+importance_weights">importance_weights()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_importance_weights(x = double(), ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_importance_weights_+3A_x">x</code></td>
<td>
<p>A double vector.</p>
</td></tr>
<tr><td><code id="new_importance_weights_+3A_...">...</code></td>
<td>
<p>Name-value pairs defining attributes</p>
</td></tr>
<tr><td><code id="new_importance_weights_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new importance weights vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_importance_weights()
new_importance_weights(c(1.5, 2.3, 10))
</code></pre>

<hr>
<h2 id='new_model'>Constructor for a base model</h2><span id='topic+new_model'></span>

<h3>Description</h3>

<p>A <strong>model</strong> is a <em>scalar object</em>, as classified in
<a href="https://adv-r.hadley.nz/s3.html#object-styles">Advanced R</a>. As such, it
takes uniquely named elements in <code>...</code> and combines them into a list with
a class of <code>class</code>. This entire object represent a single model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_model(..., blueprint = default_xy_blueprint(), class = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_model_+3A_...">...</code></td>
<td>
<p>Name-value pairs for elements specific to the model defined by
<code>class</code>.</p>
</td></tr>
<tr><td><code id="new_model_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code> returned from a call to <code><a href="#topic+mold">mold()</a></code>.</p>
</td></tr>
<tr><td><code id="new_model_+3A_class">class</code></td>
<td>
<p>A character vector representing the class of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because every model should have multiple interfaces, including formula
and <code>recipes</code> interfaces, all models should have a <code>blueprint</code> that
can process new data when <code>predict()</code> is called. The easiest way to generate
an blueprint with all of the information required at prediction time is to
use the one that is returned from a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p>A new scalar model object, represented as a classed list with named elements
specified in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_model(
  custom_element = "my-elem",
  blueprint = default_xy_blueprint(),
  class = "custom_model"
)
</code></pre>

<hr>
<h2 id='quantile_pred'>Create a vector containing sets of quantiles</h2><span id='topic+quantile_pred'></span><span id='topic+extract_quantile_levels'></span><span id='topic+as_tibble.quantile_pred'></span><span id='topic+as.matrix.quantile_pred'></span>

<h3>Description</h3>

<p><code>quantile_pred()</code> is a special vector class used to efficiently store
predictions from a quantile regression model. It requires the same quantile
levels for each row being predicted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_pred(values, quantile_levels = double())

extract_quantile_levels(x)

## S3 method for class 'quantile_pred'
as_tibble(x, ..., .rows = NULL, .name_repair = "minimal", rownames = NULL)

## S3 method for class 'quantile_pred'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_pred_+3A_values">values</code></td>
<td>
<p>A matrix of values. Each column should correspond to one of
the quantile levels.</p>
</td></tr>
<tr><td><code id="quantile_pred_+3A_quantile_levels">quantile_levels</code></td>
<td>
<p>A vector of probabilities corresponding to <code>values</code>.</p>
</td></tr>
<tr><td><code id="quantile_pred_+3A_x">x</code></td>
<td>
<p>An object produced by <code>quantile_pred()</code>.</p>
</td></tr>
<tr><td><code id="quantile_pred_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="quantile_pred_+3A_.rows">.rows</code>, <code id="quantile_pred_+3A_.name_repair">.name_repair</code>, <code id="quantile_pred_+3A_rownames">rownames</code></td>
<td>
<p>Arguments not used but required by the
original S3 method.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>quantile_pred()</code> returns a vector of values associated with the
quantile levels.
</p>
</li>
<li> <p><code>extract_quantile_levels()</code> returns a numeric vector of levels.
</p>
</li>
<li> <p><code>as_tibble()</code> returns a tibble with rows <code>".pred_quantile"</code>,
<code>".quantile_levels"</code>, and <code>".row"</code>.
</p>
</li>
<li> <p><code>as.matrix()</code> returns an unnamed matrix with rows as samples, columns as
quantile levels, and entries are predictions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>.pred_quantile &lt;- quantile_pred(matrix(rnorm(20), 5), c(.2, .4, .6, .8))

unclass(.pred_quantile)

# Access the underlying information
extract_quantile_levels(.pred_quantile)

# Matrix format
as.matrix(.pred_quantile)

# Tidy format
library(tibble)
as_tibble(.pred_quantile)
</code></pre>

<hr>
<h2 id='recompose'>Recompose a data frame into another form</h2><span id='topic+recompose'></span>

<h3>Description</h3>

<p><code>recompose()</code> takes a data frame and converts it into one of:
</p>

<ul>
<li><p> A tibble
</p>
</li>
<li><p> A data frame
</p>
</li>
<li><p> A matrix
</p>
</li>
<li><p> A sparse matrix (using the Matrix package)
</p>
</li></ul>

<p>This is an internal function used only by hardhat and recipes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recompose(data, ..., composition = "tibble", call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recompose_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="recompose_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="recompose_+3A_composition">composition</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>"tibble"</code> to convert to a tibble.
</p>
</li>
<li> <p><code>"data.frame"</code> to convert to a base data frame.
</p>
</li>
<li> <p><code>"matrix"</code> to convert to a matrix. All columns must be numeric.
</p>
</li>
<li> <p><code>"dgCMatrix"</code> to convert to a sparse matrix. All columns must be numeric,
and the Matrix package must be installed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="recompose_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output type is determined from the <code>composition</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- vctrs::data_frame(x = 1)

recompose(df)
recompose(df, composition = "matrix")

# All columns must be numeric to convert to a matrix
df &lt;- vctrs::data_frame(x = 1, y = "a")
try(recompose(df, composition = "matrix"))
</code></pre>

<hr>
<h2 id='refresh_blueprint'>Refresh a preprocessing blueprint</h2><span id='topic+refresh_blueprint'></span>

<h3>Description</h3>

<p><code>refresh_blueprint()</code> is a developer facing generic function that is called
at the end of <code><a href="#topic+update_blueprint">update_blueprint()</a></code>. It simply is a wrapper around the
method specific <code style="white-space: pre;">&#8288;new_*_blueprint()&#8288;</code> function that runs the updated blueprint
through the constructor again to ensure that all of the elements of the
blueprint are still valid after the update.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refresh_blueprint(blueprint)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refresh_blueprint_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing blueprint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you implement your own custom <code>blueprint</code>, you should export a
<code>refresh_blueprint()</code> method that just calls the constructor for your blueprint
and passes through all of the elements of the blueprint to the constructor.
</p>


<h3>Value</h3>

<p><code>blueprint</code> is returned after a call to the corresponding constructor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
blueprint &lt;- default_xy_blueprint()

# This should never be done manually, but is essentially
# what `update_blueprint(blueprint, intercept = TRUE)` does for you
blueprint$intercept &lt;- TRUE

# Then update_blueprint() will call refresh_blueprint()
# to ensure that the structure is correct
refresh_blueprint(blueprint)

# So you can't do something like...
blueprint_bad &lt;- blueprint
blueprint_bad$intercept &lt;- 1

# ...because the constructor will catch it
try(refresh_blueprint(blueprint_bad))

# And update_blueprint() catches this automatically
try(update_blueprint(blueprint, intercept = 1))
</code></pre>

<hr>
<h2 id='run-forge'><code>forge()</code> according to a blueprint</h2><span id='topic+run-forge'></span><span id='topic+run_forge'></span><span id='topic+run_forge.default_formula_blueprint'></span><span id='topic+run_forge.default_recipe_blueprint'></span><span id='topic+run_forge.default_xy_blueprint'></span>

<h3>Description</h3>

<p>This is a developer facing function that is <em>only</em> used if you are creating
your own blueprint subclass. It is called from <code><a href="#topic+forge">forge()</a></code> and dispatches off
the S3 class of the <code>blueprint</code>. This gives you an opportunity to forge the
new data in a way that is specific to your blueprint.
</p>
<p><code>run_forge()</code> is always called from <code>forge()</code> with the same arguments, unlike
<code><a href="#topic+run_mold">run_mold()</a></code>, because there aren't different interfaces for calling
<code>forge()</code>. <code>run_forge()</code> is always called as:
</p>
<p><code>run_forge(blueprint, new_data = new_data, outcomes = outcomes)</code>
</p>
<p>If you write a blueprint subclass for <code><a href="#topic+new_xy_blueprint">new_xy_blueprint()</a></code>,
<code><a href="#topic+new_recipe_blueprint">new_recipe_blueprint()</a></code>, <code><a href="#topic+new_formula_blueprint">new_formula_blueprint()</a></code>, or <code><a href="#topic+new_blueprint">new_blueprint()</a></code>,
then your <code>run_forge()</code> method signature must match this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_forge(blueprint, new_data, ..., outcomes = FALSE)

## S3 method for class 'default_formula_blueprint'
run_forge(blueprint, new_data, ..., outcomes = FALSE, call = caller_env())

## S3 method for class 'default_recipe_blueprint'
run_forge(blueprint, new_data, ..., outcomes = FALSE, call = caller_env())

## S3 method for class 'default_xy_blueprint'
run_forge(blueprint, new_data, ..., outcomes = FALSE, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run-forge_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code>.</p>
</td></tr>
<tr><td><code id="run-forge_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or matrix of predictors to process. If
<code>outcomes = TRUE</code>, this should also contain the outcomes to process.</p>
</td></tr>
<tr><td><code id="run-forge_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="run-forge_+3A_outcomes">outcomes</code></td>
<td>
<p>A logical. Should the outcomes be processed and returned
as well?</p>
</td></tr>
<tr><td><code id="run-forge_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>run_forge()</code> methods return the object that is then immediately returned
from <code>forge()</code>. See the return value section of <code><a href="#topic+forge">forge()</a></code> to understand what
the structure of the return value should look like.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bp &lt;- default_xy_blueprint()

outcomes &lt;- mtcars["mpg"]
predictors &lt;- mtcars
predictors$mpg &lt;- NULL

mold &lt;- run_mold(bp, x = predictors, y = outcomes)

run_forge(mold$blueprint, new_data = predictors)
</code></pre>

<hr>
<h2 id='run-mold'><code>mold()</code> according to a blueprint</h2><span id='topic+run-mold'></span><span id='topic+run_mold'></span><span id='topic+run_mold.default_formula_blueprint'></span><span id='topic+run_mold.default_recipe_blueprint'></span><span id='topic+run_mold.default_xy_blueprint'></span>

<h3>Description</h3>

<p>This is a developer facing function that is <em>only</em> used if you are creating
your own blueprint subclass. It is called from <code><a href="#topic+mold">mold()</a></code> and dispatches off
the S3 class of the <code>blueprint</code>. This gives you an opportunity to mold the
data in a way that is specific to your blueprint.
</p>
<p><code>run_mold()</code> will be called with different arguments depending on the
interface to <code>mold()</code> that is used:
</p>

<ul>
<li><p> XY interface:
</p>

<ul>
<li> <p><code>run_mold(blueprint, x = x, y = y)</code>
</p>
</li></ul>

</li>
<li><p> Formula interface:
</p>

<ul>
<li> <p><code>run_mold(blueprint, data = data)</code>
</p>
</li>
<li><p> Additionally, the <code>blueprint</code> will have been updated to contain the
<code>formula</code>.
</p>
</li></ul>

</li>
<li><p> Recipe interface:
</p>

<ul>
<li> <p><code>run_mold(blueprint, data = data)</code>
</p>
</li>
<li><p> Additionally, the <code>blueprint</code> will have been updated to contain the
<code>recipe</code>.
</p>
</li></ul>

</li></ul>

<p>If you write a blueprint subclass for <code><a href="#topic+new_xy_blueprint">new_xy_blueprint()</a></code>,
<code><a href="#topic+new_recipe_blueprint">new_recipe_blueprint()</a></code>, or <code><a href="#topic+new_formula_blueprint">new_formula_blueprint()</a></code> then your <code>run_mold()</code>
method signature must match whichever interface listed above will be used.
</p>
<p>If you write a completely new blueprint inheriting only from
<code><a href="#topic+new_blueprint">new_blueprint()</a></code> and write a new <code><a href="#topic+mold">mold()</a></code> method (because you aren't using
an xy, formula, or recipe interface), then you will have full control over
how <code>run_mold()</code> will be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_mold(blueprint, ...)

## S3 method for class 'default_formula_blueprint'
run_mold(blueprint, ..., data, call = caller_env())

## S3 method for class 'default_recipe_blueprint'
run_mold(blueprint, ..., data, call = caller_env())

## S3 method for class 'default_xy_blueprint'
run_mold(blueprint, ..., x, y, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run-mold_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing blueprint.</p>
</td></tr>
<tr><td><code id="run-mold_+3A_...">...</code></td>
<td>
<p>Not used. Required for extensibility.</p>
</td></tr>
<tr><td><code id="run-mold_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the outcomes and predictors.</p>
</td></tr>
<tr><td><code id="run-mold_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
<tr><td><code id="run-mold_+3A_x">x</code></td>
<td>
<p>A data frame or matrix containing the predictors.</p>
</td></tr>
<tr><td><code id="run-mold_+3A_y">y</code></td>
<td>
<p>A data frame, matrix, or vector containing the outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>run_mold()</code> methods return the object that is then immediately returned from
<code>mold()</code>. See the return value section of <code><a href="#topic+mold">mold()</a></code> to understand what the
structure of the return value should look like.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bp &lt;- default_xy_blueprint()

outcomes &lt;- mtcars["mpg"]
predictors &lt;- mtcars
predictors$mpg &lt;- NULL

run_mold(bp, x = predictors, y = outcomes)
</code></pre>

<hr>
<h2 id='scream'>Scream</h2><span id='topic+scream'></span>

<h3>Description</h3>

<p><code>scream()</code> ensures that the structure of <code>data</code> is the same as
prototype, <code>ptype</code>. Under the hood, <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code> is used, which
casts each column of <code>data</code> to the same type as the corresponding
column in <code>ptype</code>.
</p>
<p>This casting enforces a number of important structural checks,
including but not limited to:
</p>

<ul>
<li> <p><em>Data Classes</em> - Checks that the class of each column in <code>data</code> is the
same as the corresponding column in <code>ptype</code>.
</p>
</li>
<li> <p><em>Novel Levels</em> - Checks that the factor columns in <code>data</code> don't have any
<em>new</em> levels when compared with the <code>ptype</code> columns. If there are new
levels, a warning is issued and they are coerced to <code>NA</code>. This check is
optional, and can be turned off with <code>allow_novel_levels = TRUE</code>.
</p>
</li>
<li> <p><em>Level Recovery</em> - Checks that the factor columns in <code>data</code> aren't
missing any factor levels when compared with the <code>ptype</code> columns. If
there are missing levels, then they are restored.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>scream(data, ptype, allow_novel_levels = FALSE, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scream_+3A_data">data</code></td>
<td>
<p>A data frame containing the new data to check the structure
of.</p>
</td></tr>
<tr><td><code id="scream_+3A_ptype">ptype</code></td>
<td>
<p>A data frame prototype to cast <code>data</code> to. This is commonly
a 0-row slice of the training set.</p>
</td></tr>
<tr><td><code id="scream_+3A_allow_novel_levels">allow_novel_levels</code></td>
<td>
<p>Should novel factor levels in <code>data</code> be allowed?
The safest approach is the default, which throws a warning when novel levels
are found, and coerces them to <code>NA</code> values. Setting this argument to <code>TRUE</code>
will ignore all novel levels. This argument does not apply to ordered
factors. Novel levels are not allowed in ordered factors because the
level ordering is a critical part of the type.</p>
</td></tr>
<tr><td><code id="scream_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="scream_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scream()</code> is called by <code><a href="#topic+forge">forge()</a></code> after <code><a href="#topic+shrink">shrink()</a></code> but before the
actual processing is done. Generally, you don't need to call <code>scream()</code>
directly, as <code>forge()</code> will do it for you.
</p>
<p>If <code>scream()</code> is used as a standalone function, it is good practice to call
<code><a href="#topic+shrink">shrink()</a></code> right before it as there are no checks in <code>scream()</code> that ensure
that all of the required column names actually exist in <code>data</code>. Those
checks exist in <code>shrink()</code>.
</p>


<h3>Value</h3>

<p>A tibble containing the required columns after any required structural
modifications have been made.
</p>


<h3>Factor Levels</h3>

<p><code>scream()</code> tries to be helpful by recovering missing factor levels and
warning about novel levels. The following graphic outlines how <code>scream()</code>
handles factor levels when coercing <em>from</em> a column in <code>data</code> <em>to</em> a
column in <code>ptype</code>.
</p>
<p><img src="../help/figures/factor-handling.png" alt="factor-handling.png" />
</p>
<p>Note that ordered factor handing is much stricter than factor handling.
Ordered factors in <code>data</code> must have <em>exactly</em> the same levels as ordered
factors in <code>ptype</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Setup

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

# mold() is run at model fit time
# and a formula preprocessing blueprint is recorded
x &lt;- mold(log(Sepal.Width) ~ Species, train)

# Inside the result of mold() are the prototype tibbles
# for the predictors and the outcomes
ptype_pred &lt;- x$blueprint$ptypes$predictors
ptype_out &lt;- x$blueprint$ptypes$outcomes

# ---------------------------------------------------------------------------
# shrink() / scream()

# Pass the test data, along with a prototype, to
# shrink() to extract the prototype columns
test_shrunk &lt;- shrink(test, ptype_pred)

# Now pass that to scream() to perform validation checks
# If no warnings / errors are thrown, the checks were
# successful!
scream(test_shrunk, ptype_pred)

# ---------------------------------------------------------------------------
# Outcomes

# To also extract the outcomes, use the outcome prototype
test_outcome &lt;- shrink(test, ptype_out)
scream(test_outcome, ptype_out)

# ---------------------------------------------------------------------------
# Casting

# scream() uses vctrs::vec_cast() to intelligently convert
# new data to the prototype automatically. This means
# it can automatically perform certain conversions, like
# coercing character columns to factors.
test2 &lt;- test
test2$Species &lt;- as.character(test2$Species)

test2_shrunk &lt;- shrink(test2, ptype_pred)
scream(test2_shrunk, ptype_pred)

# It can also recover missing factor levels.
# For example, it is plausible that the test data only had the
# "virginica" level
test3 &lt;- test
test3$Species &lt;- factor(test3$Species, levels = "virginica")

test3_shrunk &lt;- shrink(test3, ptype_pred)
test3_fixed &lt;- scream(test3_shrunk, ptype_pred)

# scream() recovered the missing levels
levels(test3_fixed$Species)

# ---------------------------------------------------------------------------
# Novel levels

# When novel levels with any data are present in `data`, the default
# is to coerce them to `NA` values with a warning.
test4 &lt;- test
test4$Species &lt;- as.character(test4$Species)
test4$Species[1] &lt;- "new_level"

test4$Species &lt;- factor(
  test4$Species,
  levels = c(levels(test$Species), "new_level")
)

test4 &lt;- shrink(test4, ptype_pred)

# Warning is thrown
test4_removed &lt;- scream(test4, ptype_pred)

# Novel level is removed
levels(test4_removed$Species)

# No warning is thrown
test4_kept &lt;- scream(test4, ptype_pred, allow_novel_levels = TRUE)

# Novel level is kept
levels(test4_kept$Species)
</code></pre>

<hr>
<h2 id='shrink'>Subset only required columns</h2><span id='topic+shrink'></span>

<h3>Description</h3>

<p><code>shrink()</code> subsets <code>data</code> to only contain the required columns specified by
the prototype, <code>ptype</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink(data, ptype, ..., call = current_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrink_+3A_data">data</code></td>
<td>
<p>A data frame containing the data to subset.</p>
</td></tr>
<tr><td><code id="shrink_+3A_ptype">ptype</code></td>
<td>
<p>A data frame prototype containing the required columns.</p>
</td></tr>
<tr><td><code id="shrink_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="shrink_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shrink()</code> is called by <code><a href="#topic+forge">forge()</a></code> before <code><a href="#topic+scream">scream()</a></code> and before the actual
processing is done.
</p>


<h3>Value</h3>

<p>A tibble containing the required columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Setup

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

# ---------------------------------------------------------------------------
# shrink()

# mold() is run at model fit time
# and a formula preprocessing blueprint is recorded
x &lt;- mold(log(Sepal.Width) ~ Species, train)

# Inside the result of mold() are the prototype tibbles
# for the predictors and the outcomes
ptype_pred &lt;- x$blueprint$ptypes$predictors
ptype_out &lt;- x$blueprint$ptypes$outcomes

# Pass the test data, along with a prototype, to
# shrink() to extract the prototype columns
shrink(test, ptype_pred)

# To extract the outcomes, just use the
# outcome prototype
shrink(test, ptype_out)

# shrink() makes sure that the columns
# required by `ptype` actually exist in the data
# and errors nicely when they don't
test2 &lt;- subset(test, select = -Species)
try(shrink(test2, ptype_pred))
</code></pre>

<hr>
<h2 id='spruce'>Spruce up predictions</h2><span id='topic+spruce'></span><span id='topic+spruce_numeric'></span><span id='topic+spruce_class'></span><span id='topic+spruce_prob'></span>

<h3>Description</h3>

<p>The family of <code style="white-space: pre;">&#8288;spruce_*()&#8288;</code> functions convert predictions into a
standardized format. They are generally called from a prediction
implementation function for the specific <code>type</code> of prediction to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spruce_numeric(pred)

spruce_class(pred_class)

spruce_prob(pred_levels, prob_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spruce_+3A_pred">pred</code></td>
<td>
<p>(<code>type = "numeric"</code>) A numeric vector of predictions.</p>
</td></tr>
<tr><td><code id="spruce_+3A_pred_class">pred_class</code></td>
<td>
<p>(<code>type = "class"</code>) A factor of &quot;hard&quot; class predictions.</p>
</td></tr>
<tr><td><code id="spruce_+3A_pred_levels">pred_levels</code>, <code id="spruce_+3A_prob_matrix">prob_matrix</code></td>
<td>
<p>(<code>type = "prob"</code>)
</p>

<ul>
<li> <p><code>pred_levels</code> should be a character vector of the original levels of
the outcome used in training.
</p>
</li>
<li> <p><code>prob_matrix</code> should be a numeric matrix of class probabilities with
as many columns as levels in <code>pred_levels</code>, and in the same order.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>After running a <code style="white-space: pre;">&#8288;spruce_*()&#8288;</code> function, you should <em>always</em> use the validation
function <code>validate_prediction_size()</code> to ensure that the number of rows
being returned is the same as the number of rows in the input (<code>new_data</code>).
</p>


<h3>Value</h3>

<p>A tibble, ideally with the same number of rows as the <code>new_data</code> passed
to <code>predict()</code>. The column names and number of columns vary based on the
function used, but are standardized.
</p>

<hr>
<h2 id='spruce-multiple'>Spruce up multi-outcome predictions</h2><span id='topic+spruce-multiple'></span><span id='topic+spruce_numeric_multiple'></span><span id='topic+spruce_class_multiple'></span><span id='topic+spruce_prob_multiple'></span>

<h3>Description</h3>

<p>This family of <code style="white-space: pre;">&#8288;spruce_*_multiple()&#8288;</code> functions converts multi-outcome
predictions into a standardized format. They are generally called from a
prediction implementation function for the specific <code>type</code> of prediction to
return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spruce_numeric_multiple(...)

spruce_class_multiple(...)

spruce_prob_multiple(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spruce-multiple_+3A_...">...</code></td>
<td>
<p>Multiple vectors of predictions:
</p>

<ul>
<li><p> For <code>spruce_numeric_multiple()</code>, numeric vectors of equal size.
</p>
</li>
<li><p> For <code>spruce_class_multiple()</code>, factors of &quot;hard&quot; class predictions of
equal size.
</p>
</li>
<li><p> For <code>spruce_prob_multiple()</code>, tibbles of equal size, which are the result
of calling <code><a href="#topic+spruce_prob">spruce_prob()</a></code> on each matrix of prediction probabilities.
</p>
</li></ul>

<p>If the <code>...</code> are named, then this name will be used as the suffix on the
resulting column name, otherwise a positional index will be used.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>spruce_numeric_multiple()</code>, a tibble of numeric columns named with the
pattern <code style="white-space: pre;">&#8288;.pred_*&#8288;</code>.
</p>
</li>
<li><p> For <code>spruce_class_multiple()</code>, a tibble of factor columns named with the
pattern <code style="white-space: pre;">&#8288;.pred_class_*&#8288;</code>.
</p>
</li>
<li><p> For <code>spruce_prob_multiple()</code>, a tibble of data frame columns named with the
pattern <code style="white-space: pre;">&#8288;.pred_*&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>spruce_numeric_multiple(1:3, foo = 2:4)

spruce_class_multiple(
  one_step = factor(c("a", "b", "c")),
  two_step = factor(c("a", "c", "c"))
)

one_step &lt;- matrix(c(.3, .7, .0, .1, .3, .6), nrow = 2, byrow = TRUE)
two_step &lt;- matrix(c(.2, .7, .1, .2, .4, .4), nrow = 2, byrow = TRUE)
binary &lt;- matrix(c(.5, .5, .4, .6), nrow = 2, byrow = TRUE)

spruce_prob_multiple(
  one_step = spruce_prob(c("a", "b", "c"), one_step),
  two_step = spruce_prob(c("a", "b", "c"), two_step),
  binary = spruce_prob(c("yes", "no"), binary)
)
</code></pre>

<hr>
<h2 id='standardize'>Standardize the outcome</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Most of the time, the input to a model should be flexible enough to capture
a number of different input types from the user. <code>standardize()</code> focuses
on capturing the flexibility in the <em>outcome</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_+3A_y">y</code></td>
<td>
<p>The outcome. This can be:
</p>

<ul>
<li><p> A factor vector
</p>
</li>
<li><p> A numeric vector
</p>
</li>
<li><p> A 1D numeric array
</p>
</li>
<li><p> A numeric matrix with column names
</p>
</li>
<li><p> A 2D numeric array with column names
</p>
</li>
<li><p> A data frame with numeric or factor columns
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize()</code> is called from <code><a href="#topic+mold">mold()</a></code> when using an XY interface (i.e.
a <code>y</code> argument was supplied).
</p>


<h3>Value</h3>

<p>All possible values of <code>y</code> are transformed into a <code>tibble</code> for
standardization. Vectors are transformed into a <code>tibble</code> with
a single column named <code>".outcome"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardize(1:5)

standardize(factor(letters[1:5]))

mat &lt;- matrix(1:10, ncol = 2)
colnames(mat) &lt;- c("a", "b")
standardize(mat)

df &lt;- data.frame(x = 1:5, y = 6:10)
standardize(df)
</code></pre>

<hr>
<h2 id='tune'>Mark arguments for tuning</h2><span id='topic+tune'></span>

<h3>Description</h3>

<p><code>tune()</code> is an argument placeholder to be used with the recipes, parsnip, and
tune packages. It marks recipes step and parsnip model arguments for tuning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune(id = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_+3A_id">id</code></td>
<td>
<p>A single character value that can be used to differentiate
parameters that are used in multiple places but have the same name, or if
the user wants to add a note to the specified parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call object that echos the user's input.
</p>


<h3>See Also</h3>

<p><code>tune::tune_grid()</code>, <code>tune::tune_bayes()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tune()
tune("your name here")

# In practice, `tune()` is used alongside recipes or parsnip to mark
# specific arguments for tuning
library(recipes)

recipe(mpg ~ ., data = mtcars) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_pca(all_numeric_predictors, num_comp = tune())

</code></pre>

<hr>
<h2 id='update_blueprint'>Update a preprocessing blueprint</h2><span id='topic+update_blueprint'></span>

<h3>Description</h3>

<p><code>update_blueprint()</code> is the correct way to alter elements of an existing
<code>blueprint</code> object. It has two benefits over just doing
<code>blueprint$elem &lt;- new_elem</code>.
</p>

<ul>
<li><p> The name you are updating <em>must</em> already exist in the blueprint. This prevents
you from accidentally updating non-existent elements.
</p>
</li>
<li><p> The constructor for the blueprint is automatically run after the update by
<code>refresh_blueprint()</code> to ensure that the blueprint is still valid.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>update_blueprint(blueprint, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_blueprint_+3A_blueprint">blueprint</code></td>
<td>
<p>A preprocessing blueprint.</p>
</td></tr>
<tr><td><code id="update_blueprint_+3A_...">...</code></td>
<td>
<p>Name-value pairs of <em>existing</em> elements in <code>blueprint</code> that should
be updated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
blueprint &lt;- default_xy_blueprint()

# `intercept` defaults to FALSE
blueprint

update_blueprint(blueprint, intercept = TRUE)

# Can't update non-existent elements
try(update_blueprint(blueprint, intercpt = TRUE))

# Can't add non-valid elements
try(update_blueprint(blueprint, intercept = 1))
</code></pre>

<hr>
<h2 id='validate_column_names'>Ensure that <code>data</code> contains required column names</h2><span id='topic+validate_column_names'></span><span id='topic+check_column_names'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li><p> The column names of <code>data</code> must contain all <code>original_names</code>.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>missing_names</code> A character vector. The missing column names.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_column_names(data, original_names, ..., call = current_env())

check_column_names(data, original_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_column_names_+3A_data">data</code></td>
<td>
<p>A data frame to check.</p>
</td></tr>
<tr><td><code id="validate_column_names_+3A_original_names">original_names</code></td>
<td>
<p>A character vector. The original column names.</p>
</td></tr>
<tr><td><code id="validate_column_names_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_column_names_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A special error is thrown if the missing column is named <code>".outcome"</code>. This
only happens in the case where <code><a href="#topic+mold">mold()</a></code> is called using the xy-method, and
a <em>vector</em> <code>y</code> value is supplied rather than a data frame or matrix. In that
case, <code>y</code> is coerced to a data frame, and the automatic name <code>".outcome"</code> is
added, and this is what is looked for in <code><a href="#topic+forge">forge()</a></code>. If this happens, and the
user tries to request outcomes using <code>forge(..., outcomes = TRUE)</code> but
the supplied <code>new_data</code> does not contain the required <code>".outcome"</code> column,
a special error is thrown telling them what to do. See the examples!
</p>


<h3>Value</h3>

<p><code>validate_column_names()</code> returns <code>data</code> invisibly.
</p>
<p><code>check_column_names()</code> returns a named list of two components,
<code>ok</code>, and <code>missing_names</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------

original_names &lt;- colnames(mtcars)

test &lt;- mtcars
bad_test &lt;- test[, -c(3, 4)]

# All good
check_column_names(test, original_names)

# Missing 2 columns
check_column_names(bad_test, original_names)

# Will error
try(validate_column_names(bad_test, original_names))

# ---------------------------------------------------------------------------
# Special error when `.outcome` is missing

train &lt;- iris[1:100, ]
test &lt;- iris[101:150, ]

train_x &lt;- subset(train, select = -Species)
train_y &lt;- train$Species

# Here, y is a vector
processed &lt;- mold(train_x, train_y)

# So the default column name is `".outcome"`
processed$outcomes

# It doesn't affect forge() normally
forge(test, processed$blueprint)

# But if the outcome is requested, and `".outcome"`
# is not present in `new_data`, an error is thrown
# with very specific instructions
try(forge(test, processed$blueprint, outcomes = TRUE))

# To get this to work, just create an .outcome column in new_data
test$.outcome &lt;- test$Species

forge(test, processed$blueprint, outcomes = TRUE)
</code></pre>

<hr>
<h2 id='validate_no_formula_duplication'>Ensure no duplicate terms appear in <code>formula</code></h2><span id='topic+validate_no_formula_duplication'></span><span id='topic+check_no_formula_duplication'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>formula</code> must not have duplicates terms on the left and right hand
side of the formula.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>duplicates</code> A character vector. The duplicate terms.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_no_formula_duplication(formula, original = FALSE)

check_no_formula_duplication(formula, original = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_no_formula_duplication_+3A_formula">formula</code></td>
<td>
<p>A formula to check.</p>
</td></tr>
<tr><td><code id="validate_no_formula_duplication_+3A_original">original</code></td>
<td>
<p>A logical. Should the original names be checked, or should
the names after processing be used? If <code>FALSE</code>, <code>y ~ log(y)</code> is allowed
because the names are <code>"y"</code> and <code>"log(y)"</code>, if <code>TRUE</code>, <code>y ~ log(y)</code> is not
allowed because the original names are both <code>"y"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>validate_no_formula_duplication()</code> returns <code>formula</code> invisibly.
</p>
<p><code>check_no_formula_duplication()</code> returns a named list of two components,
<code>ok</code> and <code>duplicates</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All good
check_no_formula_duplication(y ~ x)

# Not good!
check_no_formula_duplication(y ~ y)

# This is generally okay
check_no_formula_duplication(y ~ log(y))

# But you can be more strict
check_no_formula_duplication(y ~ log(y), original = TRUE)

# This would throw an error
try(validate_no_formula_duplication(log(y) ~ log(y)))
</code></pre>

<hr>
<h2 id='validate_outcomes_are_binary'>Ensure that the outcome has binary factors</h2><span id='topic+validate_outcomes_are_binary'></span><span id='topic+check_outcomes_are_binary'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>outcomes</code> must have binary factor columns.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>bad_cols</code> A character vector. The names of the columns with problems.
</p>
</li>
<li> <p><code>num_levels</code> An integer vector. The actual number of levels of the columns
with problems.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_outcomes_are_binary(outcomes)

check_outcomes_are_binary(outcomes, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_outcomes_are_binary_+3A_outcomes">outcomes</code></td>
<td>
<p>An object to check.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_binary_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_binary_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected way to use this validation function is to supply it the
<code style="white-space: pre;">&#8288;$outcomes&#8288;</code> element of the result of a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p><code>validate_outcomes_are_binary()</code> returns <code>outcomes</code> invisibly.
</p>
<p><code>check_outcomes_are_binary()</code> returns a named list of three components,
<code>ok</code>, <code>bad_cols</code>, and <code>num_levels</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not a binary factor. 0 levels
check_outcomes_are_binary(data.frame(x = 1))

# Not a binary factor. 1 level
check_outcomes_are_binary(data.frame(x = factor("A")))

# All good
check_outcomes_are_binary(data.frame(x = factor(c("A", "B"))))
</code></pre>

<hr>
<h2 id='validate_outcomes_are_factors'>Ensure that the outcome has only factor columns</h2><span id='topic+validate_outcomes_are_factors'></span><span id='topic+check_outcomes_are_factors'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>outcomes</code> must have factor columns.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>bad_classes</code> A named list. The names are the names of problematic columns,
and the values are the classes of the matching column.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_outcomes_are_factors(outcomes)

check_outcomes_are_factors(outcomes, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_outcomes_are_factors_+3A_outcomes">outcomes</code></td>
<td>
<p>An object to check.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_factors_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_factors_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected way to use this validation function is to supply it the
<code style="white-space: pre;">&#8288;$outcomes&#8288;</code> element of the result of a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p><code>validate_outcomes_are_factors()</code> returns <code>outcomes</code> invisibly.
</p>
<p><code>check_outcomes_are_factors()</code> returns a named list of two components,
<code>ok</code> and <code>bad_classes</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not a factor column.
check_outcomes_are_factors(data.frame(x = 1))

# All good
check_outcomes_are_factors(data.frame(x = factor(c("A", "B"))))
</code></pre>

<hr>
<h2 id='validate_outcomes_are_numeric'>Ensure outcomes are all numeric</h2><span id='topic+validate_outcomes_are_numeric'></span><span id='topic+check_outcomes_are_numeric'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>outcomes</code> must have numeric columns.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>bad_classes</code> A named list. The names are the names of problematic columns,
and the values are the classes of the matching column.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_outcomes_are_numeric(outcomes)

check_outcomes_are_numeric(outcomes, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_outcomes_are_numeric_+3A_outcomes">outcomes</code></td>
<td>
<p>An object to check.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_numeric_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_outcomes_are_numeric_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected way to use this validation function is to supply it the
<code style="white-space: pre;">&#8288;$outcomes&#8288;</code> element of the result of a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p><code>validate_outcomes_are_numeric()</code> returns <code>outcomes</code> invisibly.
</p>
<p><code>check_outcomes_are_numeric()</code> returns a named list of two components,
<code>ok</code> and <code>bad_classes</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All good
check_outcomes_are_numeric(mtcars)

# Species is not numeric
check_outcomes_are_numeric(iris)

# This gives an intelligent error message
try(validate_outcomes_are_numeric(iris))
</code></pre>

<hr>
<h2 id='validate_outcomes_are_univariate'>Ensure that the outcome is univariate</h2><span id='topic+validate_outcomes_are_univariate'></span><span id='topic+check_outcomes_are_univariate'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>outcomes</code> must have 1 column. Atomic vectors are treated as
1 column matrices.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>n_cols</code> A single numeric. The actual number of columns.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_outcomes_are_univariate(outcomes)

check_outcomes_are_univariate(outcomes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_outcomes_are_univariate_+3A_outcomes">outcomes</code></td>
<td>
<p>An object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected way to use this validation function is to supply it the
<code style="white-space: pre;">&#8288;$outcomes&#8288;</code> element of the result of a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p><code>validate_outcomes_are_univariate()</code> returns <code>outcomes</code> invisibly.
</p>
<p><code>check_outcomes_are_univariate()</code> returns a named list of two components,
<code>ok</code> and <code>n_cols</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_outcomes_are_univariate(data.frame(x = 1))

try(validate_outcomes_are_univariate(mtcars))
</code></pre>

<hr>
<h2 id='validate_prediction_size'>Ensure that predictions have the correct number of rows</h2><span id='topic+validate_prediction_size'></span><span id='topic+check_prediction_size'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li><p> The size of <code>pred</code> must be the same as the size of <code>new_data</code>.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>size_new_data</code> A single numeric. The size of <code>new_data</code>.
</p>
</li>
<li> <p><code>size_pred</code> A single numeric. The size of <code>pred</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_prediction_size(pred, new_data)

check_prediction_size(pred, new_data, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_prediction_size_+3A_pred">pred</code></td>
<td>
<p>A tibble. The predictions to return from any prediction
<code>type</code>. This is often created using one of the spruce functions, like
<code><a href="#topic+spruce_numeric">spruce_numeric()</a></code>.</p>
</td></tr>
<tr><td><code id="validate_prediction_size_+3A_new_data">new_data</code></td>
<td>
<p>A data frame of new predictors and possibly outcomes.</p>
</td></tr>
<tr><td><code id="validate_prediction_size_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_prediction_size_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This validation function is one that is more developer focused rather than
user focused. It is a final check to be used right before a value is
returned from your specific <code>predict()</code> method, and is mainly a &quot;good
practice&quot; sanity check to ensure that your prediction blueprint always returns
the same number of rows as <code>new_data</code>, which is one of the modeling
conventions this package tries to promote.
</p>


<h3>Value</h3>

<p><code>validate_prediction_size()</code> returns <code>pred</code> invisibly.
</p>
<p><code>check_prediction_size()</code> returns a named list of three components,
<code>ok</code>, <code>size_new_data</code>, and <code>size_pred</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_predictors_are_numeric">validate_predictors_are_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Say new_data has 5 rows
new_data &lt;- mtcars[1:5, ]

# And somehow you generate predictions
# for those 5 rows
pred_vec &lt;- 1:5

# Then you use `spruce_numeric()` to clean
# up these numeric predictions
pred &lt;- spruce_numeric(pred_vec)

pred

# Use this check to ensure that
# the number of rows or pred match new_data
check_prediction_size(pred, new_data)

# An informative error message is thrown
# if the rows are different
try(validate_prediction_size(spruce_numeric(1:4), new_data))
</code></pre>

<hr>
<h2 id='validate_predictors_are_numeric'>Ensure predictors are all numeric</h2><span id='topic+validate_predictors_are_numeric'></span><span id='topic+check_predictors_are_numeric'></span>

<h3>Description</h3>

<p>validate - asserts the following:
</p>

<ul>
<li> <p><code>predictors</code> must have numeric columns.
</p>
</li></ul>

<p>check - returns the following:
</p>

<ul>
<li> <p><code>ok</code> A logical. Does the check pass?
</p>
</li>
<li> <p><code>bad_classes</code> A named list. The names are the names of problematic columns,
and the values are the classes of the matching column.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_predictors_are_numeric(predictors)

check_predictors_are_numeric(predictors, ..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_predictors_are_numeric_+3A_predictors">predictors</code></td>
<td>
<p>An object to check.</p>
</td></tr>
<tr><td><code id="validate_predictors_are_numeric_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validate_predictors_are_numeric_+3A_call">call</code></td>
<td>
<p>The call used for errors and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected way to use this validation function is to supply it the
<code style="white-space: pre;">&#8288;$predictors&#8288;</code> element of the result of a call to <code><a href="#topic+mold">mold()</a></code>.
</p>


<h3>Value</h3>

<p><code>validate_predictors_are_numeric()</code> returns <code>predictors</code> invisibly.
</p>
<p><code>check_predictors_are_numeric()</code> returns a named list of two components,
<code>ok</code>, and <code>bad_classes</code>.
</p>


<h3>Validation</h3>

<p>hardhat provides validation functions at two levels.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;check_*()&#8288;</code>:  <em>check a condition, and return a list</em>. The list
always contains at least one element, <code>ok</code>, a logical that specifies if the
check passed. Each check also has check specific elements in the returned
list that can be used to construct meaningful error messages.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;validate_*()&#8288;</code>: <em>check a condition, and error if it does not pass</em>. These
functions call their corresponding check function, and
then provide a default error message. If you, as a developer, want a
different error message, then call the <code style="white-space: pre;">&#8288;check_*()&#8288;</code> function yourself,
and provide your own validation function.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+validate_column_names">validate_column_names</a>()</code>,
<code><a href="#topic+validate_no_formula_duplication">validate_no_formula_duplication</a>()</code>,
<code><a href="#topic+validate_outcomes_are_binary">validate_outcomes_are_binary</a>()</code>,
<code><a href="#topic+validate_outcomes_are_factors">validate_outcomes_are_factors</a>()</code>,
<code><a href="#topic+validate_outcomes_are_numeric">validate_outcomes_are_numeric</a>()</code>,
<code><a href="#topic+validate_outcomes_are_univariate">validate_outcomes_are_univariate</a>()</code>,
<code><a href="#topic+validate_prediction_size">validate_prediction_size</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All good
check_predictors_are_numeric(mtcars)

# Species is not numeric
check_predictors_are_numeric(iris)

# This gives an intelligent error message
try(validate_predictors_are_numeric(iris))
</code></pre>

<hr>
<h2 id='weighted_table'>Weighted table</h2><span id='topic+weighted_table'></span>

<h3>Description</h3>

<p><code>weighted_table()</code> computes a weighted contingency table based on factors
provided in <code>...</code> and a double vector of weights provided in <code>weights</code>. It
can be seen as a weighted extension to <code><a href="base.html#topic+table">base::table()</a></code> and an alternative
to <code><a href="stats.html#topic+xtabs">stats::xtabs()</a></code>.
</p>
<p><code>weighted_table()</code> always uses the <em>exact</em> set of levels returned by
<code>levels()</code> when constructing the table. This results in the following
properties:
</p>

<ul>
<li><p> Missing values found in the factors are never included in the table unless
there is an explicit <code>NA</code> factor level. If needed, this can be added to a
factor with <code><a href="base.html#topic+factor">base::addNA()</a></code> or <code>forcats::fct_expand(x, NA)</code>.
</p>
</li>
<li><p> Levels found in the factors that aren't actually used in the underlying
data are included in the table with a value of <code>0</code>. If needed, you can
drop unused factor levels by re-running your factor through <code><a href="base.html#topic+factor">factor()</a></code>,
or by calling <code>forcats::fct_drop()</code>.
</p>
</li></ul>

<p>See the examples section for more information about these properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_table(..., weights, na_remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_table_+3A_...">...</code></td>
<td>
<p>Factors of equal length to use in the weighted table. If the
<code>...</code> are named, those names will propagate onto the &quot;dimnames names&quot; of
the resulting table. At least one factor must be provided.</p>
</td></tr>
<tr><td><code id="weighted_table_+3A_weights">weights</code></td>
<td>
<p>A double vector of weights used to fill the cells of the
weighted table. This must be the same length as the factors provided in
<code>...</code>.</p>
</td></tr>
<tr><td><code id="weighted_table_+3A_na_remove">na_remove</code></td>
<td>
<p>A single <code>TRUE</code> or <code>FALSE</code> for handling whether or not
missing values in <code>weights</code> should be removed when summing up the weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of <code>weighted_table()</code> does not have a <code>"table"</code> class attached
to it. It is only a double array. This is because &quot;table&quot; objects are
defined as containing integer counts, but weighted tables can utilize
fractional weights.
</p>


<h3>Value</h3>

<p>The weighted table as an array of double values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(c("x", "y", "z", "x", "x", "y"))
y &lt;- factor(c("a", "b", "a", "a", "b", "b"))
w &lt;- c(1.5, 2, 1.1, .5, 3, 2)

weighted_table(x = x, y = y, weights = w)

# ---------------------------------------------------------------------------
# If `weights` contains missing values, then missing values will be
# propagated into the weighted table
x &lt;- factor(c("x", "y", "y"))
y &lt;- factor(c("a", "b", "b"))
w &lt;- c(1, NA, 3)

weighted_table(x = x, y = y, weights = w)

# You can remove the missing values while summing up the weights with
# `na_remove = TRUE`
weighted_table(x = x, y = y, weights = w, na_remove = TRUE)

# ---------------------------------------------------------------------------
# If there are missing values in the factors, those typically don't show
# up in the weighted table
x &lt;- factor(c("x", NA, "y", "x"))
y &lt;- factor(c("a", "b", "a", NA))
w &lt;- 1:4

weighted_table(x = x, y = y, weights = w)

# This is because the missing values aren't considered explicit levels
levels(x)

# You can force them to show up in the table by using `addNA()` ahead of time
# (or `forcats::fct_expand(x, NA)`)
x &lt;- addNA(x, ifany = TRUE)
y &lt;- addNA(y, ifany = TRUE)
levels(x)

weighted_table(x = x, y = y, weights = w)

# ---------------------------------------------------------------------------
# If there are levels in your factors that aren't actually used in the
# underlying data, then they will still show up in the table with a `0` value
x &lt;- factor(c("x", "y", "x"), levels = c("x", "y", "z"))
y &lt;- factor(c("a", "b", "a"), levels = c("a", "b", "c"))
w &lt;- 1:3

weighted_table(x = x, y = y, weights = w)

# If you want to drop these empty factor levels from the result, you can
# rerun `factor()` ahead of time to drop them (or `forcats::fct_drop()`)
x &lt;- factor(x)
y &lt;- factor(y)
levels(x)

weighted_table(x = x, y = y, weights = w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
