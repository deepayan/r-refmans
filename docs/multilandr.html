<!DOCTYPE html><html lang="en"><head><title>Help for package multilandr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multilandr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_raster'><p>Check input raster</p></a></li>
<li><a href='#conditions'><p>Define metric conditions</p></a></li>
<li><a href='#ed_metrics'><p>'MultiLandMetrics' object</p></a></li>
<li><a href='#generate_points'><p>Generates point coordinates</p></a></li>
<li><a href='#metrics_bind'><p>Metric's data preparation</p></a></li>
<li><a href='#metrics_corr'><p>Pairwise metric correlations</p></a></li>
<li><a href='#metrics_filter'><p>Filters metrics</p></a></li>
<li><a href='#metrics_gradient'><p>Generates optimized metrics gradient</p></a></li>
<li><a href='#metrics_list'><p>Metrics list</p></a></li>
<li><a href='#metrics_plots'><p>Pairwise metric plots</p></a></li>
<li><a href='#metrics_scalogram'><p>Scalograms</p></a></li>
<li><a href='#mland'><p>Generates object of class 'MultiLand'</p></a></li>
<li><a href='#mland_export_gis'><p>Exports a 'MultiLand' object as GIS data</p></a></li>
<li><a href='#mland_load'><p>Load 'MultiLand' or 'MultiLandMetrics' object</p></a></li>
<li><a href='#mland_metrics'><p>Calculates landscape metrics</p></a></li>
<li><a href='#mland_overlap'><p>Buffers overlapping</p></a></li>
<li><a href='#mland_plot'><p>Plots landscapes from 'MultiLand' objects</p></a></li>
<li><a href='#mland_save'><p>Saves a 'MultiLand' or 'MultiLandMetrics' object</p></a></li>
<li><a href='#MultiLand-class'><p>Class &quot;MultiLand&quot;</p></a></li>
<li><a href='#MultiLandMetrics-class'><p>Class 'MultiLandMetrics'</p></a></li>
<li><a href='#otf_metrics'><p>'MultiLandMetrics' object</p></a></li>
<li><a href='#show+2CMultiLand-method'><p>Show 'MultiLand' object</p></a></li>
<li><a href='#show+2CMultiLandMetrics-method'><p>Show 'MultiLandMetrics' object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Landscape Analysis at Multiple Spatial Scales</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pablo Yair Huais &lt;pablo.huais@unc.edu.ar&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a tidy workflow for landscape-scale analysis. 'multilandr' offers tools to generate landscapes at multiple spatial scales and compute landscape metrics, primarily using the 'landscapemetrics' package. It also features utility functions for plotting and analyzing multi-scale landscapes, exploring correlations between metrics, filtering landscapes based on specific conditions, generating landscape gradients for a given metric, and preparing datasets for further statistical analysis. Documentation about 'multilandr' is provided in an introductory vignette included in this package and in the paper by Huais (2024) &lt;<a href="https://doi.org/10.1007%2Fs10980-024-01930-z">doi:10.1007/s10980-024-01930-z</a>&gt;; see citation("multilandr") for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra (&ge; 1.7-71), GGally (&ge; 2.2.1), ggplot2 (&ge; 3.5.1),
tidyterra (&ge; 0.6.0), gridExtra (&ge; 2.3), landscapemetrics (&ge;
2.1.1), sf (&ge; 1.0-16), methods (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, parallel (&ge; 4.1.0), rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'check_raster.R' 'classes.R' 'data.R' 'func_checks.R'
'generate_points.R' 'generate_points_checks.R' 'globals.R'
'methods.R' 'metrics_bind.R' 'metrics_corr.R'
'metrics_corr_checks.R' 'metrics_filter.R'
'metrics_filter_checks.R' 'metrics_gradient.R'
'metrics_gradient_checks.R' 'metrics_list.R' 'metrics_plots.R'
'metrics_scalogram.R' 'metrics_scalogram_checks.R' 'mland.R'
'mland_checks.R' 'mland_export_gis.R' 'mland_load.R'
'mland_metrics.R' 'mland_metrics_checks.R' 'mland_overlap.R'
'mland_overlap_checks.R' 'mland_plot.R' 'mland_plot_checks.R'
'mland_save.R' 'utils.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/phuais/multilandr">https://github.com/phuais/multilandr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/phuais/multilandr/issues">https://github.com/phuais/multilandr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-13 15:17:38 UTC; pablo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pablo Yair Huais <a href="https://orcid.org/0000-0002-4062-0779"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-14 14:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_raster'>Check input raster</h2><span id='topic+check_raster'></span>

<h3>Description</h3>

<p>Checks the validity of raster layers to be inputted in <code><a href="#topic+mland">mland()</a></code>, intended to represent land cover. The function directly calls
<code><a href="landscapemetrics.html#topic+check_landscape">landscapemetrics::check_landscape()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_raster(raster, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_raster_+3A_raster">raster</code></td>
<td>
<p>An object of class 'RasterLayer', 'RasterStack', 'RasterBrick', 'SpatRaster',
or a list of raster objects (one of 'RasterLayer' or 'SpatRaster').</p>
</td></tr>
<tr><td><code id="check_raster_+3A_verbose">verbose</code></td>
<td>
<p>Print warning messages in the console? Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts basic information about the inputted raster: coordinate reference system (crs) - either &quot;geographic&quot;,
&quot;projected&quot;, or NA, units of the
coordinate reference system, class for the values of the inputted raster and the number of classes
found in the raster.
</p>


<h3>Value</h3>

<p>A data frame with relevant information about the inputted raster.
</p>

<hr>
<h2 id='conditions'>Define metric conditions</h2><span id='topic+conditions'></span>

<h3>Description</h3>

<p>Helper function to define patch conditions within <code><a href="#topic+generate_points">generate_points()</a></code> or
metric conditions within <code><a href="#topic+metrics_filter">metrics_filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditions_+3A_...">...</code></td>
<td>
<p>Patch or metric conditions in the form of lists. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditions must be defined as lists (one or more).
</p>
<p>For patch conditions, within
the environment of <code><a href="#topic+generate_points">generate_points()</a></code>, each element within the list defines the condition
that the patch must meet in relation to the value of certain patch-level metric, as follows:
</p>
<pre>
 list(class, metric, minimum value, maximum value)
</pre>

<ul>
<li><p> class: the class (raster value) of the patch that must meet the defined conditions. More than one class can
be specified.
</p>
</li>
<li><p> metric: the patch-level metric whose values must meet the defined conditions. Only one metric
per condition can be defined. Available patch-level metrics can be found in <code><a href="#topic+metrics_list">metrics_list()</a></code> and in
documentation of the package <code>landscapemetrics</code>.
</p>
</li>
<li><p> minimum value: the minimum value that the metric must have for the retained patches. If equal
to -Inf, and a maximum value is defined, patches whose values in the defined metric are equal
or lower to the maximum value will be retained.
</p>
</li>
<li><p> maximum value: the maximum value that the metric must have in the retained patches. If equal
to Inf, and a minimum value is defined, patches whose values in the defined metric are equal
or higher to the minimum value will be retained.
</p>
</li></ul>

<p>For metric conditions, within
the environment of <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, each element within the list defines the required
metric conditions, as follows:
</p>
<pre>
 list(rasterlayers, class, radii, metric, minimum value, maximum value)
</pre>

<ul>
<li><p> rasterlayers: the raster layers to be considered. If NA, all raster layers will be considered. If
an extra raster layer must be specified, the string &quot;ext&quot; must precede the raster layer number
(e.g. &quot;ext1&quot;, &quot;ext2&quot;).
</p>
</li>
<li><p> class: the classes to be considered, as numbers or strings with the names of the classes. If NA, all classes of required raster layers will be
considered. If NULL, the function will assume that the metric to be considered is a landscape-level metric.
Take into account that metrics from extra calculations are considered as landscape-level metrics.
</p>
</li>
<li><p> radii: the radii to be considered. If NA, all radii will be considered.
</p>
</li>
<li><p> metrics: the name of the metric to be considered (as defined with its abbreviation by column &quot;metric&quot; in <code><a href="#topic+metrics_list">metrics_list()</a></code>).
Only one metric per condition can be defined. Metrics as extra calculations for extra raster layers must be
provided as &quot;fun_&quot; + the name of the function (e.g. &quot;fun_mean&quot;).
</p>
</li>
<li><p> minimum value: the minimum value that the metric must have in the filtered landscapes. If equal
to -Inf, and a maximum value is defined, landscapes whose values in the defined metric are equal
or lower to the maximum value will be retained.
</p>
</li>
<li><p> maximum value: the maximum value that the metric must have in the filtered landscapes. If equal
to Inf, and a minimum value is defined, landscapes whose values in the defined metric are equal
or higher to the minimum value will be retained.
</p>
</li></ul>

<p>See the example sections of functions <code><a href="#topic+generate_points">generate_points()</a></code> and
<code><a href="#topic+metrics_filter">metrics_filter()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A list to be inputted within the argument <code>patch_conditions</code> in <code><a href="#topic+generate_points">generate_points()</a></code> or
the argument <code>conditions</code> in <code><a href="#topic+metrics_filter">metrics_filter()</a></code>.
</p>

<hr>
<h2 id='ed_metrics'>'MultiLandMetrics' object</h2><span id='topic+ed_metrics'></span>

<h3>Description</h3>

<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>, for the purposes of package
examples of the following functions: <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, <code><a href="#topic+metrics_gradient">metrics_gradient()</a></code>,
<code><a href="#topic+metrics_corr">metrics_corr()</a></code>, <code><a href="#topic+metrics_plots">metrics_plots()</a></code> and <code><a href="#topic+metrics_bind">metrics_bind()</a></code>. See 'MultiLand-class'
for general information about these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ed_metrics
</code></pre>


<h3>Format</h3>

<p>An object of class <code>MultiLandMetrics</code> of length 1.
</p>


<h3>Details</h3>

<p>The main internal object is a data.frame (accesible through <code>ed_metrics@data</code>) with information
about the values of two landscape metrics: &quot;pland&quot; (percentage of landscape) and &quot;ed&quot; (edge density).
</p>
<p>The object was created from the MultiLand object named &quot;ernesdesign&quot;, which
received two raster layers from a small portion of the ecoregion &quot;El Chaco&quot; as main inputs. The main rasterlayer
was provided by the project &quot;MapBiomas Chaco&quot; for the year 2000.
The extra rasterlayer contained the NDVI values of cells within the same extent of the main rasterlayer, and was provided by Landsat.
</p>


<h3>References</h3>

<p>Project MapBiomas Chaco â€“ Collection 4.0 of annual land cover and land use maps,
accessed during July 2022 through the following link: <a href="https://chaco.mapbiomas.org/">MapBiomas Chaco</a>
</p>
<p>Landsat-5 image courtesy of the U.S. Geological Survey
</p>


<h3>See Also</h3>

<p>See the examples sections of <code><a href="#topic+mland_metrics">mland_metrics()</a></code> and <code><a href="#topic+mland">mland()</a></code>
for more context.
</p>

<hr>
<h2 id='generate_points'>Generates point coordinates</h2><span id='topic+generate_points'></span>

<h3>Description</h3>

<p>Generates point coordinates over a rasterlayer extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_points(
  raster,
  approach = "grid",
  n = NULL,
  padding = 0,
  try = NULL,
  values = NULL,
  patch_conditions = NULL,
  trim = TRUE,
  attempts = 10,
  distance = NULL,
  offset = FALSE,
  closest_cell = FALSE,
  parallel = FALSE,
  cores = 1,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_points_+3A_raster">raster</code></td>
<td>
<p>An object of class 'SpatRaster', 'RasterLayer', 'RasterStack' or 'RasterBrick'.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_approach">approach</code></td>
<td>
<p>One of the following: &quot;grid&quot; to generate points through a grid, &quot;random&quot; to
generate points at random locations, or &quot;patch&quot; to generate points inside patches that meet
pre-defined conditions. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_n">n</code></td>
<td>
<p>Number of point to generate.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_padding">padding</code></td>
<td>
<p>Numeric. Width (in meters) of the internal margin around the raster that will be
discarded from the analysis. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_try">try</code></td>
<td>
<p>Number of points to be generated in
each turn. Only applies if <code>approach = "random"</code>. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_values">values</code></td>
<td>
<p>The values of the rasterlayer where points should be placed. Only applies if
<code>approach = "random"</code>.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_patch_conditions">patch_conditions</code></td>
<td>
<p>The conditions that patches must meet to be included as the
patches from which points will be generated. Only applies if <code>approach = "patch"</code>. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_trim">trim</code></td>
<td>
<p>Logical. If TRUE (default) the number of final points will be trimmed to the value
defined in <code>n</code>.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_attempts">attempts</code></td>
<td>
<p>Number of attempts to generate new random points given the total required
points (<code>n</code>) and the minimum distance required in <code>distance</code>. Only applies if
<code>approach = "random"</code>. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_distance">distance</code></td>
<td>
<p>Distance between points of the grid (if <code>approach = "grid"</code>) or minimum distance
between generated points (if <code>approach = "random"</code>).</p>
</td></tr>
<tr><td><code id="generate_points_+3A_offset">offset</code></td>
<td>
<p>Logical. If TRUE, each point coordinates will be randomly displaced around the area
occupied by the raster cell size. If FALSE (default), each point will be located at the center of
a given raster cell. Only applies if <code>approach = "random"</code>.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_closest_cell">closest_cell</code></td>
<td>
<p>Logical. If <code>approach = "patch"</code>, whether to return the coordinates of each patch centroid even if
they fall outside the patch (FALSE, default) or to move the point to the
closest cell of the patch if this happens (TRUE).</p>
</td></tr>
<tr><td><code id="generate_points_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE, part of the processes will be parallelized. See Details.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use if <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="generate_points_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE (default), progress of the analysis will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>approach = "random"</code>, the user can restrict the locations of new generated points
inside raster cells with certain value or values, by defining them in <code>values</code>. Also a minimum distance
between the generated points can be defined in <code>distance</code> (also applies for the resolution of
the grid if <code>approach = "grid"</code>).
</p>
<p>If <code>approach = "random"</code> and a minimum distance was defined, the function will generate new
&quot;random&quot; points in sequential passes. In each pass, the function will try to generate new points
taking into account the minimum distance between points, by randomly generating a number of points as
defined in <code>try</code>. The function will perform this task until the new generated points is equal or
higher than <code>n</code>. If <code>try = NULL</code> (default), <code>try</code> will equals <code>n</code>. If in each turn no new points
were added (i.e. new points were located at less than the minimum distance to other previously
generated points), the function will record this event. If this event happens more than the
number of times defined in <code>attempts</code> before the total generated points equals <code>n</code>, the function will
terminate, and return the points that were successfully generated given the required parameters.
The user may try different values for <code>n</code>, <code>try</code> and <code>attempts</code> to get a desirable result.
</p>
<p>If <code>approach = "patch"</code>, the function will return as many points as patches that meet certain
conditions in relation to pre-defined metric values. Conditions can be defined in
argument <code>patch_conditions</code>, for which the helper function <code><a href="#topic+conditions">conditions()</a></code> is available:
</p>
<pre>
 conditions(list(class, metric, minimum value, maximum value),
            list(class, metric, minimum value, maximum value), ...)
</pre>

<ul>
<li><p> class: the class (raster value) of the patch that must meet the defined conditions. More than one class can
be specified.
</p>
</li>
<li><p> metric: the patch-level metric whose values must meet the defined conditions. Only one metric
per condition can be defined. Available patch-level metrics can be found in <code><a href="#topic+metrics_list">metrics_list()</a></code> and in
documentation of the package <code>landscapemetrics</code>.
</p>
</li>
<li><p> minimum value: the minimum value that the metric must have for the retained patches. If equal
to -Inf, and a maximum value is defined, patches whose values in the defined metric are equal
or lower to the maximum value will be retained.
</p>
</li>
<li><p> maximum value: the maximum value that the metric must have in the retained patches. If equal
to Inf, and a minimum value is defined, patches whose values in the defined metric are equal
or higher to the minimum value will be retained.
</p>
</li></ul>

<p>Retained patches will be those patches that meet all patch conditions at the same time. Returned
point's coordinates will equal the centroid of each patch. If <code>closest_cell = TRUE</code>, the point's coordinates of the
centroids that did not fall inside the patch will be moved to the closest cell belonging to that
patch.
</p>
<p>To avoid generating points to close to the boundaries of the raster, the outer borders of the
raster can be discarded from the analysis, by considering the width inputted in <code>padding</code>.
</p>
<p>If <code>parallel = TRUE</code> the function will parallelize part of the processes. Parallelization
is done to obtain the coordinates of the patches if <code>approach = "patch"</code>. The number of
cores must be declared in <code>cores</code> (parallelization requires at least two cores). To use this
functionality, package <code>parallel</code> must be installed. So far, parallelization will run
in LINUX and MAC, but not in Windows.
</p>


<h3>Value</h3>

<p>An object of class 'SpatVector' containing the coordinates of the generated points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland">mland()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loads raster
elchaco &lt;- terra::rast(system.file("extdata", "elchaco.tif", package = "multilandr"))

# Returns points at "random" locations, but inside cells of value equals to 1.
chaco_coords &lt;- generate_points(elchaco, approach = "random", values = 1, n = 500)

# The same but points must be separated by at least 300 m between each other. Also, each point
# is randomly displaced inside the raster cell.
chaco_coords2 &lt;- generate_points(elchaco, approach = "random", values = 1, n = 500,
                                 try = 100, distance = 300, offset = TRUE)

# Returns as many points as patches that meet the defined condition. This is
# all patches of value equal to 1 of area between 9 and 11 hectares.
patch_sites &lt;- generate_points(elchaco, approach = "patch",
                               patch_conditions = conditions(list(1, "area", 8, 12)),
                               padding = 2000)

</code></pre>

<hr>
<h2 id='metrics_bind'>Metric's data preparation</h2><span id='topic+metrics_bind'></span>

<h3>Description</h3>

<p>Merge data.frame with metric's values with a data.frame with other data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_bind(
  x,
  data,
  raster = NULL,
  classes = NULL,
  radii = NULL,
  c_level = NULL,
  l_level = NULL,
  ext_raster = NULL,
  show_class_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_bind_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_bind_+3A_data">data</code></td>
<td>
<p>A data.frame with data from each sampling point/site. See Details.</p>
</td></tr>
<tr><td><code id="metrics_bind_+3A_raster">raster</code>, <code id="metrics_bind_+3A_ext_raster">ext_raster</code>, <code id="metrics_bind_+3A_classes">classes</code>, <code id="metrics_bind_+3A_radii">radii</code>, <code id="metrics_bind_+3A_l_level">l_level</code>, <code id="metrics_bind_+3A_c_level">c_level</code></td>
<td>
<p>Parameters to subset data.frame containing the
metrics values. See Details.</p>
</td></tr>
<tr><td><code id="metrics_bind_+3A_show_class_names">show_class_names</code></td>
<td>
<p>Logical. If TRUE, classes names will be returned as the names of the classes
previously provided (if so) when <code>x</code> was generated. Default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Merges data.frame with metrics values, contained in an object of
class 'MultiLandMetrics' (returned by <code><a href="#topic+mland_metrics">mland_metrics()</a></code>) with a data.frame with other data for each
site. In this way, the returned data.frame will be prepared for later statistical or
visual analyses. The data.frame provided in <code>data</code> must have a column named &quot;site&quot; or &quot;point_id&quot;,
containing unique identifiers for each sampling site, which must match with the identifiers
present in the data.frame contained in <code>x</code> (i.e. data.frame with metrics values for each site).
If &quot;site&quot;, the function will assume that the site names are provided as identifiers. If &quot;point_id&quot;,
the function will assume that point ids are being provided. In any case, these identifiers must
match the site identifiers in <code>x</code>.
</p>
<p>Argument <code>raster</code>, <code>ext_raster</code>, <code>classes</code>, <code>radii</code>, <code>l_level</code> and <code>c_level</code> can be defined to
subset the data.frame contained in <code>x</code>. In each one of these, an all-positive or an
all-negative vector can be passed, whether to include (all-postive) or exclude (all-negative)
the elements to be taken into account for the subsetting:
</p>

<ul>
<li><p> rasterlayers: a numeric vector with the number of the raster layers to be included/excluded.
For example: <code>c(1, 2, 4)</code> to include raster layers 1, 2 and 4; <code>c(-2, -3)</code> to exclude raster layers 2
and 3.
</p>
</li>
<li><p> classes: must be a list with as many elements as defined raster layers in argument
<code>rasterlayers</code>. Each element of the list must be a numeric vector (classes identities) with the
classes to be included/excluded. If provided a character vector, <code><a href="#topic+metrics_bind">metrics_bind()</a></code> assumes that
classes names are provided. For example, for the case with 2 raster layers:
<code>list(c(3, 20, 35), c("Forest", "Crops"))</code> would include classes 3, 20 and 35 from rasterl ayer 1
and classes &quot;Forest&quot; and &quot;Crops&quot; for raster layer 2. For the case of a unique rasterlayer, there
is no need to input a list. For example, for the case of a unique raster layer and the
exclusion of some classes: <code>c(-5, -10, -15)</code> to exclude classes 5, 10 and 15 of
the unique raster layer; <code>c("-Forest", "-Grassland")</code> to exclude classes &quot;Forest&quot; and &quot;Grassland&quot;.
Note the &quot;-&quot; before each class name to indicate the exclusion of the classes.
</p>
</li>
<li><p> radii: a numeric vector to include/exclude particular radii. For example: <code>c(1000, 2000)</code> to
include only radii of 1000 and 2000 m; <code>c(-500, -1500)</code> to exclude radii of 500 and 1500 m.
</p>
</li>
<li><p> c_level: character vector with the class-level metrics to be included/excluded from
the analysis. For example: <code>c("np", "pland")</code> will include only the metrics &quot;number of patches&quot;
(&quot;np&quot;) and &quot;percentage of the landscape&quot; (&quot;pland&quot;) in the analysis, whereas <code>c("-np", "-pland")</code>
will exclude them. Note the &quot;-&quot; before each metric name to indicate the exclusion of the
metrics.
</p>
</li>
<li><p> l_level: character vector with the landscape-level metrics to be included/excluded from
the analysis. Extra calculations for extra raster layers are considered as landscape-level metrics,
and must be provided as &quot;fun_&quot; + the name of the function.
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame equal to sampling data provided in <code>data</code> but with additional columns
containing the values of the metrics for each sampling site.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_metrics">mland_metrics()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get sites names from ed_metrics and creates ad-hoc data.frame with random values of
# "richness" (the response variable). Only for the purpose of this example
sites &lt;- ed_metrics@points$name
sampling_data &lt;- data.frame(site = rep(sites, each = 10),
                            richness = sample(1:500, 150))

# With no filters, all columns with all metrics at all spatial scales are added to
# the sampling data
new_data &lt;- metrics_bind(ed_metrics, sampling_data)

# Subset for metrics of class "Forest", radius 5000 and metric "pland"
new_data &lt;- metrics_bind(ed_metrics, sampling_data, show_class_names = TRUE,
                         classes = "Forest", radii = 3000, c_level = "pland")

# In this format, the data.frame can be passed to a fitting model
fit &lt;- lm(richness ~ r1_Forest_pland_3000, data = new_data)
</code></pre>

<hr>
<h2 id='metrics_corr'>Pairwise metric correlations</h2><span id='topic+metrics_corr'></span>

<h3>Description</h3>

<p>Calculates pairwise correlations between landscape metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_corr(
  x,
  method = "pearson",
  fun = NULL,
  raster = NULL,
  classes = NULL,
  radii = NULL,
  c_level = NULL,
  l_level = NULL,
  ext_raster = NULL,
  show_class_names = FALSE,
  display = "radii",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_corr_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_method">method</code></td>
<td>
<p>The method to be used to calculate pair correlations: &quot;pearson&quot; (default),
&quot;spearman&quot; or &quot;kendall&quot;.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_fun">fun</code></td>
<td>
<p>A user-defined function to calculate correlations. See Details.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_raster">raster</code>, <code id="metrics_corr_+3A_ext_raster">ext_raster</code>, <code id="metrics_corr_+3A_classes">classes</code>, <code id="metrics_corr_+3A_radii">radii</code>, <code id="metrics_corr_+3A_l_level">l_level</code>, <code id="metrics_corr_+3A_c_level">c_level</code></td>
<td>
<p>Parameters to subset calculations of
correlations. See Details.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_show_class_names">show_class_names</code></td>
<td>
<p>Logical. If TRUE, row and column of returned matrices will be identified
with the names of the classes, if available in <code>x</code>. Default FALSE.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_display">display</code></td>
<td>
<p>Defines how correlations are presented: &quot;radii&quot; (default), &quot;rl&quot; or &quot;both&quot;.
See Details.</p>
</td></tr>
<tr><td><code id="metrics_corr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to function <code><a href="stats.html#topic+cor">cor()</a></code> or to the user-defined function provided
in <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correlations are calculated, by default, through the function <code><a href="stats.html#topic+cor">cor()</a></code>, by specifying
the method through the argument <code>method</code>. Alternatively, a user-defined function can be provided
in the argument <code>fun</code>. If not NULL, the function will assume that a user-defined function
have been provided. This must be a function already loaded in the environment, and
must take at least two arguments. These initial pair of arguments should be capable of receiving
two numeric vectors (one in each argument), process them in some way, and return a numeric
value (i.e. the supposed correlation).
</p>
<p>Arguments <code>raster</code>, <code>ext_raster</code>, <code>classes</code>, <code>radii</code>, <code>c_level</code> and <code>l_level</code> can be defined to
subset the calculations of pair correlations. In each one of these, an all-positive or an
all-negative vector can be passed, whether to include (all-positive) or exclude (all-negative)
the elements to be taken into account for the subsetting:
</p>

<ul>
<li><p> raster: a numeric vector with the number of the raster layers to be included/excluded.
For example: <code>c(1, 2, 4)</code> to include raster layers 1, 2 and 4; <code>c(-2, -3)</code> to exclude raster layers 2
and 3.
</p>
</li>
<li><p> ext_raster: a numeric vector with the number of the extra raster layers to be included/excluded,
as in the raster slot.
</p>
</li>
<li><p> classes: must be a list with as many elements as defined raster layers in argument
<code>raster</code>. Each element of the list must be a numeric vector (classes identities) with the
classes to be included/excluded. If provided a character vector, <code><a href="#topic+metrics_corr">metrics_corr()</a></code> assumes that
classes names are provided. For example, for the case with 2 raster layers:
<code>list(c(3, 20, 35), c("Forest", "Crops"))</code> would include classes 3, 20 and 35 from raster layer 1
and classes &quot;Forest&quot; and &quot;Crops&quot; for raster layer 2. For the case of a unique raster layer, there
is no need to input a list. For example, for the case of a unique raster layer and the
exclusion of some classes: <code>c(-5, -10, -15)</code> to exclude classes 5, 10 and 15 of
the unique raster layer; <code>c("-Forest", "-Grassland")</code> to exclude classes &quot;Forest&quot; and &quot;Grassland&quot;.
Note the &quot;-&quot; before each class name to indicate the exclusion of the classes.
</p>
</li>
<li><p> radii: a numeric vector to include/exclude particular radii. For example: <code>c(1000, 2000)</code> to
include only radii of 1000 and 2000 m; <code>c(-500, -1500)</code> to exclude radii of 500 and 1500 m.
</p>
</li>
<li><p> c_level: character vector with the class-level metrics to be included/excluded from
the analysis. For example: <code>c("np", "pland")</code> will include only the metrics &quot;number of patches&quot;
(&quot;np&quot;) and &quot;percentage of the landscape&quot; (&quot;pland&quot;) in the analysis, whereas <code>c("-np", "-pland")</code>
will exclude them. Note the &quot;-&quot; before each metric name to indicate the exclusion of the
metrics.
</p>
</li>
<li><p> l_level: character vector with the landscape-level metrics to be included/excluded from
the analysis. Other calculations for extra raster layers are considered as landscape-level metrics,
and must be provided as &quot;fun_&quot; + the name of the function (e.g. &quot;fun_mean&quot;).
</p>
</li></ul>

<p>Names of the available metrics of the 'MultiLandMetrics' object provided in <code>x</code> can
be accessed with <code>x@metrics</code> and <code>x@ext_calc</code>.
</p>
<p>Note that patch-level metrics, if exists in <code>x</code> metric's data.frame, are excluded from
calculations, as this function works at a landscape scale.
</p>
<p>Argument <code>display</code> defines how correlation values will be presented. If equals to &quot;radii&quot;
(default), correlation values are disaggregated by radii. If &quot;rl&quot;, correlation values are
disaggregated by rasterlayer: correlations between different radii will be presented.
If &quot;both&quot;, correlation values are firstly disaggregated by rasterlayer, and by radii secondly.
Disaggregations by raster layers only make sense for 'MultiLandMetrics' objects with more than one raster layer.
</p>


<h3>Value</h3>

<p>A list with matrices containing correlation values between pair of metrics. Matrices
are disaggregated by radius if <code>display = "radii"</code>, by rasterlayer if <code>display = "rl"</code> or by
rasterlayer and radii if <code>display = "both"</code>. Metrics
names are presented as row and column names of the matrices, with the following format:
&quot;level&quot;<em>&quot;metric_name&quot;</em>&quot;radius&quot;. For a landscape-level metric, a plausible metric name could be
&quot;l_np_1500&quot; indicating a landscape-level metric, which is &quot;np&quot; (&quot;number of patches&quot;) at a scale
(radius) of 1500 m. For a class-level metric a plausible metric name could be &quot;c4_pland_1000&quot;,
indicating a class-level metric of class 4 (the value of the raster), which is &quot;pland&quot;
(&quot;percentage of landscape&quot;) at a scale (radius) of 1000 m. If more that one raster layer is
being analyzed, the prefix &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, ..., &quot;rn&quot; (referring to raster layer 1, 2, 3, ..., n) is
added to the metric name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_metrics">mland_metrics()</a></code>, <code><a href="#topic+metrics_plots">metrics_plots()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculates pearson correlations between metrics of a MultiLandMetrics object
metrics_corr(ed_metrics)

# Only for radius 5000 m and with classes names rather than classes values
metrics_corr(ed_metrics, radii = 5000, show_class_names = TRUE)

# Only selecting the metric "pland"
metrics_corr(ed_metrics, radii = 5000, show_class_names = TRUE, c_level = "pland")

# Excluding the metric "pland"
metrics_corr(ed_metrics, radii = 5000, show_class_names = TRUE, c_level = "-pland")

# Excluding the metric radii of 4000 and 5000 m
metrics_corr(ed_metrics, radii = c(-4000, -5000), show_class_names = TRUE)

# Correlations of metric "pland" between classes 1 to 3, and between radii
# 1000 and 5000 m, disaggregating by rasterlayer.
metrics_corr(ed_metrics, radii = c(1000, 5000), classes = 1:3,
             c_level = "pland", display = "rl")
</code></pre>

<hr>
<h2 id='metrics_filter'>Filters metrics</h2><span id='topic+metrics_filter'></span>

<h3>Description</h3>

<p>Selects landscapes that meet certain pre-defined conditions in relation to its metrics from
a 'MultiLandMetrics' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_filter(x, conditions, output = "MLM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_filter_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_filter_+3A_conditions">conditions</code></td>
<td>
<p>List. Conditions to be met by the landscapes. See Details.</p>
</td></tr>
<tr><td><code id="metrics_filter_+3A_output">output</code></td>
<td>
<p>One of the following: &quot;MLM&quot; to return an updated version of the 'MultiLandMetrics' object provided in <code>x</code> (default),
&quot;spatial&quot; to return a 'SpatVector' with the points
of the selected landscapes, &quot;data&quot; to return a data.frame with the metric values information or &quot;coords&quot;
to return a data.frame with geographical information of the filtered points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selects landscapes that meet certain conditions in relation to the values of
their landscape metrics. The function will retain those points associated with the landscapes
that meet all the defined conditions at the same time. Conditions must be provided through a list,
for which the helper function <code><a href="#topic+conditions">conditions()</a></code> is available:
</p>
<pre>
 conditions(list(rasterlayers, class, radii, metric, minimum value, maximum value),
            list(rasterlayers, class, radii, metric, minimum value, maximum value),
            ...)
</pre>

<ul>
<li><p> rasterlayers: the raster layers to be considered. If NA, all raster layers will be considered. If
an extra raster layer must be specified, the string &quot;ext&quot; must precede the raster layer number
(e.g. &quot;ext1&quot;, &quot;ext2&quot;).
</p>
</li>
<li><p> class: the classes to be considered, as numbers or strings with the names of the classes. If NA, all classes of required raster layers will be
considered. If NULL, the function will assume that the metric to be considered is a landscape-level metric.
Take into account that metrics from extra calculations are considered as landscape-level metrics.
</p>
</li>
<li><p> radii: the radii to be considered. If NA, all radii will be considered.
</p>
</li>
<li><p> metrics: the name of the metric to be considered (as defined with its abbreviation by column &quot;metric&quot; in <code><a href="#topic+metrics_list">metrics_list()</a></code>).
Only one metric per condition can be defined. Metrics as extra calculations for extra raster layers must be
provided as &quot;fun_&quot; + the name of the function (e.g. &quot;fun_mean&quot;).
</p>
</li>
<li><p> minimum value: the minimum value that the metric must have in the filtered landscapes. If equal
to -Inf, and a maximum value is defined, landscapes whose values in the defined metric are equal
or lower to the maximum value will be retained.
</p>
</li>
<li><p> maximum value: the maximum value that the metric must have in the filtered landscapes. If equal
to Inf, and a minimum value is defined, landscapes whose values in the defined metric are equal
or higher to the minimum value will be retained.
</p>
</li></ul>

<p>A plausible list of conditions could be the following:
</p>
<pre>
 conditions(list(1, 2, 1000, "pland", 20, 30),
            list(1, 4, 1000, "np", 1, 15),
            list("ext1", NULL, 1000, "fun_mean", 70, 80))
</pre>
<p>And it would indicate that landscapes of radius equal to 1000 m should present values of &quot;pland&quot;
(percentage of the landscape) for class 2 from raster layer 1, between 20 and 30%. At the same time, landscapes of radius
equal to 1000 m should present values of &quot;np&quot; (number of patches) for class 4 from rasterlayer 1,
between 1 and 15 patches. Finally, all selected landscapes of radius equal to 1000 m should
present values for &quot;fun_mean&quot; (applied to extra raster layer &quot;ext1&quot;) between 70 and 80. Note that the
slot for &quot;class&quot; is NULL, as extra raster layers do not hold classes.
</p>


<h3>Value</h3>

<p>A 'MultiLandMetrics' if <code>output = "MLM"</code>, a 'SpatVector' if <code>output = "spatial"</code>,
a data.frame if <code>output = "data"</code> or a data.frame with geographical information of the points if <code>output = "coords"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics_gradient">metrics_gradient()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filter landscapes that have between 20 and 30% of forest at a radius of 2000 m
# and output the data.frame with metrics values
conds &lt;- conditions(list(NA, "Forest", 2000, "pland", 20, 30))
otf_subset &lt;- metrics_filter(otf_metrics,
                             conditions = conds,
                             output = "data")

# The same but returning a data.frame with information of the retained points
conds &lt;- conditions(list(NA, "Forest", 2000, "pland", 20, 30))
otf_subset_points &lt;- metrics_filter(otf_metrics,
                                    conditions = conds,
                                    output = "coords")

# Filter landscapes that have between 20 and 30% of forest at a radius of 2000 m
# and a maximum of 60% of Crops.
conds &lt;- conditions(list(NA, "Forest", 2000, "pland", 20, 30),
                    list(NA, "Crops", 2000, "pland", -Inf, 60))
otf_subset2 &lt;- metrics_filter(otf_metrics,
                              conditions = conds,
                              output = "data")
</code></pre>

<hr>
<h2 id='metrics_gradient'>Generates optimized metrics gradient</h2><span id='topic+metrics_gradient'></span>

<h3>Description</h3>

<p>Selects a set of points whose associated landscapes comprise an optimized gradient for a given landscape metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_gradient(
  x,
  rasterlayer = NULL,
  class = NULL,
  radius = NULL,
  metric = NULL,
  n,
  cutpoints = NULL,
  breaks = NULL,
  random = FALSE,
  output = "MLM"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_gradient_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_rasterlayer">rasterlayer</code></td>
<td>
<p>The raster layer to be considered. If
an extra raster layer must be specified, the string &quot;ext&quot; must precede the raster layer number
(e.g. &quot;ext1&quot;, &quot;ext2&quot;)</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_class">class</code></td>
<td>
<p>The class to be considered, as a number or as a string with the name of the class.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_radius">radius</code></td>
<td>
<p>The radius to be considered.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_metric">metric</code></td>
<td>
<p>The metric to be considered. Metrics as extra calculations for extra raster layers must be
provided as &quot;fun_&quot; + the name of the function.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_n">n</code></td>
<td>
<p>The number of points that will comprise the gradient. See Details.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_cutpoints">cutpoints</code></td>
<td>
<p>A sequence of numbers that will serve as numeric approximations to select the
points that will comprise the gradient. See Details.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_breaks">breaks</code></td>
<td>
<p>A unique number with the number of breaks that will generate the cutpoints for the
specified metric values. Default is 10. See Details.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_random">random</code></td>
<td>
<p>Logical. If TRUE, random points will be selected.</p>
</td></tr>
<tr><td><code id="metrics_gradient_+3A_output">output</code></td>
<td>
<p>One of the following: &quot;MLM&quot; to return an updated version of the 'MultiLandMetrics' object provided in <code>x</code> (default),
&quot;spatial&quot; to return a 'SpatVector' with the points
of the selected landscapes, &quot;data&quot; to return a data.frame with the metric values information or &quot;coords&quot;
to return a data.frame with geographical information of the selected points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selects a subset of landscapes that overall will
generate an optimized gradient of values for a given landscape metric of a specified raster layer,
class and radius. One can define a gradient as optimized if
its values fulfill to cover a good range of values between a minimum and a maximum value. The
final gradient will comprise the number of points specified in argument <code>n</code>. Note that
only one landscape metric can be specified at a time.
</p>
<p>The algorithm will select those points whose associated landscapes present values for the specified landscape metric that are
the most close to the specified <code>cutpoints</code>. Alternatively, the user can provide a number of
<code>breaks</code> from which the sequence of cutpoints will be generated. If both arguments are specified,
the function will consider the values inputted in <code>cutpoints</code>. If both arguments are NULL, the
algorithm will simply select <code>n</code> random points.
</p>


<h3>Value</h3>

<p>A 'MultiLandMetrics' if <code>output = "MLM"</code>, a 'SpatVector' if <code>output = "spatial"</code>,
a data.frame if <code>output = "data"</code> or a data.frame with geographical information of the points if <code>output = "coords"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics_filter">metrics_filter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generates an optimized gradient for the landscape metric "pland", for the class "Forest".
pland_gradient &lt;- metrics_gradient(otf_metrics, rasterlayer = 1, class = "Forest",
                                   radius = 2000, metric = "pland", n = 15, breaks = 10)
# Note that, in this case, specifications for the rasterlayer and the radius are
# redundant, and could be simply ignored and left as default, asthe object otf_metrics
# only comprises a unique rasterlayer and radius.

# By default, the output is an updated version of the object otf_metrics. In order to
# inspect the returned values, let's select only the dataframe containing the
# metric's values.
foo &lt;- subset(pland_gradient@data, metric == "pland" &amp; classname == "Forest",
              select = value)

# Next, we output the range of values we have obtained, note there are 15 points, as
# previously specified in the function definition in the argument 'n'
round(sort(foo$value), digits = 2)

# 1.15  1.57  8.17  8.19 15.24 22.32 29.27 36.32 43.17 43.20 49.79 50.25 55.44 57.62 64.53

# Alternatively, we can define specific cutpoints around the landscapes will be selected
# in termsof its numeric closeness.
pland_gradient &lt;- metrics_gradient(otf_metrics, rasterlayer = 1, class = "Forest",
                                   radius = 2000,metric = "pland", n = 15,
                                   cutpoints = seq(1, 60, 5))

# Again, we inspect the dataframe with the metric values to see our results.
foo &lt;- subset(pland_gradient@data, metric == "pland" &amp; classname == "Forest",
              select = value)

round(sort(foo$value), digits = 2)

# 1.15  6.02  6.03 10.99 15.97 20.99 26.01 31.02 35.95 41.14 41.34 45.93 51.41 54.56 55.44

# Both alternatives generated a wide-ranged gradient of values for the forest metric "pland"
</code></pre>

<hr>
<h2 id='metrics_list'>Metrics list</h2><span id='topic+metrics_list'></span>

<h3>Description</h3>

<p>List of available landscape metrics provided by package <code>landscapemetrics</code> to be calculated with
<code><a href="#topic+mland_metrics">mland_metrics()</a></code>. It simply calls <code><a href="landscapemetrics.html#topic+list_lsm">landscapemetrics::list_lsm()</a></code>. For more information regarding the
definition and equations of metrics, please check the user manual of <code>landscapemetrics</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_list(
  level = NULL,
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_list_+3A_level">level</code></td>
<td>
<p>Character vector. Level of metrics. Either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;
(or a vector with a combination of these). Default NULL considers all levels.</p>
</td></tr>
<tr><td><code id="metrics_list_+3A_metric">metric</code></td>
<td>
<p>Abbreviation of metrics (e.g. &quot;area&quot;).</p>
</td></tr>
<tr><td><code id="metrics_list_+3A_name">name</code></td>
<td>
<p>Full name of metrics (e.g. &quot;core area&quot;).</p>
</td></tr>
<tr><td><code id="metrics_list_+3A_type">type</code></td>
<td>
<p>Character vector. Type according to FRAGSTATS grouping. One or more of the following:
&quot;area and edge&quot;, &quot;core area&quot;, &quot;shape&quot;, &quot;aggregation&quot;, &quot;complexity&quot;, and or &quot;diversity&quot;. Default
NULL considers all types.</p>
</td></tr>
<tr><td><code id="metrics_list_+3A_what">what</code></td>
<td>
<p>Selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;. It is also
possible to specify functions as a vector of strings, e.g. what = c(&quot;lsm_c_ca&quot;, &quot;lsm_l_ta&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the list of available landscape metrics, including information
regarding the level, type, metric, name and function name provided by package <code>landscapemetrics</code>.
</p>


<h3>References</h3>

<p>Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019. landscapemetrics:
an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).
</p>
<p>McGarigal, K., SA Cushman, and E Ene. 2012. FRAGSTATS v4: Spatial Pattern Analysis Program for
Categorical and Continuous Maps. Computer software program produced by the authors at the
University of Massachusetts, Amherst. <br />
Available at the following web site: https://www.umass.edu/landeco/
</p>

<hr>
<h2 id='metrics_plots'>Pairwise metric plots</h2><span id='topic+metrics_plots'></span>

<h3>Description</h3>

<p>Plots pair of metric values in two-dimensional plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_plots(
  x,
  raster = NULL,
  classes = NULL,
  radii = NULL,
  c_level = NULL,
  l_level = NULL,
  ext_raster = NULL,
  show_class_names = FALSE,
  upper = TRUE,
  diag = TRUE,
  smooth = TRUE,
  method = "loess",
  se = FALSE,
  st_points = list(shape = 21, size = 2, col = "black", fill = "white", alpha = 1),
  st_lines = list(lty = 1, lwd = 1, col = "black", alpha = 0.6),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_plots_+3A_x">x</code></td>
<td>
<p>An object of class 'Multiland' generated with <code><a href="#topic+mland">mland()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_raster">raster</code>, <code id="metrics_plots_+3A_ext_raster">ext_raster</code>, <code id="metrics_plots_+3A_classes">classes</code>, <code id="metrics_plots_+3A_radii">radii</code>, <code id="metrics_plots_+3A_l_level">l_level</code>, <code id="metrics_plots_+3A_c_level">c_level</code></td>
<td>
<p>Parameters to subset plots. See Details.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_show_class_names">show_class_names</code></td>
<td>
<p>logical. Whether to show classes with its previously defined names (if defined)
when generating the 'MultiLand' object (TRUE), or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_upper">upper</code></td>
<td>
<p>logical. Whether to plot upper-diagonal plots or not. Default TRUE</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_diag">diag</code></td>
<td>
<p>logical. Whether to plot diagonal density plots or not. Default TRUE.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_smooth">smooth</code></td>
<td>
<p>logical. If TRUE (default) a pattern between the pair of metric values
is plotted, with a smoothing method as defined in <code>method</code>.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_method">method</code></td>
<td>
<p>Smoothing method (function) to use, as in <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code>. It accepts
&quot;loess&quot; (default), &quot;lm&quot;, &quot;gam&quot;, among others. See ?ggplot2::geom_smooth() for more details.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_se">se</code></td>
<td>
<p>logical. Whether to show (TRUE) or not (FALSE) confidence intervals when <code>smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_st_points">st_points</code></td>
<td>
<p>List of aesthetic arguments for points plotting:
<code>shape</code> for points shape, <code>size</code> for points size, <code>col</code> for
points border color, <code>fill</code> for points fill color and <code>alpha</code> for point transparency.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_st_lines">st_lines</code></td>
<td>
<p>List of aesthetic arguments for lines plotting (if <code>smooth = TRUE</code>):
<code>lty</code> for linetype, <code>lwd</code> for linewidth,
<code>col</code> for line color and <code>alpha</code> for line transparency.</p>
</td></tr>
<tr><td><code id="metrics_plots_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code>, if <code>smooth = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+metrics_plots">metrics_plots()</a></code> mainly relies on <code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code> to generate pair plots
between metrics values. Arguments <code>upper</code> and <code>diag</code> are specific arguments of
<code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code>, here adapted to the context of continuous values only.
</p>
<p>Argument <code>raster</code>, <code>classes</code>, <code>radii</code>, <code>l_level</code> and <code>c_level</code> can be defined to
subset the plots. In each one of these, an all-positive or an
all-negative vector can be passed, whether to include (all-positive) or exclude (all-negative)
the elements to be taken into account for the subsetting:
</p>

<ul>
<li><p> rasterlayers: a numeric vector with the number of the raster layers to be included/excluded.
For example: <code>c(1, 2, 4)</code> to include raster layers 1, 2 and 4; <code>c(-2, -3)</code> to exclude raster layers 2
and 3.
</p>
</li>
<li><p> classes: must be a list with as many elements as defined raster layers in argument
<code>raster</code>. Each element of the list must be a numeric vector (classes identities) with the
classes to be included/excluded. If provided a character vector, <code><a href="#topic+metrics_corr">metrics_corr()</a></code> assumes that
classes names are provided. For example, for the case with 2 raster layers:
<code>list(c(3, 20, 35), c("Forest", "Crops"))</code> would include classes 3, 20 and 35 from raster layer 1
and classes &quot;Forest&quot; and &quot;Crops&quot; for raster layer 2. For the case of a unique raster layer, there
is no need to input a list. For example, for the case of a unique raster layer and the
exclusion of some classes: <code>c(-5, -10, -15)</code> to exclude classes 5, 10 and 15 of
the unique raster layer; <code>c("-Forest", "-Grassland")</code> to exclude classes &quot;Forest&quot; and &quot;Grassland&quot;.
Note the &quot;-&quot; before each class name to indicate the exclusion of the classes.
</p>
</li>
<li><p> radii: a numeric vector to include/exclude particular radii. For example: c(1000, 2000) to
include only radii of 1000 and 2000 m; c(-500, -1500) to exclude radii of 500 and 1500 m.
</p>
</li>
<li><p> c_level: character vector with the class-level metrics to be included/excluded from
the analysis. For example: <code>c("np", "pland")</code> will include only the metrics &quot;number of patches&quot;
(&quot;np&quot;) and &quot;percentage of the landscape&quot; (&quot;pland&quot;) in the analysis, whereas <code>c("-np", "-pland")</code>
will exclude them. Note the &quot;-&quot; before each metric name to indicate the exclusion of the
metrics.
</p>
</li>
<li><p> l_level: character vector with the landscape-level metrics to be included/excluded from
the analysis. Other calculations for extra raster layers are considered as landscape-level metrics,
and must be provided as &quot;fun_&quot; + the name of the function (e.g. &quot;fun_mean&quot;).
</p>
</li></ul>

<p>Names of the available metrics of the 'MultiLandMetrics' object provided in <code>x</code> can
be accessed with <code>x@metrics</code> and <code>x@ext_calc</code>.
</p>
<p>Note that patch-level metrics, if exists in <code>x</code> metric's data.frame, are excluded from
calculations, as this function works at a landscape scale.
</p>


<h3>Value</h3>

<p>A panel with several plots returned by <code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code> relating pair of metrics
values. Metrics
names are presented at the top and right of the panel (strips), with the following format:
&quot;level&quot;<em>&quot;metric_name&quot;</em>&quot;radius&quot;. For a landscape-level metric, a plausible metric name could be
&quot;l_np_1500&quot; indicating a landscape-level metric, which is &quot;np&quot; (&quot;number of patches&quot;) at a scale
(radius) of 1500 m. For a class-level metric a plausible metric name could be &quot;c4_pland_1000&quot;,
indicating a class-level metric of class 4 (the value of the raster), which is &quot;pland&quot;
(&quot;percentage of landscape&quot;) at a scale (radius) of 1000 m. If more that one rasterlayer is
being analyzed, the prefix &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, ..., &quot;rn&quot; (referring to rasterlayer 1, 2, 3, ..., n) is
added to the metric name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_metrics">mland_metrics()</a></code>, <code><a href="#topic+metrics_corr">metrics_corr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pair plots between metrics "pland" of classes 1 to 4, for radius 3000 m
metrics_plots(ed_metrics, classes = 1:4, radii = 3000, show_class_names = TRUE,
              c_level = "pland")

# Without smooth pattern
metrics_plots(ed_metrics, classes = 1:4, radii = 3000, show_class_names = TRUE,
              c_level = "pland", smooth = FALSE)


# Changing aesthetics
metrics_plots(ed_metrics, classes = 1:4, radii = 3000, show_class_names = TRUE,
              c_level = "pland", smooth = FALSE, size = 1.5, shape = 21,
              fill = "red", alpha = 0.4)

# Assessing two radii values at the same time
metrics_plots(ed_metrics, classes = 1:4, radii = c(1000, 5000),
              show_class_names = TRUE, c_level = "pland", smooth = FALSE,
              size = 1.5, shape = 21, fill = "red", alpha = 0.4)

# An example with hundreds of points
metrics_plots(otf_metrics, classes = c("Forest", "Crops"))

# Plots can be combined with ggplot2::theme
metrics_plots(otf_metrics, classes = c("Forest", "Crops")) +
  ggplot2::theme_bw()

</code></pre>

<hr>
<h2 id='metrics_scalogram'>Scalograms</h2><span id='topic+metrics_scalogram'></span>

<h3>Description</h3>

<p>Plots the value of metrics across different spatial scales (radius)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_scalogram(
  x,
  raster = NULL,
  points = NULL,
  classes = NULL,
  radii = NULL,
  c_level = NULL,
  l_level = NULL,
  ext_raster = NULL,
  show_class_names = FALSE,
  aggregation = FALSE,
  fun = "mean",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metrics_scalogram_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_raster">raster</code>, <code id="metrics_scalogram_+3A_ext_raster">ext_raster</code>, <code id="metrics_scalogram_+3A_classes">classes</code>, <code id="metrics_scalogram_+3A_radii">radii</code>, <code id="metrics_scalogram_+3A_l_level">l_level</code>, <code id="metrics_scalogram_+3A_c_level">c_level</code></td>
<td>
<p>Parameters to select
what to plot. See Details.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_points">points</code></td>
<td>
<p>Numeric or character vector of points to be considered. See Details.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_show_class_names">show_class_names</code></td>
<td>
<p>Logical. If TRUE, raster classes will be identified
with the names of the classes, if available in <code>x</code>. Default FALSE.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_aggregation">aggregation</code></td>
<td>
<p>Logical. Should data be aggregated by site? See Details.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_fun">fun</code></td>
<td>
<p>Function to apply during aggregation. Default is &quot;mean&quot;. See Details.</p>
</td></tr>
<tr><td><code id="metrics_scalogram_+3A_...">...</code></td>
<td>
<p>Parameters passed to ggplot2::geom_line().</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+metrics_scalogram">metrics_scalogram()</a></code> generates scalograms. In these plots, the value
of a landscape metric is plotted in relation to different spatial scales (which
in this context are defined by the radii of buffers) (Wu, 2004). Curves are disaggregated by
raster classes (if applies), and a label named &quot;landscape&quot; is provided for those landscape-level
metrics.
</p>
<p>If argument <code>points</code> is a character vector,
<code><a href="#topic+metrics_scalogram">metrics_scalogram()</a></code> will assume that the 'MultiLandMetrics' object inputted in argument <code>x</code> contains
the identification names of each site/point. Therefore, the inputted values in argument <code>points</code> will be taken as these
identification names. Otherwise, if a numeric vector is inputted, these values
will be taken as point ids.
</p>
<p>Arguments <code>raster</code>, <code>ext_raster</code>, <code>classes</code>, <code>radii</code>, <code>c_level</code> and <code>l_level</code>
can be defined to select what metrics, classes, raster layers and radii will
be considered for plotting. In each one of these, an all-positive or an
all-negative vector can be passed, whether to include (all-positive) or
exclude (all-negative) the elements to be taken into account for the
selection:
</p>

<ul>
<li><p> raster: a numeric vector with the number of the raster layers to be included/excluded.
For example: <code>c(1, 2, 4)</code> to include raster layers 1, 2 and 4; <code>c(-2, -3)</code> to exclude raster layers 2
and 3.
</p>
</li>
<li><p> ext_raster: a numeric vector with the number of the extra raster layers to be included/excluded,
as in the raster slot.
</p>
</li>
<li><p> classes: must be a list with as many elements as defined raster layers in argument
<code>raster</code>. Each element of the list must be a numeric vector (classes identities) with the
classes to be included/excluded. If provided a character vector, <code><a href="#topic+metrics_scalogram">metrics_scalogram()</a></code> assumes that
classes names are provided. For example, for the case with 2 raster layers:
<code>list(c(3, 20, 35), c("Forest", "Crops"))</code> would include classes 3, 20 and 35 from raster layer 1
and classes &quot;Forest&quot; and &quot;Crops&quot; for raster layer 2. For the case of a unique raster layer, there
is no need to input a list. For example, for the case of a unique raster layer and the
exclusion of some classes: <code>c(-5, -10, -15)</code> to exclude classes 5, 10 and 15 of
the unique raster layer; <code>c("-Forest", "-Grassland")</code> to exclude classes &quot;Forest&quot; and &quot;Grassland&quot;.
Note the &quot;-&quot; before each class name to indicate the exclusion of the classes.
</p>
</li>
<li><p> radii: a numeric vector to include/exclude particular radii. For example: <code>c(1000, 2000)</code> to
include only radii of 1000 and 2000 m; <code>c(-500, -1500)</code> to exclude radii of 500 and 1500 m.
</p>
</li>
<li><p> c_level: character vector with the class-level metrics to be included/excluded from
the analysis. For example: <code>c("np", "pland")</code> will include only the metrics &quot;number of patches&quot;
(&quot;np&quot;) and &quot;percentage of the landscape&quot; (&quot;pland&quot;) in the analysis, whereas <code>c("-np", "-pland")</code>
will exclude them. Note the &quot;-&quot; before each metric name to indicate the exclusion of the
metrics.
</p>
</li>
<li><p> l_level: character vector with the landscape-level metrics to be included/excluded from
the analysis. Other calculations for extra raster layers are considered as landscape-level metrics,
and must be provided as &quot;fun_&quot; + the name of the function (e.g. &quot;fun_mean&quot;).
</p>
</li></ul>

<p>Names of the available metrics of the 'MultiLandMetrics' object provided in <code>x</code> can
be accessed with <code>x@metrics</code> and <code>x@ext_calc</code>.
</p>
<p>Note that patch-level metrics, if exists in <code>x</code> metric's data.frame, are excluded from
calculations, as this function works at a landscape scale.
</p>
<p>If <code>aggregation</code> is TRUE, the values of the selected metrics for different sites will be aggregated.
By default, for each spatial scale and raster layer, <code><a href="#topic+metrics_scalogram">metrics_scalogram()</a></code> will
calculate the mean value from the values of all available sites/points. A different
function (could be user-defined) can be provided in argument <code>fun</code>.
</p>


<h3>Value</h3>

<p>A panel with ggplot2 facet plots relating the value of the provided
metrics and the radii. Plots are
</p>


<h3>References</h3>

<p>Wu, J. (2004). Effects of changing scale on landscape pattern analysis: scaling relations. Landscape ecology, 19, 125-138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We will generate a 'MultiLand' obejct with several radii. The objective is
# evaluate metrics across a wide range of spatial scales

# Loads main raster with land covers
elchaco &lt;- terra::rast(system.file("extdata", "elchaco.tif", package = "multilandr"))

# Loads extra raster with NDVI values
elchaco_ndvi &lt;- terra::rast(system.file("extdata", "elchaco_ndvi.tif", package = "multilandr"))

# Classes names
cl_names &lt;- c(1, "Forest",
              2, "Grassland",
              3, "Crops",
              4, "Pastures",
              5, "Water",
              6, "Urban")

# Loads points
elchaco_sites &lt;- terra::vect(system.file("extdata", "elchaco_sites.gpkg", package = "multilandr"))

# Creates 'MultiLand' object by loading main raster, an extra raster and points.
ernesdesign1 &lt;- mland(points_layer = elchaco_sites,
                      rast_layer = elchaco,
                      radii = seq(500, 5000, 100),
                      class_names = list(cl_names),
                      site_ref = "name",
                      ext_rast_layer = elchaco_ndvi,
                      rast_names = c("landcover", "NDVI"),
                      segs = 20)

# Now, we calculate two metrics: the number of patches for each class
# and the total edge considering all classes (i.e. a landscape-level class)
ed_metrics5 &lt;- mland_metrics(ernesdesign1,
                             what = c("lsm_c_np", "lsm_l_te"),
                             ext_calc = list(c(1, "mean")))

# Plots scalogram for 3 different sites/landscapes, for raster layer "landcover"
# and metric "np"
metrics_scalogram(ed_metrics5, points = c("Algarrobo", "Peje", "Itin"),
                  raster = "landcover", c_level = "np",
                 aggregation = FALSE, show_class_names = TRUE)

# Scalogram with aggregation across sites. By default, a mean value among all
# considered sites is calculated.
metrics_scalogram(ed_metrics5, raster = 1,
                  aggregation = TRUE, show_class_names = TRUE)

# Here, we only plot those metrics calculated for the extra raster layer
# named "NDVI", which in this case is only one metric
metrics_scalogram(ed_metrics5, points = c("Algarrobo", "Peje", "Itin"),
                  ext_raster = "NDVI",
                  aggregation = FALSE, show_class_names = TRUE)

# Scalogram with aggregation across three sites. By default, a mean value among
# the three considered sites is calculated.
metrics_scalogram(ed_metrics5, ext_raster = 1,
                  points = c("Yuchan", "Coco", "Tala"),
                  aggregation = FALSE, show_class_names = TRUE)

# The output can be customized as every ggplot object
library(ggplot2)
metrics_scalogram(ed_metrics5, points = c("Algarrobo", "Peje", "Itin"), raster = 1,
                  c_level = "np",
                  aggregation = FALSE, show_class_names = TRUE, lwd = 1) +
  scale_color_brewer(type = "div", palette = 1) +
  theme_bw() +
  theme(aspect.ratio = 1, legend.title = element_blank())

</code></pre>

<hr>
<h2 id='mland'>Generates object of class 'MultiLand'</h2><span id='topic+mland'></span>

<h3>Description</h3>

<p>Creates an object of class 'MultiLand', which is the
main object to be used by other functions
of the package to generate plots, calculate landscape metrics and perform other relevant
analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland(
  points_layer,
  rast_layer = NULL,
  radii,
  class_names = NULL,
  site_ref = NULL,
  bufftype = "round",
  segs = 20,
  ext_rast_layer = NULL,
  rast_names = NULL,
  on_the_fly = FALSE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_+3A_points_layer">points_layer</code></td>
<td>
<p>An object of class 'SpatVector', 'SpatialPoints', 'SpatialPointsDataFrame' or 'sf', or a string with the
path to a vector file.</p>
</td></tr>
<tr><td><code id="mland_+3A_rast_layer">rast_layer</code>, <code id="mland_+3A_ext_rast_layer">ext_rast_layer</code></td>
<td>
<p>An object of class 'SpatRaster', 'RasterLayer', 'RasterStack', 'RasterBrick',
or a list of raster objects (any of 'RasterLayer' or 'SpatRaster').</p>
</td></tr>
<tr><td><code id="mland_+3A_radii">radii</code></td>
<td>
<p>A numeric vector with the radii (in meters) from which buffers will be created.</p>
</td></tr>
<tr><td><code id="mland_+3A_class_names">class_names</code></td>
<td>
<p>A list matching each raster value with a class name. See Details.</p>
</td></tr>
<tr><td><code id="mland_+3A_site_ref">site_ref</code></td>
<td>
<p>A string with the name of the column containing the identity of the sites in
points layer data (argument <code>points_layer</code>). See Details.</p>
</td></tr>
<tr><td><code id="mland_+3A_bufftype">bufftype</code></td>
<td>
<p>Type of buffer to be created: &quot;round&quot; for circular buffers (default) or &quot;square&quot;.</p>
</td></tr>
<tr><td><code id="mland_+3A_segs">segs</code></td>
<td>
<p>Number of line segments to use to approximate a quarter circle during buffer generation. Only valid when
<code>bufftype = "round"</code>. Default is 20.</p>
</td></tr>
<tr><td><code id="mland_+3A_rast_names">rast_names</code></td>
<td>
<p>A character vector with the names of the raster layers provided in <code>rast_layer</code>
and <code>ext_rast_layer</code>. See Details.</p>
</td></tr>
<tr><td><code id="mland_+3A_on_the_fly">on_the_fly</code></td>
<td>
<p>Logical. If FALSE (default) intersections between buffers and raster layers will
be calculated. If TRUE, only buffers will be generated. See Details.</p>
</td></tr>
<tr><td><code id="mland_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE (default), progress of the analysis will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mland()</code> is the primary function of the package. It creates an object of class
'MultiLand' that holds relevant objects and information about points, buffers and intersections
between buffers and raster layers.
</p>
<p>The function firstly creates buffers with center in the sites defined in <code>points_layer</code>, and size defined by
the values of <code>radii</code>. If each point defined in <code>points_layer</code> has an associated name or id for
ulterior identification, the user should provide the name of the attribute inside <code>points_layer</code>
containing this information, by passing this string through the argument <code>site_ref</code>.
</p>
<p>Argument <code>rast_layer</code> must be provided with raster layers with discrete values from which different landscape metrics (provided by package <code>landscapemetrics</code>)
could be calculated. Extra raster layers can be provided in <code>ext_rast_layer</code>, from which other metrics can be
calculated. For instance, an extra raster layer could be one depicting continuous values of slope,
from which a mean value per landscape may be calculated. Raster layers should be in a coordinate reference
system with meters as the unit, and all raster and vector layers must be in the same coordinate reference system.
The user may check the validity of the raster layer with <code><a href="#topic+check_raster">check_raster()</a></code>.
</p>
<p>The extent of the provided points layer should not exceed the limits of the extent of the provided raster layers. In addition,
the difference between the outer borders of provided points layer and raster layers should not be less than the maximum
provided radius in <code>radii</code>. The purpose is to avoid generating total or partially &quot;empty landscapes&quot; due to the existence of
non-overlapping regions between the buffers (generated around each point given a provided radius) and the raster layers.
If any of this happens, a warning will be returned.
</p>
<p>If <code>on_the_fly = FALSE</code> (default), intersections between buffers and raster layers
defined in <code>rast_layer</code> and/or <code>ext_rast_layer</code> will be generated. Otherwise, if <code>on_the_fly = TRUE</code>, only buffers will be generated. The
latter approach may be particularly useful for 'MultiLand' objects with numerous points
(hundreds or thousands), in order to avoid returning an object excessively heavy for memory. If
this is the case, intersections between buffers and raster layers will be generated when
required (&quot;on the fly&quot;). For instance, to calculate metrics with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.
</p>
<p>The names of the provided raster layers can be defined in <code>rast_names</code>. If so, this must be
a character vector with as many names (strings) as provided raster layers in arguments <code>rast_layer</code> and
<code>ext_rast_layer</code>, in the mentioned order. If there is no need of a name for a particular raster layer, the given element in the vector
should be <code>NA</code>. Definition of these names could be useful when applying other functions of
the package to the object generated here. For instance, to get the name of the raster layer
of a particular row of the data.frame with landscape metrics exported by <code><a href="#topic+mland_metrics">mland_metrics()</a></code>.
</p>
<p>Classes names can be associated with each value of the raster layers defined in <code>rast_layer</code>, for a
easier future identification. If so, the user must provide a list with as many elements as
raster layers defined in <code>rast_layer</code>. If a 'SpatRaster' with multiple layers, a 'RasterStack' or a
'RasterBrick' is provided, the
number of raster layers are extracted from these objects. Each element of the list must be a
vector built from concatenated pairs of values, with the value of the raster (the class) in the
first place and the associated class name in the second place. For example, in the case only
one rasterlayer is provided (with four unique values: 1, 2, 3 and 4), a plausible definition
for the argument <code>class_names</code> could be the following:
</p>
<pre>
 list(c(1, "Forest", 2, "Crops", 3, "Urban", 4, "Grassland"))
</pre>
<p>If, for instance, two raster layers are provided (with four unique values for the first layer,
and two unique values for the second one), a plausible definition would be:
</p>
<pre>
 list(c(1, "Forest", 2, "Crops", 3, "Urban", 4, "Grassland"),
      c(1, "Burnt Areas", 2, "Non-burnt Areas"))
</pre>


<h3>Value</h3>

<p>An object of class 'MultiLand'. This object can be used to generate useful plots with
<code><a href="#topic+mland_plot">mland_plot()</a></code>, calculate metrics with <code><a href="#topic+mland_metrics">mland_metrics()</a></code> and calculate buffer's overlapping with
<code><a href="#topic+mland_overlap">mland_overlap()</a></code>. See ?MultiLand for more details on the content of this object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_plot">mland_plot()</a></code>, <code><a href="#topic+mland_metrics">mland_metrics()</a></code>, <code><a href="#topic+mland_overlap">mland_overlap()</a></code>, <code><a href="#topic+generate_points">generate_points()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loads main raster with land covers
elchaco &lt;- terra::rast(system.file("extdata", "elchaco.tif", package = "multilandr"))

# Main raster should have discrete values (e.g. land covers). This can be
# checked with the function check_raster():

check_raster(elchaco)

# Loads extra raster with NDVI values
elchaco_ndvi &lt;- terra::rast(system.file("extdata", "elchaco_ndvi.tif", package = "multilandr"))

# Classes names
cl_names &lt;- c(1, "Forest",
              2, "Grassland",
              3, "Crops",
              4, "Pastures",
              5, "Water",
              6, "Urban")

# Loads points
elchaco_sites &lt;- terra::vect(system.file("extdata", "elchaco_sites.gpkg", package = "multilandr"))

# Creates 'MultiLand' object by loading main raster, an extra raster and points.
ernesdesign &lt;- mland(points_layer = elchaco_sites,
                     rast_layer = elchaco,
                     radii = seq(1000, 5000, 1000),
                     class_names = list(cl_names),
                     site_ref = "name",
                     ext_rast_layer = elchaco_ndvi,
                     rast_names = c("landcover", "NDVI"),
                     segs = 20)

# Returns basic information about the object
ernesdesign

# Returns the classes of each rasterlayer and its names, if initially provided
ernesdesign@classes


# Loads another main raster. Same classes as "elchaco", but a different year.
elchaco2 &lt;- terra::rast(system.file("extdata", "elchaco2.tif", package = "multilandr"))

# Creates 'MultiLand' with two raster layers.
ernesdesign2 &lt;- mland(points_layer = elchaco_sites,
                      rast_layer = list(elchaco, elchaco2),
                      radii = seq(1000, 5000, 1000),
                      class_names = list(cl_names, cl_names),
                      site_ref = "name")

# Creates the same object but with "on_the_fly = TRUE". Intersections between
# buffers and rasters will not be generated in this step
ernesdesign3 &lt;- mland(points_layer = elchaco_sites,
                      rast_layer = list(elchaco, elchaco2),
                      radii = seq(1000, 5000, 1000),
                      class_names = list(cl_names, cl_names),
                      site_ref = "name",
                      on_the_fly = TRUE)

# Creates a MultiLand object with hundreds of points. In this case, these
# points were generated with generate_points(), another function from this
# package. Also, "on_the_fly = TRUE" assures that no intersections between buffers
# and the raster are created in this step.

# Loads points
otf_sites &lt;- terra::vect(system.file("extdata", "otf_sites.gpkg", package = "multilandr"))

# Creates MultiLand object
otf_design &lt;- mland(points_layer = otf_sites,
                    rast_layer = elchaco,
                    radii = 2000,
                    class_names = list(c(1, "Forest",
                                         2, "Grassland",
                                         3, "Crops",
                                         4, "Pastures",
                                         5, "Water",
                                         6, "Urban")),
                    on_the_fly = TRUE)

</code></pre>

<hr>
<h2 id='mland_export_gis'>Exports a 'MultiLand' object as GIS data</h2><span id='topic+mland_export_gis'></span>

<h3>Description</h3>

<p>Exports points, buffers and intersections between buffers and raster layers, as vector and raster
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_export_gis(
  x,
  raster = NULL,
  points = NULL,
  radii = NULL,
  ext_raster = NULL,
  name = NULL,
  gdal = c("COMPRESS=DEFLATE", "PREDICTOR=2", "ZLEVEL=9"),
  dir = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_export_gis_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLand' generated with <code><a href="#topic+mland">mland()</a></code>.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_raster">raster</code>, <code id="mland_export_gis_+3A_ext_raster">ext_raster</code></td>
<td>
<p>Numeric. The raster layers to be exported.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_points">points</code></td>
<td>
<p>Numeric or character vector of points to be processed. See Details.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_radii">radii</code></td>
<td>
<p>Numeric vector of radii to be processed.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_name">name</code></td>
<td>
<p>Character. Name of the zip file where files will be exported.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_gdal">gdal</code></td>
<td>
<p>GeoTiff creation options for rasters (<a href="https://gdal.org/en/stable/drivers/raster/gtiff.html">GeoTiff file format</a>).
<code><a href="#topic+mland_export_gis">mland_export_gis()</a></code> uses the following compression options:
c(&quot;COMPRESS=DEFLATE&quot;, &quot;PREDICTOR=2&quot;, &quot;ZLEVEL=9&quot;).</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_dir">dir</code></td>
<td>
<p>Path to the export directory. This must be specified explicitly.
To export to the current directory, use <code>dir = getwd()</code>. Otherwise, provide
a valid path to an existing directory, ensuring it does not end with &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_verbose">verbose</code></td>
<td>
<p>Print messages in the console? Default is TRUE.</p>
</td></tr>
<tr><td><code id="mland_export_gis_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="terra.html#topic+writeRaster">terra::writeRaster</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>points</code> is a character vector,
<code><a href="#topic+mland_export_gis">mland_export_gis()</a></code> will assume that the 'MultiLand' object inputted in argument <code>x</code> was created with
<code>site_ref = TRUE</code>. This is, there is an attribute in points layer data with the names for
each individual point. Therefore, the inputted values in argument <code>points</code> will be taken as these
identification names. Otherwise, if a numeric vector is declared, the inputted values
will be taken as the automatically generated point ids (created when running <code><a href="#topic+mland">mland()</a></code>).
</p>


<h3>Value</h3>

<p>GIS data from a 'MultiLand' object is exported through a zip file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland">mland()</a></code>, <code><a href="#topic+mland_save">mland_save()</a></code>, <code><a href="#topic+mland_load">mland_load()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loads a 'MultiLand' object
ernesdesign &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(ernesdesign)

# Exports as GIS data, in temporary directory for this example and with a given name
mland_export_gis(ernesdesign, dir = tempdir(), name = "mland-GIS_example")

# Remove file for this example
unlink(file.path(tempdir(), "mland-GIS_example.zip"))

</code></pre>

<hr>
<h2 id='mland_load'>Load 'MultiLand' or 'MultiLandMetrics' object</h2><span id='topic+mland_load'></span>

<h3>Description</h3>

<p>Imports a zip file into an object of class 'MultiLand' that was previously
saved with <code><a href="#topic+mland_save">mland_save()</a></code>. Alternatively, loads to the environment an RDS object depicting a
'MultiLandMetrics' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_load(path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_load_+3A_path">path</code></td>
<td>
<p>A string depicting the path to a zip file, to load objects of class
'MultiLand', or to a RDS file to load objects of class 'MultiLandMetrics'.</p>
</td></tr>
<tr><td><code id="mland_load_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="base.html#topic+readRDS">readRDS()</a></code> when trying to load an object of class
'MultiLandMetrics'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'MultiLand' or a 'MultiLandMetrics' object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_save">mland_save()</a></code>, <code><a href="#topic+mland">mland()</a></code>, <code><a href="#topic+mland_metrics">mland_metrics()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loads mland object from a zip file, previously created with mland_save()
mland_obj &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(mland_obj)

# Loads a MultiLandMetrics object previously generated with mland_metrics() and
# exported as a RDS object with mland_save() or saveRDS()

mlm_obj &lt;- system.file("extdata", "ed_metrics.rds", package = "multilandr")
ed_metrics &lt;- mland_load(mlm_obj)
</code></pre>

<hr>
<h2 id='mland_metrics'>Calculates landscape metrics</h2><span id='topic+mland_metrics'></span>

<h3>Description</h3>

<p>Calculates landscape metrics of patch, class and/or landscape level via the package
<code>landscapemetrics</code> and user-defined functions from an object of class 'MultiLand'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_metrics(
  x,
  raster = NULL,
  points = NULL,
  radii = NULL,
  classes = NULL,
  level = NULL,
  metric = NULL,
  name = NULL,
  type = NULL,
  what = NULL,
  report_absences = TRUE,
  absence_values = NULL,
  ext_calc = NULL,
  na.exclude = TRUE,
  coords = FALSE,
  update = NULL,
  output = "MLM",
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_metrics_+3A_x">x</code></td>
<td>
<p>An object of class 'Multiland' generated with <code><a href="#topic+mland">mland()</a></code>.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_raster">raster</code></td>
<td>
<p>Vector depicting the raster layers of <code>x</code> from which metrics will be
calculated. It can be a numeric vector, for rasterlayer numbers, or a character vector, for
raster layer names (if provided during the generation of <code>x</code>). If NULL, all raster layers will be
considered.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_points">points</code></td>
<td>
<p>Numeric or character vector with the points from which metrics will be calculated.
If NULL, all points will be considered. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_radii">radii</code></td>
<td>
<p>Numeric vector depicting the radii from which metrics will be calculated.
If NULL, all radii will be considered.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_classes">classes</code></td>
<td>
<p>List containing the classes or classes names from which metrics will be calculated.
If NULL, all classes will be considered. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_level">level</code>, <code id="mland_metrics_+3A_metric">metric</code>, <code id="mland_metrics_+3A_name">name</code>, <code id="mland_metrics_+3A_type">type</code>, <code id="mland_metrics_+3A_what">what</code></td>
<td>
<p>Arguments passed to <code><a href="landscapemetrics.html#topic+calculate_lsm">landscapemetrics::calculate_lsm()</a></code>,
which define which metrics will be calculated. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_report_absences">report_absences</code></td>
<td>
<p>Logical. If TRUE (default), intersections with absences of particular
classes will be returned in the final data.frame. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_absence_values">absence_values</code></td>
<td>
<p>A list depicting which value for each class-level metric should be printed
if <code>report_absences = TRUE</code>. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_ext_calc">ext_calc</code></td>
<td>
<p>A list containing vectors, each one of length equal to 2 or more: the first element of the vector
with the identification number of the extra raster layer defined in <code>x</code>, and next elements with a string with
the name of the function to be applied to the defined raster. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_na.exclude">na.exclude</code></td>
<td>
<p>Logical. Whether to exclude (default) or not the NA values when performing
extra calculations to extra raster layers. Only applies if <code>ext_calc</code> is not NULL. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_coords">coords</code></td>
<td>
<p>Logical. If TRUE, the coordinates of the points will be returned in the data.frame
containing the values of the required metrics. Default FALSE.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_update">update</code></td>
<td>
<p>An object of class 'MultiLandMetrics', if it is intended to be updated with
new or updated metrics data. See Details.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_output">output</code></td>
<td>
<p>Either &quot;MLM&quot; (default) to output an object of class 'MultiLandMetrics' or &quot;data&quot; to output
only the data.frame with metric values.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE (default), progress of calculations will be printed.</p>
</td></tr>
<tr><td><code id="mland_metrics_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="landscapemetrics.html#topic+calculate_lsm">landscapemetrics::calculate_lsm()</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates landscape metrics from an object of class <code>MultiLand</code>
created with <code><a href="#topic+mland">mland()</a></code>. The function allows to define which metrics will be calculated in the
form defined by the function <code><a href="landscapemetrics.html#topic+calculate_lsm">landscapemetrics::calculate_lsm()</a></code> from package <code>landscapemetrics</code>, by
specifying one or more of the following arguments:
</p>

<ul>
<li><p> level: level of metrics. Either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot; (or vector with combination).
</p>
</li>
<li><p> metric: abbreviation of metrics (e.g. &quot;area&quot;).
</p>
</li>
<li><p> name: full name of metrics (e.g. &quot;core area&quot;).
</p>
</li>
<li><p> type: type according to FRAGSTATS grouping (e.g. &quot;aggregation metrics&quot;).
</p>
</li>
<li><p> what: selected level of metrics: either &quot;patch&quot;, &quot;class&quot; or &quot;landscape&quot;. It is also possible to
specify functions as a vector of strings, e.g. what = c(&quot;lsm_c_ca&quot;, &quot;lsm_l_ta&quot;).
</p>
</li></ul>

<p>Available metrics can be seen in <code><a href="#topic+metrics_list">metrics_list()</a></code> and in the associated documentation of package
<code>landscapemetrics</code>.
</p>
<p><code><a href="#topic+mland_metrics">mland_metrics()</a></code> also allows to define some other parameters that filter how metrics are calculated,
by defining the raster layers, points, radii and classes to be taken into account.
</p>
<p>If <code>report_absences = TRUE</code> (default), the function will print values of class-level metrics
from classes that are not present in particular landscapes, as a distinct row in the final
data.frame. This is particularly useful for certain class-level metrics in which the absence
of the class should be acknowledged, for instance, the percentage of landscape ('pland') for a forest class. For this
metric, a value of 0 (zero) should be printed for those landscapes where the class forest is not present.
By default, if <code>report_absences = TRUE</code>, the function will consider <code>NA</code> as the value
to be declared in the case that the class is absent in the landscape. To declare a different value
for a particular class-level metric, this can be declared inside argument <code>absence_values</code>. If
not NULL, this must be a list with the value that one ore more class-level metric should
have in the case of an absence of a class. For example, in the case of &quot;pland&quot;, the argument
should be defined as follows: <code>absence_values = list("pland" = 0)</code>. Note that the metric must be
identified with its abbreviation. You can see abbreviations for all available metrics in <code><a href="#topic+metrics_list">metrics_list()</a></code>,
under the column &quot;metric&quot;.
</p>
<p>If argument <code>points</code> is a character vector,
<code><a href="#topic+mland_metrics">mland_metrics()</a></code> assumes that the 'MultiLand' object inputted in argument <code>x</code> was created with
<code>site_ref = TRUE</code>. This is, there is an column/attribute in the points layer with the names for
each distinct point. Therefore, the inputted values in argument <code>points</code> will be taken as these
identification names. Otherwise, if a numeric vector is inputted, these values
will be taken as the automatically generated point ids (created when running <code><a href="#topic+mland">mland()</a></code>).
</p>
<p>The user may specify which classes will be considered when calculating the metrics, by
passing this information in the argument <code>classes</code>. Of course, this information only applies for
class-level metrics. The argument must be a list with as many elements as raster layers to be
considered (defined in argument <code>raster</code>, in ascending order: 1, 2, 3, ...). Each element must be a numeric vector
with the classes values (raster values) to be considered, or a character vector with
the names of the classes (if provided when generating <code>x</code>).
</p>
<p>Other arguments can be passed to function <code><a href="landscapemetrics.html#topic+calculate_lsm">landscapemetrics::calculate_lsm()</a></code> through argument
<code>...</code>. These include specific arguments relative to the calculation of particular landscape
metrics. See the documentation of this function for more information.
</p>
<p>Extra calculations can be performed through <code>ext_calc</code>. The functions defined here will take
the values of the extra raster layers defined in <code>x</code> as input. For instance, a plausible definition
could be <code>ext_calc = list(1, "mean")</code>, which will take the values from the extra raster layer 1,
and calculate its mean for each landscape. If <code>na.exclude = TRUE</code> (default), NA values will be excluded
from this task.
</p>
<p>A previously generated 'MultiLandMetrics' object can be updated with new information regarding
other metrics, probably from other points, radii, raster layers, etc, that havenÂ´t been
calculated in the previous time (or not). In this way, the returned object will be
the object provided in this argument, plus the additions of information about new metrics, and
changes to previously metric calculations. Note that if a particular metric is calculated for a
given raster layer, points, radii and or class, that were previously generated in the object
provided in <code>update</code>, the information of these metrics from the latter will be overwritten. Also
note that if in the previous 'MultiLandMetrics' object <code>report_absences</code> was <code>TRUE</code> for a given
set of metrics and other parameters (e.g. points, radii, raster layers, etc.), and in the new call
<code>report_absences</code> is <code>FALSE</code> (for the same set of other parameters), the rows depicting landscapes
with empty classes from the previous call will be mantained. If the intention is the removal of these rows,
the user should create a fresh new 'MultiLandMetrics' from scratch.
</p>


<h3>Value</h3>

<p>If <code>output = "MLM"</code>, an object of class 'MultiLandMetrics' will be returned. This object
can then be passed to functions <code><a href="#topic+metrics_corr">metrics_corr()</a></code>, <a href="#topic+metrics_plots">metrics_plots</a>, <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, <code><a href="#topic+metrics_gradient">metrics_gradient()</a></code>
and <code><a href="#topic+metrics_bind">metrics_bind()</a></code>. See
?MultiLandMetrics for more information regarding the content of this object. Otherwise,
if <code>output = "data"</code>, only a data.frame with the calculated metrics will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics_corr">metrics_corr()</a></code>, <code><a href="#topic+metrics_plots">metrics_plots()</a></code>, <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, <code><a href="#topic+metrics_gradient">metrics_gradient()</a></code>, <code><a href="#topic+metrics_bind">metrics_bind()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loads a 'MultiLand' object
ernesdesign &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(ernesdesign)

# Creates a 'MultiLandMetrics' object. It will calculate the "percentage of landscape"
# ("pland") and "edge density" ("ed") for all classes. Note that an absence value
# for each metric is declared, as the absence of a class for these metrics should be
# acknowledged as a 0 (percentage of zero and zero patches).
ed_metrics &lt;- mland_metrics(ernesdesign, level = "class", metric = c("pland", "ed"),
                            absence_values = list("pland" = 0))

# Returns data.frame with the values of all metrics for each landscape
head(ed_metrics@data)

# Shows which metrics were calculated and are contained in the data.frame
ed_metrics@metrics

# If output = "data", only the data.frame will be returned
data &lt;- mland_metrics(ernesdesign, level = "class", metric = "pland",
                      classes = c("Forest", "Crops"),
                      absence_values = list("pland" = 0),
                      output = "data")

# Calculate landscape metrics plus extra calculations for extra rasterlayer 1,
# the mean value, and a user defined function, which is the mean divided
# standard deviation.

# User-defined function
mean_sd &lt;- function(x){ mean(x)/sd(x) }

ed_metrics2 &lt;- mland_metrics(ernesdesign, level = "class",
                             metric = c("pland", "ed"),
                             absence_values = list("pland" = 0),
                             ext_calc = list(c(1, "mean"), c(1, "mean_sd")))

# We can calculate metrics for extra raster layers only
ed_metrics3 &lt;- mland_metrics(ernesdesign, ext_calc = list(c(1, "mean", "mean_sd")))

# If metrics of different levels must be calculated, a better approach is to declare
# them inside the argument 'what', by naming the function associated with the metric.
# Also in this case, only the landscapes with a radius of 5000 m are considered.
# A list of available metrics with its names, abbreviations and function names can
# be seen in metrics_list() and in the documentation of the package landscapemetrics.
ed_metrics4 &lt;- mland_metrics(ernesdesign,
                             what = c("lsm_c_area_mn", "lsm_l_ed", "lsm_l_shdi"),
                             radii = 5000)

# Calculates patch-level metrics of a particular landscape
ed_patchs &lt;- mland_metrics(ernesdesign, points = "Algarrobo",
                           level = "patch", class = "Forest",
                           radii = 1000)

</code></pre>

<hr>
<h2 id='mland_overlap'>Buffers overlapping</h2><span id='topic+mland_overlap'></span>

<h3>Description</h3>

<p>Returns matrices informing the degree of overlapped area
between buffers of a 'MultiLand' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_overlap(
  x,
  points = NULL,
  radii = NULL,
  digits = 2,
  perc = TRUE,
  title = "id"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_overlap_+3A_x">x</code></td>
<td>
<p>An object of class 'Multiland' generated with <code><a href="#topic+mland">mland()</a></code>.</p>
</td></tr>
<tr><td><code id="mland_overlap_+3A_points">points</code></td>
<td>
<p>Numeric or character vector depicting the points to be considered. If NULL, all
points will be taken into account. See Details.</p>
</td></tr>
<tr><td><code id="mland_overlap_+3A_radii">radii</code></td>
<td>
<p>Numeric vector depicting the radii to be considered. If NULL, all radii will be taken
into account.</p>
</td></tr>
<tr><td><code id="mland_overlap_+3A_digits">digits</code></td>
<td>
<p>Numeric. Number of digits for the values of overlapped areas. Default is 2.</p>
</td></tr>
<tr><td><code id="mland_overlap_+3A_perc">perc</code></td>
<td>
<p>Logical. If TRUE (default) the degree of overlapped areas will be
presented as percentages. If FALSE, proportions will be outputted.</p>
</td></tr>
<tr><td><code id="mland_overlap_+3A_title">title</code></td>
<td>
<p>One of the following: &quot;id&quot; to output each point with its id (default), or &quot;sitename&quot; to
output each point with its pre-defined point name in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>points</code> is a character vector,
<code><a href="#topic+mland_overlap">mland_overlap()</a></code> will assume that the 'MultiLand' object inputted in argument <code>x</code> was created with
<code>site_ref = TRUE</code>. This is, there is a column/attribute in the points layer with the names for
each distinct point. Therefore, the inputted values in argument <code>points</code> will be taken as these
identification names. Otherwise, if a numeric vector is declared, the inputted values
will be taken as the automatically generated point ids (created when executing <code><a href="#topic+mland">mland()</a></code>).
</p>


<h3>Value</h3>

<p>A list with as many elements as different radius in <code>x</code>. Each element contains a
matrix with the percentages (or proportions if <code>perc = FALSE</code>) of overlapping of buffer areas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loads a 'MultiLand' object
ernesdesign &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(ernesdesign)

# Returns a matrix with the percentage of overlapping between buffers of each radii
mland_overlap(ernesdesign)

# Selects only one radius and return the site names rather than the ids
mland_overlap(ernesdesign, radii = 5000, title = "sitename")

</code></pre>

<hr>
<h2 id='mland_plot'>Plots landscapes from 'MultiLand' objects</h2><span id='topic+mland_plot'></span>

<h3>Description</h3>

<p>Returns multiple plots for each landscape generated from each point and buffer, with their radii and classes,
defined by the user through a 'MultiLand' object (generated by <code><a href="#topic+mland">mland()</a></code>).
Aesthetic parameters of plots can be customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_plot(
  x,
  raster = NULL,
  points = NULL,
  radii = NULL,
  ext_raster = NULL,
  title = "id",
  ncol = NULL,
  nrow = NULL,
  st_points = list(shape = 21, size = 2, col = "black", fill = "white", alpha = 1),
  st_buffers = list(lty = 1, lwd = 1, col = "black", alpha = 0.6),
  st_classes = list(palette = "Spectral", fill = NULL, alpha = NULL, na_value =
    c("white", 1)),
  st_ext = c("chartreuse", "firebrick1")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_plot_+3A_x">x</code></td>
<td>
<p>An object of class 'MultiLand' generated with <code><a href="#topic+mland">mland()</a></code>.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_raster">raster</code>, <code id="mland_plot_+3A_ext_raster">ext_raster</code></td>
<td>
<p>Numeric. The rasterlayer to be plotted. Only one rasterlayer can be
plotted at the same time, either defined in <code>raster</code> or <code>ext_raster</code>.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_points">points</code></td>
<td>
<p>Numeric or character vector of points to be plotted. See Details.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_radii">radii</code></td>
<td>
<p>Numeric vector of radii to be plotted.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_title">title</code></td>
<td>
<p>One of the following: &quot;id&quot; to plot titles as each point id (default), or &quot;sitename&quot; to
plot titles as each pre-defined point name in <code>x</code>. See Details.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_ncol">ncol</code>, <code id="mland_plot_+3A_nrow">nrow</code></td>
<td>
<p>Number of columns and rows wherein individual plots will be arranged.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_st_points">st_points</code></td>
<td>
<p>List of aesthetic arguments for points plotting:
<code>shape</code> for points shape, <code>size</code> for points size, <code>col</code> for
points border color, <code>fill</code> for points fill color and <code>alpha</code> for point transparency.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_st_buffers">st_buffers</code></td>
<td>
<p>List of aesthetic arguments for buffers plotting:
<code>lty</code> for buffers linetype, <code>lwd</code> for buffers linewidth,
<code>col</code> for buffers border color and <code>alpha</code> for border transparency.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_st_classes">st_classes</code></td>
<td>
<p>List of aesthetic arguments for classes plotting:
<code>palette</code>, for classes color palette, <code>fill</code> a vector of fill colors for classes, <code>alpha</code>, a vector of
alpha values for classes, and <code>na_value</code> for the color of NA values. See Details.</p>
</td></tr>
<tr><td><code id="mland_plot_+3A_st_ext">st_ext</code></td>
<td>
<p>Character vector of length 2, depicting the color for the minimum and maximum values
of the raster defined in <code>ext_raster</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>points</code> is a character vector,
<code><a href="#topic+mland_plot">mland_plot()</a></code> will assume that the 'MultiLand' object inputted in argument <code>x</code> was created with
<code>site_ref = TRUE</code>. This is, there is a column/attribute in points layer data with the names for
each distinct point. Therefore, the inputted values in argument <code>points</code> will be taken as these
identification names. Otherwise, if a numeric vector is inputted, these values
will be taken as the automatically generated point ids (created when running <code><a href="#topic+mland">mland()</a></code>).
</p>
<p>If <code>title = "sitename"</code>, the title of individual plots will be the names of each point. For this,
the names of the points in <code>x</code> must had been defined when the object was created with <code><a href="#topic+mland">mland()</a></code>
(i.e. <code>x@site_ref = TRUE</code>). Otherwise, the argument will be ignored and the titles will be the
ids of the points.
</p>
<p>A pre-defined palette can be chosen to differentiate classes inside <code>palette = "palette_name"</code>,
inside the list defined in <code>st_classes</code>. Any palette from <code><a href="grDevices.html#topic+hcl.pals">hcl.pals()</a></code> can be chosen. Otherwise,
the user can define specific colors for each class, inside <code>fill</code>. This must be a vector built
with concatenated pair of values, the first value being the class (or class name, if defined
during <code>x</code> generation), and the second value the color (either the name of the color or the hex
code of the color). For example, in the case the rasterlayer has four unique values: (1, 2, 3 and 4), a plausible color definition
could be the following:
</p>
<pre>
 list(c(1, "green", 2, "red", 3, "black", 4, "yellow"))
</pre>


<h3>Value</h3>

<p>Multiple plots (in a unique plotting device) of landscapes around
defined points, radii and classes of a MultiLand object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loads a 'MultiLand' object
ernesdesign &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(ernesdesign)

# Plots all points and radii
mland_plot(ernesdesign)

# Plots points 1 to 3 and only radius 3000 m
mland_plot(ernesdesign, points = 1:3, radii = 3000)

# Plot with pre-defined colors, and specifying other arguments
cols &lt;- c(1, "forestgreen",
          2, "darkolivegreen2",
          3, "firebrick3",
          4, "goldenrod1",
          5, "deepskyblue3",
          6, "black")

mland_plot(ernesdesign, points = 9:11, radii = c(1000, 2000, 3000),
           title = "sitename", nrow = 1,
           st_points = list(shape = 9),
           st_buffers = list(lty = "dashed"),
           st_classes = list(fill = cols))

# Plot a unique landscape by calling it with its name
mland_plot(ernesdesign, points = "Peje", title = "sitename",
           st_points = list(shape = 15, col = "red"),
           st_classes = list(palette = "Hawaii"))

# Plot extra rasterlaer
mland_plot(ernesdesign, radii = 3000, ext_raster = 1, title = "sitename")

# Plot extra rasterlater with customized colors
mland_plot(ernesdesign, radii = 3000, ext_raster = 1, title = "sitename",
           st_ext = c("blue", "red"))

</code></pre>

<hr>
<h2 id='mland_save'>Saves a 'MultiLand' or 'MultiLandMetrics' object</h2><span id='topic+mland_save'></span>

<h3>Description</h3>

<p>Exports an object of class 'MultiLand' to be read in the future with <code><a href="#topic+mland_load">mland_load()</a></code>, or
an object of class 'MultiLandMetrics' as if it was saved with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mland_save(
  x,
  name = NULL,
  gdal = c("COMPRESS=DEFLATE", "PREDICTOR=2", "ZLEVEL=9"),
  dir = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mland_save_+3A_x">x</code></td>
<td>
<p>Object of class 'MultiLand' or 'MultiLandMetrics'.</p>
</td></tr>
<tr><td><code id="mland_save_+3A_name">name</code></td>
<td>
<p>If <code>x</code> is an object of class 'MultiLand', the name of the zip file where
files will be saved (without the '.zip'). If <code>x</code> is an object of class 'MultiLandMetrics',  the name of the R file (.rds). If NULL (default),
the name will be 'mland_' or 'mlandmetrics_' + a large random number.</p>
</td></tr>
<tr><td><code id="mland_save_+3A_gdal">gdal</code></td>
<td>
<p>GeoTiff creation options for rasters (<a href="https://gdal.org/en/stable/drivers/raster/gtiff.html">GeoTiff file format</a>).
<code><a href="#topic+mland_save">mland_save()</a></code> uses the following compression options: c(&quot;COMPRESS=DEFLATE&quot;, &quot;PREDICTOR=2&quot;, &quot;ZLEVEL=9&quot;). Only relevant
if <code>x</code> is an object of class 'MultiLand'.</p>
</td></tr>
<tr><td><code id="mland_save_+3A_dir">dir</code></td>
<td>
<p>Path to the export directory. This must be specified explicitly.
To export to the current directory, use <code>dir = getwd()</code>. Otherwise, provide
a valid path to an existing directory, ensuring it does not end with &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="mland_save_+3A_verbose">verbose</code></td>
<td>
<p>Print messages in the console? Default is TRUE.</p>
</td></tr>
<tr><td><code id="mland_save_+3A_...">...</code></td>
<td>
<p>If <code>x</code> is an object of class 'MultiLand', <code>...</code> should depict other arguments passed to
<a href="terra.html#topic+writeRaster">terra::writeRaster</a>, the function to write raster layers (from intersections and plain raster layers).
Otherwise, if <code>x</code> is an object of class 'MultiLandMetrics', <code>...</code> should depict other arguments passed
to <code><a href="base.html#topic+save">save()</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'MultiLand' objects should be exported with this function rather than exporting as an
external representation of R objects with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>. This is because objects of classes
'SpatVector' and 'SpatRaster' (from package terra) contained inside a 'MultiLand'
object cannot be exported as regular R objects. The exported object will be a zip file,
and can be loaded again into an R session with <code><a href="#topic+mland_load">mland_load()</a></code>.
</p>
<p>Relevant arguments can be passed to the function <a href="terra.html#topic+writeRaster">terra::writeRaster</a>, which is used to write
raster layers from a 'MultiLand' object. Particularly, in the argument <code>gdal</code> one can specify
relevant options regarding raster compression. This may reduce raster sizes significantly. Definition
of some other arguments inside <a href="terra.html#topic+writeRaster">terra::writeRaster</a> may affect exportation of raster layer
objects, in the context of a 'MultiLand' object.
</p>
<p>Objects of class 'MultiLandMetrics', instead, do not contain 'SpatVector' or 'SpatRaster' objects
and can be exported as regular R objects with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>. The user may use <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> or
<code><a href="#topic+mland_save">mland_save()</a></code>, and the outcome will be identical.
</p>


<h3>Value</h3>

<p>If <code>x</code> is an object of class 'MultiLand', a zip file or a directory containing all
information regarding the 'MultiLand' object provided in 'x'. Otherwise, if <code>x</code> is an object of
class 'MultiLandMetrics', the function will export the R object as if it was exported as a
regular R object with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mland_load">mland_load()</a></code>, <code><a href="#topic+mland">mland()</a></code>, <code><a href="#topic+mland_metrics">mland_metrics()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load MultiLand object
mland_obj &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign2 &lt;- mland_load(mland_obj)

# Save it again, in temporary directory for this example and with a given name
mland_save(ernesdesign2, name = "mland_example", dir = tempdir())

# Remove file for this example
unlink(file.path(tempdir(), "mland_example.zip"))

# Save it again but defining a higher compression for raster layers
mland_save(ernesdesign2, gdal = "COMPRESS=DEFLATE", name = "mland_example", dir = tempdir())

# Remove file for this example
unlink(file.path(tempdir(), "mland_example.zip"))

# Loads a MultiLandMetrics object previously generated with mland_metrics()
mlm_obj &lt;- system.file("extdata", "ed_metrics.rds", package = "multilandr")
ed_metrics2 &lt;- mland_load(mlm_obj)

# Save it again. In this case, mland_save() is the same as using saveRDS()
mland_save(ed_metrics2, dir = tempdir(), name = "mlandmetrics_example")

unlink(file.path(tempdir(), "mlandmetrics_example.rds"))

</code></pre>

<hr>
<h2 id='MultiLand-class'>Class &quot;MultiLand&quot;</h2><span id='topic+MultiLand-class'></span>

<h3>Description</h3>

<p>Objects of class 'MultiLand' are created with the function <code><a href="#topic+mland">mland()</a></code>, and holds
relevant objects and information to be passed to other functions of the package. The slot
<code style="white-space: pre;">&#8288;@buffers&#8288;</code> holds an object of class 'SpatVector' with the buffers for each point
contained in the slot <code style="white-space: pre;">&#8288;@points&#8288;</code> and each radius defined in slot <code style="white-space: pre;">&#8288;@radii&#8288;</code>. The slot
<code style="white-space: pre;">&#8288;@buffers@data&#8288;</code> holds a data.frame with the identification of each buffer (individualized by a
point id and a radius value).
</p>


<h3>Details</h3>

<p>If the slot <code style="white-space: pre;">&#8288;@on_the_fly&#8288;</code> equals <code>FALSE</code>, the slot <code style="white-space: pre;">&#8288;@landscapes&#8288;</code> holds the intersections (objects of class 'SpatRaster') between
buffers and the raster layers inputted by the user when running <code><a href="#topic+mland">mland()</a></code>. Intersections
between buffers and raster layers with discrete values (inputted in argument <code>raster</code> in <code><a href="#topic+mland">mland()</a></code>) are
contained inside a list named 'lsm_rasters', whereas intersections between extra raster layers
(inputted in argument <code>ext_rast_layer</code> in <code><a href="#topic+mland">mland()</a></code>) and buffers
are contained inside a list named 'ext_rasters'. Each list ('lsm_rasters' and 'ext_rasters') contains a
list with as many elements as previously inputted raster layers. Additionally, each element of
this latter list holds an additional internal list, with as many elements as intersections (i.e. rasters generated by the intersections between buffers defined
by each point and radius, and the raster layer). The name of each element of each internal list
reveals the information related to a given intersection, with the following coding: &quot;RasterLayerL-P-R&quot; or
&quot;ExtRasterLayerL-P-R&quot;, where L is the
given raster layer, P is the id of the point and R is the radius. For example, a plausible
intersection may be named as &quot;RasterLayer1-5-1500&quot;, indicating that this element holds a raster
layer which is the result of the intersection between RasterLayer1 and the buffer around point 5 and
radius 1500 m.
</p>
<p>If slot <code style="white-space: pre;">&#8288;@on_the_fly&#8288;</code> equals <code>FALSE</code>, the slot <code style="white-space: pre;">&#8288;@landscapes&#8288;</code> holds a list containing two named lists
as 'lsm_rasters' and 'ext_rasters'. Each one contains a list with as many raster layers were initially
inputted by the user when running <code><a href="#topic+mland">mland()</a></code> in arguments <code>rast_layer</code> and <code>ext_rast_layer</code>.
This means that no intersections were
made when creating the 'MultiLand' object. Intersections will be created &quot;on the fly&quot; when other functions of
the package requires them.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>The call when function <code><a href="#topic+mland">mland()</a></code> was called.</p>
</dd>
<dt><code>idkey</code></dt><dd><p>A unique identification id for the 'MultiLand' object.</p>
</dd>
<dt><code>crs_proj</code></dt><dd><p>A string depicting the CRS of points layer.</p>
</dd>
<dt><code>points</code></dt><dd><p>An object of class 'SpatVector'. Holds the points inputted by the user.</p>
</dd>
<dt><code>buffers</code></dt><dd><p>An object of class 'SpatVector'. Holds the buffers layers.</p>
</dd>
<dt><code>site_ref</code></dt><dd><p>String holding the name of the attribute that the user defined as
the one that identifies individual points and is contained inside the layer of points.</p>
</dd>
<dt><code>radii</code></dt><dd><p>Vector of numbers containing the radii that defined the creation of buffers.</p>
</dd>
<dt><code>n_layers</code></dt><dd><p>Number of raster layers (defined in argument <code>raster</code> in <code><a href="#topic+mland">mland()</a></code>) from which i
ntersections between were created (or will be if slot <code style="white-space: pre;">&#8288;@on_the_fly = TRUE&#8288;</code>).</p>
</dd>
<dt><code>n_classes</code></dt><dd><p>A numeric vector depicting the number of classes (raster values) per raster
layer (defined in argument <code>raster</code> in <code><a href="#topic+mland">mland()</a></code>).</p>
</dd>
<dt><code>classes</code></dt><dd><p>A data.frame depicting the classes (and classes names) for each rasterlayer
(defined in argument <code>raster</code> in <code><a href="#topic+mland">mland()</a></code>).</p>
</dd>
<dt><code>on_the_fly</code></dt><dd><p>A logical value indicating whether intersections between buffers and raster layers
were created (FALSE) or not (TRUE).</p>
</dd>
<dt><code>landscapes</code></dt><dd><p>If <code>on_the_fly = FALSE</code>, this slot holds the intersections between buffers and
raster layers. Otherwise, if <code>on_the_fly = TRUE</code>, it holds the raw raster layers.</p>
</dd>
<dt><code>l_ref</code></dt><dd><p>A data.frame relating each point and radius with a &quot;row_id&quot;, equal to the position of
its buffer in the slot <code style="white-space: pre;">&#8288;@buffers&#8288;</code> and to the position of the intersection for each point/radius in
the slot <code style="white-space: pre;">&#8288;@landscapes&#8288;</code> (if <code>on_the_fly = TRUE</code>).</p>
</dd>
<dt><code>rast_names</code></dt><dd><p>A list containing two data.frame with the names assigned by the user for the main raster layers
and extra raster layers defined in argument <code>rast_layer</code> and <code>ext_rast_layer</code> in <code><a href="#topic+mland">mland()</a></code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Shows information of object 'MultiLand'
ernesdesign &lt;- system.file("extdata", "ernesdesign.zip", package = "multilandr")
ernesdesign &lt;- mland_load(ernesdesign)
ernesdesign
</code></pre>

<hr>
<h2 id='MultiLandMetrics-class'>Class 'MultiLandMetrics'</h2><span id='topic+MultiLandMetrics-class'></span>

<h3>Description</h3>

<p>Objects of class <code>MultiLandMetrics</code> are returned by <code><a href="#topic+mland_metrics">mland_metrics()</a></code>. It holds all the information
relative to the metrics that were calculated by the parameters inputted by the user. This object
class can be passed to functions <code><a href="#topic+metrics_corr">metrics_corr()</a></code>, <code><a href="#topic+metrics_plots">metrics_plots()</a></code>, <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, <code><a href="#topic+metrics_gradient">metrics_gradient()</a></code> and
<code><a href="#topic+metrics_bind">metrics_bind()</a></code> for further analyses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>The call when function <code><a href="#topic+mland_metrics">mland_metrics()</a></code> was called.</p>
</dd>
<dt><code>idkey</code></dt><dd><p>A unique identification id for the 'MultiLandMetrics' object.</p>
</dd>
<dt><code>crs_proj</code></dt><dd><p>A string depicting the CRS of points layer.</p>
</dd>
<dt><code>n_layers</code></dt><dd><p>Number of raster layers from which metrics were calculated.</p>
</dd>
<dt><code>rast_names</code></dt><dd><p>A list with dataframes containing the names of the raster layers of the
'MultiLand' object the function <code><a href="#topic+mland_metrics">mland_metrics()</a></code> worked with.</p>
</dd>
<dt><code>classes</code></dt><dd><p>A data.frame depicting the raster layers, classes and classes names from which
metrics were calculated.</p>
</dd>
<dt><code>n_classes</code></dt><dd><p>Numeric vector depicting the number of distinct classes per raster layer
from which metrics were calculated.</p>
</dd>
<dt><code>points</code></dt><dd><p>A data.frame containing points coordinates and other attributes.</p>
</dd>
<dt><code>n_points</code></dt><dd><p>Number of points from which metrics were calculated.</p>
</dd>
<dt><code>site_names</code></dt><dd><p>Logical. Whether points have associated site names or not.</p>
</dd>
<dt><code>radii</code></dt><dd><p>Distinct radii from which metrics were calculated.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A data.frame depicting the metrics that were calculated, classified by level.</p>
</dd>
<dt><code>data</code></dt><dd><p>Main data.frame with the values of the metrics that were calculated for each
point, radius, raster layers and other parameters pre-defined by the user.</p>
</dd>
<dt><code>ext_calcs</code></dt><dd><p>A data.frame depicting the extra calculations that were made in given extra
raster layers.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Shows information of object 'MultiLandMetrics'
ed_metrics
otf_metrics
</code></pre>

<hr>
<h2 id='otf_metrics'>'MultiLandMetrics' object</h2><span id='topic+otf_metrics'></span>

<h3>Description</h3>

<p>An object of class 'MultiLandMetrics' generated with <code><a href="#topic+mland_metrics">mland_metrics()</a></code>, for the purposes of package
examples of the following functions: <code><a href="#topic+metrics_filter">metrics_filter()</a></code>, <code><a href="#topic+metrics_gradient">metrics_gradient()</a></code>,
<code><a href="#topic+metrics_corr">metrics_corr()</a></code>, <code><a href="#topic+metrics_plots">metrics_plots()</a></code> and <code><a href="#topic+metrics_bind">metrics_bind()</a></code>. See 'MultiLand-class' for general
information about these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otf_metrics
</code></pre>


<h3>Format</h3>

<p>An object of class <code>MultiLandMetrics</code> of length 1.
</p>


<h3>Details</h3>

<p>The main internal object is a data.frame (accesible through <code>otf_metrics@data</code>) with information about the values of two landscape metrics:
&quot;pland&quot; (percentage of landscape) and &quot;np&quot; (number of patches).
</p>
<p>The object was created from the MultiLand object named &quot;otf_design&quot;, which
received a raster layer from a small portion of the ecoregion &quot;El Chaco&quot; as main input.
The rasterlayer was provided by the project &quot;MapBiomas Chaco&quot; for the year 2000.
</p>


<h3>See Also</h3>

<p>See the examples sections of <code><a href="#topic+mland_metrics">mland_metrics()</a></code> and <code><a href="#topic+mland">mland()</a></code>
for more context.
</p>
<p>#' @references
Project MapBiomas Chaco â€“ Collection 4.0 of annual land cover and land use maps,
accessed during July 2022 through the following link: <a href="https://chaco.mapbiomas.org/">MapBiomas Chaco</a>
</p>

<hr>
<h2 id='show+2CMultiLand-method'>Show 'MultiLand' object</h2><span id='topic+show+2CMultiLand-method'></span>

<h3>Description</h3>

<p>Show 'MultiLand' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultiLand'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CMultiLand-method_+3A_object">object</code></td>
<td>
<p>Prints relevant information about a 'MultiLand' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='show+2CMultiLandMetrics-method'>Show 'MultiLandMetrics' object</h2><span id='topic+show+2CMultiLandMetrics-method'></span>

<h3>Description</h3>

<p>Show 'MultiLandMetrics' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultiLandMetrics'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CMultiLandMetrics-method_+3A_object">object</code></td>
<td>
<p>Prints relevant information about a 'MultiLandMetrics' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
