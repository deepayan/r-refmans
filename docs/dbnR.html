<!DOCTYPE html><html><head><title>Help for package dbnR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbnR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[[&lt;-.dbn.fit'><p>Replacement function for parameters inside DBNs</p></a></li>
<li><a href='#$&lt;-.dbn.fit'><p>Replacement function for parameters inside DBNs</p></a></li>
<li><a href='#acc_successions'><p>Returns a vector with the number of consecutive nodes in each level</p></a></li>
<li><a href='#add_attr_to_fit'><p>Adds the mu vector and sigma matrix as attributes to the bn.fit or dbn.fit object</p></a></li>
<li><a href='#AIC.dbn'><p>Calculate the AIC of a dynamic Bayesian network</p></a></li>
<li><a href='#AIC.dbn.fit'><p>Calculate the AIC of a dynamic Bayesian network</p></a></li>
<li><a href='#all.equal.dbn'><p>Check if two network structures are equal to each other</p></a></li>
<li><a href='#all.equal.dbn.fit'><p>Check if two fitted networks are equal to each other</p></a></li>
<li><a href='#approx_prediction_step'><p>Performs approximate inference in a time slice of the dbn</p></a></li>
<li><a href='#approximate_inference'><p>Performs approximate inference forecasting with the GDBN over a dataset</p></a></li>
<li><a href='#as_named_vector'><p>Converts a single row data.table into a named vector</p></a></li>
<li><a href='#as.character.dbn'><p>Convert a network structure into a model string</p></a></li>
<li><a href='#BIC.dbn'><p>Calculate the BIC of a dynamic Bayesian network</p></a></li>
<li><a href='#BIC.dbn.fit'><p>Calculate the BIC of a dynamic Bayesian network</p></a></li>
<li><a href='#bn_translate_exp'><p>Experimental function that translates a natPosition vector into a DBN network.</p></a></li>
<li><a href='#calc_mu'><p>Calculate the mu vector from a fitted BN or DBN</p></a></li>
<li><a href='#calc_mu_cpp'><p>Calculate the mu vector of means of a Gaussian linear network. This is</p>
the C++ backend of the function.</a></li>
<li><a href='#calc_sigma'><p>Calculate the sigma covariance matrix from a fitted BN or DBN</p></a></li>
<li><a href='#calc_sigma_cpp'><p>Calculate the sigma covariance matrix of a Gaussian linear network.</p>
This is the C++ backend of the function.</a></li>
<li><a href='#Causlist'><p>R6 class that defines causal lists in the PSO</p></a></li>
<li><a href='#check_time0_formatted'><p>Checks if the vector of names are time formatted to t_0</p></a></li>
<li><a href='#cl_to_arc_matrix_cpp'><p>Create a matrix with the arcs defined in a causlist object</p></a></li>
<li><a href='#coef.dbn.fit'><p>Extracts the coefficients of a DBN</p></a></li>
<li><a href='#create_blacklist'><p>Creates the blacklist of arcs from a folded data.table</p></a></li>
<li><a href='#create_causlist_cpp'><p>Create a causal list from a DBN. This is the C++ backend of the function.</p></a></li>
<li><a href='#create_natcauslist_cpp'><p>Create a natural causal list from a DBN. This is the C++ backend of the function.</p></a></li>
<li><a href='#crop_names_cpp'><p>If the names of the nodes have &quot;_t_0&quot; appended at the end, remove it</p></a></li>
<li><a href='#cte_times_vel_cpp'><p>Multiply a Velocity by a constant real number</p></a></li>
<li><a href='#degree'><p>Calculates the degree of a list of nodes</p></a></li>
<li><a href='#degree.bn'><p>Calculates the degree of a list of nodes</p></a></li>
<li><a href='#degree.bn.fit'><p>Calculates the degree of a list of nodes</p></a></li>
<li><a href='#degree.dbn'><p>Calculates the degree of a list of nodes</p></a></li>
<li><a href='#degree.dbn.fit'><p>Calculates the degree of a list of nodes</p></a></li>
<li><a href='#dmmhc'><p>Learns the structure of a markovian n DBN model from data</p></a></li>
<li><a href='#dynamic_ordering'><p>Gets the ordering of a single time slice in a DBN</p></a></li>
<li><a href='#exact_inference'><p>Performs exact inference forecasting with the GDBN over a dataset</p></a></li>
<li><a href='#exact_inference_backwards'><p>Performs exact inference smoothing with the GDBN over a dataset</p></a></li>
<li><a href='#exact_prediction_step'><p>Performs exact inference in a time slice of the dbn</p></a></li>
<li><a href='#expand_time_nodes'><p>Extends the names of the nodes in t_0 to t_(max-1)</p></a></li>
<li><a href='#filter_same_cycle'><p>Filter the instances in a data.table with different ids in each row</p></a></li>
<li><a href='#filtered_fold_dt'><p>Fold a dataset avoiding overlapping of different time series</p></a></li>
<li><a href='#fit_dbn_params'><p>Fits a markovian n DBN model</p></a></li>
<li><a href='#fitted.dbn.fit'><p>Extracts the fitted values of a DBN</p></a></li>
<li><a href='#fold_dt'><p>Widens the dataset to take into account the t previous time slices</p></a></li>
<li><a href='#fold_dt_rec'><p>Widens the dataset to take into account the t previous time slices</p></a></li>
<li><a href='#forecast_ts'><p>Performs forecasting with the GDBN over a dataset</p></a></li>
<li><a href='#generate_random_network_exp'><p>Generate a random DBN and a sampled dataset</p></a></li>
<li><a href='#init_cl_cpp'><p>Initialize the nodes vector</p></a></li>
<li><a href='#init_list_cpp'><p>Initialize the particles</p></a></li>
<li><a href='#initialize_cl_cpp'><p>Create a causality list and initialize it</p></a></li>
<li><a href='#learn_dbn_struc'><p>Learns the structure of a markovian n DBN model from data</p></a></li>
<li><a href='#logLik.dbn'><p>Calculate the log-likelihood of a dynamic Bayesian network</p></a></li>
<li><a href='#logLik.dbn.fit'><p>Calculate the log-likelihood of a dynamic Bayesian network</p></a></li>
<li><a href='#mean.dbn.fit'><p>Average the parameters of multiple dbn.fit objects with identical structures</p></a></li>
<li><a href='#merge_nets'><p>Merges and replicates the arcs in the static BN into all the time-slices</p>
in the DBN</a></li>
<li><a href='#motor'><p>Multivariate time series dataset on the temperature of an electric motor</p></a></li>
<li><a href='#mvn_inference'><p>Performs inference over a multivariate normal distribution</p></a></li>
<li><a href='#nat_cl_to_arc_matrix_cpp'><p>Create a matrix with the arcs defined in a causlist object</p></a></li>
<li><a href='#nat_cte_times_vel_cpp'><p>Multiply a Velocity by a constant real number</p></a></li>
<li><a href='#nat_pos_minus_pos_cpp'><p>Subtracts two natPositions to obtain the natVelocity that transforms ps1 into ps2</p></a></li>
<li><a href='#nat_pos_plus_vel_cpp'><p>Add a velocity to a position</p></a></li>
<li><a href='#nat_vel_plus_vel_cpp'><p>Adds two natVelocities</p></a></li>
<li><a href='#natCauslist'><p>R6 class that defines causal lists in the PSO</p></a></li>
<li><a href='#natParticle'><p>R6 class that defines a Particle in the PSO algorithm</p></a></li>
<li><a href='#natPosition'><p>R6 class that defines DBNs as vectors of natural numbers</p></a></li>
<li><a href='#natPsoCtrl'><p>R6 class that defines the PSO controller</p></a></li>
<li><a href='#natPsoho'><p>Learn a DBN structure with a PSO approach</p></a></li>
<li><a href='#natVelocity'><p>R6 class that defines velocities in the PSO</p></a></li>
<li><a href='#node_levels'><p>Defines a level for every node in the net</p></a></li>
<li><a href='#nodes'><p>Returns a list with the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes_gen_exp'><p>Generates the names of the nodes in t_0 and in all the network</p></a></li>
<li><a href='#nodes.bn'><p>Returns a list with the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes.bn.fit'><p>Returns a list with the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes.dbn'><p>Returns a list with the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes.dbn.fit'><p>Returns a list with the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes&lt;-'><p>Relabel the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes&lt;-.bn'><p>Relabel the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes&lt;-.bn.fit'><p>Relabel the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes&lt;-.dbn'><p>Relabel the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#nodes&lt;-.dbn.fit'><p>Relabel the names of the nodes of a BN or a DBN</p></a></li>
<li><a href='#one_hot'><p>One hot encoder for natural numbers without the 0.</p></a></li>
<li><a href='#one_hot_cpp'><p>One-hot encoder for natural numbers without the 0</p></a></li>
<li><a href='#ordering_gen_exp'><p>Generates the names of n variables.</p></a></li>
<li><a href='#Particle'><p>R6 class that defines a Particle in the PSO algorithm</p></a></li>
<li><a href='#plot_dynamic_network'><p>Plots a dynamic Bayesian network in a hierarchical way</p></a></li>
<li><a href='#plot_static_network'><p>Plots a Bayesian network in a hierarchical way</p></a></li>
<li><a href='#plot.dbn'><p>Plots a dynamic Bayesian network</p></a></li>
<li><a href='#plot.dbn.fit'><p>Plots a fitted dynamic Bayesian network</p></a></li>
<li><a href='#pos_minus_pos_cpp'><p>Subtracts two Positions to obtain the Velocity that transforms one into the other</p></a></li>
<li><a href='#pos_plus_vel_cpp'><p>Add a velocity to a position</p></a></li>
<li><a href='#Position'><p>R6 class that defines DBNs as causality lists</p></a></li>
<li><a href='#predict_bn'><p>Performs inference over a fitted GBN</p></a></li>
<li><a href='#predict_dt'><p>Performs inference over a test dataset with a GBN</p></a></li>
<li><a href='#predict.dbn.fit'><p>Performs inference in every row of a dataset with a DBN</p></a></li>
<li><a href='#print.dbn'><p>Print method for &quot;dbn&quot; objects</p></a></li>
<li><a href='#print.dbn.fit'><p>Print method for &quot;dbn.fit&quot; objects</p></a></li>
<li><a href='#PsoCtrl'><p>R6 class that defines the PSO controller</p></a></li>
<li><a href='#psoho'><p>Learn a DBN structure with a PSO approach</p></a></li>
<li><a href='#randomize_vl_cpp'><p>Randomize a velocity with the given probabilities</p></a></li>
<li><a href='#rbn.dbn.fit'><p>Simulates random samples from a fitted DBN</p></a></li>
<li><a href='#recount_arcs_exp'><p>Experimental function that recounts the number of arcs in the position</p></a></li>
<li><a href='#reduce_freq'><p>Reduce the frequency of the time series data in a data.table</p></a></li>
<li><a href='#rename_nodes_cpp'><p>Return a list of nodes with the time slice appended up to the desired size</p>
of the network</a></li>
<li><a href='#residuals.dbn.fit'><p>Returns the residuals from fitting a DBN</p></a></li>
<li><a href='#score'><p>Computes the score of a BN or a DBN</p></a></li>
<li><a href='#score.bn'><p>Computes the score of a BN or a DBN</p></a></li>
<li><a href='#score.dbn'><p>Computes the score of a BN or a DBN</p></a></li>
<li><a href='#shift_values'><p>Move the window of values backwards in a folded dataset row</p></a></li>
<li><a href='#sigma.dbn.fit'><p>Returns the standard deviation of the residuals from fitting a DBN</p></a></li>
<li><a href='#smooth_ts'><p>Performs smoothing with the GDBN over a dataset</p></a></li>
<li><a href='#time_rename'><p>Renames the columns in a data.table so that they end in '_t_0'</p></a></li>
<li><a href='#trunc_geom'><p>Geometric distribution sampler truncated to a maximum</p></a></li>
<li><a href='#vel_plus_vel_cpp'><p>Add two Velocities</p></a></li>
<li><a href='#Velocity'><p>R6 class that defines velocities affecting causality lists in the PSO</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Bayesian Network Learning and Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Learning and inference over dynamic Bayesian networks of arbitrary 
    Markovian order. Extends some of the functionality offered by the 'bnlearn' 
    package to learn the networks from data and perform exact inference. 
    It offers three structure learning algorithms for dynamic Bayesian networks:
    Trabelsi G. (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-41398-8_34">doi:10.1007/978-3-642-41398-8_34</a>&gt;, Santos F.P. and Maciel C.D. (2014)
    &lt;<a href="https://doi.org/10.1109%2FBRC.2014.6880957">doi:10.1109/BRC.2014.6880957</a>&gt;, Quesada D., Bielza C. and Larra√±aga P. (2021)
    &lt;<a href="https://doi.org/10.1007%2F978-3-030-86271-8_14">doi:10.1007/978-3-030-86271-8_14</a>&gt;. It also offers the possibility to perform 
    forecasts of arbitrary length. A tool for visualizing the structure of the 
    net is also provided via the 'visNetwork' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), bnlearn (&ge; 4.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.4), Rcpp (&ge; 1.0.2), magrittr (&ge; 1.5), R6
(&ge; 2.4.1), stats (&ge; 3.6.0), MASS (&ge; 7.3-55)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>visNetwork (&ge; 2.0.8), grDevices (&ge; 3.6.0), utils (&ge;
3.6.0), graphics (&ge; 3.6.0), testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dkesada/dbnR">https://github.com/dkesada/dbnR</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-03 12:59:23 UTC; Quesada</td>
</tr>
<tr>
<td>Author:</td>
<td>David Quesada [aut, cre],
  Gabriel Valverde [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Quesada &lt;dkesada@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-05 00:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+5B+26lt+3B-.dbn.fit'>Replacement function for parameters inside DBNs</h2><span id='topic++5B+5B+3C-.dbn.fit'></span>

<h3>Description</h3>

<p>Generic parameter replacement method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'dbn.fit'
x[[name]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-.dbn.fit_+3A_x">x</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-.dbn.fit_+3A_name">name</code></td>
<td>
<p>name of the node to replace its parameters</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-.dbn.fit_+3A_value">value</code></td>
<td>
<p>the new parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified network
</p>

<hr>
<h2 id='+24+26lt+3B-.dbn.fit'>Replacement function for parameters inside DBNs</h2><span id='topic++24+3C-.dbn.fit'></span>

<h3>Description</h3>

<p>Generic parameter replacement method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'dbn.fit'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24+2B26lt+2B3B-.dbn.fit_+3A_x">x</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-.dbn.fit_+3A_name">name</code></td>
<td>
<p>name of the node to replace its parameters</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-.dbn.fit_+3A_value">value</code></td>
<td>
<p>the new parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified network
</p>

<hr>
<h2 id='acc_successions'>Returns a vector with the number of consecutive nodes in each level</h2><span id='topic+acc_successions'></span>

<h3>Description</h3>

<p>This method processes the vector of node levels to get the position of
each node inside the level. E.g. c(1,1,1,2,2,3,4,4,5,5) turns into 
c(1,2,3,1,2,1,1,2,1,2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc_successions(nodes, res = NULL, prev = 0, acc = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acc_successions_+3A_nodes">nodes</code></td>
<td>
<p>a vector with the level of each node</p>
</td></tr>
<tr><td><code id="acc_successions_+3A_res">res</code></td>
<td>
<p>the accumulative results of the sub successions</p>
</td></tr>
<tr><td><code id="acc_successions_+3A_prev">prev</code></td>
<td>
<p>the level of the previous node processed</p>
</td></tr>
<tr><td><code id="acc_successions_+3A_acc">acc</code></td>
<td>
<p>the accumulator of the index in the current sub successions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of sub successions in each level
</p>

<hr>
<h2 id='add_attr_to_fit'>Adds the mu vector and sigma matrix as attributes to the bn.fit or dbn.fit object</h2><span id='topic+add_attr_to_fit'></span>

<h3>Description</h3>

<p>Adds the mu vector and sigma matrix as attributes to the bn.fit or dbn.fit 
object to allow performing exact MVN inference on both cases. It also adds
the number of time slices of the net for future inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attr_to_fit(fit, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_attr_to_fit_+3A_fit">fit</code></td>
<td>
<p>a fitted bn or dbn</p>
</td></tr>
<tr><td><code id="add_attr_to_fit_+3A_size">size</code></td>
<td>
<p>number of time slices of the net</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the fitted net with attributes
</p>

<hr>
<h2 id='AIC.dbn'>Calculate the AIC of a dynamic Bayesian network</h2><span id='topic+AIC.dbn'></span>

<h3>Description</h3>

<p>Generic method for calculating the Akaike information criterion (AIC) of a 
&quot;dbn&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+AIC">AIC</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
AIC(object, ..., k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.dbn_+3A_object">object</code></td>
<td>
<p>the structure of the network</p>
</td></tr>
<tr><td><code id="AIC.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
<tr><td><code id="AIC.dbn_+3A_k">k</code></td>
<td>
<p>the penalty parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the AIC score of the network
</p>

<hr>
<h2 id='AIC.dbn.fit'>Calculate the AIC of a dynamic Bayesian network</h2><span id='topic+AIC.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for calculating the Akaike information criterion (AIC) of a 
&quot;dbn.fit&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+AIC">AIC</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
AIC(object, ..., k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="AIC.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
<tr><td><code id="AIC.dbn.fit_+3A_k">k</code></td>
<td>
<p>the penalty parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the AIC score of the network
</p>

<hr>
<h2 id='all.equal.dbn'>Check if two network structures are equal to each other</h2><span id='topic+all.equal.dbn'></span>

<h3>Description</h3>

<p>Generic method for checking the equality of two
&quot;dbn&quot; S3 objects. Calls bnlearn's <code><a href="Matrix.html#topic+all.equal">all.equal</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equal.dbn'
all(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.dbn_+3A_target">target</code></td>
<td>
<p>&quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="all.equal.dbn_+3A_current">current</code></td>
<td>
<p>the other &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="all.equal.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean result of the comparison
</p>

<hr>
<h2 id='all.equal.dbn.fit'>Check if two fitted networks are equal to each other</h2><span id='topic+all.equal.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for checking the equality of two
&quot;dbn.fit&quot; S3 objects. Calls bnlearn's <code><a href="Matrix.html#topic+all.equal">all.equal</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equal.dbn.fit'
all(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.dbn.fit_+3A_target">target</code></td>
<td>
<p>&quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="all.equal.dbn.fit_+3A_current">current</code></td>
<td>
<p>the other &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="all.equal.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean result of the comparison
</p>

<hr>
<h2 id='approx_prediction_step'>Performs approximate inference in a time slice of the dbn</h2><span id='topic+approx_prediction_step'></span>

<h3>Description</h3>

<p>Given a bn.fit object and some variables, performs
particle inference over such variables in the net for a given time slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_prediction_step(fit, variables, particles, n = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_prediction_step_+3A_fit">fit</code></td>
<td>
<p>bn.fit object</p>
</td></tr>
<tr><td><code id="approx_prediction_step_+3A_variables">variables</code></td>
<td>
<p>variables to be predicted</p>
</td></tr>
<tr><td><code id="approx_prediction_step_+3A_particles">particles</code></td>
<td>
<p>a list with the provided evidence</p>
</td></tr>
<tr><td><code id="approx_prediction_step_+3A_n">n</code></td>
<td>
<p>the number of particles to be used by bnlearn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inferred particles
</p>

<hr>
<h2 id='approximate_inference'>Performs approximate inference forecasting with the GDBN over a dataset</h2><span id='topic+approximate_inference'></span>

<h3>Description</h3>

<p>Given a bn.fit object, the size of the net and a dataset,
performs approximate forecasting with bnlearns cpdist function over the 
initial evidence taken from the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximate_inference(dt, fit, obj_vars, ini, rep, len, num_p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximate_inference_+3A_dt">dt</code></td>
<td>
<p>data.table object with the TS data</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_fit">fit</code></td>
<td>
<p>bn.fit object</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_obj_vars">obj_vars</code></td>
<td>
<p>variables to be predicted</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_ini">ini</code></td>
<td>
<p>starting point in the dataset to forecast.</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_rep">rep</code></td>
<td>
<p>number of repetitions to be performed of the approximate inference</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_len">len</code></td>
<td>
<p>length of the forecast</p>
</td></tr>
<tr><td><code id="approximate_inference_+3A_num_p">num_p</code></td>
<td>
<p>number of particles to be used by bnlearn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the mu results of the forecast
</p>

<hr>
<h2 id='as_named_vector'>Converts a single row data.table into a named vector</h2><span id='topic+as_named_vector'></span>

<h3>Description</h3>

<p>Given a single row data.table, convert it into a named vector. Used in the
mvn_inference, to obtain an evidence named vector. For this case, the 
data.table should contain only the evidence that we want to provide. If a
named vector is provided instead of a data.table, nothing will be done and
the named vector will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_named_vector(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_named_vector_+3A_dt">dt</code></td>
<td>
<p>a 1 row data.table or a named vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with the values and the variable names
</p>

<hr>
<h2 id='as.character.dbn'>Convert a network structure into a model string</h2><span id='topic+as.character.dbn'></span>

<h3>Description</h3>

<p>Generic method for converting a &quot;dbn&quot; S3 object into a string.
Calls bnlearn's <code><a href="base.html#topic+as.character">as.character</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.dbn_+3A_x">x</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="as.character.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string representing the DBN model
</p>

<hr>
<h2 id='BIC.dbn'>Calculate the BIC of a dynamic Bayesian network</h2><span id='topic+BIC.dbn'></span>

<h3>Description</h3>

<p>Generic method for calculating the Bayesian information criterion (BIC) of a 
&quot;dbn&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+BIC">BIC</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.dbn_+3A_object">object</code></td>
<td>
<p>the structure of the network</p>
</td></tr>
<tr><td><code id="BIC.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the BIC score of the network
</p>

<hr>
<h2 id='BIC.dbn.fit'>Calculate the BIC of a dynamic Bayesian network</h2><span id='topic+BIC.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for calculating the Bayesian information criterion (BIC) of a 
&quot;dbn.fit&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+BIC">BIC</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="BIC.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the BIC score of the network
</p>

<hr>
<h2 id='bn_translate_exp'>Experimental function that translates a natPosition vector into a DBN network.</h2><span id='topic+bn_translate_exp'></span>

<h3>Description</h3>

<p>Experimental function that translates a natPosition vector into a DBN network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn_translate_exp(ps, ordering_raw, n_arcs, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn_translate_exp_+3A_ps">ps</code></td>
<td>
<p>a position vector of natural numbers</p>
</td></tr>
<tr><td><code id="bn_translate_exp_+3A_ordering_raw">ordering_raw</code></td>
<td>
<p>the ordering of the variables</p>
</td></tr>
<tr><td><code id="bn_translate_exp_+3A_n_arcs">n_arcs</code></td>
<td>
<p>the total number of arcs</p>
</td></tr>
<tr><td><code id="bn_translate_exp_+3A_nodes">nodes</code></td>
<td>
<p>the name of all the nodes in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bn object
</p>

<hr>
<h2 id='calc_mu'>Calculate the mu vector from a fitted BN or DBN</h2><span id='topic+calc_mu'></span>

<h3>Description</h3>

<p>Given a &quot;bn.fit&quot; or a &quot;dbn.fit&quot; object, calculate the mu vector of 
the equivalent multivariate Gaussian distribution. 
Front end of a C++ function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mu_+3A_fit">fit</code></td>
<td>
<p>a bn.fit or dbn.fit object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector of the means of each variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt_train &lt;- dbnR::motor[200:2500]
net &lt;- bnlearn::mmhc(dt_train)
fit &lt;- bnlearn::bn.fit(net, dt_train, method = "mle-g")
mu &lt;- dbnR::calc_mu(fit)

f_dt_train &lt;- dbnR::fold_dt(dt_train, size = 2)
net &lt;- dbnR::learn_dbn_struc(dt_train, size = 2)
fit &lt;- dbnR::fit_dbn_params(net, f_dt_train)
mu &lt;- dbnR::calc_mu(fit)
</code></pre>

<hr>
<h2 id='calc_mu_cpp'>Calculate the mu vector of means of a Gaussian linear network. This is 
the C++ backend of the function.</h2><span id='topic+calc_mu_cpp'></span>

<h3>Description</h3>

<p>Calculate the mu vector of means of a Gaussian linear network. This is 
the C++ backend of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu_cpp(fit, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mu_cpp_+3A_fit">fit</code></td>
<td>
<p>a bn.fit object as a Rcpp::List</p>
</td></tr>
<tr><td><code id="calc_mu_cpp_+3A_order">order</code></td>
<td>
<p>a topological ordering of the nodes as a vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the map with the nodes and their mu. Returns as a named numeric vector
</p>

<hr>
<h2 id='calc_sigma'>Calculate the sigma covariance matrix from a fitted BN or DBN</h2><span id='topic+calc_sigma'></span>

<h3>Description</h3>

<p>Given a &quot;bn.fit&quot; or a &quot;dbn.fit&quot; object, calculate the sigma covariance 
matrix of the equivalent multivariate Gaussian distribution. 
Front end of a C++ function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sigma(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sigma_+3A_fit">fit</code></td>
<td>
<p>a bn.fit or dbn.fit object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric covariance matrix of the nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt_train &lt;- dbnR::motor[200:2500]
net &lt;- bnlearn::mmhc(dt_train)
fit &lt;- bnlearn::bn.fit(net, dt_train, method = "mle-g")
sigma &lt;- dbnR::calc_sigma(fit)

f_dt_train &lt;- dbnR::fold_dt(dt_train, size = 2)
net &lt;- dbnR::learn_dbn_struc(dt_train, size = 2)
fit &lt;- dbnR::fit_dbn_params(net, f_dt_train)
sigma &lt;- dbnR::calc_sigma(fit)
</code></pre>

<hr>
<h2 id='calc_sigma_cpp'>Calculate the sigma covariance matrix of a Gaussian linear network. 
This is the C++ backend of the function.</h2><span id='topic+calc_sigma_cpp'></span>

<h3>Description</h3>

<p>Calculate the sigma covariance matrix of a Gaussian linear network. 
This is the C++ backend of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sigma_cpp(fit, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sigma_cpp_+3A_fit">fit</code></td>
<td>
<p>a bn.fit object as a Rcpp::List</p>
</td></tr>
<tr><td><code id="calc_sigma_cpp_+3A_order">order</code></td>
<td>
<p>a topological ordering of the nodes as a vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the covariance matrix
</p>

<hr>
<h2 id='Causlist'>R6 class that defines causal lists in the PSO</h2><span id='topic+Causlist'></span>

<h3>Description</h3>

<p>Constructor of the 'Causlist' class
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Causlist_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="Causlist_+3A_size">size</code></td>
<td>
<p>number of timeslices of the DBN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The causal lists will be the base of the positions and the velocities
in the pso part of the algorithm.
</p>


<h3>Value</h3>

<p>A new 'causlist' object
</p>


<h3>Fields</h3>


<dl>
<dt><code>cl</code></dt><dd><p>List of causal units</p>
</dd>
<dt><code>size</code></dt><dd><p>Size of the DBN</p>
</dd>
<dt><code>ordering</code></dt><dd><p>String vector defining the order of the nodes in a timeslice</p>
</dd>
</dl>

<hr>
<h2 id='check_time0_formatted'>Checks if the vector of names are time formatted to t_0</h2><span id='topic+check_time0_formatted'></span>

<h3>Description</h3>

<p>This will check if the names are properly time formatted in t_0
to be folded into more time slices. A vector is well formatted
in t_0 when all of its column names end in '_t_0'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_time0_formatted(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_time0_formatted_+3A_obj">obj</code></td>
<td>
<p>the vector of names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if it is well formatted. FALSE in other case.
</p>

<hr>
<h2 id='cl_to_arc_matrix_cpp'>Create a matrix with the arcs defined in a causlist object</h2><span id='topic+cl_to_arc_matrix_cpp'></span>

<h3>Description</h3>

<p>Create a matrix with the arcs defined in a causlist object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_to_arc_matrix_cpp(cl, ordering, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_to_arc_matrix_cpp_+3A_cl">cl</code></td>
<td>
<p>a causal list</p>
</td></tr>
<tr><td><code id="cl_to_arc_matrix_cpp_+3A_ordering">ordering</code></td>
<td>
<p>a list with the order of the variables in t_0</p>
</td></tr>
<tr><td><code id="cl_to_arc_matrix_cpp_+3A_rows">rows</code></td>
<td>
<p>number of arcs in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a CharacterVector and a NumericVector
</p>

<hr>
<h2 id='coef.dbn.fit'>Extracts the coefficients of a DBN</h2><span id='topic+coef.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="coef.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coefficients of the network
</p>

<hr>
<h2 id='create_blacklist'>Creates the blacklist of arcs from a folded data.table</h2><span id='topic+create_blacklist'></span>

<h3>Description</h3>

<p>This will create the blacklist of arcs that are not
to be learned in the second phase of the dmmhc. This includes arcs
backwards in time or inside time-slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_blacklist(name, size, acc = NULL, slice = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_blacklist_+3A_name">name</code></td>
<td>
<p>the names of the first time slice, ended in _t_0</p>
</td></tr>
<tr><td><code id="create_blacklist_+3A_size">size</code></td>
<td>
<p>the number of time slices of the net. Markovian 1 would be size 2</p>
</td></tr>
<tr><td><code id="create_blacklist_+3A_acc">acc</code></td>
<td>
<p>accumulator of the results in the recursion</p>
</td></tr>
<tr><td><code id="create_blacklist_+3A_slice">slice</code></td>
<td>
<p>current time slice that is being processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the two column matrix with the blacklisted arcs
</p>

<hr>
<h2 id='create_causlist_cpp'>Create a causal list from a DBN. This is the C++ backend of the function.</h2><span id='topic+create_causlist_cpp'></span>

<h3>Description</h3>

<p>Create a causal list from a DBN. This is the C++ backend of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_causlist_cpp(cl, net, size, ordering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_causlist_cpp_+3A_cl">cl</code></td>
<td>
<p>an initialized causality list</p>
</td></tr>
<tr><td><code id="create_causlist_cpp_+3A_net">net</code></td>
<td>
<p>a dbn object treated as a list of lists</p>
</td></tr>
<tr><td><code id="create_causlist_cpp_+3A_size">size</code></td>
<td>
<p>the size of the DBN</p>
</td></tr>
<tr><td><code id="create_causlist_cpp_+3A_ordering">ordering</code></td>
<td>
<p>a list with the order of the variables in t_0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a CharacterVector and a NumericVector
</p>

<hr>
<h2 id='create_natcauslist_cpp'>Create a natural causal list from a DBN. This is the C++ backend of the function.</h2><span id='topic+create_natcauslist_cpp'></span>

<h3>Description</h3>

<p>Create a natural causal list from a DBN. This is the C++ backend of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_natcauslist_cpp(cl, net, ordering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_natcauslist_cpp_+3A_cl">cl</code></td>
<td>
<p>an initialized causality list</p>
</td></tr>
<tr><td><code id="create_natcauslist_cpp_+3A_net">net</code></td>
<td>
<p>a dbn object treated as a list of lists</p>
</td></tr>
<tr><td><code id="create_natcauslist_cpp_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the variables in order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the natCauslist equivalent to the DBN
</p>

<hr>
<h2 id='crop_names_cpp'>If the names of the nodes have &quot;_t_0&quot; appended at the end, remove it</h2><span id='topic+crop_names_cpp'></span>

<h3>Description</h3>

<p>If the names of the nodes have &quot;_t_0&quot; appended at the end, remove it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_names_cpp(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_names_cpp_+3A_names">names</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector with the names cropped
</p>

<hr>
<h2 id='cte_times_vel_cpp'>Multiply a Velocity by a constant real number</h2><span id='topic+cte_times_vel_cpp'></span>

<h3>Description</h3>

<p>Multiply a Velocity by a constant real number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cte_times_vel_cpp(k, vl, abs_op, max_op)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cte_times_vel_cpp_+3A_k">k</code></td>
<td>
<p>the constant real number</p>
</td></tr>
<tr><td><code id="cte_times_vel_cpp_+3A_vl">vl</code></td>
<td>
<p>the Velocity's causal list</p>
</td></tr>
<tr><td><code id="cte_times_vel_cpp_+3A_abs_op">abs_op</code></td>
<td>
<p>the final number of 1,-1 operations</p>
</td></tr>
<tr><td><code id="cte_times_vel_cpp_+3A_max_op">max_op</code></td>
<td>
<p>the maximum number of directions in the causal list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the Velocity's new causal list and number of operations
</p>

<hr>
<h2 id='degree'>Calculates the degree of a list of nodes</h2><span id='topic+degree'></span>

<h3>Description</h3>

<p>#' Generic method for calculating the degree of a list of nodes in a
BN or a DBN. Calls bnlearn's <code><a href="#topic+degree">degree</a></code> underneath. 
I have to redefine the generic and mask the original for it to work on both 
bn and dbn objects without the user having to import bnlearn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(object, Nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot;, &quot;dbn&quot;, &quot;bn.fit&quot; or &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="degree_+3A_nodes">Nodes</code></td>
<td>
<p>which nodes to check</p>
</td></tr>
<tr><td><code id="degree_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the degree of the nodes
</p>

<hr>
<h2 id='degree.bn'>Calculates the degree of a list of nodes</h2><span id='topic+degree.bn'></span>

<h3>Description</h3>

<p>Generic method for calculating the degree of a list of nodes in a
&quot;bn&quot; S3 object. Calls bnlearn's <code><a href="#topic+degree">degree</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bn'
degree(object, Nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.bn_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="degree.bn_+3A_nodes">Nodes</code></td>
<td>
<p>which nodes to check</p>
</td></tr>
<tr><td><code id="degree.bn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the degree of the nodes
</p>

<hr>
<h2 id='degree.bn.fit'>Calculates the degree of a list of nodes</h2><span id='topic+degree.bn.fit'></span>

<h3>Description</h3>

<p>#' Generic method for calculating the degree of a list of nodes in a
&quot;bn.fit&quot; S3 object. Calls bnlearn's <code><a href="#topic+degree">degree</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bn.fit'
degree(object, Nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.bn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="degree.bn.fit_+3A_nodes">Nodes</code></td>
<td>
<p>which nodes to check</p>
</td></tr>
<tr><td><code id="degree.bn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the degree of the nodes
</p>

<hr>
<h2 id='degree.dbn'>Calculates the degree of a list of nodes</h2><span id='topic+degree.dbn'></span>

<h3>Description</h3>

<p>Generic method for calculating the degree of a list of nodes in a
&quot;dbn&quot; S3 object. Calls bnlearn's <code><a href="#topic+degree">degree</a></code> underneath.
The degree function is specifically coded to look for either the &quot;bn&quot;
or the &quot;bn.fit&quot; method inside bnlearn, so I have to cast the &quot;dbn&quot; class
into &quot;bn&quot; for it to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
degree(object, Nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.dbn_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="degree.dbn_+3A_nodes">Nodes</code></td>
<td>
<p>which nodes to check</p>
</td></tr>
<tr><td><code id="degree.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the degree of the nodes
</p>

<hr>
<h2 id='degree.dbn.fit'>Calculates the degree of a list of nodes</h2><span id='topic+degree.dbn.fit'></span>

<h3>Description</h3>

<p>#' Generic method for calculating the degree of a list of nodes in a
&quot;dbn.fit&quot; S3 object. Calls bnlearn's <code><a href="#topic+degree">degree</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
degree(object, Nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.dbn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="degree.dbn.fit_+3A_nodes">Nodes</code></td>
<td>
<p>which nodes to check</p>
</td></tr>
<tr><td><code id="degree.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the degree of the nodes
</p>

<hr>
<h2 id='dmmhc'>Learns the structure of a markovian n DBN model from data</h2><span id='topic+dmmhc'></span>

<h3>Description</h3>

<p>Learns a gaussian dynamic Bayesian network from a
dataset. It allows the creation of markovian n nets rather than only markov
1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmmhc(
  dt,
  size = 2,
  f_dt = NULL,
  blacklist = NULL,
  intra = TRUE,
  blacklist_tr = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmmhc_+3A_dt">dt</code></td>
<td>
<p>the data.frame or data.table to be used</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_size">size</code></td>
<td>
<p>number of time slices of the net. Markovian 1 would be size 2</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_f_dt">f_dt</code></td>
<td>
<p>previously folded dataset, in case some specific rows have to be removed after the folding</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_blacklist">blacklist</code></td>
<td>
<p>an optional matrix indicating forbidden arcs between nodes</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_intra">intra</code></td>
<td>
<p>if TRUE, the intra-slice arcs of the network will be learnt. If FALSE, they will be ignored</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_blacklist_tr">blacklist_tr</code></td>
<td>
<p>an optional matrix indicating forbidden intra-slice arcs between nodes</p>
</td></tr>
<tr><td><code id="dmmhc_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="bnlearn.html#topic+rsmax2">rsmax2</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the structure of the net
</p>

<hr>
<h2 id='dynamic_ordering'>Gets the ordering of a single time slice in a DBN</h2><span id='topic+dynamic_ordering'></span>

<h3>Description</h3>

<p>This method gets the structure of a DBN, isolates the nodes of a single
time slice and then gives a topological ordering of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamic_ordering(structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_ordering_+3A_structure">structure</code></td>
<td>
<p>the structure of the network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ordered nodes of t_0
</p>

<hr>
<h2 id='exact_inference'>Performs exact inference forecasting with the GDBN over a dataset</h2><span id='topic+exact_inference'></span>

<h3>Description</h3>

<p>Given a bn.fit object, the size of the net and a data.set,
performs exact forecasting over the initial evidence taken from the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_inference(dt, fit, obj_vars, ini, len, prov_ev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_inference_+3A_dt">dt</code></td>
<td>
<p>data.table object with the TS data</p>
</td></tr>
<tr><td><code id="exact_inference_+3A_fit">fit</code></td>
<td>
<p>bn.fit object</p>
</td></tr>
<tr><td><code id="exact_inference_+3A_obj_vars">obj_vars</code></td>
<td>
<p>variables to be predicted</p>
</td></tr>
<tr><td><code id="exact_inference_+3A_ini">ini</code></td>
<td>
<p>starting point in the dataset to forecast.</p>
</td></tr>
<tr><td><code id="exact_inference_+3A_len">len</code></td>
<td>
<p>length of the forecast</p>
</td></tr>
<tr><td><code id="exact_inference_+3A_prov_ev">prov_ev</code></td>
<td>
<p>variables to be provided as evidence in each forecasting step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the mu results of the forecast
</p>

<hr>
<h2 id='exact_inference_backwards'>Performs exact inference smoothing with the GDBN over a dataset</h2><span id='topic+exact_inference_backwards'></span>

<h3>Description</h3>

<p>Given a bn.fit object, the size of the net and a dataset,
performs exact smoothing over the initial evidence taken from the dataset.
Take notice that the smoothing is done backwards in time, as opposed to
forecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_inference_backwards(dt, fit, obj_vars, ini, len, prov_ev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_inference_backwards_+3A_dt">dt</code></td>
<td>
<p>data.table object with the TS data</p>
</td></tr>
<tr><td><code id="exact_inference_backwards_+3A_fit">fit</code></td>
<td>
<p>bn.fit object</p>
</td></tr>
<tr><td><code id="exact_inference_backwards_+3A_obj_vars">obj_vars</code></td>
<td>
<p>variables to be predicted. Should be in the oldest time step</p>
</td></tr>
<tr><td><code id="exact_inference_backwards_+3A_ini">ini</code></td>
<td>
<p>starting point in the dataset to smooth</p>
</td></tr>
<tr><td><code id="exact_inference_backwards_+3A_len">len</code></td>
<td>
<p>length of the smoothing</p>
</td></tr>
<tr><td><code id="exact_inference_backwards_+3A_prov_ev">prov_ev</code></td>
<td>
<p>variables to be provided as evidence in each forecasting step. Should be in the oldest time step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the inference backwards
</p>

<hr>
<h2 id='exact_prediction_step'>Performs exact inference in a time slice of the dbn</h2><span id='topic+exact_prediction_step'></span>

<h3>Description</h3>

<p>Given a bn.fit object and some variables, performs
exact MVN inference over such variables in the net for a given time slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_prediction_step(fit, variables, evidence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_prediction_step_+3A_fit">fit</code></td>
<td>
<p>list with the mu and sigma of the MVN model</p>
</td></tr>
<tr><td><code id="exact_prediction_step_+3A_variables">variables</code></td>
<td>
<p>variables to be predicted</p>
</td></tr>
<tr><td><code id="exact_prediction_step_+3A_evidence">evidence</code></td>
<td>
<p>a list with the provided evidence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the predicted mu and sigma
</p>

<hr>
<h2 id='expand_time_nodes'>Extends the names of the nodes in t_0 to t_(max-1)</h2><span id='topic+expand_time_nodes'></span>

<h3>Description</h3>

<p>This method extends the names of the nodes to the given maximum and
maintains the order of the nodes in each slice, so as to plotting
the nodes in all slices relative to their homonyms in the first slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_time_nodes(name, acc, max, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_time_nodes_+3A_name">name</code></td>
<td>
<p>the names of the nodes in the t_0 slice</p>
</td></tr>
<tr><td><code id="expand_time_nodes_+3A_acc">acc</code></td>
<td>
<p>accumulator of the resulting names in the recursion</p>
</td></tr>
<tr><td><code id="expand_time_nodes_+3A_max">max</code></td>
<td>
<p>number of time slices in the net</p>
</td></tr>
<tr><td><code id="expand_time_nodes_+3A_i">i</code></td>
<td>
<p>current slice being processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the extended names
</p>

<hr>
<h2 id='filter_same_cycle'>Filter the instances in a data.table with different ids in each row</h2><span id='topic+filter_same_cycle'></span>

<h3>Description</h3>

<p>Given an id variable that labels the different instances of a time series
inside a dataset, discard the rows that have values from more than 1 id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_same_cycle(f_dt, size, id_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_same_cycle_+3A_f_dt">f_dt</code></td>
<td>
<p>folded data.table</p>
</td></tr>
<tr><td><code id="filter_same_cycle_+3A_size">size</code></td>
<td>
<p>the size of the data.table</p>
</td></tr>
<tr><td><code id="filter_same_cycle_+3A_id_var">id_var</code></td>
<td>
<p>the variable that labels each individual instance of the time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- dbnR::motor[201:2500]
dt[, n_sec := rep(seq(46), each = 50)] # I'll create secuences of 50 instances each
f_dt &lt;- dbnR::fold_dt(dt, size = 2)
f_dt[50, .SD, .SDcols = c("n_sec_t_0", "n_sec_t_1")]
f_dt &lt;- dbnR::filter_same_cycle(f_dt, size = 2, id_var = "n_sec")
f_dt[50, .SD, .SDcols = c("n_sec_t_0", "n_sec_t_1")]
</code></pre>

<hr>
<h2 id='filtered_fold_dt'>Fold a dataset avoiding overlapping of different time series</h2><span id='topic+filtered_fold_dt'></span>

<h3>Description</h3>

<p>If the dataset that is going to be folded contains several different time series 
instances of the same process, folding it could introduce false rows with data
from different time series. Given an id variable that labels the different 
instances of a time series inside a dataset and a desired size, this function 
folds the dataset and avoids mixing data from different origins in the same instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtered_fold_dt(dt, size, id_var, clear_id_var = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtered_fold_dt_+3A_dt">dt</code></td>
<td>
<p>data.table to be folded</p>
</td></tr>
<tr><td><code id="filtered_fold_dt_+3A_size">size</code></td>
<td>
<p>the size of the data.table</p>
</td></tr>
<tr><td><code id="filtered_fold_dt_+3A_id_var">id_var</code></td>
<td>
<p>the variable that labels each individual instance of the time series</p>
</td></tr>
<tr><td><code id="filtered_fold_dt_+3A_clear_id_var">clear_id_var</code></td>
<td>
<p>boolean that decides whether or not the id_var column is deleted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- dbnR::motor[201:2500]
dt[, n_sec := rep(seq(46), each = 50)] # I'll create secuences of 50 instances each
f_dt &lt;- dbnR::fold_dt(dt, size = 2)
dim(f_dt)
f_dt &lt;- dbnR::filtered_fold_dt(dt, size = 2, id_var = "n_sec")
dim(f_dt)  # The filtered folded dt has a row less for each independent secuence
</code></pre>

<hr>
<h2 id='fit_dbn_params'>Fits a markovian n DBN model</h2><span id='topic+fit_dbn_params'></span>

<h3>Description</h3>

<p>Fits the parameters of the DBN via MLE. The &quot;mu&quot; vector of means 
and the &quot;sigma&quot; covariance matrix are set as attributes of the dbn.fit 
object for future exact inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_dbn_params(net, f_dt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_dbn_params_+3A_net">net</code></td>
<td>
<p>the structure of the DBN</p>
</td></tr>
<tr><td><code id="fit_dbn_params_+3A_f_dt">f_dt</code></td>
<td>
<p>a folded data.table</p>
</td></tr>
<tr><td><code id="fit_dbn_params_+3A_...">...</code></td>
<td>
<p>additional parameters for the <code><a href="bnlearn.html#topic+bn.fit">bn.fit</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;dbn.fit&quot; S3 object with the fitted net
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
dt_train &lt;- dbnR::motor[200:2500]
net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")
</code></pre>

<hr>
<h2 id='fitted.dbn.fit'>Extracts the fitted values of a DBN</h2><span id='topic+fitted.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="fitted.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the fitted values of the network
</p>

<hr>
<h2 id='fold_dt'>Widens the dataset to take into account the t previous time slices</h2><span id='topic+fold_dt'></span>

<h3>Description</h3>

<p>This function will widen the dataset to put the t previous time slices
in each row, so that it can be used to learn temporal arcs in the second
phase of the dmmhc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold_dt(dt, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_dt_+3A_dt">dt</code></td>
<td>
<p>the data.table to be treated</p>
</td></tr>
<tr><td><code id="fold_dt_+3A_size">size</code></td>
<td>
<p>number of time slices to unroll. Markovian 1 would be size 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the extended data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(motor)
size &lt;-  3
f_dt &lt;- fold_dt(motor, size)
</code></pre>

<hr>
<h2 id='fold_dt_rec'>Widens the dataset to take into account the t previous time slices</h2><span id='topic+fold_dt_rec'></span>

<h3>Description</h3>

<p>This will widen the dataset to put the t previous time slices
in each row, so that it can be used to learn temporal arcs in the second
phase of the dmmhc. Recursive version not exported, the user calls from the
handler 'fold_dt'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold_dt_rec(dt, n_prev, size, slice = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_dt_rec_+3A_dt">dt</code></td>
<td>
<p>the data.table to be treated</p>
</td></tr>
<tr><td><code id="fold_dt_rec_+3A_n_prev">n_prev</code></td>
<td>
<p>names of the previous time slice</p>
</td></tr>
<tr><td><code id="fold_dt_rec_+3A_size">size</code></td>
<td>
<p>number of time slices to unroll. Markovian 1 would be size 2</p>
</td></tr>
<tr><td><code id="fold_dt_rec_+3A_slice">slice</code></td>
<td>
<p>the current time slice being treated. Should not be modified
when first calling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the extended data.table
</p>

<hr>
<h2 id='forecast_ts'>Performs forecasting with the GDBN over a dataset</h2><span id='topic+forecast_ts'></span>

<h3>Description</h3>

<p>Given a dbn.fit object, the size of the net and a folded dataset,
performs a forecast over the initial evidence taken from the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_ts(
  dt,
  fit,
  size = NULL,
  obj_vars,
  ini = 1,
  len = dim(dt)[1] - ini,
  rep = 1,
  num_p = 50,
  print_res = TRUE,
  plot_res = TRUE,
  mode = "exact",
  prov_ev = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_ts_+3A_dt">dt</code></td>
<td>
<p>data.table object with the TS data</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_fit">fit</code></td>
<td>
<p>dbn.fit object</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_size">size</code></td>
<td>
<p>number of time slices of the net. Deprecated, will be removed in the future</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_obj_vars">obj_vars</code></td>
<td>
<p>variables to be predicted</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_ini">ini</code></td>
<td>
<p>starting point in the dataset to forecast.</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_len">len</code></td>
<td>
<p>length of the forecast</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_rep">rep</code></td>
<td>
<p>number of times to repeat the approximate forecasting</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_num_p">num_p</code></td>
<td>
<p>number of particles in the approximate forecasting</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_print_res">print_res</code></td>
<td>
<p>if TRUE prints the mae and sd metrics of the forecast</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_plot_res">plot_res</code></td>
<td>
<p>if TRUE plots the results of the forecast</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_mode">mode</code></td>
<td>
<p>&quot;exact&quot; for exact inference, &quot;approx&quot; for approximate</p>
</td></tr>
<tr><td><code id="forecast_ts_+3A_prov_ev">prov_ev</code></td>
<td>
<p>variables to be provided as evidence in each forecasting step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the original time series values and the results of the forecast
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
data(motor)
dt_train &lt;- motor[200:900]
dt_val &lt;- motor[901:1000]
obj &lt;- c("pm_t_0")
net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
f_dt_val &lt;- fold_dt(dt_val, size)
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")
res &lt;- suppressWarnings(forecast_ts(f_dt_val, fit, 
        obj_vars = obj, len = 10, print_res = FALSE, plot_res = FALSE))
</code></pre>

<hr>
<h2 id='generate_random_network_exp'>Generate a random DBN and a sampled dataset</h2><span id='topic+generate_random_network_exp'></span>

<h3>Description</h3>

<p>This function generates both a random DBN and a dataset that can be used to 
learn its structure from data. It's intended for experimental use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_network_exp(
  n_vars,
  size,
  min_mu,
  max_mu,
  min_sd,
  max_sd,
  min_coef,
  max_coef,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_network_exp_+3A_n_vars">n_vars</code></td>
<td>
<p>number of desired variables per time-slice</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_size">size</code></td>
<td>
<p>desired size of the networks</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_min_mu">min_mu</code></td>
<td>
<p>minimum mean allowed for the variables</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_max_mu">max_mu</code></td>
<td>
<p>maximum mean allowed for the variables</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_min_sd">min_sd</code></td>
<td>
<p>minimum standard deviation allowed for the variables</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_max_sd">max_sd</code></td>
<td>
<p>maximum standard deviation allowed for the variables</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_min_coef">min_coef</code></td>
<td>
<p>minimum coefficient allowed for the parent nodes</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_max_coef">max_coef</code></td>
<td>
<p>maximum coefficient allowed for the parent nodes</p>
</td></tr>
<tr><td><code id="generate_random_network_exp_+3A_seed">seed</code></td>
<td>
<p>the seed of the experiment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the original network structure and the sampled dataset
</p>

<hr>
<h2 id='init_cl_cpp'>Initialize the nodes vector</h2><span id='topic+init_cl_cpp'></span>

<h3>Description</h3>

<p>Initialize the vector in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_cl_cpp(n_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_cl_cpp_+3A_n_nodes">n_nodes</code></td>
<td>
<p>number of receiving nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the randomly initialized particles
</p>

<hr>
<h2 id='init_list_cpp'>Initialize the particles</h2><span id='topic+init_list_cpp'></span>

<h3>Description</h3>

<p>Initialize the particles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_list_cpp(nodes, size, n_inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_list_cpp_+3A_nodes">nodes</code></td>
<td>
<p>the names of the nodes</p>
</td></tr>
<tr><td><code id="init_list_cpp_+3A_size">size</code></td>
<td>
<p>the size of the DBN</p>
</td></tr>
<tr><td><code id="init_list_cpp_+3A_n_inds">n_inds</code></td>
<td>
<p>the number of particles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the randomly initialized particles
</p>

<hr>
<h2 id='initialize_cl_cpp'>Create a causality list and initialize it</h2><span id='topic+initialize_cl_cpp'></span>

<h3>Description</h3>

<p>Create a causality list and initialize it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_cl_cpp(ordering, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_cl_cpp_+3A_ordering">ordering</code></td>
<td>
<p>a list with the order of the variables in t_0</p>
</td></tr>
<tr><td><code id="initialize_cl_cpp_+3A_size">size</code></td>
<td>
<p>the size of the DBN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a causality list
</p>

<hr>
<h2 id='learn_dbn_struc'>Learns the structure of a markovian n DBN model from data</h2><span id='topic+learn_dbn_struc'></span>

<h3>Description</h3>

<p>Learns a gaussian dynamic Bayesian network from a dataset. 
It allows the creation of markovian n nets rather than only markov 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn_dbn_struc(dt, size = 2, method = "dmmhc", f_dt = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_dbn_struc_+3A_dt">dt</code></td>
<td>
<p>the data.frame or data.table to be used</p>
</td></tr>
<tr><td><code id="learn_dbn_struc_+3A_size">size</code></td>
<td>
<p>number of time slices of the net. Markovian 1 would be size 2</p>
</td></tr>
<tr><td><code id="learn_dbn_struc_+3A_method">method</code></td>
<td>
<p>the structure learning method of choice to use</p>
</td></tr>
<tr><td><code id="learn_dbn_struc_+3A_f_dt">f_dt</code></td>
<td>
<p>previously folded dataset, in case some specific rows have to be removed after the folding</p>
</td></tr>
<tr><td><code id="learn_dbn_struc_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="bnlearn.html#topic+rsmax2">rsmax2</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;dbn&quot; S3 object with the structure of the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("motor")
net &lt;- learn_dbn_struc(motor, size = 3)
</code></pre>

<hr>
<h2 id='logLik.dbn'>Calculate the log-likelihood of a dynamic Bayesian network</h2><span id='topic+logLik.dbn'></span>

<h3>Description</h3>

<p>Generic method for calculating the log-likelihood of a 
&quot;dbn&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+logLik">logLik</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
logLik(object, dt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.dbn_+3A_object">object</code></td>
<td>
<p>the structure of the network</p>
</td></tr>
<tr><td><code id="logLik.dbn_+3A_dt">dt</code></td>
<td>
<p>the dataset to calculate the score of the network</p>
</td></tr>
<tr><td><code id="logLik.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log-likelihood score of the network
</p>

<hr>
<h2 id='logLik.dbn.fit'>Calculate the log-likelihood of a dynamic Bayesian network</h2><span id='topic+logLik.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for calculating the log-likelihood of a 
&quot;dbn.fit&quot; S3 object given some data. Calls bnlearn's <code><a href="stats.html#topic+logLik">logLik</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
logLik(object, dt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="logLik.dbn.fit_+3A_dt">dt</code></td>
<td>
<p>the dataset to calculate the score of the network</p>
</td></tr>
<tr><td><code id="logLik.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters for the network scoring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log-likelihood score of the network
</p>

<hr>
<h2 id='mean.dbn.fit'>Average the parameters of multiple dbn.fit objects with identical structures</h2><span id='topic+mean.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.dbn.fit_+3A_x">x</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="mean.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the averaged parameters
</p>

<hr>
<h2 id='merge_nets'>Merges and replicates the arcs in the static BN into all the time-slices
in the DBN</h2><span id='topic+merge_nets'></span>

<h3>Description</h3>

<p>This will join the static net and the state transition
net by replicating the arcs in the static net in all the time slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_nets(net0, netCP1, size, acc = NULL, slice = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_nets_+3A_net0">net0</code></td>
<td>
<p>the structure of the static net</p>
</td></tr>
<tr><td><code id="merge_nets_+3A_netcp1">netCP1</code></td>
<td>
<p>the state transition net</p>
</td></tr>
<tr><td><code id="merge_nets_+3A_size">size</code></td>
<td>
<p>the number of time slices of the net. Markovian 1 would be size 2</p>
</td></tr>
<tr><td><code id="merge_nets_+3A_acc">acc</code></td>
<td>
<p>accumulator of the results in the recursion</p>
</td></tr>
<tr><td><code id="merge_nets_+3A_slice">slice</code></td>
<td>
<p>current time slice that is being processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the merged nets
</p>

<hr>
<h2 id='motor'>Multivariate time series dataset on the temperature of an electric motor</h2><span id='topic+motor'></span>

<h3>Description</h3>

<p>Data from several sensors on an electric motor that records different
benchmark sessions of measurements at 2 Hz. The dataset is reduced to
3000 instances from the 60th session in order to include it in the package
for testing purposes. For the complete dataset, refer to the source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(motor)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 3000 rows and 11 columns.
</p>


<h3>Source</h3>

<p>Kaggle, &lt;https://www.kaggle.com/wkirgsn/electric-motor-temperature&gt;
</p>

<hr>
<h2 id='mvn_inference'>Performs inference over a multivariate normal distribution</h2><span id='topic+mvn_inference'></span>

<h3>Description</h3>

<p>Given some evidence, this function performs inference over a multivariate normal 
distribution. After converting a Gaussian linear network to its MVN form, this
kind of inference can be performed. It's recommended to use
<code><a href="#topic+predict_dt">predict_dt</a></code> functions instead unless you need a more flexible 
inference method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn_inference(mu, sigma, evidence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn_inference_+3A_mu">mu</code></td>
<td>
<p>the mean vector</p>
</td></tr>
<tr><td><code id="mvn_inference_+3A_sigma">sigma</code></td>
<td>
<p>the covariance matrix</p>
</td></tr>
<tr><td><code id="mvn_inference_+3A_evidence">evidence</code></td>
<td>
<p>a single row data.table or a named vector with the values and names of the variables given as evidence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the posterior mean and covariance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
data(motor)
dt_train &lt;- motor[200:2500]
dt_val &lt;- motor[2501:3000]
obj &lt;- c("pm_t_0")

net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
f_dt_val &lt;- fold_dt(dt_val, size)
ev &lt;- f_dt_val[1, .SD, .SDcols = obj]
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")

pred &lt;- mvn_inference(calc_mu(fit), calc_sigma(fit), ev)
</code></pre>

<hr>
<h2 id='nat_cl_to_arc_matrix_cpp'>Create a matrix with the arcs defined in a causlist object</h2><span id='topic+nat_cl_to_arc_matrix_cpp'></span>

<h3>Description</h3>

<p>Create a matrix with the arcs defined in a causlist object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_cl_to_arc_matrix_cpp(cl, ordering, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nat_cl_to_arc_matrix_cpp_+3A_cl">cl</code></td>
<td>
<p>a causal list</p>
</td></tr>
<tr><td><code id="nat_cl_to_arc_matrix_cpp_+3A_ordering">ordering</code></td>
<td>
<p>a list with the order of the variables in t_0</p>
</td></tr>
<tr><td><code id="nat_cl_to_arc_matrix_cpp_+3A_rows">rows</code></td>
<td>
<p>number of arcs in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a StringMatrix with the parent nodes and the children nodes
</p>

<hr>
<h2 id='nat_cte_times_vel_cpp'>Multiply a Velocity by a constant real number</h2><span id='topic+nat_cte_times_vel_cpp'></span>

<h3>Description</h3>

<p>Multiply a Velocity by a constant real number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_cte_times_vel_cpp(k, vl, vl_neg, abs_op, max_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nat_cte_times_vel_cpp_+3A_k">k</code></td>
<td>
<p>the constant real number</p>
</td></tr>
<tr><td><code id="nat_cte_times_vel_cpp_+3A_vl">vl</code></td>
<td>
<p>the Velocity's positive causal list</p>
</td></tr>
<tr><td><code id="nat_cte_times_vel_cpp_+3A_vl_neg">vl_neg</code></td>
<td>
<p>the Velocity's negative causal list</p>
</td></tr>
<tr><td><code id="nat_cte_times_vel_cpp_+3A_abs_op">abs_op</code></td>
<td>
<p>the final number of 1,-1 operations</p>
</td></tr>
<tr><td><code id="nat_cte_times_vel_cpp_+3A_max_size">max_size</code></td>
<td>
<p>the maximum size of the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new total number of operations
</p>

<hr>
<h2 id='nat_pos_minus_pos_cpp'>Subtracts two natPositions to obtain the natVelocity that transforms ps1 into ps2</h2><span id='topic+nat_pos_minus_pos_cpp'></span>

<h3>Description</h3>

<p>Subtracts two natPositions to obtain the natVelocity that transforms ps1 into ps2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_pos_minus_pos_cpp(ps1, ps2, vl, vl_neg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nat_pos_minus_pos_cpp_+3A_ps1">ps1</code></td>
<td>
<p>the first position's causal list</p>
</td></tr>
<tr><td><code id="nat_pos_minus_pos_cpp_+3A_ps2">ps2</code></td>
<td>
<p>the second position's causal list</p>
</td></tr>
<tr><td><code id="nat_pos_minus_pos_cpp_+3A_vl">vl</code></td>
<td>
<p>the natVelocity's positive causal list</p>
</td></tr>
<tr><td><code id="nat_pos_minus_pos_cpp_+3A_vl_neg">vl_neg</code></td>
<td>
<p>the natVelocity's negative causal list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the velocity's causal lists by reference and the number of operations by return
</p>

<hr>
<h2 id='nat_pos_plus_vel_cpp'>Add a velocity to a position</h2><span id='topic+nat_pos_plus_vel_cpp'></span>

<h3>Description</h3>

<p>Add a velocity to a position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_pos_plus_vel_cpp(cl, vl, vl_neg, n_arcs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nat_pos_plus_vel_cpp_+3A_cl">cl</code></td>
<td>
<p>the position's causal list</p>
</td></tr>
<tr><td><code id="nat_pos_plus_vel_cpp_+3A_vl">vl</code></td>
<td>
<p>the velocity's positive causal list</p>
</td></tr>
<tr><td><code id="nat_pos_plus_vel_cpp_+3A_vl_neg">vl_neg</code></td>
<td>
<p>velocity's negative causal list</p>
</td></tr>
<tr><td><code id="nat_pos_plus_vel_cpp_+3A_n_arcs">n_arcs</code></td>
<td>
<p>number of arcs present in the position. Remainder: can't return integers by reference, they get casted to 1 sized vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new position by reference and the new number of arcs by return
</p>

<hr>
<h2 id='nat_vel_plus_vel_cpp'>Adds two natVelocities</h2><span id='topic+nat_vel_plus_vel_cpp'></span>

<h3>Description</h3>

<p>Adds two natVelocities represented as two numeric vectors: one with the
positive part and one with the negative part. Adding them is a process that
does a bitwise 'or' with both the positive and negative parts of the two
velocities, adjusts the new abs_op, removes duplicated arcs in the final
velocity by using a bitwise 'xor' with both parts and adjusts the final abs_op.
The results are returned via modifying the original vl1 and vl1_neg by
reference and returning the final abs_op normally. I can't have an integer
edited by reference because it automatically gets casted and cannot be used
to return values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_vel_plus_vel_cpp(vl1, vl1_neg, vl2, vl2_neg, abs_op1, abs_op2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_vl1">vl1</code></td>
<td>
<p>the first Velocity's positive part</p>
</td></tr>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_vl1_neg">vl1_neg</code></td>
<td>
<p>the first Velocity's negative part</p>
</td></tr>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_vl2">vl2</code></td>
<td>
<p>the second Velocity's positive part</p>
</td></tr>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_vl2_neg">vl2_neg</code></td>
<td>
<p>the first Velocity's negative part</p>
</td></tr>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_abs_op1">abs_op1</code></td>
<td>
<p>the number of 1,-1 operations in the first velocity</p>
</td></tr>
<tr><td><code id="nat_vel_plus_vel_cpp_+3A_abs_op2">abs_op2</code></td>
<td>
<p>the number of 1,-1 operations in the second velocity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the total number of resulting operations
</p>

<hr>
<h2 id='natCauslist'>R6 class that defines causal lists in the PSO</h2><span id='topic+natCauslist'></span>

<h3>Description</h3>

<p>Constructor of the 'natCauslist' class
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="natCauslist_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="natCauslist_+3A_ordering_raw">ordering_raw</code></td>
<td>
<p>a vector with the names of the nodes without the appended &quot;_t_0&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The causal lists will be the base of the positions and the velocities
in the pso part of the algorithm. They will not have the same structure
as their binary counterparts, but their class skeleton will serve as a
base.
</p>


<h3>Value</h3>

<p>A new 'natCauslist' object
</p>


<h3>Fields</h3>


<dl>
<dt><code>cl</code></dt><dd><p>List of causal units</p>
</dd>
<dt><code>ordering</code></dt><dd><p>String vector defining the order of the nodes in t_0</p>
</dd>
<dt><code>ordering</code></dt><dd><p>String vector defining the order of the nodes without the appended &quot;_t_0&quot;</p>
</dd>
</dl>

<hr>
<h2 id='natParticle'>R6 class that defines a Particle in the PSO algorithm</h2><span id='topic+natParticle'></span>

<h3>Description</h3>

<p>Constructor of the 'natParticle' class
</p>
<p>Evaluate the score of the particle's position
</p>
<p>Evaluate the score of the particle's position.
Updates the local best if the new one is better.
</p>
<p>Update the position of the particle with the velocity
</p>
<p>Update the position of the particle given the constants after calculating
the new velocity
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="natParticle_+3A_nodes">nodes</code></td>
<td>
<p>a vector with the names of the nodes</p>
</td></tr>
<tr><td><code id="natParticle_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="natParticle_+3A_ordering_raw">ordering_raw</code></td>
<td>
<p>a vector with the names of the nodes without the appended &quot;_t_0&quot;</p>
</td></tr>
<tr><td><code id="natParticle_+3A_max_size">max_size</code></td>
<td>
<p>maximum number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="natParticle_+3A_v_probs">v_probs</code></td>
<td>
<p>vector of probabilities for the velocity sampling</p>
</td></tr>
<tr><td><code id="natParticle_+3A_p">p</code></td>
<td>
<p>parameter of the truncated geometric distribution</p>
</td></tr>
<tr><td><code id="natParticle_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
<tr><td><code id="natParticle_+3A_dt">dt</code></td>
<td>
<p>dataset to evaluate the fitness of the particle</p>
</td></tr>
<tr><td><code id="natParticle_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="natParticle_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="natParticle_+3A_gb_ps">gb_ps</code></td>
<td>
<p>position of the global best</p>
</td></tr>
<tr><td><code id="natParticle_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="natParticle_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A particle has a Position, a Velocity and a local best
</p>


<h3>Value</h3>

<p>A new 'natParticle' object
</p>
<p>The score of the current position
</p>


<h3>Fields</h3>


<dl>
<dt><code>ps</code></dt><dd><p>position of the particle</p>
</dd>
<dt><code>cl</code></dt><dd><p>velocity of the particle</p>
</dd>
<dt><code>velocity</code></dt><dd><p>that takes the particle to the global best</p>
</dd>
<dt><code>velocity</code></dt><dd><p>that takes the particle to the local best</p>
</dd>
<dt><code>lb</code></dt><dd><p>local best score obtained</p>
</dd>
<dt><code>lb_ps</code></dt><dd><p>local best position found</p>
</dd>
<dt><code>score</code></dt><dd><p>bnlearn score function used</p>
</dd>
</dl>

<hr>
<h2 id='natPosition'>R6 class that defines DBNs as vectors of natural numbers</h2><span id='topic+natPosition'></span>

<h3>Description</h3>

<p>Constructor of the 'natPosition' class
</p>
<p>Translate the vector into a DBN network
</p>
<p>Uses this object private cl and transforms it into a DBN.
</p>
<p>Add a velocity to the position
</p>
<p>Given a natVelocity object, add it to the current position.
</p>
<p>Return the static node ordering
</p>
<p>This function takes as input a dbn and return the node ordering of the
variables inside a timeslice. This ordering is needed to understand a
position vector.
</p>
<p>Translate a DBN into a position vector
</p>
<p>This function takes as input a network from a DBN and transforms the 
structure into a vector of natural numbers if it is a valid DBN. Valid 
DBNs have only inter-timeslice edges and only allow variables in t_0 to 
have parents.
</p>
<p>Generates a random position
</p>
<p>This function takes as input the number of variables, the maximum size
and the parameter p and returns a random position with arcs 
sampled either from the uniform distribution or from a truncated 
geometric distribution. Much faster than the binary implementation with
lists of lists and random bn generation into translation.
</p>
<p>Recount the number of arcs in the cl
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="natPosition_+3A_nodes">nodes</code></td>
<td>
<p>a vector with the names of the nodes</p>
</td></tr>
<tr><td><code id="natPosition_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="natPosition_+3A_ordering_raw">ordering_raw</code></td>
<td>
<p>a vector with the names of the nodes without the appended &quot;_t_0&quot;</p>
</td></tr>
<tr><td><code id="natPosition_+3A_max_size">max_size</code></td>
<td>
<p>Maximum number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="natPosition_+3A_vl">vl</code></td>
<td>
<p>a natVelocity object</p>
</td></tr>
<tr><td><code id="natPosition_+3A_net">net</code></td>
<td>
<p>a dbn object</p>
</td></tr>
<tr><td><code id="natPosition_+3A_n_vars">n_vars</code></td>
<td>
<p>the number of variables in t_0</p>
</td></tr>
<tr><td><code id="natPosition_+3A_p">p</code></td>
<td>
<p>the parameter of the truncated geometric sampler. If lesser or
equal to 0, a uniform distribution will be used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A natPosition represents a single HO-DBN structure with a vector. Its function
is to encode the solutions in the PSO framework. Each particle will have a 
position.
</p>


<h3>Value</h3>

<p>A new 'natPosition' object
</p>
<p>a dbn object
</p>
<p>the ordering of the nodes in t_0
</p>
<p>a random position
</p>
<p>the number of arcs
</p>


<h3>Fields</h3>


<dl>
<dt><code>n_arcs</code></dt><dd><p>Number of arcs in the network</p>
</dd>
<dt><code>max_size</code></dt><dd><p>Maximum number of timeslices of the DBN</p>
</dd>
<dt><code>p</code></dt><dd><p>Parameter of the sampling truncated geometric distribution</p>
</dd>
<dt><code>nodes</code></dt><dd><p>Names of the nodes in the network</p>
</dd>
</dl>

<hr>
<h2 id='natPsoCtrl'>R6 class that defines the PSO controller</h2><span id='topic+natPsoCtrl'></span>

<h3>Description</h3>

<p>Constructor of the 'natPsoCtrl' class
</p>
<p>If the names of the nodes have &quot;_t_0&quot; appended at the end, remove it
</p>
<p>Initialize the particles for the algorithm to random positions and velocities.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="natPsoCtrl_+3A_n_it">n_it</code></td>
<td>
<p>maximum number of iterations of the pso algorithm</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_cte">cte</code></td>
<td>
<p>boolean that defines whether the parameters remain constant or vary as the execution progresses</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_nodes">nodes</code></td>
<td>
<p>a vector with the names of the nodes</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_max_size">max_size</code></td>
<td>
<p>maximum number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_n_inds">n_inds</code></td>
<td>
<p>number of particles that the algorithm will simultaneously process</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_v_probs">v_probs</code></td>
<td>
<p>vector that defines the random velocity initialization probabilities</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_p">p</code></td>
<td>
<p>parameter of the truncated geometric distribution for sampling edges</p>
</td></tr>
<tr><td><code id="natPsoCtrl_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The controller will encapsulate the particles and run the algorithm. This
time, it extends the class &quot;PsoCtrl&quot; in the &quot;structure_learning_psoho.R&quot;
file, because both controllers are practically the same. The particles,
positions and velocities are too different to extend one another though.
</p>


<h3>Value</h3>

<p>A new 'natPsoCtrl' object
</p>
<p>the ordering with the names cropped
</p>

<hr>
<h2 id='natPsoho'>Learn a DBN structure with a PSO approach</h2><span id='topic+natPsoho'></span>

<h3>Description</h3>

<p>Given a dataset and the desired Markovian order, this function returns a DBN
structure ready to be fitted.
Original algorithm at https://link.springer.com/chapter/10.1007/978-3-030-86271-8_14
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natPsoho(
  dt,
  size,
  f_dt = NULL,
  n_inds = 50,
  n_it = 50,
  in_cte = 1,
  gb_cte = 0.5,
  lb_cte = 0.5,
  v_probs = c(10, 65, 25),
  r_probs = c(-0.5, 1.5),
  score = "bge",
  p = 0.06,
  cte = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="natPsoho_+3A_dt">dt</code></td>
<td>
<p>a data.table with the data of the network to be trained</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_size">size</code></td>
<td>
<p>Maximum number of timeslices of the DBN allowed. Markovian order 1 equals size 2, and so on</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_f_dt">f_dt</code></td>
<td>
<p>previously folded dataset, in case some specific rows have to be removed after the folding</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_n_inds">n_inds</code></td>
<td>
<p>Number of particles used in the algorithm</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_n_it">n_it</code></td>
<td>
<p>Maximum number of iterations that the algorithm can perform</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_v_probs">v_probs</code></td>
<td>
<p>vector that defines the random velocity initialization probabilities</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_p">p</code></td>
<td>
<p>parameter of the truncated geometric distribution for sampling edges</p>
</td></tr>
<tr><td><code id="natPsoho_+3A_cte">cte</code></td>
<td>
<p>a boolean that determines whether the inertia, global best and local best parameters remain constant or vary as the algorithm progresses. Inertia and local best values decrease as the global best increases, to favor exploration at first and exploitation at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'dbn' object with the structure of the best network found
</p>

<hr>
<h2 id='natVelocity'>R6 class that defines velocities in the PSO</h2><span id='topic+natVelocity'></span>

<h3>Description</h3>

<p>Constructor of the 'natVelocity' class. Only difference with the
natCauslist one is that it has a negative cl attribute.
</p>
<p>Getter of the abs_op attribute.
</p>
<p>return the number of operations that the velocity performs
</p>
<p>Setter of the abs_op attribute. Intended for inside use only. 
This should be a 'protected' function in Java-like OOP, but there's no 
such thing in R6. This function should not be used from outside the
package.
</p>
<p>Randomizes the Velocity's directions.
</p>
<p>Given two positions, returns the velocity that gets the first position to the
other one.
</p>
<p>Add both velocities directions
</p>
<p>Multiply the Velocity by a constant real number
</p>
<p>This function multiplies the Velocity by a constant real number. 
It is non deterministic by definition. When calculating k*|V|, the 
result will be floored and bounded to the set [-max_op, max_op], where max_op
is the maximum number of arcs that can be present in the network.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="natVelocity_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_ordering_raw">ordering_raw</code></td>
<td>
<p>a vector with the names of the nodes without the appended &quot;_t_0&quot;</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_max_size">max_size</code></td>
<td>
<p>maximum number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_n">n</code></td>
<td>
<p>the new number of operations that the velocity performs</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_probs">probs</code></td>
<td>
<p>the weight of each value -1,0,1. They define the probability that each of them will be picked</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_p">p</code></td>
<td>
<p>the parameter of the geometric distribution</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_ps1">ps1</code></td>
<td>
<p>the origin natPosition object</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_ps2">ps2</code></td>
<td>
<p>the objective natPosition object</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_vl">vl</code></td>
<td>
<p>a Velocity object</p>
</td></tr>
<tr><td><code id="natVelocity_+3A_k">k</code></td>
<td>
<p>a real number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The velocities will be defined as two natural vectors where each element in
them represents the arcs from a temporal family of nodes to a receiving
node. 1-bits in the binary representation of this number represent arc 
additions/deletions
</p>


<h3>Value</h3>

<p>A new 'natVelocity' object
</p>
<p>the natVelocity that gets the ps1 to ps2
</p>


<h3>Fields</h3>


<dl>
<dt><code>abs_op</code></dt><dd><p>Total number of operations 1 or -1 in the velocity</p>
</dd>
<dt><code>max_size</code></dt><dd><p>Maximum number of timeslices of the DBN</p>
</dd>
<dt><code>cl_neg</code></dt><dd><p>Negative part of the velocity</p>
</dd>
</dl>

<hr>
<h2 id='node_levels'>Defines a level for every node in the net</h2><span id='topic+node_levels'></span>

<h3>Description</h3>

<p>Calculates the levels in which the nodes will be distributed when plotting
the structure. This level is defined by their parent nodes: a node with no
parents will always be in the level 0. Subsequently, the level of a node
will be one more of the maximum level of his parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_levels(net, order, lvl = 1, acc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_levels_+3A_net">net</code></td>
<td>
<p>the structure of the network.</p>
</td></tr>
<tr><td><code id="node_levels_+3A_order">order</code></td>
<td>
<p>a topological order of the nodes, with the orphan nodes
in the first place. See <code><a href="bnlearn.html#topic+node.ordering">node.ordering</a></code></p>
</td></tr>
<tr><td><code id="node_levels_+3A_lvl">lvl</code></td>
<td>
<p>current level being processed</p>
</td></tr>
<tr><td><code id="node_levels_+3A_acc">acc</code></td>
<td>
<p>accumulator of the nodes already processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the names of the nodes in the first row and their
level on the second
</p>

<hr>
<h2 id='nodes'>Returns a list with the names of the nodes of a BN or a DBN</h2><span id='topic+nodes'></span>

<h3>Description</h3>

<p>Generic method for obtaining the names of the nodes in a BN or a DBN.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath. 
I have to redefine the generic and mask the original for it to work on both 
bn and dbn objects without the user having to import bnlearn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot;, &quot;dbn&quot;, &quot;bn.fit&quot; or &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="nodes_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the names of the nodes
</p>

<hr>
<h2 id='nodes_gen_exp'>Generates the names of the nodes in t_0 and in all the network</h2><span id='topic+nodes_gen_exp'></span>

<h3>Description</h3>

<p>Given the names of the desired variables, this function generates the names
of the variables in a DBN without needing a previous dataset. It's just a 
wrapper around the 'fold_dt' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes_gen_exp(ordering, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes_gen_exp_+3A_ordering">ordering</code></td>
<td>
<p>the names of the variables</p>
</td></tr>
<tr><td><code id="nodes_gen_exp_+3A_size">size</code></td>
<td>
<p>the desired size of the dbn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dictionary with the variable names in t_0 and in all other time slices
</p>

<hr>
<h2 id='nodes.bn'>Returns a list with the names of the nodes of a BN or a DBN</h2><span id='topic+nodes.bn'></span>

<h3>Description</h3>

<p>Generic method for obtaining the names of the nodes in &quot;bn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bn'
nodes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes.bn_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot; object</p>
</td></tr>
<tr><td><code id="nodes.bn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the names of the nodes
</p>

<hr>
<h2 id='nodes.bn.fit'>Returns a list with the names of the nodes of a BN or a DBN</h2><span id='topic+nodes.bn.fit'></span>

<h3>Description</h3>

<p>Generic method for obtaining the names of the nodes in &quot;bn.fit&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bn.fit'
nodes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes.bn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;bn.fit&quot; object</p>
</td></tr>
<tr><td><code id="nodes.bn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the names of the nodes
</p>

<hr>
<h2 id='nodes.dbn'>Returns a list with the names of the nodes of a BN or a DBN</h2><span id='topic+nodes.dbn'></span>

<h3>Description</h3>

<p>Generic method for obtaining the names of the nodes in &quot;dbn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath.
The nodes function is specifically coded to look for either the &quot;bn&quot;
or the &quot;bn.fit&quot; method inside bnlearn, so I have to cast the &quot;dbn&quot; class
into &quot;bn&quot; for it to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
nodes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes.dbn_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="nodes.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the names of the nodes
</p>

<hr>
<h2 id='nodes.dbn.fit'>Returns a list with the names of the nodes of a BN or a DBN</h2><span id='topic+nodes.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for obtaining the names of the nodes in &quot;dbn.fit&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
nodes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes.dbn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="nodes.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the names of the nodes
</p>

<hr>
<h2 id='nodes+26lt+3B-'>Relabel the names of the nodes of a BN or a DBN</h2><span id='topic+nodes+3C-'></span>

<h3>Description</h3>

<p>Generic method for renaming the nodes in a BN or a DBN.
Calls bnlearn's <code><a href="#topic+nodes+3C-">nodes&lt;-</a></code> underneath. 
I have to redefine the generic and mask the original for it to work on both 
bn and dbn objects without the user having to import bnlearn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot;, &quot;dbn&quot;, &quot;bn.fit&quot; or &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="nodes+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a list with the new names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>

<hr>
<h2 id='nodes+26lt+3B-.bn'>Relabel the names of the nodes of a BN or a DBN</h2><span id='topic+nodes+3C-.bn'></span>

<h3>Description</h3>

<p>Generic method for renaming the nodes in a &quot;bn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes+3C-">nodes&lt;-</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'bn'
nodes(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes+2B26lt+2B3B-.bn_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot; object</p>
</td></tr>
<tr><td><code id="nodes+2B26lt+2B3B-.bn_+3A_value">value</code></td>
<td>
<p>a list with the new names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>

<hr>
<h2 id='nodes+26lt+3B-.bn.fit'>Relabel the names of the nodes of a BN or a DBN</h2><span id='topic+nodes+3C-.bn.fit'></span>

<h3>Description</h3>

<p>Generic method for renaming the nodes in a &quot;bn.fit&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes+3C-">nodes&lt;-</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'bn.fit'
nodes(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes+2B26lt+2B3B-.bn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;bn.fit&quot; object</p>
</td></tr>
<tr><td><code id="nodes+2B26lt+2B3B-.bn.fit_+3A_value">value</code></td>
<td>
<p>a list with the new names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>

<hr>
<h2 id='nodes+26lt+3B-.dbn'>Relabel the names of the nodes of a BN or a DBN</h2><span id='topic+nodes+3C-.dbn'></span>

<h3>Description</h3>

<p>Generic method for renaming the nodes in a &quot;bn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes+3C-">nodes&lt;-</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'dbn'
nodes(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes+2B26lt+2B3B-.dbn_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="nodes+2B26lt+2B3B-.dbn_+3A_value">value</code></td>
<td>
<p>a list with the new names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>

<hr>
<h2 id='nodes+26lt+3B-.dbn.fit'>Relabel the names of the nodes of a BN or a DBN</h2><span id='topic+nodes+3C-.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for renaming the nodes in a &quot;bn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+nodes+3C-">nodes&lt;-</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'dbn.fit'
nodes(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes+2B26lt+2B3B-.dbn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="nodes+2B26lt+2B3B-.dbn.fit_+3A_value">value</code></td>
<td>
<p>a list with the new names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>

<hr>
<h2 id='one_hot'>One hot encoder for natural numbers without the 0.</h2><span id='topic+one_hot'></span>

<h3>Description</h3>

<p>Given a natural number, return the natural number equivalent to its
one-hot encoding. Examples: 3 -&gt; 100 -&gt; 4, 5 -&gt; 10000 -&gt; 16
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot(nat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_hot_+3A_nat">nat</code></td>
<td>
<p>the natural number to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the converted number
</p>

<hr>
<h2 id='one_hot_cpp'>One-hot encoder for natural numbers without the 0</h2><span id='topic+one_hot_cpp'></span>

<h3>Description</h3>

<p>Given a natural number, return the natural number equivalent to its
one-hot encoding. Instead of pow, the '&lt;&lt;' operator will be used.
Examples: 3 -&gt; 100 -&gt; 4, 5 -&gt; 10000 -&gt; 16
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot_cpp(nat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_hot_cpp_+3A_nat">nat</code></td>
<td>
<p>the natural number to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the converted number
</p>

<hr>
<h2 id='ordering_gen_exp'>Generates the names of n variables.</h2><span id='topic+ordering_gen_exp'></span>

<h3>Description</h3>

<p>Given the total number of variables, this function generates a character
vector with variables named &quot;Xi&quot;, where i is a number in the interval [0,n-1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordering_gen_exp(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordering_gen_exp_+3A_n">n</code></td>
<td>
<p>the total number of variables desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with the variable names
</p>

<hr>
<h2 id='Particle'>R6 class that defines a Particle in the PSO algorithm</h2><span id='topic+Particle'></span>

<h3>Description</h3>

<p>Constructor of the 'Particle' class
</p>
<p>Evaluate the score of the particle's position
</p>
<p>Evaluate the score of the particle's position.
Updates the local best if the new one is better.
</p>
<p>Update the position of the particle with the velocity
</p>
<p>Update the position of the particle given the constants after calculating
the new velocity
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Particle_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="Particle_+3A_size">size</code></td>
<td>
<p>number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="Particle_+3A_v_probs">v_probs</code></td>
<td>
<p>vector that defines the random velocity initialization probabilities</p>
</td></tr>
<tr><td><code id="Particle_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
<tr><td><code id="Particle_+3A_dt">dt</code></td>
<td>
<p>dataset to evaluate the fitness of the particle</p>
</td></tr>
<tr><td><code id="Particle_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="Particle_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="Particle_+3A_gb_ps">gb_ps</code></td>
<td>
<p>position of the global best</p>
</td></tr>
<tr><td><code id="Particle_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="Particle_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A particle has a Position, a Velocity and a local best
</p>


<h3>Value</h3>

<p>A new 'Particle' object
</p>
<p>The score of the current position
</p>


<h3>Fields</h3>


<dl>
<dt><code>ps</code></dt><dd><p>position of the particle</p>
</dd>
<dt><code>cl</code></dt><dd><p>velocity of the particle</p>
</dd>
<dt><code>lb</code></dt><dd><p>local best score obtained</p>
</dd>
<dt><code>lb_ps</code></dt><dd><p>local best position found</p>
</dd>
<dt><code>score</code></dt><dd><p>bnlearn score function used</p>
</dd>
</dl>

<hr>
<h2 id='plot_dynamic_network'>Plots a dynamic Bayesian network in a hierarchical way</h2><span id='topic+plot_dynamic_network'></span>

<h3>Description</h3>

<p>To plot the DBN, this method first computes a hierarchical structure
for a time slice and replicates it for each slice. Then, it calculates the
relative position of each node with respect to his equivalent in the first
slice. The result is a net where each time slice is ordered and separated
from one another, where the leftmost slice is the oldest and the rightmost
represents the present time. This function is also called by the generic
plot function of &quot;dbn&quot; and &quot;dbn.fit&quot; S3 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dynamic_network(
  structure,
  offset = 200,
  subset_nodes = NULL,
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dynamic_network_+3A_structure">structure</code></td>
<td>
<p>the structure or fit of the network.</p>
</td></tr>
<tr><td><code id="plot_dynamic_network_+3A_offset">offset</code></td>
<td>
<p>the blank space between time slices</p>
</td></tr>
<tr><td><code id="plot_dynamic_network_+3A_subset_nodes">subset_nodes</code></td>
<td>
<p>a vector containing the names of the subset of nodes to plot</p>
</td></tr>
<tr><td><code id="plot_dynamic_network_+3A_reverse">reverse</code></td>
<td>
<p>reverse to the classic naming convention of the nodes. 
The oldest time-slice will now be t_0 and the most recent one t_n. 
Only for visualization purposes, the network is unmodified underneath. If
using subset_nodes, remember that t_0 is now the oldest time-slice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the visualization of the DBN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
size = 3
dt_train &lt;- dbnR::motor[200:2500]
net &lt;- learn_dbn_struc(dt_train, size)
plot_dynamic_network(net)

</code></pre>

<hr>
<h2 id='plot_static_network'>Plots a Bayesian network in a hierarchical way</h2><span id='topic+plot_static_network'></span>

<h3>Description</h3>

<p>This function calculates the levels of each node and then plots them in a hierarchical
layout in visNetwork. Can be used in place of the generic plot function 
offered by bnlearn for &quot;bn&quot; and &quot;bn.fit&quot; S3 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_static_network(structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_static_network_+3A_structure">structure</code></td>
<td>
<p>the structure or fit of the network.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dt_train &lt;- dbnR::motor[200:2500]
net &lt;- bnlearn::mmhc(dt_train)
plot_static_network(net)
fit &lt;- bnlearn::bn.fit(net, dt_train, method = "mle-g")
plot_static_network(fit) # Works for both the structure and the fitted net

</code></pre>

<hr>
<h2 id='plot.dbn'>Plots a dynamic Bayesian network</h2><span id='topic+plot.dbn'></span>

<h3>Description</h3>

<p>Generic method for plotting the &quot;dbn&quot; S3 objects. Calls 
<code><a href="#topic+plot_dynamic_network">plot_dynamic_network</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dbn_+3A_x">x</code></td>
<td>
<p>the structure of the network.</p>
</td></tr>
<tr><td><code id="plot.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters for the visualization of a DBN</p>
</td></tr>
</table>

<hr>
<h2 id='plot.dbn.fit'>Plots a fitted dynamic Bayesian network</h2><span id='topic+plot.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for plotting the &quot;dbn.fit&quot; S3 objects. Calls 
<code><a href="#topic+plot_dynamic_network">plot_dynamic_network</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dbn.fit_+3A_x">x</code></td>
<td>
<p>the structure of the network.</p>
</td></tr>
<tr><td><code id="plot.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters for the visualization of a DBN</p>
</td></tr>
</table>

<hr>
<h2 id='pos_minus_pos_cpp'>Subtracts two Positions to obtain the Velocity that transforms one into the other</h2><span id='topic+pos_minus_pos_cpp'></span>

<h3>Description</h3>

<p>Subtracts two Positions to obtain the Velocity that transforms one into the other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos_minus_pos_cpp(cl, ps, vl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_minus_pos_cpp_+3A_cl">cl</code></td>
<td>
<p>the first position's causal list</p>
</td></tr>
<tr><td><code id="pos_minus_pos_cpp_+3A_ps">ps</code></td>
<td>
<p>the second position's causal list</p>
</td></tr>
<tr><td><code id="pos_minus_pos_cpp_+3A_vl">vl</code></td>
<td>
<p>the Velocity's causal list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the Velocity's causal list and the number of operations
</p>

<hr>
<h2 id='pos_plus_vel_cpp'>Add a velocity to a position</h2><span id='topic+pos_plus_vel_cpp'></span>

<h3>Description</h3>

<p>Add a velocity to a position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos_plus_vel_cpp(cl, vl, n_arcs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_plus_vel_cpp_+3A_cl">cl</code></td>
<td>
<p>the position's causal list</p>
</td></tr>
<tr><td><code id="pos_plus_vel_cpp_+3A_vl">vl</code></td>
<td>
<p>the velocity's causal list</p>
</td></tr>
<tr><td><code id="pos_plus_vel_cpp_+3A_n_arcs">n_arcs</code></td>
<td>
<p>number of arcs present in the position</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the modified position and the new number of arcs
</p>

<hr>
<h2 id='Position'>R6 class that defines DBNs as causality lists</h2><span id='topic+Position'></span>

<h3>Description</h3>

<p>Constructor of the 'causlist' class
</p>
<p>Translate the causality list into a DBN network
</p>
<p>Uses this object private causality list and transforms it into a DBN.
</p>
<p>Add a velocity to the position
</p>
<p>Given a Velocity object, add it to the current position.
</p>
<p>Given another position, returns the velocity that gets this position to the
other.
</p>
<p>Return the static node ordering
</p>
<p>This function takes as input a dbn and return the node ordering of the
variables inside a timeslice. This ordering is needed to understand a
causal list.
</p>
<p>Translate a DBN into a causality list
</p>
<p>This function takes as input a network from a DBN and transforms the 
structure into a causality list if it is a valid DBN. Valid DBNs have only
inter-timeslice edges and only allow variables in t_0 to have parents.
</p>
<p>Generates a random DBN valid for causality list translation
</p>
<p>This function takes as input a list with the names of the nodes and the
desired size of the network and returns a random DBN structure.
</p>
<p>Fixes a DBN structure to make it suitable for causality list translation
</p>
<p>This function takes as input a DBN structure and removes the 
intra-timeslice arcs and the arcs that end in a node not in t_0.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Position_+3A_vl">vl</code></td>
<td>
<p>a Velocity object</p>
</td></tr>
<tr><td><code id="Position_+3A_ps">ps</code></td>
<td>
<p>a Position object
return the Velocity that gets this position to the new one</p>
</td></tr>
<tr><td><code id="Position_+3A_nodes">nodes</code></td>
<td>
<p>a character vector with the names of the nodes in the net</p>
</td></tr>
<tr><td><code id="Position_+3A_size">size</code></td>
<td>
<p>the desired size of the DBN</p>
</td></tr>
<tr><td><code id="Position_+3A_net">net</code></td>
<td>
<p>the DBN structure</p>
</td></tr>
<tr><td><code id="Position_+3A_nodes_t_0">nodes_t_0</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A causality list has a list with causal units, a size representing the
Markovian order of the network and a specific node ordering.
</p>


<h3>Value</h3>

<p>A new 'causlist' object
</p>
<p>a dbn object
</p>
<p>the ordering of the nodes in t_0
</p>
<p>a causlist object
</p>
<p>a random dbn structure
</p>
<p>the fixed network
</p>


<h3>Fields</h3>


<dl>
<dt><code>n_arcs</code></dt><dd><p>Number of arcs in the network</p>
</dd>
<dt><code>nodes</code></dt><dd><p>Names of the nodes in the network</p>
</dd>
</dl>

<hr>
<h2 id='predict_bn'>Performs inference over a fitted GBN</h2><span id='topic+predict_bn'></span>

<h3>Description</h3>

<p>Performs inference over a Gaussian BN. It's thought to be used in a map for
a data.table, to use as evidence each separate row. If not specifically
needed, it's recommended to use the function <code><a href="#topic+predict_dt">predict_dt</a></code> instead.
This function is deprecated and will be removed in a future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_bn(fit, evidence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_bn_+3A_fit">fit</code></td>
<td>
<p>the fitted bn</p>
</td></tr>
<tr><td><code id="predict_bn_+3A_evidence">evidence</code></td>
<td>
<p>values of the variables used as evidence for the net</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with the predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
data(motor)
dt_train &lt;- motor[200:2500]
dt_val &lt;- motor[2501:3000]
net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
f_dt_val &lt;- fold_dt(dt_val, size)
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")
res &lt;- f_dt_val[, predict_bn(fit, .SD), .SDcols = c("pm_t_0", "coolant_t_0"), by = 1:nrow(f_dt_val)]
</code></pre>

<hr>
<h2 id='predict_dt'>Performs inference over a test dataset with a GBN</h2><span id='topic+predict_dt'></span>

<h3>Description</h3>

<p>This function performs inference over each row of a folded data.table, 
plots the results and gives metrics of the accuracy of the predictions. Given
that only a single row is predicted, the horizon of the prediction is at most 1.
This function is also called by the generic predict method for &quot;dbn.fit&quot; 
objects. For long term forecasting, please refer to the 
<code><a href="#topic+forecast_ts">forecast_ts</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_dt(fit, dt, obj_nodes, verbose = T, look_ahead = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_dt_+3A_fit">fit</code></td>
<td>
<p>the fitted bn</p>
</td></tr>
<tr><td><code id="predict_dt_+3A_dt">dt</code></td>
<td>
<p>the test dataset</p>
</td></tr>
<tr><td><code id="predict_dt_+3A_obj_nodes">obj_nodes</code></td>
<td>
<p>the nodes that are going to be predicted. They are all predicted at the same time</p>
</td></tr>
<tr><td><code id="predict_dt_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, displays the metrics and plots the real values against the predictions</p>
</td></tr>
<tr><td><code id="predict_dt_+3A_look_ahead">look_ahead</code></td>
<td>
<p>boolean that defines whether or not the values of the variables in t_0 should be used when predicting, even if they are not present in obj_nodes. This decides if look-ahead bias is introduced or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with the prediction results for each row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
data(motor)
dt_train &lt;- motor[200:900]
dt_val &lt;- motor[901:1000]

# With a DBN
obj &lt;- c("pm_t_0")
net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
f_dt_val &lt;- fold_dt(dt_val, size)
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")
res &lt;- suppressWarnings(predict_dt(fit, f_dt_val, obj_nodes = obj, verbose = FALSE))

# With a Gaussian BN directly from bnlearn
obj &lt;- c("pm")
net &lt;- bnlearn::mmhc(dt_train)
fit &lt;- bnlearn::bn.fit(net, dt_train, method = "mle-g")
res &lt;- suppressWarnings(predict_dt(fit, dt_val, obj_nodes = obj, verbose = FALSE))
</code></pre>

<hr>
<h2 id='predict.dbn.fit'>Performs inference in every row of a dataset with a DBN</h2><span id='topic+predict.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for predicting a dataset with a &quot;dbn.fit&quot; S3 objects. Calls 
<code><a href="#topic+predict_dt">predict_dt</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dbn.fit_+3A_object">object</code></td>
<td>
<p>a &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="predict.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters for the inference process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with the prediction results
</p>

<hr>
<h2 id='print.dbn'>Print method for &quot;dbn&quot; objects</h2><span id='topic+print.dbn'></span>

<h3>Description</h3>

<p>Generic print method for &quot;dbn&quot; S3 objects. Calls bnlearn's print underneath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dbn_+3A_x">x</code></td>
<td>
<p>the &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="print.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='print.dbn.fit'>Print method for &quot;dbn.fit&quot; objects</h2><span id='topic+print.dbn.fit'></span>

<h3>Description</h3>

<p>Generic print method for &quot;dbn.fit&quot; S3 objects. Calls bnlearn's print underneath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dbn.fit_+3A_x">x</code></td>
<td>
<p>the &quot;dbn.fit&quot; object</p>
</td></tr>
<tr><td><code id="print.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='PsoCtrl'>R6 class that defines the PSO controller</h2><span id='topic+PsoCtrl'></span>

<h3>Description</h3>

<p>Constructor of the 'PsoCtrl' class
</p>
<p>Getter of the cluster attribute
</p>
<p>Transforms the best position found into a bn structure and returns it
</p>
<p>Main function of the pso algorithm.
</p>
<p>Initialize the particles for the algorithm to random positions and velocities.
</p>
<p>Evaluate the particles and update the global best
</p>
<p>Modify the PSO parameters after each iteration
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="PsoCtrl_+3A_n_it">n_it</code></td>
<td>
<p>maximum number of iterations of the pso algorithm</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_cte">cte</code></td>
<td>
<p>a boolean that determines whether the parameters remain constant or vary as the algorithm progresses. The increases and decreases are calculated as a function of the total number of iterations, decreasing until close to 0 and increasing until close to 1.</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_ordering">ordering</code></td>
<td>
<p>a vector with the names of the nodes in t_0</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_size">size</code></td>
<td>
<p>number of timeslices of the DBN</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_n_inds">n_inds</code></td>
<td>
<p>number of particles that the algorithm will simultaneously process</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_v_probs">v_probs</code></td>
<td>
<p>vector that defines the random velocity initialization probabilities</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
<tr><td><code id="PsoCtrl_+3A_dt">dt</code></td>
<td>
<p>the dataset used to evaluate the position</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The controller will encapsulate the particles and run the algorithm
</p>


<h3>Value</h3>

<p>A new 'PsoCtrl' object
</p>
<p>the cluster attribute
</p>
<p>the size attribute
</p>


<h3>Fields</h3>


<dl>
<dt><code>parts</code></dt><dd><p>list with all the particles in the algorithm</p>
</dd>
<dt><code>cl</code></dt><dd><p>cluster for the parallel computations</p>
</dd>
<dt><code>n_it</code></dt><dd><p>maximum number of iterations of the pso algorithm</p>
</dd>
<dt><code>in_cte</code></dt><dd><p>parameter that varies the effect of the inertia</p>
</dd>
<dt><code>gb_cte</code></dt><dd><p>parameter that varies the effect of the global best</p>
</dd>
<dt><code>lb_cte</code></dt><dd><p>parameter that varies the effect of the local best</p>
</dd>
<dt><code>b_ps</code></dt><dd><p>global best position found</p>
</dd>
<dt><code>b_scr</code></dt><dd><p>global best score obtained</p>
</dd>
<dt><code>r_probs</code></dt><dd><p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</dd>
<dt><code>cte</code></dt><dd><p>boolean that defines whether the parameters remain constant or vary as the execution progresses</p>
</dd>
<dt><code>in_var</code></dt><dd><p>decrement of the inertia each iteration</p>
</dd>
<dt><code>gb_var</code></dt><dd><p>increment of the global best parameter each iteration</p>
</dd>
<dt><code>lb_var</code></dt><dd><p>increment of the local best parameter each iteration</p>
</dd>
</dl>

<hr>
<h2 id='psoho'>Learn a DBN structure with a PSO approach</h2><span id='topic+psoho'></span>

<h3>Description</h3>

<p>Given a dataset and the desired Markovian order, this function returns a DBN
structure ready to be fitted. It requires a folded dataset.
Original algorithm at https://doi.org/10.1109/BRC.2014.6880957
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psoho(
  dt,
  size,
  f_dt = NULL,
  n_inds = 50,
  n_it = 50,
  in_cte = 1,
  gb_cte = 0.5,
  lb_cte = 0.5,
  v_probs = c(10, 65, 25),
  r_probs = c(-0.5, 1.5),
  score = "bge",
  cte = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psoho_+3A_dt">dt</code></td>
<td>
<p>a data.table with the data of the network to be trained</p>
</td></tr>
<tr><td><code id="psoho_+3A_size">size</code></td>
<td>
<p>Number of timeslices of the DBN. Markovian order 1 equals size 2, and so on.</p>
</td></tr>
<tr><td><code id="psoho_+3A_f_dt">f_dt</code></td>
<td>
<p>previously folded dataset, in case some specific rows have to be removed after the folding</p>
</td></tr>
<tr><td><code id="psoho_+3A_n_inds">n_inds</code></td>
<td>
<p>Number of particles used in the algorithm.</p>
</td></tr>
<tr><td><code id="psoho_+3A_n_it">n_it</code></td>
<td>
<p>Maximum number of iterations that the algorithm can perform.</p>
</td></tr>
<tr><td><code id="psoho_+3A_in_cte">in_cte</code></td>
<td>
<p>parameter that varies the effect of the inertia</p>
</td></tr>
<tr><td><code id="psoho_+3A_gb_cte">gb_cte</code></td>
<td>
<p>parameter that varies the effect of the global best</p>
</td></tr>
<tr><td><code id="psoho_+3A_lb_cte">lb_cte</code></td>
<td>
<p>parameter that varies the effect of the local best</p>
</td></tr>
<tr><td><code id="psoho_+3A_v_probs">v_probs</code></td>
<td>
<p>vector that defines the random velocity initialization probabilities</p>
</td></tr>
<tr><td><code id="psoho_+3A_r_probs">r_probs</code></td>
<td>
<p>vector that defines the range of random variation of gb_cte and lb_cte</p>
</td></tr>
<tr><td><code id="psoho_+3A_score">score</code></td>
<td>
<p>bnlearn score function used</p>
</td></tr>
<tr><td><code id="psoho_+3A_cte">cte</code></td>
<td>
<p>a boolean that determines whether the inertia, global best and local best parameters remain constant or vary as the algorithm progresses. Inertia and local best values decrease as the global best increases, to favor exploration at first and exploitation at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'dbn' object with the structure of the best network found
</p>

<hr>
<h2 id='randomize_vl_cpp'>Randomize a velocity with the given probabilities</h2><span id='topic+randomize_vl_cpp'></span>

<h3>Description</h3>

<p>Randomize a velocity with the given probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_vl_cpp(vl, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_vl_cpp_+3A_vl">vl</code></td>
<td>
<p>a velocity list</p>
</td></tr>
<tr><td><code id="randomize_vl_cpp_+3A_probs">probs</code></td>
<td>
<p>the probabilities of each value in the set -1,0,1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a velocity list with randomized values
</p>

<hr>
<h2 id='rbn.dbn.fit'>Simulates random samples from a fitted DBN</h2><span id='topic+rbn.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn's <code><a href="bnlearn.html#topic+rbn">rbn</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
rbn(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbn.dbn.fit_+3A_x">x</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="rbn.dbn.fit_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="rbn.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sampled dataset
</p>

<hr>
<h2 id='recount_arcs_exp'>Experimental function that recounts the number of arcs in the position</h2><span id='topic+recount_arcs_exp'></span>

<h3>Description</h3>

<p>Experimental function that recounts the number of arcs in the position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recount_arcs_exp(ps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recount_arcs_exp_+3A_ps">ps</code></td>
<td>
<p>a position vector of natural numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of arcs
</p>

<hr>
<h2 id='reduce_freq'>Reduce the frequency of the time series data in a data.table</h2><span id='topic+reduce_freq'></span>

<h3>Description</h3>

<p>In a time series dataset, there is a time difference between one row and the 
next one. This function reduces the number of rows from its current frequency
to the desired one by averaging batches of rows. Instead of the frequency in Hz, the 
number of seconds between rows is asked (Hz = 1/s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_freq(dt, obj_freq, curr_freq, id_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_freq_+3A_dt">dt</code></td>
<td>
<p>the original data.table</p>
</td></tr>
<tr><td><code id="reduce_freq_+3A_obj_freq">obj_freq</code></td>
<td>
<p>the desired number of seconds between rows</p>
</td></tr>
<tr><td><code id="reduce_freq_+3A_curr_freq">curr_freq</code></td>
<td>
<p>the number of seconds between rows in the original dataset</p>
</td></tr>
<tr><td><code id="reduce_freq_+3A_id_var">id_var</code></td>
<td>
<p>optional variable that labels different time series in a dataset, to avoid averaging values from different processes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data.table with the desired frequency
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's assume that the dataset has a frequency of 4Hz, 0.25 seconds between rows
dt &lt;- dbnR::motor
dim(dt)
# Let's change the frequency to 2Hz, 0.5 seconds between rows
dt &lt;- reduce_freq(dt, obj_freq = 0.5, curr_freq = 0.2)
dim(dt)
</code></pre>

<hr>
<h2 id='rename_nodes_cpp'>Return a list of nodes with the time slice appended up to the desired size
of the network</h2><span id='topic+rename_nodes_cpp'></span>

<h3>Description</h3>

<p>Return a list of nodes with the time slice appended up to the desired size
of the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_nodes_cpp(nodes, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_nodes_cpp_+3A_nodes">nodes</code></td>
<td>
<p>a list with the names of the nodes in the network</p>
</td></tr>
<tr><td><code id="rename_nodes_cpp_+3A_size">size</code></td>
<td>
<p>the size of the DBN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the renamed nodes in each timeslice
</p>

<hr>
<h2 id='residuals.dbn.fit'>Returns the residuals from fitting a DBN</h2><span id='topic+residuals.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="residuals.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the residuals of fitting the network
</p>

<hr>
<h2 id='score'>Computes the score of a BN or a DBN</h2><span id='topic+score'></span>

<h3>Description</h3>

<p>Generic method for computing the score of a BN or a DBN.
Calls bnlearn's <code><a href="#topic+nodes">nodes</a></code> underneath. 
I have to redefine the generic and mask the original for it to work on both 
bn and dbn objects without the user having to import bnlearn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot; or &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the score of the network
</p>

<hr>
<h2 id='score.bn'>Computes the score of a BN or a DBN</h2><span id='topic+score.bn'></span>

<h3>Description</h3>

<p>Generic method for computing the score of a &quot;bn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+score">score</a></code> underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bn'
score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.bn_+3A_object">object</code></td>
<td>
<p>a &quot;bn&quot; object</p>
</td></tr>
<tr><td><code id="score.bn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the score of the network
</p>

<hr>
<h2 id='score.dbn'>Computes the score of a BN or a DBN</h2><span id='topic+score.dbn'></span>

<h3>Description</h3>

<p>Generic method for computing the score of a &quot;dbn&quot; S3 object.
Calls bnlearn's <code><a href="#topic+score">score</a></code> underneath.
The nodes function is specifically coded to look for either the &quot;bn&quot;
or the &quot;bn.fit&quot; method inside bnlearn, so I have to cast the &quot;dbn&quot; class
into &quot;bn&quot; for it to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn'
score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.dbn_+3A_object">object</code></td>
<td>
<p>a &quot;dbn&quot; object</p>
</td></tr>
<tr><td><code id="score.dbn_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the score of the network
</p>

<hr>
<h2 id='shift_values'>Move the window of values backwards in a folded dataset row</h2><span id='topic+shift_values'></span>

<h3>Description</h3>

<p>This function moves the values in t_0, t_1, ..., t_n-1 in a folded dataset row to
t_1, t_2, ..., t_n. All the variables in t_0 will be inputed with NAs and the
obtained row can be used to forecast up to any desired point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_values(f_dt, row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_values_+3A_f_dt">f_dt</code></td>
<td>
<p>a folded dataset</p>
</td></tr>
<tr><td><code id="shift_values_+3A_row">row</code></td>
<td>
<p>the index of the row that is going to be processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one row data.table the shifted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- dbnR::motor
f_dt &lt;- dbnR::fold_dt(dt, size = 2)
s_row &lt;- dbnR::shift_values(f_dt, row = 500)
</code></pre>

<hr>
<h2 id='sigma.dbn.fit'>Returns the standard deviation of the residuals from fitting a DBN</h2><span id='topic+sigma.dbn.fit'></span>

<h3>Description</h3>

<p>Generic method for &quot;dbn.fit&quot; S3 objects. 
Calls bnlearn underneath.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbn.fit'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.dbn.fit_+3A_object">object</code></td>
<td>
<p>the fitted network</p>
</td></tr>
<tr><td><code id="sigma.dbn.fit_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the standard deviation residuals of fitting the network
</p>

<hr>
<h2 id='smooth_ts'>Performs smoothing with the GDBN over a dataset</h2><span id='topic+smooth_ts'></span>

<h3>Description</h3>

<p>Given a dbn.fit object, the size of the net and a folded dataset,
performs a smoothing of a trajectory. Smoothing is the opposite of 
forecasting: given a starting point, predict backwards in time to obtain
the time series that generated that point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_ts(
  dt,
  fit,
  size = NULL,
  obj_vars,
  ini = dim(dt)[1],
  len = ini - 1,
  print_res = TRUE,
  plot_res = TRUE,
  prov_ev = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_ts_+3A_dt">dt</code></td>
<td>
<p>data.table object with the TS data</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_fit">fit</code></td>
<td>
<p>dbn.fit object</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_size">size</code></td>
<td>
<p>number of time slices of the net. Deprecated, will be removed in the future</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_obj_vars">obj_vars</code></td>
<td>
<p>variables to be predicted. Should be in the oldest time step</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_ini">ini</code></td>
<td>
<p>starting point in the dataset to smooth</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_len">len</code></td>
<td>
<p>length of the smoothing</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_print_res">print_res</code></td>
<td>
<p>if TRUE prints the mae and sd metrics of the smoothing</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_plot_res">plot_res</code></td>
<td>
<p>if TRUE plots the results of the smoothing</p>
</td></tr>
<tr><td><code id="smooth_ts_+3A_prov_ev">prov_ev</code></td>
<td>
<p>variables to be provided as evidence in each smoothing step. Should be in the oldest time step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the original values and the results of the smoothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size = 3
data(motor)
dt_train &lt;- motor[200:900]
dt_val &lt;- motor[901:1000]
obj &lt;- c("pm_t_2")
net &lt;- learn_dbn_struc(dt_train, size)
f_dt_train &lt;- fold_dt(dt_train, size)
f_dt_val &lt;- fold_dt(dt_val, size)
fit &lt;- fit_dbn_params(net, f_dt_train, method = "mle-g")
res &lt;- suppressWarnings(smooth_ts(f_dt_val, fit, 
        obj_vars = obj, len = 10, print_res = FALSE, plot_res = FALSE))
</code></pre>

<hr>
<h2 id='time_rename'>Renames the columns in a data.table so that they end in '_t_0'</h2><span id='topic+time_rename'></span>

<h3>Description</h3>

<p>This will rename the columns in a data.table so that
they end in '_t_0', which will be needed when folding the data.table. If
any of the columns already ends in '_t_0', a warning will be issued and
no further operation will be done. There is no need to use this function
to learn a DBN unless some operation with the variable names wants to be 
done prior to folding a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_rename(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_rename_+3A_dt">dt</code></td>
<td>
<p>the data.table to be treated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the renamed data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("motor")
dt &lt;- time_rename(motor)
</code></pre>

<hr>
<h2 id='trunc_geom'>Geometric distribution sampler truncated to a maximum</h2><span id='topic+trunc_geom'></span>

<h3>Description</h3>

<p>A geometric distribution sampler with probability 'p' restricted to values
inside [1, max]. Because of this restriction, very low values of 'p' 
coupled with low 'max' return increasingly uniform populations in 
the interval [1, max].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trunc_geom(p, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trunc_geom_+3A_p">p</code></td>
<td>
<p>the parameter of the geometric distribution</p>
</td></tr>
<tr><td><code id="trunc_geom_+3A_max">max</code></td>
<td>
<p>the maximum value allowed to be sampled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sampled value
</p>

<hr>
<h2 id='vel_plus_vel_cpp'>Add two Velocities</h2><span id='topic+vel_plus_vel_cpp'></span>

<h3>Description</h3>

<p>Add two Velocities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vel_plus_vel_cpp(vl1, vl2, abs_op)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vel_plus_vel_cpp_+3A_vl1">vl1</code></td>
<td>
<p>the first Velocity's causal list</p>
</td></tr>
<tr><td><code id="vel_plus_vel_cpp_+3A_vl2">vl2</code></td>
<td>
<p>the second Velocity's causal list</p>
</td></tr>
<tr><td><code id="vel_plus_vel_cpp_+3A_abs_op">abs_op</code></td>
<td>
<p>the final number of 1,-1 operations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the Velocity's causal list and the number of operations
</p>

<hr>
<h2 id='Velocity'>R6 class that defines velocities affecting causality lists in the PSO</h2><span id='topic+Velocity'></span>

<h3>Description</h3>

<p>Getter of the abs_op attribute.
</p>
<p>return the number of operations that the velocity performs
</p>
<p>Setter of the abs_op attribute. Intended for inside use only. 
This should be a 'protected' function in Java-like OOP, but there's no 
such thing in R6. This function should not be used from outside the
package.
</p>
<p>Randomizes the Velocity's directions. If the seed provided is NULL, no
seed will be used.
</p>
<p>Given a position, returns the velocity that gets this position to the
other.
</p>
<p>Add both velocities directions
</p>
<p>Multiply the Velocity by a constant real number
</p>
<p>This function multiplies the Velocity by a constant real number. 
It is non deterministic by definition. When calculating k*|V|, the 
result will be floored and bounded to the set [-max_op, max_op], where max_op
is the maximum number of arcs that can be present in the network.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Velocity_+3A_n">n</code></td>
<td>
<p>the new number of operations that the velocity performs</p>
</td></tr>
<tr><td><code id="Velocity_+3A_probs">probs</code></td>
<td>
<p>the weight of each value -1,0,1. They define the probability that each of them will be picked</p>
</td></tr>
<tr><td><code id="Velocity_+3A_seed">seed</code></td>
<td>
<p>the seed provided to the random number generation</p>
</td></tr>
<tr><td><code id="Velocity_+3A_ps">ps</code></td>
<td>
<p>a Position object
return the Velocity that gets this position to the new one</p>
</td></tr>
<tr><td><code id="Velocity_+3A_vl">vl</code></td>
<td>
<p>a Velocity object</p>
</td></tr>
<tr><td><code id="Velocity_+3A_k">k</code></td>
<td>
<p>a real number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The velocities will be defined as a causality list where each element in
a causal unit is a pair (v, node) with v being either 0, 1 or -1. 0 means 
that arc remained the same, 1 means that arc was added and -1 means that arc 
was deleted.
</p>


<h3>Fields</h3>


<dl>
<dt><code>abs_op</code></dt><dd><p>Total number of operations 1 or -1 in the velocity</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
