<!DOCTYPE html><html lang="en"><head><title>Help for package tree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cv.tree'><p>Cross-validation for Choosing Tree Complexity</p></a></li>
<li><a href='#deviance.tree'><p>Extract Deviance from a Tree Object</p></a></li>
<li><a href='#misclass.tree'><p>Misclassifications by a Classification Tree</p></a></li>
<li><a href='#na.tree.replace'>
<p>Replace NAs in Predictor Variables</p></a></li>
<li><a href='#partition.tree'><p>Plot the Partitions of a simple Tree Model</p></a></li>
<li><a href='#plot.tree'><p>Plot a Tree Object</p></a></li>
<li><a href='#plot.tree.sequence'>
<p>Plot a Tree Sequence</p></a></li>
<li><a href='#predict.tree'>
<p>Predictions from a Fitted Tree Object</p></a></li>
<li><a href='#prune.tree'>
<p>Cost-complexity Pruning of Tree Object</p></a></li>
<li><a href='#snip.tree'><p>Snip Parts of Tree Objects</p></a></li>
<li><a href='#text.tree'><p>Annotate a Tree Plot</p></a></li>
<li><a href='#tile.tree'><p>Add Class Barcharts to a Classification Tree Plot</p></a></li>
<li><a href='#tree'><p>Fit a Classification or Regression Tree</p></a></li>
<li><a href='#tree.control'><p>Select Parameters for Tree</p></a></li>
<li><a href='#tree.screens'><p>Split Screen for Plotting Trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Classification and Regression Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-44</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), grDevices, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Classification and regression trees.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-10 15:20:41 UTC; ripley</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian Ripley [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Ripley &lt;Brian.Ripley@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-11 10:04:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='cv.tree'>Cross-validation for Choosing Tree Complexity</h2><span id='topic+cv.tree'></span>

<h3>Description</h3>

<p>Runs a K-fold cross-validation experiment to find the deviance or
number of misclassifications as a function of the cost-complexity
parameter <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.tree(object, rand, FUN = prune.tree, K = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.tree_+3A_object">object</code></td>
<td>
<p>An object of class <code>"tree"</code>.</p>
</td></tr>
<tr><td><code id="cv.tree_+3A_rand">rand</code></td>
<td>
<p>Optionally an integer vector of the length the number of
cases used to create <code>object</code>, assigning the cases to different
groups for cross-validation.</p>
</td></tr>
<tr><td><code id="cv.tree_+3A_fun">FUN</code></td>
<td>
<p>The function to do the pruning.</p>
</td></tr>
<tr><td><code id="cv.tree_+3A_k">K</code></td>
<td>
<p>The number of folds of the cross-validation.</p>
</td></tr>
<tr><td><code id="cv.tree_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>FUN</code> applied to <code>object</code>, with component
<code>dev</code> replaced by the cross-validated results from the
sum of the <code>dev</code> components of each fit.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code>, <code><a href="#topic+prune.tree">prune.tree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cpus, package="MASS")
cpus.ltr &lt;- tree(log10(perf) ~ syct + mmin + mmax + cach
     + chmin + chmax, data=cpus)
cv.tree(cpus.ltr, , prune.tree)
</code></pre>

<hr>
<h2 id='deviance.tree'>Extract Deviance from a Tree Object</h2><span id='topic+deviance.tree'></span><span id='topic+deviance.singlenode'></span>

<h3>Description</h3>

<p>Extract deviance from a tree object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree'
deviance(object, detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.tree_+3A_object">object</code></td>
<td>
<p>an object of calls <code>"tree"</code></p>
</td></tr>
<tr><td><code id="deviance.tree_+3A_detail">detail</code></td>
<td>
<p>logical. If true, returns a vector of deviance
contributions from each node.</p>
</td></tr>
<tr><td><code id="deviance.tree_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The overall deviance, or a vector of contributions from the cases
at each node. The overall deviance is the sum over leaves in the
latter case.
</p>

<hr>
<h2 id='misclass.tree'>Misclassifications by a Classification Tree</h2><span id='topic+misclass.tree'></span>

<h3>Description</h3>

<p>Report the number of mis-classifications made by a classification
tree, either overall or at each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misclass.tree(tree, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="misclass.tree_+3A_tree">tree</code></td>
<td>
<p>Object of class <code>"tree"</code>, representing a
classification tree.</p>
</td></tr>
<tr><td><code id="misclass.tree_+3A_detail">detail</code></td>
<td>
<p>If false, report overall number of
mis-classifications. If true, report the number at each node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantities returned are weighted by the observational weights if
these are supplied in the construction of <code>tree</code>.
</p>


<h3>Value</h3>

<p>Either the overall number of misclassifications or the number for each node.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ir.tr &lt;- tree(Species ~., iris)
misclass.tree(ir.tr)
misclass.tree(ir.tr, detail=TRUE)
</code></pre>

<hr>
<h2 id='na.tree.replace'>
Replace NAs in Predictor Variables
</h2><span id='topic+na.tree.replace'></span>

<h3>Description</h3>

<p>Adds a new level called <code>"NA"</code> to any discrete predictor in
a data frame that contains <code>NA</code>s.  Stops if any continuous
predictor contains an <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.tree.replace(frame)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.tree.replace_+3A_frame">frame</code></td>
<td>

<p>data frame used to grow a tree.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function is used via the <code>na.action</code> argument to <code>tree</code>.
</p>


<h3>Value</h3>

<p>data frame such that a new level named <code>"NA"</code> is added to
any discrete predictor in <code>frame</code> with <code>NA</code>s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code>, <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>

<hr>
<h2 id='partition.tree'>Plot the Partitions of a simple Tree Model</h2><span id='topic+partition.tree'></span>

<h3>Description</h3>

<p>Plot the partitions of a tree involving one or two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition.tree(tree, label = "yval", add = FALSE, ordvars, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition.tree_+3A_tree">tree</code></td>
<td>
<p>A object of class <code>"tree"</code>.</p>
</td></tr>
<tr><td><code id="partition.tree_+3A_label">label</code></td>
<td>
<p>A character string giving the column of the frame
component of <code>tree</code> to be used to label the regions.</p>
</td></tr>
<tr><td><code id="partition.tree_+3A_add">add</code></td>
<td>
<p>If true, add to existing plot, otherwise start a new plot.</p>
</td></tr>
<tr><td><code id="partition.tree_+3A_ordvars">ordvars</code></td>
<td>
<p>The ordering of the variables to be used in a 2D
plot. Specify the names in a character string of length 2; the first
will be used on the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="partition.tree_+3A_...">...</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used with a regression or classification tree containing
one or two continuous predictors (only).
</p>
<p>If the tree contains one predictor, the predicted value (a regression
tree) or the probability of the first class (a classification tree) is
plotted against the predictor over its range in the training set.
</p>
<p>If the tree contains two predictors, a plot is made of the space
covered by those two predictors and the partition made by the tree is
superimposed. 
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ir.tr &lt;- tree(Species ~., iris)
ir.tr
ir.tr1 &lt;- snip.tree(ir.tr, nodes = c(12, 7))
summary(ir.tr1)
par(pty = "s")
plot(iris[, 3],iris[, 4], type="n",
     xlab="petal length", ylab="petal width")
text(iris[, 3], iris[, 4], c("s", "c", "v")[iris[, 5]])
partition.tree(ir.tr1, add = TRUE, cex = 1.5)

# 1D example
ir.tr &lt;- tree(Petal.Width ~ Petal.Length, iris)
plot(iris[,3], iris[,4], type="n", xlab="Length", ylab="Width")
partition.tree(ir.tr, add = TRUE, cex = 1.5)
</code></pre>

<hr>
<h2 id='plot.tree'>Plot a Tree Object</h2><span id='topic+plot.tree'></span>

<h3>Description</h3>

<p>Plot a tree object on the current graphical device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree'
plot(x, y = NULL, type = c("proportional", "uniform"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tree_+3A_x">x</code></td>
<td>
<p>an object of class <code>"tree"</code>.</p>
</td></tr>
<tr><td><code id="plot.tree_+3A_y">y</code></td>
<td>
<p>ignored. Used for positional matching of <code>type</code>.</p>
</td></tr>
<tr><td><code id="plot.tree_+3A_type">type</code></td>
<td>
<p>character string. If this partially matches
<code>"uniform"</code>, the branches are of uniform
length. Otherwise they are proportional to the decrease in impurity.</p>
</td></tr>
<tr><td><code id="plot.tree_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An (invisible) list with components <code>x</code> and <code>y</code>
giving the coordinates of the tree nodes.
</p>
<p>As a side effect, the value of <code>type == "uniform"</code> is stored in
the variable <code>.Tree.unif.?</code> in the global environment, where <code>?</code>
is the device number.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code></p>

<hr>
<h2 id='plot.tree.sequence'>
Plot a Tree Sequence
</h2><span id='topic+plot.tree.sequence'></span>

<h3>Description</h3>

<p>Allows the user to plot a tree sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree.sequence'
plot(x, ..., type = "l", ylim = range(x$dev),
    order = c("increasing", "decreasing"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tree.sequence_+3A_x">x</code></td>
<td>
<p>object of class <code>tree.sequence</code>.
This is assumed to be the result of some function that produces
an object with the same named components (<code>size</code>,
<code>deviance</code>, <code>k</code>) as that returned by <code><a href="#topic+prune.tree">prune.tree</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tree.sequence_+3A_order">order</code></td>
<td>
<p>of <code>size</code> on the plot.  Use <code>"decreasing"</code> for
the natural ordering of <code>k</code> and the amount of pruning.  Only
the first character is needed.</p>
</td></tr>
<tr><td><code id="plot.tree.sequence_+3A_type">type</code>, <code id="plot.tree.sequence_+3A_ylim">ylim</code>, <code id="plot.tree.sequence_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code>plot()</code> for class <code>tree.sequence</code>.
It can be invoked by calling <code>plot(x)</code> for an
object <code>x</code> of the appropriate class, or directly by
calling <code>plot.tree.sequence(x)</code> regardless of the
class of the object.
</p>


<h3>Side Effects</h3>

<p>Plots deviance or number of misclassifications (or total loss)
versus size for a sequence of trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cpus, package="MASS")
cpus.ltr &lt;- tree(log(perf) ~ syct + mmin + mmax + cach + chmin + chmax,
                 data = cpus)
plot(prune.tree(cpus.ltr))
</code></pre>

<hr>
<h2 id='predict.tree'>
Predictions from a Fitted Tree Object
</h2><span id='topic+predict.tree'></span>

<h3>Description</h3>

<p>Returns a vector of predicted responses from a fitted tree object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree'
predict(object, newdata = list(),
        type = c("vector", "tree", "class", "where"), 
        split = FALSE, nwts, eps = 1e-3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tree_+3A_object">object</code></td>
<td>

<p>fitted model object of class <code>tree</code>.  This is assumed to be the result
of some function that produces an object with the same named
components as that returned by the <code>tree</code> function.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_newdata">newdata</code></td>
<td>

<p>data frame containing the values at which predictions are required.
The predictors referred to in the right side
of <code>formula(object)</code> must be present by name in <code>newdata</code>.
If missing, fitted values are returned.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_type">type</code></td>
<td>

<p>character string denoting whether the predictions are
returned as a vector (default) or as a tree object.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_split">split</code></td>
<td>

<p>governs the handling of missing values. If false, cases with missing
values are dropped down the tree until a leaf is reached or a node
for which the attribute is missing, and that node is used for
prediction. If <code>split = TRUE</code> cases with missing attributes are
split into fractional cases and dropped down each side of the split.
The predicted values are averaged over the fractions to give the
prediction.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_nwts">nwts</code></td>
<td>

<p>weights for the <code>newdata</code> cases, used when predicting a tree.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_eps">eps</code></td>
<td>

<p>a lower bound for the probabilities, used if events of predicted
probability zero occur in <code>newdata</code> when predicting a tree.
</p>
</td></tr>
<tr><td><code id="predict.tree_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code>predict()</code> for class <code>tree</code>.
It can be invoked by calling <code>predict(x)</code> for an
object <code>x</code> of the appropriate class, or directly by
calling <code>predict.tree(x)</code> regardless of the
class of the object.
</p>


<h3>Value</h3>

<p>If <code>type = "vector"</code>:
vector of predicted responses or, if the response is a factor, matrix
of predicted class probabilities.  This new object is obtained by
dropping <code>newdata</code> down <code>object</code>.  For factor predictors, if an
observation contains a level not used to grow the tree, it is left at
the deepest possible node and <code>frame$yval</code> or <code>frame$yprob</code> at that
node is the prediction.
</p>
<p>If <code>type = "tree"</code>:
an object of class <code>"tree"</code> is returned with new values
for <code>frame$n</code> and <code>frame$dev</code>. If
<code>newdata</code> does not contain a column for the response in the formula
the value of <code>frame$dev</code> will be <code>NA</code>, and if some values in the
response are missing, the some of the deviances will be <code>NA</code>.
</p>
<p>If <code>type = "class"</code>:
for a classification tree, a factor of the  predicted classes (that
with highest posterior probability, with ties split randomly).
</p>
<p>If <code>type = "where"</code>:
the nodes the cases reach.
</p>


<h3>References</h3>

<p>Ripley, B. D. (1996).
<em>Pattern Recognition and Neural Networks.</em>
Cambridge University Press, Cambridge. Chapter 7.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+tree">tree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shuttle, package="MASS")
shuttle.tr &lt;- tree(use ~ ., shuttle, subset=1:253,
                   mindev=1e-6, minsize=2)
shuttle.tr
shuttle1 &lt;- shuttle[254:256, ]  # 3 missing cases
predict(shuttle.tr, shuttle1)
</code></pre>

<hr>
<h2 id='prune.tree'>
Cost-complexity Pruning of Tree Object
</h2><span id='topic+prune.tree'></span><span id='topic+prune.misclass'></span>

<h3>Description</h3>

<p>Determines a nested sequence of subtrees of the supplied tree by
recursively &ldquo;snipping&rdquo; off the least important splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.tree(tree, k = NULL, best = NULL, newdata, nwts,
           method = c("deviance", "misclass"), loss, eps = 1e-3)

prune.misclass(tree, k = NULL, best = NULL, newdata, 
               nwts, loss, eps = 1e-3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune.tree_+3A_tree">tree</code></td>
<td>

<p>fitted model object of class <code>tree</code>.  This is assumed to be the result
of some function that produces an object with the same named
components as that returned by the <code>tree()</code> function.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_k">k</code></td>
<td>

<p>cost-complexity parameter defining either a specific subtree of <code>tree</code>
(<code>k</code> a scalar) or the (optional) sequence of subtrees minimizing the
cost-complexity measure (<code>k</code> a vector). If missing, <code>k</code> is
determined algorithmically.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_best">best</code></td>
<td>

<p>integer requesting the size (i.e. number of terminal nodes) of a
specific subtree in the cost-complexity sequence to be returned. This
is an alternative way to select a subtree than by supplying a scalar
cost-complexity parameter <code>k</code>.  If there is no tree in the sequence of
the requested size, the next largest is returned.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_newdata">newdata</code></td>
<td>

<p>data frame upon which the sequence of cost-complexity subtrees is
evaluated.  If missing, the data used to grow the tree are used.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_nwts">nwts</code></td>
<td>

<p>weights for the <code>newdata</code> cases.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_method">method</code></td>
<td>

<p>character string denoting the measure of node heterogeneity used to
guide cost-complexity pruning.  For regression trees, only the
default, <code>deviance</code>, is accepted.  For classification trees, the
default is <code>deviance</code> and the alternative is <code>misclass</code>
(number of misclassifications or total loss).
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_loss">loss</code></td>
<td>

<p>a matrix giving for each true class (row) the numeric loss of
predicting the class (column).  The classes should be in the order of
the levels of the response.  It is conventional for a loss matrix to
have a zero diagonal.  The default is 0&ndash;1 loss.
</p>
</td></tr>
<tr><td><code id="prune.tree_+3A_eps">eps</code></td>
<td>

<p>a lower bound for the probabilities, used to compute deviances if
events of predicted probability zero occur in <code>newdata</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines a nested sequence of subtrees of the supplied tree by
recursively &quot;snipping&quot; off the least important splits, based upon
the cost-complexity measure.  <code>prune.misclass</code> is an abbreviation for
<code>prune.tree(method = "misclass")</code> for use with <code>cv.tree</code>.
</p>
<p>If <code>k</code> is supplied, the optimal subtree for that value is returned.
</p>
<p>The response as well as the predictors referred to in the right side
of the formula in <code>tree</code> must be present by name in
<code>newdata</code>. These data are dropped down each tree in the
cost-complexity sequence and deviances or losses calculated by
comparing the supplied response to the prediction.  The function
<code><a href="#topic+cv.tree">cv.tree</a>()</code> routinely uses the <code>newdata</code> argument
in cross-validating the pruning procedure.  A <code>plot</code> method
exists for objects of this class.  It displays the value of the
deviance, the number of misclassifications or the total loss for
each subtree in the cost-complexity sequence.  An additional axis
displays the values of the cost-complexity parameter at each subtree.
</p>


<h3>Value</h3>

<p>If <code>k</code> is supplied and is a scalar, a <code>tree</code> object is
returned that minimizes the cost-complexity measure for that <code>k</code>.
If <code>best</code> is supplied, a <code>tree</code> object of size <code>best</code>
is returned.  Otherwise, an object of class <code>tree.sequence</code>
is returned.  The object contains the following components:
</p>
<table role = "presentation">
<tr><td><code>size</code></td>
<td>

<p>number of terminal nodes in each tree in the cost-complexity pruning
sequence.
</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>

<p>total deviance of each tree in the cost-complexity pruning sequence.
</p>
</td></tr>
<tr><td><code>k</code></td>
<td>

<p>the value of the cost-complexity pruning parameter of each tree in 
the sequence.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fgl, package="MASS")
fgl.tr &lt;- tree(type ~ ., fgl)
print(fgl.tr); plot(fgl.tr)

fgl.cv &lt;- cv.tree(fgl.tr,, prune.tree)
for(i in 2:5)  fgl.cv$dev &lt;- fgl.cv$dev +
   cv.tree(fgl.tr,, prune.tree)$dev
fgl.cv$dev &lt;- fgl.cv$dev/5
plot(fgl.cv)
</code></pre>

<hr>
<h2 id='snip.tree'>Snip Parts of Tree Objects</h2><span id='topic+snip.tree'></span>

<h3>Description</h3>

<p><code>snip.tree</code> has two related functions. If <code>nodes</code> is
supplied, it removes those nodes and all their descendants from the
tree.
</p>
<p>If <code>nodes</code> is not supplied, the user is invited to select nodes
interactively; this makes sense only if the tree has already been
plotted. A node is selected by clicking with the left mouse button;
its number and the deviance of the current tree and that which would
remain if that node were removed are printed. Selecting the same node
again causes it to be removed (and the lines of its sub-tree erased).
Clicking any other button terminates the selection process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snip.tree(tree, nodes, xy.save = FALSE,
          digits = getOption("digits") - 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snip.tree_+3A_tree">tree</code></td>
<td>
<p>An object of class <code>"tree"</code>.</p>
</td></tr>
<tr><td><code id="snip.tree_+3A_nodes">nodes</code></td>
<td>
<p>An integer vector giving those nodes that are the roots of
sub-trees to be snipped off. If missing, the user is invited to
select a node at which to snip.</p>
</td></tr>
<tr><td><code id="snip.tree_+3A_xy.save">xy.save</code></td>
<td>
<p>If true, the <code>x</code> and <code>y</code> coordinates selected
interactively are saved as attribute <code>.xy</code> of the returned value.</p>
</td></tr>
<tr><td><code id="snip.tree_+3A_digits">digits</code></td>
<td>
<p>Precision used in printing statistics for selected nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree object containing the nodes that remain after
specified or selected subtrees have been snipped off.
</p>


<h3>Note</h3>

<p>Prior to version 1.0-34, the saved coordinates were place in object
<code>.xy</code> in the workspace.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code>, <code><a href="#topic+prune.tree">prune.tree</a></code>.</p>

<hr>
<h2 id='text.tree'>Annotate a Tree Plot</h2><span id='topic+text.tree'></span>

<h3>Description</h3>

<p>Add text to a tree plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree'
text(x, splits = TRUE, label = "yval", all = FALSE,
     pretty = NULL, digits = getOption("digits") - 3, 
     adj = par("adj"), xpd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text.tree_+3A_x">x</code></td>
<td>
<p>an object of class <code>"tree"</code></p>
</td></tr>
<tr><td><code id="text.tree_+3A_splits">splits</code></td>
<td>
<p>logical. If <code>TRUE</code> the splits are labelled</p>
</td></tr>
<tr><td><code id="text.tree_+3A_label">label</code></td>
<td>
<p>The name of column in the <code>frame</code> component of
<code>x</code>, to be used to label the nodes. Can be <code>NULL</code> to
suppress node-labelling</p>
</td></tr>
<tr><td><code id="text.tree_+3A_all">all</code></td>
<td>
<p>logical. By default, only the leaves are labelled, but if
true interior nodes are also labelled.</p>
</td></tr>
<tr><td><code id="text.tree_+3A_pretty">pretty</code></td>
<td>
<p>the manipulation used for split labels involving
attributes.  See Details.</p>
</td></tr>
<tr><td><code id="text.tree_+3A_digits">digits</code></td>
<td>
<p>significant digits for numerical labels.</p>
</td></tr>
<tr><td><code id="text.tree_+3A_adj">adj</code>, <code id="text.tree_+3A_xpd">xpd</code>, <code id="text.tree_+3A_...">...</code></td>
<td>
<p>graphical parameters such as <code>cex</code> and <code>font</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pretty = 0</code> then the level names of a factor split attributes
are used unchanged.  If <code>pretty = NULL</code>, the levels are presented
by <code>a</code>, <code>b</code>, ... <code>z</code>, <code>0</code> ... <code>5</code>.  If
<code>pretty</code> is a positive integer, <code><a href="base.html#topic+abbreviate">abbreviate</a></code> is
applied to the labels with that value for its argument
<code>minlength</code>.
</p>
<p>If the lettering is vertical (par <code>srt = 90</code>) and <code>adj</code> is
not supplied it is adjusted appropriately.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.tree">plot.tree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ir.tr &lt;- tree(Species ~., iris)
plot(ir.tr)
text(ir.tr)
</code></pre>

<hr>
<h2 id='tile.tree'>Add Class Barcharts to a Classification Tree Plot</h2><span id='topic+tile.tree'></span>

<h3>Description</h3>

<p>This computes the frequencies of level of <code>var</code> for cases
reaching each leaf of the tree, and plots barcharts of the set of
frequencies underneath each leaf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile.tree(tree, var, screen.arg = ascr + 1, axes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tile.tree_+3A_tree">tree</code></td>
<td>
<p>fitted object of class <code>"tree"</code>.</p>
</td></tr>
<tr><td><code id="tile.tree_+3A_var">var</code></td>
<td>
<p>a factor variable to be displayed: by default it is the
response factor of the tree.</p>
</td></tr>
<tr><td><code id="tile.tree_+3A_screen.arg">screen.arg</code></td>
<td>
<p>The screen to be used: default the next after the
currently active screen.</p>
</td></tr>
<tr><td><code id="tile.tree_+3A_axes">axes</code></td>
<td>
<p>logical flag for drawing of axes for the barcharts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of counts of categories (rows) for each leaf (columns). The
principal effect is the plot.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.screens">tree.screens</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fgl, package="MASS")
fgl.tr &lt;- tree(type ~ ., fgl)
summary(fgl.tr)
plot(fgl.tr);  text(fgl.tr, all=TRUE, cex=0.5)
fgl.tr1 &lt;- snip.tree(fgl.tr, node=c(108, 31, 26))
tree.screens()
plot(fgl.tr1)
text(fgl.tr1)
tile.tree(fgl.tr1, fgl$type)
close.screen(all = TRUE)
</code></pre>

<hr>
<h2 id='tree'>Fit a Classification or Regression Tree</h2><span id='topic+tree'></span><span id='topic+print.tree'></span><span id='topic+summary.tree'></span><span id='topic+print.summary.tree'></span><span id='topic+residuals.tree'></span>

<h3>Description</h3>

<p>A tree is grown by binary recursive partitioning using the response in
the specified formula and choosing splits from the terms of the
right-hand-side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(formula, data, weights, subset,
     na.action = na.pass, control = tree.control(nobs, ...),
     method = "recursive.partition",
     split = c("deviance", "gini"),
     model = FALSE, x = FALSE, y = TRUE, wts = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_+3A_formula">formula</code></td>
<td>
<p>A formula expression. The left-hand-side (response)
should be either a numerical vector when a regression tree will be
fitted or a factor, when a classification tree is produced. The
right-hand-side should be a series of numeric or factor
variables separated by <code>+</code>; there should be no interaction
terms. Both <code>.</code> and <code>-</code> are allowed: regression trees can
have <code>offset</code> terms.</p>
</td></tr>
<tr><td><code id="tree_+3A_data">data</code></td>
<td>
<p>A data frame in which to preferentially interpret
<code>formula</code>, <code>weights</code> and <code>subset</code>.</p>
</td></tr>
<tr><td><code id="tree_+3A_weights">weights</code></td>
<td>
<p>Vector of non-negative observational weights; fractional
weights are allowed.</p>
</td></tr>
<tr><td><code id="tree_+3A_subset">subset</code></td>
<td>
<p>An expression specifying the subset of cases to be used.</p>
</td></tr>
<tr><td><code id="tree_+3A_na.action">na.action</code></td>
<td>
<p>A function to filter missing data from the model
frame. The default is <code>na.pass</code> (to do nothing) as <code>tree</code>
handles missing values (by dropping them down the tree as far
as possible).</p>
</td></tr>
<tr><td><code id="tree_+3A_control">control</code></td>
<td>
<p>A list as returned by <code>tree.control</code>.</p>
</td></tr>
<tr><td><code id="tree_+3A_method">method</code></td>
<td>
<p>character string giving the method to use. The only other
useful value is <code>"model.frame"</code>.</p>
</td></tr>
<tr><td><code id="tree_+3A_split">split</code></td>
<td>
<p>Splitting criterion to use.</p>
</td></tr>
<tr><td><code id="tree_+3A_model">model</code></td>
<td>
<p>If this argument is itself a model frame, then the
<code>formula</code> and <code>data</code> arguments are ignored, and
<code>model</code> is used to define the model.  If the argument is
logical and true, the model frame is stored as component
<code>model</code> in the result.</p>
</td></tr>
<tr><td><code id="tree_+3A_x">x</code></td>
<td>
<p>logical. If true, the matrix of variables for each case
is returned.</p>
</td></tr>
<tr><td><code id="tree_+3A_y">y</code></td>
<td>
<p>logical. If true, the response variable is returned.</p>
</td></tr>
<tr><td><code id="tree_+3A_wts">wts</code></td>
<td>
<p>logical. If true, the weights are returned.</p>
</td></tr>
<tr><td><code id="tree_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed to
<code>tree.control</code>. Normally used for <code>mincut</code>, <code>minsize</code>
or <code>mindev</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tree is grown by binary recursive partitioning using the response in
the specified formula and choosing splits from the terms of the
right-hand-side. Numeric variables are divided into
<code class="reqn">X &lt; a</code> and <code class="reqn">X &gt; a</code>; the levels of an unordered factor
are divided into
two non-empty groups. The split which maximizes the reduction in
impurity is chosen, the data set split and the process
repeated. Splitting continues until the terminal nodes are too small or
too few to be split.
</p>
<p>Tree growth is limited to a depth of 31 by the use of integers to
label nodes.
</p>
<p>Factor predictor variables can have up to 32 levels. This limit is
imposed for ease of labelling, but since their use in a classification
tree with three or more levels in a response involves a search over
<code class="reqn">2^{(k-1)}-1</code> groupings for <code class="reqn">k</code> levels,
the practical limit is much less.
</p>


<h3>Value</h3>

<p>The value is an object of class <code>"tree"</code> which has components
</p>
<table role = "presentation">
<tr><td><code>frame</code></td>
<td>
<p>A data frame with a row for each node, and
<code>row.names</code> giving the node numbers. The columns include
<code>var</code>, the variable used at the split (or <code>"&lt;leaf&gt;"</code> for a
terminal node), <code>n</code>, the (weighted) number of cases reaching
that node, <code>dev</code> the deviance of the node, <code>yval</code>, the
fitted value at the node (the mean for regression trees, a majority
class for classification trees) and <code>split</code>, a two-column
matrix of the labels for the left and right splits at the
node. Classification trees also have <code>yprob</code>, a matrix of
fitted probabilities for each response level.</p>
</td></tr>
<tr><td><code>where</code></td>
<td>
<p>An integer vector giving the row number of the frame
detailing the node to which each case is assigned.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The terms of the formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call to <code>Tree</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>If <code>model = TRUE</code>, the model frame.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>x = TRUE</code>, the model matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>If <code>y = TRUE</code>, the response.</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>If <code>wts = TRUE</code>, the weights.</p>
</td></tr>
</table>
<p>and attributes <code>xlevels</code> and, for classification trees,
<code>ylevels</code>.
</p>
<p>A tree with no splits is of class <code>"singlenode"</code> which inherits
from class <code>"tree"</code>.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>References</h3>

<p>Breiman L., Friedman J. H., Olshen R. A., and  Stone,  C. J. (1984)
<em>Classification  and Regression Trees.</em>  Wadsworth.
</p>
<p>Ripley, B. D. (1996)
<em>Pattern Recognition and Neural Networks.</em>
Cambridge University Press, Cambridge. Chapter 7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.control">tree.control</a></code>, <code><a href="#topic+prune.tree">prune.tree</a></code>,
<code><a href="#topic+predict.tree">predict.tree</a></code>, <code><a href="#topic+snip.tree">snip.tree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cpus, package="MASS")
cpus.ltr &lt;- tree(log10(perf) ~ syct+mmin+mmax+cach+chmin+chmax, cpus)
cpus.ltr
summary(cpus.ltr)
plot(cpus.ltr);  text(cpus.ltr)

ir.tr &lt;- tree(Species ~., iris)
ir.tr
summary(ir.tr)
</code></pre>

<hr>
<h2 id='tree.control'>Select Parameters for Tree</h2><span id='topic+tree.control'></span>

<h3>Description</h3>

<p>A utility function for use with the <code>control</code> argument of <code>tree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.control(nobs, mincut = 5, minsize = 10, mindev = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.control_+3A_nobs">nobs</code></td>
<td>
<p>The number of observations in the training set.</p>
</td></tr>
<tr><td><code id="tree.control_+3A_mincut">mincut</code></td>
<td>
<p>The minimum number of observations to include in either
child node.  This is a weighted quantity; the observational weights are used
to compute the &lsquo;number&rsquo;. The default is 5.</p>
</td></tr>
<tr><td><code id="tree.control_+3A_minsize">minsize</code></td>
<td>
<p>The smallest allowed node size: a weighted quantity.  The
default is 10.</p>
</td></tr>
<tr><td><code id="tree.control_+3A_mindev">mindev</code></td>
<td>
<p>The within-node deviance must be at least this times that
of the root node for the node to be split.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>This function produces default values of <code>mincut</code> and
<code>minsize</code>, and ensures that <code>mincut</code> is at most half
<code>minsize</code>.
</p>
<p>To produce a tree that fits the data perfectly, set <code>mindev = 0</code>
and <code>minsize = 2</code>, if the limit on tree depth allows such a tree.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>mincut</code></td>
<td>
<p>The maximum of the input or default <code>mincut</code> and 1</p>
</td></tr>
<tr><td><code>minsize</code></td>
<td>
<p>The maximum of the input or default <code>minsize</code> and 2.</p>
</td></tr>
<tr><td><code>nmax</code></td>
<td>
<p>A estimate of the maximum number of nodes that might be grown.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The input <code>nobs</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The interpretation of <code>mindev</code> given here is that of Chambers and
Hastie (1992, p. 415), and apparently not what is actually implemented
in S.  It seems S uses an absolute bound.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992)
<em>Statistical Models in S</em>. Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree">tree</a></code></p>

<hr>
<h2 id='tree.screens'>Split Screen for Plotting Trees</h2><span id='topic+tree.screens'></span>

<h3>Description</h3>

<p>Splits the screen in a way suitable for using <code>tile.tree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.screens(figs, screen.arg = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.screens_+3A_figs">figs</code></td>
<td>
<p>A specification of the split of the screen. See
<code><a href="graphics.html#topic+split.screen">split.screen</a></code> for the allowed forms.</p>
</td></tr>
<tr><td><code id="tree.screens_+3A_screen.arg">screen.arg</code></td>
<td>
<p>the screen to divide, by default the whole display area.</p>
</td></tr>
<tr><td><code id="tree.screens_+3A_...">...</code></td>
<td>
<p>plot parameters to be passed to <code>par</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of screen numbers for the newly-created screens.
</p>


<h3>Author(s)</h3>

<p>B. D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+tile.tree">tile.tree</a></code>, <code><a href="graphics.html#topic+split.screen">split.screen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fgl, package="MASS")
fgl.tr &lt;- tree(type ~ ., fgl)
summary(fgl.tr)
plot(fgl.tr);  text(fgl.tr, all=TRUE, cex=0.5)
fgl.tr1 &lt;- snip.tree(fgl.tr, node=c(108, 31, 26))
tree.screens()
plot(fgl.tr1)
tile.tree(fgl.tr1, fgl$type)
close.screen(all = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
