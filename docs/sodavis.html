<!DOCTYPE html><html><head><title>Help for package sodavis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sodavis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mich_lung'><p>Gene expression data for Michigan lung cancer study in Beer et al. (2002)</p></a></li>
<li><a href='#pumadyn'><p>Pumadyn dataset</p></a></li>
<li><a href='#s_soda'>
<p>S-SODA algorithm for general index model variable selection</p></a></li>
<li><a href='#s_soda_model'>
<p>S-SODA model estimation.</p></a></li>
<li><a href='#s_soda_pred'>
<p>Predict the response y using S-SODA model.</p></a></li>
<li><a href='#s_soda_pred_grid'>
<p>Predict the response y using S-SODA model in a 2-dimensional grid.</p></a></li>
<li><a href='#soda'>
<p>SODA algorithm for variable and interaction selection</p></a></li>
<li><a href='#soda_trace_CV'>
<p>Calculate a trace of cross-validation error rate for SODA forward-backward procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SODA: Main and Interaction Effects Selection for Logistic
Regression, Quadratic Discriminant and General Index Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), nnet, MASS, mvtnorm</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Yang Li, Jun S. Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yang Li &lt;yangli.stat@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Variable and interaction selection are essential to classification in high-dimensional setting. In this package, we provide the implementation of SODA procedure, which is a forward-backward algorithm that selects both main and interaction effects under logistic regression and quadratic discriminant analysis. We also provide an extension, S-SODA, for dealing with the variable selection problem for semi-parametric models with continuous responses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-13 02:42:04 UTC; yangli</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-13 21:24:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='mich_lung'>Gene expression data for Michigan lung cancer study in Beer et al. (2002)</h2><span id='topic+mich_lung_xx'></span><span id='topic+mich_lung_yy'></span>

<h3>Description</h3>

<p>Gene expression data of 5217 genes for n = 86 subjects,
with 62 subjects in &quot;good outcomes&quot; (class 1) and 24 subjects in &quot;poor outcomes&quot; (class 2), from the microarray study of Beer et al. (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mich_lung)</code></pre>


<h3>Format</h3>

<p>Response variable vector and design matrix on 86 observations for expression of 5217 genes.</p>


<h3>References</h3>

<p>Beer et al. (1999) Gene-expression profiles predict survival of patients with lung adenocarcinoma. <em>Nature medicine</em>, 286(8): 816-824.
</p>

<hr>
<h2 id='pumadyn'>Pumadyn dataset</h2><span id='topic+pumadyn_isample_x'></span><span id='topic+pumadyn_isample_y'></span><span id='topic+pumadyn_osample_x'></span><span id='topic+pumadyn_osample_y'></span>

<h3>Description</h3>

<p>This is a dataset synthetically generated from a realistic simulation of the dynamics of a Unimation Puma 560 robot arm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pumadyn)</code></pre>


<h3>Format</h3>

<p>Response variable vector and design matrix on 4499 in-sample and 3693 out-sample observations for 32 predictor variables.</p>


<h3>References</h3>

<p>Corke, P. I. (1996). A Robotics Toolbox for MATLAB. <em>IEEE Robotics and Automation Magazine</em>, 3 (1): 24-32. 
</p>

<hr>
<h2 id='s_soda'>
S-SODA algorithm for general index model variable selection
</h2><span id='topic+s_soda'></span>

<h3>Description</h3>

<p>S-SODA is an extension of SODA to conduct variable selection for general index models with continuous response. S-SODA first evenly discretizes the continuous response into H slices, and then apply SODA on the discretized response. Compared with existing variable selection methods based on the Sliced Inverse Regression (SIR), SODA requires neither the linearity nor the constant variance condition and is much more robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_soda(x, y, H = 5, gam = 0, minF = 3, norm = F, debug = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_soda_+3A_x">x</code></td>
<td>

<p>The design matrix, of dimensions n * p, without an intercept. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_y">y</code></td>
<td>

<p>The response vector of dimension n * 1.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_h">H</code></td>
<td>

<p>The number of slices.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_gam">gam</code></td>
<td>

<p>EBIC penalization coefficient parameter for SODA.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_minf">minF</code></td>
<td>

<p>Minimum number of steps in forward interaction screening. Default is minF=3.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_norm">norm</code></td>
<td>

<p>If set as True, S-SODA first marginally quantile-normalize each predictor to the standard normal distribution.
</p>
</td></tr>
<tr><td><code id="s_soda_+3A_debug">debug</code></td>
<td>

<p>If print debug information.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>BIC</code></td>
<td>

<p>Trace of extended Bayesian information criterion (EBIC) score.
</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>

<p>Trace of selected variables.
</p>
</td></tr>
<tr><td><code>Term</code></td>
<td>

<p>Trace of selected main and interaction terms.
</p>
</td></tr>
<tr><td><code>best_BIC</code></td>
<td>

<p>Final selected term set EBIC score.
</p>
</td></tr>
<tr><td><code>best_Var</code></td>
<td>

<p>Final selected variables.
</p>
</td></tr>
<tr><td><code>best_Term</code></td>
<td>

<p>Final selected main and interaction terms.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># # (uncomment the code to run)
# # Simulation:  x1 / (1 + x2^2) example 
# N = 500
# x1 = runif(N, -3, +3)
# x2 = runif(N, -3, +3)
# x3 = x1 / exp(x2^2) + rnorm(N, 0, 0.2)
# ss = s_soda_model(cbind(x1,x2), x3, H=25)
# 
# # true surface in grid
# MM = 50
# xx1 = seq(-3, +3, length.out = MM)
# xx2 = seq(-3, +3, length.out = MM)
# yyy = matrix(0, MM, MM)
# for(i in 1:MM)
#   for(j in 1:MM)
#     yyy[i,j] = xx1[i] / exp(xx2[j]^2)
# 
# # predicted surface
# ppp = s_soda_pred_grid(xx1, xx2, ss, po=1)
# 
# par(mfrow=c(1, 2), mar=c(1.75, 3, 1.25, 1.5))
# persp(xx1, xx2, yyy, theta=-45, xlab="X1", ylab="X2", zlab="Y")
# persp(xx1, xx2, ppp, theta=-45, xlab="X1", ylab="X2", zlab="Pred")
# 
# # Pumadyn dataset
# #data(pumadyn);
# #s_soda(pumadyn_isample_x, pumadyn_isample_y, H=25, gam=0)
</code></pre>

<hr>
<h2 id='s_soda_model'>
S-SODA model estimation.
</h2><span id='topic+s_soda_model'></span>

<h3>Description</h3>

<p>S-SODA assumes within each slice the X vector follow multivariate normal distribution. This function estimates the mean vector and covariance matrix of X for each slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_soda_model(x, y, H = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_soda_model_+3A_x">x</code></td>
<td>

<p>The design matrix, of dimensions n * p, without an intercept. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="s_soda_model_+3A_y">y</code></td>
<td>

<p>The response vector of dimension n * 1.
</p>
</td></tr>
<tr><td><code id="s_soda_model_+3A_h">H</code></td>
<td>

<p>The number of slices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>int_h</code></td>
<td>

<p>Slice index.
</p>
</td></tr>
<tr><td><code>int_p</code></td>
<td>

<p>Proportion of samples in each slice.
</p>
</td></tr>
<tr><td><code>int_l</code></td>
<td>

<p>Length of each slice (max - min response).
</p>
</td></tr>
<tr><td><code>int_m</code></td>
<td>

<p>Mean vector of covariates in each slice.
</p>
</td></tr>
<tr><td><code>int_v</code></td>
<td>

<p>Covariance matrix of covariates in each slice.
</p>
</td></tr>
</table>

<hr>
<h2 id='s_soda_pred'>
Predict the response y using S-SODA model.
</h2><span id='topic+s_soda_pred'></span>

<h3>Description</h3>

<p>S-SODA assumes within each slice the X vector follow multivariate normal distribution. This function predicts the response y by reverting the P(X | slice(y)) to P(slice(y) | X), and estimates the E(y|X) as sum_h E(y | slice(y)=h, X) P (slice(y)=h | X)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_soda_pred(x, model, po = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_soda_pred_+3A_x">x</code></td>
<td>

<p>The design matrix, of dimensions n * p, without an intercept. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="s_soda_pred_+3A_model">model</code></td>
<td>

<p>S-SODA model estimated from s_soda_model function.
</p>
</td></tr>
<tr><td><code id="s_soda_pred_+3A_po">po</code></td>
<td>

<p>Order of terms in X to approximate E(y | slice(y)=h, X).  If po=0, E(y | slice(y)=h, X) is the mean of y in slice h.  If po=1, E(y | slice(y)=h, X) is the linear regression of X to predict y in slice h.  If po=2, the linear regression also include 2nd order terms of X.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted response.
</p>

<hr>
<h2 id='s_soda_pred_grid'>
Predict the response y using S-SODA model in a 2-dimensional grid.
</h2><span id='topic+s_soda_pred_grid'></span>

<h3>Description</h3>

<p>Calls function s_soda_pred in a 2-dimensional grid defined by x1 and x2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_soda_pred_grid(xx1, xx2, model, po = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_soda_pred_grid_+3A_xx1">xx1</code></td>
<td>

<p>Grid breakpoints for predictor 1.
</p>
</td></tr>
<tr><td><code id="s_soda_pred_grid_+3A_xx2">xx2</code></td>
<td>

<p>Grid breakpoints for predictor 2.
</p>
</td></tr>
<tr><td><code id="s_soda_pred_grid_+3A_model">model</code></td>
<td>

<p>S-SODA model estimated from s_soda_model.
</p>
</td></tr>
<tr><td><code id="s_soda_pred_grid_+3A_po">po</code></td>
<td>

<p>Order of terms in X to approximate E(y | slice(y)=h, X).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted response.
</p>

<hr>
<h2 id='soda'>
SODA algorithm for variable and interaction selection
</h2><span id='topic+soda'></span>

<h3>Description</h3>

<p>SODA is a forward-backward variable and interaction selection algorithm under logistic regression model with second-order terms.  In the forward stage, a stepwise procedure is conducted to screen for important predictors with both main and interaction effects, and in the backward stage SODA remove insignificant terms so as to optimize the extended BIC (EBIC) criterion.  SODA is applicable for variable selection for logistic regression, linear/quadratic discriminant analysis and other discriminant analysis with generative model being in exponential family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soda(xx, yy, norm = F, debug = F, gam = 0, minF = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soda_+3A_xx">xx</code></td>
<td>

<p>The design matrix, of dimensions n * p, without an intercept. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="soda_+3A_yy">yy</code></td>
<td>

<p>The response vector of dimension n * 1.
</p>
</td></tr>
<tr><td><code id="soda_+3A_norm">norm</code></td>
<td>

<p>Logical flag for xx variable quantile normalization to standard normal, prior to performing
SODA algorithm.  Default is norm=FALSE.  Quantile-normalization is suggested if the data contains
obvious outliers.
</p>
</td></tr>
<tr><td><code id="soda_+3A_debug">debug</code></td>
<td>

<p>Logical flag for printing debug information.
</p>
</td></tr>
<tr><td><code id="soda_+3A_gam">gam</code></td>
<td>

<p>Tuning paramter gamma in extended BIC criterion.
</p>
<p>EBIC for selected set S:
</p>
<p>EBIC = -2 * log-likelihood + |S| * log(n) + 2 * |S| * gamma * log(p)
</p>
</td></tr>
<tr><td><code id="soda_+3A_minf">minF</code></td>
<td>

<p>Minimum number of steps in forward interaction screening. Default is minF=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>EBIC</code></td>
<td>

<p>Trace of extended Bayesian information criterion (EBIC) score.
</p>
</td></tr>
<tr><td><code>Type</code></td>
<td>

<p>Trace of step type (&quot;Forward (Main)&quot;, &quot;Forward (Int)&quot;, &quot;Backward&quot;).
</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>

<p>Trace of selected variables.
</p>
</td></tr>
<tr><td><code>Term</code></td>
<td>

<p>Trace of selected main and interaction terms.
</p>
</td></tr>
<tr><td><code>final_EBIC</code></td>
<td>

<p>Final selected term set EBIC score.
</p>
</td></tr>
<tr><td><code>final_Var</code></td>
<td>

<p>Final selected variables.
</p>
</td></tr>
<tr><td><code>final_Term</code></td>
<td>

<p>Final selected main and interaction terms.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yang Li, Jun S. Liu
</p>


<h3>References</h3>

<p>Li Y, Liu JS. (2017). Robust Variable and Interaction Selection for Logistic Regression and Multiple Index Models. <em>Technical Report</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># # (uncomment the code to run)
# # simulation study with 1 main effect and 2 interactions
# N = 250;
# p = 1000;
# r = 0.5;
# s = 1;
# H = abs(outer(1:p, 1:p, "-"))
# S = s * r^H;
# S[cbind(1:p, 1:p)] = S[cbind(1:p, 1:p)] * s

# xx = as.matrix(data.frame(mvrnorm(N, rep(0,p), S)));
# zz = 1 + xx[,1] - xx[,10]^2 + xx[,10]*xx[,20];
# yy = as.numeric(runif(N) &lt; exp(zz) / (1+exp(zz)))

# res_SODA = soda(xx, yy, gam=0.5);
# cv_SODA  = soda_trace_CV(xx, yy, res_SODA)
# cv_SODA

# # Michigan lung cancer dataset
# data(mich_lung);
# res_SODA = soda(mich_lung_xx, mich_lung_yy, gam=0.5);
# cv_SODA  = soda_trace_CV(mich_lung_xx, mich_lung_yy, res_SODA)
# cv_SODA
</code></pre>

<hr>
<h2 id='soda_trace_CV'>
Calculate a trace of cross-validation error rate for SODA forward-backward procedure
</h2><span id='topic+soda_trace_CV'></span>

<h3>Description</h3>

<p>This function takes a SODA result variable as input, and calculates the cross-validation error for each step of the SODA procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soda_trace_CV(xx, yy, res_SODA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soda_trace_CV_+3A_xx">xx</code></td>
<td>

<p>The design matrix, of dimensions n * p, without an intercept. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="soda_trace_CV_+3A_yy">yy</code></td>
<td>

<p>The response vector of dimension n * 1.
</p>
</td></tr>
<tr><td><code id="soda_trace_CV_+3A_res_soda">res_SODA</code></td>
<td>

<p>SODA result varaible. See example below.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yang Li, Jun S. Liu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Michigan lung cancer dataset (uncomment the code to run)
#data(mich_lung);
#res_SODA = soda(mich_lung_xx, mich_lung_yy, gam=0.5);
#cv_SODA  = soda_trace_CV(mich_lung_xx, mich_lung_yy, res_SODA)
#cv_SODA
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
