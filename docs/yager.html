<!DOCTYPE html><html lang="en"><head><title>Help for package yager</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {yager}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#folds'><p>Generate a list of index for the n-fold cross-validation</p></a></li>
<li><a href='#gen_latin'><p>Generate random numbers of latin hypercube sampling</p></a></li>
<li><a href='#gen_sobol'><p>Generate sobol sequence</p></a></li>
<li><a href='#gen_unifm'><p>Generate Uniform random numbers</p></a></li>
<li><a href='#grnn.fit'><p>Create a general regression neural network</p></a></li>
<li><a href='#grnn.imp'><p>Derive the importance rank of all predictors used in the GRNN</p></a></li>
<li><a href='#grnn.margin'><p>Derive the marginal effect of a predictor used in a GRNN</p></a></li>
<li><a href='#grnn.optmiz_auc'><p>Optimize the optimal value of GRNN smoothing parameter based on AUC</p></a></li>
<li><a href='#grnn.parpred'><p>Calculate predicted values of GRNN by using parallelism</p></a></li>
<li><a href='#grnn.partial'><p>Derive the partial effect of a predictor used in a GRNN</p></a></li>
<li><a href='#grnn.pfi'><p>Derive the PFI rank of all predictors used in the GRNN</p></a></li>
<li><a href='#grnn.predict'><p>Calculate predicted values of GRNN</p></a></li>
<li><a href='#grnn.predone'><p>Calculate a predicted value of GRNN</p></a></li>
<li><a href='#grnn.search_auc'><p>Search for the optimal value of GRNN smoothing parameter based on AUC</p></a></li>
<li><a href='#grnn.search_rsq'><p>Search for the optimal value of GRNN smoothing parameter based on r-square</p></a></li>
<li><a href='#grnn.x_imp'><p>Derive the importance of a predictor used in the GRNN</p></a></li>
<li><a href='#grnn.x_pfi'><p>Derive the permutation feature importance of a predictor used in the GRNN</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Yet Another General Regression Neural Network</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>WenSui Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>WenSui Liu &lt;liuwensui@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Another implementation of general regression neural network in R
    based on Specht (1991) &lt;<a href="https://doi.org/10.1109%2F72.97934">doi:10.1109/72.97934</a>&gt;. It is applicable to the 
    functional approximation or the classification. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statcompute/yager">https://github.com/statcompute/yager</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>datasets, stats, randtoolbox, lhs, MLmetrics, graphics,
parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-25 18:07:29 UTC; liuwensui</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-25 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='folds'>Generate a list of index for the n-fold cross-validation</h2><span id='topic+folds'></span>

<h3>Description</h3>

<p>The function <code>folds</code> generates a list of index for the n-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folds(idx, n, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="folds_+3A_idx">idx</code></td>
<td>
<p>A vector of index list</p>
</td></tr>
<tr><td><code id="folds_+3A_n">n</code></td>
<td>
<p>The number of n folds</p>
</td></tr>
<tr><td><code id="folds_+3A_seed">seed</code></td>
<td>
<p>The seed value to generate random n-fold index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of n-fold index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folds(seq(10), n = 3, seed = 2020)
</code></pre>

<hr>
<h2 id='gen_latin'>Generate random numbers of latin hypercube sampling</h2><span id='topic+gen_latin'></span>

<h3>Description</h3>

<p>The function <code>gen_latin</code> generates a vector of random numbers by latin hypercube sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_latin(min = 0, max = 1, n, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_latin_+3A_min">min</code></td>
<td>
<p>The minimum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_latin_+3A_max">max</code></td>
<td>
<p>The maxinum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_latin_+3A_n">n</code></td>
<td>
<p>The number of random numbers to gernate</p>
</td></tr>
<tr><td><code id="gen_latin_+3A_seed">seed</code></td>
<td>
<p>The seed value of random number generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of random numbers bounded by the min and max
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_latin(0, 1, 10, 2020)
</code></pre>

<hr>
<h2 id='gen_sobol'>Generate sobol sequence</h2><span id='topic+gen_sobol'></span>

<h3>Description</h3>

<p>The function <code>gen_sobol</code> generates a vector of scrambled sobol sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sobol(min = 0, max = 1, n, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_sobol_+3A_min">min</code></td>
<td>
<p>The minimum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_sobol_+3A_max">max</code></td>
<td>
<p>The maxinum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_sobol_+3A_n">n</code></td>
<td>
<p>The number of random numbers to gernate</p>
</td></tr>
<tr><td><code id="gen_sobol_+3A_seed">seed</code></td>
<td>
<p>The seed value of random number generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of sobol sequence bounded by the min and max
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_sobol(0, 1, 10, 2020)
</code></pre>

<hr>
<h2 id='gen_unifm'>Generate Uniform random numbers</h2><span id='topic+gen_unifm'></span>

<h3>Description</h3>

<p>The function <code>gen_unifm</code> generates a vector of uniform random numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_unifm(min = 0, max = 1, n, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_unifm_+3A_min">min</code></td>
<td>
<p>The minimum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_unifm_+3A_max">max</code></td>
<td>
<p>The maxinum value of random numbers</p>
</td></tr>
<tr><td><code id="gen_unifm_+3A_n">n</code></td>
<td>
<p>The number of random numbers to gernate</p>
</td></tr>
<tr><td><code id="gen_unifm_+3A_seed">seed</code></td>
<td>
<p>The seed value of random number generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of uniform random numbers bounded by the min and max
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_unifm(0, 1, 10, 2020)
</code></pre>

<hr>
<h2 id='grnn.fit'>Create a general regression neural network</h2><span id='topic+grnn.fit'></span>

<h3>Description</h3>

<p>The function <code>grnn.fit</code> creates a general regression neural network (GRNN)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.fit(x, y, sigma = 1, w = rep(1, length(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.fit_+3A_x">x</code></td>
<td>
<p>The matrix of predictors</p>
</td></tr>
<tr><td><code id="grnn.fit_+3A_y">y</code></td>
<td>
<p>The vector of response variable</p>
</td></tr>
<tr><td><code id="grnn.fit_+3A_sigma">sigma</code></td>
<td>
<p>The scalar of smoothing parameter</p>
</td></tr>
<tr><td><code id="grnn.fit_+3A_w">w</code></td>
<td>
<p>The vector of weights with default = 1 for each record</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general regression neural network object
</p>


<h3>References</h3>

<p>Donald Specht. (1991). A General Regression Neural Network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
</code></pre>

<hr>
<h2 id='grnn.imp'>Derive the importance rank of all predictors used in the GRNN</h2><span id='topic+grnn.imp'></span>

<h3>Description</h3>

<p>The function <code>grnn.imp</code> derives the importance rank of all predictors used in the GRNN
It essentially is a wrapper around the function <code>grnn.x_imp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.imp(net, class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.imp_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.imp_+3A_class">class</code></td>
<td>
<p>TRUE or FALSE, whether it is for the classification or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with important values of all predictors in the GRNN
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.x_imp">grnn.x_imp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:3])
gnet &lt;- grnn.fit(x = X, y = Y)
## Not run: 
grnn.imp(net = gnet, class = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='grnn.margin'>Derive the marginal effect of a predictor used in a GRNN</h2><span id='topic+grnn.margin'></span>

<h3>Description</h3>

<p>The function <code>grnn.margin</code> derives the marginal effect of a predictor used in a GRNN
by assuming mean values for the rest predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.margin(net, i, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.margin_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.margin_+3A_i">i</code></td>
<td>
<p>The ith predictor in the GRNN</p>
</td></tr>
<tr><td><code id="grnn.margin_+3A_plot">plot</code></td>
<td>
<p>TRUE or FALSE to plot the marginal effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the marginal effect or a dataframe of the marginal effect
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.partial">grnn.partial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.margin(gnet, 1, plot = FALSE)
</code></pre>

<hr>
<h2 id='grnn.optmiz_auc'>Optimize the optimal value of GRNN smoothing parameter based on AUC</h2><span id='topic+grnn.optmiz_auc'></span>

<h3>Description</h3>

<p>The function <code>grnn.optmiz_auc</code> optimize the optimal value of GRNN smoothing parameter by cross-validation.
It is applicable to the classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.optmiz_auc(net, lower = 0, upper, nfolds = 4, seed = 1, method = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.optmiz_auc_+3A_net">net</code></td>
<td>
<p>A GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.optmiz_auc_+3A_lower">lower</code></td>
<td>
<p>A scalar for the lower bound of the smoothing parameter</p>
</td></tr>
<tr><td><code id="grnn.optmiz_auc_+3A_upper">upper</code></td>
<td>
<p>A scalar for the upper bound of the smoothing parameter</p>
</td></tr>
<tr><td><code id="grnn.optmiz_auc_+3A_nfolds">nfolds</code></td>
<td>
<p>A scalar for the number of n-fold, 4 by default</p>
</td></tr>
<tr><td><code id="grnn.optmiz_auc_+3A_seed">seed</code></td>
<td>
<p>The seed value for the n-fold cross-validation, 1 by default</p>
</td></tr>
<tr><td><code id="grnn.optmiz_auc_+3A_method">method</code></td>
<td>
<p>A scalar referring to the optimization method, 1 for Golden section searc and 2 for Brent’s method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The best outcome
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.search_auc">grnn.search_auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
## Not run: 
grnn.optmiz_auc(net = gnet, lower = 3, upper = 7, nfolds = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='grnn.parpred'>Calculate predicted values of GRNN by using parallelism</h2><span id='topic+grnn.parpred'></span>

<h3>Description</h3>

<p>The function <code>grnn.parpred</code> calculates a vector of GRNN predicted values based on an input matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.parpred(net, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.parpred_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.parpred_+3A_x">x</code></td>
<td>
<p>The matrix of input predictors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.predict">grnn.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.parpred(gnet, X[seq(5), ])
</code></pre>

<hr>
<h2 id='grnn.partial'>Derive the partial effect of a predictor used in a GRNN</h2><span id='topic+grnn.partial'></span>

<h3>Description</h3>

<p>The function <code>grnn.partial</code> derives the partial effect of a predictor used in a GRNN
by average-out values of the rest predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.partial(net, i, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.partial_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.partial_+3A_i">i</code></td>
<td>
<p>The ith predictor in the GRNN</p>
</td></tr>
<tr><td><code id="grnn.partial_+3A_plot">plot</code></td>
<td>
<p>TRUE or FALSE to plot the partial effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the partial effect or a dataframe of the partial effect
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.margin">grnn.margin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
## Not run: 
grnn.partial(gnet, 1, plot = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='grnn.pfi'>Derive the PFI rank of all predictors used in the GRNN</h2><span id='topic+grnn.pfi'></span>

<h3>Description</h3>

<p>The function <code>grnn.pfi</code> derives the PFI rank of all predictors used in the GRNN
It essentially is a wrapper around the function <code>grnn.x_pfi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.pfi(net, class = FALSE, ntry = 1000, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.pfi_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.pfi_+3A_class">class</code></td>
<td>
<p>TRUE or FALSE, whether it is for the classification or not</p>
</td></tr>
<tr><td><code id="grnn.pfi_+3A_ntry">ntry</code></td>
<td>
<p>The number of random permutations to try, 1e3 times by default</p>
</td></tr>
<tr><td><code id="grnn.pfi_+3A_seed">seed</code></td>
<td>
<p>The seed value for the random permutation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with PFI values of all predictors in the GRNN
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.x_pfi">grnn.x_pfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:3])
gnet &lt;- grnn.fit(x = X, y = Y)
## Not run: 
grnn.pfi(net = gnet, class = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='grnn.predict'>Calculate predicted values of GRNN</h2><span id='topic+grnn.predict'></span>

<h3>Description</h3>

<p>The function <code>grnn.predict</code> calculates a vector of GRNN predicted values based on an input matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.predict(net, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.predict_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.predict_+3A_x">x</code></td>
<td>
<p>The matrix of input predictors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.predone">grnn.predone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.predict(gnet, X[seq(5), ])
</code></pre>

<hr>
<h2 id='grnn.predone'>Calculate a predicted value of GRNN</h2><span id='topic+grnn.predone'></span>

<h3>Description</h3>

<p>The function <code>grnn.predone</code> calculates a predicted value of GRNN based on an input vector
</p>
<p>The function <code>grnn.predone</code> calculates a predicted value of GRNN based on an input vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.predone(net, x, type = 1)

grnn.predone(net, x, type = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.predone_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.predone_+3A_x">x</code></td>
<td>
<p>The vector of input predictors</p>
</td></tr>
<tr><td><code id="grnn.predone_+3A_type">type</code></td>
<td>
<p>A scalar, 1 for euclidean distance and 2 for manhattan distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of the predicted value
</p>
<p>A scalar of the predicted value
</p>


<h3>References</h3>

<p>Donald Specht. (1991). A General Regression Neural Network.
</p>
<p>Donald Specht. (1991). A General Regression Neural Network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.fit">grnn.fit</a></code>
</p>
<p><code><a href="#topic+grnn.fit">grnn.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
for (i in seq(5)) print(grnn.predone(gnet, X[i, ]))
data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
for (i in seq(5)) print(grnn.predone(gnet, X[i, ]))
</code></pre>

<hr>
<h2 id='grnn.search_auc'>Search for the optimal value of GRNN smoothing parameter based on AUC</h2><span id='topic+grnn.search_auc'></span>

<h3>Description</h3>

<p>The function <code>grnn.search_auc</code> searches for the optimal value of GRNN smoothing parameter by cross-validation.
It is applicable to the classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.search_auc(net, sigmas, nfolds = 4, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.search_auc_+3A_net">net</code></td>
<td>
<p>A GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.search_auc_+3A_sigmas">sigmas</code></td>
<td>
<p>A numeric vector to search for the best smoothing parameter</p>
</td></tr>
<tr><td><code id="grnn.search_auc_+3A_nfolds">nfolds</code></td>
<td>
<p>A scalar for the number of n-fold, 4 by default</p>
</td></tr>
<tr><td><code id="grnn.search_auc_+3A_seed">seed</code></td>
<td>
<p>The seed value for the n-fold cross-validation, 1 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of all searching outcomes and the best outcome
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.search_auc(net = gnet, sigmas = c(3, 5, 7), nfolds = 2)
</code></pre>

<hr>
<h2 id='grnn.search_rsq'>Search for the optimal value of GRNN smoothing parameter based on r-square</h2><span id='topic+grnn.search_rsq'></span>

<h3>Description</h3>

<p>The function <code>grnn.search_rsq</code> searches for the optimal value of GRNN smoothing parameter by cross-validation.
It is applicable to the functional approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.search_rsq(net, sigmas, nfolds = 4, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.search_rsq_+3A_net">net</code></td>
<td>
<p>A GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.search_rsq_+3A_sigmas">sigmas</code></td>
<td>
<p>A numeric vector to search for the best smoothing parameter</p>
</td></tr>
<tr><td><code id="grnn.search_rsq_+3A_nfolds">nfolds</code></td>
<td>
<p>A scalar for the number of n-fold, 4 by default</p>
</td></tr>
<tr><td><code id="grnn.search_rsq_+3A_seed">seed</code></td>
<td>
<p>The seed value for the n-fold cross-validation, 1 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of all searching outcomes and the best outcome
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.search_rsq(net = gnet, sigmas = seq(3), nfolds = 2)
</code></pre>

<hr>
<h2 id='grnn.x_imp'>Derive the importance of a predictor used in the GRNN</h2><span id='topic+grnn.x_imp'></span>

<h3>Description</h3>

<p>The function <code>grnn.x_imp</code> derives the importance of a predictor used in the GRNN
by using the loss of predictability after eliminating the impact of the predictor in interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.x_imp(net, i, class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.x_imp_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.x_imp_+3A_i">i</code></td>
<td>
<p>The ith predictor in the GRNN</p>
</td></tr>
<tr><td><code id="grnn.x_imp_+3A_class">class</code></td>
<td>
<p>TRUE or FALSE, whether it is for the classification or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the variable name and two values of importance measurements, namely &quot;imp1&quot; and &quot;imp2&quot;.
The &quot;imp1&quot; measures the loss of predictability after replacing all values of the predictor with its mean.
The &quot;imp2&quot; measures the loss of predictability after dropping the predictor from the GRNN.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.x_pfi">grnn.x_pfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.x_imp(net = gnet, 1)
</code></pre>

<hr>
<h2 id='grnn.x_pfi'>Derive the permutation feature importance of a predictor used in the GRNN</h2><span id='topic+grnn.x_pfi'></span>

<h3>Description</h3>

<p>The function <code>grnn.x_pfi</code> derives the permutation feature importance (PFI) of a predictor used in the GRNN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grnn.x_pfi(net, i, class = FALSE, ntry = 1000, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grnn.x_pfi_+3A_net">net</code></td>
<td>
<p>The GRNN object generated by grnn.fit()</p>
</td></tr>
<tr><td><code id="grnn.x_pfi_+3A_i">i</code></td>
<td>
<p>The ith predictor in the GRNN</p>
</td></tr>
<tr><td><code id="grnn.x_pfi_+3A_class">class</code></td>
<td>
<p>TRUE or FALSE, whether it is for the classification or not</p>
</td></tr>
<tr><td><code id="grnn.x_pfi_+3A_ntry">ntry</code></td>
<td>
<p>The number of random permutations to try, 1e3 times by default</p>
</td></tr>
<tr><td><code id="grnn.x_pfi_+3A_seed">seed</code></td>
<td>
<p>The seed value for the random permutation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the variable name and the PFI value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grnn.x_imp">grnn.x_imp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package = "datasets")
Y &lt;- ifelse(iris[, 5] == "setosa", 1, 0)
X &lt;- scale(iris[, 1:4])
gnet &lt;- grnn.fit(x = X, y = Y)
grnn.x_pfi(net = gnet, 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
