<!DOCTYPE html><html><head><title>Help for package pez</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pez}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cc.manip'><p>Manipulating and examining comparative.comm objects</p></a></li>
<li><a href='#comparative.comm'><p>Creates a community comparative ecology object, the basis of all</p>
functions in pez</a></li>
<li><a href='#ConDivSim'><p>Null models for functional-phylogenetic diversity</p></a></li>
<li><a href='#dist.xxx'><p>Make co-existence matrices based on phylogeny (and/or) traits, and</p>
community or environemntal overlap</a></li>
<li><a href='#drop_tip'><p>Trim a phylogeny</p></a></li>
<li><a href='#eco.scape'><p>eco.space scape simulation with a macro-ecological focus</p></a></li>
<li><a href='#eco.xxx.regression'><p>eco.xxx.regression</p></a></li>
<li><a href='#eco.xxx.regression.list'><p>List of eco.xxx.regressions</p></a></li>
<li><a href='#fibre.plot'><p><code>fibre.plot</code> (fibrously) plots a phylogeny</p></a></li>
<li><a href='#fingerprint.regression'><p>Regress trait evolution against trait ecology (following</p>
Cavender-Bares et al. 2004)</a></li>
<li><a href='#generic.metrics'><p>Calculate any metric(s) (and compare with null distributions)</p></a></li>
<li><a href='#laja'><p>Macroinvertebrate samples from the Rio Laja of Mexico</p></a></li>
<li><a href='#pez'><p>Phylogenetics for the Environmental Sciences</p></a></li>
<li><a href='#pez-internal'><p>Internal pez Functions</p></a></li>
<li><a href='#pez.dispersion'><p>Calculate (phylogenetic) dispersion: examine assemblages in the</p>
context of a source pools</a></li>
<li><a href='#pez.dissimilarity'><p>Calculate (phylogenetic) dissimilarity: compare assemblages to</p>
one-another</a></li>
<li><a href='#pez.endemism'><p>Calculate (phylogenetic) endemism</p></a></li>
<li><a href='#pez.evenness'><p>Calculate (phylogenetic) evenness: examine assemblage composition</p>
and abundance</a></li>
<li><a href='#pez.metrics'><p>Phylogenetic and functional trait metrics within pez</p></a></li>
<li><a href='#pez.shape'><p>Calculate (phylogenetic) shape: examine assemblage composition</p></a></li>
<li><a href='#pglmm'><p>Phylogenetic Generalised Linear Mixed Model for Community Data</p></a></li>
<li><a href='#phy.build'><p>Build a novel phylogeny from existing data</p></a></li>
<li><a href='#phy.signal'><p>Calculate phylogenetic &lsquo;signal&rsquo;</p></a></li>
<li><a href='#plot.comparative.comm'><p>Dot-plots of community presence/absence or abundance</p></a></li>
<li><a href='#scape'><p>Simulate phylogenetic community structure across a landscape</p></a></li>
<li><a href='#sim.meta'><p>Simulate a meta-community (and its phylogeny)</p></a></li>
<li><a href='#sim.phy'><p>Simulate phylogenies</p></a></li>
<li><a href='#trait.asm'><p>Produces simulated communities based on species attributes</p></a></li>
<li><a href='#traitgram.cc'><p>Traitgram for comparative community object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetics for the Environmental Sciences</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Author:</td>
<td>William D. Pearse, Marc W. Cadotte, Jeannine Cavender-Bares,
    Anthony R. Ives, Caroline Tucker, Steve C. Walker, Matthew R. Helmus</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William D. Pearse &lt;will.pearse@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Eco-phylogenetic and community phylogenetic analyses.
    Keeps community ecological and phylogenetic data matched up and
    comparable using 'comparative.comm' objects. Wrappers for common
    community phylogenetic indices ('pez.shape', 'pez.evenness',
    'pez.dispersion', and 'pez.dissimilarity' metrics). Implementation
    of Cavender-Bares (2004) correlation of phylogenetic and
    ecological matrices ('fingerprint.regression'). Phylogenetic
    Generalised Linear Mixed Models (PGLMMs; 'pglmm') following Ives &amp;
    Helmus (2011) and Rafferty &amp; Ives (2013). Simulation of null
    assemblages, traits, and phylogenies ('scape', 'sim.meta.comm').</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.6), lme4 (&ge; 1.1-7), formatR (&ge; 1.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caper (&ge; 0.5-2), picante (&ge; 1.6-2), quantreg (&ge; 5.05),
mvtnorm (&ge; 1.0-0), vegan (&ge; 2.0-10), ade4 (&ge; 1.6-2), FD (&ge;
1.0-12), Matrix (&ge; 1.1-4), methods (&ge; 3.1.0), animation (&ge;
2.4-0), phytools (&ge; 0.6-60)</td>
</tr>
<tr>
<td>Depends:</td>
<td>ape (&ge; 3.1-4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-31 16:05:27 UTC; will</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-31 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cc.manip'>Manipulating and examining comparative.comm objects</h2><span id='topic+cc.manip'></span><span id='topic++5B.comparative.comm'></span><span id='topic+trait.names'></span><span id='topic+env.names'></span><span id='topic+species'></span><span id='topic+species+3C-'></span><span id='topic+sites'></span><span id='topic+sites+3C-'></span><span id='topic+traits+3C-'></span><span id='topic+traits'></span><span id='topic+env+3C-'></span><span id='topic+env'></span><span id='topic+comm+3C-'></span><span id='topic+comm'></span><span id='topic+tree'></span><span id='topic+phy'></span><span id='topic+tree+3C-'></span><span id='topic+phy+3C-'></span><span id='topic+assemblage.phylogenies'></span><span id='topic+as.data.frame.comparative.comm'></span><span id='topic+within.comparative.comm'></span>

<h3>Description</h3>

<p>As described in the vignette, we recommend using these wrappers to
manipulate species and site data, as it guarantees that everything
will be kept consistent across all parts of the
<code><a href="#topic+comparative.comm">comparative.comm</a></code> object. With them, you can drop
species, sites, and work directly with each part of your data. You
can also manipulate your <code><a href="#topic+comparative.comm">comparative.comm</a></code> object's
<code>phy</code>, <code>data</code>, <code>env</code>, and <code>comm</code> slots directly
if you wish, but altering the object directly yourself runs the
risk of things getting unsynchronised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'comparative.comm'
x[sites, spp, warn = FALSE]

trait.names(object)

env.names(object)

species(x)

species(x) &lt;- value

sites(x)

sites(x) &lt;- value

traits(x) &lt;- value

traits(x)

env(x) &lt;- value

env(x)

comm(x) &lt;- value

comm(x)

tree(x)

phy(x)

tree(x) &lt;- value

phy(x) &lt;- value

assemblage.phylogenies(data)

## S3 method for class 'comparative.comm'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  abundance.weighted = FALSE,
  ...
)

## S3 method for class 'comparative.comm'
within(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc.manip_+3A_x">x</code></td>
<td>
<p><code>comparative.comm</code> object</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_sites">sites</code></td>
<td>
<p>numbers of sites to be kept or dropped from <code>x</code>;
must be given as numbers. For example, <code>x[1:5,]</code>, or
<code>x[-1:-5,]</code>, but not <code>x[c("site a", "site b"),]</code>.</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_spp">spp</code></td>
<td>
<p>numbers of species to be kept or dropped from <code>x</code>;
must be given as numbers. For example, <code>x[,1:5]</code>, or
<code>x[,-1:-5]</code>, but not <code>x[c("sp a", "sp b"),]</code>.</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_warn">warn</code></td>
<td>
<p>whether to warn if species/sites are dropped when
creating object (default: TRUE)</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_value">value</code></td>
<td>
<p>when altering a <code><a href="#topic+comparative.comm">comparative.comm</a></code>
object's internal structure, the thing that you're inserting into
it!</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_row.names">row.names</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_optional">optional</code></td>
<td>
<p>ignored
presence-absence dataset (default: FALSE)</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>whether to create to create a</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cc.manip_+3A_expr">expr</code></td>
<td>
<p>expression to be evaluated within the scope of
<code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Names of the traits or environmental variables
</p>


<h3>Note</h3>

<p>As described in <code><a href="#topic+comparative.comm">comparative.comm</a></code>, each
<code><a href="#topic+comparative.comm">comparative.comm</a></code> object contains a phylogeny
(<code>$phy</code>) and a site-by-species community matrix (as used in
<code><a href="vegan.html#topic+vegan">vegan</a></code>). Optionally, it may contain a
<code>data.frame</code> of trait data (each row a species, each column a
trait ) *called <code>data</code>* for compatibility with
<code><a href="caper.html#topic+comparative.data">comparative.data</a></code>.
</p>


<h3>See Also</h3>

<p>comparative.comm plot.comaparative.comm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
#Subset on species, then sites
data &lt;- data[1:5,]
data &lt;- data[,1:5]
#Site and species can be manipulated
species(data)
sites(data)[1:3] &lt;- c("lovely", "invert", "sites")
#Other data can be viewed
trait.names(data)
env.names(data)
#Get assemblage phylogenies of all sites
assemblage.phylogenies(data)
#Add some trait/env data in
traits(data)$new.trait &lt;- sample(letters, nrow(comm(data)), replace=TRUE)
env(data)$new.env &lt;- sample(letters, ncol(comm(data)), replace=TRUE)
#Manipulate/check phylogeny and community matrix
phy(data) #...tree(data) works too...
comm(data)[1,3] &lt;- 3
comm(data) &lt;- comm(data)[-3,]
</code></pre>

<hr>
<h2 id='comparative.comm'>Creates a community comparative ecology object, the basis of all
functions in pez</h2><span id='topic+comparative.comm'></span><span id='topic+print.comparative.comm'></span>

<h3>Description</h3>

<p>Basic checking of whether the input data match up is performed; you
need only supply <code>comm</code> and <code>phy</code>, nothing else is
mandatory. You can manipulate the internals of
<code>comparative.comm</code>, or use the wrappers inside <code>pez</code> to
keep everything in order. Examples of these features are given
below; they are described in detailed at <code><a href="#topic+cc.manip">cc.manip</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparative.comm(
  phy,
  comm,
  traits = NULL,
  env = NULL,
  warn = TRUE,
  force.root = -1
)

## S3 method for class 'comparative.comm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparative.comm_+3A_phy">phy</code></td>
<td>
<p>phylogeny (in <code><a href="ape.html#topic+phylo">phylo</a></code> format) of
species</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_comm">comm</code></td>
<td>
<p>community <code>matrix</code> (as used in
<code><a href="vegan.html#topic+vegan">vegan</a></code>) with species as columns and rows as
communities. Must contain <code>rownames</code> and <code>colnames</code>; NAs
are not checked for but probably unwise.</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_traits">traits</code></td>
<td>
<p><code>data.frame</code> of species traits, with
<code>rownames</code> matching <code>comm</code>. Saved in the <code>data</code> slot
of the resulting <code>comparative.comm</code> object for compatibility
with <code><a href="caper.html#topic+comparative.data">comparative.data</a></code>.</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_env">env</code></td>
<td>
<p><code>data.frame</code> of environmental data with
<code>rownames</code> matching <code>comm</code></p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_warn">warn</code></td>
<td>
<p>whether to warn if species/sites are dropped when
creating object (default: TRUE)</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_force.root">force.root</code></td>
<td>
<p>if <code>phy</code> is unrooted, a <code>root.edge</code> of
force.root will be added (default: -1, which means this will never
happen). Rarely needed, rarely advisable.</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_x">x</code></td>
<td>
<p><code>comparative.comm</code> object to be printed</p>
</td></tr>
<tr><td><code id="comparative.comm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>comparative.comm object
</p>


<h3>Note</h3>

<p><code>comparative.comm</code> is compatible with
<code><a href="caper.html#topic+comparative.data">comparative.data</a></code>; this means
that the slot for species' trait data is called <code>data</code>. I
appreciate this is somewhat unwieldy, but hopefully you agree it is
helpful in the long-term.
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.comparative.comm">plot.comparative.comm</a></code> <code><a href="#topic+cc.manip">cc.manip</a></code> <code>link[caper:comparative.data]{comparative.data}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
#Subset on species, then sites
data &lt;- data[1:5,]
data &lt;- data[,1:5]
#Site and species can be manipulated
species(data)
sites(data)[1:3] &lt;- c("lovely", "invert", "sites")
#Other data can be viewed
trait.names(data)
env.names(data)
#Get assemblage phylogenies of all sites
assemblage.phylogenies(data)
#Do some manual manipulation of your objects (NOTE: $data for traits)
data$data$new.trait &lt;- sample(letters, nrow(data$comm), replace=TRUE)
</code></pre>

<hr>
<h2 id='ConDivSim'>Null models for functional-phylogenetic diversity</h2><span id='topic+ConDivSim'></span>

<h3>Description</h3>

<p>Simulate expectations (under a null model) of mean pairwise distance for 
a set of communities with different species richness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConDivSim(object, type = "traits", n.sim = 100, plot = TRUE, disp99 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConDivSim_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+comparative.comm">comparative.comm</a></code> object, with
presence-absence community data.</p>
</td></tr>
<tr><td><code id="ConDivSim_+3A_type">type</code></td>
<td>
<p>character string giving the type of distance matrix on
which the mean pairwise distance is based. Either &quot;trait&quot; or &quot;phy&quot;
to a phylogenetic or trait-based distance matrix, or an actual
matrix to use (e.g., one from <code><a href="#topic+funct.phylo.dist">funct.phylo.dist</a></code>)</p>
</td></tr>
<tr><td><code id="ConDivSim_+3A_n.sim">n.sim</code></td>
<td>
<p>The number of permutations of the presence vector used to 
make the estimations.</p>
</td></tr>
<tr><td><code id="ConDivSim_+3A_plot">plot</code></td>
<td>
<p>TRUE or FALSE to make the plot of the expected average 
mean pairwise distance, and the 5-95% confidence interval.</p>
</td></tr>
<tr><td><code id="ConDivSim_+3A_disp99">disp99</code></td>
<td>
<p>Display the 99% interval?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot == TRUE</code>, then a surface is drawn giving the
null distribution.  Lighter shades of gray give larger intervals
with categories: 0.005-0.995 = 99%, 0.025-0.975 = 95%, 0.05-0.95
= 90%, 0.25-0.75 = 50%.
</p>


<h3>Value</h3>

<p><code>matrix</code> with quantiles of mean pairwise distances for
all quantiles of of mean pairwise distance, with one row for the
range of species richnesses in the data (see column SpRich).
</p>


<h3>Note</h3>

<p>No serious checking of user-provided matrices is performed;
this is both useful and dangerous!
</p>


<h3>Author(s)</h3>

<p>Steve Walker, wrappers by Will Pearse
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.phy">sim.phy</a></code> <code><a href="#topic+scape">scape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
#Must have all species present in at least one community!
#...and must be presence-absence data
data &lt;- data[,colSums(data$comm) &gt; 0]
data$comm[data$comm&gt;1] &lt;- 1
sims &lt;- ConDivSim(data)
#...without traits...
sims.phy &lt;- ConDivSim(data, type="phy")
</code></pre>

<hr>
<h2 id='dist.xxx'>Make co-existence matrices based on phylogeny (and/or) traits, and
community or environemntal overlap</h2><span id='topic+dist.xxx'></span><span id='topic+comm.dist'></span><span id='topic+comm.dist.matrix'></span><span id='topic+comm.dist.comparative.comm'></span><span id='topic+traits.dist'></span><span id='topic+traits.dist.comparative.comm'></span><span id='topic+traits.dist.default'></span><span id='topic+traits.dist.data.frame'></span><span id='topic+dist.func.default'></span><span id='topic+phylo.dist'></span><span id='topic+phylo.dist.phylo'></span><span id='topic+phylo.dist.comparative.comm'></span><span id='topic+funct.phylo.dist'></span><span id='topic+pianka.dist'></span><span id='topic+pianka.dist.matrix'></span><span id='topic+pianka.dist.comparative.comm'></span>

<h3>Description</h3>

<p>Make co-existence matrices based on phylogeny (and/or) traits, and
community or environemntal overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.dist(x)

## S3 method for class 'matrix'
comm.dist(x)

## S3 method for class 'comparative.comm'
comm.dist(x)

traits.dist(x, dist.func = dist.func.default, ...)

## S3 method for class 'comparative.comm'
traits.dist(x, dist.func = dist.func.default, alltogether = TRUE, ...)

## Default S3 method:
traits.dist(x, dist.func = dist.func.default, ...)

## S3 method for class 'data.frame'
traits.dist(x, dist.func = dist.func.default, ...)

dist.func.default(x)

phylo.dist(x, ...)

## S3 method for class 'phylo'
phylo.dist(x, ...)

## S3 method for class 'comparative.comm'
phylo.dist(x, ...)

funct.phylo.dist(x, phyloWeight, p = 2, ...)

pianka.dist(x, ...)

## S3 method for class 'matrix'
pianka.dist(x, env = NULL, ...)

## S3 method for class 'comparative.comm'
pianka.dist(x, alltogether = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.xxx_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_dist.func">dist.func</code></td>
<td>
<p>a function for computing distances.  The default,
<code>dist.func.default</code>, returns a Euclidean distance of the
scaled and centred data.</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_alltogether">alltogether</code></td>
<td>
<p>should one multivariate distance matrix be
computed for all traits at once (DEFAULT; <code>alltogether =
TRUE</code>) or for each trait at a time (<code>alltogether = FALSE</code>)?</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_phyloweight">phyloWeight</code></td>
<td>
<p>phylogenetic weighting parameter (referred to as
<code>a</code> in Cadotte et al. (2013)</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_p">p</code></td>
<td>
<p>exponent giving the exponent to use for combining
functional and phylogenetic distances (the default, <code>p = 2</code>,
gives a Euclidean combination).</p>
</td></tr>
<tr><td><code id="dist.xxx_+3A_env">env</code></td>
<td>
<p>environmental variable to be used to calculate the
distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>comm.dist</code> returns the 1 - co-existence of
species. Look at how this is calcualted; it incorporates
abundances, and if you don't want it to do so simply call it on a
presence/absensence (1/0) matrix.
</p>
<p><code>traits.dist</code> returns the functional trait distance
of species
</p>
<p><code>phylo.dist</code> returns the phylogenetic (cophenetic)
distance of species
</p>
<p><code>funct.phylo.dist</code> returns the combined phylogenetic
and trait distances of species, based on the traitgram approach of
Cadotte et al. (2013).
</p>
<p>Make functional phylogenetic distance matrix
</p>
<p><code>pianka.dist</code> returns the environemntal tolerances
distance matrices of species. Based on Pianka's distance (i.e.,
niche overlap based on environmental variables at co-occuring
sites), as defined in Cavender-Bares et al. (2004) - likely not the
original reference!
</p>


<h3>References</h3>

<p>Cadotte M.A., Albert C.H., &amp; Walker S.C. The ecology of differences: assessing community assembly with trait and evolutionary distances. Ecology Letters 16(10): 1234&ndash;1244.
</p>
<p>Cavender-Bares J., Ackerly D.D., Baum D.A. &amp; Bazzaz F.A. (2004) Phylogenetic overdispersion in Floridian oak communities. The Americant Naturalist 163(6): 823&ndash;843.
</p>

<hr>
<h2 id='drop_tip'>Trim a phylogeny</h2><span id='topic+drop_tip'></span>

<h3>Description</h3>

<p>This is a weak wrapper around <code>ape</code>'s
<code><a href="ape.html#topic+drop.tip">drop.tip</a></code>. Importantly, if asked to drop no species
from a phylogeny, it will just return the phylogeny (not an empty
phylogeny, as <code><a href="ape.html#topic+drop.tip">drop.tip</a></code>) will.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_tip(tree, spp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_tip_+3A_tree">tree</code></td>
<td>
<p>An <code><a href="ape.html#topic+phylo">phylo</a></code> object</p>
</td></tr>
<tr><td><code id="drop_tip_+3A_spp">spp</code></td>
<td>
<p>A vector of species (one, many, or none) to be removed
from <code>tree</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="ape.html#topic+phylo">phylo</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+drop.tip">drop.tip</a></code> <code><a href="ape.html#topic+extract.clade">extract.clade</a></code>
</p>

<hr>
<h2 id='eco.scape'>eco.space scape simulation with a macro-ecological focus</h2><span id='topic+eco.scape'></span>

<h3>Description</h3>

<p><code>eco.scape</code> is a modified version of the Helmus et al. method
implemented in <code><a href="#topic+scape">scape</a></code>. It produces phylogenetically
structured communities. It allows phylogenetic signals in niche
optima, but unlike <code><a href="#topic+scape">scape</a></code>, does not include the
ability to specify niche optima signal type (attraction/repulsion)
or phylogenetic signal in range size. Instead, the focus is on
having more control over the macroecological characteristics of the
resulting landscapes. In particular, eco.scape produces landscapes
with fixed mean range sizes, reasonable range size and abundance
distributions, and control over whether species present on a tree
must be present in the landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eco.scape(
  tree,
  scape.size = 10,
  g.center = 1,
  wd.all = 0.2 * (scape.size + 1)^2,
  signal.center = TRUE,
  center.scale = 1,
  site.stoch.scale = 0,
  sd.center = 1,
  sd.range = 1,
  K = 100,
  extinction = FALSE,
  rho = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eco.scape_+3A_tree">tree</code></td>
<td>
<p><code><a href="ape.html#topic+phylo">phylo</a></code> object; must have branch
lengths and be ultrametric</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_scape.size">scape.size</code></td>
<td>
<p>edge dimension of square landscape</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_g.center">g.center</code></td>
<td>
<p>strength of phylogenetic signal in species range
centers. See <code><a href="ape.html#topic+corBlomberg">corBlomberg</a></code>,
1=brownian,&lt;1=rates of evol accelerate, &gt;1=rates decelerate.</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_wd.all">wd.all</code></td>
<td>
<p>niche width, larger values simulate broader range
sizes</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_signal.center">signal.center</code></td>
<td>
<p>simulate with phylosignal in range centers</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_center.scale">center.scale</code></td>
<td>
<p>adjust strength of phylogenetic attraction in
range centers independent of g.center</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_site.stoch.scale">site.stoch.scale</code></td>
<td>
<p>adjust strength of random variation in
species richness across sites</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_sd.center">sd.center</code></td>
<td>
<p>sd in <code><a href="stats.html#topic+rnorm">rnorm</a></code>rnorm for
the range centers, increase to get more variation in center values
across species</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_sd.range">sd.range</code></td>
<td>
<p>sd in rnorm for the range sizes, increase to get
more variation in range sizes across gradients</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_k">K</code></td>
<td>
<p>carrying capacity of a site in terms of maximum
individuals that can be present. Currently a constant value. Used
to scale the presence-absence matrix to include abundances.</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_extinction">extinction</code></td>
<td>
<p>TRUE/FALSE can species on the tree go extinct on
the landscape? If the number of species present on the landscape
should equal the number of tips on the tree, choose FALSE. See
Details.</p>
</td></tr>
<tr><td><code id="eco.scape_+3A_rho">rho</code></td>
<td>
<p>Grafen branch adjustment of phylogenetic tree see
<code><a href="ape.html#topic+corGrafen">corGrafen</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates a landscape with species (i.e., tree tips) distributions
dependent on a supplied phylogenetic tree. The amount and type of
structure is determened by the signal parameter
<code>g.center</code>. Parameters are based on an Ornstein-Uhlenbeck
model of evolution with stabilizing selection. Values of g=1
indicate no stabilizing selection and correspond to the Brownian
motion model of evolution; 01 corresponds to disruptive selection
where phylogenetic signal for the supplied tree is amplified. See
corBlomberg. Communities are simulated along two gradients where
the positions along those gradients, <code>g.center</code>, can exhibit
phylogenetic signal.
</p>
<p>The function returns a landscape where the average range size is
equivalent to the wd.all parameter - in the scape function, this
parameter is not necessarily returned in the resulting
landscape. To do this, the probability of presence (th) that
returns the wd.all parameter is solved for. If there is no solution
that can produce the wd.all given, the error &quot;Error in uniroot(f,
lower = 0, upper = max(X.), tol = 10^-200): f() values at end
points not of opposite sign&quot; will occur. This seems to mostly arise
for extreme or unlikely parameter values (small species pools, low
carrying capacities). Try adjusting parameter values first.
</p>
<p>The <code>extinction</code> parameter specifies whether all of the
species on the tree should be present in the final landscape. Some
species will have probabilities of presence less than those
required for presence. If extinctions is <code>TRUE</code>, these species
will not be present. If <code>FALSE</code>, these species will be present
in 1 site, that in which they have the highest probability of
presence.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cc</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object with
presence/absence results of simulations. The site names are the
row.columns of the cells in the original grid cells that made up
the data, and these co-ordinates are also given in the <code>env</code>
slot of the object along with the environmental gradient
information.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>presence/absence matrix</p>
</td></tr>
<tr><td><code>Yab</code></td>
<td>
<p>abundance matrix</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>spatial coordinates for X and Y (stacked columns)</p>
</td></tr>
<tr><td><code>X.joint</code></td>
<td>
<p>full probabilities of species at sites, used to
construct Y</p>
</td></tr>
<tr><td><code>X1</code></td>
<td>
<p>probabilities of species along gradient 1</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>probabilities of species along gradient 2</p>
</td></tr>
<tr><td><code>gradient1</code>, <code>gradient2</code></td>
<td>
<p>environmental gradient values</p>
</td></tr>
<tr><td><code>nichewd</code></td>
<td>
<p>average niche width of the assemblage</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>carrying capacity of each cell</p>
</td></tr>
<tr><td><code>environ</code></td>
<td>
<p>matrix depicting environmental values over the 2D
landscape</p>
</td></tr>
<tr><td><code>sppXs</code></td>
<td>
<p>full probabilities of each species as an array
arranged in a scape.size X scape.size matr ix</p>
</td></tr>
<tr><td><code>V.phylo</code></td>
<td>
<p>initial phylogenetic covariance matrix from tree,
output of vcv.phylo(tree, corr=T)</p>
</td></tr>
<tr><td><code>V.phylo.rho</code></td>
<td>
<p>phylogenetic covariance matrix from tree scaled
by Grafen if rho is provided, other wise just an output of
vcv.phylo(tree, corr=T)</p>
</td></tr>
<tr><td><code>V.center</code></td>
<td>
<p>scaled (by g.center) phylo covariance matrix used
in the simulations</p>
</td></tr>
<tr><td><code>bspp1</code></td>
<td>
<p>species optima for gradient 1</p>
</td></tr>
<tr><td><code>bspp2</code></td>
<td>
<p>pecies optima for gradient 2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Helmus, Caroline Tucker, cosmetic edits by Will Pearse
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scape">scape</a></code> <code><a href="#topic+sim.phy">sim.phy</a></code> <code><a href="#topic+sim.meta">sim.meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulations
tree &lt;- rcoal(64)

scape1 &lt;- eco.scape(tree, scape.size=25, g.center=1,
    signal.center=FALSE, K=100, extinction=TRUE)
scape2 &lt;- eco.scape(tree, scape.size=16, g.center=0.2,
    signal.center=TRUE, K=100, extinction=FALSE)
scape3 &lt;- eco.scape(tree, scape.size=16, g.center=20,
    signal.center=TRUE, K=100, extinction=TRUE)

# Plotting distributions and landscape patterns
original_landscape &lt;- scape1
abundmax &lt;- original_landscape$K
PA_mat &lt;- as.matrix(original_landscape$Y)
abund_mat &lt;- original_landscape$Yab
site.size &lt;- nrow(PA_mat)
species &lt;- ncol(PA_mat)
mx &lt;- original_landscape$gradient
env &lt;- original_landscape$environ$env.gradient
par(mfrow=c(2,2), oma=c(0,0,2,0))
heatcol &lt;- (colorRampPalette(c("yellow","red")))

image(matrix(env,sqrt(site.size),sqrt(site.size),byrow=TRUE),
    col=heatcol(max(env)),xaxt="n",yaxt="n",main="Env gradient")

image(matrix(rowSums(PA_mat),sqrt(site.size),sqrt(site.size),byrow=TRUE),
    col=heatcol(16),xaxt="n",yaxt="n",main="Species Richness")

hist(colSums(PA_mat),ylab="Number of species",xlab="Number of sites",
    main="Species Area Relationship",col="lightgrey")

hist(colSums(abund_mat),ylab="Number of species",xlab="Number of individuals",
    main="Species Abundance Relationship",col="lightgrey")
mtext("Env random, phy.signal=0.2, 32 species", outer=TRUE, side=3, cex=1.25)
</code></pre>

<hr>
<h2 id='eco.xxx.regression'>eco.xxx.regression</h2><span id='topic+eco.xxx.regression'></span><span id='topic+eco.env.regression'></span><span id='topic+eco.phy.regression'></span><span id='topic+eco.trait.regression'></span><span id='topic+summary.eco.xxx.regression'></span><span id='topic+print.eco.xxx.regression'></span><span id='topic+plot.eco.xxx.regression'></span>

<h3>Description</h3>

<p>Regression species co-existence against environmental tolerance,
trait similarity, or phylogenetic relatedness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eco.env.regression(
  data,
  randomisation = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap"),
  permute = 0,
  method = c("quantile", "lm", "mantel"),
  altogether = TRUE,
  indep.swap = 1000,
  abundance = TRUE,
  ...
)

eco.phy.regression(
  data,
  randomisation = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap"),
  permute = 0,
  method = c("quantile", "lm", "mantel"),
  indep.swap = 1000,
  abundance = TRUE,
  ...
)

eco.trait.regression(
  data,
  randomisation = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap"),
  permute = 0,
  method = c("quantile", "lm", "mantel"),
  altogether = TRUE,
  indep.swap = 1000,
  abundance = TRUE,
  ...
)

## S3 method for class 'eco.xxx.regression'
summary(object, ...)

## S3 method for class 'eco.xxx.regression'
print(x, ...)

## S3 method for class 'eco.xxx.regression'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eco.xxx.regression_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> for analysis</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_randomisation">randomisation</code></td>
<td>
<p>null distribution with which to compare your
community data, one of: <code>taxa.labels</code> (DEFAULT),
<code>richness</code>, <code>frequency</code>, <code>sample.pool</code>,
<code>phylogeny.pool</code>, <code>independentswap</code>, <code>trialswap</code> (as
implemented in <code><a href="picante.html#topic+picante">picante</a></code>)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_permute">permute</code></td>
<td>
<p>the number of null permutations to perform (DEFAULT
0)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_method">method</code></td>
<td>
<p>how to compare distance matrices (only the lower
triangle;), one of: <code><a href="stats.html#topic+lm">lm</a></code> (linear regression),
<code>quantile</code> (DEFAULT; <code>quantreg::<a href="quantreg.html#topic+rq">rq</a></code>),
<code>mantel</code> (<code><a href="vegan.html#topic+mantel">mantel</a></code>)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_altogether">altogether</code></td>
<td>
<p>use distance matrix based on all traits (default
TRUE), or perform separate regressions for each trait (returns a
list, see details)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_indep.swap">indep.swap</code></td>
<td>
<p>number of independent swap iterations to perform
(if specified in <code>randomisation</code>; DEFAULT 1000)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_abundance">abundance</code></td>
<td>
<p>whether to incorporate species' abundances
(default: TRUE)</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to model fitting functions</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_object">object</code></td>
<td>
<p><code>eco.xxx.regression</code> object</p>
</td></tr>
<tr><td><code id="eco.xxx.regression_+3A_x">x</code></td>
<td>
<p><code>eco.xxx.regression</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are similar to those performed in Cavender-Bares et
al. (2004). Each function regresses the species co-existence matrix
of <code><a href="utils.html#topic+data">data</a></code> (calculated using <code><a href="#topic+comm.dist">comm.dist</a></code>)
against either species' trait dissimilarity
(<code><a href="#topic+eco.trait.regression">eco.trait.regression</a></code>), species' phylogenetic
distance (<code><a href="#topic+eco.phy.regression">eco.phy.regression</a></code>), or species' shared
environmental tolerances as measured by Pianka's distance
(<code><a href="#topic+eco.env.regression">eco.env.regression</a></code>).
</p>
<p>If <code>altogether</code> is set to <code>FALSE</code>, each trait or
environemntal variables in your data will have a separate
<code>eco.trait.regression</code> or <code>eco.env.regression</code> applied to
it. The functions will return a list of individual regressions; you
can either examine/plot them as a group (see examples below), or
extract an individual regression and work with that. These lists
are of class <code>eco.xxx.regression.list</code>; a bit messy, but it
does work!...
</p>


<h3>Note</h3>

<p>Like <code><a href="#topic+fingerprint.regression">fingerprint.regression</a></code>, this is a
data-hungry method. Warnings will be generated if any of the
methods cannot be fitted properly (the examples below give toy
examples of this). In such cases the summary and plot methods of
these functions may generate errors; perhaps use
<code><a href="base.html#topic+traceback">traceback</a></code> to examine where these are coming from, and
consider whether you want to be working with the data generating
these errors. I am loathe to hide these errors or gloss over them,
because they represent the reality of your data!
</p>
<p>WDP loves quantile regressions, and advises that you check
different quantiles using the <code>tau</code> options.
</p>


<h3>Author(s)</h3>

<p>Will Pearse, Jeannine Cavender-Bares
</p>


<h3>References</h3>

<p>Cavender-Bares J., Ackerly D.D., Baum D.A. &amp; Bazzaz F.A. (2004) Phylogenetic overdispersion in Floridian oak communities. The Americant Naturalist 163(6): 823&ndash;843.
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D., Blomberg, S.P. &amp; Webb, C.O. Picante: R tools for integrating phylogenies and ecology. Bioinformatics 26(11): 1463&ndash;1464.
</p>
<p>Pagel M. Inferring the historical patterns of biological evolution. Nature 401(6756): 877&ndash;884.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fingerprint.regression">fingerprint.regression</a></code> <code><a href="#topic+phy.signal">phy.signal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
#We wouldn't recommend only using ten permutations - this is just for speed!
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
eco.trait.regression(data, permute=10)
#Specify additional options
eco.trait.regression(data, tau=c(0.25,0.5,0.75), permute=10)
plot(eco.trait.regression(data, permute=10, method="lm"))
plot(eco.trait.regression(data, permute=10, method="lm", altogether=FALSE))
</code></pre>

<hr>
<h2 id='eco.xxx.regression.list'>List of eco.xxx.regressions</h2><span id='topic+eco.xxx.regression.list'></span><span id='topic+summary.eco.xxx.regression.list'></span><span id='topic+print.eco.xxx.regression.list'></span><span id='topic+plot.eco.xxx.regression.list'></span>

<h3>Description</h3>

<p>List of eco.xxx.regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eco.xxx.regression.list'
summary(object, ...)

## S3 method for class 'eco.xxx.regression.list'
print(x, ...)

## S3 method for class 'eco.xxx.regression.list'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eco.xxx.regression.list_+3A_object">object</code></td>
<td>
<p><code>eco.xxx.regression.list</code> object</p>
</td></tr>
<tr><td><code id="eco.xxx.regression.list_+3A_...">...</code></td>
<td>
<p>additional arguments to plotting functions</p>
</td></tr>
<tr><td><code id="eco.xxx.regression.list_+3A_x">x</code></td>
<td>
<p><code>eco.xxx.regression.list</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='fibre.plot'><code>fibre.plot</code> (fibrously) plots a phylogeny</h2><span id='topic+fibre.plot'></span>

<h3>Description</h3>

<p><code>fibre.plot</code> (fibrously) plots a phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibre.plot(
  tree,
  gif,
  focal,
  frames = 60,
  colours = colorRampPalette(c("blue", "black", "red")),
  f.colours = colorRampPalette(c("darkgreen", "lightgreen")),
  pca = NULL,
  clade.mat = NULL,
  delay = 0.2,
  side.tree = TRUE,
  width = 600,
  height = 600
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fibre.plot_+3A_tree">tree</code></td>
<td>
<p>a phylogeny (of class phylo) you wish to plot</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_gif">gif</code></td>
<td>
<p>name of GIF you would like to create. This should *not*
including a folder name (this is due to the use of
<code><a href="animation.html#topic+saveGIF">saveGIF</a></code>); &quot;plot.gif&quot; would be fine,
but &quot;work/plot.gif&quot; would not</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_focal">focal</code></td>
<td>
<p>species numbers or clade numbers to plot differently
(see examples). Note that specifying a clade will highlight the
clade *before* it arises; this is by design. If not specified
(the default) there will be no focal species; this is fine.</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_frames">frames</code></td>
<td>
<p>number of frames for animation; this will also
determine the time internals for the plot</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_colours">colours</code></td>
<td>
<p>a function that will return a colour ramp for use in
plotting of species on the fiber plot itself as well as the
standard phylogeny to the right (e.g., <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>)</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_f.colours">f.colours</code></td>
<td>
<p>as <code>colours</code> but for the <code>focal</code> species</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_pca">pca</code></td>
<td>
<p>PCA (of class <code><a href="stats.html#topic+prcomp">prcomp</a></code>) of
phylogenetic dissimilarity matrix; NULL calculates one, I
recommend you use the output from a previous run to speed
things up</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_clade.mat">clade.mat</code></td>
<td>
<p>clade matrix (from
<code><a href="caper.html#topic+clade.matrix">clade.matrix</a></code>$clade.matrix) of phylogeny; NULL
calculates one, I recommend you use the output from a previous
run to speed things up</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_delay">delay</code></td>
<td>
<p>the delay between each slice's frame in the output
GIF; default 0.2 seconds</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_side.tree">side.tree</code></td>
<td>
<p>whether to plot a standard phylogeny to the right
of the plot to aid with interpretation (default: TRUE). You
almost certainly want this option</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_width">width</code></td>
<td>
<p>width of animation</p>
</td></tr>
<tr><td><code id="fibre.plot_+3A_height">height</code></td>
<td>
<p>height of animation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probably best to just plot it out and see what happens, to
be honest.
</p>


<h3>Value</h3>

<p>The data that were plotted last, the PCA and clade.matrix
to speed later plots, and the colours used.
</p>


<h3>Note</h3>

<p>I would be grateful if you could cite the article this code
was released in when using this code. I maintain this code in
the package &quot;willeerd&quot; on GitHub. I give an example of how to
install this code from there below. Updates will be released
through that, and I welcome code improvements!
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fibre.plot(rlineage(0.1,0), "Yule_fibre.gif")

## End(Not run)
</code></pre>

<hr>
<h2 id='fingerprint.regression'>Regress trait evolution against trait ecology (following
Cavender-Bares et al. 2004)</h2><span id='topic+fingerprint.regression'></span><span id='topic+print.fingerprint.regression'></span><span id='topic+summary.fingerprint.regression'></span><span id='topic+plot.fingerprint.regression'></span>

<h3>Description</h3>

<p>Calculates traits' phylogenetic inertia and regresses this against
trait similarity among co-existing species (sensu Cavender-Bares et
al. 2004 Figure 6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fingerprint.regression(
  data,
  eco.rnd = c("taxa.labels", "richness", "frequency", "sample.pool", "phylogeny.pool",
    "independentswap", "trialswap"),
  eco.method = c("quantile", "lm", "mantel"),
  eco.permute = 1000,
  evo.method = c("lambda", "delta", "kappa", "blom.k"),
  eco.swap = 1000,
  abundance = TRUE,
  ...
)

## S3 method for class 'fingerprint.regression'
print(x, ...)

## S3 method for class 'fingerprint.regression'
summary(object, ...)

## S3 method for class 'fingerprint.regression'
plot(
  x,
  eco = c("slope", "corrected"),
  xlab = "Community Trait Similarity",
  ylab = "Phylogenetic inertia",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fingerprint.regression_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> for analysis</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_eco.rnd">eco.rnd</code></td>
<td>
<p>null distribution with which to compare your
community data, one of: <code>taxa.labels</code> (DEFAULT),
<code>richness</code>, <code>frequency</code>, <code>sample.pool</code>,
<code>phylogeny.pool</code>, <code>independentswap</code>, <code>trialswap</code> (as
implemented in <code><a href="picante.html#topic+picante">picante</a></code>)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_eco.method">eco.method</code></td>
<td>
<p>how to compare distance matrices (only the lower
triangle;), one of: <code><a href="stats.html#topic+lm">lm</a></code> (linear regression),
<code>quantile</code> (DEFAULT; <code><a href="quantreg.html#topic+rq">rq</a></code>),
<code>mantel</code> (<code><a href="vegan.html#topic+mantel">mantel</a></code>)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_eco.permute">eco.permute</code></td>
<td>
<p>number of permutations for ecological null model
(<code>eco.rnd</code>); default 1000</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_evo.method">evo.method</code></td>
<td>
<p>how to measure phylogenetic inertia, one of:
<code>lambda</code> (default), <code>delta</code>, <code>kappa</code>, <code>blom.k</code>;
see <code><a href="#topic+phy.signal">phy.signal</a></code>.</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_eco.swap">eco.swap</code></td>
<td>
<p>number of independent swap iterations to perform
(if specified in <code>eco.rnd</code>; DEFAULT 1000)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_abundance">abundance</code></td>
<td>
<p>whether to incorporate species' abundances
(default: TRUE)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to model fitting
functions and plotting functions</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_x">x</code></td>
<td>
<p><code>fingerprint.regression</code> object</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_object">object</code></td>
<td>
<p><code>fingerprint.regression</code> object</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_eco">eco</code></td>
<td>
<p>plot the observed slopes (DEFAULT: <code>slope</code>), or the
median difference between the simulations and the observed values
(<code>corrected</code>)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis (default &quot;Ecological Trait Coexistence&quot;)</p>
</td></tr>
<tr><td><code id="fingerprint.regression_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis (default &quot;Phylogenetic inertia&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the term &lsquo;fingerprint regression&rsquo; is new to pez, the method
is very similar to that employed in Cavender-Bares et al. 2004
Figure 6. For each trait, the phylogenetic inertia of species
traits is regressed against their co-occurrence in the community
matrix. Note that Pagel's lambda, delta, and kappa, and Blomberg's
K, can be used, unlike the original where a mantel test was
employed. Moreover, note also that Pianka's distance (as described
in the manuscript) is used to measure species overlap.
</p>


<h3>Note</h3>

<p>Like <code><a href="#topic+eco.xxx.regression">eco.xxx.regression</a></code>, this is a data-hungry
method. Warnings will be generated if any of the methods cannot be
fitted properly (the examples below give toy examples of this). In
such cases the summary and plot methods of these functions may
generate errors; perhaps using <code><a href="base.html#topic+traceback">traceback</a></code> to examine
where these are coming from, and consider whether you want to be
working with the data generating these errors. I am loathe to hide
these errors or gloss over them, because they represent the reality
of your data!
</p>
<p>WDP loves quantile regressions, and advises that you check
different quantiles using the <code>tau</code> options.
</p>


<h3>Author(s)</h3>

<p>Will Pearse and Jeannine Cavender-Bares
</p>


<h3>References</h3>

<p>Cavender-Bares J., Ackerly D.D., Baum D.A. &amp; Bazzaz F.A. (2004) Phylogenetic overdispersion in Floridian oak communities. The Americant Naturalist 163(6): 823&ndash;843.
</p>
<p>Kembel, S.W., Cowan, P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D., Blomberg, S.P. &amp; Webb, C.O. Picante: R tools for integrating phylogenies and ecology. Bioinformatics 26(11): 1463&ndash;1464.
</p>
<p>Pagel M. Inferring the historical patterns of biological evolution. Nature 401(6756): 877&ndash;884.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eco.xxx.regression">eco.xxx.regression</a></code> <code><a href="#topic+phy.signal">phy.signal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
fingerprint.regression(data, eco.permute=10)
plot(fingerprint.regression(data, permute=10, method="lm"))
</code></pre>

<hr>
<h2 id='generic.metrics'>Calculate any metric(s) (and compare with null distributions)</h2><span id='topic+generic.metrics'></span><span id='topic+generic.null'></span><span id='topic+.ses'></span><span id='topic+.metric.null'></span>

<h3>Description</h3>

<p>Allow the calculation of any metric within <code>pez</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic.null(
  data,
  metrics,
  null.model = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap", "trait.asm"),
  permute = 1000,
  comp.fun = .ses,
  ...
)

.ses(observed, null)

.metric.null(
  data,
  metrics,
  null.model = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap", "trait.asm"),
  permute = 1000,
  trait = -1,
  ...
)

generic.metrics(data, metrics, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generic.metrics_+3A_data">data</code></td>
<td>
<p>data <code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_metrics">metrics</code></td>
<td>
<p>vector of functions to be calculated on <code>data</code>;
see <a href="#topic+pez.metrics">pez.metrics</a> for a list of them.</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_null.model">null.model</code></td>
<td>
<p>one of &quot;taxa.labels&quot;, &quot;richness&quot;, &quot;frequency&quot;,
&quot;sample.pool&quot;, &quot;phylogeny.pool&quot;, &quot;independentswap&quot;, or
&quot;independentswap&quot;. These correspond to the null models available in
<code><a href="picante.html#topic+picante">picante</a></code></p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_permute">permute</code></td>
<td>
<p>number of null permutations to perform (default
1000)</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_comp.fun">comp.fun</code></td>
<td>
<p>comparison function to compare observed values with
null values. Default is <code><a href="#topic+.ses">.ses</a></code>; this is a Standard
Effect Size (obs - mean)/SEmean. You may supply your own function;
it should take the observed site-metric matrix as its first
argument, and a site-metric-permutation array as its second. See
the internals of <code><a href="#topic+generic.null">generic.null</a></code> for an example of its
use.</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_...">...</code></td>
<td>
<p>additional arguments (e.g, <code>dist</code>,
<code>abundance.weighted</code>) to be passed to any metric functions
(see <code><a href="#topic+generic.metrics">generic.metrics</a></code> for possible arguments)</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_observed">observed</code></td>
<td>
<p>observed metric values in site-metric matrix
(<em>e.g.</em>, from <code><a href="#topic+generic.metrics">generic.metrics</a></code>)</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_null">null</code></td>
<td>
<p>null distributions (<em>e.g.</em>, from
<code><a href="#topic+.metric.null">.metric.null</a></code>) in a site-metric-permutation array</p>
</td></tr>
<tr><td><code id="generic.metrics_+3A_trait">trait</code></td>
<td>
<p>if using <code>trait.asm</code> <code>null.model</code>, which
trait to use (as in <code><a href="#topic+trait.asm">trait.asm</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generic.null</code> Calculate metrics and compare with null
distributions. Very light wrapper around the utility functions
<code><a href="#topic+generic.null">generic.null</a></code> and <code><a href="#topic+generic.metrics">generic.metrics</a></code> (which
is, itself, a very simple function!).
</p>


<h3>Value</h3>

<p><code>generic.null</code> Output from <code>comp.fun</code>, by default
an array (site-metric-type), where type is the observed value, the
mean of the null permutations, the Standard Error of that mean, the
Standard Effect Size of the metric (obs-null.mean)/SE, and then the
rank of the observed value in the permutations. The rank can be
considered a bootstrapped p-value of significance, but remember
that this is a rank: at the 95
would be significant.
</p>
<p><code>.ses</code> Vector of standard effect sizes
</p>
<p><code>.metric.null</code> site-metric-permutation array
</p>
<p><code>generic.metrics</code> site-metric matrix
</p>


<h3>Note</h3>

<p><code>comp.fun</code> can be <em>anything</em>; much ink has been
written about the use of standard effect sizes in eco-phylogenetic
analyses (<em>e.g.</em>, Kembel 2009). That this function makes it
easy for you to compute Standard Effect Sizes does not necessarily
mean that you should (see Pearse et al. 2013).
</p>
<p>Calculating null permutations on a dispersion metric makes little
sense, since (by definition; see Pearse et al. 2014) a dispersion
metric <em>require</em> the use of a null distribution to be
calculated. There is nothing to stop you doing so, however! The
code makes no attempt to stop you calculating null dissimilarity
metrics, but I am not certain that doing so is a good idea using
this code as I don't know what to do with such null models!
</p>
<p>The <code><a href="#topic+pez.shape">pez.shape</a></code>, <code><a href="#topic+pez.evenness">pez.evenness</a></code>,
<code><a href="#topic+pez.dispersion">pez.dispersion</a></code>, and <code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
wrapper functions go to some trouble to stop you calculating
metrics using inappropriate data (see their notes). These functions
give you access to the underlying code within <code>pez</code>; there is
nothing I can do to stop you calculating a metric that, in my
opinion, doesn't make any sense. You have been warned :D
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>


<h3>References</h3>

<p>Kembel S.W. (2009) Disentangling niche and neutral
influences on community assembly: assessing the performance of
community phylogenetic structure tests. Ecology letters, 12(9),
949-960.
</p>
<p>Pearse W.D., Jones F.A. &amp; Purvis A. (2013) Barro
Colorado Island's phylogenetic assemblage structure across fine
spatial scales and among clades of different ages. Ecology, 94(12),
2861-2872.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Setup data
data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
#Calculate some metrics
generic.metrics(data, c(.mpd, .pse))
#Compare with a trait-based null model (trait.asm)
generic.null(data, c(.mpd, .pse), "trait.asm", permute=10, trait="fish.pref")
#...be patient when running large (e.g., 1000) sets of null simulations
#You can also do this in pieces, giving even more flexibility
observed &lt;- generic.metrics(data, c(.mpd, .pse))
#null &lt;- .metric.null(data, c(.mpd, .pse))
#ses &lt;- .ses(observed, null)
#...this is how everything works within generic.null
#...and, as with everything in pez, all internal functions start with a "."
</code></pre>

<hr>
<h2 id='laja'>Macroinvertebrate samples from the Rio Laja of Mexico</h2><span id='topic+laja'></span><span id='topic+invert.traits'></span><span id='topic+invert.tree'></span><span id='topic+river.env'></span><span id='topic+river.sites'></span>

<h3>Description</h3>

<p>This data set includes macroinvertebrate samples from
the Rio Laja, a phylogenetic tree of the taxa and traits that
include mean body length and fish feeding preference as in Helmus
<em>et al.</em> 2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(laja)
</code></pre>


<h3>Format</h3>

<p><code>laja</code> contains a <code><a href="ape.html#topic+phylo">phylo</a></code> object, a
dataframe of sites-by-taxa, a dataframe of sites-by-environment,
and a dataframe of traits
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus
</p>


<h3>References</h3>

<p>Helmus M., Mercado-Silva N. &amp; Vander Zanden
M.J. (2013). Subsidies to predators, apparent competition and the
phylogenetic structure of prey communities. Oecologia, 173,
997-1007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
</code></pre>

<hr>
<h2 id='pez'>Phylogenetics for the Environmental Sciences</h2><span id='topic+pez'></span><span id='topic+package-pez'></span><span id='topic+pez-package'></span>

<h3>Description</h3>

<p>Analysis and manipulation of eco-phylogenetic datasets containing
species phylogeny, species traits, community composition, and
environmental data. Provide the <code><a href="#topic+comparative.comm">comparative.comm</a></code>
object to ease data manipulation, and wrappers for common community
phylogenetic indices grouped according to Pearse et al. 2014:
<code><a href="#topic+pez.shape">pez.shape</a></code>, <code><a href="#topic+pez.evenness">pez.evenness</a></code>,
<code><a href="#topic+pez.dispersion">pez.dispersion</a></code>, and
<code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>. Implementation of Cavender-Bares
et al. (2004) correlation of phylogenetic and ecological matrices
(<code><a href="#topic+fingerprint.regression">fingerprint.regression</a></code>). Simulation of null
assemblages, traits, and phylogenies (<code><a href="#topic+scape">scape</a></code>,
<code><a href="#topic+sim.meta.comm">sim.meta.comm</a></code>).
</p>


<h3>References</h3>

<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus M.R. (2014). Metrics and Models of Community Phylogenetics. In: Modern Phylogenetic Comparative Methods and Their Application in Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p>Cavender-Bares J., Ackerly D.D., Baum D.A. &amp; Bazzaz F.A. (2004) Phylogenetic overdispersion in Floridian oak communities. The Americant Naturalist 163(6): 823&ndash;843.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(pez)
data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits, river.env)
pez.shape(data)
</code></pre>

<hr>
<h2 id='pez-internal'>Internal pez Functions</h2><span id='topic+.Random.seed'></span><span id='topic+.eco.evo.clade.regression'></span><span id='topic+.eco.evo.regression'></span><span id='topic+.eco.null'></span><span id='topic+.eco.phy.regression'></span><span id='topic+.plot.regression'></span><span id='topic+.prepare.regression.output'></span><span id='topic+.summary.regression'></span><span id='topic+summary.phy.structure'></span><span id='topic+.removeErrors'></span>

<h3>Description</h3>

<p>Internal pez functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='pez.dispersion'>Calculate (phylogenetic) dispersion: examine assemblages in the
context of a source pools</h2><span id='topic+pez.dispersion'></span>

<h3>Description</h3>

<p>As described in Pearse et al. (2014), a dispersion metric is one
the examines the phylogenetic structure of species present in each
assemblage in the context of a source pool of potentially present
species. Unlike other metrics, the value of a dispersion metric is
*contingent* on the definition of source pool, and (often)
randomisations used to conduct that comparison. For completeness,
options are provided to calculate these metrics using species
traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pez.dispersion(
  data,
  null.model = c("taxa.labels", "richness", "frequency", "sample.pool",
    "phylogeny.pool", "independentswap", "trialswap"),
  abundance = FALSE,
  sqrt.phy = FALSE,
  traitgram = NULL,
  traitgram.p = 2,
  ext.dist = NULL,
  permute = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.dispersion_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_null.model">null.model</code></td>
<td>
<p>one of &quot;taxa.labels&quot;, &quot;richness&quot;, &quot;frequency&quot;,
&quot;sample.pool&quot;, &quot;phylogeny.pool&quot;, &quot;independentswap&quot;, or
&quot;independentswap&quot;. These correspond to the null models available in
<code><a href="picante.html#topic+picante">picante</a></code>; only <code>d</code> does not use these null models</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_abundance">abundance</code></td>
<td>
<p>Whether to use abundance-weighted forms of these
metrics (default: FALSE). D, which is presence/absence only, and so
will not be calculated when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_sqrt.phy">sqrt.phy</code></td>
<td>
<p>If TRUE (default is FALSE) your phylogenetic
distance matrix will be square-rooted; specifying TRUE will force
the square-root transformation on phylogenetic distance matrices
(in the spirit of Leitten and Cornwell, 2014). See &lsquo;details&rsquo; for
details about different metric calculations when a distance matrix
is used.</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_traitgram">traitgram</code></td>
<td>
<p>If not NULL (default), a number to be passed to
<code>funct.phylo.dist</code> (<code>phyloWeight</code>; the &lsquo;a&rsquo; parameter),
causing analysis on a distance matrix reflecting both traits and
phylogeny (0 &ndash;&gt; only phylogeny, 1 &ndash;&gt; only traits; see
<code>funct.phylo.dist</code>). If a vector of numbers is given,
<code>pez.dispersion</code> iterates across them and returns a <code>data.frame</code>
with coefficients from each iteration. See &lsquo;details&rsquo; for details
about different metric calculations when a distance matrix is used.</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_traitgram.p">traitgram.p</code></td>
<td>
<p>A value for &lsquo;p&rsquo; to be used in conjunction with
<code>traitgram</code> when calling <code>funct.phylo.dist</code>.</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_ext.dist">ext.dist</code></td>
<td>
<p>Supply an external species-level distance matrix
for use in calculations. See &lsquo;details&rsquo; for comments on the use of
distance matrices in different metric calculations.</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_permute">permute</code></td>
<td>
<p>number of null permutations to perform (default
1000)</p>
</td></tr>
<tr><td><code id="pez.dispersion_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to metrics (unlikely
you will want to use this!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these metrics do not involve comparison with some kind of
evolutionary-derived expectation for phylogenetic shape. Those that
do, however, such as D, make no sense unless applied to a
phylogenetic distance matrix - their null expectation *requires*
it. Using square-rooted distance matrices, or distance matrices
that incorporate trait information, can be an excellent thing to
do, but (for the above reasons), <code>pez</code> won't give you an
answer for metrics for which WDP thinks it makes no sense. SESpd
can (...up to you whether it should!...) be used with a
square-rooted distance matrix, but the results *will always be
wrong* if you do not have an ultrametric tree (branch lengths
proportional to time) and you will be warned about this. WDP
strongly feels you should only be using ultrametric phylogenies in
any case, but code to fix this bug is welcome.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with metric values
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus, Will Pearse
</p>


<h3>References</h3>

<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus
M.R. (2014). Metrics and Models of Community Phylogenetics. In:
Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p><code>sesmpd,sesmntd</code> Webb C.O. (2000). Exploring the
phylogenetic structure of ecological communities: An example for
rain forest trees. American Naturalist, 156, 145-155.
</p>
<p><code>sespd</code> Webb C.O., Ackerly D.D. &amp; Kembel
S.W. (2008). Phylocom: software for the analysis of phylogenetic
community structure and trait evolution. Bioinformatics
Applications Note, 24, 2098-2100.
</p>
<p><code>innd,mipd</code> Ness J.H., Rollinson E.J. &amp; Whitney
K.D. (2011). Phylogenetic distance can predict susceptibility to
attack by natural enemies. Oikos, 120, 1327-1334.
</p>
<p><code>d</code> Fritz S.A. &amp; Purvis A. (2010). Selectivity in
Mammalian Extinction Risk and Threat Types: a New Measure of
Phylogenetic Signal Strength in Binary Traits. Conservation
Biology, 24, 1042-1051.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pez.shape">pez.shape</a></code> <code><a href="#topic+pez.evenness">pez.evenness</a></code> <code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
## Not run: pez.dispersion(data)
pez.dispersion(data, permute = 100)
</code></pre>

<hr>
<h2 id='pez.dissimilarity'>Calculate (phylogenetic) dissimilarity: compare assemblages to
one-another</h2><span id='topic+pez.dissimilarity'></span>

<h3>Description</h3>

<p>As described in Pearse et al. (2014), a dissimilarity metric
compares diversity between communities. WARNING: Phylosor is
presented as a distance matrix here, i.e. it is *not* the fraction
of shared branch length among communities, but rather '1 - shared
branch length'. This means <code>dissimilarity</code> always returns a
*distance* object, not a similarity object; this is a different
convention from other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pez.dissimilarity(
  data,
  metric = c("all", "unifrac", "pcd", "phylosor", "comdist"),
  abundance.weighted = FALSE,
  permute = 1000,
  sqrt.phy = FALSE,
  traitgram = NULL,
  traitgram.p = 2,
  ext.dist = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.dissimilarity_+3A_data">data</code></td>
<td>
<p><code>comparative.comm</code> object</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_metric">metric</code></td>
<td>
<p>default (<code>all</code>) calculates everything;
individually call-able metrics are: <code>unifrac</code>, <code>pcd</code>,
<code>phylosor</code>, <code>comdist</code>.</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>If TRUE (default is FALSE) metrics are
calculated incorporating species abundances; only <code>comdist</code>
can incorporate abundances</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_permute">permute</code></td>
<td>
<p>Number of permutations for metric (currently only
for <code>pcd</code>)</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_sqrt.phy">sqrt.phy</code></td>
<td>
<p>If TRUE (default is FALSE) your phylogenetic
distance matrix will be square-rooted; specifying TRUE will force
the square-root transformation on phylogenetic distance matrices
(in the spirit of Leitten and Cornwell, 2014). See &lsquo;details&rsquo; for
details about different metric calculations when a distance matrix
is used.</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_traitgram">traitgram</code></td>
<td>
<p>If not NULL (default), a number to be passed to
<code>funct.phylo.dist</code> (<code>phyloWeight</code>; the &lsquo;a&rsquo; parameter),
causing analysis on a distance matrix reflecting both traits and
phylogeny (0 &ndash;&gt; only phylogeny, 1 &ndash;&gt; only traits; see
<code>funct.phylo.dist</code>). Unlike other metric wrapper functions,
<code>dissimilarity</code> does not accept a vector of traitgram values;
call the function many times to get these. This is simply because
it can take so long: you're probably better off
looping/<code>apply</code>-ing over this function yourself.</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_traitgram.p">traitgram.p</code></td>
<td>
<p>A value for &lsquo;p&rsquo; to be used in conjunction with
<code>traitgram</code> when calling <code>funct.phylo.dist</code>.</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_ext.dist">ext.dist</code></td>
<td>
<p>Supply an external species-level distance matrix
for use in calculations. See &lsquo;details&rsquo; for comments on the use of
distance matrices in different metric calculations.</p>
</td></tr>
<tr><td><code id="pez.dissimilarity_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to 'metric
function(s) you are calling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using square-rooted distance matrices, or distance matrices that
incorporate trait information, can be an excellent thing to do, but
(for the above reasons), <code>pez</code> won't give you an answer for
metrics for which WDP thinks it makes no sense. All results from
this other than <code>comdist</code> *will always be wrong* if you do not
have an ultrametric tree and square-root (branch lengths
proportional to time) and you will be warned about this. WDP
strongly feels you should only be using ultrametric phylogenies in
any case, but code to fix this bug is welcome.
</p>


<h3>Value</h3>

<p>list object of metric values.
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus, Will Pearse
</p>


<h3>References</h3>

<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus
M.R. (2014). Metrics and Models of Community Phylogenetics. In:
Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p><code>unifrac</code> Lozupone C.A. &amp; Knight
R. (2005). UniFrac: a new phylogenetic method for comparing
microbial communities. Applied and Environmental Microbiology, 71,
8228-8235.
</p>
<p><code>pcd</code> Ives A.R. &amp; Helmus M.R. (2010). Phylogenetic
metrics of community similarity. The American Naturalist, 176,
E128-E142.
</p>
<p><code>phylosor</code> Bryant J.A., Lamanna C., Morlon H.,
Kerkhoff A.J., Enquist B.J. &amp; Green J.L. (2008). Microbes on
mountainsides: Contrasting elevational patterns of bacterial and
plant diversity. Proceedings of the National Academy of Sciences of
the United States of America, 105, 11505-11511.
</p>
<p><code>comdist</code> C.O. Webb, D.D. Ackerly, and
S.W. Kembel. 2008. Phylocom: software for the analysis of
phylogenetic community structure and trait
evolution. Bioinformatics 18:2098-2100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pez.shape">pez.shape</a></code> <code><a href="#topic+pez.evenness">pez.evenness</a></code> <code><a href="#topic+pez.dispersion">pez.dispersion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
## Not run: 
dissim &lt;- pez.dissimilarity(data)

## End(Not run)
</code></pre>

<hr>
<h2 id='pez.endemism'>Calculate (phylogenetic) endemism</h2><span id='topic+pez.endemism'></span>

<h3>Description</h3>

<p>At present, only a small number of metrics, but we intend for this
to grow with time. Note that metrics that incorporate abundance are
mixed in with those that do not. Some of these metrics make sense
when used with probabilities, for example those derived from an
SDM; some do not. You will have to use your own judgement (as with
everything in science!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pez.endemism(data, sqrt.phy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.endemism_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="pez.endemism_+3A_sqrt.phy">sqrt.phy</code></td>
<td>
<p>If TRUE (default is FALSE) your phylogenetic
distance matrix will be square-rooted; specifying TRUE will
force the square-root transformation on phylogenetic distance
matrices (in the spirit of Leitten and Cornwell, 2014). See
&lsquo;details&rsquo; for details about different metric calculations when
a distance matrix is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with metric values.
</p>


<h3>Author(s)</h3>

<p>Will Pearse, Dan Rosauer
</p>


<h3>References</h3>

<p><code>BED</code> Cadotte, M. W., &amp; Jonathan Davies,
T. (2010). Rarest of the rare: advances in combining
evolutionary distinctiveness and scarcity to inform
conservation at biogeographical scales. Diversity and
Distributions, 16(3), 376-385.
</p>
<p><code>PE</code> Rosauer, D. A. N., Laffan, S. W., Crisp,
M. D., Donnellan, S. C., &amp; Cook, L. G. (2009). Phylogenetic
endemism: a new approach for identifying geographical
concentrations of evolutionary history. Molecular Ecology,
18(19), 4061-4072.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pez.shape">pez.shape</a></code> <code><a href="#topic+pez.evenness">pez.evenness</a></code>
<code><a href="#topic+pez.dispersion">pez.dispersion</a></code> <code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
(output&lt;-pez.endemism(data))
</code></pre>

<hr>
<h2 id='pez.evenness'>Calculate (phylogenetic) evenness: examine assemblage composition
and abundance</h2><span id='topic+pez.evenness'></span>

<h3>Description</h3>

<p>As described in Pearse et al. (2014), an evenness metric is one the
examines the phylogenetic structure of species present in each
assemblage, taking into account their abundances. For completeness,
options are provided to calculate these metrics using species
traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pez.evenness(
  data,
  sqrt.phy = FALSE,
  traitgram = NULL,
  traitgram.p = 2,
  ext.dist = NULL,
  quick = TRUE,
  q = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.evenness_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_sqrt.phy">sqrt.phy</code></td>
<td>
<p>If TRUE (default is FALSE) your phylogenetic
distance matrix will be square-rooted; specifying TRUE will force
the square-root transformation on phylogenetic distance matrices
(in the spirit of Leitten and Cornwell, 2014). See &lsquo;details&rsquo; for
details about different metric calculations when a distance
matrix is used.</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_traitgram">traitgram</code></td>
<td>
<p>If not NULL (default), a number to be passed to
<code>funct.phylo.dist</code> (<code>phyloWeight</code>; the &lsquo;a&rsquo; parameter),
causing analysis on a distance matrix reflecting both traits and
phylogeny (0&ndash;&gt;only phylogeny, 1&ndash;&gt; only traits; see
<code>funct.phylo.dist</code>). If a vector of numbers is given,
<code>pez.eveness</code> iterates across them and returns a
<code>data.frame</code> with coefficients from each iteration. See
&lsquo;details&rsquo; for details about different metric calculations when a
distance matrix is used.</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_traitgram.p">traitgram.p</code></td>
<td>
<p>A value for &lsquo;p&rsquo; to be used in conjunction with
<code>traitgram</code> when calling <code>funct.phylo.dist</code>.</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_ext.dist">ext.dist</code></td>
<td>
<p>Supply an external species-level distance matrix
for use in calculations. See &lsquo;details&rsquo; for comments on the use of
distance matrices in different metric calculations.</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_quick">quick</code></td>
<td>
<p>Only calculate metrics which are quick to calculate
(default: TRUE); setting to FALSE will also calculate
<code>fd.dist</code> and the Pagel transformations (lambda, delta,
kappa).</p>
</td></tr>
<tr><td><code id="pez.evenness_+3A_q">q</code></td>
<td>
<p>value for <em>q</em> in <code>scheiner</code> (default 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these metrics do not involve comparison with some kind of
evolutionary-derived expectation for phylogenetic shape. Those that
do, however, such as PSE, make no sense unless applied to a
phylogenetic distance matrix - their null expectation *requires*
it. Using square-rooted distance matrices, or distance matrices
that incorporate trait information, can be an excellent thing to
do, but (for the above reasons), <code>pez</code> won't give you an
answer for metrics for which WDP thinks it makes no
sense. <code>pae</code>, <code>iac</code>, <code>haead</code> &amp; <code>eaed</code> can
(...up to you whether you should!...)  be used with a square-rooted
distance matrix, but the results *will always be wrong* if you do
not have an ultrametric tree (branch lengths proportional to time)
and you will be warned about this. WDP strongly feels you should
only be using ultrametric phylogenies in any case, but code to fix
this bug is welcome.
</p>


<h3>Value</h3>

<p><code>phy.structure</code> list object of metric values. Use
<code>coefs</code> to extract a summary metric table, or examine each
individual metric (which gives more details for each) by calling
<code>print</code> on the output (i.e., type <code>output</code> in the example
below).
</p>


<h3>Note</h3>

<p>As mentioned above, <code>dist.fd</code> is calculated using a
phylogenetic distance matrix if no trait data are available, or
if you specify <code>sqrt.phy</code>. It is not calculated by default
because it generates warning messsages (which WDP is loathe to
suppress) which are related to the general tendency for a low
rank of phylogenetic distance matrices. Much ink has been written
about this, and in par this problem is why the <code>eigen.sum</code>
measure came to be suggested.
</p>
<p>Some of these metrics can cause (inconsequential) warnings if given
assemblages with only one species/individual in them, and return
NA/NaN values depending on the metric. I consider these &lsquo;features&rsquo;,
not bugs.
</p>
<p>Some of the metrics in this wrapper are also in
<code><a href="#topic+pez.shape">pez.shape</a></code>; such metrics can be calculated using
species' abundances (making them <em>evenness</em>) metrics or simply
using presence/absence of species (making them <em>shape</em>
metrics).
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus, Will Pearse
</p>


<h3>References</h3>

<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus
M.R. (2014). Metrics and Models of Community Phylogenetics. In:
Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p><code>pse</code> Helmus M.R., Bland T.J., Williams C.K. &amp;
Ives A.R. (2007). Phylogenetic measures of biodiversity. American
Naturalist, 169, E68-E83.
</p>
<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus
M.R. (2014). Metrics and Models of Community Phylogenetics. In:
Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p><code>pse</code> Helmus M.R., Bland T.J., Williams C.K. &amp;
Ives A.R. (2007). Phylogenetic measures of biodiversity. American
Naturalist, 169, E68-E83.
</p>
<p><code>rao</code> Webb C.O. (2000). Exploring the phylogenetic
structure of ecological communities: An example for rain forest
trees. American Naturalist, 156, 145-155.
</p>
<p><code>taxon</code> Clarke K.R. &amp; Warwick R.M. (1998). A
taxonomic distinctness index and its statistical
properties. J. Appl. Ecol., 35, 523-531.
</p>
<p><code>entropy</code> Allen B., Kon M. &amp; Bar-Yam Y. (2009). A
New Phylogenetic Diversity Measure Generalizing the Shannon Index
and Its Application to Phyllostomid Bats. The American Naturalist,
174, 236-243.
</p>
<p><code>pae,iac,haed,eaed</code> Cadotte M.W., Davies T.J.,
Regetz J., Kembel S.W., Cleland E. &amp; Oakley
T.H. (2010). Phylogenetic diversity metrics for ecological
communities: integrating species richness, abundance and
evolutionary history. Ecology Letters, 13, 96-105.
</p>
<p><code>lambda,delta,kappa</code> Mark Pagel (1999) Inferring
the historical patterns of biological evolution. Nature 6756(401):
877&ndash;884.
</p>
<p><code>innd,mipd</code> Ness J.H., Rollinson E.J. &amp; Whitney
K.D. (2011). Phylogenetic distance can predict susceptibility to
attack by natural enemies. Oikos, 120, 1327-1334.
</p>
<p><code>scheiner</code> Scheiner, S.M. (20120). A metric of
biodiversity that integrates abundance, phylogeny, and function.
Oikos, 121, 1191-1202.
</p>


<h3>See Also</h3>

<p>pez.shape pez.dispersion pez.dissimilarity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
pez.evenness(data)
</code></pre>

<hr>
<h2 id='pez.metrics'>Phylogenetic and functional trait metrics within pez</h2><span id='topic+pez.metrics'></span><span id='topic+.hed'></span><span id='topic+.eed'></span><span id='topic+.psv'></span><span id='topic+.psr'></span><span id='topic+.mpd'></span><span id='topic+.vpd'></span><span id='topic+.vntd'></span><span id='topic+.pd'></span><span id='topic+.mntd'></span><span id='topic+.gamma'></span><span id='topic+.taxon'></span><span id='topic+.eigen.sum'></span><span id='topic+.dist.fd'></span><span id='topic+.sqrt.phy'></span><span id='topic+.phylo.entropy'></span><span id='topic+.aed'></span><span id='topic+.haed'></span><span id='topic+.simpson.phylogenetic'></span><span id='topic+.iac'></span><span id='topic+.pae'></span><span id='topic+.scheiner'></span><span id='topic+.pse'></span><span id='topic+.rao'></span><span id='topic+.lambda'></span><span id='topic+.delta'></span><span id='topic+.kappa'></span><span id='topic+.eaed'></span><span id='topic+.unifrac'></span><span id='topic+.pcd'></span><span id='topic+.comdist'></span><span id='topic+.phylosor'></span><span id='topic+.d'></span><span id='topic+.ses.mpd'></span><span id='topic+.ses.mntd'></span><span id='topic+.ses.vpd'></span><span id='topic+.ses.vntd'></span><span id='topic+.ses.mipd'></span><span id='topic+.ses.innd'></span><span id='topic+.mipd'></span><span id='topic+.innd'></span><span id='topic+.pe'></span><span id='topic+.bed'></span>

<h3>Description</h3>

<p>Using these functions, you can calculate any of the phylogenetic
metrics within pez, using <code><a href="#topic+comparative.comm">comparative.comm</a></code>
objects. While you can call each individually, using the
<code><a href="#topic+pez.shape">pez.shape</a></code>, <code><a href="#topic+pez.evenness">pez.evenness</a></code>,
<code><a href="#topic+pez.dispersion">pez.dispersion</a></code>, and <code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
wrapper functions (and the more flexible
<code><a href="#topic+generic.metrics">generic.metrics</a></code> and null model functions) are probably
your best bet. Note that *all of these functions* take a common
first parameter: a <code><a href="#topic+comparative.comm">comparative.comm</a></code> object. There are
additional parameters that can be passed, which are described
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hed(x, ...)

.eed(x, na.rm = TRUE, ...)

.psv(x, ...)

.psr(x, ...)

.mpd(x, dist = NULL, abundance.weighted = FALSE, ...)

.vpd(x, dist = NULL, abundance.weighted = FALSE, ...)

.vntd(x, dist = NULL, abundance.weighted = FALSE, ...)

.pd(x, include.root = TRUE, abundance.weighted = FALSE, ...)

.mntd(x, dist = NULL, abundance.weighted = FALSE, ...)

.gamma(x, ...)

.taxon(x, dist = NULL, abundance.weighted = FALSE, ...)

.eigen.sum(x, dist = NULL, which.eigen = 1, ...)

.dist.fd(x, method = "phy", abundance.weighted = FALSE, ...)

.sqrt.phy(x)

.phylo.entropy(x, ...)

.aed(x, ...)

.haed(x, ...)

.simpson.phylogenetic(x)

.iac(x, na.rm = TRUE, ...)

.pae(x, na.rm = TRUE, ...)

.scheiner(x, q = 0, abundance.weighted = FALSE, ...)

.pse(x, ...)

.rao(x, ...)

.lambda(x, ...)

.delta(x, ...)

.kappa(x, ...)

.eaed(x, ...)

.unifrac(x, ...)

.pcd(x, permute = 1000, ...)

.comdist(x, dist = NULL, abundance.weighted = FALSE, ...)

.phylosor(x, dist = NULL, abundance.weighted = FALSE, ...)

.d(x, permute = 1000, ...)

.ses.mpd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.ses.mntd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.ses.vpd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.ses.vntd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.ses.mipd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.ses.innd(
  x,
  dist = NULL,
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  permute = 1000,
  ...
)

.mipd(x, dist = NULL, abundance.weighted = FALSE, ...)

.innd(x, dist = NULL, abundance.weighted = FALSE, ...)

.innd(x, dist = NULL, abundance.weighted = FALSE, ...)

.pe(x, ...)

.bed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.metrics_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs in calculations (altering this can obscure
errors that are meaningful; I would advise leaving alone)</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_dist">dist</code></td>
<td>
<p>distance matrix for use with calculations; could be
generated from traits, a square-root-transformed distance matrix
(see <code><a href="#topic+.sqrt.phy">.sqrt.phy</a></code> for creating a
<code><a href="#topic+comparative.comm">comparative.comm</a></code> object with a square-root
transformed phylogeny). Default: NULL (&ndash;&gt; calculate distance
matrix from phylogeny)</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_abundance.weighted">abundance.weighted</code></td>
<td>
<p>whether to include species' abundances in
metric calculation, often dictating whether you're calculating a
<code><a href="#topic+pez.shape">pez.shape</a></code> or <code><a href="#topic+pez.evenness">pez.evenness</a></code>
metric. Default: FALSE</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_include.root">include.root</code></td>
<td>
<p>include root in PD calculations (default is
TRUE, as in picante, but within <code><a href="#topic+pez.shape">pez.shape</a></code> I specify
FALSE</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_which.eigen">which.eigen</code></td>
<td>
<p>which phylo-eigenvector to be used for PVR
metric</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_method">method</code></td>
<td>
<p>whether to calculate using phylogeny (&quot;phy&quot;;
default) or trait data (&quot;traits&quot;)</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_q">q</code></td>
<td>
<p>the q parameter for <code>.scheiner</code>; default 0.0001</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_permute">permute</code></td>
<td>
<p>number of permutations of null randomisations
(mostly only applies to <code><a href="#topic+pez.dispersion">dispersion
metrics</a></code>)</p>
</td></tr>
<tr><td><code id="pez.metrics_+3A_null.model">null.model</code></td>
<td>
<p>one of &quot;taxa.labels&quot;, &quot;richness&quot;, &quot;frequency&quot;,
&quot;sample.pool&quot;, &quot;phylogeny.pool&quot;, &quot;independentswap&quot;, or
&quot;independentswap&quot;. These correspond to the null models available in
<code><a href="picante.html#topic+picante">picante</a></code>; only <code>d</code> does not use these null models</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.pd</code> returns two metrics: Faith's PD (which does not take
into account abundance) and Faith's PD corrected for species
richness or total abundance (depending on
<code>abundance.weighted</code>). I am almost certain that I got the idea
for this from somewhere, but I can't find the reference: if you
published on this before 2012, please get in touch with me.
</p>
<p><code>.scheiner</code> has a different formula for the case where
<code>q</code> is equal to 1 (check the code if interested). The nature
of its definition means that values very close to, but not exactly
equal to, 1 may be extremely large or extremely small. This is a
feature, not a bug, and an inherent aspect of its definition. Check
the formula in the code for more information!
</p>


<h3>Note</h3>

<p>Many (but not all) of these functions are fairly trivial
wrappers around functions in other packages. In the citations for
each metric, * indicates a function that's essentially written in
<code><a href="picante.html#topic+picante">picante</a></code>. The Pagel family of measures are also fairly
trivial wrapper around <code><a href="caper.html#topic+caper">caper</a></code> code, functional
dissimilarity <code><a href="FD.html#topic+FD">FD</a></code> code, <code>gamma</code>, and <code><a href="ape.html#topic+ape">ape</a></code>
code. I can't demand it, but I would be grateful if you would cite these
authors when using these wrappers.
</p>
<p>The <code><a href="#topic+pez.shape">pez.shape</a></code>, <code><a href="#topic+pez.evenness">pez.evenness</a></code>,
<code><a href="#topic+pez.dispersion">pez.dispersion</a></code>, and <code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
wrapper functions go to some trouble to stop you calculating
metrics using inappropriate data (see their notes). These functions
give you access to the underlying code within <code>pez</code>; there is
nothing I can do to stop you calculating a metric that, in my
opinion, doesn't make any sense. You have been warned :D
</p>
<p>If you're a developer hoping to make your metric(s) work in this
framework, please use the argument naming convention for arguments
described in this help file, and use the <code>...</code> operator in
your definition. That way functions that don't need particular
arguments can co-exist peacefully with those that do. The first
argument to one of these functions should <em>always</em> be a
<code><a href="#topic+comparative.comm">comparative.comm</a></code> object; there is no method dispatch
on any of these functions and I foresee future pain without this
rule.
</p>


<h3>References</h3>

<p><code>eed,hed</code> (i.e., <em>Eed, Hed</em>) Cadotte M.W.,
Davies T.J., Regetz J., Kembel S.W., Cleland E. &amp; Oakley
T.H. (2010). Phylogenetic diversity metrics for ecological
communities: integrating species richness, abundance and
evolutionary history. Ecology Letters, 13, 96-105.
</p>
<p><code>PSV,PSR,PSE</code> Helmus M.R., Bland T.J., Williams
C.K. &amp; Ives A.R. (2007). Phylogenetic measures of
biodiversity. American Naturalist, 169, E68-E83.
</p>
<p><code>PD</code> Faith D.P. (1992). Conservation evaluation
and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p><code>gamma</code> Pybus O.G. &amp; Harvey P.H. (2000) Testing
macro-evolutionary models using incomplete molecular
phylogenies. _Proceedings of the Royal Society of London. Series
B. Biological Sciences 267: 2267&ndash;2272.
</p>
<p><code>taxon</code> Clarke K.R. &amp; Warwick R.M. (1998). A
taxonomic distinctness index and its statistical
properties. J. Appl. Ecol., 35, 523-531.
</p>
<p><code>eigen.sum</code> Diniz-Filho J.A.F., Cianciaruso M.V.,
Rangel T.F. &amp; Bini L.M. (2011). Eigenvector estimation of
phylogenetic and functional diversity. Functional Ecology, 25,
735-744.
</p>
<p><code>entropy</code> Allen B., Kon M. &amp; Bar-Yam Y. (2009). A
New Phylogenetic Diversity Measure Generalizing the Shannon Index
and Its Application to Phyllostomid Bats. The American Naturalist,
174, 236-243.
</p>
<p><code>pae,aed,iac,haed,eaed</code> Cadotte M.W., Davies T.J.,
Regetz J., Kembel S.W., Cleland E. &amp; Oakley
T.H. (2010). Phylogenetic diversity metrics for ecological
communities: integrating species richness, abundance and
evolutionary history. Ecology Letters, 13, 96-105.
</p>
<p><code>scheiner</code> Scheiner, S.M. (20120). A metric of
biodiversity that integrates abundance, phylogeny, and function.
Oikos, 121, 1191-1202.
</p>
<p><code>rao</code> Webb C.O. (2000). Exploring the phylogenetic
structure of ecological communities: An example for rain forest
trees. American Naturalist, 156, 145-155.
</p>
<p><code>lambda,delta,kappa</code> Mark Pagel (1999) Inferring
the historical patterns of biological evolution. Nature 6756(401):
877&ndash;884.
</p>
<p><code>unifrac</code> Lozupone C.A. &amp; Knight
R. (2005). UniFrac: a new phylogenetic method for comparing
microbial communities. Applied and Environmental Microbiology, 71,
8228-8235.
</p>
<p><code>pcd</code> Ives A.R. &amp; Helmus M.R. (2010). Phylogenetic
metrics of community similarity. The American Naturalist, 176,
E128-E142.
</p>
<p><code>comdist</code> C.O. Webb, D.D. Ackerly, and
S.W. Kembel. 2008. Phylocom: software for the analysis of
phylogenetic community structure and trait
evolution. Bioinformatics 18:2098-2100.
</p>
<p><code>phylosor</code> Bryant J.A., Lamanna C., Morlon H.,
Kerkhoff A.J., Enquist B.J. &amp; Green J.L. (2008). Microbes on
mountainsides: Contrasting elevational patterns of bacterial and
plant diversity. Proceedings of the National Academy of Sciences of
the United States of America, 105, 11505-11511.
</p>
<p><code>d</code> Fritz S.A. &amp; Purvis A. (2010). Selectivity in
Mammalian Extinction Risk and Threat Types: a New Measure of
Phylogenetic Signal Strength in Binary Traits. Conservation
Biology, 24, 1042-1051.
</p>
<p><code>sesmpd,sesmntd</code> Webb C.O. (2000). Exploring the
phylogenetic structure of ecological communities: An example for
rain forest trees. American Naturalist, 156, 145-155.
</p>
<p><code>innd,mipd</code> Ness J.H., Rollinson E.J. &amp; Whitney
K.D. (2011). Phylogenetic distance can predict susceptibility to
attack by natural enemies. Oikos, 120, 1327-1334.
</p>
<p><code>PE</code> Rosauer, D. A. N., Laffan, S. W., Crisp,
M. D., Donnellan, S. C., &amp; Cook, L. G. (2009). Phylogenetic
endemism: a new approach for identifying geographical
concentrations of evolutionary history. Molecular Ecology,
18(19), 4061-4072.
</p>
<p><code>BED</code> Cadotte, M. W., &amp; Jonathan Davies,
T. (2010). Rarest of the rare: advances in combining
evolutionary distinctiveness and scarcity to inform
conservation at biogeographical scales. Diversity and
Distributions, 16(3), 376-385.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites)
.psv(data)
</code></pre>

<hr>
<h2 id='pez.shape'>Calculate (phylogenetic) shape: examine assemblage composition</h2><span id='topic+pez.shape'></span>

<h3>Description</h3>

<p>As described in Pearse et al. (2014), a shape metric is one the
examines the phylogenetic structure of species present in each
assemblage, ignoring abundances entirely. For completeness, options
are provided to calculate these metrics using species traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pez.shape(
  data,
  sqrt.phy = FALSE,
  traitgram = NULL,
  traitgram.p = 2,
  ext.dist = NULL,
  which.eigen = 1,
  quick = TRUE,
  q = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pez.shape_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_sqrt.phy">sqrt.phy</code></td>
<td>
<p>If TRUE (default is FALSE) your phylogenetic
distance matrix will be square-rooted; specifying TRUE will force
the square-root transformation on phylogenetic distance matrices
(in the spirit of Leitten and Cornwell, 2014). See &lsquo;details&rsquo; for
details about different metric calculations when a distance matrix
is used.</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_traitgram">traitgram</code></td>
<td>
<p>If not NULL (default), a number to be passed to
<code>funct.phylo.dist</code> (<code>phyloWeight</code>; the &lsquo;a&rsquo; parameter),
causing analysis on a distance matrix reflecting both traits and
phylogeny (0 &ndash;&gt; only phylogeny, 1 &ndash;&gt; only traits; see
<code>funct.phylo.dist</code>). If a vector of numbers is given,
<code>pez.shape</code> iterates across them and returns a
<code>data.frame</code> with coefficients from each iteration. See
&lsquo;details&rsquo; for details about different metric calculations when a
distance matrix is used.</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_traitgram.p">traitgram.p</code></td>
<td>
<p>A value for &lsquo;p&rsquo; to be used in conjunction with
<code>traitgram</code> when calling <code>funct.phylo.dist</code>.</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_ext.dist">ext.dist</code></td>
<td>
<p>Supply an external species-level distance matrix
for use in calculations. See &lsquo;details&rsquo; for comments on the use of
distance matrices in different metric calculations.</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_which.eigen">which.eigen</code></td>
<td>
<p>The eigen vector to calculate for the PhyloEigen
metric (<code>eigen.sum</code>)</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_quick">quick</code></td>
<td>
<p>Only calculate metrics which are quick to calculate
(default: TRUE); setting to FALSE will also calculate
<code>fd.dist</code>.</p>
</td></tr>
<tr><td><code id="pez.shape_+3A_q">q</code></td>
<td>
<p>value for <em>q</em> in <code>scheiner</code> (default 0.0001)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these metrics do not involve comparison with some kind of
evolutionary-derived expectation for phylogenetic shape. Those that
do, however, such as PSV, make no sense unless applied to a
phylogenetic distance matrix - their null expectation *requires*
it. Using square-rooted distance matrices, or distance matrices
that incorporate trait information, can be an excellent thing to
do, but (for the above reasons), <code>pez</code> won't give you an
answer for metrics for which WDP thinks it makes no
sense. <code>pd</code>, <code>eed</code> &amp; <code>hed</code> can (...up to you whether
you should!...) be used with a square-rooted distance matrix, but
the results *will always be wrong* if you do not have an
ultrametric tree (branch lengths proportional to time) and you will
be warned about this. WDP strongly feels you should only be using
ultrametric phylogenies in any case, but code to fix this bug is
welcome.
</p>


<h3>Value</h3>

<p><code>phy.structure</code> list object of metric values. Use
<code>coefs</code> to extract a summary metric table, or examine each
individual metric (which gives more details for each) by calling
<code>print</code> on the output (i.e., type <code>output</code> in the example
below).
</p>
<p>Some of the metrics in this wrapper are also in
<code><a href="#topic+pez.evenness">pez.evenness</a></code>; such metrics can be calculated using
species' abundances (making them <em>evenness</em>) metrics or simply
using presence/absence of species (making them <em>shape</em>
metrics).
</p>


<h3>Note</h3>

<p>As mentioned above, <code>dist.fd</code> is calculated using a
phylogenetic distance matrix if no trait data are available, or if
you specify <code>sqrt.phy</code>. It is not calculated by default
because it generates warning messsages (which WDP is loathe to
suppress) which are related to the general tendency for a low rank
of phylogenetic distance matrices. Much ink has been written about
this, and in part this problem is why the <code>eigen.sum</code> measure
came to be suggested.
</p>
<p>Many of these metrics, (<em>e.g.</em>, <code>eed</code>) will cause
(inconsequential) warnings if given assemblages with only one
species in them, and return NA/NaN values depending on the
metric. I consider these &lsquo;features&rsquo;, not bugs.
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus, Will Pearse
</p>


<h3>References</h3>

<p>Pearse W.D., Purvis A., Cavender-Bares J. &amp; Helmus
M.R. (2014). Metrics and Models of Community Phylogenetics. In:
Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology. Springer Berlin Heidelberg, pp. 451-464.
</p>
<p><code>PSV,PSR</code> Helmus M.R., Bland T.J., Williams C.K. &amp;
Ives A.R. (2007). Phylogenetic measures of biodiversity. American
Naturalist, 169, E68-E83.
</p>
<p><code>PD</code> Faith D.P. (1992). Conservation evaluation
and phylogenetic diversity. Biological Conservation, 61, 1-10.
</p>
<p><code>gamma</code> Pybus O.G. &amp; Harvey P.H. (2000) Testing
macro-evolutionary models using incomplete molecular
phylogenies. _Proceedings of the Royal Society of London. Series
B. Biological Sciences 267: 2267&ndash;2272.
</p>
<p><code>taxon</code> Clarke K.R. &amp; Warwick R.M. (1998). A
taxonomic distinctness index and its statistical
properties. J. Appl. Ecol., 35, 523-531.
</p>
<p><code>eigen.sum</code> Diniz-Filho J.A.F., Cianciaruso M.V.,
Rangel T.F. &amp; Bini L.M. (2011). Eigenvector estimation of
phylogenetic and functional diversity. Functional Ecology, 25,
735-744.
</p>
<p><code>eed,hed</code> (i.e., <em>Eed, Hed</em>) Cadotte M.W.,
Davies T.J., Regetz J., Kembel S.W., Cleland E. &amp; Oakley
T.H. (2010). Phylogenetic diversity metrics for ecological
communities: integrating species richness, abundance and
evolutionary history. Ecology Letters, 13, 96-105.
</p>
<p><code>innd,mipd</code> Ness J.H., Rollinson E.J. &amp; Whitney
K.D. (2011). Phylogenetic distance can predict susceptibility to
attack by natural enemies. Oikos, 120, 1327-1334.
</p>
<p><code>scheiner</code> Scheiner, S.M. (20120). A metric of
biodiversity that integrates abundance, phylogeny, and function.
Oikos, 121, 1191-1202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pez.evenness">pez.evenness</a></code> <code><a href="#topic+pez.dispersion">pez.dispersion</a></code>
<code><a href="#topic+pez.dissimilarity">pez.dissimilarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
(output&lt;-pez.shape(data))
</code></pre>

<hr>
<h2 id='pglmm'>Phylogenetic Generalised Linear Mixed Model for Community Data</h2><span id='topic+pglmm'></span><span id='topic+communityPGLMM'></span><span id='topic+communityPGLMM.gaussian'></span><span id='topic+communityPGLMM.binary'></span><span id='topic+communityPGLMM.binary.LRT'></span><span id='topic+communityPGLMM.matrix.structure'></span><span id='topic+summary.communityPGLMM'></span><span id='topic+plot.communityPGLMM'></span><span id='topic+communityPGLMM.predicted.values'></span>

<h3>Description</h3>

<p>This function performs Generalized Linear Mixed Models for binary
and continuous phylogenetic data, estimating regression
coefficients with approximate standard errors. It is modeled after
<code><a href="lme4.html#topic+lmer">lmer</a></code> but is more general by allowing
correlation structure within random effects; these correlations can
be phylogenetic among species, or any other correlation structure,
such as geographical correlations among sites. It is, however, much
more specific than <code><a href="lme4.html#topic+lmer">lmer</a></code> in that it can
only analyze a subset of1 the types of model designed handled by
<code><a href="lme4.html#topic+lmer">lmer</a></code>. It is also much slower than
<code><a href="lme4.html#topic+lmer">lmer</a></code> and requires users to specify
correlation structures as covariance
matrices. <code>communityPGLMM</code> can analyze models in Ives and
Helmus (2011). It can also analyze bipartite phylogenetic data,
such as that analyzed in Rafferty and Ives (2011), by giving sites
phylogenetic correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communityPGLMM(
  formula,
  data = list(),
  family = "gaussian",
  sp = NULL,
  site = NULL,
  random.effects = list(),
  REML = TRUE,
  s2.init = NULL,
  B.init = NULL,
  reltol = 10^-6,
  maxit = 500,
  tol.pql = 10^-6,
  maxit.pql = 200,
  verbose = FALSE
)

communityPGLMM.gaussian(
  formula,
  data = list(),
  family = "gaussian",
  sp = NULL,
  site = NULL,
  random.effects = list(),
  REML = TRUE,
  s2.init = NULL,
  B.init = NULL,
  reltol = 10^-8,
  maxit = 500,
  verbose = FALSE
)

communityPGLMM.binary(
  formula,
  data = list(),
  family = "binomial",
  sp = NULL,
  site = NULL,
  random.effects = list(),
  REML = TRUE,
  s2.init = 0.25,
  B.init = NULL,
  reltol = 10^-5,
  maxit = 40,
  tol.pql = 10^-6,
  maxit.pql = 200,
  verbose = FALSE
)

communityPGLMM.binary.LRT(x, re.number = 0, ...)

communityPGLMM.matrix.structure(
  formula,
  data = list(),
  family = "binomial",
  sp = NULL,
  site = NULL,
  random.effects = list(),
  ss = 1
)

## S3 method for class 'communityPGLMM'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'communityPGLMM'
plot(x, digits = max(3, getOption("digits") - 3), ...)

communityPGLMM.predicted.values(x, show.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing the
fixed-effects of the model; for example, <code>Y ~ X</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_data">data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables
named in formula. The data frame should have long format with
factors specifying species and sites. <code>communityPGLMM</code> will
reorder rows of the data frame so that species are nested within
sites. Please note that calling
<code><a href="#topic+as.data.frame.comparative.comm">as.data.frame.comparative.comm</a></code> will return your
<code>comparative.comm</code> object into this format for you.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_family">family</code></td>
<td>
<p>either <code>gaussian</code> for a Linear Mixed Model, or
<code>binomial</code> for binary dependent data.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_sp">sp</code></td>
<td>
<p>a <code><a href="base.html#topic+factor">factor</a></code> variable that identifies species</p>
</td></tr>
<tr><td><code id="pglmm_+3A_site">site</code></td>
<td>
<p>a <code><a href="base.html#topic+factor">factor</a></code> variable that identifies sites</p>
</td></tr>
<tr><td><code id="pglmm_+3A_random.effects">random.effects</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> that contains, for
non-nested random effects, lists of triplets of the form
<code>list(X, group = group, covar = V)</code>. This is modeled after the
<code><a href="lme4.html#topic+lmer">lmer</a></code> formula syntax <code>(X | group)</code>
where <code>X</code> is a variable and <code>group</code> is a grouping
factor. Note that <code>group</code> should be either your <code>sp</code> or
<code>site</code> variable specified in <code>sp</code> and <code>site</code>. The
additional term <code>V</code> is a covariance matrix of rank equal to
the number of levels of group that specifies the covariances among
groups in the random effect <code>X</code>. For nested variable random
effects, <code>random.effects</code> contains lists of quadruplets of the
form <code>list(X, group1 = group1, covar = V, group2 = group2)</code>
where <code>group1</code> is nested within <code>group2</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_reml">REML</code></td>
<td>
<p>whether REML or ML is used for model fitting. For the
generalized linear mixed model for binary data, these don't have
standard interpretations, and there is no log likelihood function
that can be used in likelihood ratio tests.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_s2.init">s2.init</code></td>
<td>
<p>an array of initial estimates of s2 for each random
effect that scales the variance. If s2.init is not provided for
<code>family="gaussian"</code>, these are estimated using in a clunky way
using <code><a href="stats.html#topic+lm">lm</a></code> assuming no phylogenetic signal.  A better
approach is to run <code>link[lme4:lmer]{lmer}</code> and use the output
random effects for <code>s2.init</code>. If <code>s2.init</code> is not
provided for <code>family="binomial"</code>, these are set to 0.25.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_b.init">B.init</code></td>
<td>
<p>initial estimates of <code class="reqn">B</code>, a matrix containing
regression coefficients in the model for the fixed effects. This
matrix must have <code>dim(B.init)=c(p+1,1)</code>, where <code>p</code> is the
number of predictor (independent) variables; the first element of
<code>B</code> corresponds to the intercept, and the remaining elements
correspond in order to the predictor (independent) variables in the
formula.  If <code>B.init</code> is not provided, these are estimated
using in a clunky way using <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>
assuming no phylogenetic signal.  A better approach is to run
<code><a href="lme4.html#topic+lmer">lmer</a></code> and use the output fixed effects for
<code>B.init</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_reltol">reltol</code></td>
<td>
<p>a control parameter dictating the relative tolerance
for convergence in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_maxit">maxit</code></td>
<td>
<p>a control parameter dictating the maximum number of
iterations in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_tol.pql">tol.pql</code></td>
<td>
<p>a control parameter dictating the tolerance for
convergence in the PQL estimates of the mean components of the
binomial GLMM.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_maxit.pql">maxit.pql</code></td>
<td>
<p>a control parameter dictating the maximum number
of iterations in the PQL estimates of the mean components of the
binomial GLMM.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, the model deviance and running
estimates of <code>s2</code> and <code>B</code> are plotted each iteration
during optimization.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_x">x</code></td>
<td>
<p><code>communityPGLMM</code> object</p>
</td></tr>
<tr><td><code id="pglmm_+3A_re.number">re.number</code></td>
<td>
<p>which <code>random.effect</code> in <code>x</code> to be
tested</p>
</td></tr>
<tr><td><code id="pglmm_+3A_...">...</code></td>
<td>
<p>additional arguments to summary and plotting functions
(currently ignored)</p>
</td></tr>
<tr><td><code id="pglmm_+3A_ss">ss</code></td>
<td>
<p>which of the <code>random.effects</code> to produce</p>
</td></tr>
<tr><td><code id="pglmm_+3A_object">object</code></td>
<td>
<p>communityPGLMM object to be summarised</p>
</td></tr>
<tr><td><code id="pglmm_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits for printing, as
in <code><a href="base.html#topic+print.default">print.default</a></code></p>
</td></tr>
<tr><td><code id="pglmm_+3A_show.plot">show.plot</code></td>
<td>
<p>if <code>TRUE</code> (default), display plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vignette 'pez-pglmm-overview' gives a gentle
introduction to using PGLMMS. For linear mixed models (<code>family
= 'gaussian'</code>), the function estimates parameters for the model of
the form, for example,
</p>
<p style="text-align: center;"><code class="reqn">Y = \beta_0 + \beta_1x + b_0 + b_1x</code>
</p>

<p style="text-align: center;"><code class="reqn">b_0 ~ Gaussian(0, \sigma_0^2I_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 ~ Gaussian(0, \sigma_0^2V_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">\eta ~ Gaussian(0,\sigma^2)</code>
</p>

<p>where <code class="reqn">\beta_0</code> and <code class="reqn">\beta_1</code> are fixed
effects, and <code class="reqn">V_{sp}</code> is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution). Here, the variation in the mean
(intercept) for each species is given by the random effect
<code class="reqn">b_0</code> that is assumed to be independent among
species. Variation in species' responses to predictor variable
<code class="reqn">x</code> is given by a random effect <code class="reqn">b_0</code> that is
assumed to depend on the phylogenetic relatedness among species
given by <code class="reqn">V_{sp}</code>; if species are closely related,
their specific responses to <code class="reqn">x</code> will be similar. This
particular model would be specified as
</p>
<p><code>re.1 &lt;- list(1, sp = dat$sp, covar = diag(nspp))</code>
<code>re.2 &lt;- list(dat$X, sp = dat$sp, covar = Vsp)</code>
<code>z &lt;- communityPGLMM(Y ~ X, data = data, family = "gaussian", random.effects = list(re.1, re.2))</code>
</p>
<p>The covariance matrix covar is standardized to have its determinant
equal to 1. This in effect standardizes the interpretation of the
scalar <code class="reqn">\sigma^2</code>. Although mathematically this is
not required, it is a very good idea to standardize the predictor
(independent) variables to have mean 0 and variance 1. This will
make the function more robust and improve the interpretation of the
regression coefficients. For categorical (factor) predictor
variables, you will need to construct 0-1 dummy variables, and
these should not be standardized (for obvious reasons).
</p>
<p>For binary generalized linear mixed models (<code>family =
'binomial'</code>), the function estimates parameters for the model of
the form, for example,
</p>
<p style="text-align: center;"><code class="reqn">y = \beta_0 + \beta_1x + b_0 + b_1x</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = logit^{-1}(y)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_0 ~ Gaussian(0, \sigma_0^2I_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 ~ Gaussian(0, \sigma_0^2V_{sp})</code>
</p>

<p>where <code class="reqn">\beta_0</code> and <code class="reqn">\beta_1</code> are fixed
effects, and <code class="reqn">V_{sp}</code> is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution).
</p>
<p><code>z &lt;- communityPGLMM(Y ~ X, data = data, family =
'binomial', random.effects = list(re.1, re.2))</code>
</p>
<p>As with the linear mixed model, it is a very good idea to
standardize the predictor (independent) variables to have mean 0
and variance 1. This will make the function more robust and improve
the interpretation of the regression coefficients. For categorical
(factor) predictor variables, you will need to construct 0-1 dummy
variables, and these should not be standardized (for obvious
reasons).
</p>


<h3>Value</h3>

<p>an object of class <code>communityPGLMM</code>
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>the formula for fixed effects</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>either <code>gaussian</code> or <code>binomial</code> depending on the model fit</p>
</td></tr>
<tr><td><code>random.effects</code></td>
<td>
<p>the list of random effects</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimates of the regression coefficients</p>
</td></tr>
<tr><td><code>B.se</code></td>
<td>
<p>approximate standard errors of the fixed effects regression coefficients</p>
</td></tr>
<tr><td><code>B.cov</code></td>
<td>
<p>approximate covariance matrix for the fixed effects regression coefficients</p>
</td></tr>
<tr><td><code>B.zscore</code></td>
<td>
<p>approximate Z scores for the fixed effects regression coefficients</p>
</td></tr>
<tr><td><code>B.pvalue</code></td>
<td>
<p>approximate tests for the fixed effects regression coefficients being different from zero</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>random effects' standard deviations for the covariance matrix <code class="reqn">\sigma^2V</code> for each random effect in order. For the linear mixed model, the residual variance is listed last</p>
</td></tr>
<tr><td><code>s2r</code></td>
<td>
<p>random effects variances for non-nested random effects</p>
</td></tr>
<tr><td><code>s2n</code></td>
<td>
<p>random effects variances for nested random effects</p>
</td></tr>
<tr><td><code>s2resid</code></td>
<td>
<p>for linear mixed models, the residual vairance</p>
</td></tr>
<tr><td><code>logLIK</code></td>
<td>
<p>for linear mixed models, the log-likelihood for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>for linear mixed models, the AIC for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>for linear mixed models, the BIC for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>REML</code></td>
<td>
<p>whether or not REML is used (<code>TRUE</code> or <code>FALSE</code>)</p>
</td></tr>
<tr><td><code>s2.init</code></td>
<td>
<p>the user-provided initial estimates of <code>s2</code></p>
</td></tr>
<tr><td><code>B.init</code></td>
<td>
<p>the user-provided initial estimates of <code>B</code></p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the response (dependent) variable returned in matrix form</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the predictor (independent) variables returned in matrix form (including 1s in the first column)</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the residuals. For the generalized linear mixed model, these are the predicted residuals in the <code class="reqn">logit^{-1}</code> space</p>
</td></tr>
<tr><td><code>iV</code></td>
<td>
<p>the inverse of the covariance matrix for the entire system (of dimension (nsp*nsite) by (nsp*nsite))</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>predicted mean values for the generalized linear mixed model. Set to NULL for linear mixed models</p>
</td></tr>
<tr><td><code>sp</code>, <code>sp</code></td>
<td>
<p>matrices used to construct the nested design matrix</p>
</td></tr>
<tr><td><code>Zt</code></td>
<td>
<p>the design matrix for random effects</p>
</td></tr>
<tr><td><code>St</code></td>
<td>
<p>diagonal matrix that maps the random effects variances onto the design matrix</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p>the convergence code provided by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations performed by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>These function <em>do not</em> use a
<code><a href="#topic+comparative.comm">comparative.comm</a></code> object, but you can use
<code><a href="#topic+as.data.frame.comparative.comm">as.data.frame.comparative.comm</a></code> to
create a <code>data.frame</code> for use with these functions. The power
of this method comes from deciding your own parameters parameters
to be determined (the data for regression, the random effects,
etc.), and it is our hope that this interface gives you more
flexibility in model selection/fitting.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives, cosmetic changes by Will Pearse
</p>


<h3>References</h3>

<p>Ives, A. R. and M. R. Helmus. 2011. Generalized linear
mixed models for phylogenetic analyses of community
structure. Ecological Monographs 81:511-525.
</p>
<p>Rafferty, N. E., and A. R. Ives. 2013. Phylogenetic
trait-based analyses of ecological networks. Ecology 94:2321-2333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Structure of examples:
# First, a (brief) description of model types, and how they are specified
# - these are *not* to be run 'as-is'; they show how models should be organised
# Second, a run-through of how to simulate, and then analyse, data
# - these *are* to be run 'as-is'; they show how to format and work with data

## Not run: 
#########################################################
#First section; brief summary of models and their use####
#########################################################
## Model structures from Ives &amp; Helmus (2011)
# dat = data set for regression (note: *not* an comparative.comm object)
# nspp = number of species
# nsite = number of sites
# Vphy = phylogenetic covariance matrix for species
# Vrepul = inverse of Vphy representing phylogenetic repulsion

# Model 1 (Eq. 1)
re.site &lt;- list(1, site = dat$site, covar = diag(nsite))
re.sp.site &lt;- list(1, sp = dat$sp, covar = Vphy, site = dat$site) # note: nested
z &lt;- communityPGLMM(freq ~ sp, data = dat, family = "binomial", sp
= dat$sp, site = dat$site, random.effects = list(re.site,
re.sp.site), REML = TRUE, verbose = TRUE, s2.init=.1)


# Model 2 (Eq. 2)
re.site &lt;- list(1, site = dat$site, covar = diag(nsite))
re.slope &lt;- list(X, sp = dat$sp, covar = diag(nspp))
re.slopephy &lt;- list(X, sp = dat$sp, covar = Vphy)
z &lt;- communityPGLMM(freq ~ sp + X, data = dat, family = "binomial",
sp = dat$sp, site = dat$site, random.effects = list(re.site,
re.slope, re.slopephy), REML = TRUE, verbose = TRUE, s2.init=.1)

# Model 3 (Eq. 3)
re.site &lt;- list(1, site = dat$site, covar = diag(nsite))
re.sp.site &lt;- list(1, sp = dat$sp, covar = Vrepul, site = dat$site) # note: nested
z &lt;- communityPGLMM(freq ~ sp*X, data = dat, family = "binomial",
sp = dat$sp, site = dat$site, random.effects = list(re.site,
re.sp.site), REML = TRUE, verbose = TRUE, s2.init=.1)

## Model structure from Rafferty &amp; Ives (2013) (Eq. 3)
# dat = data set
# npp = number of pollinators (sp)
# nsite = number of plants (site)
# VphyPol = phylogenetic covariance matrix for pollinators
# VphyPlt = phylogenetic covariance matrix for plants

re.a &lt;- list(1, sp = dat$sp, covar = diag(nspp))
re.b &lt;- list(1, sp = dat$sp, covar = VphyPol)
re.c &lt;- list(1, sp = dat$sp, covar = VphyPol, dat$site)
re.d &lt;- list(1, site = dat$site, covar = diag(nsite))
re.f &lt;- list(1, site = dat$site, covar = VphyPlt)
re.g &lt;- list(1, site = dat$site, covar = VphyPlt, dat$sp)
#term h isn't possible in this implementation, but can be done with
available matlab code

z &lt;- communityPGLMM(freq ~ sp*X, data = dat, family = "binomial",
sp = dat$sp, site = dat$site, random.effects = list(re.a, re.b,
re.c, re.d, re.f, re.g), REML = TRUE, verbose = TRUE, s2.init=.1)

## End(Not run)

#########################################################
#Second section; detailed simulation and analysis #######
#NOTE: this section is explained and annotated in #######
#      detail in the vignette 'pez-pglmm-overview'#######
#      run 'vignette('pez-pglmm-overview') to read#######
#########################################################
# Generate simulated data for nspp species and nsite sites
nspp &lt;- 15
nsite &lt;- 10

# residual variance (set to zero for binary data)
sd.resid &lt;- 0

# fixed effects
beta0 &lt;- 0
beta1 &lt;- 0

# magnitude of random effects
sd.B0 &lt;- 1
sd.B1 &lt;- 1

# whether or not to include phylogenetic signal in B0 and B1
signal.B0 &lt;- TRUE
signal.B1 &lt;- TRUE

# simulate a phylogenetic tree
phy &lt;- rtree(n = nspp)
phy &lt;- compute.brlen(phy, method = "Grafen", power = 0.5)

# standardize the phylogenetic covariance matrix to have determinant 1
Vphy &lt;- vcv(phy)
Vphy &lt;- Vphy/(det(Vphy)^(1/nspp))

# Generate environmental site variable
X &lt;- matrix(1:nsite, nrow = 1, ncol = nsite)
X &lt;- (X - mean(X))/sd(X)

# Perform a Cholesky decomposition of Vphy. This is used to
# generate phylogenetic signal: a vector of independent normal random
# variables, when multiplied by the transpose of the Cholesky
# deposition of Vphy will have covariance matrix equal to Vphy.

iD &lt;- t(chol(Vphy))

# Set up species-specific regression coefficients as random effects
if (signal.B0 == TRUE) {
		b0 &lt;- beta0 + iD %*% rnorm(nspp, sd = sd.B0)
} else {
		b0 &lt;- beta0 + rnorm(nspp, sd = sd.B0)
}
if (signal.B1 == TRUE) {
		b1 &lt;- beta1 + iD %*% rnorm(nspp, sd = sd.B1)
} else {
		b1 &lt;- beta1 + rnorm(nspp, sd = sd.B1)
}

# Simulate species abundances among sites to give matrix Y that
# contains species in rows and sites in columns
y &lt;- rep(b0, each=nsite)
y &lt;- y + rep(b1, each=nsite) * rep(X, nspp)
y &lt;- y + rnorm(nspp*nsite) #add some random 'error'
Y &lt;- rbinom(length(y), size=1, prob=exp(y)/(1+exp(y)))
y &lt;- matrix(outer(b0, array(1, dim = c(1, nsite))), nrow = nspp,
ncol = nsite) + matrix(outer(b1, X), nrow = nspp, ncol = nsite)
e &lt;- rnorm(nspp * nsite, sd = sd.resid)
y &lt;- y + matrix(e, nrow = nspp, ncol = nsite)
y &lt;- matrix(y, nrow = nspp * nsite, ncol = 1)

Y &lt;- rbinom(n = length(y), size = 1, prob = exp(y)/(1 + exp(y)))
Y &lt;- matrix(Y, nrow = nspp, ncol = nsite)

# name the simulated species 1:nspp and sites 1:nsites
rownames(Y) &lt;- 1:nspp
colnames(Y) &lt;- 1:nsite

par(mfrow = c(3, 1), las = 1, mar = c(2, 4, 2, 2) - 0.1)
matplot(t(X), type = "l", ylab = "X", main = "X among sites")
hist(b0, xlab = "b0", main = "b0 among species")
hist(b1, xlab = "b1", main = "b1 among species")

#Plot out; you get essentially this from plot(your.pglmm.model)
image(t(Y), ylab = "species", xlab = "sites", main = "abundance",
col=c("black","white"))

# Transform data matrices into "long" form, and generate a data frame
YY &lt;- matrix(Y, nrow = nspp * nsite, ncol = 1)

XX &lt;- matrix(kronecker(X, matrix(1, nrow = nspp, ncol = 1)), nrow =
nspp * nsite, ncol = 1)

site &lt;- matrix(kronecker(1:nsite, matrix(1, nrow = nspp, ncol =
1)), nrow = nspp * nsite, ncol = 1)
sp &lt;- matrix(kronecker(matrix(1, nrow = nsite, ncol = 1), 1:nspp),
nrow = nspp * nsite, ncol = 1)

dat &lt;- data.frame(Y = YY, X = XX, site = as.factor(site), sp = as.factor(sp))

# Format input and perform communityPGLMM()
# set up random effects

# random intercept with species independent
re.1 &lt;- list(1, sp = dat$sp, covar = diag(nspp))

# random intercept with species showing phylogenetic covariances
re.2 &lt;- list(1, sp = dat$sp, covar = Vphy)

# random slope with species independent
re.3 &lt;- list(dat$X, sp = dat$sp, covar = diag(nspp))

# random slope with species showing phylogenetic covariances
re.4 &lt;- list(dat$X, sp = dat$sp, covar = Vphy)

# random effect for site
re.site &lt;- list(1, site = dat$site, covar = diag(nsite))

simple &lt;- communityPGLMM(Y ~ X, data = dat, family = "binomial", sp
= dat$sp, site = dat$site, random.effects = list(re.site),
REML=TRUE, verbose=FALSE)

# The rest of these tests are not run to save CRAN server time;
# - please take a look at them because they're *very* useful!
## Not run:  
z.binary &lt;- communityPGLMM(Y ~ X, data = dat, family = "binomial",
sp = dat$sp, site = dat$site, random.effects = list(re.1, re.2,
re.3, re.4), REML = TRUE, verbose = FALSE)

# output results
z.binary
plot(z.binary)

# test statistical significance of the phylogenetic random effect
# on species slopes using a likelihood ratio test
communityPGLMM.binary.LRT(z.binary, re.number = 4)$Pr

# extract the predicted values of Y
communityPGLMM.predicted.values(z.binary, show.plot = TRUE)

# examine the structure of the overall covariance matrix
communityPGLMM.matrix.structure(Y ~ X, data = dat, family =
"binomial", sp = dat$sp, site = dat$site, random.effects =
list(re.1, re.2, re.3, re.4))

# look at the structure of re.1
communityPGLMM.matrix.structure(Y ~ X, data = dat, family =
"binomial", sp = dat$sp, site = dat$site, random.effects =
list(re.1))

# compare results to glmer() when the model contains no
# phylogenetic covariance among species; the results should be
# similar.
communityPGLMM(Y ~ X, data = dat, family = "binomial", sp = dat$sp,
site = dat$site, random.effects = list(re.1, re.3), REML = FALSE,
verbose = FALSE)

# lmer
if(require(lme4)){
summary(glmer(Y ~ X + (1 | sp) + (0 + X | sp), data=dat, family =
"binomial"))

# compare results to lmer() when the model contains no phylogenetic
# covariance among species; the results should be similar.
communityPGLMM(Y ~ X, data = dat, family = "gaussian", sp = dat$sp,
site = dat$site, random.effects = list(re.1, re.3), REML = FALSE,
verbose = FALSE)

# lmer
summary(lmer(Y ~ X + (1 | sp) + (0 + X | sp), data=dat, REML = FALSE))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='phy.build'>Build a novel phylogeny from existing data</h2><span id='topic+phy.build'></span><span id='topic+congeneric.merge'></span><span id='topic+bind.replace'></span><span id='topic+congeneric.impute'></span>

<h3>Description</h3>

<p>Build a novel phylogeny from existing data
</p>
<p><code>congeneric.impute</code> sequentially add species to a phylogeny to
form an _imputed_ bifurcating tree. Makes use of a result from
Steel &amp; Mooers (2010) that gives the expected branch-length under a
Yule model whether the rate of diversification has been
estimated. The intention of this is to approximate the method by
which phylogenetic structure is sampled from the prior in BEAST;
i.e., to approximate the standard Kuhn et al. (2011) method for
imputing a phylogeny. When using <code>congeneric.impute</code> you
should (1) repeat your analyses across many (if in doubt,
thousands) of separate runs (see Kuhn et al. 2011) and (2) check
for yourself that your trees are unbiased for your purpose - I make
no guarantee this is appropriate, and in many cases I think it
would not be. See also 'notes' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congeneric.merge(tree, species, split = "_", ...)

bind.replace(backbone, donor, replacing.tip.label, donor.length = NA)

congeneric.impute(tree, species, split = "_", max.iter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy.build_+3A_tree">tree</code></td>
<td>
<p><code><a href="ape.html#topic+phylo">phylo</a></code> phylogeny to have those
species inserted into it</p>
</td></tr>
<tr><td><code id="phy.build_+3A_species">species</code></td>
<td>
<p>vector of species names to be bound into the tree if
missing from it</p>
</td></tr>
<tr><td><code id="phy.build_+3A_split">split</code></td>
<td>
<p>the character that splits genus and species names in
your phylogeny. Default is <code>_</code>, i.e. Quercus_robur.</p>
</td></tr>
<tr><td><code id="phy.build_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="phy.build_+3A_backbone">backbone</code></td>
<td>
<p>backbone phylogeny (<code><a href="ape.html#topic+phylo">phylo</a></code>)
into which the donor is to be bound</p>
</td></tr>
<tr><td><code id="phy.build_+3A_donor">donor</code></td>
<td>
<p>phylogeny (<code><a href="ape.html#topic+phylo">phylo</a></code>) to bound
into the backbone phylogeny</p>
</td></tr>
<tr><td><code id="phy.build_+3A_replacing.tip.label">replacing.tip.label</code></td>
<td>
<p>the species in the donor phylogeny
that's being replaced by the donor phylogeny</p>
</td></tr>
<tr><td><code id="phy.build_+3A_donor.length">donor.length</code></td>
<td>
<p>how deep the donor phylogeny should be cut into
the backbone phylogeny. If NA (default), then the bladj algorithm
is followed (or, in plain English, it's put half-way along the
branch)</p>
</td></tr>
<tr><td><code id="phy.build_+3A_max.iter">max.iter</code></td>
<td>
<p>Sometimes the random draw for the new branch length
to be added will be too large to allow it to be added to the
tree. In such cases, <code>congeneric.imput</code> will randomly draw
another branch length, and it will repeat this process
<code>max.iter</code> times. See 'notes' for more on this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>congeneric.merge</code> Binds missing species into a
phylogeny by replacing all members of the clade it belongs to with
a polytomy. Assumes the <code>tip.labels</code> represent Latin
binomials, split by the <code>split</code> argument. This code was
originally shipped with phyloGenerator - this is the <code>merge</code>
method in that program.
</p>
<p><code>bind.replace</code> Binds a phylogeny (donor) into a
bigger phylogeny ('backbone'); useful if you're building a
phylogeny a la Phylomatic. A version of this R code was shipped
with phyloGenerator (Pearse &amp; Purvis 2013). This is really an
internal function for <code>congeneric.merge</code>, but hopefully it's
of some use to you!
</p>


<h3>Value</h3>

<p><code><a href="ape.html#topic+phylo">phylo</a></code> phylogeny
</p>
<p>phylogeny (<code><a href="ape.html#topic+phylo">phylo</a></code>)
</p>


<h3>Note</h3>

<p>Thank you to Josep Padulles Cubino, who found that the genus
name splitting in a previous version of this function could
cause incorrect placement in oddly named cases. As with all
phylogenetic construction tools, the output from
<code>congeneric.merge</code> should be checked for accuracy before
use.
</p>
<p>Caveats for <code>congeneric.impute</code>: something I noticed is
that BEAST randomly picks an edge to break when adding species
(starting from a null tree), and this is the behaviour I have
(attempted to) replicate here. It is not clear to me that this
is unbiased, since a clade undergoing rapid diversification
will have many edges but these will be short (and so cannot
have an edge inserted into them following the method below). My
understanding is this is a known problem, and I simply cannot
think of a better way of doing this that doesn't incorporate
what I consider to be worse pathology. Thus this method, even
if it works (which I can't guarantee), it should tend to break
long branches.
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>
<p>Will Pearse
</p>


<h3>References</h3>

<p>Pearse W.D. &amp; Purvis A. phyloGenerator: an automated phylogeny generation tool for ecologists. Methods in Ecology and Evolution 4(7): 692&ndash;698.
</p>
<p>Steel, M., &amp; Mooers, A. (2010). The expected length of
pendant and interior edges of a Yule tree. Applied Mathematics
Letters, 23(11), 1315-1319.
</p>
<p>Kuhn, T. S., Mooers, A. O., &amp; Thomas, G. H. (2011). A
simple polytomy resolver for dated phylogenies. Methods in
Ecology and Evolution, 2(5), 427-436.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- read.tree(text="((a_a:1,b_b:1):1, c_c:2):1;")
tree &lt;- congeneric.merge(tree, c("a_nother", "a_gain", "b_sharp"))
tree &lt;- read.tree(text="((a_a:1,b_b:1):1, c_c:2):1;")
tree &lt;- congeneric.impute(tree, c("a_nother", "a_gain", "b_sharp"))
</code></pre>

<hr>
<h2 id='phy.signal'>Calculate phylogenetic &lsquo;signal&rsquo;</h2><span id='topic+phy.signal'></span>

<h3>Description</h3>

<p>Calculate phylogenetic &lsquo;signal&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phy.signal(data, method = c("lambda", "delta", "kappa", "blom.k"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy.signal_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="phy.signal_+3A_method">method</code></td>
<td>
<p>what kind of signal to calculate, one of Pagel's
lambda(default), delta, and kappa, or Blomberg's K.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phylogenetic &lsquo;signal&rsquo; is one of those concepts that is
said a lot in community ecology, but some do not full consider
its meaning. Think carefully before rushing to report a value
whether: (1) it makes sense to assess phylogenetic &lsquo;signal&rsquo; in
your datasets, and (2) what the phrase &lsquo;phylogenetic signal&rsquo;
actually means. This code makes use of <code>caper::<a href="caper.html#topic+pgls">pgls</a></code>
to get estimates of fit; alternatives that offer more flexibility
exist (see below).
</p>


<h3>Value</h3>

<p>Named numeric vector, where each element is a trait or
community.
</p>


<h3>Author(s)</h3>

<p>Will Pearse, Jeannine Cavender-Bares
</p>


<h3>References</h3>

<p>Blomberg S.P., Garland T. &amp; Ives A.R. Testing for
phylogenetic signal in comparative data: behavioral traits are
more labile. Evolution 57(4): 717&ndash;745.
</p>
<p>R. P. Freckleton, P. H. Harvey, and
M. Pagel. Phylogenetic analysis and comparative data: A test and
review of evidence. American Naturalist, 160:712-726, 2002.
</p>
<p>Mark Pagel (1999) Inferring the historical patterns of
biological evolution. Nature 6756(401): 877&ndash;884.
</p>


<h3>See Also</h3>

<p>fitContinuous fitDiscrete pgls phylosignal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
phy.signal(data, "lambda")
</code></pre>

<hr>
<h2 id='plot.comparative.comm'>Dot-plots of community presence/absence or abundance</h2><span id='topic+plot.comparative.comm'></span>

<h3>Description</h3>

<p>Dot-plots of community presence/absence or abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'comparative.comm'
plot(
  x,
  sites = NULL,
  abundance = FALSE,
  pch = 20,
  dot.cex = NULL,
  site.col = "black",
  fraction = 3,
  x.increment = NULL,
  show.tip.label = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.comparative.comm_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_sites">sites</code></td>
<td>
<p>names of sites to plot (default: all); see examples</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_abundance">abundance</code></td>
<td>
<p>make size proportional to species abundance
(default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_pch">pch</code></td>
<td>
<p>plotting character to be used for sites (see
<code><a href="graphics.html#topic+pch">pch</a></code>)</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_dot.cex">dot.cex</code></td>
<td>
<p>function to determine point size; see examples, this
isn't as terrible-sounding as it seems.</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_site.col">site.col</code></td>
<td>
<p>colours to use when plotting sites; if not same
length as number of sites, only the first element is used (no
recycling)</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_fraction">fraction</code></td>
<td>
<p>fraction of plot window to be taken up with
phylogeny; e.g., 3 (default) means phylogeny is 1/3 of plot</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_x.increment">x.increment</code></td>
<td>
<p>specify exact spacing of points along plot; see
examples</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>whether to plot species names on phylogeney
(default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.comparative.comm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Take a look at the examples: this is (hopefully!) a lot
more straightforward than it might seem. Getting the right spacing
of dots on the phylogeny may take some playing around with the
<code>fraction</code> and <code>x.increment</code> arguments. It may seem a
little strange to set point size using a function, however, this
gives you much more flexibility and the ability to (usefully)
transform your data.
</p>


<h3>Value</h3>

<p>List containing plot.phylo information, as well as the used
x.adj values (compare with your <code>x.increment</code>)
</p>


<h3>Author(s)</h3>

<p>Will Pearse, Matt Helmus
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> <code><a href="#topic+traitgram.cc">traitgram.cc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laja)
data &lt;- comparative.comm(invert.tree, river.sites, invert.traits)
plot(data)
plot(data, sites=c("AT", "BP"), fraction=1.5)
settings &lt;- plot(data, sites=c("AT", "BP"), site.col=rainbow(2), fraction=1.5)
plot(data, sites=c("AT", "BP"), site.col=rainbow(2),
fraction=1.2, x.increment=settings$x.increment/4)
#dot.cex isn't as scary as it sounds...
plot(data, site.col=rainbow(2), fraction=1.2, abundance=TRUE, dot.cex=sqrt)
#...or other trivial variants...
abund.sqrt &lt;- function(x) ifelse(x&gt;0, sqrt(x), 0)
plot(data, sites=c("AT", "BP"), site.col=rainbow(2), fraction=1.2,
x.increment=settings$x.increment/4, abundance=TRUE, dot.cex=abund.sqrt)
plot(data, sites=c("AT", "BP"), site.col=rainbow(2), fraction=1.2,
x.increment=settings$x.increment/4, abundance=TRUE, dot.cex=function(x) sqrt(x))
</code></pre>

<hr>
<h2 id='scape'>Simulate phylogenetic community structure across a landscape</h2><span id='topic+scape'></span>

<h3>Description</h3>

<p><code>scape</code> simulates communities that are phylogenetically structured
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scape(
  tree,
  scape.size = 10,
  g.center = 1,
  g.range = 1,
  g.repulse = 1,
  wd.all = 150,
  signal.center = TRUE,
  signal.range = TRUE,
  same.range = TRUE,
  repulse = TRUE,
  center.scale = 1,
  range.scale = 1,
  repulse.scale = 1,
  site.stoch.scale = 0.5,
  sd.center = 1,
  sd.range = 1,
  rho = NULL,
  th = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scape_+3A_tree">tree</code></td>
<td>
<p><code><a href="ape.html#topic+phylo">phylo</a></code> object</p>
</td></tr>
<tr><td><code id="scape_+3A_scape.size">scape.size</code></td>
<td>
<p>edge dimension of square landscape</p>
</td></tr>
<tr><td><code id="scape_+3A_g.center">g.center</code></td>
<td>
<p>strength of phylogenetic signal in species range centers</p>
</td></tr>
<tr><td><code id="scape_+3A_g.range">g.range</code></td>
<td>
<p>strength of phylogenetic signal in species range sizes</p>
</td></tr>
<tr><td><code id="scape_+3A_g.repulse">g.repulse</code></td>
<td>
<p>strength of phylogenetic repulsion</p>
</td></tr>
<tr><td><code id="scape_+3A_wd.all">wd.all</code></td>
<td>
<p>niche width, larger values simulate broader range sizes</p>
</td></tr>
<tr><td><code id="scape_+3A_signal.center">signal.center</code></td>
<td>
<p>simulate with phylosignal in range centers</p>
</td></tr>
<tr><td><code id="scape_+3A_signal.range">signal.range</code></td>
<td>
<p>simulate with phylosignal in range size</p>
</td></tr>
<tr><td><code id="scape_+3A_same.range">same.range</code></td>
<td>
<p>make all range sizes equal</p>
</td></tr>
<tr><td><code id="scape_+3A_repulse">repulse</code></td>
<td>
<p>include phylogenetic repulsion in range centers</p>
</td></tr>
<tr><td><code id="scape_+3A_center.scale">center.scale</code></td>
<td>
<p>adjust strength of phylogenetic attraction in
range centers independent of <code>g.center</code></p>
</td></tr>
<tr><td><code id="scape_+3A_range.scale">range.scale</code></td>
<td>
<p>adjust strength of phylogenetic signal in range
size independent of <code>g.range</code></p>
</td></tr>
<tr><td><code id="scape_+3A_repulse.scale">repulse.scale</code></td>
<td>
<p>adjust strength of phylogenetic repulsion
independent of <code>g.repulse</code></p>
</td></tr>
<tr><td><code id="scape_+3A_site.stoch.scale">site.stoch.scale</code></td>
<td>
<p>adjust strength of random variation in
species richness across sites</p>
</td></tr>
<tr><td><code id="scape_+3A_sd.center">sd.center</code></td>
<td>
<p>sd in <code><a href="stats.html#topic+rnorm">rnorm</a></code> for the range centers,
increase to get more variation in center values across species</p>
</td></tr>
<tr><td><code id="scape_+3A_sd.range">sd.range</code></td>
<td>
<p>sd <code><a href="stats.html#topic+rnorm">rnorm</a></code> for the range sizes,
increase to get more variation in range sizes across gradients</p>
</td></tr>
<tr><td><code id="scape_+3A_rho">rho</code></td>
<td>
<p>Grafen branch adjustment of phylogenetic tree see
<code><a href="ape.html#topic+corGrafen">corGrafen</a></code></p>
</td></tr>
<tr><td><code id="scape_+3A_th">th</code></td>
<td>
<p>probability threshold 10^-th above which species are
considered present at a site</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates a landscape with species (i.e., tree tips)
distributions dependent on a supplied phylogenetic tree.  The
amount and type of structure is determened by the signal parameters
<code>g.center</code>, <code>g.range</code> and <code>g.repulse</code>. Parameters
are based on an Ornstein-Uhlenbeck model of evolution with
stabilizing selection. Values of g=1 indicate no stabilizing
selection and correspond to the Brownian motion model of evolution;
0&lt;g&lt;1 represents stabilizing selection; and g&gt;1 corresponds to
disruptive selection where phylogenetic signal for the supplied
tree is amplified. See <code><a href="ape.html#topic+corBlomberg">corBlomberg</a></code>.  Communities are
simulated along two gradients where the positions along those
gradients, <code>g.center</code> and range sizes <code>g.range</code>, can
exhibit phylogenetic signal. Phylogenetic attraction is simulated
in the <code>g.center</code> paramter, while repulsion in
<code>g.repulse</code>. Both can be exhibited such that closly related
species are generally found with similar range centers
(phylogenetic attraction) but just not at the same site
(phylogenetic repulsion).  The function then returns probabilities
of of each species across sites and the presence and absences of
species based a supplied threshold, <code>th</code>, which can be
increased to obtain more species at sites and thus increase average
site species richness.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cc</code></td>
<td>
<p><code><a href="#topic+comparative.comm">comparative.comm</a></code> object with presence/absence
results of simulations. The site names are the row.columns of the
cells in the original grid cells that made up the data, and these
co-ordinates are also given in the <code>env</code> slot of the object.</p>
</td></tr>
<tr><td><code>X.joint</code></td>
<td>
<p>full probabilities of species at sites, used
to construct <code>cc</code></p>
</td></tr>
<tr><td><code>X1</code></td>
<td>
<p>probabilities of species along gradient 1</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>probabilities of species along gradient 2</p>
</td></tr>
<tr><td><code>sppXs</code></td>
<td>
<p>full probabilities of each species as an array
arranged in a <code>scape.size</code>-by-<code>scape.size</code> matrix</p>
</td></tr>
<tr><td><code>V.phylo</code></td>
<td>
<p>initial phylogenetic covariance matrix from
tree</p>
</td></tr>
<tr><td><code>V.phylo.rho</code></td>
<td>
<p>phylogenetic covariance matrix from tree
scaled by Grafen if rho is provided</p>
</td></tr>
<tr><td><code>V.center</code></td>
<td>
<p>scaled by <code>g.center</code> phylo covariance
matrix used in the simulations</p>
</td></tr>
<tr><td><code>V.range</code></td>
<td>
<p>scaled by <code>g.range</code> phylo covariance
matrix used in the simulations</p>
</td></tr>
<tr><td><code>V.repulse</code></td>
<td>
<p>scaled by <code>g.repulse</code> phylo
covariance matrix used in the simulations</p>
</td></tr>
<tr><td><code>bspp1</code></td>
<td>
<p>species optima for gradient 1</p>
</td></tr>
<tr><td><code>bspp2</code></td>
<td>
<p>species optima for gradient 2</p>
</td></tr>                              
<tr><td><code>u</code></td>
<td>
<p>the env gradients values for the two gradients</p>
</td></tr>
<tr><td><code>wd</code></td>
<td>
<p>the denominator for species ranges</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.R. Helmus, cosmetic changes by Will Pearse
</p>


<h3>References</h3>

<p>Helmus M.R. &amp; Ives A.R. (2012). Phylogenetic diversity
area curves. Ecology, 93, S31-S43.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eco.scape">eco.scape</a></code> <code><a href="#topic+sim.phy">sim.phy</a></code>
<code><a href="#topic+sim.meta">sim.meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create balanced tree with equal branch-lengths (signal in centers)
tree &lt;- stree(8,type="balanced")
tree$edge.length &lt;- rep(1, nrow(tree$edge))
tree$root &lt;- 1
kk &lt;- scape(tree, scape.size=100, g.center=100, g.range=1, g.repulse=1, wd.all=150,
    signal.center=TRUE, signal.range=FALSE, same.range=FALSE, repulse=FALSE,center.scale = 1,
    range.scale = 1, repulse.scale = 1, site.stoch.scale = 0, sd.center=3, sd.range=1,
    rho=NULL, th=20)

#Make some plots
par(mfrow=c(1,Ntip(tree)),mar=c(.1,.1,.1,.1))
for(j in seq_along(tree$tip.label))
    image(t(1 - kk$sppXs[,,j]/max(kk$sppXs[,,j])), xlab = "",
              ylab = "",main = "",axes=FALSE, col=grey.colors(10))

par(mfrow=c(2,1))
matplot((kk$X1), type = "l", xlab="gradient",ylab = "probability",
main = "Gradient 1",col=rainbow(dim(kk$X1)[2]),lty=1)
matplot((kk$X2), type = "l", xlab="gradient",ylab = "probability",
main = "Gradient 2",col=rainbow(dim(kk$X2)[2]),lty=1)

plot(x=seq_along(sites(kk$cc)),y = rowSums(comm(kk$cc)), main = "SR",type = "l")
cor(kk$X1)
</code></pre>

<hr>
<h2 id='sim.meta'>Simulate a meta-community (and its phylogeny)</h2><span id='topic+sim.meta'></span><span id='topic+sim.meta.comm'></span><span id='topic+sim.meta.phy.comm'></span>

<h3>Description</h3>

<p><code>sim.meta.comm</code> simulates species moving through a
metacommunity. At each time-step each cell's next abundance for
each species is <code>env.quality</code> - <code>current.abundance</code> +
<code>stochastic</code>, and a species gets as many chances to migrate in
each time-step as it has cells (the same cell could migrate
multiple times). I use a Poisson for everything because I don't
want half-species (these are individuals), and keeping everything
in Poisson makes it easier to compare the relative rates of
everything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.meta.comm(
  size = 10,
  n.spp = 8,
  timesteps = 10,
  p.migrate = 0.05,
  env.lam = 10,
  abund.lam = 5,
  stoch.lam = 1
)

sim.meta.phy.comm(
  size = 10,
  n.spp = 8,
  timesteps = 10,
  p.migrate = 0.3,
  env.lam = 10,
  abund.lam = 5,
  stoch.lam = 1,
  p.speciate = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.meta_+3A_size">size</code></td>
<td>
<p>the length and width of the meta-community in grid
cells</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_n.spp">n.spp</code></td>
<td>
<p>number of species</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_timesteps">timesteps</code></td>
<td>
<p>number of time-steps (each discrete)</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_p.migrate">p.migrate</code></td>
<td>
<p>probability that a group of species in each grid
cell will migrate to another grid cell each timestep (i.e., 10
cells occuped by a species &ndash;&gt; 10*<code>p.migrate</code> chance of
migration)</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_env.lam">env.lam</code></td>
<td>
<p>lambda value for Poisson
distribution used to distribute environmental quality; essentially
the carrying capacity (for each species separately) for that cell</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_abund.lam">abund.lam</code></td>
<td>
<p>lambda value for Poisson
distribution used to distribute initial abundances and abundance
after migration</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_stoch.lam">stoch.lam</code></td>
<td>
<p>lambda value for Poisson
distribution of noise added to the next step abundance
calculation. With equal chance, this is taken as either a positive
or a negative number (see details if you're confused as to why this
is Poisson!)</p>
</td></tr>
<tr><td><code id="sim.meta_+3A_p.speciate">p.speciate</code></td>
<td>
<p>probabilty that, at each timestep, a species will
speciate. A species can only speciate, migrate, or reproduce if it
has individuals!</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim.meta.phy.comm</code> As above, but with a simulation of
phylogeny as well - there are no additional extinction parameters,
since extinction happens as a natural consequence of ecological
interactions.
</p>


<h3>Value</h3>

<p>For <code>sim.meta.comm</code> a list with a species-site matrix
as the first slot, and the environment as the second. Rownames of
the site-species are the List with the x and y co-ordinates of the
simulation grid pasted together; colnames are arbitrary species
names. <code>sim.meta.comm</code>, a <code><a href="#topic+comparative.comm">comparative.comm</a></code>
object (since we have now simulated a phylogeny), with the same
naming convention for the site names.  phylogeny.
</p>
<p><code>sim.meta.phy.comm</code> <code><a href="#topic+comparative.comm">comparative.comm</a></code>
object that describes the data; note that the rownames of the
community object refer to the <code>row.column</code> of the data in the
simulated grid assemblages.
</p>


<h3>Note</h3>

<p><code><a href="#topic+scape">scape</a></code> is a much more sophisticated simulation
of the biogeography, but requires you to supply a phylogeny. You
pays your money, you makes your choice.
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>
<p>Will Pearse
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.phy">sim.phy</a></code> <code><a href="#topic+scape">scape</a></code>
</p>

<hr>
<h2 id='sim.phy'>Simulate phylogenies</h2><span id='topic+sim.phy'></span><span id='topic+sim.bd.phy'></span><span id='topic+sim.bd.tr.phy'></span><span id='topic+edge2phylo'></span>

<h3>Description</h3>

<p>Simulate phylogenies under pure birth/death or as a function of
trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bd.phy(speciate = 0.1, extinction = 0.025, time.steps = 20)

sim.bd.tr.phy(
  speciate = 0.1,
  extinction = 0.025,
  time.steps = 20,
  tr.range = c(0, 1),
  sp.tr = 2,
  ext.tr = 1,
  tr.walk = 0.2,
  tr.wrap = TRUE
)

edge2phylo(edge, s, e = numeric(0), el = NA, t = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.phy_+3A_speciate">speciate</code></td>
<td>
<p>probability each species will speciate in each
time-step (0-1)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_extinction">extinction</code></td>
<td>
<p>probability each species will go extinct in each
time-step (0-1)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_time.steps">time.steps</code></td>
<td>
<p>number of time-steps for simulation</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_tr.range">tr.range</code></td>
<td>
<p>vector of length two specifying boundaries for
trait values (see notes); initial two species will be at the 25th
and 75th percentiles of this space. See also <code>tr.wrap</code></p>
</td></tr>
<tr><td><code id="sim.phy_+3A_sp.tr">sp.tr</code></td>
<td>
<p>speciation rate's interaction with the minimum
distance between a species and the species most similar to it (see
details)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_ext.tr">ext.tr</code></td>
<td>
<p>extinction rate's interaction with the minimum
distance between a species and the species most similar to it (see
details)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_tr.walk">tr.walk</code></td>
<td>
<p>at each time-step a species not undergoing
speciation or extinction has its trait value drawn from a
distribution centered at its current value and with a standard
deviation set by this value. I.e., this is the rate of the Brownian
motion trait evolution.</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_tr.wrap">tr.wrap</code></td>
<td>
<p>whether to force species' trait values to stay
within the boundary defined by <code>tr.range</code>; default TRUE.</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_edge">edge</code></td>
<td>
<p>a two-column matrix where the first column is the start
node, the second the destination, as in
<code><a href="ape.html#topic+phylo">phylo</a>$edge</code></p>
</td></tr>
<tr><td><code id="sim.phy_+3A_s">s</code></td>
<td>
<p>which of the rows in the edge matrix represent
extant species</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_e">e</code></td>
<td>
<p>which of the tips in the edge matrix are extinct
(DEFAULT: empty vector, i.e., none)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_el">el</code></td>
<td>
<p>a vector to be used to give edge.length to the
phylogeny (default NA, i.e., none)</p>
</td></tr>
<tr><td><code id="sim.phy_+3A_t">t</code></td>
<td>
<p>if given (default NA), a vector to be used for traits
(<code>$traits</code> slot) in the phylogeny</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim.bd.tree</code> simulates a pure birth/death speciation
model. There are two important things to note: (1) speciation is
randomised before extinction, and only one thing can happen to a
lineage per timestep. (2) This code works well for my purposes, but
absurd parameter values can cause the function to crash.
</p>
<p><code>sim.bd.tr.tree</code> is an extension of <code>sim.bd.tree</code>, and
all its caveats apply to it. It additionally simulated the
evolution of a trait under Brownain motion
(<code>tr.walk</code>). Species' speciation/extinction rates change
depending on whether they have a trait value similar to other
species (<code>sp.tr</code>, <code>ext.tr</code>). When a speciation event
happens, the two daughters split evenly about the ancestor's trait
value, taking values half-way to whatever the nearest species'
value is. To be precise: <code class="reqn">p(speciate)_i = speciate_i + sp.tr
\times min(trait distance)</code>, <code class="reqn">p(extinct)_i = exinction_i + ext.tr
\times min(trait distance)</code>, where <code class="reqn">i</code> denotes each species.
</p>
<p><code>edge2phylo</code> is an internal function for the
<code><a href="#topic+sim.phy">sim.phy</a></code> and <code><a href="#topic+sim.meta">sim.meta</a></code> function families,
which may be of use to you. Check those functions' code for
examples of use.
</p>
<p>These functions are closely related to <code><a href="#topic+sim.meta">sim.meta</a></code>; the
latter are extensions that simulate meta-community structure at the
same time.
</p>


<h3>Value</h3>

<p><code><a href="ape.html#topic+phylo">phylo</a></code> object with random
tip.labels, and trait values if using <code>sim.br.tr.tree</code>.
</p>


<h3>Author(s)</h3>

<p>Will Pearse
</p>
<p>Will Pearse
</p>
<p>Will Pearse
</p>


<h3>See Also</h3>

<p>sim.meta scape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- sim.bd.phy(0.1, 0, 10)
plot(tree)
</code></pre>

<hr>
<h2 id='trait.asm'>Produces simulated communities based on species attributes</h2><span id='topic+trait.asm'></span>

<h3>Description</h3>

<p><code>trait.asm</code> calculates phylogenetic biodiversity metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trait.asm(
  a,
  m = 1000,
  meanSR = NULL,
  interval = c(0.001, 10),
  exponential = TRUE,
  Pscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trait.asm_+3A_a">a</code></td>
<td>
<p>species attributes (e.g., traits like body size)</p>
</td></tr>
<tr><td><code id="trait.asm_+3A_m">m</code></td>
<td>
<p>number of communities to be simulated</p>
</td></tr>
<tr><td><code id="trait.asm_+3A_meansr">meanSR</code></td>
<td>
<p>target mean species richness across simulated communities</p>
</td></tr>
<tr><td><code id="trait.asm_+3A_interval">interval</code></td>
<td>
<p>adjust to obtain <code>meanSR</code></p>
</td></tr>
<tr><td><code id="trait.asm_+3A_exponential">exponential</code></td>
<td>
<p>use the exponential distribution when simulating communities</p>
</td></tr>
<tr><td><code id="trait.asm_+3A_pscale">Pscale</code></td>
<td>
<p>adjust this value when not using the exponential distribution in order to scale the species richnesses in the simulated communities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates a set of communties based on the supplied attribute (trait) where larger values make it more likely for species to be in the communities.
</p>


<h3>Value</h3>

<p><code>Y</code> presence/absence matrix
</p>
<p><code>P</code> probabilities
</p>
<p><code>a</code> the supplied trait
</p>
<p><code>exponential</code> if the exponential distribution was used
</p>
<p><code>meanSR</code> supplied <code>meanSR</code> value
</p>
<p><code>std</code> estimated sd
</p>


<h3>Author(s)</h3>

<p>M.R. Helmus
</p>


<h3>References</h3>

<p>Helmus M., Mercado-Silva N. &amp; Vander Zanden M.J. (2013). Subsidies to predators, apparent competition and the phylogenetic structure of prey communities. Oecologia, 173, 997-1007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(laja)
 trait.asm(laja$fish.pref)

## End(Not run)
</code></pre>

<hr>
<h2 id='traitgram.cc'>Traitgram for comparative community object</h2><span id='topic+traitgram.cc'></span><span id='topic+princompOne'></span>

<h3>Description</h3>

<p><code>traitgram.cc</code> A wrapper for the
<code><a href="picante.html#topic+traitgram">traitgram</a></code> function in the
<code>picante</code> package.
</p>
<p><code>princompOne</code> A very soft wrapper for <code><a href="stats.html#topic+princomp">princomp</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traitgram.cc(object, trait, moreArgs = NULL, ...)

princompOne(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traitgram.cc_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+comparative.comm">comparative.comm</a></code> object.</p>
</td></tr>
<tr><td><code id="traitgram.cc_+3A_trait">trait</code></td>
<td>
<p>Which trait to plot.  If <code><a href="base.html#topic+missing">missing</a></code>, use
the first trait.  If a positive <code><a href="base.html#topic+numeric">numeric</a></code> vector of
<code><a href="base.html#topic+length">length</a></code> one, use the <code>as.integer(trait)</code>th
trait.  If a <code><a href="base.html#topic+numeric">numeric</a></code> vector, use it instead of the
trait data in <code>object</code>.  If a <code><a href="base.html#topic+character">character</a></code> vector
of <code><a href="base.html#topic+length">length</a></code> one, use the trait with that name.  If a
<code><a href="base.html#topic+function">function</a></code> pass the trait data frame through that
function and use the result (<code><a href="#topic+princompOne">princompOne</a></code> is a
wrapper).  If an <code><a href="base.html#topic+expression">expression</a></code>, evaluate that
expression in the environment of the trait data and use the
result.  If a <code><a href="base.html#topic+character">character</a></code> vector, then convert to an
expression and evaluate in the environment of the trait data and
use the result.</p>
</td></tr>
<tr><td><code id="traitgram.cc_+3A_moreargs">moreArgs</code></td>
<td>
<p>List of more arguments to pass on to <code>trait</code>
(if its a <code><a href="base.html#topic+function">function</a></code>).</p>
</td></tr>
<tr><td><code id="traitgram.cc_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="picante.html#topic+traitgram">traitgram</a></code> or <code>prcomp</code> for
<code>traitgram.cc</code> and <code>princomOne</code> respectively.</p>
</td></tr>
<tr><td><code id="traitgram.cc_+3A_x">x</code></td>
<td>
<p>A matrix-like object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>traitgram.cc</code>: see
<code><a href="picante.html#topic+traitgram">traitgram</a></code>
</p>
<p><code>princompOne</code>: the first axis of a PCA
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
