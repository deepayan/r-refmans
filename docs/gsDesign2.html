<!DOCTYPE html><html><head><title>Help for package gsDesign2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gsDesign2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ahr'><p>Average hazard ratio under non-proportional hazards (test version)</p></a></li>
<li><a href='#as_gt'><p>Convert summary table of a fixed or group sequential design object to a gt object</p></a></li>
<li><a href='#as_rtf'><p>Write summary table of a fixed or group sequential design object to an RTF file</p></a></li>
<li><a href='#define_enroll_rate'><p>Define enrollment rate</p></a></li>
<li><a href='#define_fail_rate'><p>Define failure rate</p></a></li>
<li><a href='#event_diff'><p>Considering the enrollment rate, failure rate, and randomization ratio,</p>
calculate the difference between the targeted number of events and the
accumulated events at time <code>x</code></a></li>
<li><a href='#expected_accrual'><p>Piecewise constant expected accrual</p></a></li>
<li><a href='#expected_event'><p>Expected events observed under piecewise exponential model</p></a></li>
<li><a href='#expected_time'><p>Predict time at which a targeted event count is achieved</p></a></li>
<li><a href='#fastlag'><p>Find the &quot;previous&quot; values in a vector</p></a></li>
<li><a href='#fixed_design_ahr'><p>Fixed design using average hazard ratio under non-proportional hazards</p></a></li>
<li><a href='#fixed_design_fh'><p>Fixed design using Fleming-Harrington method</p></a></li>
<li><a href='#fixed_design_lf'><p>Fixed design using Lachin-Foulkes method</p></a></li>
<li><a href='#fixed_design_maxcombo'><p>Fixed design using MaxCombo method</p></a></li>
<li><a href='#fixed_design_mb'><p>Fixed design using Magirr-Burman method</p></a></li>
<li><a href='#fixed_design_milestone'><p>Fixed design using milestone method</p></a></li>
<li><a href='#fixed_design_rd'><p>Fixed design for binary outcome measuring in risk difference</p></a></li>
<li><a href='#fixed_design_rmst'><p>Fixed design using RMST method</p></a></li>
<li><a href='#get_combo_power'><p>Function to calculate power</p></a></li>
<li><a href='#gs_b'><p>Default boundary generation</p></a></li>
<li><a href='#gs_create_arm'><p>Create npsurvSS arm object</p></a></li>
<li><a href='#gs_design_ahr'><p>Group sequential design using average hazard ratio under non-proportional hazards</p></a></li>
<li><a href='#gs_design_combo'><p>Group sequential design using MaxCombo test under non-proportional hazards</p></a></li>
<li><a href='#gs_design_npe'><p>Group sequential design computation with non-constant effect and information</p></a></li>
<li><a href='#gs_design_rd'><p>Group sequential design of binary outcome measuring in risk difference</p></a></li>
<li><a href='#gs_design_wlr'><p>Group sequential design using weighted log-rank test under non-proportional hazards</p></a></li>
<li><a href='#gs_info_ahr'><p>Information and effect size based on AHR approximation</p></a></li>
<li><a href='#gs_info_combo'><p>Information and effect size for MaxCombo test</p></a></li>
<li><a href='#gs_info_rd'><p>Information and effect size under risk difference</p></a></li>
<li><a href='#gs_info_wlr'><p>Information and effect size for weighted log-rank test</p></a></li>
<li><a href='#gs_power_ahr'><p>Group sequential design power using average hazard ratio under</p>
non-proportional hazards</a></li>
<li><a href='#gs_power_combo'><p>Group sequential design power using MaxCombo test under non-proportional hazards</p></a></li>
<li><a href='#gs_power_npe'><p>Group sequential bound computation with non-constant effect</p></a></li>
<li><a href='#gs_power_rd'><p>Group sequential design power of binary outcome measuring in risk difference</p></a></li>
<li><a href='#gs_power_wlr'><p>Group sequential design power using weighted log rank test under non-proportional hazards</p></a></li>
<li><a href='#gs_spending_bound'><p>Derive spending bound for group sequential boundary</p></a></li>
<li><a href='#gs_spending_combo'><p>Derive spending bound for MaxCombo group sequential boundary</p></a></li>
<li><a href='#gsDesign2-package'><p>gsDesign2: Group Sequential Design with Non-Constant Effect</p></a></li>
<li><a href='#ppwe'><p>Piecewise exponential cumulative distribution function</p></a></li>
<li><a href='#pw_info'><p>Average hazard ratio under non-proportional hazards (test version)</p></a></li>
<li><a href='#s2pwe'><p>Approximate survival distribution with piecewise exponential distribution</p></a></li>
<li><a href='#summary.fixed_design'><p>Summary for fixed design or group sequential design objects</p></a></li>
<li><a href='#to_integer'><p>Rounds sample size to an even number for equal design</p></a></li>
<li><a href='#wlr_weight'><p>Weight functions for weighted log-rank test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Group Sequential Design with Non-Constant Effect</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of 'gsDesign2' is to enable fixed or group sequential
    design under non-proportional hazards. To enable highly flexible enrollment,
    time-to-event and time-to-dropout assumptions, 'gsDesign2' offers piecewise
    constant enrollment, failure rates, and dropout rates for a stratified
    population. This package includes three methods for designs:
    average hazard ratio, weighted logrank tests in Yung and Liu (2019)
    &lt;<a href="https://doi.org/10.1111%2Fbiom.13196">doi:10.1111/biom.13196</a>&gt;, and MaxCombo tests.
    Substantial flexibility on top of what is in the 'gsDesign' package
    is intended for selecting boundaries.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://merck.github.io/gsDesign2/">https://merck.github.io/gsDesign2/</a>,
<a href="https://github.com/Merck/gsDesign2">https://github.com/Merck/gsDesign2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Merck/gsDesign2/issues">https://github.com/Merck/gsDesign2/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, data.table, dplyr, gsDesign, gt, methods, mvtnorm,
npsurvSS, r2rtf, stats, tibble, tidyr, utils, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, kableExtra, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 15:58:38 UTC; xiaonan4</td>
</tr>
<tr>
<td>Author:</td>
<td>Keaven Anderson [aut],
  Yilong Zhang [aut],
  Yujie Zhao [aut, cre],
  Jianxiao Yang [aut],
  Nan Xiao [aut],
  Amin Shirazi [ctb],
  Ruixue Wang [ctb],
  Yi Cui [ctb],
  Ping Yang [ctb],
  Xin Tong Li [ctb],
  Chenxiang Li [ctb],
  Hiroaki Fukuda [ctb],
  Hongtao Zhang [ctb],
  Yalin Zhu [ctb],
  John Blischak [ctb],
  Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yujie Zhao &lt;yujie.zhao@merck.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 16:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ahr'>Average hazard ratio under non-proportional hazards (test version)</h2><span id='topic+ahr'></span>

<h3>Description</h3>

<p>Provides a geometric average hazard ratio under
various non-proportional hazards assumptions for either single or multiple strata studies.
The piecewise exponential distribution allows a simple method to specify a distribution
and enrollment pattern where the enrollment, failure and dropout rates changes over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  total_duration = 30,
  ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="ahr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="ahr_+3A_total_duration">total_duration</code></td>
<td>
<p>Total follow-up from start of enrollment to data
cutoff; this can be a single value or a vector of positive numbers.</p>
</td></tr>
<tr><td><code id="ahr_+3A_ratio">ratio</code></td>
<td>
<p>Ratio of experimental to control randomization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>time</code> (from <code>total_duration</code>),
<code>ahr</code> (average hazard ratio), <code>event</code> (expected number of events),
<code>info</code> (information under given scenarios), <code>and</code> info0
(information under related null hypothesis) for each value of
<code>total_duration</code> input.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: default
ahr()

# Example: default with multiple analysis times (varying total_duration)
ahr(total_duration = c(15, 30))

# Stratified population
enroll_rate &lt;- define_enroll_rate(
  stratum = c(rep("Low", 2), rep("High", 3)),
  duration = c(2, 10, 4, 4, 8),
  rate = c(5, 10, 0, 3, 6)
)
fail_rate &lt;- define_fail_rate(
  stratum = c(rep("Low", 2), rep("High", 2)),
  duration = 1,
  fail_rate = c(.1, .2, .3, .4),
  dropout_rate = .001,
  hr = c(.9, .75, .8, .6)
)
ahr(enroll_rate = enroll_rate, fail_rate = fail_rate, total_duration = c(15, 30))
</code></pre>

<hr>
<h2 id='as_gt'>Convert summary table of a fixed or group sequential design object to a gt object</h2><span id='topic+as_gt'></span><span id='topic+as_gt.fixed_design'></span><span id='topic+as_gt.gs_design'></span>

<h3>Description</h3>

<p>Convert summary table of a fixed or group sequential design object to a gt object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_gt(x, ...)

## S3 method for class 'fixed_design'
as_gt(x, title = NULL, footnote = NULL, ...)

## S3 method for class 'gs_design'
as_gt(
  x,
  title = NULL,
  subtitle = NULL,
  colname_spanner = "Cumulative boundary crossing probability",
  colname_spannersub = c("Alternate hypothesis", "Null hypothesis"),
  footnote = NULL,
  display_bound = c("Efficacy", "Futility"),
  display_columns = NULL,
  display_inf_bound = TRUE,
  full_alpha = 0.025,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_gt_+3A_x">x</code></td>
<td>
<p>A summary object of a fixed or group sequential design.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="as_gt_+3A_title">title</code></td>
<td>
<p>A string to specify the title of the gt table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_footnote">footnote</code></td>
<td>
<p>A list containing <code>content</code>, <code>location</code>, and <code>attr</code>.
<code>content</code> is a vector of string to specify the footnote text;
<code>location</code> is a vector of string to specify the locations to put the
superscript of the footnote index;
<code>attr</code> is a vector of string to specify the attributes of the footnotes,
for example, <code>c("colname", "title", "subtitle", "analysis", "spanner")</code>;
users can use the functions in the <code>gt</code> package to customize the table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_subtitle">subtitle</code></td>
<td>
<p>A string to specify the subtitle of the gt table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_colname_spanner">colname_spanner</code></td>
<td>
<p>A string to specify the spanner of the gt table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_colname_spannersub">colname_spannersub</code></td>
<td>
<p>A vector of strings to specify the spanner details of the gt table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_display_bound">display_bound</code></td>
<td>
<p>A vector of strings specifying the label of the bounds.
The default is <code>c("Efficacy", "Futility")</code>.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_display_columns">display_columns</code></td>
<td>
<p>A vector of strings specifying the variables to be
displayed in the summary table.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_display_inf_bound">display_inf_bound</code></td>
<td>
<p>Logical, whether to display the +/-inf bound.</p>
</td></tr>
<tr><td><code id="as_gt_+3A_full_alpha">full_alpha</code></td>
<td>
<p>The full alpha used in the design, the default is 0.025.
when the futility bound is non-binding, a footnote will be displayed, saying
the smaller value subtracts the probability of crossing a futility bound before
crossing an efficacy bound at a later analysis under the null hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gt_tbl</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)

# Enrollment rate
enroll_rate &lt;- define_enroll_rate(
  duration = 18,
  rate = 20
)

# Failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 12,
  dropout_rate = .001,
  hr = c(1, .6)
)

# Study duration in months
study_duration &lt;- 36

# Experimental / Control randomization ratio
ratio &lt;- 1

# 1-sided Type I error
alpha &lt;- 0.025

# Type II error (1 - power)
beta &lt;- 0.1

# AHR ----
# under fixed power
fixed_design_ahr(
  alpha = alpha, power = 1 - beta,
  enroll_rate = enroll_rate, fail_rate = fail_rate,
  study_duration = study_duration, ratio = ratio
) %&gt;%
  summary() %&gt;%
  as_gt()

# FH ----
# under fixed power
fixed_design_fh(
  alpha = alpha, power = 1 - beta,
  enroll_rate = enroll_rate, fail_rate = fail_rate,
  study_duration = study_duration, ratio = ratio
) %&gt;%
  summary() %&gt;%
  as_gt()

# the default output
library(dplyr)

gs_design_ahr() %&gt;%
  summary() %&gt;%
  as_gt()

gs_power_ahr() %&gt;%
  summary() %&gt;%
  as_gt()

gs_design_wlr() %&gt;%
  summary() %&gt;%
  as_gt()

gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt()


gs_power_combo() %&gt;%
  summary() %&gt;%
  as_gt()

gs_design_rd() %&gt;%
  summary() %&gt;%
  as_gt()

gs_power_rd() %&gt;%
  summary() %&gt;%
  as_gt()

# usage of title = ..., subtitle = ...
# to edit the title/subtitle
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt(
    title = "Bound Summary",
    subtitle = "from gs_power_wlr"
  )

# usage of colname_spanner = ..., colname_spannersub = ...
# to edit the spanner and its sub-spanner
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt(
    colname_spanner = "Cumulative probability to cross boundaries",
    colname_spannersub = c("under H1", "under H0")
  )

# usage of footnote = ...
# to edit the footnote
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt(
    footnote = list(
      content = c(
        "approximate weighted hazard ratio to cross bound.",
        "wAHR is the weighted AHR.",
        "the crossing probability.",
        "this table is generated by gs_power_wlr."
      ),
      location = c("~wHR at bound", NA, NA, NA),
      attr = c("colname", "analysis", "spanner", "title")
    )
  )

# usage of display_bound = ...
# to either show efficacy bound or futility bound, or both(default)
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt(display_bound = "Efficacy")

# usage of display_columns = ...
# to select the columns to display in the summary table
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_gt(display_columns = c("Analysis", "Bound", "Nominal p", "Z", "Probability"))

</code></pre>

<hr>
<h2 id='as_rtf'>Write summary table of a fixed or group sequential design object to an RTF file</h2><span id='topic+as_rtf'></span><span id='topic+as_rtf.fixed_design'></span><span id='topic+as_rtf.gs_design'></span>

<h3>Description</h3>

<p>Write summary table of a fixed or group sequential design object to an RTF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rtf(x, ...)

## S3 method for class 'fixed_design'
as_rtf(
  x,
  title = NULL,
  footnote = NULL,
  col_rel_width = NULL,
  orientation = c("portrait", "landscape"),
  text_font_size = 9,
  file,
  ...
)

## S3 method for class 'gs_design'
as_rtf(
  x,
  title = NULL,
  subtitle = NULL,
  colname_spanner = "Cumulative boundary crossing probability",
  colname_spannersub = c("Alternate hypothesis", "Null hypothesis"),
  footnote = NULL,
  display_bound = c("Efficacy", "Futility"),
  display_columns = NULL,
  display_inf_bound = TRUE,
  full_alpha = 0.025,
  col_rel_width = NULL,
  orientation = c("portrait", "landscape"),
  text_font_size = 9,
  file,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rtf_+3A_x">x</code></td>
<td>
<p>A summary object of a fixed or group sequential design.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_title">title</code></td>
<td>
<p>A string to specify the title of the RTF table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_footnote">footnote</code></td>
<td>
<p>A list containing <code>content</code>, <code>location</code>, and <code>attr</code>.
<code>content</code> is a vector of string to specify the footnote text;
<code>location</code> is a vector of string to specify the locations to put the
superscript of the footnote index;
<code>attr</code> is a vector of string to specify the attributes of the footnotes,
for example, <code>c("colname", "title", "subtitle", "analysis", "spanner")</code>;
users can use the functions in the <code>gt</code> package to customize the table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_col_rel_width">col_rel_width</code></td>
<td>
<p>Column relative width in a vector e.g. c(2,1,1) refers to 2:1:1.
Default is NULL for equal column width.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_orientation">orientation</code></td>
<td>
<p>Orientation in 'portrait' or 'landscape'.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_text_font_size">text_font_size</code></td>
<td>
<p>Text font size.  To vary text font size by column, use
numeric vector with length of vector equal to number of columns
displayed e.g. c(9,20,40).</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_file">file</code></td>
<td>
<p>File path for the output.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_subtitle">subtitle</code></td>
<td>
<p>A string to specify the subtitle of the RTF table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_colname_spanner">colname_spanner</code></td>
<td>
<p>A string to specify the spanner of the RTF table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_colname_spannersub">colname_spannersub</code></td>
<td>
<p>A vector of strings to specify the spanner details of the RTF table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_display_bound">display_bound</code></td>
<td>
<p>A vector of strings specifying the label of the bounds.
The default is <code>c("Efficacy", "Futility")</code>.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_display_columns">display_columns</code></td>
<td>
<p>A vector of strings specifying the variables to be
displayed in the summary table.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_display_inf_bound">display_inf_bound</code></td>
<td>
<p>Logical, whether to display the +/-inf bound.</p>
</td></tr>
<tr><td><code id="as_rtf_+3A_full_alpha">full_alpha</code></td>
<td>
<p>The full alpha used in the design, the default is 0.025.
when the futility bound is non-binding, a footnote will be displayed, saying
the smaller value subtracts the probability of crossing a futility bound before
crossing an efficacy bound at a later analysis under the null hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as_rtf()</code> returns the input <code>x</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Enrollment rate
enroll_rate &lt;- define_enroll_rate(
  duration = 18,
  rate = 20
)

# Failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 12,
  dropout_rate = .001,
  hr = c(1, .6)
)

# Study duration in months
study_duration &lt;- 36

# Experimental / Control randomization ratio
ratio &lt;- 1

# 1-sided Type I error
alpha &lt;- 0.025

# Type II error (1 - power)
beta &lt;- 0.1

# AHR ----
# under fixed power
x &lt;- fixed_design_ahr(
  alpha = alpha, power = 1 - beta,
  enroll_rate = enroll_rate, fail_rate = fail_rate,
  study_duration = study_duration, ratio = ratio
) %&gt;% summary()
x %&gt;% as_rtf(file = tempfile(fileext = ".rtf"))
x %&gt;% as_rtf(title = "Fixed design", file = tempfile(fileext = ".rtf"))
x %&gt;% as_rtf(
  footnote = "Power computed with average hazard ratio method given the sample size",
  file = tempfile(fileext = ".rtf")
)
x %&gt;% as_rtf(text_font_size = 10, file = tempfile(fileext = ".rtf"))

# FH ----
# under fixed power
fixed_design_fh(
  alpha = alpha, power = 1 - beta,
  enroll_rate = enroll_rate, fail_rate = fail_rate,
  study_duration = study_duration, ratio = ratio
) %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))
#'

# the default output
library(dplyr)

gs_design_ahr() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

gs_power_ahr() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

gs_design_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))


gs_power_combo() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

gs_design_rd() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

gs_power_rd() %&gt;%
  summary() %&gt;%
  as_rtf(file = tempfile(fileext = ".rtf"))

# usage of title = ..., subtitle = ...
# to edit the title/subtitle
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(
    title = "Bound Summary",
    subtitle = "from gs_power_wlr",
    file = tempfile(fileext = ".rtf")
  )

# usage of colname_spanner = ..., colname_spannersub = ...
# to edit the spanner and its sub-spanner
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(
    colname_spanner = "Cumulative probability to cross boundaries",
    colname_spannersub = c("under H1", "under H0"),
    file = tempfile(fileext = ".rtf")
  )

# usage of footnote = ...
# to edit the footnote
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(
    footnote = list(
      content = c(
        "approximate weighted hazard ratio to cross bound.",
        "wAHR is the weighted AHR.",
        "the crossing probability.",
        "this table is generated by gs_power_wlr."
      ),
      location = c("~wHR at bound", NA, NA, NA),
      attr = c("colname", "analysis", "spanner", "title")
    ),
    file = tempfile(fileext = ".rtf")
  )

# usage of display_bound = ...
# to either show efficacy bound or futility bound, or both(default)
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(
    display_bound = "Efficacy",
    file = tempfile(fileext = ".rtf")
  )

# usage of display_columns = ...
# to select the columns to display in the summary table
gs_power_wlr() %&gt;%
  summary() %&gt;%
  as_rtf(
    display_columns = c("Analysis", "Bound", "Nominal p", "Z", "Probability"),
    file = tempfile(fileext = ".rtf")
  )

</code></pre>

<hr>
<h2 id='define_enroll_rate'>Define enrollment rate</h2><span id='topic+define_enroll_rate'></span>

<h3>Description</h3>

<p>Define the enrollment rate of subjects for a study as following a piecewise
exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_enroll_rate(duration, rate, stratum = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_enroll_rate_+3A_duration">duration</code></td>
<td>
<p>A numeric vector of ordered piecewise study duration interval.</p>
</td></tr>
<tr><td><code id="define_enroll_rate_+3A_rate">rate</code></td>
<td>
<p>A numeric vector of enrollment rate in each <code>duration</code>.</p>
</td></tr>
<tr><td><code id="define_enroll_rate_+3A_stratum">stratum</code></td>
<td>
<p>A character vector of stratum name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>duration</code> are ordered piecewise for a duration equal to
<code class="reqn">t_i - t_{i-1}</code>, where <code class="reqn">0 = t_0 &lt; t_i &lt; \cdots &lt; t_M = \infty</code>.
The enrollment rates are defined in each duration with the same length.
</p>
<p>For a study with multiple strata, different duration and rates can be
specified in each stratum.
</p>


<h3>Value</h3>

<p>An <code>enroll_rate</code> data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define enroll rate without stratum
define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

# Define enroll rate with stratum
define_enroll_rate(
  duration = rep(c(2, 2, 2, 18), 3),
  rate = c((1:4) / 3, (1:4) / 2, (1:4) / 6),
  stratum = c(array("High", 4), array("Moderate", 4), array("Low", 4))
)
</code></pre>

<hr>
<h2 id='define_fail_rate'>Define failure rate</h2><span id='topic+define_fail_rate'></span>

<h3>Description</h3>

<p>Define subject failure rate for a study with two treatment groups.
Also supports stratified designs that have different failure rates in
each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_fail_rate(duration, fail_rate, dropout_rate, hr = 1, stratum = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_fail_rate_+3A_duration">duration</code></td>
<td>
<p>A numeric vector of ordered piecewise study duration interval.</p>
</td></tr>
<tr><td><code id="define_fail_rate_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A numeric vector of failure rate in each <code>duration</code> in the control group.</p>
</td></tr>
<tr><td><code id="define_fail_rate_+3A_dropout_rate">dropout_rate</code></td>
<td>
<p>A numeric vector of dropout rate in each <code>duration</code>.</p>
</td></tr>
<tr><td><code id="define_fail_rate_+3A_hr">hr</code></td>
<td>
<p>A numeric vector of hazard ratio between treatment and control group.</p>
</td></tr>
<tr><td><code id="define_fail_rate_+3A_stratum">stratum</code></td>
<td>
<p>A character vector of stratum name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define the failure and dropout rate of subjects for a study as following
a piecewise exponential distribution.
The <code>duration</code> are ordered piecewise for a duration equal to
<code class="reqn">t_i - t_{i-1}</code>, where <code class="reqn">0 = t_0 &lt; t_i &lt; \cdots &lt; t_M = \infty</code>.
The failure rate, dropout rate, and hazard ratio in a study duration
can be specified.
</p>
<p>For a study with multiple strata, different duration, failure rates,
dropout rates, and hazard ratios can be specified in each stratum.
</p>


<h3>Value</h3>

<p>A <code>fail_rate</code> data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define enroll rate
define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

# Define enroll rate with stratum
define_fail_rate(
  stratum = c(rep("Low", 2), rep("High", 2)),
  duration = 1,
  fail_rate = c(.1, .2, .3, .4),
  dropout_rate = .001,
  hr = c(.9, .75, .8, .6)
)
</code></pre>

<hr>
<h2 id='event_diff'>Considering the enrollment rate, failure rate, and randomization ratio,
calculate the difference between the targeted number of events and the
accumulated events at time <code>x</code></h2><span id='topic+event_diff'></span>

<h3>Description</h3>

<p>A helper function passed to <code>uniroot()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_diff(x, enroll_rate, fail_rate, ratio, target_event)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_diff_+3A_x">x</code></td>
<td>
<p>Duration</p>
</td></tr>
<tr><td><code id="event_diff_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="event_diff_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="event_diff_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="event_diff_+3A_target_event">target_event</code></td>
<td>
<p>The targeted number of events to be achieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value that represents the difference between the
expected number of events for the provided duration (<code>x</code>) and the targeted
number of events (<code>target_event</code>)
</p>

<hr>
<h2 id='expected_accrual'>Piecewise constant expected accrual</h2><span id='topic+expected_accrual'></span>

<h3>Description</h3>

<p>Computes the expected cumulative enrollment (accrual)
given a set of piecewise constant enrollment rates and times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_accrual(
  time = 0:24,
  enroll_rate = define_enroll_rate(duration = c(3, 3, 18), rate = c(5, 10, 20))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_accrual_+3A_time">time</code></td>
<td>
<p>Times at which enrollment is to be computed.</p>
</td></tr>
<tr><td><code id="expected_accrual_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with expected cumulative enrollment for the specified <code>times</code>.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# Example 1: default
expected_accrual()

# Example 2: unstratified design
expected_accrual(
  time = c(5, 10, 20),
  enroll_rate = define_enroll_rate(
    duration = c(3, 3, 18),
    rate = c(5, 10, 20)
  )
)

expected_accrual(
  time = c(5, 10, 20),
  enroll_rate = define_enroll_rate(
    duration = c(3, 3, 18),
    rate = c(5, 10, 20),
  )
)

# Example 3: stratified design
expected_accrual(
  time = c(24, 30, 40),
  enroll_rate = define_enroll_rate(
    stratum = c("subgroup", "complement"),
    duration = c(33, 33),
    rate = c(30, 30)
  )
)
</code></pre>

<hr>
<h2 id='expected_event'>Expected events observed under piecewise exponential model</h2><span id='topic+expected_event'></span>

<h3>Description</h3>

<p>Computes expected events over time and by strata
under the assumption of piecewise constant enrollment rates and piecewise
exponential failure and censoring rates.
The piecewise exponential distribution allows a simple method to specify a distribution
and enrollment pattern
where the enrollment, failure and dropout rates changes over time.
While the main purpose may be to generate a trial that can be analyzed at a single point in time or
using group sequential methods, the routine can also be used to simulate an adaptive trial design.
The intent is to enable sample size calculations under non-proportional hazards assumptions
for stratified populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_event(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18),
    dropout_rate = 0.001),
  total_duration = 25,
  simple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_event_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="expected_event_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="expected_event_+3A_total_duration">total_duration</code></td>
<td>
<p>Total follow-up from start of enrollment to data cutoff.</p>
</td></tr>
<tr><td><code id="expected_event_+3A_simple">simple</code></td>
<td>
<p>If default (<code>TRUE</code>), return numeric expected number of events,
otherwise a data frame as described below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More periods will generally be supplied in output than those that are input.
The intent is to enable expected event calculations in a tidy format to
maximize flexibility for a variety of purposes.
</p>


<h3>Value</h3>

<p>The default when <code>simple = TRUE</code> is to return the total expected
number of events as a real number.
Otherwise, when <code>simple = FALSE</code>, a data frame is returned with
the following variables for each period specified in <code>fail_rate</code>:
</p>

<ul>
<li> <p><code>t</code>: start of period.
</p>
</li>
<li> <p><code>fail_rate</code>: failure rate during the period.
</p>
</li>
<li> <p><code>event</code>: expected events during the period.
</p>
</li></ul>

<p>The records in the returned data frame correspond to the input data frame <code>fail_rate</code>.
</p>


<h3>Specification</h3>




<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign2)

# Default arguments, simple output (total event count only)
expected_event()

# Event count by time period
expected_event(simple = FALSE)

# Early cutoff
expected_event(total_duration = .5)

# Single time period example
expected_event(
  enroll_rate = define_enroll_rate(duration = 10, rate = 10),
  fail_rate = define_fail_rate(duration = 100, fail_rate = log(2) / 6, dropout_rate = .01),
  total_duration = 22,
  simple = FALSE
)

# Single time period example, multiple enrollment periods
expected_event(
  enroll_rate = define_enroll_rate(duration = c(5, 5), rate = c(10, 20)),
  fail_rate = define_fail_rate(duration = 100, fail_rate = log(2) / 6, dropout_rate = .01),
  total_duration = 22, simple = FALSE
)
</code></pre>

<hr>
<h2 id='expected_time'>Predict time at which a targeted event count is achieved</h2><span id='topic+expected_time'></span>

<h3>Description</h3>

<p><code>expected_time()</code> is made to match input format with <code><a href="#topic+ahr">ahr()</a></code> and to solve for the
time at which the expected accumulated events is equal to an input target.
Enrollment and failure rate distributions are specified as follows.
The piecewise exponential distribution allows a simple method to specify a distribution
and enrollment pattern
where the enrollment, failure and dropout rates changes over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_time(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9) * 5),
  fail_rate = define_fail_rate(stratum = "All", duration = c(3, 100), fail_rate =
    log(2)/c(9, 18), hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),
  target_event = 150,
  ratio = 1,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_time_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="expected_time_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="expected_time_+3A_target_event">target_event</code></td>
<td>
<p>The targeted number of events to be achieved.</p>
</td></tr>
<tr><td><code id="expected_time_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="expected_time_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to <code>target_event</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>Time</code> (computed to match events in <code>target_event</code>),
<code>AHR</code> (average hazard ratio), <code>Events</code> (<code>target_event</code> input),
<code>info</code> (information under given scenarios), and <code>info0</code>
(information under related null hypothesis) for each value of
<code>total_duration</code> input.
</p>


<h3>Specification</h3>




<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----
# default

expected_time()


# Example 2 ----
# check that result matches a finding using AHR()
# Start by deriving an expected event count
enroll_rate &lt;- define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9) * 5)
fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)
total_duration &lt;- 20
xx &lt;- ahr(enroll_rate, fail_rate, total_duration)
xx

# Next we check that the function confirms the timing of the final analysis.

expected_time(enroll_rate, fail_rate,
  target_event = xx$event, interval = c(.5, 1.5) * xx$time
)

</code></pre>

<hr>
<h2 id='fastlag'>Find the &quot;previous&quot; values in a vector</h2><span id='topic+fastlag'></span>

<h3>Description</h3>

<p>Fast replacement of <code>dplyr::lag</code> for the simple case of <code>n = 1L</code>
and always supplying a new value to insert at the beginning of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastlag(x, first)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastlag_+3A_x">x</code></td>
<td>
<p>A vector (<code>length(x) &gt; 0</code>)</p>
</td></tr>
<tr><td><code id="fastlag_+3A_first">first</code></td>
<td>
<p>A single value (<code>length(first) == 1</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Important: this function is fast because it provides minimal safety checks.
It relies on the
<a href="https://adv-r.hadley.nz/vectors-chap.html#testing-and-coercion">coercion
rules</a> of <code><a href="base.html#topic+c">c</a></code>. For best results, <code>x</code> and <code>first</code>
should be the same type of atomic vector, though it should be fine to mix
<code>numeric</code> and <code>integer</code> vectors as long as your own code also
doesn't rely on this distinction. It can also work on lists if needed.
</p>


<h3>Value</h3>

<p>a vector that begins with <code>first</code> and is followed by <code>x</code>
with its final value removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gsDesign2:::fastlag(1:5, first = 100) == c(100, 1:4)

</code></pre>

<hr>
<h2 id='fixed_design_ahr'>Fixed design using average hazard ratio under non-proportional hazards</h2><span id='topic+fixed_design_ahr'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for AHR method.
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_ahr(
  enroll_rate,
  fail_rate,
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  event = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_ahr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_ahr_+3A_event">event</code></td>
<td>
<p>Targeted event at each analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_ahr(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_ahr(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_fh'>Fixed design using Fleming-Harrington method</h2><span id='topic+fixed_design_fh'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for Fleming-Harrington method (Farrington and Manning, 1990).
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_fh(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  enroll_rate,
  fail_rate,
  rho = 0,
  gamma = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_fh_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_rho">rho</code></td>
<td>
<p>test parameter in Fleming-Harrington method.</p>
</td></tr>
<tr><td><code id="fixed_design_fh_+3A_gamma">gamma</code></td>
<td>
<p>test parameter in Fleming-Harrington method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_fh(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  rho = 1, gamma = 1
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_fh(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  rho = 1, gamma = 1
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_lf'>Fixed design using Lachin-Foulkes method</h2><span id='topic+fixed_design_lf'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for Lachin-Foulkes method (Lachin and Foulkes, 1986).
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_lf(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  enroll_rate,
  fail_rate
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_lf_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error (strictly between 0 and 1).</p>
</td></tr>
<tr><td><code id="fixed_design_lf_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_lf_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_lf_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_lf_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_lf_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_lf(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_fh(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_maxcombo'>Fixed design using MaxCombo method</h2><span id='topic+fixed_design_maxcombo'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for MaxCombo method.
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_maxcombo(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  enroll_rate,
  fail_rate,
  rho = c(0, 0, 1),
  gamma = c(0, 1, 0),
  tau = rep(-1, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_maxcombo_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error (strictly between 0 and 1).</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_rho">rho</code></td>
<td>
<p>A vector of numbers paring with gamma and tau for maxcombo test.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_gamma">gamma</code></td>
<td>
<p>A vector of numbers paring with rho and tau for maxcombo test.</p>
</td></tr>
<tr><td><code id="fixed_design_maxcombo_+3A_tau">tau</code></td>
<td>
<p>A vector of numbers paring with gamma and rho for maxcombo test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_maxcombo(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  rho = c(0, 0.5), gamma = c(0, 0), tau = c(-1, -1)
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_maxcombo(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  rho = c(0, 0.5), gamma = c(0, 0), tau = c(-1, -1)
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_mb'>Fixed design using Magirr-Burman method</h2><span id='topic+fixed_design_mb'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for Magirr-Burman method.
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_mb(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  enroll_rate,
  fail_rate,
  tau = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_mb_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_mb_+3A_tau">tau</code></td>
<td>
<p>Test parameter of Magirr-Burman method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_mb(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 4
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_mb(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 4
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_milestone'>Fixed design using milestone method</h2><span id='topic+fixed_design_milestone'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for milestone method (Yung and Liu, 2020).
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_milestone(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  enroll_rate,
  fail_rate,
  study_duration = 36,
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_milestone_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error (strictly between 0 and 1).</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_milestone_+3A_tau">tau</code></td>
<td>
<p>Test parameter of milestone method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_milestone(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 18
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_milestone(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 18
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_rd'>Fixed design for binary outcome measuring in risk difference</h2><span id='topic+fixed_design_rd'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for binary outcome measuring in risk difference (Mehrotra and Railkar, 2000).
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_rd(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  p_c,
  p_e,
  rd0 = 0,
  n = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_rd_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error (strictly between 0 and 1).</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_p_c">p_c</code></td>
<td>
<p>A numerical value of the control arm rate.</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_p_e">p_e</code></td>
<td>
<p>A numerical value of the experimental arm rate.</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_rd0">rd0</code></td>
<td>
<p>Risk difference under null hypothesis, default is 0.</p>
</td></tr>
<tr><td><code id="fixed_design_rd_+3A_n">n</code></td>
<td>
<p>Sample size. If NULL with power input, the sample size will be
computed to achieve the targeted power</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_rd(
  alpha = 0.025, power = 0.9, p_c = .15, p_e = .1,
  rd0 = 0, ratio = 1
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_rd(
  alpha = 0.025, power = NULL, p_c = .15, p_e = .1,
  rd0 = 0, n = 2000, ratio = 1
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='fixed_design_rmst'>Fixed design using RMST method</h2><span id='topic+fixed_design_rmst'></span>

<h3>Description</h3>

<p>Computes fixed design sample size (given power) or power (given sample size)
for RMST methods (Yung and Liu, 2020).
Returns a list with a basic summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_design_rmst(
  alpha = 0.025,
  power = NULL,
  ratio = 1,
  study_duration = 36,
  enroll_rate,
  fail_rate,
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_design_rmst_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error (strictly between 0 and 1).</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_power">power</code></td>
<td>
<p>Power (<code>NULL</code> to compute power or strictly between 0
and <code>1 - alpha</code> otherwise).</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_study_duration">study_duration</code></td>
<td>
<p>Study duration.</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="fixed_design_rmst_+3A_tau">tau</code></td>
<td>
<p>Test parameter in RMST.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Example 1: given power and compute sample size
x &lt;- fixed_design_rmst(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 18
)
x %&gt;% summary()

# Example 2: given sample size and compute power
x &lt;- fixed_design_rmst(
  alpha = .025,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = 100,
    fail_rate = log(2) / 12,
    hr = .7,
    dropout_rate = .001
  ),
  study_duration = 36,
  tau = 18
)
x %&gt;% summary()
</code></pre>

<hr>
<h2 id='get_combo_power'>Function to calculate power</h2><span id='topic+get_combo_power'></span>

<h3>Description</h3>

<p>A helper function passed to <code>uniroot()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_combo_power(n, bound, info_fh, theta_fh, corr_fh, algorithm, beta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_combo_power_+3A_n">n</code></td>
<td>
<p>Input sample size</p>
</td></tr>
<tr><td><code id="get_combo_power_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="mvtnorm.html#topic+GenzBretz">GenzBretz</a></code>,
<code><a href="mvtnorm.html#topic+Miwa">Miwa</a></code> or <code><a href="mvtnorm.html#topic+TVPACK">TVPACK</a></code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td></tr>
<tr><td><code id="get_combo_power_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="get_combo_power_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <a href="mvtnorm.html#topic+pmvnorm">mvtnorm::pmvnorm</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the difference between the derived power and the
targeted power (1 - beta), based on the provided sample size, upper and lower
boundaries, and treatment effect.
</p>


<h3>Value</h3>

<p>The optimal sample size (a single numeric value)
</p>

<hr>
<h2 id='gs_b'>Default boundary generation</h2><span id='topic+gs_b'></span>

<h3>Description</h3>

<p><code>gs_b()</code> is the simplest version of a function to be used with the
<code>upper</code> and <code>lower</code> arguments in <code>gs_prob()</code>,
<code>gs_power_nph()</code> and <code>gs_design_nph()</code>;
it simply returns the vector input in the input vector <code>Z</code> or,
if <code>k</code> is specified, <code style="white-space: pre;">&#8288;par[k]j&#8288;</code> is returned.
Note that if bounds need to change with changing information at analyses,
<code>gs_b()</code> should not be used.
For instance, for spending function bounds use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_b(par = NULL, k = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_b_+3A_par">par</code></td>
<td>
<p>For <code>gs_b()</code>, this is just Z-values for the boundaries;
can include infinite values.</p>
</td></tr>
<tr><td><code id="gs_b_+3A_k">k</code></td>
<td>
<p>Is <code>NULL</code> (default), return <code>par</code>, else return <code>par[k]</code>.</p>
</td></tr>
<tr><td><code id="gs_b_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the vector input <code>par</code> if <code>k</code> is <code>NULL</code>, otherwise, <code>par[k]</code>.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple: enter a vector of length 3 for bound
gs_b(par = 4:2)

# 2nd element of par
gs_b(par = 4:2, k = 2)

# Generate an efficacy bound using a spending function
# Use Lan-DeMets spending approximation of O'Brien-Fleming bound
# as 50%, 75% and 100% of final spending
# Information fraction
IF &lt;- c(.5, .75, 1)
gs_b(par = gsDesign::gsDesign(
  alpha = .025, k = length(IF),
  test.type = 1, sfu = gsDesign::sfLDOF,
  timing = IF
)$upper$bound)
</code></pre>

<hr>
<h2 id='gs_create_arm'>Create npsurvSS arm object</h2><span id='topic+gs_create_arm'></span>

<h3>Description</h3>

<p>Create npsurvSS arm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_create_arm(enroll_rate, fail_rate, ratio, total_time = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_create_arm_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_create_arm_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_create_arm_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="gs_create_arm_+3A_total_time">total_time</code></td>
<td>
<p>Total analysis time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the two arms.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enroll_rate &lt;- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

gs_create_arm(enroll_rate, fail_rate, ratio = 1)
</code></pre>

<hr>
<h2 id='gs_design_ahr'>Group sequential design using average hazard ratio under non-proportional hazards</h2><span id='topic+gs_design_ahr'></span>

<h3>Description</h3>

<p>Group sequential design using average hazard ratio under non-proportional hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_design_ahr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  alpha = 0.025,
  beta = 0.1,
  info_frac = NULL,
  analysis_time = 36,
  ratio = 1,
  binding = FALSE,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, test.type = 1, n.I = c(0.25, 0.75, 1), sfu = sfLDOF,
    sfupar = NULL)$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(0.1), -Inf, -Inf),
  h1_spending = TRUE,
  test_upper = TRUE,
  test_lower = TRUE,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  r = 18,
  tol = 1e-06,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_design_ahr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_info_frac">info_frac</code></td>
<td>
<p>Targeted information fraction at each analysis.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Minimum time of analysis.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_h1_spending">h1_spending</code></td>
<td>
<p>Indicator that lower bound to be set by spending
under alternate hypothesis (input <code>fail_rate</code>)
if spending is used for lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default) indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicated no lower bound; otherwise, a logical vector
of the same length as <code>info</code> should indicate which analyses will have a
lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
<tr><td><code id="gs_design_ahr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be added.
</p>


<h3>Value</h3>

<p>A list with input parameters, enrollment rate, analysis, and bound.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign)
library(gsDesign2)
library(dplyr)

# Example 1 ----
# call with defaults
gs_design_ahr()

# Example 2 ----
# Single analysis
gs_design_ahr(analysis_time = 40)

# Example 3 ----
# Multiple analysis_time
gs_design_ahr(analysis_time = c(12, 24, 36))

# Example 4 ----
# Specified information fraction

gs_design_ahr(info_frac = c(.25, .75, 1), analysis_time = 36)


# Example 5 ----
# multiple analysis times &amp; info_frac
# driven by times
gs_design_ahr(info_frac = c(.25, .75, 1), analysis_time = c(12, 25, 36))
# driven by info_frac

gs_design_ahr(info_frac = c(1 / 3, .8, 1), analysis_time = c(12, 25, 36))


# Example 6 ----
# 2-sided symmetric design with O'Brien-Fleming spending

gs_design_ahr(
  analysis_time = c(12, 24, 36),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  h1_spending = FALSE
)

# 2-sided asymmetric design with O'Brien-Fleming upper spending
# Pocock lower spending under H1 (NPH)

gs_design_ahr(
  analysis_time = c(12, 24, 36),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDPocock, total_spend = 0.1, param = NULL, timing = NULL),
  h1_spending = TRUE
)


# Example 7 ----

gs_design_ahr(
  alpha = 0.0125,
  analysis_time = c(12, 24, 36),
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.0125, param = NULL, timing = NULL),
  lower = gs_b,
  lpar = rep(-Inf, 3)
)

gs_design_ahr(
  alpha = 0.0125,
  analysis_time = c(12, 24, 36),
  upper = gs_b,
  upar = gsDesign::gsDesign(
    k = 3, test.type = 1, n.I = c(.25, .75, 1),
    sfu = sfLDOF, sfupar = NULL, alpha = 0.0125
  )$upper$bound,
  lower = gs_b,
  lpar = rep(-Inf, 3)
)

</code></pre>

<hr>
<h2 id='gs_design_combo'>Group sequential design using MaxCombo test under non-proportional hazards</h2><span id='topic+gs_design_combo'></span>

<h3>Description</h3>

<p>Group sequential design using MaxCombo test under non-proportional hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_design_combo(
  enroll_rate = define_enroll_rate(duration = 12, rate = 500/12),
  fail_rate = define_fail_rate(duration = c(4, 100), fail_rate = log(2)/15, hr = c(1,
    0.6), dropout_rate = 0.001),
  fh_test = rbind(data.frame(rho = 0, gamma = 0, tau = -1, test = 1, analysis = 1:3,
    analysis_time = c(12, 24, 36)), data.frame(rho = c(0, 0.5), gamma = 0.5, tau = -1,
    test = 2:3, analysis = 3, analysis_time = 36)),
  ratio = 1,
  alpha = 0.025,
  beta = 0.2,
  binding = FALSE,
  upper = gs_b,
  upar = c(3, 2, 1),
  lower = gs_b,
  lpar = c(-1, 0, 1),
  algorithm = mvtnorm::GenzBretz(maxpts = 1e+05, abseps = 1e-05),
  n_upper_bound = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_design_combo_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_fh_test">fh_test</code></td>
<td>
<p>A data frame to summarize the test in each analysis.
See examples for its data structure.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="mvtnorm.html#topic+GenzBretz">GenzBretz</a></code>,
<code><a href="mvtnorm.html#topic+Miwa">Miwa</a></code> or <code><a href="mvtnorm.html#topic+TVPACK">TVPACK</a></code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_n_upper_bound">n_upper_bound</code></td>
<td>
<p>A numeric value of upper limit of sample size.</p>
</td></tr>
<tr><td><code id="gs_design_combo_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <a href="mvtnorm.html#topic+pmvnorm">mvtnorm::pmvnorm</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with input parameters, enrollment rate, analysis, and bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The example is slow to run
library(dplyr)
library(mvtnorm)
library(gsDesign)

enroll_rate &lt;- define_enroll_rate(
  duration = 12,
  rate = 500 / 12
)

fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 15, # median survival 15 month
  hr = c(1, .6),
  dropout_rate = 0.001
)

fh_test &lt;- rbind(
  data.frame(
    rho = 0, gamma = 0, tau = -1,
    test = 1, analysis = 1:3, analysis_time = c(12, 24, 36)
  ),
  data.frame(
    rho = c(0, 0.5), gamma = 0.5, tau = -1,
    test = 2:3, analysis = 3, analysis_time = 36
  )
)

x &lt;- gsSurv(
  k = 3,
  test.type = 4,
  alpha = 0.025,
  beta = 0.2,
  astar = 0,
  timing = 1,
  sfu = sfLDOF,
  sfupar = 0,
  sfl = sfLDOF,
  sflpar = 0,
  lambdaC = 0.1,
  hr = 0.6,
  hr0 = 1,
  eta = 0.01,
  gamma = 10,
  R = 12,
  S = NULL,
  T = 36,
  minfup = 24,
  ratio = 1
)

# Example 1 ----
# User-defined boundary

gs_design_combo(
  enroll_rate,
  fail_rate,
  fh_test,
  alpha = 0.025, beta = 0.2,
  ratio = 1,
  binding = FALSE,
  upar = x$upper$bound,
  lpar = x$lower$bound
)

# Example 2 ----

# Boundary derived by spending function
gs_design_combo(
  enroll_rate,
  fail_rate,
  fh_test,
  alpha = 0.025,
  beta = 0.2,
  ratio = 1,
  binding = FALSE,
  upper = gs_spending_combo,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025), # alpha spending
  lower = gs_spending_combo,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2), # beta spending
)

</code></pre>

<hr>
<h2 id='gs_design_npe'>Group sequential design computation with non-constant effect and information</h2><span id='topic+gs_design_npe'></span>

<h3>Description</h3>

<p>Derives group sequential design size,
bounds and boundary crossing probabilities based on proportionate
information and effect size at analyses.
It allows a non-constant treatment effect over time,
but also can be applied for the usual homogeneous effect size designs.
It requires treatment effect and proportionate statistical information
at each analysis as well as a method of deriving bounds, such as spending.
The routine enables two things not available in the gsDesign package:
</p>

<ol>
<li><p> non-constant effect, 2) more flexibility in boundary selection.
For many applications, the non-proportional-hazards design function
<code>gs_design_nph()</code> will be used; it calls this function.
Initial bound types supported are 1) spending bounds,
</p>
</li>
<li><p> fixed bounds, and 3) Haybittle-Peto-like bounds.
The requirement is to have a boundary update method that
can each bound without knowledge of future bounds.
As an example, bounds based on conditional power that
require knowledge of all future bounds are not supported by this routine;
a more limited conditional power method will be demonstrated.
Boundary family designs Wang-Tsiatis designs including
the original (non-spending-function-based) O'Brien-Fleming and Pocock designs
are not supported by <code><a href="#topic+gs_power_npe">gs_power_npe()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gs_design_npe(
  theta = 0.1,
  theta0 = NULL,
  theta1 = NULL,
  info = 1,
  info0 = NULL,
  info1 = NULL,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  alpha = 0.025,
  beta = 0.1,
  upper = gs_b,
  upar = qnorm(0.975),
  lower = gs_b,
  lpar = -Inf,
  test_upper = TRUE,
  test_lower = TRUE,
  binding = FALSE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_design_npe_+3A_theta">theta</code></td>
<td>
<p>Natural parameter for group sequential design
representing expected incremental drift at all analyses;
used for power calculation.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_theta0">theta0</code></td>
<td>
<p>Natural parameter used for upper bound spending;
if <code>NULL</code>, this will be set to 0.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_theta1">theta1</code></td>
<td>
<p>Natural parameter used for lower bound spending;
if <code>NULL</code>, this will be set to <code>theta</code>
which yields the usual beta-spending.
If set to 0, spending is 2-sided under null hypothesis.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_info">info</code></td>
<td>
<p>Proportionate statistical information at
all analyses for input <code>theta</code>.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_info0">info0</code></td>
<td>
<p>Proportionate statistical information
under null hypothesis, if different than alternative;
impacts null hypothesis bound calculation.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_info1">info1</code></td>
<td>
<p>Proportionate statistical information
under alternate hypothesis;
impacts null hypothesis bound calculation.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to the function provided in <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_lower">lower</code></td>
<td>
<p>Function to compare lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to the function provided in <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include
an upper (efficacy) bound; single value of <code>TRUE</code> (default) indicates
all analyses; otherwise, a logical vector of the same length as <code>info</code>
should indicate which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicates no lower bound; otherwise,
a logical vector of the same length as <code>info</code> should indicate which
analyses will have a lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration
as in Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_design_npe_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs <code>info</code> and <code>info0</code> should be
vectors of the same length with increasing positive numbers.
The design returned will change these by some constant scale
factor to ensure the design has power <code>1 - beta</code>.
The bound specifications in <code>upper</code>, <code>lower</code>, <code>upar</code>, <code>lpar</code>
will be used to ensure Type I error and other boundary properties are as specified.
</p>


<h3>Value</h3>

<p>A tibble with columns analysis, bound, z, probability, theta, info, info0.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Author(s)</h3>

<p>Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(gsDesign)

# Example 1 ----
# Single analysis
# Lachin book p 71 difference of proportions example
pc &lt;- .28 # Control response rate
pe &lt;- .40 # Experimental response rate
p0 &lt;- (pc + pe) / 2 # Ave response rate under H0

# Information per increment of 1 in sample size
info0 &lt;- 1 / (p0 * (1 - p0) * 4)
info &lt;- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)

# Result should round up to next even number = 652
# Divide information needed under H1 by information per patient added
gs_design_npe(theta = pe - pc, info = info, info0 = info0)


# Example 2 ----
# Fixed bound
x &lt;- gs_design_npe(
  alpha = 0.0125,
  theta = c(.1, .2, .3),
  info = (1:3) * 80,
  info0 = (1:3) * 80,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF, alpha = 0.0125)$upper$bound,
  lower = gs_b,
  lpar = c(-1, 0, 0)
)
x

# Same upper bound; this represents non-binding Type I error and will total 0.025
gs_power_npe(
  theta = rep(0, 3),
  info = (x %&gt;% filter(bound == "upper"))$info,
  upper = gs_b,
  upar = (x %&gt;% filter(bound == "upper"))$z,
  lower = gs_b,
  lpar = rep(-Inf, 3)
)

# Example 3 ----
# Spending bound examples
# Design with futility only at analysis 1; efficacy only at analyses 2, 3
# Spending bound for efficacy; fixed bound for futility
# NOTE: test_upper and test_lower DO NOT WORK with gs_b; must explicitly make bounds infinite
# test_upper and test_lower DO WORK with gs_spending_bound
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_b,
  lpar = c(-1, -Inf, -Inf),
  test_upper = c(FALSE, TRUE, TRUE)
)

# one can try `info_scale = "h1_info"` or `info_scale = "h0_info"` here
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 30,
  info_scale = "h1_info",
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_b,
  lpar = c(-1, -Inf, -Inf),
  test_upper = c(FALSE, TRUE, TRUE)
)

# Example 4 ----
# Spending function bounds
# 2-sided asymmetric bounds
# Lower spending based on non-zero effect
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 30,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)
)

# Example 5 ----
# Two-sided symmetric spend, O'Brien-Fleming spending
# Typically, 2-sided bounds are binding
xx &lt;- gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)
xx

# Re-use these bounds under alternate hypothesis
# Always use binding = TRUE for power calculations
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_b,
  lower = gs_b,
  upar = (xx %&gt;% filter(bound == "upper"))$z,
  lpar = -(xx %&gt;% filter(bound == "upper"))$z
)
</code></pre>

<hr>
<h2 id='gs_design_rd'>Group sequential design of binary outcome measuring in risk difference</h2><span id='topic+gs_design_rd'></span>

<h3>Description</h3>

<p>Group sequential design of binary outcome measuring in risk difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_design_rd(
  p_c = tibble::tibble(stratum = "All", rate = 0.2),
  p_e = tibble::tibble(stratum = "All", rate = 0.15),
  info_frac = 1:3/3,
  rd0 = 0,
  alpha = 0.025,
  beta = 0.1,
  ratio = 1,
  stratum_prev = NULL,
  weight = c("unstratified", "ss", "invar"),
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(0.1), rep(-Inf, 2)),
  test_upper = TRUE,
  test_lower = TRUE,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  binding = FALSE,
  r = 18,
  tol = 1e-06,
  h1_spending = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_design_rd_+3A_p_c">p_c</code></td>
<td>
<p>Rate at the control group.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_p_e">p_e</code></td>
<td>
<p>Rate at the experimental group.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_info_frac">info_frac</code></td>
<td>
<p>Statistical information fraction.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_rd0">rd0</code></td>
<td>
<p>Treatment effect under super-superiority designs, the default is 0.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_stratum_prev">stratum_prev</code></td>
<td>
<p>Randomization ratio of different stratum.
If it is unstratified design then <code>NULL</code>.
Otherwise it is a tibble containing two columns (stratum and prevalence).</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_weight">weight</code></td>
<td>
<p>The weighting scheme for stratified population.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default) indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value of <code>FALSE</code> indicates no lower bound; otherwise,
a logical vector of the same length as <code>info</code> should indicate which
analyses will have a lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration
as in Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
<tr><td><code id="gs_design_rd_+3A_h1_spending">h1_spending</code></td>
<td>
<p>Indicator that lower bound to be set by
spending under alternate hypothesis (input <code>fail_rate</code>)
if spending is used for lower bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be added.
</p>


<h3>Value</h3>

<p>A list with input parameters, analysis, and bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign)

# Example 1 ----
# unstratified group sequential design
gs_design_rd(
  p_c = tibble::tibble(stratum = "All", rate = .2),
  p_e = tibble::tibble(stratum = "All", rate = .15),
  info_frac = c(0.7, 1),
  rd0 = 0,
  alpha = .025,
  beta = .1,
  ratio = 1,
  stratum_prev = NULL,
  weight = "unstratified",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 2, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 2 ----
# stratified group sequential design
gs_design_rd(
  p_c = tibble::tibble(
    stratum = c("biomarker positive", "biomarker negative"),
    rate = c(.2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("biomarker positive", "biomarker negative"),
    rate = c(.15, .22)
  ),
  info_frac = c(0.7, 1),
  rd0 = 0,
  alpha = .025,
  beta = .1,
  ratio = 1,
  stratum_prev = tibble::tibble(
    stratum = c("biomarker positive", "biomarker negative"),
    prevalence = c(.4, .6)
  ),
  weight = "ss",
  upper = gs_spending_bound, lower = gs_b,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lpar = rep(-Inf, 2)
)
</code></pre>

<hr>
<h2 id='gs_design_wlr'>Group sequential design using weighted log-rank test under non-proportional hazards</h2><span id='topic+gs_design_wlr'></span>

<h3>Description</h3>

<p>Group sequential design using weighted log-rank test under non-proportional hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_design_wlr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = tibble(stratum = "All", duration = c(3, 100), fail_rate = log(2)/c(9, 18),
    hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),
  weight = wlr_weight_fh,
  approx = "asymptotic",
  alpha = 0.025,
  beta = 0.1,
  ratio = 1,
  info_frac = NULL,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  analysis_time = 36,
  binding = FALSE,
  upper = gs_b,
  upar = gsDesign(k = 3, test.type = 1, n.I = c(0.25, 0.75, 1), sfu = sfLDOF, sfupar =
    NULL)$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(0.1), -Inf, -Inf),
  test_upper = TRUE,
  test_lower = TRUE,
  h1_spending = TRUE,
  r = 18,
  tol = 1e-06,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_design_wlr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_weight">weight</code></td>
<td>
<p>Weight of weighted log rank test:
</p>

<ul>
<li> <p><code>"1"</code> = unweighted.
</p>
</li>
<li> <p><code>"n"</code> = Gehan-Breslow.
</p>
</li>
<li> <p><code>"sqrtN"</code> = Tarone-Ware.
</p>
</li>
<li> <p><code>"FH_p[a]_q[b]"</code> = Fleming-Harrington with p=a and q=b.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_approx">approx</code></td>
<td>
<p>Approximate estimation method for Z statistics.
</p>

<ul>
<li> <p><code>"event_driven"</code> = only work under proportional hazard model with log rank test.
</p>
</li>
<li> <p><code>"asymptotic"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_alpha">alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_beta">beta</code></td>
<td>
<p>Type II error.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_info_frac">info_frac</code></td>
<td>
<p>Targeted information fraction at each analysis.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Minimum time of analysis.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default) indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicated no lower bound; otherwise, a logical vector
of the same length as <code>info</code> should indicate which analyses will have a
lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_h1_spending">h1_spending</code></td>
<td>
<p>Indicator that lower bound to be set by spending
under alternate hypothesis (input <code>fail_rate</code>)
if spending is used for lower bound.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
<tr><td><code id="gs_design_wlr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with input parameters, enrollment rate, analysis, and bound.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(mvtnorm)
library(gsDesign)
library(gsDesign2)

# set enrollment rates
enroll_rate &lt;- define_enroll_rate(duration = 12, rate = 500 / 12)

# set failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 15, # median survival 15 month
  hr = c(1, .6),
  dropout_rate = 0.001
)

# Example 1 ----
# Boundary is fixed
x &lt;- gsSurv(
  k = 3,
  test.type = 4,
  alpha = 0.025, beta = 0.2,
  astar = 0, timing = 1,
  sfu = sfLDOF, sfupar = 0,
  sfl = sfLDOF, sflpar = 0,
  lambdaC = 0.1,
  hr = 0.6, hr0 = 1,
  eta = 0.01, gamma = 10,
  R = 12, S = NULL,
  T = 36, minfup = 24,
  ratio = 1
)

gs_design_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  ratio = 1,
  alpha = 0.025, beta = 0.2,
  weight = function(x, arm0, arm1) {
    wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0.5)
  },
  upper = gs_b,
  upar = x$upper$bound,
  lower = gs_b,
  lpar = x$lower$bound,
  analysis_time = c(12, 24, 36)
)

# Example 2 ----
# Boundary derived by spending function
gs_design_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  ratio = 1,
  alpha = 0.025, beta = 0.2,
  weight = function(x, arm0, arm1) {
    wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0.5)
  },
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2),
  analysis_time = c(12, 24, 36)
)
</code></pre>

<hr>
<h2 id='gs_info_ahr'>Information and effect size based on AHR approximation</h2><span id='topic+gs_info_ahr'></span>

<h3>Description</h3>

<p>Based on piecewise enrollment rate, failure rate, and dropout rates computes
approximate information and effect size using an average hazard ratio model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_info_ahr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  ratio = 1,
  event = NULL,
  analysis_time = NULL,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_info_ahr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_info_ahr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_info_ahr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="gs_info_ahr_+3A_event">event</code></td>
<td>
<p>Targeted minimum events at each analysis.</p>
</td></tr>
<tr><td><code id="gs_info_ahr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Targeted minimum study duration at each analysis.</p>
</td></tr>
<tr><td><code id="gs_info_ahr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+ahr">ahr()</a></code> function computes statistical information at targeted
event times. The <code><a href="#topic+expected_time">expected_time()</a></code> function is used to get events and
average HR at targeted <code>analysis_time</code>.
</p>


<h3>Value</h3>

<p>A data frame with columns Analysis, Time, AHR, Events, theta, info, info0.
<code>info</code>, and <code>info0</code> contain statistical information under H1, H0, respectively.
For analysis <code>k</code>, <code>Time[k]</code> is the maximum of <code>analysis_time[k]</code> and the
expected time required to accrue the targeted <code>event[k]</code>.
<code>AHR</code> is the expected average hazard ratio at each analysis.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign)
library(gsDesign2)

# Example 1 ----

# Only put in targeted events
gs_info_ahr(event = c(30, 40, 50))

# Example 2 ----

# Only put in targeted analysis times
gs_info_ahr(analysis_time = c(18, 27, 36))

# Example 3 ----

# Some analysis times after time at which targeted event accrue
# Check that both Time &gt;= input analysis_time and event &gt;= input event
gs_info_ahr(event = c(30, 40, 50), analysis_time = c(16, 19, 26))
gs_info_ahr(event = c(30, 40, 50), analysis_time = c(14, 20, 24))

</code></pre>

<hr>
<h2 id='gs_info_combo'>Information and effect size for MaxCombo test</h2><span id='topic+gs_info_combo'></span>

<h3>Description</h3>

<p>Information and effect size for MaxCombo test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_info_combo(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  ratio = 1,
  event = NULL,
  analysis_time = NULL,
  rho,
  gamma,
  tau = rep(-1, length(rho)),
  approx = "asymptotic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_info_combo_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_event">event</code></td>
<td>
<p>Targeted events at each analysis.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Minimum time of analysis.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_rho">rho</code></td>
<td>
<p>Weighting parameters.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_gamma">gamma</code></td>
<td>
<p>Weighting parameters.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_tau">tau</code></td>
<td>
<p>Weighting parameters.</p>
</td></tr>
<tr><td><code id="gs_info_combo_+3A_approx">approx</code></td>
<td>
<p>Approximation method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns as test index, analysis index,
analysis time, sample size, number of events, ahr, delta,
sigma2, theta, and statistical information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs_info_combo(rho = c(0, 0.5), gamma = c(0.5, 0), analysis_time = c(12, 24))
</code></pre>

<hr>
<h2 id='gs_info_rd'>Information and effect size under risk difference</h2><span id='topic+gs_info_rd'></span>

<h3>Description</h3>

<p>Information and effect size under risk difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_info_rd(
  p_c = tibble::tibble(stratum = "All", rate = 0.2),
  p_e = tibble::tibble(stratum = "All", rate = 0.15),
  n = tibble::tibble(stratum = "All", n = c(100, 200, 300), analysis = 1:3),
  rd0 = 0,
  ratio = 1,
  weight = c("unstratified", "ss", "invar")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_info_rd_+3A_p_c">p_c</code></td>
<td>
<p>Rate at the control group.</p>
</td></tr>
<tr><td><code id="gs_info_rd_+3A_p_e">p_e</code></td>
<td>
<p>Rate at the experimental group.</p>
</td></tr>
<tr><td><code id="gs_info_rd_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="gs_info_rd_+3A_rd0">rd0</code></td>
<td>
<p>The risk difference under H0.</p>
</td></tr>
<tr><td><code id="gs_info_rd_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="gs_info_rd_+3A_weight">weight</code></td>
<td>
<p>Weighting method, can be <code>"unstratified"</code>, <code>"ss"</code>,
or <code>"invar"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns as analysis index, sample size,
risk difference, risk difference under null hypothesis, theta1
(standardized treatment effect under alternative hypothesis),
theta0 (standardized treatment effect under null hypothesis),
and statistical information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----
# unstratified case with H0: rd0 = 0
gs_info_rd(
  p_c = tibble::tibble(stratum = "All", rate = .15),
  p_e = tibble::tibble(stratum = "All", rate = .1),
  n = tibble::tibble(stratum = "All", n = c(100, 200, 300), analysis = 1:3),
  rd0 = 0,
  ratio = 1
)

# Example 2 ----
# unstratified case with H0: rd0 != 0
gs_info_rd(
  p_c = tibble::tibble(stratum = "All", rate = .2),
  p_e = tibble::tibble(stratum = "All", rate = .15),
  n = tibble::tibble(stratum = "All", n = c(100, 200, 300), analysis = 1:3),
  rd0 = 0.005,
  ratio = 1
)

# Example 3 ----
# stratified case under sample size weighting and H0: rd0 = 0
gs_info_rd(
  p_c = tibble::tibble(stratum = c("S1", "S2", "S3"), rate = c(.15, .2, .25)),
  p_e = tibble::tibble(stratum = c("S1", "S2", "S3"), rate = c(.1, .16, .19)),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(50, 100, 200, 40, 80, 160, 60, 120, 240)
  ),
  rd0 = 0,
  ratio = 1,
  weight = "ss"
)

# Example 4 ----
# stratified case under inverse variance weighting and H0: rd0 = 0
gs_info_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(50, 100, 200, 40, 80, 160, 60, 120, 240)
  ),
  rd0 = 0,
  ratio = 1,
  weight = "invar"
)

# Example 5 ----
# stratified case under sample size weighting and H0: rd0 != 0
gs_info_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(50, 100, 200, 40, 80, 160, 60, 120, 240)
  ),
  rd0 = 0.02,
  ratio = 1,
  weight = "ss"
)

# Example 6 ----
# stratified case under inverse variance weighting and H0: rd0 != 0
gs_info_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(50, 100, 200, 40, 80, 160, 60, 120, 240)
  ),
  rd0 = 0.02,
  ratio = 1,
  weight = "invar"
)

# Example 7 ----
# stratified case under inverse variance weighting and H0: rd0 != 0 and
# rd0 difference for different statum
gs_info_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(50, 100, 200, 40, 80, 160, 60, 120, 240)
  ),
  rd0 = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rd0 = c(0.01, 0.02, 0.03)
  ),
  ratio = 1,
  weight = "invar"
)
</code></pre>

<hr>
<h2 id='gs_info_wlr'>Information and effect size for weighted log-rank test</h2><span id='topic+gs_info_wlr'></span>

<h3>Description</h3>

<p>Based on piecewise enrollment rate, failure rate, and dropout rates computes
approximate information and effect size using an average hazard ratio model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_info_wlr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  ratio = 1,
  event = NULL,
  analysis_time = NULL,
  weight = wlr_weight_fh,
  approx = "asymptotic",
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_info_wlr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio.</p>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_event">event</code></td>
<td>
<p>Targeted minimum events at each analysis.</p>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Targeted minimum study duration at each analysis.</p>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_weight">weight</code></td>
<td>
<p>Weight of weighted log rank test:
</p>

<ul>
<li> <p><code>"1"</code> = unweighted.
</p>
</li>
<li> <p><code>"n"</code> = Gehan-Breslow.
</p>
</li>
<li> <p><code>"sqrtN"</code> = Tarone-Ware.
</p>
</li>
<li> <p><code>"FH_p[a]_q[b]"</code> = Fleming-Harrington with p=a and q=b.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_approx">approx</code></td>
<td>
<p>Approximate estimation method for Z statistics.
</p>

<ul>
<li> <p><code>"event_driven"</code> = only work under proportional hazard model with log rank test.
</p>
</li>
<li> <p><code>"asymptotic"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_info_wlr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+ahr">ahr()</a></code> function computes statistical information at targeted event times.
The <code><a href="#topic+expected_time">expected_time()</a></code> function is used to get events and average HR at
targeted <code>analysis_time</code>.
</p>


<h3>Value</h3>

<p>A tibble with columns Analysis, Time, N, Events, AHR, delta, sigma2,
theta, info, info0.
<code>info</code> and <code>info0</code> contain statistical information under H1, H0, respectively.
For analysis <code>k</code>, <code>Time[k]</code> is the maximum of <code>analysis_time[k]</code> and the
expected time required to accrue the targeted <code>event[k]</code>.
<code>AHR</code> is the expected average hazard ratio at each analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign2)

# Set enrollment rates
enroll_rate &lt;- define_enroll_rate(duration = 12, rate = 500 / 12)

# Set failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 15, # median survival 15 month
  hr = c(1, .6),
  dropout_rate = 0.001
)

# Set the targeted number of events and analysis time
event &lt;- c(30, 40, 50)
analysis_time &lt;- c(10, 24, 30)

gs_info_wlr(
  enroll_rate = enroll_rate, fail_rate = fail_rate,
  event = event, analysis_time = analysis_time
)
</code></pre>

<hr>
<h2 id='gs_power_ahr'>Group sequential design power using average hazard ratio under
non-proportional hazards</h2><span id='topic+gs_power_ahr'></span>

<h3>Description</h3>

<p>Group sequential design power using average hazard ratio under
non-proportional hazards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_power_ahr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = rep(0.001, 2)),
  event = c(30, 40, 50),
  analysis_time = NULL,
  upper = gs_b,
  upar = gsDesign(k = length(event), test.type = 1, n.I = event, maxn.IPlan = max(event),
    sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(0.1), rep(-Inf, 2)),
  test_lower = TRUE,
  test_upper = TRUE,
  ratio = 1,
  binding = FALSE,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  r = 18,
  tol = 1e-06,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_power_ahr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_event">event</code></td>
<td>
<p>Targeted event at each analysis.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Minimum time of analysis.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value of <code>FALSE</code> indicated no lower bound;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have a lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default) indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should
indicate which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
<tr><td><code id="gs_power_ahr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bound satisfy input upper bound specification in
<code>upper</code>, <code>upar</code>, and lower bound specification in <code>lower</code>, <code>lpar</code>.
<code><a href="#topic+ahr">ahr()</a></code> computes statistical information at targeted event times.
The <code><a href="#topic+expected_time">expected_time()</a></code> function is used to get events and average HR at
targeted <code>analysis_time</code>.
</p>


<h3>Value</h3>

<p>A tibble with columns <code>Analysis</code>, <code>Bound</code>, <code>Z</code>, <code>Probability</code>,
<code>theta</code>, <code>Time</code>, <code>AHR</code>, <code>Events</code>.
Contains a row for each analysis and each bound.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign2)
library(dplyr)

# Example 1 ----
# The default output of `gs_power_ahr()` is driven by events,
# i.e., `event = c(30, 40, 50)`, `analysis_time = NULL`

gs_power_ahr()

# Example 2 ----
# 2-sided symmetric O'Brien-Fleming spending bound, driven by analysis time,
# i.e., `event = NULL`, `analysis_time = c(12, 24, 36)`

gs_power_ahr(
  analysis_time = c(12, 24, 36),
  event = NULL,
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)

# Example 3 ----
# 2-sided symmetric O'Brien-Fleming spending bound, driven by event,
# i.e., `event = c(20, 50, 70)`, `analysis_time = NULL`

gs_power_ahr(
  analysis_time = NULL,
  event = c(20, 50, 70),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)

# Example 4 ----
# 2-sided symmetric O'Brien-Fleming spending bound,
# driven by both `event` and `analysis_time`, i.e.,
# both `event` and `analysis_time` are not `NULL`,
# then the analysis will driven by the maximal one, i.e.,
# Time = max(analysis_time, calculated Time for targeted event)
# Events = max(events, calculated events for targeted analysis_time)

gs_power_ahr(
  analysis_time = c(12, 24, 36),
  event = c(30, 40, 50),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)

</code></pre>

<hr>
<h2 id='gs_power_combo'>Group sequential design power using MaxCombo test under non-proportional hazards</h2><span id='topic+gs_power_combo'></span>

<h3>Description</h3>

<p>Group sequential design power using MaxCombo test under non-proportional hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_power_combo(
  enroll_rate = define_enroll_rate(duration = 12, rate = 500/12),
  fail_rate = define_fail_rate(duration = c(4, 100), fail_rate = log(2)/15, hr = c(1,
    0.6), dropout_rate = 0.001),
  fh_test = rbind(data.frame(rho = 0, gamma = 0, tau = -1, test = 1, analysis = 1:3,
    analysis_time = c(12, 24, 36)), data.frame(rho = c(0, 0.5), gamma = 0.5, tau = -1,
    test = 2:3, analysis = 3, analysis_time = 36)),
  ratio = 1,
  binding = FALSE,
  upper = gs_b,
  upar = c(3, 2, 1),
  lower = gs_b,
  lpar = c(-1, 0, 1),
  algorithm = GenzBretz(maxpts = 1e+05, abseps = 1e-05),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_power_combo_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_fh_test">fh_test</code></td>
<td>
<p>A data frame to summarize the test in each analysis.
See examples for its data structure.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="mvtnorm.html#topic+GenzBretz">GenzBretz</a></code>,
<code><a href="mvtnorm.html#topic+Miwa">Miwa</a></code> or <code><a href="mvtnorm.html#topic+TVPACK">TVPACK</a></code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td></tr>
<tr><td><code id="gs_power_combo_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <a href="mvtnorm.html#topic+pmvnorm">mvtnorm::pmvnorm</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with input parameters, enrollment rate, analysis, and bound.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(mvtnorm)
library(gsDesign)
library(gsDesign2)

enroll_rate &lt;- define_enroll_rate(
  duration = 12,
  rate = 500 / 12
)

fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 15, # median survival 15 month
  hr = c(1, .6),
  dropout_rate = 0.001
)

fh_test &lt;- rbind(
  data.frame(rho = 0, gamma = 0, tau = -1, test = 1, analysis = 1:3, analysis_time = c(12, 24, 36)),
  data.frame(rho = c(0, 0.5), gamma = 0.5, tau = -1, test = 2:3, analysis = 3, analysis_time = 36)
)

# Example 1 ----
# Minimal Information Fraction derived bound

gs_power_combo(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  fh_test = fh_test,
  upper = gs_spending_combo,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_combo,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)
)

</code></pre>

<hr>
<h2 id='gs_power_npe'>Group sequential bound computation with non-constant effect</h2><span id='topic+gs_power_npe'></span>

<h3>Description</h3>

<p>Derives group sequential bounds and boundary crossing probabilities for a design.
It allows a non-constant treatment effect over time,
but also can be applied for the usual homogeneous effect size designs.
It requires treatment effect and statistical information at each analysis
as well as a method of deriving bounds, such as spending.
The routine enables two things not available in the gsDesign package:
</p>

<ol>
<li><p> non-constant effect, 2) more flexibility in boundary selection.
For many applications, the non-proportional-hazards design function
<code>gs_design_nph()</code> will be used; it calls this function.
Initial bound types supported are 1) spending bounds,
</p>
</li>
<li><p> fixed bounds, and 3) Haybittle-Peto-like bounds.
The requirement is to have a boundary update method that can
each bound without knowledge of future bounds.
As an example, bounds based on conditional power that require
knowledge of all future bounds are not supported by this routine;
a more limited conditional power method will be demonstrated.
Boundary family designs Wang-Tsiatis designs including the
original (non-spending-function-based) O'Brien-Fleming and Pocock designs
are not supported by <code>gs_power_npe()</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gs_power_npe(
  theta = 0.1,
  theta0 = NULL,
  theta1 = NULL,
  info = 1,
  info0 = NULL,
  info1 = NULL,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  upper = gs_b,
  upar = qnorm(0.975),
  lower = gs_b,
  lpar = -Inf,
  test_upper = TRUE,
  test_lower = TRUE,
  binding = FALSE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_power_npe_+3A_theta">theta</code></td>
<td>
<p>Natural parameter for group sequential design representing
expected incremental drift at all analyses; used for power calculation.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_theta0">theta0</code></td>
<td>
<p>Natural parameter for null hypothesis,
if needed for upper bound computation.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_theta1">theta1</code></td>
<td>
<p>Natural parameter for alternate hypothesis,
if needed for lower bound computation.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_info">info</code></td>
<td>
<p>Statistical information at all analyses for input <code>theta</code>.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_info0">info0</code></td>
<td>
<p>Statistical information under null hypothesis,
if different than <code>info</code>;
impacts null hypothesis bound calculation.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_info1">info1</code></td>
<td>
<p>Statistical information under hypothesis used for
futility bound calculation if different from
<code>info</code>; impacts futility hypothesis bound calculation.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_lower">lower</code></td>
<td>
<p>Function to compare lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_lpar">lpar</code></td>
<td>
<p>parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include
an upper (efficacy) bound;
single value of <code>TRUE</code> (default) indicates all analyses; otherwise,
a logical vector of the same length as <code>info</code> should
indicate which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include a lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value of <code>FALSE</code> indicated no lower bound; otherwise,
a logical vector of the same length as <code>info</code> should
indicate which analyses will have a lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_power_npe_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns as analysis index, bounds, z,
crossing probability, theta (standardized treatment effect),
theta1 (standardized treatment effect under alternative hypothesis),
information fraction, and statistical information.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign)
library(gsDesign2)
library(dplyr)

# Default (single analysis; Type I error controlled)
gs_power_npe(theta = 0) %&gt;% filter(bound == "upper")

# Fixed bound
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lower = gs_b,
  lpar = c(-1, 0, 0)
)

# Same fixed efficacy bounds, no futility bound (i.e., non-binding bound), null hypothesis
gs_power_npe(
  theta = rep(0, 3),
  info = (1:3) * 40,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lpar = rep(-Inf, 3)
) %&gt;%
  filter(bound == "upper")

# Fixed bound with futility only at analysis 1; efficacy only at analyses 2, 3
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = c(Inf, 3, 2),
  lower = gs_b,
  lpar = c(qnorm(.1), -Inf, -Inf)
)

# Spending function bounds
# Lower spending based on non-zero effect
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)
)

# Same bounds, but power under different theta
gs_power_npe(
  theta = c(.15, .25, .35),
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)
)

# Two-sided symmetric spend, O'Brien-Fleming spending
# Typically, 2-sided bounds are binding
x &lt;- gs_power_npe(
  theta = rep(0, 3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)

# Re-use these bounds under alternate hypothesis
# Always use binding = TRUE for power calculations
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  binding = TRUE,
  upar = (x %&gt;% filter(bound == "upper"))$z,
  lpar = -(x %&gt;% filter(bound == "upper"))$z
)
</code></pre>

<hr>
<h2 id='gs_power_rd'>Group sequential design power of binary outcome measuring in risk difference</h2><span id='topic+gs_power_rd'></span>

<h3>Description</h3>

<p>Group sequential design power of binary outcome measuring in risk difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_power_rd(
  p_c = tibble::tibble(stratum = "All", rate = 0.2),
  p_e = tibble::tibble(stratum = "All", rate = 0.15),
  n = tibble::tibble(stratum = "All", n = c(40, 50, 60), analysis = 1:3),
  rd0 = 0,
  ratio = 1,
  weight = c("unstratified", "ss", "invar"),
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(0.1), rep(-Inf, 2)),
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  binding = FALSE,
  test_upper = TRUE,
  test_lower = TRUE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_power_rd_+3A_p_c">p_c</code></td>
<td>
<p>Rate at the control group.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_p_e">p_e</code></td>
<td>
<p>Rate at the experimental group.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_rd0">rd0</code></td>
<td>
<p>Treatment effect under super-superiority designs, the default is 0.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:control randomization ratio.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_weight">weight</code></td>
<td>
<p>Weighting method, can be <code>"unstratified"</code>, <code>"ss"</code>,
or <code>"invar"</code>.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_lower">lower</code></td>
<td>
<p>Function to compare lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default)  indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include a lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicated no lower bound; otherwise,
a logical vector of the same length as <code>info</code> should indicate which
analyses will have a lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_power_rd_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with input parameter, analysis, and bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----
library(gsDesign)

# unstratified case with H0: rd0 = 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = "All",
    rate = .2
  ),
  p_e = tibble::tibble(
    stratum = "All",
    rate = .15
  ),
  n = tibble::tibble(
    stratum = "All",
    n = c(20, 40, 60),
    analysis = 1:3
  ),
  rd0 = 0,
  ratio = 1,
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 2 ----
# unstratified case with H0: rd0 != 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = "All",
    rate = .2
  ),
  p_e = tibble::tibble(
    stratum = "All",
    rate = .15
  ),
  n = tibble::tibble(
    stratum = "All",
    n = c(20, 40, 60),
    analysis = 1:3
  ),
  rd0 = 0.005,
  ratio = 1,
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# use spending function
gs_power_rd(
  p_c = tibble::tibble(
    stratum = "All",
    rate = .2
  ),
  p_e = tibble::tibble(
    stratum = "All",
    rate = .15
  ),
  n = tibble::tibble(
    stratum = "All",
    n = c(20, 40, 60),
    analysis = 1:3
  ),
  rd0 = 0.005,
  ratio = 1,
  upper = gs_spending_bound,
  lower = gs_b,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 3 ----
# stratified case under sample size weighting and H0: rd0 = 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(10, 20, 24, 18, 26, 30, 10, 20, 24)
  ),
  rd0 = 0,
  ratio = 1,
  weight = "ss",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 4 ----
# stratified case under inverse variance weighting and H0: rd0 = 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(10, 20, 24, 18, 26, 30, 10, 20, 24)
  ),
  rd0 = 0,
  ratio = 1,
  weight = "invar",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 5 ----
# stratified case under sample size weighting and H0: rd0 != 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(10, 20, 24, 18, 26, 30, 10, 20, 24)
  ),
  rd0 = 0.02,
  ratio = 1,
  weight = "ss",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 6 ----
# stratified case under inverse variance weighting and H0: rd0 != 0
gs_power_rd(
  p_c = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.15, .2, .25)
  ),
  p_e = tibble::tibble(
    stratum = c("S1", "S2", "S3"),
    rate = c(.1, .16, .19)
  ),
  n = tibble::tibble(
    stratum = rep(c("S1", "S2", "S3"), each = 3),
    analysis = rep(1:3, 3),
    n = c(10, 20, 24, 18, 26, 30, 10, 20, 24)
  ),
  rd0 = 0.03,
  ratio = 1,
  weight = "invar",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)
</code></pre>

<hr>
<h2 id='gs_power_wlr'>Group sequential design power using weighted log rank test under non-proportional hazards</h2><span id='topic+gs_power_wlr'></span>

<h3>Description</h3>

<p>Group sequential design power using weighted log rank test under non-proportional hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_power_wlr(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = tibble(stratum = "All", duration = c(3, 100), fail_rate = log(2)/c(9, 18),
    hr = c(0.9, 0.6), dropout_rate = rep(0.001, 2)),
  event = c(30, 40, 50),
  analysis_time = NULL,
  binding = FALSE,
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign(k = 3, test.type = 1, n.I = c(30, 40, 50), maxn.IPlan = 50, sfu =
    sfLDOF, sfupar = NULL)$upper$bound,
  lpar = c(qnorm(0.1), rep(-Inf, 2)),
  test_upper = TRUE,
  test_lower = TRUE,
  ratio = 1,
  weight = wlr_weight_fh,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  approx = "asymptotic",
  r = 18,
  tol = 1e-06,
  interval = c(0.01, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_power_wlr_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>Enrollment rates.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_fail_rate">fail_rate</code></td>
<td>
<p>Failure and dropout rates.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_event">event</code></td>
<td>
<p>Targeted event at each analysis.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Minimum time of analysis.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_binding">binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_upper">upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_lower">lower</code></td>
<td>
<p>Function to compute lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_upar">upar</code></td>
<td>
<p>Parameters passed to <code>upper</code>.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_lpar">lpar</code></td>
<td>
<p>Parameters passed to <code>lower</code>.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_test_upper">test_upper</code></td>
<td>
<p>Indicator of which analyses should include an upper
(efficacy) bound; single value of <code>TRUE</code> (default) indicates all analyses;
otherwise, a logical vector of the same length as <code>info</code> should indicate
which analyses will have an efficacy bound.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_test_lower">test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicated no lower bound; otherwise, a logical vector
of the same length as <code>info</code> should indicate which analyses will have a
lower bound.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_ratio">ratio</code></td>
<td>
<p>Experimental:Control randomization ratio (not yet implemented).</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_weight">weight</code></td>
<td>
<p>Weight of weighted log rank test:
</p>

<ul>
<li> <p><code>"1"</code> = unweighted.
</p>
</li>
<li> <p><code>"n"</code> = Gehan-Breslow.
</p>
</li>
<li> <p><code>"sqrtN"</code> = Tarone-Ware.
</p>
</li>
<li> <p><code>"FH_p[a]_q[b]"</code> = Fleming-Harrington with p=a and q=b.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_info_scale">info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_approx">approx</code></td>
<td>
<p>Approximate estimation method for Z statistics.
</p>

<ul>
<li> <p><code>"event_driven"</code> = only work under proportional hazard model with log rank test.
</p>
</li>
<li> <p><code>"asymptotic"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration as in
Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally, <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td></tr>
<tr><td><code id="gs_power_wlr_+3A_interval">interval</code></td>
<td>
<p>An interval that is presumed to include the time at which
expected event count is equal to targeted event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with input parameters, enrollment rate,
analysis, and bound.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gsDesign)
library(gsDesign2)

# set enrollment rates
enroll_rate &lt;- define_enroll_rate(duration = 12, rate = 500 / 12)

# set failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 15, # median survival 15 month
  hr = c(1, .6),
  dropout_rate = 0.001
)

# set the targeted number of events and analysis time
target_events &lt;- c(30, 40, 50)
target_analysisTime &lt;- c(10, 24, 30)

# Example 1 ----

# fixed bounds and calculate the power for targeted number of events
gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = target_events,
  analysis_time = NULL,
  upper = gs_b,
  upar = gsDesign(
    k = length(target_events),
    test.type = 1,
    n.I = target_events,
    maxn.IPlan = max(target_events),
    sfu = sfLDOF,
    sfupar = NULL
  )$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 2 ----
# fixed bounds and calculate the power for targeted analysis time

gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = NULL,
  analysis_time = target_analysisTime,
  upper = gs_b,
  upar = gsDesign(
    k = length(target_events),
    test.type = 1,
    n.I = target_events,
    maxn.IPlan = max(target_events),
    sfu = sfLDOF,
    sfupar = NULL
  )$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 3 ----
# fixed bounds and calculate the power for targeted analysis time &amp; number of events

gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = target_events,
  analysis_time = target_analysisTime,
  upper = gs_b,
  upar = gsDesign(
    k = length(target_events),
    test.type = 1,
    n.I = target_events,
    maxn.IPlan = max(target_events),
    sfu = sfLDOF,
    sfupar = NULL
  )$upper$bound,
  lower = gs_b,
  lpar = c(qnorm(.1), rep(-Inf, 2))
)

# Example 4 ----
# spending bounds and calculate the power for targeted number of events

gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = target_events,
  analysis_time = NULL,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)
)

# Example 5 ----
# spending bounds and calculate the power for targeted analysis time

gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = NULL,
  analysis_time = target_analysisTime,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)
)

# Example 6 ----
# spending bounds and calculate the power for targeted analysis time &amp; number of events

gs_power_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  event = target_events,
  analysis_time = target_analysisTime,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)
)

</code></pre>

<hr>
<h2 id='gs_spending_bound'>Derive spending bound for group sequential boundary</h2><span id='topic+gs_spending_bound'></span>

<h3>Description</h3>

<p>Computes one bound at a time based on spending under given distributional
assumptions. While user specifies <code>gs_spending_bound()</code> for use with other
functions, it is not intended for use on its own.
Most important user specifications are made through a list provided to
functions using <code>gs_spending_bound()</code>.
Function uses numerical integration and Newton-Raphson iteration to derive
an individual bound for a group sequential design that satisfies a
targeted boundary crossing probability. Algorithm is a simple extension of
that in Chapter 19 of Jennison and Turnbull (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_spending_bound(
  k = 1,
  par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL,
    max_info = NULL),
  hgm1 = NULL,
  theta = 0.1,
  info = 1:3,
  efficacy = TRUE,
  test_bound = TRUE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_spending_bound_+3A_k">k</code></td>
<td>
<p>Analysis for which bound is to be computed.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_par">par</code></td>
<td>
<p>A list with the following items:
</p>

<ul>
<li> <p><code>sf</code> (class spending function).
</p>
</li>
<li> <p><code>total_spend</code> (total spend).
</p>
</li>
<li> <p><code>param</code> (any parameters needed by the spending function <code>sf()</code>).
</p>
</li>
<li> <p><code>timing</code> (a vector containing values at which spending function
is to be evaluated or <code>NULL</code> if information-based spending is used).
</p>
</li>
<li> <p><code>max_info</code> (when <code>timing</code> is <code>NULL</code>, this can be input as positive number
to be used with <code>info</code> for information fraction at each analysis).
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_hgm1">hgm1</code></td>
<td>
<p>Subdensity grid from <code>h1()</code> (k=2) or <code>hupdate()</code> (k&gt;2)
for analysis k-1; if k=1, this is not used and may be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_theta">theta</code></td>
<td>
<p>Natural parameter used for lower bound only spending;
represents average drift at each time of analysis at least up to analysis k;
upper bound spending is always set under null hypothesis (theta = 0).</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_info">info</code></td>
<td>
<p>Statistical information at all analyses, at least up to analysis k.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_efficacy">efficacy</code></td>
<td>
<p><code>TRUE</code> (default) for efficacy bound, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_test_bound">test_bound</code></td>
<td>
<p>A logical vector of the same length as <code>info</code>
should indicate which analyses will have a bound.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_r">r</code></td>
<td>
<p>Integer value controlling grid for numerical integration
as in Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally <code>r</code> will not be changed by the user.</p>
</td></tr>
<tr><td><code id="gs_spending_bound_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence (on Z-scale).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric bound (possibly infinite) or, upon failure,
generates an error message.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Author(s)</h3>

<p>Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>


<h3>References</h3>

<p>Jennison C and Turnbull BW (2000),
<em>Group Sequential Methods with Applications to Clinical Trials</em>.
Boca Raton: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs_power_ahr(
  analysis_time = c(12, 24, 36),
  event = c(30, 40, 50),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)
</code></pre>

<hr>
<h2 id='gs_spending_combo'>Derive spending bound for MaxCombo group sequential boundary</h2><span id='topic+gs_spending_combo'></span>

<h3>Description</h3>

<p>Derive spending bound for MaxCombo group sequential boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_spending_combo(par = NULL, info = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs_spending_combo_+3A_par">par</code></td>
<td>
<p>A list with the following items:
</p>

<ul>
<li> <p><code>sf</code> (class spending function).
</p>
</li>
<li> <p><code>total_spend</code> (total spend).
</p>
</li>
<li> <p><code>param</code> (any parameters needed by the spending function <code>sf()</code>).
</p>
</li>
<li> <p><code>timing</code> (a vector containing values at which spending function
is to be evaluated or <code>NULL</code> if information-based spending is used).
</p>
</li>
<li> <p><code>max_info</code> (when <code>timing</code> is <code>NULL</code>, this can be input as positive number
to be used with <code>info</code> for information fraction at each analysis).
</p>
</li></ul>
</td></tr>
<tr><td><code id="gs_spending_combo_+3A_info">info</code></td>
<td>
<p>Statistical information at all analyses, at least up to analysis k.</p>
</td></tr>
<tr><td><code id="gs_spending_combo_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>par$sf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the alpha spending per analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># alpha-spending
par &lt;- list(sf = gsDesign::sfLDOF, total_spend = 0.025)
gs_spending_combo(par, info = 1:3 / 3)

# beta-spending
par &lt;- list(sf = gsDesign::sfLDOF, total_spend = 0.2)
gs_spending_combo(par, info = 1:3 / 3)
</code></pre>

<hr>
<h2 id='gsDesign2-package'>gsDesign2: Group Sequential Design with Non-Constant Effect</h2><span id='topic+gsDesign2'></span><span id='topic+gsDesign2-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The goal of 'gsDesign2' is to enable fixed or group sequential design under non-proportional hazards. To enable highly flexible enrollment, time-to-event and time-to-dropout assumptions, 'gsDesign2' offers piecewise constant enrollment, failure rates, and dropout rates for a stratified population. This package includes three methods for designs: average hazard ratio, weighted logrank tests in Yung and Liu (2019) <a href="https://doi.org/10.1111/biom.13196">doi:10.1111/biom.13196</a>, and MaxCombo tests. Substantial flexibility on top of what is in the 'gsDesign' package is intended for selecting boundaries.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yujie Zhao <a href="mailto:yujie.zhao@merck.com">yujie.zhao@merck.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>
</li>
<li><p> Yilong Zhang <a href="mailto:elong0527@gmail.com">elong0527@gmail.com</a>
</p>
</li>
<li><p> Jianxiao Yang <a href="mailto:yangjx@ucla.edu">yangjx@ucla.edu</a>
</p>
</li>
<li><p> Nan Xiao <a href="mailto:nan.xiao1@merck.com">nan.xiao1@merck.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Amin Shirazi <a href="mailto:ashirazist@gmail.com">ashirazist@gmail.com</a> [contributor]
</p>
</li>
<li><p> Ruixue Wang <a href="mailto:ruixue.wang@merck.com">ruixue.wang@merck.com</a> [contributor]
</p>
</li>
<li><p> Yi Cui <a href="mailto:yi.cui@merck.com">yi.cui@merck.com</a> [contributor]
</p>
</li>
<li><p> Ping Yang <a href="mailto:ping.yang1@merck.com">ping.yang1@merck.com</a> [contributor]
</p>
</li>
<li><p> Xin Tong Li <a href="mailto:xin.tong.li@merck.com">xin.tong.li@merck.com</a> [contributor]
</p>
</li>
<li><p> Chenxiang Li <a href="mailto:chenxiang.li@merck.com">chenxiang.li@merck.com</a> [contributor]
</p>
</li>
<li><p> Hiroaki Fukuda <a href="mailto:hiroaki.fukuda@merck.com">hiroaki.fukuda@merck.com</a> [contributor]
</p>
</li>
<li><p> Hongtao Zhang <a href="mailto:hongtao.zhang1@merck.com">hongtao.zhang1@merck.com</a> [contributor]
</p>
</li>
<li><p> Yalin Zhu <a href="mailto:yalin.zhu@outlook.com">yalin.zhu@outlook.com</a> [contributor]
</p>
</li>
<li><p> John Blischak <a href="mailto:jdblischak@gmail.com">jdblischak@gmail.com</a> [contributor]
</p>
</li>
<li><p> Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://merck.github.io/gsDesign2/">https://merck.github.io/gsDesign2/</a>
</p>
</li>
<li> <p><a href="https://github.com/Merck/gsDesign2">https://github.com/Merck/gsDesign2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Merck/gsDesign2/issues">https://github.com/Merck/gsDesign2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ppwe'>Piecewise exponential cumulative distribution function</h2><span id='topic+ppwe'></span>

<h3>Description</h3>

<p>Computes the cumulative distribution function (CDF) or survival rate
for a piecewise exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppwe(x, duration, rate, lower_tail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppwe_+3A_x">x</code></td>
<td>
<p>Times at which distribution is to be computed.</p>
</td></tr>
<tr><td><code id="ppwe_+3A_duration">duration</code></td>
<td>
<p>A numeric vector of time duration.</p>
</td></tr>
<tr><td><code id="ppwe_+3A_rate">rate</code></td>
<td>
<p>A numeric vector of event rate.</p>
</td></tr>
<tr><td><code id="ppwe_+3A_lower_tail">lower_tail</code></td>
<td>
<p>Indicator of whether lower (<code>TRUE</code>) or upper tail
(<code>FALSE</code>; default) of CDF is to be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">\lambda_i</code> is the failure rate in the interval
<code class="reqn">(t_{i-1},t_i], i=1,2,\ldots,M</code> where
<code class="reqn">0=t_0&lt;t_i\ldots,t_M=\infty</code>.
The cumulative hazard function at an arbitrary time <code class="reqn">t&gt;0</code> is then:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(t)=\sum_{i=1}^M \delta(t\leq t_i)(\min(t,t_i)-t_{i-1})\lambda_i.</code>
</p>

<p>The survival at time <code class="reqn">t</code> is then
</p>
<p style="text-align: center;"><code class="reqn">S(t)=\exp(-\Lambda(t)).</code>
</p>



<h3>Value</h3>

<p>A vector with cumulative distribution function or survival values.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot a survival function with 2 different sets of time values
# to demonstrate plot precision corresponding to input parameters.

x1 &lt;- seq(0, 10, 10 / pi)
duration &lt;- c(3, 3, 1)
rate &lt;- c(.2, .1, .005)

survival &lt;- ppwe(
  x = x1,
  duration = duration,
  rate = rate
)
plot(x1, survival, type = "l", ylim = c(0, 1))

x2 &lt;- seq(0, 10, .25)
survival &lt;- ppwe(
  x = x2,
  duration = duration,
  rate = rate
)
lines(x2, survival, col = 2)
</code></pre>

<hr>
<h2 id='pw_info'>Average hazard ratio under non-proportional hazards (test version)</h2><span id='topic+pw_info'></span>

<h3>Description</h3>

<p>Provides a geometric average hazard ratio under
various non-proportional hazards assumptions for either single or multiple strata studies.
The piecewise exponential distribution allows a simple method to specify a distribution
and enrollment pattern where the enrollment, failure and dropout rates changes over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_info(
  enroll_rate = define_enroll_rate(duration = c(2, 2, 10), rate = c(3, 6, 9)),
  fail_rate = define_fail_rate(duration = c(3, 100), fail_rate = log(2)/c(9, 18), hr =
    c(0.9, 0.6), dropout_rate = 0.001),
  total_duration = 30,
  ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pw_info_+3A_enroll_rate">enroll_rate</code></td>
<td>
<p>An <code>enroll_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_enroll_rate">define_enroll_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="pw_info_+3A_fail_rate">fail_rate</code></td>
<td>
<p>A <code>fail_rate</code> data frame with or without stratum
created by <code><a href="#topic+define_fail_rate">define_fail_rate()</a></code>.</p>
</td></tr>
<tr><td><code id="pw_info_+3A_total_duration">total_duration</code></td>
<td>
<p>Total follow-up from start of enrollment to data
cutoff; this can be a single value or a vector of positive numbers.</p>
</td></tr>
<tr><td><code id="pw_info_+3A_ratio">ratio</code></td>
<td>
<p>Ratio of experimental to control randomization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with <code>time</code> (from <code>total_duration</code>),
<code>ahr</code> (average hazard ratio), <code>event</code> (expected number of events),
<code>info</code> (information under given scenarios), <code>and</code> info0
(information under related null hypothesis) for each value of
<code>total_duration</code> input
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: default
pw_info()

# Example: default with multiple analysis times (varying total_duration)
pw_info(total_duration = c(15, 30))

# Stratified population
enroll_rate &lt;- define_enroll_rate(
  stratum = c(rep("Low", 2), rep("High", 3)),
  duration = c(2, 10, 4, 4, 8),
  rate = c(5, 10, 0, 3, 6)
)
fail_rate &lt;- define_fail_rate(
  stratum = c(rep("Low", 2), rep("High", 2)),
  duration = 1,
  fail_rate = c(.1, .2, .3, .4),
  dropout_rate = .001,
  hr = c(.9, .75, .8, .6)
)
# Give results by change-points in the piecewise model
ahr(enroll_rate = enroll_rate, fail_rate = fail_rate, total_duration = c(15, 30))

# Same example, give results by strata and time period
pw_info(enroll_rate = enroll_rate, fail_rate = fail_rate, total_duration = c(15, 30))
</code></pre>

<hr>
<h2 id='s2pwe'>Approximate survival distribution with piecewise exponential distribution</h2><span id='topic+s2pwe'></span>

<h3>Description</h3>

<p>Converts a discrete set of points from an arbitrary survival distribution
to a piecewise exponential approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2pwe(times, survival)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2pwe_+3A_times">times</code></td>
<td>
<p>Positive increasing times at which survival distribution is provided.</p>
</td></tr>
<tr><td><code id="s2pwe_+3A_survival">survival</code></td>
<td>
<p>Survival (1 - cumulative distribution function) at specified <code>times</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the duration and rate.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: arbitrary numbers
s2pwe(1:9, (9:1) / 10)
# Example: lognormal
s2pwe(c(1:6, 9), plnorm(c(1:6, 9), meanlog = 0, sdlog = 2, lower.tail = FALSE))
</code></pre>

<hr>
<h2 id='summary.fixed_design'>Summary for fixed design or group sequential design objects</h2><span id='topic+summary.fixed_design'></span><span id='topic+summary.gs_design'></span>

<h3>Description</h3>

<p>Summary for fixed design or group sequential design objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixed_design'
summary(object, ...)

## S3 method for class 'gs_design'
summary(
  object,
  analysis_vars = NULL,
  analysis_decimals = NULL,
  col_vars = NULL,
  col_decimals = NULL,
  bound_names = c("Efficacy", "Futility"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fixed_design_+3A_object">object</code></td>
<td>
<p>A design object returned by fixed_design_xxx() and gs_design_xxx().</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_...">...</code></td>
<td>
<p>Additional parameters (not used).</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_analysis_vars">analysis_vars</code></td>
<td>
<p>The variables to be put at the summary header of each analysis.</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_analysis_decimals">analysis_decimals</code></td>
<td>
<p>The displayed number of digits of <code>analysis_vars</code>.</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_col_vars">col_vars</code></td>
<td>
<p>The variables to be displayed.</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_col_decimals">col_decimals</code></td>
<td>
<p>The decimals to be displayed for the displayed variables in <code>col_vars</code>.</p>
</td></tr>
<tr><td><code id="summary.fixed_design_+3A_bound_names">bound_names</code></td>
<td>
<p>Names for bounds; default is <code>c("Efficacy", "Futility")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary table (data frame).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Enrollment rate
enroll_rate &lt;- define_enroll_rate(
  duration = 18,
  rate = 20
)

# Failure rates
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 12,
  hr = c(1, .6),
  dropout_rate = .001
)

# Study duration in months
study_duration &lt;- 36

# Experimental / Control randomization ratio
ratio &lt;- 1

# 1-sided Type I error
alpha &lt;- 0.025
# Type II error (1 - power)
beta &lt;- 0.1

# AHR ----
# under fixed power
fixed_design_ahr(
  alpha = alpha,
  power = 1 - beta,
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  study_duration = study_duration,
  ratio = ratio
) %&gt;% summary()

# FH ----
# under fixed power
fixed_design_fh(
  alpha = alpha,
  power = 1 - beta,
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  study_duration = study_duration,
  ratio = ratio
) %&gt;% summary()

# Design parameters ----
library(gsDesign)
library(gsDesign2)
library(dplyr)

# enrollment/failure rates
enroll_rate &lt;- define_enroll_rate(
  stratum = "All",
  duration = 12,
  rate = 1
)
fail_rate &lt;- define_fail_rate(
  duration = c(4, 100),
  fail_rate = log(2) / 12,
  hr = c(1, .6),
  dropout_rate = .001
)

# Information fraction
info_frac &lt;- (1:3) / 3

# Analysis times in months; first 2 will be ignored as info_frac will not be achieved
analysis_time &lt;- c(.01, .02, 36)

# Experimental / Control randomization ratio
ratio &lt;- 1

# 1-sided Type I error
alpha &lt;- 0.025

# Type II error (1 - power)
beta &lt;- .1

# Upper bound
upper &lt;- gs_spending_bound
upar &lt;- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)

# Lower bound
lower &lt;- gs_spending_bound
lpar &lt;- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = 0, timing = NULL)

# weight function in WLR
wgt00 &lt;- function(x, arm0, arm1) {
  wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0)
}
wgt05 &lt;- function(x, arm0, arm1) {
  wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = .5)
}

# test in COMBO
fh_test &lt;- rbind(
  data.frame(rho = 0, gamma = 0, tau = -1, test = 1, analysis = 1:3, analysis_time = c(12, 24, 36)),
  data.frame(rho = c(0, 0.5), gamma = 0.5, tau = -1, test = 2:3, analysis = 3, analysis_time = 36)
)

# AHR ----

x_ahr &lt;- gs_design_ahr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  info_frac = info_frac, # Information fraction
  analysis_time = analysis_time,
  ratio = ratio,
  alpha = alpha,
  beta = beta,
  upper = upper,
  upar = upar,
  lower = lower,
  lpar = lpar
)

x_ahr %&gt;% summary()
x_ahr %&gt;% summary(analysis_vars = c("time", "event", "info_frac"), analysis_decimals = c(1, 0, 2))
x_ahr %&gt;% summary(bound_names = c("A is better", "B is better"))

# WLR ----

x_wlr &lt;- gs_design_wlr(
  enroll_rate = enroll_rate,
  fail_rate = fail_rate,
  weight = wgt05,
  info_frac = NULL,
  analysis_time = sort(unique(x_ahr$analysis$time)),
  ratio = ratio,
  alpha = alpha,
  beta = beta,
  upper = upper,
  upar = upar,
  lower = lower,
  lpar = lpar
)
x_wlr %&gt;% summary()

# Maxcombo ----

x_combo &lt;- gs_design_combo(
  ratio = 1,
  alpha = 0.025,
  beta = 0.2,
  enroll_rate = define_enroll_rate(duration = 12, rate = 500 / 12),
  fail_rate = tibble::tibble(
    stratum = "All",
    duration = c(4, 100),
    fail_rate = log(2) / 15, hr = c(1, .6), dropout_rate = .001
  ),
  fh_test = fh_test,
  upper = gs_spending_combo,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),
  lower = gs_spending_combo,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)
)
x_combo %&gt;% summary()

# Risk difference ----

gs_design_rd(
  p_c = tibble::tibble(stratum = "All", rate = .2),
  p_e = tibble::tibble(stratum = "All", rate = .15),
  info_frac = c(0.7, 1),
  rd0 = 0,
  alpha = .025,
  beta = .1,
  ratio = 1,
  stratum_prev = NULL,
  weight = "unstratified",
  upper = gs_b,
  lower = gs_b,
  upar = gsDesign::gsDesign(
    k = 3, test.type = 1, sfu = gsDesign::sfLDOF, sfupar = NULL
  )$upper$bound,
  lpar = c(qnorm(.1), rep(-Inf, 2))
) %&gt;% summary()

</code></pre>

<hr>
<h2 id='to_integer'>Rounds sample size to an even number for equal design</h2><span id='topic+to_integer'></span><span id='topic+to_integer.fixed_design'></span><span id='topic+to_integer.gs_design'></span>

<h3>Description</h3>

<p>Rounds sample size to an even number for equal design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_integer(x, ...)

## S3 method for class 'fixed_design'
to_integer(x, sample_size = TRUE, ...)

## S3 method for class 'gs_design'
to_integer(x, sample_size = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_integer_+3A_x">x</code></td>
<td>
<p>An object returned by fixed_design_xxx() and gs_design_xxx().</p>
</td></tr>
<tr><td><code id="to_integer_+3A_...">...</code></td>
<td>
<p>Additional parameters (not used).</p>
</td></tr>
<tr><td><code id="to_integer_+3A_sample_size">sample_size</code></td>
<td>
<p>Logical, indicting if ceiling
sample size to an even integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list similar to the output of fixed_design_xxx() and gs_design_xxx(),
except the sample size is an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(gsDesign2)

# Average hazard ratio

x &lt;- fixed_design_ahr(
  alpha = .025, power = .9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 1),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12, hr = c(1, .6),
    dropout_rate = .001
  ),
  study_duration = 36
)
x %&gt;% to_integer()

# FH
x &lt;- fixed_design_fh(
  alpha = 0.025, power = 0.9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12,
    hr = c(1, .6),
    dropout_rate = .001
  ),
  rho = 0.5, gamma = 0.5,
  study_duration = 36, ratio = 1
)
x %&gt;% to_integer()

# MB
x &lt;- fixed_design_mb(
  alpha = 0.025, power = 0.9,
  enroll_rate = define_enroll_rate(duration = 18, rate = 20),
  fail_rate = define_fail_rate(
    duration = c(4, 100),
    fail_rate = log(2) / 12, hr = c(1, .6),
    dropout_rate = .001
  ),
  tau = 4,
  study_duration = 36, ratio = 1
)
x %&gt;% to_integer()


gs_design_ahr() %&gt;% to_integer()


gs_design_wlr() %&gt;% to_integer()

</code></pre>

<hr>
<h2 id='wlr_weight'>Weight functions for weighted log-rank test</h2><span id='topic+wlr_weight'></span><span id='topic+wlr_weight_fh'></span><span id='topic+wlr_weight_1'></span><span id='topic+wlr_weight_n'></span><span id='topic+wlr_weight_mb'></span>

<h3>Description</h3>


<ul>
<li> <p><code>wlr_weight_fh</code> is Fleming-Harrington, FH(rho, gamma) weight function.
</p>
</li>
<li> <p><code>wlr_weight_1</code>  is constant for log rank test.
</p>
</li>
<li> <p><code>wlr_weight_power</code> is Gehan-Breslow and Tarone-Ware weight function.
</p>
</li>
<li> <p><code>wlr_weight_mb</code> is Magirr (2021) weight function.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0, tau = NULL)

wlr_weight_1(x, arm0, arm1)

wlr_weight_n(x, arm0, arm1, power = 1)

wlr_weight_mb(x, arm0, arm1, tau = NULL, wmax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlr_weight_+3A_x">x</code></td>
<td>
<p>A vector of numeric values.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_arm0">arm0</code></td>
<td>
<p>An <code>arm</code> object defined in the npsurvSS package.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_arm1">arm1</code></td>
<td>
<p>An <code>arm</code> object defined in the npsurvSS package.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_rho">rho</code></td>
<td>
<p>A scalar parameter that controls the type of test.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_gamma">gamma</code></td>
<td>
<p>A scalar parameter that controls the type of test.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_tau">tau</code></td>
<td>
<p>A scalar parameter of the cut-off time for modest weighted log rank test.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_power">power</code></td>
<td>
<p>A scalar parameter that controls the power of the weight function.</p>
</td></tr>
<tr><td><code id="wlr_weight_+3A_wmax">wmax</code></td>
<td>
<p>A scalar parameter of the cut-off weight for modest weighted log rank test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of weights.
</p>
<p>A vector of weights.
</p>
<p>A vector of weights.
</p>
<p>A vector of weights.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enroll_rate &lt;- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

gs_arm &lt;- gs_create_arm(enroll_rate, fail_rate, ratio = 1)
arm0 &lt;- gs_arm$arm0
arm1 &lt;- gs_arm$arm1

wlr_weight_fh(1:3, arm0, arm1, rho = 0, gamma = 0, tau = NULL)
enroll_rate &lt;- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

gs_arm &lt;- gs_create_arm(enroll_rate, fail_rate, ratio = 1)
arm0 &lt;- gs_arm$arm0
arm1 &lt;- gs_arm$arm1

wlr_weight_1(1:3, arm0, arm1)
enroll_rate &lt;- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

gs_arm &lt;- gs_create_arm(enroll_rate, fail_rate, ratio = 1)
arm0 &lt;- gs_arm$arm0
arm1 &lt;- gs_arm$arm1

wlr_weight_n(1:3, arm0, arm1, power = 2)
enroll_rate &lt;- define_enroll_rate(
  duration = c(2, 2, 10),
  rate = c(3, 6, 9)
)

fail_rate &lt;- define_fail_rate(
  duration = c(3, 100),
  fail_rate = log(2) / c(9, 18),
  hr = c(.9, .6),
  dropout_rate = .001
)

gs_arm &lt;- gs_create_arm(enroll_rate, fail_rate, ratio = 1)
arm0 &lt;- gs_arm$arm0
arm1 &lt;- gs_arm$arm1

wlr_weight_mb(1:3, arm0, arm1, tau = -1, wmax = 1.2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
