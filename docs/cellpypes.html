<!DOCTYPE html><html><head><title>Help for package cellpypes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cellpypes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#class_to_deseq2'><p>Create DESeq2 object for a given cell type</p></a></li>
<li><a href='#classify'><p>Classify cells on previously defined rules</p></a></li>
<li><a href='#evaluate_rule'><p>Evaluate rule to obtain positive / negative cells</p></a></li>
<li><a href='#feat'><p>Feature plots: Color gene expression in 2D embeddings</p></a></li>
<li><a href='#find_knn'><p>Find approximate k-nearest neighbors</p></a></li>
<li><a href='#is_classes'><p>Check if obj$classes looks as expected.</p>
is_class returns FALSE for example in these cases:
is_classes(NULL)
is_classes(data.frame())
is_classes(data.frame(class=c(&quot;T&quot;,&quot;T&quot;), parent=c(&quot;..root..&quot;,&quot;..root..&quot;)))</a></li>
<li><a href='#is_rules'><p>Check if obj$rules looks as expected.</p></a></li>
<li><a href='#knn_refine'><p>Refine cell type labels with knn classifier</p></a></li>
<li><a href='#plot_classes'><p>Call and visualize 'classify' function</p></a></li>
<li><a href='#plot_last'><p>Plot the last modified rule or class</p></a></li>
<li><a href='#pool_across_neighbors'><p>Sum up x across neighbors in a nearest neighbor graph.</p></a></li>
<li><a href='#pseudobulk'><p>Form pseudobulks from single cells.</p></a></li>
<li><a href='#pseudobulk_id'><p>Generate unique IDs to identify your pseudobulks.</p></a></li>
<li><a href='#pype_code_template'><p>Generate code template for cellpype rules</p></a></li>
<li><a href='#pype_from_seurat'><p>Convert Seurat to cellpypes object.</p></a></li>
<li><a href='#rule'><p>Add a cell type rule.</p></a></li>
<li><a href='#simulated_umis'><p>Simulated scRNAseq data</p></a></li>
<li><a href='#tree_ancestry'><p>Find parent, parent's parent and so on for a class using recursive programming</p></a></li>
<li><a href='#tree_descendants'><p>Find child, child's child and so on for class(es) using recursive programming</p></a></li>
<li><a href='#tree_leaf_nodes'><p>Finds leaf nodes, i.e. classes without children</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cell Type Pipes for Single-Cell RNA Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Annotate single-cell RNA sequencing data manually based on
    marker gene thresholds.
    Find cell type rules (gene+threshold) through exploration,
    use the popular piping operator '%&gt;%' to reconstruct complex
    cell type hierarchies.
    'cellpypes' models technical noise to find positive and negative cells for
    a given expression threshold and returns cell type labels or pseudobulks.
    Cite this package as Frauhammer (2022) &lt;<a href="https://doi.org/10.5281%2Fzenodo.6555728">doi:10.5281/zenodo.6555728</a>&gt; and
    visit <a href="https://github.com/FelixTheStudent/cellpypes">https://github.com/FelixTheStudent/cellpypes</a> for tutorials and newest
    features.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FelixTheStudent/cellpypes">https://github.com/FelixTheStudent/cellpypes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FelixTheStudent/cellpypes/issues">https://github.com/FelixTheStudent/cellpypes/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, Seurat, DESeq2,
RcppAnnoy, tibble, SeuratObject</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>scUtils, ggplot2, Matrix, rlang, viridis, cowplot, dplyr,
scales, methods, scattermore</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 02:26:57 UTC; felix</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Frauhammer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Frauhammer &lt;felixfrauhammer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 07:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='class_to_deseq2'>Create DESeq2 object for a given cell type</h2><span id='topic+class_to_deseq2'></span>

<h3>Description</h3>

<p>Create a DESeq2 data set (&lsquo;dds&rsquo; in the
<a href="https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html">DESeq2 vignette</a>)
for the specified class (cell type).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_to_deseq2(obj, meta_df, class, design = ~condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="class_to_deseq2_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="class_to_deseq2_+3A_meta_df">meta_df</code></td>
<td>
<p>Data frame where each column helps to identify a pseudobulk.
Typical columns of meta_df are for example patient, treatment and
cell type &ndash; anything
that uniquely identifies a replicate / batch / 10x run.
Each row in meta_df corresponds to a single cell in your raw count matrix.</p>
</td></tr>
<tr><td><code id="class_to_deseq2_+3A_class">class</code></td>
<td>
<p>The name of cellpypes class for which you want to test
for differential expression.</p>
</td></tr>
<tr><td><code id="class_to_deseq2_+3A_design">design</code></td>
<td>
<p>A formula based on columns in <code>meta_df</code>.
To test differential expression between two groups
in meta_df$condition, use formula <code>~ condition</code>.
More complex formulas (e.g. with interactions) are possible, for example
<code>~ genotype + treatment + genotype:treatment</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DESeq2 object (e.g. dds)
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("simulated_umis") 
# Meta data
ncells &lt;- ncol(simulated_umis$raw)
dummy_variable &lt;- function(x) factor(sample(x, ncells, replace=TRUE))
meta_data &lt;- data.frame(patient=dummy_variable(paste0("patient", 1:6)),
                        treatment=dummy_variable(c("control", "treated")))

obj &lt;- rule(simulated_umis, "T", "CD3E","&gt;", 1e-4)
 # &gt; 5 s in CRAN check
dds &lt;- class_to_deseq2(obj, meta_data, "T", ~ treatment)

</code></pre>

<hr>
<h2 id='classify'>Classify cells on previously defined rules</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>Classify cells on previously defined rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(
  obj,
  classes = NULL,
  knn_refine = 0,
  replace_overlap_with = "Unassigned",
  return_logical_matrix = FALSE,
  overdispersion = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="classify_+3A_classes">classes</code></td>
<td>
<p>Character vector with one or more class names.
If NULL (the default), plots finest available cell types
(all classes that are not parent of any other class).</p>
</td></tr>
<tr><td><code id="classify_+3A_knn_refine">knn_refine</code></td>
<td>
<p>Numeric between 0 and 1. If 0, do not refine labels
obtained from UMI count pooling.
If larger than 0 (recommended: 0.1), cellpypes will try to label
unassigned cells by majority vote, see section <strong>knn_refine</strong> below.</p>
</td></tr>
<tr><td><code id="classify_+3A_replace_overlap_with">replace_overlap_with</code></td>
<td>
<p>Character string, by default: <code>"Unassigned"</code>.
See section <strong>Handling overlap</strong>.</p>
</td></tr>
<tr><td><code id="classify_+3A_return_logical_matrix">return_logical_matrix</code></td>
<td>
<p>logical. If TRUE,
a logical matrix with
classes in columns and cells in rows is returned instead of resolving
overlaps with <code>replace_overlap_with</code>.
If a single class is supplied, the matrix has exactly one
column and the user can pipe it into &quot;drop&quot; to convert it to a vector.</p>
</td></tr>
<tr><td><code id="classify_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Defaults to 0.01, only change it if you know
what you are doing.
If set to 0, the NB simplifies to the Poisson distribution, and larger
values give more variance.
The 0.01 default value follows the recommendation by
Lause, Berens and Kobak (Genome Biology 2021) to use
<code>size=100</code> in <a href="stats.html#topic+pnbinom">pnbinom</a> for typical data sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor with cell type labels.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Handling overlap</h3>

<p>Overlap denotes all cells
for which rules from multiple classes apply, and these cells will be
labeled as <code>Unassigned</code> by default.
If you are in fact interested in where the overlap is,
set <code>return_logical_matrix</code>=TRUE and inspect the result.
Note that
it matters whether you call <code>classify("Tcell")</code> or
<code>classify(c("Tcell","Bcell")</code> – any existing overlap between T and B cells
is labelled as <code>Unassigned</code> in
this second call, but not in the first.
</p>
<p>Replacing overlap happens only between mutually
exclusive labels (such as Tcell and Bcell), but
not within a lineage.
To make an example, overlap is NOT replaced between child (PD1+Ttox) and
parent (Ttox) or any other ancestor (Tcell), but instead the
most detailed cell type (PD1+Ttox) is returned.
</p>
<p>All of the above is also true for <code>plot_classes</code>, as it wraps <code>classify</code>.
</p>


<h3>knn_refine</h3>

<p>With <code>knn_refine &gt; 0</code>, cellpypes refines cell type labels with a kNN classifier.
</p>
<p>By default, cellpypes only assigns cells to a class if all relevant rules
apply.
In other words, all marker gene UMI counts in the cell's neighborhood all have to
be clearly above/below their threshold.
Since UMI counts are sparse (even after neighbor pooling done by cellpypes),
this can leave many cells unassigned.
</p>
<p>It is reasonable to assume an unassigned cell is of the same cell type as the
majority of its nearest neighbors.
Therefore, cellpypes implements a kNN classifier to further refine labels
obtained by
manually thresholding UMI counts.
<code>knn_refine = 0.3</code> means a cell is assigned the class label held by
most of its neighbors unless no class gets more than 30 %.
If most neighbors are unassigned, the cell will also be set to &quot;Unassigned&quot;.
Choosing <code>knn_refine = 0.3</code> gives results reminiscent of clustering
(which assigns all cells),
while <code>knn_refine = 0.5</code> leaves cells 'in between' two similar
cell types unassigned.
</p>
<p>We recommend looking at <code>knn_refine =  0</code> first as it's faster and
more directly tied to marker gene expression.
If assigning all cells is desired, we recommend <code>knn_refine = 0.3</code> or lower,
while <code>knn_refine = 0.5</code> makes cell types more 'crisp' by setting cells
'in between' related subtypes to &quot;Unassigned&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>classify(rule(simulated_umis, "Tcell", "CD3E", "&gt;", 1))
</code></pre>

<hr>
<h2 id='evaluate_rule'>Evaluate rule to obtain positive / negative cells</h2><span id='topic+evaluate_rule'></span>

<h3>Description</h3>

<p>The rule is defined by feature, operator and threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_rule(obj, feature, operator, threshold, overdispersion = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_rule_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="evaluate_rule_+3A_feature">feature</code></td>
<td>
<p>Character scalar naming the gene you'd like to threshold.</p>
</td></tr>
<tr><td><code id="evaluate_rule_+3A_operator">operator</code></td>
<td>
<p>One of <code>c("&gt;","&lt;")</code>. Use &quot;&gt;&quot; for positive (CD3E+) and
&quot;&lt;&quot; for negative markers (MS4A1-).</p>
</td></tr>
<tr><td><code id="evaluate_rule_+3A_threshold">threshold</code></td>
<td>
<p>Numeric scalar with the expression threshold separating positive
from negative cells. Evaluate_rule expects a plain fraction, not CP10K
(while rule has the use_CP10K argument).</p>
</td></tr>
<tr><td><code id="evaluate_rule_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Defaults to 0.01, only change it if you know
what you are doing.
If set to 0, the NB simplifies to the Poisson distribution, and larger
values give more variance.
The 0.01 default value follows the recommendation by
Lause, Berens and Kobak (Genome Biology 2021) to use
<code>size=100</code> in <a href="stats.html#topic+pnbinom">pnbinom</a> for typical data sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector stating for each cell whether the rule is true.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>


<hr>
<h2 id='feat'>Feature plots: Color gene expression in 2D embeddings</h2><span id='topic+feat'></span>

<h3>Description</h3>

<p>Highlight gene expression in UMAP embeddings, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat(obj, features, fast = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="feat_+3A_features">features</code></td>
<td>
<p>A vector of genes (features) to colour by.</p>
</td></tr>
<tr><td><code id="feat_+3A_fast">fast</code></td>
<td>
<p>Set this to TRUE if you want fast plotting in spite of many cells
(using the scattermore package). If NULL (default), cellpypes decides
automatically and fast plotting is done for more than 10k cells, if FALSE
it always uses <code>geom_point</code>.</p>
</td></tr>
<tr><td><code id="feat_+3A_verbose">verbose</code></td>
<td>
<p>feat ignores gene names not present in your object and
warns you about them by default. <code>verbose</code>=FALSE will suppress the warning
(not recommended in interactive use).</p>
</td></tr>
<tr><td><code id="feat_+3A_...">...</code></td>
<td>
<p>Arguments passed to cowplot's <a href="cowplot.html#topic+plot_grid">plot_grid</a> function,
for example ncol or rel_widths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object (assembled by cowplot).
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>feat(simulated_umis, "CD3E")
</code></pre>

<hr>
<h2 id='find_knn'>Find approximate k-nearest neighbors</h2><span id='topic+find_knn'></span>

<h3>Description</h3>

<p>Implements RcppAnnoy's approximate nearest neighbor search
(much faster than precise neighbors).
Random search is made reproducible using <code>set.seed(seed)</code>.
Hint: If you pass <code>find_knn</code>'s output directly to <code>uwot::umap</code> via the
<code>nn_method</code> argument, make sure to set <code>umap</code>'s argument <code>n_sgd_threads</code>
to &lt;=1 to ensure the UMAP embedding is reproducible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_knn(featureMatrix, k = 50, n_trees = 50, seed = 42)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_knn_+3A_featurematrix">featureMatrix</code></td>
<td>
<p>Numeric matrix with features in rows, cells in columns.
Rows could be normalized genes or latent dimensions such as principal
components.</p>
</td></tr>
<tr><td><code id="find_knn_+3A_k">k</code></td>
<td>
<p>Number of neighbors to find.</p>
</td></tr>
<tr><td><code id="find_knn_+3A_n_trees">n_trees</code></td>
<td>
<p>RccpAnnoy builds a forest  of <code>n_trees</code> trees.
More trees gives higher precision when querying. Default: 50.</p>
</td></tr>
<tr><td><code id="find_knn_+3A_seed">seed</code></td>
<td>
<p>Random seed for neighbor search, default: 42.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two slots:
</p>

<ul>
<li> <p><code>idx</code> A NxK matrix (N cells, K neighbors) containing the integer
indexes of the approximate nearest neighbors in featureMatrix.
Each cell is considered to be its own nearest neighbor, next to
K-1 other neighbors.
</p>
</li>
<li> <p><code>dist</code> A NxK matrix containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>Inspired by <code>uwot::umap</code>'s return value when setting <code>ret_nn=TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Imagine we have 30 cells and 100 features:
 fmat &lt;- matrix(rnorm(3000), ncol=30)
 nn &lt;- find_knn(fmat,k=15)
 # nn$idx has 30 rows and 15 columns.
</code></pre>

<hr>
<h2 id='is_classes'>Check if obj$classes looks as expected.
is_class returns FALSE for example in these cases:
is_classes(NULL)
is_classes(data.frame())
is_classes(data.frame(class=c(&quot;T&quot;,&quot;T&quot;), parent=c(&quot;..root..&quot;,&quot;..root..&quot;)))</h2><span id='topic+is_classes'></span>

<h3>Description</h3>

<p>Check if obj$classes looks as expected.
is_class returns FALSE for example in these cases:
is_classes(NULL)
is_classes(data.frame())
is_classes(data.frame(class=c(&quot;T&quot;,&quot;T&quot;), parent=c(&quot;..root..&quot;,&quot;..root..&quot;)))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_classes(classes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_classes_+3A_classes">classes</code></td>
<td>
<p>The obj$classes you want to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar.
</p>

<hr>
<h2 id='is_rules'>Check if obj$rules looks as expected.</h2><span id='topic+is_rules'></span>

<h3>Description</h3>

<p>Check if obj$rules looks as expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rules(rules)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rules_+3A_rules">rules</code></td>
<td>
<p>The obj$rules slot of a cellpypes object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>

<hr>
<h2 id='knn_refine'>Refine cell type labels with knn classifier</h2><span id='topic+knn_refine'></span>

<h3>Description</h3>

<p>Assigns the label that most neighbors have, given it is more than
<code>min_knn_prob</code>.
I've found empirically on the MALT data that <code>min_knn_prob=0.5</code> gives
good results, whether you classify the entire data set or just a single
cell type.
It simply excludes some of the cells that have more than 2 cell types in their
neighborhood and none is much stronger than the others,
so this is a reasonable, conservative filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_refine(labels, neighbors, min_knn_prob = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_refine_+3A_labels">labels</code></td>
<td>
<p>Cell type labels as character or factor.</p>
</td></tr>
<tr><td><code id="knn_refine_+3A_neighbors">neighbors</code></td>
<td>
<p>Neighbor graph, pass <code>obj$neighbors</code>.</p>
</td></tr>
<tr><td><code id="knn_refine_+3A_min_knn_prob">min_knn_prob</code></td>
<td>
<p>Value between 0 and 1, defaults to 0.5.
If the 'winning label' is below this proportion of kNN that have it,
knn_refine will return &quot;Unassigned&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with refined labels.
</p>

<hr>
<h2 id='plot_classes'>Call and visualize 'classify' function</h2><span id='topic+plot_classes'></span>

<h3>Description</h3>

<p>Call and visualize 'classify' function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_classes(
  obj,
  classes = NULL,
  knn_refine = 0,
  replace_overlap_with = "Unassigned",
  return_logical_matrix = FALSE,
  fast = NULL,
  point_size = 0.4,
  point_size_legend = 2,
  base_size = 15,
  overdispersion = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_classes_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_classes">classes</code></td>
<td>
<p>Character vector with one or more class names.
If NULL (the default), plots finest available cell types
(all classes that are not parent of any other class).</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_knn_refine">knn_refine</code></td>
<td>
<p>Numeric between 0 and 1. If 0, do not refine labels
obtained from UMI count pooling.
If larger than 0 (recommended: 0.1), cellpypes will try to label
unassigned cells by majority vote, see section <strong>knn_refine</strong> below.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_replace_overlap_with">replace_overlap_with</code></td>
<td>
<p>Character string, by default: <code>"Unassigned"</code>.
See section <strong>Handling overlap</strong>.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_return_logical_matrix">return_logical_matrix</code></td>
<td>
<p>logical. If TRUE,
a logical matrix with
classes in columns and cells in rows is returned instead of resolving
overlaps with <code>replace_overlap_with</code>.
If a single class is supplied, the matrix has exactly one
column and the user can pipe it into &quot;drop&quot; to convert it to a vector.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_fast">fast</code></td>
<td>
<p>Set this to TRUE if you want fast plotting in spite of many cells
(using the scattermore package). If NULL (default), cellpypes decides
automatically and fast plotting is done for more than 10k cells, if FALSE
it always uses <code>geom_point</code>.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_point_size">point_size</code></td>
<td>
<p>Dot size used by <a href="ggplot2.html#topic+geom_point">geom_point</a>.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_point_size_legend">point_size_legend</code></td>
<td>
<p>Dot size displayed in legend.
Legend colors are easier to read with larger points.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_base_size">base_size</code></td>
<td>
<p>The base_size of <a href="ggplot2.html#topic+theme_bw">theme_bw</a>, i.e.
how large text is displayed. Default: 15.</p>
</td></tr>
<tr><td><code id="plot_classes_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Defaults to 0.01, only change it if you know
what you are doing.
If set to 0, the NB simplifies to the Poisson distribution, and larger
values give more variance.
The 0.01 default value follows the recommendation by
Lause, Berens and Kobak (Genome Biology 2021) to use
<code>size=100</code> in <a href="stats.html#topic+pnbinom">pnbinom</a> for typical data sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Handling overlap</h3>

<p>Overlap denotes all cells
for which rules from multiple classes apply, and these cells will be
labeled as <code>Unassigned</code> by default.
If you are in fact interested in where the overlap is,
set <code>return_logical_matrix</code>=TRUE and inspect the result.
Note that
it matters whether you call <code>classify("Tcell")</code> or
<code>classify(c("Tcell","Bcell")</code> – any existing overlap between T and B cells
is labelled as <code>Unassigned</code> in
this second call, but not in the first.
</p>
<p>Replacing overlap happens only between mutually
exclusive labels (such as Tcell and Bcell), but
not within a lineage.
To make an example, overlap is NOT replaced between child (PD1+Ttox) and
parent (Ttox) or any other ancestor (Tcell), but instead the
most detailed cell type (PD1+Ttox) is returned.
</p>
<p>All of the above is also true for <code>plot_classes</code>, as it wraps <code>classify</code>.
</p>


<h3>knn_refine</h3>

<p>With <code>knn_refine &gt; 0</code>, cellpypes refines cell type labels with a kNN classifier.
</p>
<p>By default, cellpypes only assigns cells to a class if all relevant rules
apply.
In other words, all marker gene UMI counts in the cell's neighborhood all have to
be clearly above/below their threshold.
Since UMI counts are sparse (even after neighbor pooling done by cellpypes),
this can leave many cells unassigned.
</p>
<p>It is reasonable to assume an unassigned cell is of the same cell type as the
majority of its nearest neighbors.
Therefore, cellpypes implements a kNN classifier to further refine labels
obtained by
manually thresholding UMI counts.
<code>knn_refine = 0.3</code> means a cell is assigned the class label held by
most of its neighbors unless no class gets more than 30 %.
If most neighbors are unassigned, the cell will also be set to &quot;Unassigned&quot;.
Choosing <code>knn_refine = 0.3</code> gives results reminiscent of clustering
(which assigns all cells),
while <code>knn_refine = 0.5</code> leaves cells 'in between' two similar
cell types unassigned.
</p>
<p>We recommend looking at <code>knn_refine =  0</code> first as it's faster and
more directly tied to marker gene expression.
If assigning all cells is desired, we recommend <code>knn_refine = 0.3</code> or lower,
while <code>knn_refine = 0.5</code> makes cell types more 'crisp' by setting cells
'in between' related subtypes to &quot;Unassigned&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_classes(rule(simulated_umis, "T", "CD3E","&gt;", 1))
</code></pre>

<hr>
<h2 id='plot_last'>Plot the last modified rule or class</h2><span id='topic+plot_last'></span>

<h3>Description</h3>

<p>Plot the last modified rule or class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_last(
  obj,
  show_feat = TRUE,
  what = "rule",
  fast = NULL,
  legend_rel_width = 0.3,
  overdispersion = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_last_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="plot_last_+3A_show_feat">show_feat</code></td>
<td>
<p>If TRUE (default), a second panel shows the feature plot of
the relevant gene.</p>
</td></tr>
<tr><td><code id="plot_last_+3A_what">what</code></td>
<td>
<p>Either &quot;rule&quot; or &quot;class&quot;.</p>
</td></tr>
<tr><td><code id="plot_last_+3A_fast">fast</code></td>
<td>
<p>Set this to TRUE if you want fast plotting in spite of many cells
(using the scattermore package). If NULL (default), cellpypes decides
automatically and fast plotting is done for more than 10k cells, if FALSE
it always uses <code>geom_point</code>.</p>
</td></tr>
<tr><td><code id="plot_last_+3A_legend_rel_width">legend_rel_width</code></td>
<td>
<p>Relative width compared to the other two plots
(only relevant if <code>show_feat=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot_last_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Defaults to 0.01, only change if you know what you
are doing. See further <a href="#topic+classify">classify</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object with the plot.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot_last(rule(simulated_umis, "T", "CD3E","&gt;", 1))
</code></pre>

<hr>
<h2 id='pool_across_neighbors'>Sum up x across neighbors in a nearest neighbor graph.</h2><span id='topic+pool_across_neighbors'></span>

<h3>Description</h3>

<p>Neighbor pooling means that x is summed across
the nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_across_neighbors(x, neighbors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_across_neighbors_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="pool_across_neighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>Nearest neighbor graph provided as NxK index matrix
(N observations, K neighbors) or NxN adjacency matrix.
Index matrices can be obtained with <a href="#topic+find_knn">find_knn</a>
(specifically the slot <code>idx</code> in the list it returns).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# simulate 30 cells without biological signal:
dummy_dat &lt;- matrix(rpois(3000, .1), ncol=30) 
# find 15 approximate nearest neighbors 
neighbors &lt;- find_knn(dummy_dat, k = 15) 
# pool gene1 counts across neighbors:
neighbor_sum_gene1 &lt;- pool_across_neighbors(dummy_dat[1,], neighbors$idx)

</code></pre>

<hr>
<h2 id='pseudobulk'>Form pseudobulks from single cells.</h2><span id='topic+pseudobulk'></span>

<h3>Description</h3>

<p>Sum up cells in count matrix <code>raw</code> for bulk RNA methods such as
DESeq2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudobulk(raw, pseudobulk_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudobulk_+3A_raw">raw</code></td>
<td>
<p>A matrix with raw UMI counts, cells in columns.</p>
</td></tr>
<tr><td><code id="pseudobulk_+3A_pseudobulk_id">pseudobulk_id</code></td>
<td>
<p>A factor that identifies which cells should go to
which pseudobulk. Generate pseudobulk_ids with the <a href="#topic+pseudobulk_id">pseudobulk_id</a> function!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column is a pseudobulk and each row a gene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create pseudobulk counts and coldata for DESeq2: 
coldata &lt;- data.frame(
  celltype = rep(c("X+Y-", "X+Y+", "X-Y+", "X-Y-"),
                 each = nrow(simulated_umis$embed)/4), # 4 cell types
  patient  = c("3", "500.", "*5", "/")
)
coldata$pseudobulk_id &lt;- pseudobulk_id(coldata)
counts &lt;- pseudobulk(simulated_umis$raw, coldata$pseudobulk_id)
# Use counts/coldata as input for DESeqDataSetFromMatrix (DESeq2).

</code></pre>

<hr>
<h2 id='pseudobulk_id'>Generate unique IDs to identify your pseudobulks.</h2><span id='topic+pseudobulk_id'></span>

<h3>Description</h3>

<p>This function generates unique IDs that are valid colnames as well.
Use these IDs in function pseudobulk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudobulk_id(factor_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudobulk_id_+3A_factor_df">factor_df</code></td>
<td>
<p>Data frame where each column helps to identify a pseudobulk.
Each row in factor_df corresponds to a single cell in your raw count matrix.
Typical columns of factor_df are for example patient, treatment and cell type &ndash; anything
that uniquely identifies a replicate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wraps <a href="base.html#topic+make.names">make.names</a> to generate syntactically valid IDs.
Use these IDs in the <a href="#topic+pseudobulk">pseudobulk</a> function.
Note that this function combines all columns in factor_df, so only include
the columns that uniquely identify replicates.
Cells from the same experimental unit
</p>


<h3>Value</h3>

<p>Factor with syntactically valid and unique IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create pseudobulk counts and coldata for DESeq2: 
coldata &lt;- data.frame(
  celltype = rep(c("X+Y-", "X+Y+", "X-Y+", "X-Y-"),
                 each = nrow(simulated_umis$embed)/4), # 4 cell types
  patient  = c("3", "500.", "*5", "/")
)
coldata$pseudobulk_id &lt;- pseudobulk_id(coldata)
counts &lt;- pseudobulk(simulated_umis$raw, coldata$pseudobulk_id)
# Use counts/coldata as input for DESeqDataSetFromMatrix (DESeq2).
</code></pre>

<hr>
<h2 id='pype_code_template'>Generate code template for cellpype rules</h2><span id='topic+pype_code_template'></span>

<h3>Description</h3>

<p>This function <a href="#topic+rule">rule</a> code snippet with neat
text alignment to the console.
Paste this into your script and start changing the rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pype_code_template(n_rules = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pype_code_template_+3A_n_rules">n_rules</code></td>
<td>
<p>Number of lines (rules) to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints rules to the consoles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pype_code_template()
</code></pre>

<hr>
<h2 id='pype_from_seurat'>Convert Seurat to cellpypes object.</h2><span id='topic+pype_from_seurat'></span>

<h3>Description</h3>

<p>Start cellpyping a Seurat object.
This function saves the user from building his own cellpypes object,
which is done with <code>list(umi, neighbors,embed, totalUMI)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pype_from_seurat(seurat, graph_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pype_from_seurat_+3A_seurat">seurat</code></td>
<td>
<p>A Seurat object.</p>
</td></tr>
<tr><td><code id="pype_from_seurat_+3A_graph_name">graph_name</code></td>
<td>
<p>Supply one of the graphs. To see options, type
<code>names(seurat@graphs)</code>. If left empty (<code>NULL</code>, the default),
<code>pype_from_seurat</code> will try to guess the correct name for you.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cellpypes object.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>


<hr>
<h2 id='rule'>Add a cell type rule.</h2><span id='topic+rule'></span>

<h3>Description</h3>

<p>This is the heart of cellpypes and best used by piping from
one rule into the next
with <code style="white-space: pre;">&#8288;magrittr::%&gt;%&#8288;</code>. Check out examples at
<a href="https://github.com/FelixTheStudent/cellpypes">gitHub</a>)!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule(
  obj,
  class,
  feature,
  operator = "&gt;",
  threshold,
  parent = NULL,
  use_CP10K = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rule_+3A_obj">obj</code></td>
<td>
<p>A cellpypes object, see section <strong>cellpypes Objects</strong> below.</p>
</td></tr>
<tr><td><code id="rule_+3A_class">class</code></td>
<td>
<p>Character scalar with the class name. Typically,
cellpypes classes
are literature cell types (&quot;T cell&quot;) or any subpopulation of interest
(&quot;CD3E+TNF+LAG3-&quot;).</p>
</td></tr>
<tr><td><code id="rule_+3A_feature">feature</code></td>
<td>
<p>Character scalar naming the gene you'd like to threshold.
Must be a row name in <code>obj$raw</code>.</p>
</td></tr>
<tr><td><code id="rule_+3A_operator">operator</code></td>
<td>
<p>One of <code>c("&gt;","&lt;")</code>. Use &quot;&gt;&quot; for positive (CD3E+) and
&quot;&lt;&quot; for negative markers (MS4A1-).</p>
</td></tr>
<tr><td><code id="rule_+3A_threshold">threshold</code></td>
<td>
<p>Numeric scalar with the expression threshold separating positive
from negative cells.
Experiment with this value, until expression and selected cells agree well
in UMAP (see examples on
<a href="https://github.com/FelixTheStudent/cellpypes">gitHub</a>).</p>
</td></tr>
<tr><td><code id="rule_+3A_parent">parent</code></td>
<td>
<p>Character scalar with the parent class
(e.g. &quot;T cell&quot; for &quot;Cytotoxic T cells&quot;).
Only has to be specified once per class (else most recent one is taken),
and defaults to
&quot;..root..&quot; if NULL is passed in all rules.</p>
</td></tr>
<tr><td><code id="rule_+3A_use_cp10k">use_CP10K</code></td>
<td>
<p>If TRUE, <code>threshold</code> is taken to be
counts per 10 thousand UMI counts, a measure for RNA molecule fractions.
We recommend CP10K for human intuition (1 CP10K is roughly 1 UMI per cell),
but the results are the exact same whether you use
<code>threshold=1,CP10K=TRUE</code> or
<code>threshold=1e-4,CP10K=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code>rule</code> is computationally cheap because it only stores
the cell type rule while all computations
happen in <a href="#topic+classify">classify</a>.
If you have classes with multiple rules, the most recent <code>parent</code> and
<code>feature</code>-<code>threshold</code> combination counts.
It is ok to mix rules with and without <code>use_CP10K=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>obj</code> is returned, but with the rule and class stored in
<code>obj$rules</code> and <code>obj$classes</code>, to be used by
<a href="#topic+classify">classify</a>.
</p>


<h3>cellpypes Objects</h3>

<p>A cellpypes object is a <a href="base.html#topic+list">list</a> with four slots:
</p>

<dl>
<dt><code>raw </code></dt><dd><p>(sparse) matrix with genes in rows, cells in columns</p>
</dd>
<dt><code>totalUMI </code></dt><dd><p>the colSums of obj$raw</p>
</dd>
<dt><code>embed </code></dt><dd><p>two-dimensional embedding of the cells, provided as data.frame
or tibble with two columns and one row per cell.</p>
</dd>
<dt><code>neighbors </code></dt><dd><p>index matrix with one row per cell and k columns, where
k is the number of nearest neighbors (we recommend 15&lt;k&lt;100, e.g. k=50).
Here are two ways to get the neighbors index matrix:
</p>

<ul>
<li><p> Use <code>find_knn(featureMatrix)$idx</code>, where featureMatrix could be
principal components, latent variables or normalized genes (features in
rows, cells in columns).
</p>
</li>
<li><p> use <code>as(seurat@graphs[["RNA_nn"]], "dgCMatrix")&gt; .1</code> to extract
the kNN
graph computed on RNA. The <code>&gt; .1</code> ensures this also works with RNA_snn,
wknn/wsnn or any other
available graph – check with <code>names(seurat@graphs)</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>See Also</h3>

<p>To have nicely formatted code in the end, copy the output of
<code>pype_code_template()</code> to your script and start editing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># T cells are CD3E+:
obj &lt;- rule(simulated_umis, "T", "CD3E", "&gt;", .1)
# T cells are MS4A1-:
obj &lt;- rule(obj, "T", "MS4A1", "&lt;", 1)
# Tregs are a subset of T cells:
obj &lt;- rule(obj, "Treg", "FOXP3", "&gt;", .1, parent="T") 

</code></pre>

<hr>
<h2 id='simulated_umis'>Simulated scRNAseq data</h2><span id='topic+simulated_umis'></span>

<h3>Description</h3>

<p>This data serves to develop cellpypes and to illustrate its functionality.
I made it up entirely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated_umis
</code></pre>


<h3>Format</h3>

<p>A list with 4 entries:
</p>

<dl>
<dt>raw</dt><dd><p>Raw (unnormalized) UMI counts for a handful of genes, last row are totalUMI. </p>
</dd>
<dt>neighbors</dt><dd><p>Indices of each cell's 50 nearest neighbors.</p>
</dd>
<dt>embed</dt><dd><p>Simulated UMAP embedding.</p>
</dd>
<dt>celltype</dt><dd><p>Cell type label that I used to simulate the data.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Very simple simulation (c.f. data-raw/simulated_umis.R in source code).
</p>

<hr>
<h2 id='tree_ancestry'>Find parent, parent's parent and so on for a class using recursive programming</h2><span id='topic+tree_ancestry'></span>

<h3>Description</h3>

<p>Find parent, parent's parent and so on for a class using recursive programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_ancestry(classes, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_ancestry_+3A_classes">classes</code></td>
<td>
<p>The class definitions of a cellpypes object, i.e. obj$classes.</p>
</td></tr>
<tr><td><code id="tree_ancestry_+3A_class">class</code></td>
<td>
<p>A character vector of length one with the class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the ancestry of a class.
</p>

<hr>
<h2 id='tree_descendants'>Find child, child's child and so on for class(es) using recursive programming</h2><span id='topic+tree_descendants'></span>

<h3>Description</h3>

<p>Find child, child's child and so on for class(es) using recursive programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_descendants(classes, class, leafs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_descendants_+3A_classes">classes</code></td>
<td>
<p>The class definitions of a cellpypes object, i.e. obj$classes.</p>
</td></tr>
<tr><td><code id="tree_descendants_+3A_class">class</code></td>
<td>
<p>A character vector with one or multiple classes.</p>
</td></tr>
<tr><td><code id="tree_descendants_+3A_leafs">leafs</code></td>
<td>
<p>Has to be the output of tree_leaf_nodes(classes). It's passed
as argument so that tree_leaf_nodes is not executed in each recursion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the descendants of a class.
</p>

<hr>
<h2 id='tree_leaf_nodes'>Finds leaf nodes, i.e. classes without children</h2><span id='topic+tree_leaf_nodes'></span>

<h3>Description</h3>

<p>Finds leaf nodes, i.e. classes without children
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_leaf_nodes(classes, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_leaf_nodes_+3A_classes">classes</code></td>
<td>
<p>Put obj$classes here, i.e. a tree of class definitions
created with the rule function.</p>
</td></tr>
<tr><td><code id="tree_leaf_nodes_+3A_invert">invert</code></td>
<td>
<p>If TRUE, return classes that are NOT leafs instead of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the tree's leafs.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
