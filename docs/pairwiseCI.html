<!DOCTYPE html><html lang="en"><head><title>Help for package pairwiseCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pairwiseCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pairwiseCI-package'>
<p>Wrapper functions for two-sample confidence intervals and tests.</p></a></li>
<li><a href='#as.data.frame.pairwiseCI'><p>Coercing pairwiseCI objects to data.frames</p></a></li>
<li><a href='#as.data.frame.pairwiseMEP'><p>Coerce pairwiseMEP objects to data.frames</p></a></li>
<li><a href='#behenic'><p>Measurements of behenic acid in two samples</p></a></li>
<li><a href='#cabbage'><p>Yield of cabbage in one-factorial field trial</p></a></li>
<li><a href='#MOVERR'>
<p>MOVER-R method by Donner and Zhou (2012)</p></a></li>
<li><a href='#np.re'>
<p>Nonparametric test and confidence interval based on relative effects</p></a></li>
<li><a href='#Oats'><p>The Oats data set</p></a></li>
<li><a href='#overdispersed.binomial.ratio'><p>Confidence intervals for risk ratios of overdispersed binomial data</p></a></li>
<li><a href='#pairwiseCI'><p>Wrapper function for two-sample confidence intervals</p></a></li>
<li><a href='#pairwiseCIInt'><p>Internal functions for pairwiseCI</p></a></li>
<li><a href='#pairwiseCImethodsCont'><p>Confidence intervals for two sample comparisons of continuous data</p></a></li>
<li><a href='#pairwiseCImethodsCount'><p>Confidence intervals for two sample comparisons of count data</p></a></li>
<li><a href='#pairwiseCImethodsProp'><p>Confidence intervals for two sample comparisons of binomial proportions</p></a></li>
<li><a href='#pairwiseMEP'><p>Wrapper to compute confidence intervals for multiple endpoints</p></a></li>
<li><a href='#pairwiseTest'><p>Wrapper to calculate unadjusted p-values for pairwise comparisons</p></a></li>
<li><a href='#pairwiseTestInt'><p>Internal functions for pairwiseTest</p></a></li>
<li><a href='#plot.pairwiseCI'><p>Plotting the output of pairwiseCI</p></a></li>
<li><a href='#plotCI.methods'><p> Plot confidence intervals</p></a></li>
<li><a href='#print.pairwiseCI'><p> Print function for &quot;pairwiseCI&quot;</p></a></li>
<li><a href='#print.pairwiseTest'><p> Print function for &quot;pairwiseTest&quot;</p></a></li>
<li><a href='#print.summary.pairwiseCI'><p> Print function for &quot;summary.pairwiseCI&quot;</p></a></li>
<li><a href='#print.summary.pairwiseTest'><p> Print function for &quot;summary.pairwiseTest&quot;</p></a></li>
<li><a href='#profileDG'><p> Construct a (quasi-) likelihood-profile</p></a></li>
<li><a href='#Prop.test'><p> Wrapper to prop.test(stats)</p></a></li>
<li><a href='#QBmover'><p>Confidence intervals for ratios of proportions based on the quasibinomial assumption</p></a></li>
<li><a href='#repellent'><p> Repellent effect of sulphur in eight concentrations</p></a></li>
<li><a href='#rooting'><p>Rooting (success/failure) of plants in a 3-factorial field trial</p></a></li>
<li><a href='#sodium'><p>Sodium contents in transgenic and isogenic corn</p></a></li>
<li><a href='#summary.pairwiseCI'><p> Summary function for pairwiseCI</p></a></li>
<li><a href='#summary.pairwiseTest'><p> Summary function for &quot;pairwiseTest&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Confidence Intervals for Two Sample Comparisons</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-27</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-03-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Frank Schaarschmidt [aut, cre],
  Daniel Gerhard [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank Schaarschmidt &lt;schaarschmidt@biostat.uni-hannover.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>MCPAN, coin(&ge; 1.3-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, boot, MASS, mcprofile</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation of the parametric, nonparametric confidence intervals
 for the difference or ratio of location parameters, nonparametric confidence interval
 for the Behrens-Fisher problem and for the difference, ratio and odds-ratio of binomial
 proportions for comparison of independent samples. Common wrapper functions to split 
 data sets and apply confidence intervals or tests to these subsets.
 A by-statement allows calculation of CI separately for the levels of further factors. 
 CI are not adjusted for multiplicity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-11 07:01:02 UTC; Schaarschmidt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-11 11:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='pairwiseCI-package'>
Wrapper functions for two-sample confidence intervals and tests.
</h2><span id='topic+pairwiseCI-package'></span>

<h3>Description</h3>

<p>A collection of wrapper functions for simple evaluation of factorial trials.
The function pairwiseCI allows to calculate 2-sample confidence intervals for all-pairs and many-to-one comparisons
between levels of a factor. Intervals are NOT adjusted for multiple hypothesis testing per default.
The function pairwiseTest allows to calculate p-values of two-sample tests for all-pairs and many-to-one comparisons
between levels of a factor. P-values are NOT adjusted for multiple hypothesis testing per default.
Both function allow splitting of the data according to additional factors.
Intervals can be plotted, summary.pairwiseTest allows to use the p-value adjustments as implemented in p.adjust(stats).
Different test and interval methods (parametric, nonparametric, bootstrap for robust estimators of location, binomial proportions)
are implemented in a unified user level function.
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt and Daniel Gerhard, for the Institute of Biostatistics, Leibniz Universitaet Hannover
Maintainer: Frank Schaarschmidt &lt;schaarschmidt@biostat.uni-hannover.de&gt;
</p>


<h3>See Also</h3>

<p>Multiple comparisons for the differences of means:<span class="pkg">multcomp</span>
</p>
<p><code>pairwise.t.test(stats)</code>
<code>pairwise.prop.test(stats)</code>
<code>p.adjust(stats)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# some examples:
# In many cases the shown examples might not make sense,
# but display how the functions can be used.

data(Oats)
Oats

# # all pairwise comparisons,
# separately for each level of nitro:

apc &lt;- pairwiseCI(yield ~ Variety, data=Oats,
 by="nitro", method="Param.diff")

apc

# Intervals can be plotted:

plot(apc)

# See ?pairwiseCI or ?pairwiseCImethodsCont
# for further options for intervals of 2 samples
# of continuous data.


# Or a test

apcTest &lt;- pairwiseTest(yield ~ Variety, data=Oats,
 by="nitro", method="t.test")

# with holm-adjusted p-values:
summary(apcTest, p.adjust.method="holm")



# # If only comparisons to one control would be of interest:
# many to one comparisons, with variety Marvellous as control,
# for each level of nitro separately:

m21 &lt;- pairwiseCI(yield ~ Variety, data=Oats,
 by="nitro", method="Param.diff", control="Marvellous")


##############################################
# # Proportions: another structure of the data is needed.
# Currently the data.frame data must contain two columns,
# specifying the number of successes and failures on each 
# unit.

# The rooting example:
# Calculate confidence intervals for the 
# difference of proportions between the 3 doses of IBA,
# separately for 4 combinations of "Age" and "Position".
# Note: we pool over Rep in that way. Whether this makes
# sense or not, is decision of the user.

data(rooting)
rooting

# Confidence intervals for the risk difference

aprootsRD&lt;-pairwiseCI(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.diff")

# See ?pairwiseCIProp for further options to compare proportions

# Or a test:

aprootsTest&lt;-pairwiseTest(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.test")
aprootsTest

summary(aprootsTest, p.adjust.method="holm")

</code></pre>

<hr>
<h2 id='as.data.frame.pairwiseCI'>Coercing pairwiseCI objects to data.frames</h2><span id='topic+as.data.frame.pairwiseCI'></span>

<h3>Description</h3>

<p>Creates a data.frame from the output of pairwiseCI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseCI'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.pairwiseCI_+3A_x">x</code></td>
<td>
<p> an object of class &ldquo;pairwiseCI&rdquo; </p>
</td></tr>
<tr><td><code id="as.data.frame.pairwiseCI_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p> containing the estimates</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>containing the lower bounds</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>containing the upper bounds</p>
</td></tr>
<tr><td><code>comparison</code></td>
<td>
<p>containing character strings, specifying which levels have been compared</p>
</td></tr>
</table>
<p>and if the argument by has been specified, 
</p>
<table role = "presentation">
<tr><td><code>by</code></td>
<td>
<p>containing the levels by which the original data set has been split</p>
</td></tr>
</table>
<p>and the conf.level and a character string naming the used method.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pairwiseCI">pairwiseCI</a></code>, <code><a href="#topic+summary.pairwiseTest">summary.pairwiseTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(repellent)

out2&lt;-pairwiseCI(decrease~treatment, data=repellent, control="H",
 alternative="two.sided", method="Param.diff")

out2

as.data.frame(out2)



</code></pre>

<hr>
<h2 id='as.data.frame.pairwiseMEP'>Coerce pairwiseMEP objects to data.frames</h2><span id='topic+as.data.frame.pairwiseMEP'></span>

<h3>Description</h3>

<p>Coerces the output of the function pairwiseMEP to a data.frame. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseMEP'
as.data.frame(x, row.names = NULL,
 optional = FALSE, whichep = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.pairwiseMEP_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;pairwiseMEP&rdquo; as can be obtained by calling <code><a href="#topic+pairwiseMEP">pairwiseMEP</a></code> </p>
</td></tr>
<tr><td><code id="as.data.frame.pairwiseMEP_+3A_row.names">row.names</code></td>
<td>
<p>as in <code>as.data.frame</code></p>
</td></tr>
<tr><td><code id="as.data.frame.pairwiseMEP_+3A_optional">optional</code></td>
<td>
<p>as in <code>as.data.frame</code></p>
</td></tr>
<tr><td><code id="as.data.frame.pairwiseMEP_+3A_whichep">whichep</code></td>
<td>
<p> a vector of integers or character strings, indexing which endpoints (which response variables)
from object <code>x</code> shall be coerced to a data.frame; if omitted (default), all endpoints are coerced to a data.frame </p>
</td></tr>
<tr><td><code id="as.data.frame.pairwiseMEP_+3A_...">...</code></td>
<td>
<p> Further arguments to be passed to <code>as.data.frame</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p> numeric, the point estimates </p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p> numeric, the lower confidence limits  </p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p> numeric, the upper confidence limits </p>
</td></tr>
<tr><td><code>comparison</code></td>
<td>
<p> character, the name of the groupwise comparison </p>
</td></tr>
<tr><td><code>by</code></td>
<td>
<p> optional, character, the name of subset of the original data.frame</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> character, the name of the response variable </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> character, the name of the method used for calculation of the lower and upper limits, see <code><a href="#topic+pairwiseMEP">pairwiseMEP</a></code> </p>
</td></tr>
</table>

<hr>
<h2 id='behenic'>Measurements of behenic acid in two samples</h2><span id='topic+behenic'></span>

<h3>Description</h3>

<p>Observations below a detection limit: in field trials with transgenic and isogenic corn
varieties the behenic acid content was measured. Objective is to prove equivalence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(behenic)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 2 variables.
</p>

<dl>
<dt><code>Treatment</code></dt><dd><p>a factor with 2 levels: <code>transgenic</code> <code>xisogenic</code></p>
</dd>
<dt><code>Behenic</code></dt><dd><p>a numeric vector giving concentration of behenic acid, where 0.002 is the detection limit</p>
</dd>
</dl>



<h3>Source</h3>

<p><em>Oberdoerfer, R.B.</em> Example dataset from composition analyses of genetically modified oilseed rape seeds. 2003; BCS GmbH.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(behenic)
boxplot(Behenic~Treatment, data= behenic)
</code></pre>

<hr>
<h2 id='cabbage'>Yield of cabbage in one-factorial field trial</h2><span id='topic+cabbage'></span>

<h3>Description</h3>

<p>Cabbage yield in dependence of four doses of fertilizer. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cabbage)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 2 variables.
</p>

<dl>
<dt><code>Fert</code></dt><dd><p>a factor with levels <code>D1</code> <code>D2</code> <code>D3</code> <code>D4</code>, the different doses of fertilizer</p>
</dd>
<dt><code>yield</code></dt><dd><p>a numeric vector, cabbage yield</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(cabbage)
boxplot(yield~Fert, data=cabbage)
</code></pre>

<hr>
<h2 id='MOVERR'>
MOVER-R method by Donner and Zhou (2012)
</h2><span id='topic+MOVERR'></span>

<h3>Description</h3>

<p>Compute confidence intervals for the ratio (theta1/theta0) of two parameters based on point estimates and confidence intervals for the two parameters, theta1 and theta0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOVERR(theta0, ci0, theta1, ci1, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MOVERR_+3A_theta0">theta0</code></td>
<td>
<p>a single numeric vale, the point estimate for the parameter to appear in the denominator</p>
</td></tr>
<tr><td><code id="MOVERR_+3A_ci0">ci0</code></td>
<td>
<p> vector with two numeric values, the lower and upper confidence limits for the parameter to appear in the denominator</p>
</td></tr>
<tr><td><code id="MOVERR_+3A_theta1">theta1</code></td>
<td>
<p>a single numeric vale, the point estimate for the parameter to appear in the numerator</p>
</td></tr>
<tr><td><code id="MOVERR_+3A_ci1">ci1</code></td>
<td>
<p>vector with two numeric values, the lower and upper confidence limits for the parameter to appear in the numerator</p>
</td></tr>
<tr><td><code id="MOVERR_+3A_alternative">alternative</code></td>
<td>
<p>a character string, <code>"two.sided"</code> for two-sided intervals, <code>"less"</code> for upper limits, <code>"greater"</code> for lower limits only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Eq. (9) in Donner and Zou (2012), for computing confidence intervals for a ratio of two parameters, when their estimators are uncorrelated.
</p>


<h3>Value</h3>

<p>a list with elements
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>numeric, the lower and upper confidence limits for the ratio</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimate for the ratio</p>
</td></tr>
</table>
<p>and the input estimates and confidence limits
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Donner and Zou (2012):</em> Closed-form confidence intervals for functions of the normal mean and standard deviation. Statistical Methods in Medical Research 21(4):347-359.
</p>

<hr>
<h2 id='np.re'>
Nonparametric test and confidence interval based on relative effects
</h2><span id='topic+np.re'></span>

<h3>Description</h3>

<p>Nonparametric test and confidence interval for comparing two samples in presence of heterogeneous variances (Behrens Fisher Problem). The confidence intervals
estimate the relative effect p(x,y), i.e. the probability that a randomly chosen observation from population x is larger than a randomly chosen observation from population y, <code class="reqn">P(x&gt;y)+P(x=y)/2</code>.
Different approximations are available, the method is designed for continuous or ordered categorical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.re(x, y, conf.level = 0.95, 
alternative = c("two.sided", "less", "greater"),
 method = c("logit", "probit", "normal", "t.app"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="np.re_+3A_x">x</code></td>
<td>

<p>a numeric vector, containing the observations of the first sample
</p>
</td></tr>
<tr><td><code id="np.re_+3A_y">y</code></td>
<td>

<p>a numeric vector, containing the observations of the second sample
</p>
</td></tr>
<tr><td><code id="np.re_+3A_conf.level">conf.level</code></td>
<td>

<p>a single numeric value, the desired confidence level of the interval to be constructed.
</p>
</td></tr>
<tr><td><code id="np.re_+3A_alternative">alternative</code></td>
<td>

<p>a single character string, one of &quot;two.sided&quot; (for two-sided testing and confidence intervals), &quot;less&quot; (for testing that x &lt; y in tendency, or upper confidence limits for p(x,y)), or &quot;greater&quot; (for testing x &gt; y in tendency, or lower confidence limits for p(x,y))
</p>
</td></tr>
<tr><td><code id="np.re_+3A_method">method</code></td>
<td>
<p> a single character string, one of &quot;logit&quot;,&quot;probit&quot;,&quot;normal&quot;,&quot;t.app&quot;, specifying which of the different available approximative methods should be used. See details below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs two sample tests for the nonparametric Behrens-Fisher problem. The hypothesis tested is </p>
<p style="text-align: center;"><code class="reqn">H_0: p(x,y)=1/2</code>
</p>
<p>, where
p(x,y) denotes the relative effect of 2 independent samples x and y. Further, confidence intervals for the relative effect p(x,y) are computed. For the computation of p-values as well as confidence limits, 
a standard normal or Satterthwaite t-approximation can be used directly on the scale of the relative effects (method &quot;normal&quot;,&quot;t.app&quot;). Based on these methods, the intervals may have bounds outside [0,1] for extreme results.
Alternatively variance stabilising transformations (Probit and Logit) may be used in combination with normal approximation (methods &quot;logit&quot;, and &quot;probit&quot;). 
</p>
<p>If the samples are completely separated, the variance estimator is zero by construction. In this case, estimated relative effects 0 or 1 are replaced with 0.001, 0.999 respectively. The variance estimator is replaced as described in Neubert and Brunner (2006).
</p>


<h3>Value</h3>

<p>An object of class &quot;htest&quot;
</p>


<h3>Author(s)</h3>

<p>Frank Konietschke, <span class="pkg">nparcomp</span>, with adaptations by Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Brunner, E., Munzel, U. (2000).</em> The Nonparametric Behrens-Fisher Problem: Asymptotic Theory and a Small Sample Approximation. Biometrical Journal 42, 17 -25.
<em>Neubert, K., Brunner, E., (2006).</em> A Studentized Permutation Test for the Nonparametric Behrens-Fisher Problem. Computational Statistics and Data Analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sodium)

iso&lt;-subset(sodium, Treatment=="xisogenic")$Sodiumcontent
tra&lt;-subset(sodium, Treatment=="transgenic")$Sodiumcontent

np.re(x=iso, y=tra, conf.level = 0.95)
np.re(x=iso, y=tra, conf.level = 0.95, alternative="less")
np.re(x=iso, y=tra, conf.level = 0.95, alternative="greater")

</code></pre>

<hr>
<h2 id='Oats'>The Oats data set</h2><span id='topic+Oats'></span>

<h3>Description</h3>

<p>The yield of three varieties of Oat was recorded in a field trial with 6 Blocks on 4 levels of nitrogen fertilization.
Originally a split plot design, here simply for demonstration of pairwiseCI.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oats)</code></pre>


<h3>Format</h3>

<p>A data frame with 72 observations on the following 4 variables.
</p>

<dl>
<dt><code>Block</code></dt><dd><p>an ordered factor with levels <code>VI</code> &lt; <code>V</code> &lt; <code>III</code> &lt; <code>IV</code> &lt; <code>II</code> &lt; <code>I</code></p>
</dd>
<dt><code>Variety</code></dt><dd><p>a factor with levels <code>Golden Rain</code> <code>Marvellous</code> <code>Victory</code></p>
</dd>
<dt><code>nitro</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>yield</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>See Oats(nlme).</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Oats)
boxplot(yield ~ nitro*Variety, data=Oats)
</code></pre>

<hr>
<h2 id='overdispersed.binomial.ratio'>Confidence intervals for risk ratios of overdispersed binomial data</h2><span id='topic+Quasibin.ratio'></span><span id='topic+Betabin.ratio'></span><span id='topic+ODbin.ratio'></span>

<h3>Description</h3>

<p>Calculate approximate confidence intervals for ratios of proportions (risk ratios) of two samples. Three functions are available for intervals assuming the beta binomial distribution, based on a generalized assumption of overdispersion estimated from the residuals, and based on the quasibinomial assumption using a generalized linear model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Betabin.ratio(x, y, conf.level=0.95, alternative="two.sided",
 CImethod=c("FBB", "LBB"), iccpool=FALSE, resbin=FALSE) 

ODbin.ratio(x, y, conf.level=0.95, alternative="two.sided",
 CImethod=c("FOD", "LOD"), varmethod=c("res", "san"), resbin=FALSE) 

Quasibin.ratio(x, y, conf.level = 0.95, alternative = "two.sided", grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overdispersed.binomial.ratio_+3A_x">x</code></td>
<td>
<p> a matrix or data.frame of the first sample, with two columns giving the counts of successes and failures in the two columns; each row should correspond to one experimental or observational unit; first column will be treated as 'success'</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_y">y</code></td>
<td>
<p> a matrix or data.frame of the second sample, with two columns giving the counts of successes and failures in the two columns; each row should correspond to one experimental or observational unit; first column will be treated as 'success'</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_conf.level">conf.level</code></td>
<td>
<p> a single numeric value between 0 and 1, the confidence level</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_alternative">alternative</code></td>
<td>
<p>a character string, <code>"two.sided"</code> for two-sided intervals, <code>"less"</code> for upper limits, <code>"greater"</code> for lower limits only</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_cimethod">CImethod</code></td>
<td>
<p>a character string, chossing between available methods for interval computation: in <code>betabin.ratio</code>: assuming the beta binomial distribution <code>"FBB"</code> invokes the Fieller-Bailey interval and <code>"LBB"</code> invokes the delta-method on the log scale (Lui et al. 2000);
in <code>ODbin.ratio</code>: without particular assumptions w.r.t to the distibution, <code>"FOD"</code> invokes the Fieller-Bailey interval and <code>"LOD"</code> invokes the delta-method on the log scale as described by Zaihra and Paul (2010)</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_iccpool">iccpool</code></td>
<td>
<p>logical, if <code>FALSE</code>, a separate intra-class-correlation coefficient is estimated for each sample (assuming different levels of overdispersion in the two samples); if <code>TRUE</code>, a joint intra-class-correlation coefficient (assuming equal ICCs in the two samples)</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_resbin">resbin</code></td>
<td>
<p>logical: if <code>FALSE</code>, underdispersion is allowed in estimation; if <code>TRUE</code>, underdispersion not allowed: when sample estimates suggest underdispersion, the variance is fixed at the binommial variance</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_varmethod">varmethod</code></td>
<td>
<p>a character string specifying te type of variance estimation in <code>ODbin.ratio</code>: <code>"res"</code> is the residual variance, <code>"san"</code> corresponds to a sandwich estimator, details see (Zaihra and Paul, 2010)</p>
</td></tr>
<tr><td><code id="overdispersed.binomial.ratio_+3A_grid">grid</code></td>
<td>
<p>optional, a numeric vector to be supplied to the profiling used internally in <code>quasibin.ratio</code> to obtain profile deviance intervals for each samples proportion on the logit-scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods in <code>betabin.ratio</code> are described by Lui et al., (2000), where different estimates for ICC (and thus overdispersion) are computed for each sample.
For small sample size or extreme proportions, one may restrict the variance to that of the binomial distribution and/or use a pooled estimator of ICC for a joint model of overdispersion in the two samples. 
</p>
<p>The methods in <code>ODbin.ratio</code> are described by Zaihra and Paul (2010), where different estimates for overdispersion are computed for each sample. Zaihra and Paul refer to two different methods of estimating the variance (MR, MS), here referred to as &quot;res&quot;, &quot;san&quot;, respectively. As above one may restrict the variance to that of the binomial distribution.
</p>
<p>The method to compute intervals under the quasibinomial assumptions in <code>quasibin.ratio</code> uses a quasibinomial generalized linear model to obtain profile deviance intervals (e.g. Bates and Watts, 1988; relying on package mcprofile), and then applies the MOVERR method by Donner and Zhou(2012); experimental! 
</p>


<h3>Value</h3>

<p>a list with elements
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>confidence limits for the ratio of proprotions in x over that in y</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimate for the ratio of proprotions in x over that in y</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The method in <code>quasibin.ratio</code> is experimental.
</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt
</p>


<h3>References</h3>

<p><em>Lui K-L, Mayer JA, Eckhardt L (2000):</em> Confidence intervals for the risk ratio under cluster sampling based on the beta-binomial model. Statistics in Medicine 19, 2933-2942.
</p>
<p><em>Zaihra, T and Paul, S (2010):</em> Interval Estimation of Some Epidemiological Measures of Association. The International Journal of Biostatistics. 6 (1), Article 35.
</p>
<p><em>Bates and Watts(1988):</em> Nonlinear Regression Analysis and Its Applications, Wiley, Ch.6
</p>
<p><em>Donner and Zou (2012):</em> Closed-form confidence intervals for functions of the normal mean and standard deviation. Statistical Methods in Medical Research 21(4):347-359.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Toxicologoical data: Number of Pups alive four days after birth (16 litters of rats)
# Original source: Weil, 1970: Selection of valid number[...].
#  Food and Cosmetics, Toxicology, 8, 177-182.
# Cited from Zaihra and Paul(2010): Interval Estimation  of Some Epidemiological
# Measures of Association. Int. J Biostatistics, 6(1), Article 35.


mchem = c(12, 11, 10, 9, 11, 10, 10, 9, 9, 5, 9, 7, 10, 6, 10, 7)
xchem = c(12, 11, 10, 9, 10,  9,  9, 8, 8, 4, 7, 4,  5, 3,  3, 0)
dchem &lt;- cbind("alive"=xchem, "dead"=mchem-xchem)

mcon = c(13, 12, 9, 9, 8, 8, 13, 12, 10, 10, 9, 13, 5, 7, 10, 10)
xcon = c(13, 12, 9, 9, 8, 8, 12, 11,  9,  9, 8, 11, 4, 5,  7,  7)
dcon &lt;- cbind("alive"=xcon, "dead"=mcon-xcon)


# Zaihra and Paul report: MR2: [0.714; 1.034]
ODbin.ratio(x=dchem, y=dcon, CImethod="LOD", resbin=FALSE) 

# Zaihra and Paul report: MR4: [0.710; 1.029]
ODbin.ratio(x=dchem, y=dcon, CImethod="FOD", resbin=FALSE) 



Betabin.ratio(x=dchem, y=dcon, CImethod="FBB", iccpool=TRUE, resbin=TRUE) 

Quasibin.ratio(x=dchem, y=dcon)


# Solar protection data: intervention and control group (Mayer, 1997:)

# Number of children with adequate level of solar protection
# Source: Mayer, Slymen, Eckhardt et al.(1997): Reducing ultraviolat 
# radiation exposure in children. Preventive Medicine 26, 845-861. 
# Cited from: Lui et al. (2000)

mint=c(3,2,2,5,4,3,1,2,2,2,1,3,1,3,2,2,6,2,4,2,2,2,2,1,1,1,1,1,1)
xint=c(1,1,1,0,1,2,1,2,2,1,1,2,1,2,2,0,0,0,0,1,2,1,1,1,1,0,0,0,0)
dint &lt;- cbind("adequate"=xint, "non-adequate"=mint-xint)

mcont=c(2,4,3,2,3,4,4,2,2,3,2,2,4,3,2,3,1,1,2,2,2,3,3,4,1,1,1,1,1)
xcont=c(0,0,2,2,0,4,2,1,1,3,2,1,1,3,2,3,1,0,1,2,1,1,2,4,1,1,1,0,0)
dcont &lt;- cbind("adequate"=xcont, "non-adequate"=mcont-xcont)


# Lui et al.(2000) report for the Fieller-Bailey method
# with pooled ICC: 905% CI = [0.964; 2.281]
Betabin.ratio(x=dcont, y=dint, conf.level=0.95, alternative="two.sided",
 CImethod="FBB", iccpool=TRUE, resbin=FALSE) 

# and for the Log-scale delta method with pooled ICC:
# 95% CI = [0.954; 2.248]
Betabin.ratio(x=dcont, y=dint, conf.level=0.95, alternative="two.sided",
 CImethod="LBB", iccpool=TRUE, resbin=FALSE) 

ODbin.ratio(x=dcont, y=dint, conf.level=0.95, alternative="two.sided",
 CImethod="FOD", resbin=TRUE) 

Quasibin.ratio(x=dcont, y=dint, conf.level = 0.95, alternative = "two.sided")



</code></pre>

<hr>
<h2 id='pairwiseCI'>Wrapper function for two-sample confidence intervals</h2><span id='topic+pairwiseCI'></span>

<h3>Description</h3>

<p>Confidence intervals (CI) for difference or ratio of location parameters of two independent samples.
The CI are NOT adjusted for multiplicity by default. A by statement allows for separate calculation
of pairwise comparisons according to further factors in the given dataframe. 
The function applies the intervals available from t.test(stats) for difference of means with
and without assumptions of homogeneous variances; large sample approximations for the difference and ratio of means of lognormal data; the exact CI for difference (wilcox.exact(exactRankTests))
and ratio of location based on the Hodges-Lehmann estimator; bootstrap intervalls for ratio and difference
of Medians and Harrell-Davis estimators a more robust alternatives to the Hodges-Lehmann estimator (boot, Hmisc); 
the Score test derived CI for the difference (prop.test(stats)), Woolf-interval for the odds-ratio
and a crude asymptotic as well as an iterative interval for the ratio of proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseCI(formula, data, by = NULL,
 alternative = "two.sided", conf.level = 0.95,
 method = "Param.diff", control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseCI_+3A_formula">formula</code></td>
<td>
<p> A formula of the structure <kbd>response ~ treatment</kbd> for numerical variables,
and of structure <kbd>cbind(success, failure)</kbd> <kbd>~ treatment</kbd> for binomial variables </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_data">data</code></td>
<td>
<p> A data.frame containing the numerical response variable and the treatment
and by variable as factors. Note, that for binomial data, two columns containing the number
of successes and failures must be present in the data. </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_by">by</code></td>
<td>
<p> A character string or character vector giving the name(s) of additional
factors by which the data set is to be split. </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_alternative">alternative</code></td>
<td>
<p> Character string, either &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;  </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_conf.level">conf.level</code></td>
<td>
<p> The comparisonwise confidence level of the intervals, where 0.95 is default </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_method">method</code></td>
<td>
<p> A character string specifying the confidence interval method, with the following options
<kbd>"Param.diff"</kbd>: Difference of two means, with additional argument <kbd>var.equal=FALSE</kbd>(default) as in <kbd>t.test(stats)</kbd>,
<kbd>"Param.ratio"</kbd>: Ratio of two means, with additional argument <kbd>var.equal=FALSE</kbd>(default) as in <kbd>ttestratio(mratios)</kbd>,
<kbd>"Lognorm.diff"</kbd>: Difference of two means, assuming a lognormal distribution, based on generalized pivotal quantities,
<kbd>"Lognorm.ratio"</kbd>: Ratio of two means, assuming a lognormal distribution, based on generalized pivotal quantities,
<kbd>"np.re"</kbd>: nonparametric confidence interval for relative effects suitable for the Behrens Fisher problem,
<kbd>"HL.diff"</kbd>: Exact conditional nonparametric CI for difference of locations based on the Hodges-Lehmann estimator,
<kbd>"HL.ratio"</kbd>: Exact conditional nonparametric CI for ratio of locations, based on the Hodges-Lehmann estimator,
<kbd>"Median.diff"</kbd>: Nonparametric CI for difference of locations, based on the medians (percentile bootstrap, stratified by the grouping variable),
<kbd>"Median.ratio"</kbd>: Nonparametric CI for ratio of locations, based on the medians (percentile bootstrap, stratified by the grouping variable),
<kbd>"Negbin.ratio"</kbd>: Profile-likelihood CI for ratio of expected values assuming the negative binomial distribution, adapting code from the profile function of MASS (Venables and Ripley,2002),
<kbd>"Quasipoisson.ratio"</kbd>: Profile-deviance CI for the ratio of expected values with a quasipoisson assumption, using the adapted code of the profile function in MASS 
<kbd>"Poisson.ratio"</kbd>: Profile-likelihood CI for the ratio of expected values with a Poisson assumption, again using slightly changed code from MASS,
<kbd>"Prop.diff"</kbd>: Asymptotic CI for the difference of proportions with the following options: <kbd>CImethod="NHS"</kbd> Newcombes Hybrid Score interval (Newcombe, 1998), <kbd>CImethod="CC"</kbd> continuity corrected interval (Newcombe, 1998) as implemented in <kbd>prop.test(stats)</kbd>,  <kbd>CImethod="AC"</kbd> Agresti-Caffo interval (Agresti and Caffo, 2000)
<kbd>"Prop.ratio"</kbd>: Asymptotic CI (normal approximation on the log: <kbd>CImethod="GNC"</kbd>) or iterative CI (<kbd>CImethod="Score"</kbd>) for ratio of proportions,
<kbd>"Prop.or"</kbd>: Asymptotic CI for the odds ratio (normal approximation on the log: <kbd>CImethod="Woolf"</kbd>), or the exact CI corresponding to Fishers exact test (<kbd>CImethod="Exact"</kbd>, taken from <kbd>fisher.test</kbd>, package <kbd>stats</kbd>)
See <kbd>?pairwiseCImethods</kbd> for details.
</p>
</td></tr>                                                 
<tr><td><code id="pairwiseCI_+3A_control">control</code></td>
<td>
<p> Character string, specifying one of the levels of the treatment variable as 
control group in the comparisons; default is NULL, then CI for all pairwise comparisons are calculated. </p>
</td></tr>
<tr><td><code id="pairwiseCI_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the functions specified in <code><a href="#topic+pairwiseCImethodsCont">pairwiseCImethodsCont</a></code>, <code><a href="#topic+pairwiseCImethodsCount">pairwiseCImethodsCount</a></code> and <code><a href="#topic+pairwiseCImethodsProp">pairwiseCImethodsProp</a></code>. 
In particular, different methods to calculate confidence intervals can be specified via the argument <kbd>CImethod</kbd> for the comparison of binomial proportions, see details in <code><a href="#topic+pairwiseCImethodsProp">pairwiseCImethodsProp</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all the computed intervals are without adjustment for multiplicity by default. 
When based on crude normal approximations or crude non-parametric bootstrap methods, the derived confidence intervals can be unreliable for small sample sizes.
The method implemented here split the data set into small subsets (according to the grouping variable in <kbd>formula</kbd> and the variable specified in <kbd>by</kbd>)
and compute confidence intervals only based each particular subset. Please note that, when a (generalized) linear model can be reasonable assumed to describe the 
complete data set, it is smarter to compute confidence intervals based on the model estimators. Methods to do this are, e.g., implemented in the packages <span class="pkg">stats</span>, <span class="pkg">multcomp</span>, <span class="pkg">mratios</span>.
</p>


<h3>Value</h3>

<p>an object of class &quot;pairwiseCI&quot; structured as:
</p>
<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>byout</code></td>
<td>
<p>A named list, ordered by the levels of the by-factor, where each element is a list
containing the numeric vectors <kbd>estimate</kbd>, <kbd>lower</kbd>, <kbd>upper</kbd> and the character vector <kbd>compnames</kbd></p>
</td></tr>
<tr><td><code>bynames</code></td>
<td>
<p>the level names of the by-factor</p>
</td></tr>
</table>
<p>and further elements as input, try str() for details.
</p>
<p>the object is printed by <code><a href="#topic+print.pairwiseCI">print.pairwiseCI</a></code>.
</p>


<h3>References</h3>

 

<ul>
<li> <p><kbd>Param.diff</kbd> simply uses: <kbd>t.test</kbd> in <span class="pkg">stats</span>, note that the default setting assums possibly heterogeneous variances (<kbd>var.equal=FALSE</kbd>).
</p>
</li>
<li> <p><kbd>Param.ratio</kbd> for homogeneous variances (<kbd>var.equal=TRUE</kbd>): <b>Fieller EC (1954):</b> Some problems in interval estimation. Journal of the Royal Statistical Society, Series B, 16, 175-185.
</p>
</li>
<li> <p><kbd>Param.ratio</kbd> for heterogenous variances (<kbd>var.equal=FALSE</kbd>): : the test proposed in: <b>Tamhane, AC, Logan, BR (2004):</b> Finding the maximum safe dose level for heteroscedastic data. Journal of Biopharmaceutical Statistics 14, 843-856.
is inverted by solving a quadratic equation according to Fieller, where the estimated ratio is simply plugged in order to get Satterthwaite approximated degrees of freedom.
See also: <b>Hasler, M,  Vonk, R, Hothorn, LA:</b> Assessing non-inferiority of a new treatment in a three arm trial in the presence of heteroscedasticity. Statistics in Medicine 2007 (in press).
</p>
</li>
<li> <p><kbd>Lognorm.ratio</kbd> and <kbd>Lognorm.ratio</kbd>: <b>Chen, Y-H, Zhou, X-H (2006)</b>: Interval estimates for the ratio and the difference of two lognormal means.
Statistics in Medicine 25, 4099-4113.
</p>
</li>
<li> <p><kbd>Np.re</kbd>: <b>Brunner, E., Munzel, U. (2000).</b> The Nonparametric Behrens-Fisher Problem: Asymptotic Theory and a Small Sample Approximation. Biometrical Journal 42, 17 -25.
<b>Neubert, K., Brunner, E., (2006).</b> A Studentized Permutation Test for the Nonparametric Behrens-Fisher Problem. Computational Statistics and Data Analysis.
</p>
</li>
<li> <p><kbd>HL.diff</kbd>: <kbd>wilcox.exact</kbd> in <span class="pkg">exactRankTests</span> 
</p>
</li>
<li> <p><kbd>HL.ratio</kbd>: <b>Hothorn, T, Munzel, U:</b> Non-parametric confidence interval for the ratio. Report University of Erlangen, Department Medical Statistics 2002;
available via: http://www.imbe.med.uni-erlangen.de/~hothorn/
For the Hodges-Lehmann estimator see: <b>Hodges, J.L., Lehmann E.L.(1963):</b> Estimates of location based on rank tests. Ann. Math. Statist. 34, 598-611.
</p>
</li>
<li> <p><kbd>Median.diff</kbd>: The interval is calculated from a bootstrap sample (stratified according to the group variable) of the difference of sample Medians, using package boot.
</p>
</li>
<li> <p><kbd>Median.ratio</kbd>: The interval is calculated from a bootstrap sample (stratified according to the group variable) of the ratio of sample Medians, using package boot.
</p>
<p>Note, that the 4 bootstrap versions will hardly make sense for small samples, because of the discreteness of the resulting bootstrap sample.
</p>
</li>
<li> <p><kbd>Poisson.ratio</kbd>: Profile-likelihood CI, based on the assumption of a Poisson distribution, basic method described in <b>Venables, W.N., Ripley, B.D. (2002):</b> Modern Applied Statistics with S. Springer Verlag, New York.
</p>
</li>
<li> <p><kbd>Quasipoisson.ratio</kbd>: Profile-deviance CI, based on the quasipoisson assumption, basic method  described in Venables, <b>W.N., Ripley, B.D. (2002):</b> Modern Applied Statistics with S. Springer Verlag, New York.
</p>
</li>
<li> <p><kbd>Negbin.ratio</kbd>: Profile-likelihood CI, based on the assumption of the negative binomial distribution, basic method  described in <b>Venables, W.N., Ripley, B.D. (2002):</b> Modern Applied Statistics with S. Springer Verlag, New York.
</p>
</li>
<li> <p><kbd>Prop.diff</kbd>: provides three approximate methods to calculate confidence intervals for the difference of proportions: Default is <kbd>CImethod="NHS"</kbd>: Newcombes Hybrid Score interval (Newcombe, 1998), other options are <kbd>CImethod="CC"</kbd> continuity corrected interval (Newcombe, 1998) as implemented in <kbd>prop.test(stats)</kbd> and <kbd>CImethod="AC"</kbd> Agresti-Caffo interval (Agresti and Caffo, 2000) 
<b>Newcombe R.G. (1998):</b> Interval Estimation for the Difference Between Independent Proportions: Comparison of Eleven Methods. Statistics in Medicine 17, 873-890. 
</p>
</li>
<li> <p><kbd>Prop.ratio</kbd> calculates the crude asymptotic interval (normal approximation on the log-scale, <kbd>CImethod="GNC"</kbd>) or the Score interval (<kbd>CImethod="Score"</kbd>), both described in:
<b>Gart, JJ and Nam, J (1988)</b>: Approximate interval estimation of the ratio of binomial parameters: A review and corrections for skewness.
Biometrics 44, 323-338. 
</p>
</li>
<li> <p><kbd>Prop.or</kbd> Adjusted Woolf interval (<kbd>CImethod="Woolf"</kbd>), e.g. in: <b>Lawson, R (2005):</b> Small sample confidence intervals for the odds ratio. Communication in Statistics Simulation and Computation, 33, 1095-1113.
or the exact interval corresponding to Fishers exact test (<kbd>CImethod="Exact"</kbd>, taken from <kbd>fisher.test(stats)</kbd>, see references there)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.pairwiseCI">as.data.frame.pairwiseCI</a></code> to create a data.frame from the output,
<code><a href="#topic+summary.pairwiseCI">summary.pairwiseCI</a></code> to create a more easily accessable list from the output,
<code><a href="#topic+plot.pairwiseCI">plot.pairwiseCI</a></code> to plot the intervals.
Further, see 
<span class="pkg">multcomp</span> for simultaneous intervals for difference for various contrasts,
<span class="pkg">mratios</span> for simultaneous intervals for the ratio of means,
<span class="pkg">stats</span> <kbd>p.adjust</kbd>, <kbd>pairwise.t.test</kbd>, <kbd>pairwise.prop.test</kbd>, <kbd>pairwise.wilcox.test</kbd>,
<kbd>TukeyHSD</kbd> for methods of multiple comparisons.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# some examples:
# In many cases the shown examples might not make sense,
# but display how the functions can be used.

data(Oats)

# # all pairwise comparisons,
# separately for each level of nitro:

apc &lt;- pairwiseCI(yield ~ Variety, data=Oats,
 by="nitro", method="Param.diff")

apc

plot(apc)

# # many to one comparisons, with variety Marvellous as control,
# for each level of nitro separately:

m21 &lt;- pairwiseCI(yield ~ Variety, data=Oats,
 by="nitro", method="Param.diff", control="Marvellous")

 plot(m21)

# # the same using confidence intervals for the ratio of means:

m21 &lt;- pairwiseCI(yield ~ Variety, data=Oats,
 by="nitro", method="Param.diff", control="Marvellous")

 plot(m21, CIvert=TRUE, H0line=0.9)

###############################################

# The repellent data set (a trial on repellent 
# effect of sulphur on honey bees): Measured was
# the decrease of sugar solutions (the higher the decrease,
# the higher the feeding, and the less the repellent effect).
# Homogeneity of variances is questionable. Which of the doses
# leads to decrease of the variable decrease compared to the
# control group "H"?

data(repellent)
boxplot(decrease ~ treatment, data=repellent)

# as difference to control (corresponding to Welch tests)
beeCId&lt;-pairwiseCI(decrease ~ treatment, data=repellent,
 method="Param.diff", control="H", alternative="less",
 var.equal=FALSE)
beeCId
plot(beeCId)

# as ratio to control:

## Not run: 
beeCIr&lt;-pairwiseCI(decrease ~ treatment, data=repellent,
 method="Param.ratio", control="H", alternative="less",
 var.equal=FALSE)
beeCIr
plot(beeCIr)

# Bonferroni-adjustment can be applied:

beeCIrBonf&lt;-pairwiseCI(decrease ~ treatment, data=repellent,
 method="Param.ratio", control="H", alternative="less",
 var.equal=FALSE, conf.level=1-0.05/7)
beeCIrBonf
plot(beeCIrBonf)

## End(Not run)

##############################################

# Proportions:

# The rooting example:
# Calculate confidence intervals for the 
# difference of proportions between the 3 doses of IBA,
# separately for 4 combinations of "Age" and "Position".
# Note: we pool over Rep in that way. Whether this makes
# sense or not, is decision of the user.

data(rooting)

# Risk difference

aprootsRD&lt;-pairwiseCI(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.diff")

aprootsRD

# Odds ratio


aprootsOR&lt;-pairwiseCI(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.or")

aprootsOR

# Risk ratio

aprootsRR&lt;-pairwiseCI(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.ratio")

aprootsRR

# CI can be plotted:

plot(aprootsRR)

###############################################

# CIs assuming lognormal distribution of the response:

resp&lt;-rlnorm(n=20, meanlog = 0, sdlog = 1)
treat&lt;-as.factor(rep(c("A","B")))
datln&lt;-data.frame(resp=resp, treat=treat)

pairwiseCI(resp~treat, data=datln, method="Lognorm.diff")
pairwiseCI(resp~treat, data=datln,  method="Lognorm.ratio")

</code></pre>

<hr>
<h2 id='pairwiseCIInt'>Internal functions for pairwiseCI</h2><span id='topic+pairwiseCICont'></span><span id='topic+pairwiseCIProp'></span>

<h3>Description</h3>

<p>For internal use. Two different methods for data representable as a two numeric vectors (pairwiseCICont) and
data representable as matrix with two columns like <kbd>cbind(successes, failures)</kbd>.
Functions that split up a data.frame according to one factor, and perform all pairwise comparisons
and comparisons to control among the levels of the factor by calling methods documented in <code><a href="#topic+pairwiseCImethodsCont">pairwiseCImethodsCont</a></code>
and <code><a href="#topic+pairwiseCImethodsProp">pairwiseCImethodsProp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pairwiseCICont(formula, data, alternative="two.sided",
 conf.level=0.95, method, control=NULL, ...)

pairwiseCIProp(formula, data, alternative="two.sided",
 conf.level=0.95, control=NULL, method, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseCIInt_+3A_formula">formula</code></td>
<td>
<p>A formula of the structure <kbd>response ~ treatment</kbd> for numerical variables,
and of structure <kbd>cbind(success, failure)</kbd> <kbd>~ treatment</kbd> for binomial variables </p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_data">data</code></td>
<td>
<p>A data.frame containing the numerical response variable and the treatment
and by variable as factors. Note, that for binomial data, two columns containing the number
of successes and failures must be present in the data. </p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_alternative">alternative</code></td>
<td>
<p> Character string, either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd> or <kbd>"greater"</kbd> </p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_conf.level">conf.level</code></td>
<td>
<p> The <em>comparisonwise confidence level</em> of the intervals, where 0.95 is default </p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_method">method</code></td>
<td>
<p> A character string specifying the confidence interval method, one of the following options
<kbd>"Param.diff"</kbd>: Difference of two means, with additional argument <kbd>var.equal=FALSE</kbd>(default) as in <kbd>t.test(stats)</kbd>
<kbd>"Param.ratio"</kbd>: Ratio of two means, with additional argument <kbd>var.equal=FALSE</kbd>(default) as in <kbd>ttestratio(mratios)</kbd>
<kbd>"Lognorm.diff"</kbd>: Difference of two means, assuming a lognormal distribution,
<kbd>"Lognorm.ratio"</kbd>: Ratio of two means, assuming a lognormal distribution,
<kbd>"HL.diff"</kbd>: Exact nonparametric CI for difference of locations based on the Hodges-Lehmann estimator,
<kbd>"HL.ratio"</kbd>: Exact nonparametric CI for ratio of locations, based on the Hodges-Lehmann estimator,
<kbd>"Median.diff"</kbd>: Nonparametric CI for difference of locations, based on the medians (percentile bootstrap CI),
<kbd>"Median.ratio"</kbd>: Nonparametric CI for ratio of locations, based on the medians (percentile bootstrap CI),
<kbd>"Prop.diff"</kbd>: Asymptotic CI for difference of proportions <kbd>prop.test(stats)</kbd>
<kbd>"Prop.ratio"</kbd>: Asymptotic CI for ratio of proportions
<kbd>"Prop.or"</kbd>: Asymptotic CI for the odds ratio
See <code>?pairwiseCImethods</code> for details.
</p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_control">control</code></td>
<td>
<p> Character string, specifying one of the levels of the treatment variable as control group in the comparisons; default is <kbd>NULL</kbd>, then CI for all pairwise comparisons are calculated. </p>
</td></tr>
<tr><td><code id="pairwiseCIInt_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the functions specified in <kbd>methods</kbd></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal use in pairwiseCI.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p> numeric vector: the point estimates </p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>numeric vector: lower confidence bounds</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>numeric vector: upper confidence bounds</p>
</td></tr>
<tr><td><code>compnames</code></td>
<td>
<p>character vector with the names of comparisons</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+pairwiseCI">pairwiseCI</a></code> for the user level function;
<code><a href="#topic+pairwiseCImethodsCont">pairwiseCImethodsCont</a></code>, and <code><a href="#topic+pairwiseCImethodsProp">pairwiseCImethodsProp</a></code> for a more detailed documentation of the implemented methods;
<code><a href="#topic+summary.pairwiseCI">summary.pairwiseCI</a></code> for a summary function.
</p>
<p><kbd>t.test(stats)</kbd>,  <kbd>wilcox.exact(exactRankTests)</kbd>, <kbd>prop.test(stats)</kbd> for the sources of some of the CI methods,
<span class="pkg">multcomp</span> for simultaneous intervals for difference for various contrasts,
<span class="pkg">mratios</span> for simultaneous intervals for the ratio in many-to-one comparisons</p>

<hr>
<h2 id='pairwiseCImethodsCont'>Confidence intervals for two sample comparisons of continuous data</h2><span id='topic+pairwiseCImethodsCont'></span><span id='topic+Param.diff'></span><span id='topic+Param.ratio'></span><span id='topic+Lognorm.diff'></span><span id='topic+Lognorm.ratio'></span><span id='topic+Median.diff'></span><span id='topic+Median.ratio'></span><span id='topic+HL.diff'></span><span id='topic+HL.ratio'></span><span id='topic+HD.diff'></span><span id='topic+HD.ratio'></span>

<h3>Description</h3>

<p>Confidence interval methods available for pairwiseCI for comparison of two independent samples. Methods for continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Param.diff(x, y, conf.level=0.95, alternative="two.sided", ...)
Param.ratio(x, y, conf.level=0.95, alternative="two.sided", ...)

Lognorm.diff(x, y, conf.level=0.95, alternative="two.sided", sim=10000, ...)
Lognorm.ratio(x, y, conf.level=0.95, alternative="two.sided", sim=10000, ...)

HL.diff(x, y, conf.level=0.95, alternative="two.sided", ...)
HL.ratio(x, y, conf.level=0.95, alternative="two.sided", ...)

Median.diff(x, y, conf.level=0.95, alternative="two.sided", ...)
Median.ratio(x, y, conf.level=0.95, alternative="two.sided", ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseCImethodsCont_+3A_x">x</code></td>
<td>
<p> vector of observations in the first sample  </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCont_+3A_y">y</code></td>
<td>
<p> vector of observations in the second sample </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCont_+3A_alternative">alternative</code></td>
<td>
<p> character string, either &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;  </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCont_+3A_conf.level">conf.level</code></td>
<td>
<p> the comparisonwise confidence level of the intervals, where 0.95 is default </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCont_+3A_sim">sim</code></td>
<td>
<p>a single integer value, specifying the number of samples to be drawn for calculation of the empirical distribution of the generalized pivotal quantities</p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCont_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the individual methods, see details</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><kbd>Param.diff</kbd> calculates the confidence interval for the difference
in means of two Gaussian samples by calling <kbd>t.test</kbd> in package <span class="pkg">stats</span>,
assuming homogeneous variances if <kbd>var.equal=TRUE</kbd>,
and heterogeneous variances if <kbd>var.equal=FALSE</kbd> (default);
</p>
</li>
<li> <p><kbd>Param.ratio</kbd> calculates the Fiellers (1954) confidence interval for the ratio
of two Gaussian samples by calling <kbd>ttestratio</kbd> in package <span class="pkg">mratios</span>,
assuming homogeneous variances if <kbd>var.equal=TRUE</kbd>.
If heterogeneous variances are assumed (setting <kbd>var.equal=FALSE</kbd>, the default), the test by Tamhane and Logan (2004) is inverted by solving a quadratic equation according to Fieller,
where the estimated ratio is simply plugged in order to get Satterthwaite approximated degrees of freedom. See Hasler and Vonk (2006) for some simulation results.
</p>
</li>
<li> <p><kbd>Lognorm.diff</kbd> calculates the confidence interval for the difference
in means of two Lognormal samples, based on general pivotal quantities (Chen and Zhou, 2006); currently, further arguments <kbd>(\dots)</kbd>
are not used; 
</p>
</li>
<li> <p><kbd>Lognorm.ratio</kbd> calculates the confidence interval for the ratio
in means of two Lognormal samples, based on general pivotal quantities (Chen and Zhou, 2006); currently, further arguments <kbd>(\dots)</kbd>
are not used; 
</p>
</li>
<li> <p><kbd>HL.diff</kbd> calculates the Hodges-Lehmann confidence interval for the difference of locations
by calling <kbd>wilcox_test</kbd> in package <span class="pkg">coin</span>, further arguments ... are passed to wilcox_test and 
corresponding methods for Independence problems, for example <code>distribution</code> may be used to switch 
from <code>exact</code> (default), to approximate or asymptotic versions;
</p>
</li>
<li> <p><kbd>HL.ratio</kbd> calculates a Hodges-Lehmann-like confidence interval for the ratio of locations for positive data
by calling <kbd>wilcox_test</kbd> in package <span class="pkg">coin</span> on the logarithms of observations and backtransforming (Hothorn and Munzel, 2002),
further arguments ... are passed to wilcox_test and corresponding methods for Independence problems, for example <code>distribution</code> 
may be used to switch from <code>exact</code> (default), to approximate or asymptotic versions;
</p>
</li>
<li> <p><kbd>Median.diff</kbd> calculates a percentile bootstrap confidence interval for the difference
of Medians using <kbd>boot.ci</kbd> in package <span class="pkg">boot</span>, the number of bootstrap replications can be set
via <kbd>R=999</kbd> (default); 
</p>
</li>
<li> <p><kbd>Median.ratio</kbd> calculates a percentile bootstrap confidence interval for the ratio
of Medians using <kbd>boot.ci</kbd> in package <span class="pkg">boot</span>, the number of bootstrap replications can be set
via <kbd>R=999</kbd> (default); 
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>a vector containing the lower and upper confidence limit</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a single named value</p>
</td></tr>
</table>


<h3>References</h3>

 

<ul>
<li> <p><kbd>Param.diff</kbd> uses <kbd>t.test</kbd> in <span class="pkg">stats</span>. 
</p>
</li>
<li> <p><b> Fieller EC (1954)</b>: Some problems in interval estimation. 
Journal of the Royal Statistical Society, Series B, 16, 175-185.
</p>
</li>
<li> <p><b> Tamhane, AC, Logan, BR (2004)</b>: Finding the maximum safe dose level for heteroscedastic data.
Journal of Biopharmaceutical Statistics 14, 843-856.
</p>
</li>
<li> <p><b>Hasler, M,  Vonk, R, Hothorn, LA</b>: Assessing non-inferiority of a new treatment in a three arm trial in the presence of heteroscedasticity (submitted). 
</p>
</li>
<li>  <p><b>Chen, Y-H, Zhou, X-H (2006)</b>: Interval estimates for the ratio and the difference of two lognormal means.
Statistics in Medicine 25, 4099-4113.
</p>
</li>
<li> <p><b>Hothorn, T, Munzel, U</b>: Exact Nonparametric Confidence Interval for the Ratio of Medians.
Technical Report, Universitaet Erlangen-Nuernberg, Institut fuer Medizininformatik, Biometrie und Epidemiologie, 2002; available via:
<kbd>http://www.statistik.uni-muenchen.de/~hothorn/bib/TH_TR_bib.html</kbd>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

data(sodium)

iso&lt;-subset(sodium, Treatment=="xisogenic")$Sodiumcontent
trans&lt;-subset(sodium, Treatment=="transgenic")$Sodiumcontent

iso
trans

## CI for the difference of means, 
# assuming normal errors and homogeneous variances :

thomo&lt;-Param.diff(x=iso, y=trans, var.equal=TRUE)

# allowing heterogeneous variances
thetero&lt;-Param.diff(x=iso, y=trans, var.equal=FALSE)


## Fieller CIs for the ratio of means,
# also assuming normal errors:

Fielhomo&lt;-Param.ratio(x=iso, y=trans, var.equal=TRUE)

# allowing heterogeneous variances

Fielhetero&lt;-Param.ratio(x=iso, y=trans, var.equal=FALSE)


HLD&lt;-HL.diff(x=iso, y=trans)

thomo
thetero

Fielhomo
Fielhetero

HLD


# # #

# Lognormal CIs:

x&lt;-rlnorm(n=10, meanlog=0, sdlog=1)
y&lt;-rlnorm(n=10, meanlog=0, sdlog=1)

Lognorm.diff(x=x, y=y)
Lognorm.ratio(x=x, y=y)

 </code></pre>

<hr>
<h2 id='pairwiseCImethodsCount'>Confidence intervals for two sample comparisons of count data</h2><span id='topic+pairwiseCImethodsCount'></span><span id='topic+Poisson.ratio'></span><span id='topic+Quasipoisson.ratio'></span><span id='topic+Negbin.ratio'></span>

<h3>Description</h3>

<p>Confidence interval methods available for pairwiseCI for comparison of two independent samples. Methods for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Poisson.ratio(x, y, conf.level=0.95, alternative="two.sided")
Quasipoisson.ratio(x, y, conf.level=0.95, alternative="two.sided")
Negbin.ratio(x, y, conf.level=0.95, alternative="two.sided")


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseCImethodsCount_+3A_x">x</code></td>
<td>
<p> vector of observations in the first sample  </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCount_+3A_y">y</code></td>
<td>
<p> vector of observations in the second sample </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCount_+3A_alternative">alternative</code></td>
<td>
<p> character string, either &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;  </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsCount_+3A_conf.level">conf.level</code></td>
<td>
<p> the comparisonwise confidence level of the intervals, where 0.95 is default </p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><kbd>Poisson.ratio</kbd> calculates a confidence interval for the ratio of
means assuming the Poisson distribution of the response by fitting a generalized linear model with log-link using <kbd>glm</kbd> in package <span class="pkg">stats</span>,
constructing a likelihood profile and deriving a equal-tailed confidence interval from this profile. Please not that confidence intervals from this method
produce severely misleading results, when there is extra-Poisson variation in the data.
</p>
</li>
<li> <p><kbd>Quasipoisson.ratio</kbd> calculates a confidence interval for the ratio of
means of the response by fitting a generalized linear model with family <kbd>quasipoisson</kbd> and log-link using <kbd>glm</kbd> in package <span class="pkg">stats</span>,
constructing a deviance profile and deriving a equal-tailed confidence interval from this profile.
</p>
</li>
<li> <p><kbd>Negbin.ratio</kbd> calculates a confidence interval for the ratio of
means assuming the negative binomial distribution of the response by fitting a generalized linear model with log-link using <kbd>glm.nb</kbd> in package <span class="pkg">MASS</span>,
constructing a likelihood profile and deriving a equal-tailed confidence interval from this profile.
</p>
</li></ul>

<p>Note, that for all the methods, a separate glm is fitted for each two-sample comparison! When a common model can be reasonbly assumed for all the data, there are smarter methods of constructing confidence
intervals for groupwise comparisons, based on a common model, see e.g. the function <kbd>confint</kbd> in package <span class="pkg">stats</span>, the function <kbd>confint.glm</kbd> in package <span class="pkg">MASS</span> and the function <kbd>confint.glht</kbd> in package <span class="pkg">multcomp</span>.
</p>
<p>Note, that the code used here is slightly changed from the original code by Venables and Ripley, or Bates and Watts. An limit is imposed on the parameter space in which the profile is constructed. By that limitation, intervals can also be constructed for extreme cases with all observations in one group being zero.
</p>
<p>Note, that the <kbd>Poisson.ratio</kbd> can be used when only one count is present in each group. For <kbd>Quasipoisson.ratio</kbd>, <kbd>Negbin.ratio</kbd>, repeated observations are necessary in each group.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>a vector containing the lower and upper confidence limit</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a single named value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Gerhard, Frank Schaarschmidt</p>


<h3>References</h3>

 
<p><b>Venables WN and Ripley BD (2002).</b> Modern Applied Statistics using S, Fourth Edition. Springer New York.
<b>Bates, D.M. and Watts, D.G.(1988).</b> Nonlinear Regression Analysis and Its Applications. John Wiley and Sons, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(count = rpois(n=20, lambda=5), treat=rep(LETTERS[1:4], each=5))

QPCI&lt;-pairwiseCI(count ~ treat, data=df,
 alternative="two.sided", control="A", method="Quasipoisson.ratio")
 
QPCI


 </code></pre>

<hr>
<h2 id='pairwiseCImethodsProp'>Confidence intervals for two sample comparisons of binomial proportions</h2><span id='topic+pairwiseCImethodsProp'></span><span id='topic+Prop.diff'></span><span id='topic+Prop.ratio'></span><span id='topic+Prop.or'></span>

<h3>Description</h3>

<p>For the comparison of two independent samples of binomial observations, confidence intervals for
the difference (RD), ratio (RR) and odds ratio (OR) of proportions are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Prop.diff(x, y, conf.level=0.95, alternative="two.sided",
 CImethod=c("NHS", "CC", "AC"), ...)

Prop.ratio(x, y, conf.level=0.95, alternative="two.sided",
 CImethod=c("Score", "MNScore", "MOVER", "GNC"))

Prop.or(x, y, conf.level=0.95, alternative="two.sided",
 CImethod=c("Exact", "Woolf"), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseCImethodsProp_+3A_x">x</code></td>
<td>
<p> observations of the first sample: either a vector with number of successes and failures, or a data.frame with two columns (the successes and failures)) </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsProp_+3A_y">y</code></td>
<td>
<p> observations of the second sample: either a vector with number of successes and failures, or a data.frame with two columns (the successes and failures)) </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsProp_+3A_alternative">alternative</code></td>
<td>
<p> character string, either &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;  </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsProp_+3A_conf.level">conf.level</code></td>
<td>
<p> the comparisonwise confidence level of the intervals, where 0.95 is the default </p>
</td></tr>
<tr><td><code id="pairwiseCImethodsProp_+3A_cimethod">CImethod</code></td>
<td>
<p>a single character string, see below for details</p>
</td></tr>
<tr><td><code id="pairwiseCImethodsProp_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the individual methods, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, the input are two vectors <kbd>x</kbd> and <kbd>y</kbd> giving the number of successes and failures in the two samples,
or, alternatively, two <kbd>data.frame</kbd>s <kbd>x</kbd> and <kbd>y</kbd> each containing one column for the successes 
and one column for the failures, and the rows containing repeated observations from the same treatment.
</p>
<p>Please note, that the confidence intervals available in this function assume counts of successes and failures from a binomial distribution and thus do NOT APPROPRIATELY account for extra-binomial variability between repeated observations for the same treatment! 
When there are repeated observations (input as a data.frame with several rows), intervals are calculated based on the sums over the rows of success and failure!
</p>
<p>The following methods are available for the risk difference:
</p>

<ul>
<li> <p><kbd>Prop.diff</kbd>: asymptotic continuity corrected confidence interval for the difference of proportions by calling <kbd>prop.test</kbd> in package <span class="pkg">stats</span>, see <kbd>?prop.test</kbd> for details,
</p>
</li>
<li> <p><kbd>Prop.diff</kbd> with <kbd>CImethod="AC"</kbd>: asymptotic Wald-type interval after adding one pseudo-observation to each cell (Agresti and Caffo, 2000).
</p>
</li>
<li> <p><kbd>Prop.diff</kbd> with <kbd>CImethod="NHS"</kbd>: asymptotic Newcombes Hybrid Score Interval (Newcombe, 1998).
</p>
</li></ul>

<p>For the risk ratio:
</p>

<ul>
<li> <p><kbd>Prop.ratio</kbd> with <kbd>CImethod="Score"</kbd>:  asymptotic Score interval for the ratio of proportions (by iteratively inverting a Chi-Squared test) according to Koopman (1984), following the description by Gart and Nam (1988). This method does NOT involve the skewness correction or extensions to stratification described in Gart and Nam (1988).
</p>
</li>
<li> <p><kbd>Prop.ratio</kbd> with <kbd>CImethod="MNScore"</kbd>: asymptotic Score interval for the ratio of proportions (by iteratively inverting a Chi-Squared test) according to Miettinen and Nurminen (1985), following the description by Gart and Nam (1988). 
</p>
</li>
<li> <p><kbd>Prop.ratio</kbd> with <kbd>CImethod="MOVER"</kbd>: asymptotic method of variance estimate recovery for ratios (Donner and Zou, 2012; Fagerland and Newcombe, 2013), relying on the Wilson Score interval to obtain the confidence limits for the single proportions.
</p>
</li>
<li> <p><kbd>Prop.ratio</kbd> with <kbd>CImethod="GNC"</kbd>: crude normal approximation on the log-scale after adding 0.5 to the observed number of successes and the samples sizes.
</p>
</li></ul>

<p>For the odds ratio:
</p>

<ul>
<li> <p><kbd>Prop.or</kbd> with <kbd>CImethod="Woolf"</kbd> asymptotic adjusted Woolf confidence interval for the odds ratio of proportions (normal approximation after adding 0.5 to each cell count), as, e.g., described in Lawson (2005).
</p>
</li>
<li> <p><kbd>Prop.or</kbd> with <kbd>CImethod="Exact"</kbd> calculates the exact confidence interval for the odds ratio of proportions corresponding to Fishers exact test, by calling to <kbd>fisher.test</kbd> in <span class="pkg">stats</span>. For details, see <kbd>?fisher.test</kbd>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p>a vector containing the lower and upper confidence limit, and the methods name as an attribute</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a single named value</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the quantile used for constructing the interval</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
</table>


<h3>References</h3>

 

<ul>
<li> <p><b>Agresti A and Caffo B (2000):</b> Simple and effective confidence intervals for proportions and differences of proportions result from adding two successes and two failures. American Statistician 54 (4), 280-288.
</p>
</li>
<li> <p><b>Donner A and Zou GY (2012):</b> Closed-form confidence intervals for functions of the normal mean and standard deviation.Statistical Methods in Medical Research 21(4):347-359.
</p>
</li>
<li> <p><b>Fagerland MW, Newcombe RG (2013):</b> Confidence intervals for odds ratio and relative risk based on the inverse hyperbolic sine transformation. Statistics in Medicine, DOI: 10.1002/sim.5714
</p>
</li>
<li> <p><b>Gart JJ and Nam J (1988)</b>: Approximate interval estimation of the ratio of binomial parameters: A review and corrections for skewness. Biometrics 44, 323-338.
</p>
</li>
<li> <p><b>Koopman, PAR (1984):</b> Confidence Intervals for the Ratio of Two Binomial Proportions. Biometrics 40(2), 513-517.
</p>
</li>
<li> <p><b>Lawson R (2005)</b>: Small sample confidence intervals for the odds ratio. Communication in Statistics Simulation and Computation, 33, 1095-1113.
</p>
</li>
<li> <p><b>Miettinen O and Nurminen M (1985):</b> Comparative Analysis of Two Rates. Statistics in Medicine 4, 213-226.
</p>
</li>
<li> <p><b>Newcombe RG (1998):</b> Interval Estimation for the Difference Between Independent Proportions: Comparison of Eleven Methods. Statistics in Medicine 17, 873-890. 
</p>
</li>
<li> <p><b>Venables WN and Ripley BD (2002). Modern Applied Statistics with S. Fourth Edition. Springer New York.</b> 
</p>
</li></ul>



<h3>See Also</h3>

<p>An alternative implementation of the Score interval for the risk ratio in package <kbd>propCIs</kbd>, function <kbd>riskscoreci</kbd>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The rooting data.

data(rooting)

# the first comparison should be the same as:

Age5_PosB_IBA0 &lt;- subset(rooting,
 Age=="5" &amp; Position=="B" &amp; IBA=="0")[,c("root", "noroot")]
Age5_PosB_IBA0.5 &lt;- subset(rooting,
 Age=="5" &amp; Position=="B" &amp; IBA=="0.5")[,c("root", "noroot")]

Age5_PosB_IBA0
Age5_PosB_IBA0.5

Prop.diff(x=Age5_PosB_IBA0, y=Age5_PosB_IBA0.5)

Prop.ratio(x=Age5_PosB_IBA0, y=Age5_PosB_IBA0.5)

Prop.or(x=Age5_PosB_IBA0, y=Age5_PosB_IBA0.5)

# is the same as input two vectors x,y each containing
# the count of successes and the count of failures

 colSums(Age5_PosB_IBA0)
 colSums(Age5_PosB_IBA0.5)

Prop.diff(x=c(16,32),y=c(29,19))

Prop.ratio(x=c(16,32),y=c(29,19))

Prop.or(x=c(16,32),y=c(29,19))

# # # 

# Comparison with original publications:

# I. Risk difference:

# Continuity corrected interval:

# 1.Comparison with results presented in Newcombe (1998),
# Table II, page 877, 10. Score, CC
# column 1 (a): 56/70-48/80: [0.0441; 0.3559]

Prop.diff(x=c(56,70-56),y=c(48,80-48), alternative="two.sided",
 conf.level=0.95, CImethod="CC")


# Risk difference, NHS
# Newcombes Hybrid Score interval:

# 1.Comparison with results presented in Newcombe (1998),
# Table II, page 877, 10. Score, noCC
# column 1 (a): 56/70-48/80: [0.0524; 0.3339]


Prop.diff(x=c(56,70-56),y=c(48,80-48), alternative="two.sided",
 conf.level=0.95, CImethod="NHS")

Prop.diff(x=c(56,70-56),y=c(48,80-48), alternative="greater",
 conf.level=0.975, CImethod="NHS")

Prop.diff(x=c(56,70-56),y=c(48,80-48), alternative="less",
 conf.level=0.975, CImethod="NHS")


# 2.Comparison with results presented in Newcombe (1998),
# Table II, page 877, 10. Score, noCC
# column 2 (b): 9/10-3/10: [0.1705; 0.8090]

Prop.diff(x=c(9,1),y=c(3,7), alternative="two.sided",
 conf.level=0.95, CImethod="NHS")


# 3.Comparison with results presented in Newcombe (1998),
# Table II, page 877, 10. Score, noCC
# column 2 (h): 10/10-0/10: [0.6075; 1.000]

Prop.diff(x=c(10,0),y=c(0,10), alternative="two.sided",
 conf.level=0.95, CImethod="NHS")


# II. Risk ratio,
# Score interval according to Koopman(1984), Gart and Nam (1988)

# 1.Comparison with results presented in Gart and Nam (1998),
# Section 5 (page 327), Example 1
# x1/n1=8/15 x0/n0=4/15:
# Log: [0.768, 4.65]
# Score: [0.815; 5.34]

# Log (GNC)
Prop.ratio(x=c(8,7),y=c(4,11), alternative="two.sided",
 conf.level=0.95, CImethod="GNC")

# Score (Score)
Prop.ratio(x=c(8,7),y=c(4,11), alternative="two.sided",
 conf.level=0.95, CImethod="Score")

Prop.ratio(x=c(8,7),y=c(4,11), alternative="less",
 conf.level=0.975, CImethod="Score")

Prop.ratio(x=c(8,7),y=c(4,11), alternative="greater",
 conf.level=0.975, CImethod="Score")



# 2.Comparison with results presented in Gart and Nam (1998),
# Section 5 (page 328), Example 2
# x1/n1=6/10 x0/n0=6/20:
# Crude Log: [0.883, 4.32]
# Score: [0.844; 4.59]

Prop.ratio(x=c(6,4),y=c(6,14), alternative="two.sided",
 conf.level=0.95, CImethod="GNC")

Prop.ratio(x=c(6,4),y=c(6,14), alternative="two.sided",
 conf.level=0.95, CImethod="Score")


# Koopman (1984), page 517
# x1=36, n1=40, x0=16, n0=80: [2.94, 7.15]

Prop.ratio(x=c(36, 4), y=c(16, 64), CImethod="Score")$conf.int 


# Miettinen, Nurminen (1985) p. 217 (Example 6): 
# x1=10, n1=10, x0=20, n0=20: [0.72, 1.20]

Prop.ratio(x=c(10, 0), y=c(20, 0), CImethod="MNScore")$conf.int


# MOVER-R Wilson in Newcombe and Fagerland, 2013, Table VIII:
#  x1=24, n1=73,x0=53, n0=65: [0.282, 0.563]
Prop.ratio(x=c(24, 49), y=c(53, 12), CImethod="MOVER")$conf.int 

#  x1=29, n1=55, x0=11, n0=11: [0.398, 0.761]
Prop.ratio(x=c(29, 26), y=c(11,0), CImethod="MOVER")$conf.int 

#  x1=7, n1=18, x0=1, n0=18: [(1.27, 40.8)]
Prop.ratio(x=c(7, 11), y=c(1, 17), CImethod="MOVER")$conf.int 


 </code></pre>

<hr>
<h2 id='pairwiseMEP'>Wrapper to compute confidence intervals for multiple endpoints</h2><span id='topic+pairwiseMEP'></span><span id='topic+pairwiseMEP.data.frame'></span>

<h3>Description</h3>

<p>This is a test version!
Computes confidence intervals for pair wise comparisons of groups (assuming independent observations)
for multiple endpoints. The methods available in pairwiseCI for continuous and count data can be called. Methods for
binary data are currently not available. NOTE: Although multiple endpoints and multiple group wise comparisons are considered, there
is no adjustment for multiplicity implemented in this function! 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pairwiseMEP(x, ...)

## S3 method for class 'data.frame'
pairwiseMEP(x, ep, f,
 control = NULL, conf.level = 0.95, 
 alternative = c("two.sided", "less", "greater"), 
 method = "Param.diff", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseMEP_+3A_x">x</code></td>
<td>
<p> a data.frame </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_ep">ep</code></td>
<td>
<p> a vector of character strings, naming the variables in <kbd>x</kbd> which are the response variables (endpoints) of interest </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_f">f</code></td>
<td>
<p> a single character string, naming a factor variable in data which splits the dataset into treatment groups </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_control">control</code></td>
<td>
<p> optionally, a single character string, naming a factor level in variable <kbd>f</kbd>, which shall be considered as control group; if omitted (default) all pairwise comparisons are computed </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_conf.level">conf.level</code></td>
<td>
<p> a single numeric between 0.5 and 1, specifying the local confidence level of the single confidence intervals</p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_alternative">alternative</code></td>
<td>
<p> a single character string, one of <kbd>'two.sided'</kbd>, <kbd>'less'</kbd>, <kbd>'greater'</kbd> </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_method">method</code></td>
<td>
<p> a vector of character strings, specifying the method for computation of the confidence intervals, see <code><a href="#topic+pairwiseCImethodsCont">pairwiseCImethodsCont</a></code> and <code><a href="#topic+pairwiseCImethodsCount">pairwiseCImethodsCount</a></code> for possible options;
must have length 1 or the same length as <kbd>ep</kbd>! </p>
</td></tr>
<tr><td><code id="pairwiseMEP_+3A_...">...</code></td>
<td>
<p>  further arguments to be passed to <code><a href="#topic+pairwiseCI">pairwiseCI</a></code>, options are listed in <code><a href="#topic+pairwiseCImethodsCont">pairwiseCImethodsCont</a></code> and <code><a href="#topic+pairwiseCImethodsCount">pairwiseCImethodsCount</a></code>   </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code>pairwiseCI</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>conf.int</code></td>
<td>
<p> a list with one element for each element in <kbd>ep</kbd>, containing the estimates, lower and upper limits and the comparison names and by levels in the format of a data.frame </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> as input <kbd>x</kbd> </p>
</td></tr>
<tr><td><code>ep</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> as input </p>
</td></tr>
</table>


<h3>See Also</h3>

<p> The result can be plotted: <code><a href="#topic+plotCI.pairwiseMEP">plotCI.pairwiseMEP</a></code>,
and coerced to a data.frame: <code><a href="#topic+as.data.frame.pairwiseMEP">as.data.frame.pairwiseMEP</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1&lt;-rnorm(80,100,8)
x2&lt;-rnbinom(80,mu=10, size=10)
A&lt;-rep(c("a1","a2"), c(40,40))
B&lt;-rep(rep(c("b1","b2"), c(20,20)), times=2)
dat&lt;-data.frame(x1=x1,x2=x2,A=A, B=B)

test&lt;-pairwiseMEP(x=dat, ep=c("x1","x2"), control="a1",
 f="A", by="B", method=c("Param.ratio","Negbin.ratio"))
test


plotCI(test, whichep=c("x1","x2"))

as.data.frame(test, whichep=c(1,2))

as.data.frame(test, whichep=c("x1","x2"))


</code></pre>

<hr>
<h2 id='pairwiseTest'>Wrapper to calculate unadjusted p-values for pairwise comparisons</h2><span id='topic+pairwiseTest'></span>

<h3>Description</h3>

<p>Calculation of raw p-values for pairwise comparisons of several groups.
The data can be split by additional factors. Any test function can be used,
that takes two samples x,y as input and returns a list containing the p.value in an element named <kbd>p.value</kbd>.
The output of this function might be further processed using <kbd>p.adjust</kbd> in order to adjust for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseTest(formula, data, by = NULL,
 method = "t.test", control = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseTest_+3A_formula">formula</code></td>
<td>
<p> a formula specifiying the response and the factor variable: <kbd>response ~ factor</kbd>  </p>
</td></tr>
<tr><td><code id="pairwiseTest_+3A_data">data</code></td>
<td>
<p> a data frame, containing the variables specified in <kbd>formula</kbd> </p>
</td></tr>
<tr><td><code id="pairwiseTest_+3A_by">by</code></td>
<td>
<p> optional vector of character strings, defining factors by which to split the data set.
Then, pairwise comparisons are performed separately for each level of the specified factors.</p>
</td></tr>
<tr><td><code id="pairwiseTest_+3A_method">method</code></td>
<td>
<p> character string, giving the name of the function, which shall be used to calculate local p-values. Any function,
taking two vectors x, and y as first arguments and returning a list with the p.value in a list element named <kbd>p.value</kbd> can be specified.</p>
</td></tr>
<tr><td><code id="pairwiseTest_+3A_control">control</code></td>
<td>
<p> optional character string, defining the name of a control group.
Must be one of the levels of the factor variable defined in <kbd>formula</kbd>.
By default control=NULL, then all pairwise comparisons between the levels of the factor variable are computed.  </p>
</td></tr>
<tr><td><code id="pairwiseTest_+3A_...">...</code></td>
<td>
<p> Arguments to be passed the function defined in <kbd>method</kbd>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits the response variable according to the factor(s) specified in <kbd>by</kbd>, and within each subset
according to the grouping variable specified in <kbd>formula</kbd>. The function specified in <kbd>method</kbd> is called
to calculate a p.value for all pairwise comparisons of between the subsets, within each level of <kbd>by</kbd>.
The p-values are NOT adjusted for multiple hypothesis testing.
</p>
<p>For binomial proportions, only <kbd>"Prop.test"</kbd> can be specified in the argument <kbd>method</kbd>;
For continous variables, any function can be specified, which takes <kbd>x</kbd> and <kbd>y</kbd> as first arguments,
and returns a list containing a list containing the appropriate p-value in the element named <kbd>p.value</kbd>
(as do the functions of class <kbd>"htest"</kbd>). See the examples for details. 
</p>


<h3>Value</h3>

<p>A named list with elements
</p>
<table role = "presentation">
<tr><td><code>byout</code></td>
<td>
<p>a list, containing the output of pairwiseTestint for each level of by,
i.e. a data.frame containing with columns <kbd>p.value</kbd>,<kbd>compnames</kbd> <kbd>groupx</kbd>, <kbd>groupy</kbd></p>
</td></tr>
<tr><td><code>bynames</code></td>
<td>
<p>a character vector containing the names of the levels of the factors specified in <kbd>by</kbd> </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string, name of the function used</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code>by</code></td>
<td>
<p>vector of character strings, same as  argument <kbd>by</kbd></p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>further arguments that were passed to <kbd>FUN</kbd></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Frank Schaarschmidt </p>


<h3>See Also</h3>

 
<p>You can use <code><a href="#topic+summary.pairwiseTest">summary.pairwiseTest</a></code> to calculate multiplicity adjusted p-values from the output of pairwiseTest.
</p>
<p>The following methods provide multiplicity adjusted p-values for various situations:
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>, <code><a href="stats.html#topic+pairwise.prop.test">pairwise.prop.test</a></code>, <kbd>\link{p.adjust}</kbd>,
<kbd>summary.glht(multcomp)</kbd>, <kbd>simtest.ratio(mratios)</kbd>   </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#######################################################
# The rooting example:
# Calculate confidence intervals for the 
# difference of proportions between the 3 doses of IBA,
# separately for 4 combinations of "Age" and "Position".
# Note: we pool over Rep in that way. Whether this makes
# sense or not, is decision of the user.

data(rooting)

# Pairwise Chi-square tests:

aproots&lt;-pairwiseTest(cbind(root, noroot) ~ IBA,
 data=rooting, by=c("Age", "Position"), method="Prop.test")

aproots

# With Holm adjustment for multiple hypotheses testing:

summary(aproots, p.adjust.method="holm")


#########################################################

data(Oats)


apc &lt;- pairwiseTest(yield ~ nitro, data=Oats,
 by="Variety", method="wilcox.test")

apc

summary(apc)
summary(apc, p.adjust.method="holm")

  </code></pre>

<hr>
<h2 id='pairwiseTestInt'>Internal functions for pairwiseTest</h2><span id='topic+pairwiseTestInt'></span><span id='topic+pairwiseTestProp'></span><span id='topic+pairwiseTestCont'></span>

<h3>Description</h3>

<p> Only for internal use by pairwiseTest.
Two different functions for data representable as a two numeric vectors (pairwiseTestCont) and
data representable as matrix with two columns (pairwiseTestProp) as created can be done with a formula
like <kbd>cbind(successes, failures) ~ group</kbd>.
Functions that split up a data.frame according to one factor, and perform all pairwise comparisons
and comparisons to control among the levels of the factor by calling functions that can deal with two vectors x and y
or the one documented in ?Prop.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pairwiseTestCont(formula, data, control=NULL, method, ...)
pairwiseTestProp(formula, data, control=NULL, method, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseTestInt_+3A_formula">formula</code></td>
<td>
<p> a formula specifiying the response and the factor variable: <kbd>response ~ factor</kbd>  </p>
</td></tr>
<tr><td><code id="pairwiseTestInt_+3A_data">data</code></td>
<td>
<p> a data frame, containing the variables specified in <kbd>formula</kbd> </p>
</td></tr>
<tr><td><code id="pairwiseTestInt_+3A_method">method</code></td>
<td>
<p> character string, giving the name of the function, which shall be used to calculate local p-values. Any function,
taking two vectors x, and y as first arguments and returning a list with the p.value in a list element named <kbd>p.value</kbd> can be specified.</p>
</td></tr>
<tr><td><code id="pairwiseTestInt_+3A_control">control</code></td>
<td>
<p> optional character string, defining the name of a control group.
Must be one of the levels of the factor variable defined in <kbd>formula</kbd>.
By default control=NULL, then all pairwise comparisons between the levels of the factor variable are computed.  </p>
</td></tr>
<tr><td><code id="pairwiseTestInt_+3A_...">...</code></td>
<td>
<p> Arguments to be passed the function defined in <kbd>method</kbd>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use in pairwiseTest.
</p>


<h3>Value</h3>

<p>a data.frame containing the columns
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>numeric vector: the p.values</p>
</td></tr>
<tr><td><code>compnames</code></td>
<td>
<p>character vector: the names of the comparisons performed</p>
</td></tr>
<tr><td><code>groupx</code></td>
<td>
<p>character vector: the names of the first group</p>
</td></tr>
<tr><td><code>groupy</code></td>
<td>
<p>character vector: the names of the second group</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+pairwiseTest">pairwiseTest</a></code> for a user level function, 
and 
<code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>, <code><a href="stats.html#topic+pairwise.prop.test">pairwise.prop.test</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> for further functions to calculate multiplicity adjusted p-values.  </p>

<hr>
<h2 id='plot.pairwiseCI'>Plotting the output of pairwiseCI</h2><span id='topic+plot.pairwiseCI'></span>

<h3>Description</h3>

<p>Easy method for plotting estimates and confidence bounds calculated using <code><a href="#topic+pairwiseCI">pairwiseCI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseCI'
plot(x,
 CIvert=NULL, CIlty = 1, CIlwd=1, CIcex=1,
 H0line=NULL, H0lty=1, H0lwd=1,
 main=NULL, ylab="", xlab="",
 ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pairwiseCI_+3A_x">x</code></td>
<td>
<p> an object of class &quot;pairwiseCI&quot;, the output of function <kbd>\link{pairwiseCI}</kbd> </p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_civert">CIvert</code></td>
<td>
<p> logical, whether confidence intervals shall be plotted vertical if <kbd>CIvert=TRUE</kbd> and horizontal if <kbd>CIvert=FALSE</kbd> </p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_cilty">CIlty</code></td>
<td>
<p> integer, giving the line type of the CI, as documented for <kbd>cex</kbd> in <kbd>?par</kbd></p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_cilwd">CIlwd</code></td>
<td>
<p> integer, giving the line width of the CI, as documented for <kbd>lwd</kbd> <kbd>?par</kbd></p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_cicex">CIcex</code></td>
<td>
<p> numerical value giving the size of CIsymbols relative to the default value, see <kbd>cex</kbd> in <kbd>?par</kbd> </p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_h0line">H0line</code></td>
<td>
<p> Value to be plotted as vertical or horizontal line, depending on the value of <kbd>CIvert</kbd></p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_h0lty">H0lty</code></td>
<td>
<p> integer, giving the line type of the CI, as documented for <kbd>lty</kbd> in <kbd>?par</kbd></p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_h0lwd">H0lwd</code></td>
<td>
<p> integer, giving the line width of the CI, as documented for <kbd>lwd</kbd> in <kbd>?par</kbd></p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_main">main</code></td>
<td>
<p> as <kbd>main</kbd> in <kbd>plot</kbd>  </p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_ylab">ylab</code></td>
<td>
<p> label of y-axis as <kbd>ylab</kbd> in <kbd>plot</kbd>, default is no label</p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_xlab">xlab</code></td>
<td>
<p> label of x-axis as <kbd>ylab</kbd> in <kbd>plot</kbd>, default is no label </p>
</td></tr>
<tr><td><code id="plot.pairwiseCI_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <kbd>axis</kbd>. Note, that arguments <kbd>las</kbd>, <kbd>at</kbd>, <kbd>labels</kbd> are defined internally and can not be set via ... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Frank Schaarschmidt </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Oats)

output &lt;- pairwiseCI(yield ~ Block, data=Oats,
 by="nitro",method="Param.diff", control="I")

# default plot for difference methods:
plot(output)

# some small changes:
plot(output, CIvert=TRUE, H0line=c(-2,0,2), H0lty=c(2,1,2))

output &lt;- pairwiseCI(yield ~ Block, data=Oats,
 by="nitro", method="Param.ratio", control="I")

# default plot for ratio methods:
plot(output)

# some small changes:
plot(output, CIvert=FALSE, H0line=c(0.7, 1, 1/0.7),
 H0lty=c(3,2,3))

</code></pre>

<hr>
<h2 id='plotCI.methods'> Plot confidence intervals</h2><span id='topic+plotCI.pairwiseMEP'></span><span id='topic+plotCI.pairwiseCI'></span>

<h3>Description</h3>

<p>Creates plot of confidence intervals calculated by calling &quot;pairwiseMEP&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseCI'
plotCI(x, ...)
## S3 method for class 'pairwiseMEP'
plotCI(x, whichep = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCI.methods_+3A_x">x</code></td>
<td>
<p> an object of class <kbd>'pairwiseMEP'</kbd> or <kbd>'pairwiseCI'</kbd></p>
</td></tr>
<tr><td><code id="plotCI.methods_+3A_whichep">whichep</code></td>
<td>
<p> an optional vector of character strings (or integers); specifying the names (or indices in the element <kbd>conf.int</kbd> of the list returned by <kbd>pairwiseMEP</kbd>) of those response variables for which the confidence intervals shall be plotted </p>
</td></tr>
<tr><td><code id="plotCI.methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <kbd>plotCI</kbd> in package <span class="pkg">MCPAN</span>, see <kbd>?plotCI</kbd> for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x1&lt;-rnorm(120,20,2)
x2&lt;-rnorm(120,100,8)
x3&lt;-rpois(120,10)
A&lt;-rep(c("a1","a2","a3"), c(40,40,40))
B&lt;-rep(rep(c("b1","b2"), c(20,20)), times=3)
dat&lt;-data.frame(x1=x1,x2=x2,x3=x3,A=A, B=B)


test&lt;-pairwiseMEP(x=dat, ep=c("x1","x2","x3"),
 f="A", by="B", conf.level=0.9, control="a1",
 method=c("Param.ratio","Param.ratio","Poisson.ratio"))

plotCI(test, whichep=c("x1","x2"), lines=c(0.8,1.25))

plotCI(test, whichep=c(1,2,3))


</code></pre>

<hr>
<h2 id='print.pairwiseCI'> Print function for &quot;pairwiseCI&quot; </h2><span id='topic+print.pairwiseCI'></span>

<h3>Description</h3>

<p>Print out confidence intervals calculated using pairwiseCI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseCI'
print(x , digits=4, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pairwiseCI_+3A_x">x</code></td>
<td>
<p> an object of class &quot;pairwiseCI&quot;, the output of function pairwiseCI() </p>
</td></tr>
<tr><td><code id="print.pairwiseCI_+3A_digits">digits</code></td>
<td>
<p> integer, to which decimal output shall be rounded </p>
</td></tr>
<tr><td><code id="print.pairwiseCI_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <kbd>print</kbd></p>
</td></tr>
</table>

<hr>
<h2 id='print.pairwiseTest'> Print function for &quot;pairwiseTest&quot; </h2><span id='topic+print.pairwiseTest'></span>

<h3>Description</h3>

<p>Print function for pairwiseTest objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseTest'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pairwiseTest_+3A_x">x</code></td>
<td>
<p> an object of class &quot;pairwiseTest&quot; </p>
</td></tr>
<tr><td><code id="print.pairwiseTest_+3A_digits">digits</code></td>
<td>
<p> digits for rounding </p>
</td></tr>
<tr><td><code id="print.pairwiseTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <kbd>print</kbd></p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.pairwiseCI'> Print function for &quot;summary.pairwiseCI&quot; </h2><span id='topic+print.summary.pairwiseCI'></span>

<h3>Description</h3>

<p>Print function for summary.pairwiseCI 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pairwiseCI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.pairwiseCI_+3A_x">x</code></td>
<td>
<p> an object of class &quot;summary.pairwiseCI&quot;, created by the function <code><a href="#topic+summary.pairwiseCI">summary.pairwiseCI</a></code> </p>
</td></tr>
<tr><td><code id="print.summary.pairwiseCI_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <kbd>print</kbd> </p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.pairwiseTest'> Print function for &quot;summary.pairwiseTest&quot; </h2><span id='topic+print.summary.pairwiseTest'></span>

<h3>Description</h3>

<p>Print function for summary.pairwiseCI 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pairwiseTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.pairwiseTest_+3A_x">x</code></td>
<td>
<p> an object of class &quot;summary.pairwiseTest&quot;, created by the function <code><a href="#topic+summary.pairwiseTest">summary.pairwiseTest</a></code> </p>
</td></tr>
<tr><td><code id="print.summary.pairwiseTest_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <kbd>print</kbd> </p>
</td></tr>
</table>

<hr>
<h2 id='profileDG'> Construct a (quasi-) likelihood-profile </h2><span id='topic+profileDG'></span>

<h3>Description</h3>

<p>Construct a (quasi-) likelihood-profile based on a glm-fit. For internal use for functions constructing profile-likelihood confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileDG(fit, steps = 100, wh = 1:p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profileDG_+3A_fit">fit</code></td>
<td>
<p> an object of class <kbd>"glm"</kbd> or <kbd>"negbin"</kbd></p>
</td></tr>
<tr><td><code id="profileDG_+3A_steps">steps</code></td>
<td>
<p> a single integer value, the number of steps for the profile </p>
</td></tr>
<tr><td><code id="profileDG_+3A_wh">wh</code></td>
<td>
<p> wh </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adaptation of the code in <kbd>profile.glm</kbd>. Will work also for the case that only 0-values occur in one group.
For internal use
</p>


<h3>Value</h3>

<p>An object of class <kbd>"profile.glm"</kbd>, <kbd>"profile"</kbd>.
</p>


<h3>Author(s)</h3>

<p> Daniel Gerhard </p>

<hr>
<h2 id='Prop.test'> Wrapper to prop.test(stats)</h2><span id='topic+Prop.test'></span>

<h3>Description</h3>

<p>Only for internal use in pairwiseTest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prop.test(x, y, alternative = "two.sided", test=c("prop.test", "fisher.test"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Prop.test_+3A_x">x</code></td>
<td>
<p> a vector of success and failure in sample x,
or a data.frame with a column of successes and a column of failures, then colSums are used. </p>
</td></tr>
<tr><td><code id="Prop.test_+3A_y">y</code></td>
<td>
<p> a vector of success and failure in sample y,
or a data.frame with a column of successes and a column of failures, then colSums are used. </p>
</td></tr>
<tr><td><code id="Prop.test_+3A_alternative">alternative</code></td>
<td>
<p> character string defining the alternative hypothesis </p>
</td></tr>
<tr><td><code id="Prop.test_+3A_test">test</code></td>
<td>
<p> a single character string: which function to be called, choices are <kbd>"prop.test"</kbd> for the chi-square test, and &quot;fisher.test&quot; for Fishers exact test, as they are defined in package stats</p>
</td></tr>
<tr><td><code id="Prop.test_+3A_...">...</code></td>
<td>
<p> arguments to be passed to <kbd>prop.test(stats)</kbd> or <kbd>fisher.test(stats)</kbd> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just a wrapper function to call <kbd>prop.test(stats)</kbd>. 
If x, y are data.frames containing two columns taken to be counts of successes and counts of failures, columnwise sums of x,y are calculated.
The total number of successes and the total number of trials is then passed to prop.test.
</p>


<h3>Value</h3>

<p>An object of class &quot;htest&quot;, as defined by <kbd>prop.test(stats)</kbd>
</p>


<h3>See Also</h3>

<p><kbd>prop.test</kbd>, and <kbd>pairwise.prop.test</kbd> in <span class="pkg">stats</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# If input is a data.frame:

set.seed(1234)

trials=rep(20,8)
success &lt;- rbinom(n=8, size=trials,
 prob=c(0.2,0.2,0.2,0.2, 0.3,0.3,0.3,0.3))
failure &lt;- trials-success

f&lt;-as.factor(rep(c("group1", "group2"), each=4))

data&lt;-data.frame(success=success, failure=failure, f=f)

g1&lt;-subset(data, f=="group1")[,c("success","failure")]
g2&lt;-subset(data, f=="group2")[,c("success","failure")]

g1
g2

# Prop.test calculates the columnwise sums and calls prop.test stats:

Prop.test(x=g1, y=g2)

# should be the same as:

CS1&lt;-colSums(g1)
CS2&lt;-colSums(g2)

CS1
CS2

prop.test(x=c(CS1[1], CS2[1]), n=c(sum(CS1), sum(CS2)))

</code></pre>

<hr>
<h2 id='QBmover'>Confidence intervals for ratios of proportions based on the quasibinomial assumption</h2><span id='topic+QBmover'></span>

<h3>Description</h3>

<p>Confidence intervals for ratios of proportions with overdispersed binomial data in a one-factor quasibinomial generalized linear model.
Intervals are computed using the MOVER-R method on profile deviance intervals (as implemented in mcprofile) for the single proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QBmover(succ, fail, trt, conf.level = 0.95,
 alternative = "two.sided", grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QBmover_+3A_succ">succ</code></td>
<td>
<p>vector of counts of successes</p>
</td></tr>
<tr><td><code id="QBmover_+3A_fail">fail</code></td>
<td>
<p>vector of counts of failures</p>
</td></tr>
<tr><td><code id="QBmover_+3A_trt">trt</code></td>
<td>
<p>factor variable distinguishing the treatment groups</p>
</td></tr>
<tr><td><code id="QBmover_+3A_conf.level">conf.level</code></td>
<td>
<p>a single numeric value, the confidence level</p>
</td></tr>
<tr><td><code id="QBmover_+3A_alternative">alternative</code></td>
<td>
<p>a character string, <code>"two.sided"</code> for two-sided intervals, <code>"less"</code> for upper limits, <code>"greater"</code> for lower limits only</p>
</td></tr>
<tr><td><code id="QBmover_+3A_grid">grid</code></td>
<td>
<p>optional, a numeric vector to be supplied to the profiling used internally in <code>quasibin.ratio</code> to obtain profile deviance intervals for each samples proportion on the logit-scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with three columns
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>estimated ratios</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limits</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limits</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Experimental</p>


<h3>Author(s)</h3>

<p>Frank Schaarschmidt</p>


<h3>References</h3>

<p><em>Donner and Zou (2012):</em> Closed-form confidence intervals for functions of the normal mean and standard deviation. Statistical Methods in Medical Research 21(4):347-359.
<em>Gerhard (2014):</em> Simultaneous Small Sample Inference For Linear Combinations Of Generalized Linear Model Parameters. Communications in Statistics - Simulation and Computation. DOI:10.1080/03610918.2014.895836</p>


<h3>Examples</h3>

<pre><code class='language-R'>QBmover(succ=c(0,0,1,  0,6,8), fail=c(20,20,18, 20,14,12), 
 trt=factor(rep(c("A", "B"), c(3,3))), conf.level = 0.95,
 alternative = "two.sided", grid = NULL)

</code></pre>

<hr>
<h2 id='repellent'> Repellent effect of sulphur in eight concentrations</h2><span id='topic+repellent'></span>

<h3>Description</h3>

<p> Sugar solutions were presented to certain number of bees. To assess the repellent effect
of the fungicide sulphur of bees, increasing concentration of sulphur was added to the sugar solutions.
The decrease of sugar solutions (i.e. uptake by bees) was measured. Low values of decrease therefore can
be interpreted as high repellent effect of the sulphur concentration.
Assumed to be a completely randomized design. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(repellent)</code></pre>


<h3>Format</h3>

<p>A data frame with 64 observations on the following 2 variables.
</p>

<dl>
<dt><code>decrease</code></dt><dd><p>a numeric vector, the absolut decrease of sugar solutions from begin to end of the experiment</p>
</dd>
<dt><code>treatment</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code>, the concentration of sulphur</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(repellent)
boxplot(decrease ~ treatment, data=repellent)

</code></pre>

<hr>
<h2 id='rooting'>Rooting (success/failure) of plants in a 3-factorial field trial</h2><span id='topic+rooting'></span>

<h3>Description</h3>

<p>Part of an experiment on propagation of plant genera Acer and Pyrus.
Cuttings were taken from motherplants of age 5 and age 20, from top or base,
and were treated with 0, 0.5 and 2 percent IBA to induce rooting.
Treatments were arranged in a completely randomized design,
among other variables, the number of cuttings with and without roots was recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rooting)</code></pre>


<h3>Format</h3>

<p>A data frame with 48 observations on the following 6 variables.
</p>

<dl>
<dt><code>Age</code></dt><dd><p>a numeric vector: age of mother plants</p>
</dd>
<dt><code>Position</code></dt><dd><p>a factor with levels <code>B</code> and <code>T</code>, for &quot;base&quot; and &quot;top&quot; cuttings</p>
</dd>
<dt><code>IBA</code></dt><dd><p>a numeric vector, specifying the concentration of IBA</p>
</dd>
<dt><code>Rep</code></dt><dd><p>a numeric vector, number of replication</p>
</dd>
<dt><code>root</code></dt><dd><p>a numeric vector, number of cuttings with successfull rooting, out of 12 trials</p>
</dd>
<dt><code>noroot</code></dt><dd><p>a numeric vector, number of cuttings showing no rooting, out of 12 trials</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data taken from Msc thesis by Dawit Mamushet Yifru,
Institute of Floriculture,
Tree Nursery Science and Plant Breeding,
University of Hannover, 2005. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rooting)

rooting$IBAf&lt;-as.factor(rooting$IBA)
rooting$Rep&lt;-as.factor(rooting$Rep)

fitB&lt;-glm(cbind(root,noroot)~Rep+(Age + Position + IBA)^2,
 data=rooting, family=binomial)

fitQB&lt;-glm(cbind(root,noroot)~Rep+(Age + Position + IBA)^2,
 data=rooting, family=quasibinomial)

summary(fitB)
summary(fitQB)

anova(fitB, test="Chisq")
anova(fitQB, test="F")

</code></pre>

<hr>
<h2 id='sodium'>Sodium contents in transgenic and isogenic corn</h2><span id='topic+sodium'></span>

<h3>Description</h3>

<p>Sodium was measured in transgenic corn and the original isogenic corn variety.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sodium)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 2 variables.
</p>

<dl>
<dt><code>Treatment</code></dt><dd><p>a factor with levels <code>transgenic</code> <code>xisogenic</code></p>
</dd>
<dt><code>Sodiumcontent</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p><b>Oberdoerfer, R.B.</b> Example dataset from composition analyses of genetically modified oilseed rape seeds. 2003; BCS GmbH.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sodium)
boxplot(Sodiumcontent ~Treatment, data=sodium)

</code></pre>

<hr>
<h2 id='summary.pairwiseCI'> Summary function for pairwiseCI</h2><span id='topic+summary.pairwiseCI'></span>

<h3>Description</h3>

<p> Creates a list of data.frames from the output of pairwiseCI</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseCI'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pairwiseCI_+3A_object">object</code></td>
<td>
<p> An object of class <kbd>"pairwiseCI"</kbd>, created using the function <code><a href="#topic+pairwiseCI">pairwiseCI</a></code> </p>
</td></tr>
<tr><td><code id="summary.pairwiseCI_+3A_digits">digits</code></td>
<td>
<p> number of digits for rounding of results </p>
</td></tr>
<tr><td><code id="summary.pairwiseCI_+3A_...">...</code></td>
<td>
<p> Currently not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>See Also</h3>

 <p><code>link{as.data.frame.pairwiseCI}</code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rooting)

rootRR&lt;-pairwiseCI(cbind(root,noroot) ~ IBA,
 data=rooting, by="Age", method="Prop.ratio")

# after calling summary,
# extracting parts of the output is easier: 

srootRR&lt;-summary(rootRR)

srootRR$'20'$conf.int$upper

</code></pre>

<hr>
<h2 id='summary.pairwiseTest'> Summary function for &quot;pairwiseTest&quot; </h2><span id='topic+summary.pairwiseTest'></span>

<h3>Description</h3>

<p> Creates a data.frame from the output of pairwiseTest,
allows to adjust raw p-values by methods implemented in p.adjust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwiseTest'
summary(object, digits = 4,
 p.adjust.method = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pairwiseTest_+3A_object">object</code></td>
<td>
<p> An object of class &quot;pairwiseTest&quot;, created using the function <code><a href="#topic+pairwiseTest">pairwiseTest</a></code> </p>
</td></tr>
<tr><td><code id="summary.pairwiseTest_+3A_digits">digits</code></td>
<td>
<p> number of digits for rounding of results </p>
</td></tr>
<tr><td><code id="summary.pairwiseTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p> Method to adjust p-values for multiple hypothesis testing, see options in <kbd>p.adjust.method</kbd> in <span class="pkg">stats</span>.
The default in this function in &quot;none&quot;, resulting in unadjusted p-values</p>
</td></tr>
<tr><td><code id="summary.pairwiseTest_+3A_...">...</code></td>
<td>
<p> Currently not used. </p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>Coerces the raw p-values and the corresponding group levels to a data.frame and applies p.adjust to it. 
</p>


<h3>Value</h3>

<p>A dataframe, with columns
</p>
<table role = "presentation">
<tr><td><code>p.val.raw</code></td>
<td>
<p>raw p-values</p>
</td></tr>
<tr><td><code>p.val.adj</code></td>
<td>
<p>adjusted p-values, according to the method specified in <kbd>p.adjust.method</kbd> </p>
</td></tr>
<tr><td><code>comparison</code></td>
<td>
<p>the calculated differences or ratios of parameters</p>
</td></tr>
<tr><td><code>groupx</code></td>
<td>
<p>levels of group x</p>
</td></tr>
<tr><td><code>groupy</code></td>
<td>
<p>levels of group y</p>
</td></tr>
</table>
<p>and possibly further columns containing levels of by.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Oats)
apOats&lt;-pairwiseTest(yield~nitro, data=Oats,
 by="Variety", method="t.test", var.equal=FALSE)
apOats

# summary just creates a data.frame from the output
summary(apOats)

# an allows application of p.adjust
# on the p.values:

summary(apOats, p.adjust.method="holm")

# See ?p.adjust.methods for the methods available.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
