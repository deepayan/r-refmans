<!DOCTYPE html><html><head><title>Help for package SuperGauss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SuperGauss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acf2incr'><p>Convert position autocorrelations to increment autocorrelations.</p></a></li>
<li><a href='#acf2msd'><p>Convert autocorrelation of stationary increments to mean squared displacement of posititions.</p></a></li>
<li><a href='#Cholesky'><p>Cholesky multiplication with Toeplitz variance matrices.</p></a></li>
<li><a href='#Circulant'><p>Constructor and methods for Circulant matrix objects.</p></a></li>
<li><a href='#dnormtz'><p>Density of a multivariate normal with Toeplitz variance matrix.</p></a></li>
<li><a href='#fbm_msd'><p>Mean square displacement of fractional Brownian motion.</p></a></li>
<li><a href='#matern_acf'><p>Matern autocorrelation function.</p></a></li>
<li><a href='#msd2acf'><p>Convert mean square displacement of positions to autocorrelation of increments.</p></a></li>
<li><a href='#NormalCirculant'><p>Multivariate normal with Circulant variance matrix.</p></a></li>
<li><a href='#NormalToeplitz'><p>Multivariate normal with Toeplitz variance matrix.</p></a></li>
<li><a href='#pex_acf'><p>Power-exponential autocorrelation function.</p></a></li>
<li><a href='#rnormtz'><p>Simulate a stationary Gaussian time series.</p></a></li>
<li><a href='#SuperGauss-defunct'><p>Defunct functions in <span class="pkg">SuperGauss</span>.</p></a></li>
<li><a href='#SuperGauss-package'><p>Superfast inference for stationary Gaussian time series.</p></a></li>
<li><a href='#toep.mult'><p>Toeplitz matrix multiplication.</p></a></li>
<li><a href='#Toeplitz'><p>Constructor and methods for Toeplitz matrix objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Superfast Likelihood Inference for Stationary Gaussian Time
Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood evaluations for stationary Gaussian time series are typically obtained via the Durbin-Levinson algorithm, which scales as O(n^2) in the number of time series observations.  This package provides a "superfast" O(n log^2 n) algorithm written in C++, crossing over with Durbin-Levinson around n = 300.  Efficient implementations of the score and Hessian functions are also provided, leading to superfast versions of inference algorithms such as Newton-Raphson and Hamiltonian Monte Carlo.  The C++ code provides a Toeplitz matrix class packaged as a header-only library, to simplify low-level usage in other packages and outside of R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, R6, Rcpp (&ge; 0.12.7), fftw</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, mvtnorm, numDeriv</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw3 (&gt;= 3.1.2)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-24 19:11:11 UTC; mlysy</td>
</tr>
<tr>
<td>Author:</td>
<td>Yun Ling [aut],
  Martin Lysy [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Lysy &lt;mlysy@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-24 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acf2incr'>Convert position autocorrelations to increment autocorrelations.</h2><span id='topic+acf2incr'></span>

<h3>Description</h3>

<p>Convert the autocorrelation of a stationary sequence <code style="white-space: pre;">&#8288;x = (x_1, ..., x_N)&#8288;</code> to that of its increments, <code style="white-space: pre;">&#8288;dx = (x_2 - x_1, ..., x_N - x_(N-1))&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf2incr(acf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf2incr_+3A_acf">acf</code></td>
<td>
<p>Length-<code>N</code> vector of position autocorrelations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length <code>N-1</code> vector of increment autocorrelations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acf2incr(acf = exp(-(0:10)))
</code></pre>

<hr>
<h2 id='acf2msd'>Convert autocorrelation of stationary increments to mean squared displacement of posititions.</h2><span id='topic+acf2msd'></span>

<h3>Description</h3>

<p>Converts the autocorrelation of a stationary increment sequence <code style="white-space: pre;">&#8288;dx = (x_1 - x_0, ..., x_N - x_(N-1))&#8288;</code> to the mean squared displacement (MSD) of the corresponding positions, i.e., <code>MSD_i = E[(x_i - x_0)^2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf2msd(acf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf2msd_+3A_acf">acf</code></td>
<td>
<p>Length-<code>N</code> autocorrelation vector of a stationary increment sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-<code>N</code> MSD vector of the corresponding positions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acf2msd(acf = exp(-(0:10)))
</code></pre>

<hr>
<h2 id='Cholesky'>Cholesky multiplication with Toeplitz variance matrices.</h2><span id='topic+Cholesky'></span><span id='topic+cholXZ'></span><span id='topic+cholZX'></span>

<h3>Description</h3>

<p>Multiplies the Cholesky decomposition of the Toeplitz matrix with another matrix, or solves a system of equations with the Cholesky factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholZX(Z, acf)

cholXZ(X, acf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cholesky_+3A_z">Z</code></td>
<td>
<p>Length-<code>N</code> or <code style="white-space: pre;">&#8288;N x p&#8288;</code> matrix of residuals.</p>
</td></tr>
<tr><td><code id="Cholesky_+3A_acf">acf</code></td>
<td>
<p>Length-<code>N</code> autocorrelation vector of the Toeplitz variance matrix.</p>
</td></tr>
<tr><td><code id="Cholesky_+3A_x">X</code></td>
<td>
<p>Length-<code>N</code> or <code style="white-space: pre;">&#8288;N x p&#8288;</code> matrix of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>C == t(chol(toeplitz(acf)))</code>, then <code>cholZX()</code> computes <code>C %*% Z</code> and <code>cholZX()</code> computes <code>solve(C, X)</code>.  Both functions use the Durbin-Levinson algorithm.
</p>


<h3>Value</h3>

<p>Size <code style="white-space: pre;">&#8288;N x p&#8288;</code> residual or observation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 10
p &lt;- 2
acf &lt;- exp(-(1:N - 1))

Z &lt;- matrix(rnorm(N * p), N, p)
cholZX(Z = Z, acf = acf) - (t(chol(toeplitz(acf))) %*%  Z)

X &lt;- matrix(rnorm(N * p), N, p)
cholXZ(X = X, acf = acf) - solve(t(chol(toeplitz(acf))), X)
</code></pre>

<hr>
<h2 id='Circulant'>Constructor and methods for Circulant matrix objects.</h2><span id='topic+Circulant'></span>

<h3>Description</h3>

<p>Constructor and methods for Circulant matrix objects.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Circulant$new()</code></a>
</p>
</li>
<li> <p><a href="#method-size"><code>Circulant$size()</code></a>
</p>
</li>
<li> <p><a href="#method-set_acf"><code>Circulant$set_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-get_acf"><code>Circulant$get_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-set_psd"><code>Circulant$set_psd()</code></a>
</p>
</li>
<li> <p><a href="#method-get_psd"><code>Circulant$get_psd()</code></a>
</p>
</li>
<li> <p><a href="#method-has_acf"><code>Circulant$has_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-prod"><code>Circulant$prod()</code></a>
</p>
</li>
<li> <p><a href="#method-solve"><code>Circulant$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-log_det"><code>Circulant$log_det()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Circulant$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$new(N, uacf, upsd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>Size of Circulant matrix.</p>
</dd>
<dt><code>uacf</code></dt><dd><p>Optional vector of <code>Nu = floor(N/2)+1</code> unique elements of the autocorrelation.</p>
</dd>
<dt><code>upsd</code></dt><dd><p>Optional vector of <code>Nu = floor(N/2)+1</code> unique elements of the PSD.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circulant</code> object.
</p>


<hr>
<a id="method-size"></a>



<h4>Method <code>size()</code></h4>

<p>Get the size of the Circulant matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$size()</pre></div>



<h5>Returns</h5>

<p>Size of the Circulant matrix.
</p>


<hr>
<a id="method-set_acf"></a>



<h4>Method <code>set_acf()</code></h4>

<p>Set the autocorrelation of the Circulant matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$set_acf(uacf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uacf</code></dt><dd><p>Vector of <code>Nu = floor(N/2)+1</code> unique elements of the autocorrelation.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-get_acf"></a>



<h4>Method <code>get_acf()</code></h4>

<p>Get the autocorrelation of the Circulant matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$get_acf()</pre></div>



<h5>Returns</h5>

<p>The complete autocorrelation vector of length <code>N</code>.
</p>


<hr>
<a id="method-set_psd"></a>



<h4>Method <code>set_psd()</code></h4>

<p>Set the PSD of the Circulant matrix.
</p>
<p>The power spectral density (PSD) of a Circulant matrix <code>Ct = Circulant(acf)</code> is defined as <code>psd = iFFT(acf)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$set_psd(upsd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>upsd</code></dt><dd><p>Vector of <code>Nu = floor(N/2)+1</code> unique elements of the psd.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-get_psd"></a>



<h4>Method <code>get_psd()</code></h4>

<p>Get the PSD of the Circulant matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$get_psd()</pre></div>



<h5>Returns</h5>

<p>The complete PSD vector of length <code>N</code>.
</p>


<hr>
<a id="method-has_acf"></a>



<h4>Method <code>has_acf()</code></h4>

<p>Check whether the autocorrelation of the Circulant matrix has been set.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$has_acf()</pre></div>



<h5>Returns</h5>

<p>Logical; <code>TRUE</code> if <code>Circulant$set_acf()</code> has been called.
</p>


<hr>
<a id="method-prod"></a>



<h4>Method <code>prod()</code></h4>

<p>Circulant matrix-matrix product.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$prod(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector or matrix with <code>N</code> rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The matrix product <code>Ct %*% x</code>.
</p>


<hr>
<a id="method-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve a Circulant system of equations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$solve(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Optional vector or matrix with <code>N</code> rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The solution in <code>z</code> to the system of equations <code>Ct %*% z = x</code>.  If <code>x</code> is missing, returns the inverse of <code>Ct</code>.
</p>


<hr>
<a id="method-log_det"></a>



<h4>Method <code>log_det()</code></h4>

<p>Calculate the log-determinant of the Circulant matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$log_det()</pre></div>



<h5>Returns</h5>

<p>The log-determinant <code>log(det(Ct))</code>.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circulant$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='dnormtz'>Density of a multivariate normal with Toeplitz variance matrix.</h2><span id='topic+dnormtz'></span>

<h3>Description</h3>

<p>Density of a multivariate normal with Toeplitz variance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnormtz(X, mu, acf, log = FALSE, method = c("gschur", "ltz"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnormtz_+3A_x">X</code></td>
<td>
<p>Vector of length <code>N</code> or <code style="white-space: pre;">&#8288;N x n&#8288;</code> matrix, of which each column is a multivariate observation.</p>
</td></tr>
<tr><td><code id="dnormtz_+3A_mu">mu</code></td>
<td>
<p>Vector or matrix of mean values of compatible dimensions with <code>X</code>.  Defaults to all zeros.</p>
</td></tr>
<tr><td><code id="dnormtz_+3A_acf">acf</code></td>
<td>
<p>Vector of length <code>N</code> containing the first column of the Toeplitz variance matrix.</p>
</td></tr>
<tr><td><code id="dnormtz_+3A_log">log</code></td>
<td>
<p>Logical; whether to return the multivariate normal density on the log scale.</p>
</td></tr>
<tr><td><code id="dnormtz_+3A_method">method</code></td>
<td>
<p>Which calculation method to use.  Choices are: <code>gschur</code> for a modified version of the Generalized Schur algorithm of Ammar &amp; Gragg (1988), or <code>ltz</code> for the Levinson-Trench-Zohar method.  The former scales as <code style="white-space: pre;">&#8288;O(N log^2 N)&#8288;</code> whereas the latter scales as <code>O(N^2)</code> and should only be used for <code>N &lt; 300</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <code>n</code> (log-)densities, one for each column of <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data
N &lt;- 10 # length of each time series
n &lt;- 3 # number of time series
theta &lt;- 0.1
lambda &lt;- 2
mu &lt;- theta^2 * rep(1, N)
acf &lt;- exp(-lambda * (1:N - 1))

X &lt;- rnormtz(n, acf = acf) + mu

# evaluate log-density
dnormtz(X, mu, acf, log = TRUE)
</code></pre>

<hr>
<h2 id='fbm_msd'>Mean square displacement of fractional Brownian motion.</h2><span id='topic+fbm_msd'></span>

<h3>Description</h3>

<p>Mean square displacement of fractional Brownian motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbm_msd(tseq, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbm_msd_+3A_tseq">tseq</code></td>
<td>
<p>Length-<code>N</code> vector of timepoints.</p>
</td></tr>
<tr><td><code id="fbm_msd_+3A_h">H</code></td>
<td>
<p>Hurst parameter (between 0 and 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean squared displacement (MSD) of a stochastic process <code>X_t</code> is defined as</p>
<pre>MSD(t) = E[(X_t - X_0)^2].
</pre>
<p>Fractional Brownian motion (fBM) is a continuous Gaussian process with stationary increments, such that its covariance function is entirely defined the MSD, which in this case is <code style="white-space: pre;">&#8288;MSD(t) = |t|^(2H)&#8288;</code>.
</p>


<h3>Value</h3>

<p>Length-<code>N</code> vector of mean square displacements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fbm_msd(tseq = 1:10, H = 0.4)
</code></pre>

<hr>
<h2 id='matern_acf'>Matern autocorrelation function.</h2><span id='topic+matern_acf'></span>

<h3>Description</h3>

<p>Matern autocorrelation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_acf(tseq, lambda, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_acf_+3A_tseq">tseq</code></td>
<td>
<p>Vector of <code>N</code> time points at which the autocorrelation is to be calculated.</p>
</td></tr>
<tr><td><code id="matern_acf_+3A_lambda">lambda</code></td>
<td>
<p>Timescale parameter.</p>
</td></tr>
<tr><td><code id="matern_acf_+3A_nu">nu</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matern autocorrelation is given by
</p>
<p style="text-align: center;"><code class="reqn">
\mathrm{\scriptsize ACF}(t) = \frac{2^{1-\nu}}{\Gamma(\nu)} \left(\sqrt{2\nu}\frac{t}{\lambda}\right)^\nu K_\nu\left(\sqrt{2\nu} \frac{t}{\lambda}\right),
</code>
</p>

<p>where <code class="reqn">K_\nu(x)</code> is the modified Bessel function of second kind.
</p>


<h3>Value</h3>

<p>An autocorrelation vector of length <code>N</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matern_acf(tseq = 1:10, lambda = 1, nu = 3/2)
</code></pre>

<hr>
<h2 id='msd2acf'>Convert mean square displacement of positions to autocorrelation of increments.</h2><span id='topic+msd2acf'></span>

<h3>Description</h3>

<p>Converts the mean squared displacement (MSD) of a stationary increments sequence <code style="white-space: pre;">&#8288;x = (x_0, x_1, ..., x_N)&#8288;</code> positions to the autocorrelation of the corresponding increments <code style="white-space: pre;">&#8288;dx = (x_1 - x_0, ..., x_N - x_(N-1))&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msd2acf(msd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msd2acf_+3A_msd">msd</code></td>
<td>
<p>Length-<code>N</code> MSD vector, i.e., excluding <code>x_0</code> which is assumed to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-<code>N</code> autocorrelation vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># autocorrelation of fBM increments
msd2acf(msd = fbm_msd(tseq = 0:10, H = .3))
</code></pre>

<hr>
<h2 id='NormalCirculant'>Multivariate normal with Circulant variance matrix.</h2><span id='topic+NormalCirculant'></span>

<h3>Description</h3>

<p>Provides methods for the Normal-Circulant (NCt) distribution, which for a random vector <code>z</code> of length <code>N</code> is defined as</p>
<pre>z ~ NCt(uacf)   &lt;=&gt;   z ~ Normal(0, toeplitz(acf)),
</pre>
<p>where <code>uacf</code> are the <code>Nu = floor(N/2)+1</code> unique elements of the autocorrelation vector <code>acf</code>, i.e.,</p>
<pre>acf = (uacf, rev(uacf[2:(Nu-1)]),   N even,
    = (uacf, rev(uacf[2:Nu])),      N odd.
</pre>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>NormalCirculant$new()</code></a>
</p>
</li>
<li> <p><a href="#method-size"><code>NormalCirculant$size()</code></a>
</p>
</li>
<li> <p><a href="#method-logdens"><code>NormalCirculant$logdens()</code></a>
</p>
</li>
<li> <p><a href="#method-grad_full"><code>NormalCirculant$grad_full()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>NormalCirculant$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCirculant$new(N)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>Size of the NCt random vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>NormalCirculant</code> object.
</p>


<hr>
<a id="method-size"></a>



<h4>Method <code>size()</code></h4>

<p>Get the size of the NCt random vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCirculant$size()</pre></div>



<h5>Returns</h5>

<p>Size of the NCt random vector.
</p>


<hr>
<a id="method-logdens"></a>



<h4>Method <code>logdens()</code></h4>

<p>Log-density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCirculant$logdens(z, uacf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument. A vector of length <code>N</code> or an <code style="white-space: pre;">&#8288;N x n_obs&#8288;</code> matrix where each column is an <code>N</code>-dimensional observation.</p>
</dd>
<dt><code>uacf</code></dt><dd><p>A vector of length <code>Nu = floor(N/2)</code> containing the first half of the autocorrelation (i.e., first row/column) of the Circulant variance matrix.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A scalar or vector of length <code>n_obs</code> containing the log-density of the NCt evaluated at its arguments.
</p>


<hr>
<a id="method-grad_full"></a>



<h4>Method <code>grad_full()</code></h4>

<p>Full gradient of log-density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCirculant$grad_full(z, uacf, calc_dldz = TRUE, calc_dldu = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument.  A vector of length <code>N</code>.</p>
</dd>
<dt><code>uacf</code></dt><dd><p>A vector of length <code>Nu = floor(N/2)</code> containing the first half of the autocorrelation (i.e., first row/column) of the Circulant variance matrix.</p>
</dd>
<dt><code>calc_dldz</code></dt><dd><p>Whether or not to calculate the gradient with respect to <code>z</code>.</p>
</dd>
<dt><code>calc_dldu</code></dt><dd><p>Whether or not to calculate the gradient with respect to <code>uacf</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt><code>ldens</code></dt><dd><p>The log-density evaluated at <code>z</code> and <code>uacf</code>.</p>
</dd>
<dt><code>dldz</code></dt><dd><p>The length-<code>N</code> gradient vector with respect to <code>z</code>, if <code>calc_dldz = TRUE</code>.</p>
</dd>
<dt><code>dldu</code></dt><dd><p>The length-<code>Nu = floor(N/2)+1</code> gradient vector with respect to <code>uacf</code>, if <code>calc_dldu = TRUE</code>.</p>
</dd>
</dl>



<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalCirculant$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='NormalToeplitz'>Multivariate normal with Toeplitz variance matrix.</h2><span id='topic+NormalToeplitz'></span>

<h3>Description</h3>

<p>Provides methods for the Normal-Toeplitz (NTz) distribution defined as</p>
<pre>z ~ NTz(acf)   &lt;=&gt;   z ~ Normal(0, toeplitz(acf)),
</pre>
<p>i.e., for a multivariate normal with mean zero and variance <code>Tz = toeplitz(acf)</code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>NormalToeplitz$new()</code></a>
</p>
</li>
<li> <p><a href="#method-size"><code>NormalToeplitz$size()</code></a>
</p>
</li>
<li> <p><a href="#method-logdens"><code>NormalToeplitz$logdens()</code></a>
</p>
</li>
<li> <p><a href="#method-grad"><code>NormalToeplitz$grad()</code></a>
</p>
</li>
<li> <p><a href="#method-hess"><code>NormalToeplitz$hess()</code></a>
</p>
</li>
<li> <p><a href="#method-grad_full"><code>NormalToeplitz$grad_full()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>NormalToeplitz$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$new(N)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>Size of the NTz random vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>NormalToeplitz</code> object.
</p>


<hr>
<a id="method-size"></a>



<h4>Method <code>size()</code></h4>

<p>Get the size of the NTz random vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$size()</pre></div>



<h5>Returns</h5>

<p>Size of the NTz random vector.
</p>


<hr>
<a id="method-logdens"></a>



<h4>Method <code>logdens()</code></h4>

<p>Log-density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$logdens(z, acf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument. A vector of length <code>N</code> or an <code style="white-space: pre;">&#8288;N x n_obs&#8288;</code> matrix where each column is an <code>N</code>-dimensional observation.</p>
</dd>
<dt><code>acf</code></dt><dd><p>A vector of length <code>N</code> containing the autocorrelation (i.e., first row/column) of the Toeplitz variance matrix.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A scalar or vector of length <code>n_obs</code> containing the log-density of the NTz evaluated at its arguments.
</p>


<hr>
<a id="method-grad"></a>



<h4>Method <code>grad()</code></h4>

<p>Gradient of the log-density with respect to parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$grad(z, dz, acf, dacf, full_out = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument.  A vector of length <code>N</code>.</p>
</dd>
<dt><code>dz</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta&#8288;</code> matrix containing the gradient <code>dz/dtheta</code>.</p>
</dd>
<dt><code>acf</code></dt><dd><p>A vector of length <code>N</code> containing the autocorrelation of the Toeplitz variance matrix.</p>
</dd>
<dt><code>dacf</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta&#8288;</code> matrix containing the gradient <code>dacf/dtheta</code>.</p>
</dd>
<dt><code>full_out</code></dt><dd><p>If <code>TRUE</code>, returns the log-density as well (see 'Value').</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of length <code>n_theta</code> containing the gradient of the NTz log-density with respect to <code>theta</code>, or a list with elements <code>ldens</code> and <code>grad</code> consisting of the log-density and the gradient vector.
</p>


<hr>
<a id="method-hess"></a>



<h4>Method <code>hess()</code></h4>

<p>Hessian of log-density with respect to parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$hess(z, dz, d2z, acf, dacf, d2acf, full_out = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument.  A vector of length <code>N</code>.</p>
</dd>
<dt><code>dz</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta&#8288;</code> matrix containing the gradient <code>dz/dtheta</code>.</p>
</dd>
<dt><code>d2z</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta x n_theta&#8288;</code> array containing the Hessian <code style="white-space: pre;">&#8288;d^2z/dtheta^2&#8288;</code>.</p>
</dd>
<dt><code>acf</code></dt><dd><p>A vector of length <code>N</code> containing the autocorrelation of the Toeplitz variance matrix.</p>
</dd>
<dt><code>dacf</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta&#8288;</code> matrix containing the gradient <code>dacf/dtheta</code>.</p>
</dd>
<dt><code>d2acf</code></dt><dd><p>An <code style="white-space: pre;">&#8288;N x n_theta x n_theta&#8288;</code> array containing the Hessian <code>dacf^2/dtheta^2</code>.</p>
</dd>
<dt><code>full_out</code></dt><dd><p>If <code>TRUE</code>, returns the log-density and its gradient as well (see 'Value').</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code style="white-space: pre;">&#8288;n_theta x n_theta&#8288;</code> matrix containing the Hessian of the NTz log-density with respect to <code>theta</code>, or a list with elements <code>ldens</code>, <code>grad</code>, and <code>hess</code> consisting of the log-density, its gradient (a vector of size <code>n_theta</code>), and the Hessian matrix, respectively.
</p>


<hr>
<a id="method-grad_full"></a>



<h4>Method <code>grad_full()</code></h4>

<p>Full gradient of log-density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$grad_full(z, acf, calc_dldz = TRUE, calc_dlda = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>z</code></dt><dd><p>Density argument.  A vector of length <code>N</code>.</p>
</dd>
<dt><code>acf</code></dt><dd><p>A vector of length <code>N</code> containing the autocorrelation of the Toeplitz variance matrix.</p>
</dd>
<dt><code>calc_dldz</code></dt><dd><p>Whether or not to calculate the gradient with respect to <code>z</code>.</p>
</dd>
<dt><code>calc_dlda</code></dt><dd><p>Whether or not to calculate the gradient with respect to <code>acf</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt><code>ldens</code></dt><dd><p>The log-density evaluated at <code>z</code> and <code>acf</code>.</p>
</dd>
<dt><code>dldz</code></dt><dd><p>The length-<code>N</code> gradient vector with respect to <code>z</code>, if <code>calc_dldz = TRUE</code>.</p>
</dd>
<dt><code>dlda</code></dt><dd><p>The length-<code>N</code> gradient vector with respect to <code>acf</code>, if <code>calc_dlda = TRUE</code>.</p>
</dd>
</dl>



<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalToeplitz$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='pex_acf'>Power-exponential autocorrelation function.</h2><span id='topic+pex_acf'></span>

<h3>Description</h3>

<p>Power-exponential autocorrelation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pex_acf(tseq, lambda, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pex_acf_+3A_tseq">tseq</code></td>
<td>
<p>Vector of <code>N</code> time points at which the autocorrelation is to be calculated.</p>
</td></tr>
<tr><td><code id="pex_acf_+3A_lambda">lambda</code></td>
<td>
<p>Timescale parameter.</p>
</td></tr>
<tr><td><code id="pex_acf_+3A_rho">rho</code></td>
<td>
<p>Power parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power-exponential autocorrelation function is given by:
</p>
<p style="text-align: center;"><code class="reqn">
\mathrm{\scriptsize ACF}(t) = \exp \left\{-(t/\lambda)^\rho\right\}.
</code>
</p>



<h3>Value</h3>

<p>An autocorrelation vector of length <code>N</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pex_acf(tseq = 1:10, lambda = 1, rho = 2)
</code></pre>

<hr>
<h2 id='rnormtz'>Simulate a stationary Gaussian time series.</h2><span id='topic+rnormtz'></span>

<h3>Description</h3>

<p>Simulate a stationary Gaussian time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnormtz(n = 1, acf, Z, fft = TRUE, nkeep, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnormtz_+3A_n">n</code></td>
<td>
<p>Number of time series to generate.</p>
</td></tr>
<tr><td><code id="rnormtz_+3A_acf">acf</code></td>
<td>
<p>Length-<code>N</code> vector giving the autocorrelation of the series.</p>
</td></tr>
<tr><td><code id="rnormtz_+3A_z">Z</code></td>
<td>
<p>Optional size <code style="white-space: pre;">&#8288;(2N-2) x n&#8288;</code> or <code style="white-space: pre;">&#8288;N x n&#8288;</code> matrix of iid standard normals, to use in the FFT and Durbin-Levinson methods, respectively.</p>
</td></tr>
<tr><td><code id="rnormtz_+3A_fft">fft</code></td>
<td>
<p>Logical; whether or not to use the <code style="white-space: pre;">&#8288;O(N log N)&#8288;</code> FFT-based algorithm of Wood and Chan (1994) or the more stable <code>O(N^2)</code> Durbin-Levinson algorithm.  See Details.</p>
</td></tr>
<tr><td><code id="rnormtz_+3A_nkeep">nkeep</code></td>
<td>
<p>Length of time series.  Defaults to <code>N = length(acf)</code>. See Details.</p>
</td></tr>
<tr><td><code id="rnormtz_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance on negative eigenvalues.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FFT method fails when the embedding circulant matrix is not positive definite.  This is typically due to one of two things:
</p>

<ol>
<li><p> Roundoff error can make tiny eigenvalues appear negative.  For this purpose, argument <code>tol</code> can be used to replace all negative eigenvalues by <code>tol * ev_max</code>, where <code>ev_max</code> is the largest eigenvalue.
</p>
</li>
<li><p> The autocorrelation is decaying too slowly on the given timescale.  To mitigate this, argument <code>nkeep</code> can be used to supply a longer <code>acf</code> than is required, and keep only the first <code>nkeep</code> time series observations.  For consistency, <code>nkeep</code> also applies to Durbin-Levinson method.
</p>
</li></ol>



<h3>Value</h3>

<p>Length-<code>nkeep</code> vector or size <code style="white-space: pre;">&#8288;nkeep x n&#8288;</code> matrix with time series as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 10
acf &lt;- exp(-(1:N - 1)/N)
rnormtz(n = 3, acf = acf)
</code></pre>

<hr>
<h2 id='SuperGauss-defunct'>Defunct functions in <span class="pkg">SuperGauss</span>.</h2><span id='topic+SuperGauss-defunct'></span><span id='topic+rSnorm'></span><span id='topic+dSnorm'></span><span id='topic+Snorm.grad'></span><span id='topic+Snorm.hess'></span>

<h3>Description</h3>

<p>Defunct functions in <span class="pkg">SuperGauss</span>.
</p>


<h3>The following functions have been removed from the <span class="pkg">SuperGauss</span> package</h3>


<dl>
<dt><code>rSnorm()</code></dt><dd><p>Please use <code><a href="#topic+rnormtz">rnormtz()</a></code> instead.</p>
</dd>
<dt><code>dSnorm()</code></dt><dd><p>Please use <code><a href="#topic+dnormtz">dnormtz()</a></code> instead.</p>
</dd>
<dt><code>Snorm.grad()</code></dt><dd><p>Please use the <code>grad()</code> method in the <a href="#topic+NormalToeplitz">NormalToeplitz</a> class.</p>
</dd>
<dt><code>Snorm.hess()</code></dt><dd><p>Please use the <code>hess()</code> method in the <a href="#topic+NormalToeplitz">NormalToeplitz</a> class.</p>
</dd>
</dl>


<hr>
<h2 id='SuperGauss-package'>Superfast inference for stationary Gaussian time series.</h2><span id='topic+SuperGauss'></span><span id='topic+SuperGauss-package'></span>

<h3>Description</h3>

<p>Likelihood evaluations for stationary Gaussian time series are typically obtained via the Durbin-Levinson algorithm, which scales as O(n^2) in the number of time series observations. This package provides a &quot;superfast&quot; O(n log^2 n) algorithm written in C++, crossing over with Durbin-Levinson around n = 300. Efficient implementations of the score and Hessian functions are also provided, leading to superfast versions of inference algorithms such as Newton-Raphson and Hamiltonian Monte Carlo. The C++ code provides a Toeplitz matrix class packaged as a header-only library, to simplify low-level usage in other packages and outside of R.
</p>


<h3>Details</h3>

<p>While likelihood calculations with stationary Gaussian time series generally scale as <code>O(N^2)</code> in the number of observations, this package implements an algorithm which scales as <code style="white-space: pre;">&#8288;O(N log^2 N)&#8288;</code>.  &quot;Superfast&quot; algorithms for loglikelihood gradients and Hessians are also provided.  The underlying C++ code is distributed through a header-only library found in the installed package's <code>include</code> directory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Lysy <a href="mailto:mlysy@uwaterloo.ca">mlysy@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Yun Ling
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Superfast inference for the timescale parameter
# of the exponential autocorrelation function
exp_acf &lt;- function(lambda) exp(-(1:N-1)/lambda)

# simulate data
lambda0 &lt;- 1
N &lt;- 1000
X &lt;- rnormtz(n = 1, acf = exp_acf(lambda0))

# loglikelihood function
# allocate memory for a NormalToeplitz distribution object
NTz &lt;- NormalToeplitz$new(N)
loglik &lt;- function(lambda) {
  NTz$logdens(z = X, acf = exp_acf(lambda))
  ## dSnorm(X = X, acf = Toep, log = TRUE)
}

# maximum likelihood estimation
optimize(f = loglik, interval = c(.2, 5), maximum = TRUE)
</code></pre>

<hr>
<h2 id='toep.mult'>Toeplitz matrix multiplication.</h2><span id='topic+toep.mult'></span>

<h3>Description</h3>

<p>Efficient matrix multiplication with Toeplitz matrix and arbitrary matrix or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toep.mult(acf, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toep.mult_+3A_acf">acf</code></td>
<td>
<p>Length-<code>N</code> vector giving the first column (or row) of the Toeplitz matrix.</p>
</td></tr>
<tr><td><code id="toep.mult_+3A_x">X</code></td>
<td>
<p>Vector or matrix of compatible dimensions with <code>acf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>N</code>-row matrix corresponding to <code>toeplitz(acf) %*% X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 20
d &lt;- 3
acf &lt;- exp(-(1:N))
X &lt;- matrix(rnorm(N*d), N, d)
toep.mult(acf, X)
</code></pre>

<hr>
<h2 id='Toeplitz'>Constructor and methods for Toeplitz matrix objects.</h2><span id='topic+Toeplitz'></span><span id='topic+is.Toeplitz'></span><span id='topic+as.Toeplitz'></span><span id='topic+ncol+2CToeplitz-method'></span><span id='topic+nrow+2CToeplitz-method'></span><span id='topic+dim.Toeplitz'></span><span id='topic++25+2A+25'></span><span id='topic+determinant+2CToeplitz-method'></span><span id='topic+determinant'></span><span id='topic+solve+2CToeplitz-method'></span><span id='topic+solve'></span><span id='topic+solve+2CToeplitz+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>Toeplitz</code> class contains efficient methods for linear algebra with symmetric positive definite (i.e., variance) Toeplitz matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Toeplitz(x)

as.Toeplitz(x)

## S3 method for class 'Toeplitz'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Toeplitz_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code style="white-space: pre;">&#8288;N x N&#8288;</code> Toeplitz matrix <code>Tz</code> is defined by its length-<code>N</code> &quot;autocorrelation&quot; vector <code>acf</code>, i.e., first row/column <code>Tz</code>.  Thus, for the function <code><a href="stats.html#topic+toeplitz">stats::toeplitz()</a></code>, we have <code>Tz = toeplitz(acf)</code>.
</p>
<p>It is assumed that <code>acf</code> defines a valid (i.e., positive definite) variance matrix.  The matrix multiplication methods still work when this is not the case but the other methods do not (return values typically contain <code>NaN</code>s).
</p>
<p><code>as.Toeplitz(x)</code> attempts to convert its argument to a <code>Toeplitz</code> object by calling <code>Toeplitz$new(acf = x)</code>. <code>is.Toeplitz(x)</code> checks whether its argument is a <code>Toeplitz</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Toeplitz$new()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>Toeplitz$print()</code></a>
</p>
</li>
<li> <p><a href="#method-size"><code>Toeplitz$size()</code></a>
</p>
</li>
<li> <p><a href="#method-set_acf"><code>Toeplitz$set_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-get_acf"><code>Toeplitz$get_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-has_acf"><code>Toeplitz$has_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-prod"><code>Toeplitz$prod()</code></a>
</p>
</li>
<li> <p><a href="#method-solve"><code>Toeplitz$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-log_det"><code>Toeplitz$log_det()</code></a>
</p>
</li>
<li> <p><a href="#method-trace_grad"><code>Toeplitz$trace_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-trace_hess"><code>Toeplitz$trace_hess()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Toeplitz$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$new(N, acf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>Size of Toeplitz matrix.</p>
</dd>
<dt><code>acf</code></dt><dd><p>Autocorrelation vector of length <code>N</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Toeplitz</code> object.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$print()</pre></div>


<hr>
<a id="method-size"></a>



<h4>Method <code>size()</code></h4>

<p>Get the size of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$size()</pre></div>



<h5>Returns</h5>

<p>Size of the Toeplitz matrix.  <code><a href="base.html#topic+nrow">ncol()</a></code>, <code><a href="base.html#topic+nrow">nrow()</a></code>, and <code><a href="base.html#topic+dim">dim()</a></code> methods for <code>Toeplitz</code> objects also work as expected.
</p>


<hr>
<a id="method-set_acf"></a>



<h4>Method <code>set_acf()</code></h4>

<p>Set the autocorrelation of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$set_acf(acf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf</code></dt><dd><p>Autocorrelation vector of length <code>N</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-get_acf"></a>



<h4>Method <code>get_acf()</code></h4>

<p>Get the autocorrelation of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$get_acf()</pre></div>



<h5>Returns</h5>

<p>The autocorrelation vector of length <code>N</code>.
</p>


<hr>
<a id="method-has_acf"></a>



<h4>Method <code>has_acf()</code></h4>

<p>Check whether the autocorrelation of the Toeplitz matrix has been set.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$has_acf()</pre></div>



<h5>Returns</h5>

<p>Logical; <code>TRUE</code> if <code>Toeplitz$set_acf()</code> has been called.
</p>


<hr>
<a id="method-prod"></a>



<h4>Method <code>prod()</code></h4>

<p>Toeplitz matrix-matrix product.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$prod(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector or matrix with <code>N</code> rows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The matrix product <code>Tz %*% x</code>. <code>Tz %*% x</code> and <code>x %*% Tz</code> also work as expected.
</p>


<hr>
<a id="method-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve a Toeplitz system of equations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$solve(x, method = c("gschur", "pcg"), tol = 1e-10)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Optional vector or matrix with <code>N</code> rows.</p>
</dd>
<dt><code>method</code></dt><dd><p>Solve method to use.  Choices are: <code>gschur</code> for a modified version of the Generalized Schur algorithm of Ammar &amp; Gragg (1988), or <code>pcg</code> for the preconditioned conjugate gradient method of Chen et al (2006).  The former is faster and obtains the log-determinant as a direct biproduct.  The latter is more numerically stable for long-memory autocorrelations.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Tolerance level for the <code>pcg</code> method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The solution in <code>z</code> to the system of equations <code>Tz %*% z = x</code>.  If <code>x</code> is missing, returns the inverse of <code>Tz</code>.  <code>solve(Tz, x)</code> and <code>solve(Tz, x, method, tol)</code> also work as expected.
</p>


<hr>
<a id="method-log_det"></a>



<h4>Method <code>log_det()</code></h4>

<p>Calculate the log-determinant of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$log_det()</pre></div>



<h5>Returns</h5>

<p>The log-determinant <code>log(det(Tz))</code>.  <code>determinant(Tz)</code> also works as expected.
</p>


<hr>
<a id="method-trace_grad"></a>



<h4>Method <code>trace_grad()</code></h4>

<p>Computes the trace-gradient with respect to Toeplitz matrices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$trace_grad(acf2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf2</code></dt><dd><p>Length-<code>N</code> autocorrelation vector of the second Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Computes the trace of</p>
<pre>solve(Tz, toeplitz(acf2)).
</pre>
<p>This is used in the computation of the gradient of <code>log(det(Tz(theta)))</code> with respect to <code>theta</code>.
</p>


<hr>
<a id="method-trace_hess"></a>



<h4>Method <code>trace_hess()</code></h4>

<p>Computes the trace-Hessian with respect to Toeplitz matrices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$trace_hess(acf2, acf3)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf2</code></dt><dd><p>Length-<code>N</code> autocorrelation vector of the second Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
<dt><code>acf3</code></dt><dd><p>Length-<code>N</code> autocorrelation vector of the third Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Computes the trace of</p>
<pre>solve(Tz, toeplitz(acf2)) %*% solve(Tz, toeplitz(acf3)).
</pre>
<p>This is used in the computation of the Hessian of <code>log(det(Tz(theta)))</code> with respect to <code>theta</code>.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># construct a Toeplitz matrix
acf &lt;- exp(-(1:5))
Tz &lt;- Toeplitz$new(acf = acf)
# alternatively, can allocate space first
Tz &lt;- Toeplitz$new(N = length(acf))
Tz$set_acf(acf = acf)

# basic methods
Tz$get_acf() # extract the acf
dim(Tz) # == c(nrow(Tz), ncol(Tz))
Tz # print method

# linear algebra methods
X &lt;- matrix(rnorm(10), 5, 2)
Tz %*% X
t(X) %*% Tz
solve(Tz, X)
determinant(Tz) # log-determinant
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
