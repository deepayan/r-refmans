<!DOCTYPE html><html lang="en-US"><head><title>Help for package sgsR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sgsR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sgsR-package'><p>sgsR: Structurally Guided Sampling</p></a></li>
<li><a href='#allocating'><p>Allocating strata: 'existing'</p></a></li>
<li><a href='#calculate_allocation'><p>Sample allocation type and count</p></a></li>
<li><a href='#calculate_allocation_existing'><p>Sample allocation type and count</p></a></li>
<li><a href='#calculate_coobs'><p>coobs algorithm sampling</p></a></li>
<li><a href='#calculate_distance'><p>Distance to access layer</p></a></li>
<li><a href='#calculate_lhsOpt'><p>Analyze optimal Latin hypercube sample number</p></a></li>
<li><a href='#calculate_pcomp'><p>Raster principal components</p></a></li>
<li><a href='#calculate_pop'><p>Population descriptors</p></a></li>
<li><a href='#calculate_representation'><p>Compare sample representation within sraster strata</p></a></li>
<li><a href='#calculate_sampsize'><p>Sample size determination</p></a></li>
<li><a href='#check_existing'><p>Check existing sample data against requirements</p></a></li>
<li><a href='#coords_existing'><p>Get existing and XY coordinates</p></a></li>
<li><a href='#extract_metrics'><p>Extract metrics</p></a></li>
<li><a href='#extract_strata'><p>Extract strata</p></a></li>
<li><a href='#masking'><p>Masking</p></a></li>
<li><a href='#matrices'><p>Matrices</p></a></li>
<li><a href='#plot'><p>Plot</p></a></li>
<li><a href='#prepare_existing'><p>Prepare existing sample data</p></a></li>
<li><a href='#rules'><p>Sampling rules</p></a></li>
<li><a href='#sample_ahels'><p>Adapted Hypercube Evaluation of a Legacy Sample (ahels)</p></a></li>
<li><a href='#sample_balanced'><p>Balanced sampling</p></a></li>
<li><a href='#sample_clhs'><p>Conditioned Latin Hypercube Sampling</p></a></li>
<li><a href='#sample_existing'><p>Sample existing</p></a></li>
<li><a href='#sample_existing_balanced'><p>Sample Existing Data Using Balanced Sampling</p></a></li>
<li><a href='#sample_existing_clhs'><p>Sub-sample using the conditional Latin hypercube sampling (CLHS)</p></a></li>
<li><a href='#sample_existing_srs'><p>Randomly sample from an existing dataset</p></a></li>
<li><a href='#sample_existing_strat'><p>Sample Existing Data Based on Strata</p></a></li>
<li><a href='#sample_nc'><p>Nearest centroid (NC) sampling</p></a></li>
<li><a href='#sample_srs'><p>Simple random sampling</p></a></li>
<li><a href='#sample_strat'><p>Stratified sampling</p></a></li>
<li><a href='#sample_sys_strat'><p>Systematic stratified sampling</p></a></li>
<li><a href='#sample_systematic'><p>Systematic sampling</p></a></li>
<li><a href='#strat_breaks'><p>Breaks stratification</p></a></li>
<li><a href='#strat_kmeans'><p>k-means stratification</p></a></li>
<li><a href='#strat_map'><p>Map a raster stack of a list of rasters</p></a></li>
<li><a href='#strat_poly'><p>Stratify using polygons</p></a></li>
<li><a href='#strat_quantiles'><p>Quantiles stratification</p></a></li>
<li><a href='#take_samples'><p>Take Samples Based on Strata</p></a></li>
<li><a href='#vectorize'><p>Vectorization helpers</p></a></li>
<li><a href='#write'><p>Write</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.5</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Structurally Guided Sampling</td>
</tr>
<tr>
<td>Description:</td>
<td>Structurally guided sampling (SGS) approaches for airborne laser scanning (ALS; LIDAR). Primary functions provide means 
    to generate data-driven stratifications &amp; methods for allocating samples. Intermediate functions for calculating and extracting important information 
    about input covariates and samples are also included. Processing outcomes are intended to help forest and environmental management
    practitioners better optimize field sample placement as well as assess and augment existing sample networks in the context of data
    distributions and conditions. ALS data is the primary intended use case, however any rasterized remote sensing data can be used, 
    enabling data-driven stratifications and sampling approaches.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tgoodbody/sgsR">https://github.com/tgoodbody/sgsR</a>,
<a href="https://tgoodbody.github.io/sgsR/">https://tgoodbody.github.io/sgsR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tgoodbody/sgsR/issues">https://github.com/tgoodbody/sgsR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, sf, terra, tidyr, clhs, SamplingBigData,
BalancedSampling, spatstat.geom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Rfast, testthat (&ge; 3.0.0), doParallel,
doSNOW, snow, foreach, entropy, roxygen2, covr, RANN, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 23:32:34 UTC; goodb</td>
</tr>
<tr>
<td>Author:</td>
<td>Tristan RH Goodbody
    <a href="https://orcid.org/0000-0002-6894-7925"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Nicholas C Coops <a href="https://orcid.org/0000-0002-0151-9037"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Queinnec <a href="https://orcid.org/0000-0002-2741-1032"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tristan RH Goodbody &lt;goodbody.t@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sgsR-package'>sgsR: Structurally Guided Sampling</h2><span id='topic+sgsR'></span><span id='topic+sgsR-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Structurally guided sampling (SGS) approaches for airborne laser scanning (ALS; LIDAR). Primary functions provide means to generate data-driven stratifications &amp; methods for allocating samples. Intermediate functions for calculating and extracting important information about input covariates and samples are also included. Processing outcomes are intended to help forest and environmental management practitioners better optimize field sample placement as well as assess and augment existing sample networks in the context of data distributions and conditions. ALS data is the primary intended use case, however any rasterized remote sensing data can be used, enabling data-driven stratifications and sampling approaches.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tristan RH Goodbody <a href="mailto:goodbody.t@gmail.com">goodbody.t@gmail.com</a> (<a href="https://orcid.org/0000-0002-6894-7925">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Nicholas C Coops <a href="mailto:nicholas.coops@ubc.ca">nicholas.coops@ubc.ca</a> (<a href="https://orcid.org/0000-0002-0151-9037">ORCID</a>)
</p>
</li>
<li><p> Martin Queinnec <a href="mailto:queinnec@mail.ubc.ca">queinnec@mail.ubc.ca</a> (<a href="https://orcid.org/0000-0002-2741-1032">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tgoodbody/sgsR">https://github.com/tgoodbody/sgsR</a>
</p>
</li>
<li> <p><a href="https://tgoodbody.github.io/sgsR/">https://tgoodbody.github.io/sgsR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tgoodbody/sgsR/issues">https://github.com/tgoodbody/sgsR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='allocating'>Allocating strata: 'existing'</h2><span id='topic+allocating'></span><span id='topic+allocate_existing_prop'></span><span id='topic+allocate_existing_optim'></span><span id='topic+allocate_existing_manual'></span><span id='topic+allocate_existing_equal'></span><span id='topic+allocate_prop'></span><span id='topic+allocate_optim'></span><span id='topic+allocate_manual'></span><span id='topic+allocate_equal'></span><span id='topic+allocate_existing'></span><span id='topic+allocate_force'></span>

<h3>Description</h3>

<p>Allocation algorithms based on 'existing'
</p>
<p>Allocation algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate_existing_prop(existing, nSamp)

allocate_existing_optim(existing, metric, nSamp)

allocate_existing_manual(existing, nSamp, weights)

allocate_existing_equal(existing, nSamp)

allocate_prop(sraster, nSamp)

allocate_optim(sraster, mraster, nSamp)

allocate_manual(sraster, nSamp, weights)

allocate_equal(sraster, nSamp)

allocate_existing(toSample, existing)

allocate_force(toSample, nSamp, diff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allocating_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT' or data.frame.  Existing plot network.</p>
</td></tr>
<tr><td><code id="allocating_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="allocating_+3A_weights">weights</code></td>
<td>
<p>Numeric. Only applicable when <code>allocation = "manual"</code>. Vector of weights where <code>sum(weights) == 1</code>. Vector length
must be equal to the number of unique strata where the first numeric value corresponds to stratum 1, second stratum 2 etc.</p>
</td></tr>
<tr><td><code id="allocating_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratification raster to be used for sampling.</p>
</td></tr>
<tr><td><code id="allocating_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metric raster. Required when <code>allocation = optim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of allocated samples by stratum. Used internally within <code>sample_existing(type = "strat")</code>.
</p>
<p>Data frame of allocated samples by stratum. Used internally within <code>sample_strat()</code>.
</p>

<hr>
<h2 id='calculate_allocation'>Sample allocation type and count</h2><span id='topic+calculate_allocation'></span>

<h3>Description</h3>

<p>Determine how many samples to allocate within strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_allocation(
  sraster,
  nSamp,
  allocation = "prop",
  weights = NULL,
  mraster = NULL,
  existing = NULL,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_allocation_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratification raster to be used for sampling.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_allocation">allocation</code></td>
<td>
<p>Character. Allocation algorithm to be used. Either <code>prop</code> (default) for proportional allocation,
<code>optim</code> for optimal allocation (equal sampling cost), <code>equal</code> for equal number of samples (defined by <code>nSamp</code>)
for each strata, or <code>"manual"</code> for user defined strata weights defined using <code>weights</code>.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_weights">weights</code></td>
<td>
<p>Numeric. Only applicable when <code>allocation = "manual"</code>. Vector of weights where <code>sum(weights) == 1</code>. Vector length
must be equal to the number of unique strata where the first numeric value corresponds to stratum 1, second stratum 2 etc.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metric raster. Required when <code>allocation = optim</code>.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT' or data.frame.  Existing plot network.</p>
</td></tr>
<tr><td><code id="calculate_allocation_+3A_force">force</code></td>
<td>
<p>Logical. <code>Default = FALSE</code> - force <code>nSamp</code> to be exactly the user defined value
in cases where <code>nSamp</code> and <code>sraster</code> strata count are not equally divisible. Additional samples often need to be allocated or removed
based on rounding differences resulting from proportional differences between <code>nSamp</code> and strata coverages in <code>sraster</code>.
In these instances samples are either added to strata with the lowest number of samples or are removed from strata with the highest number of samples.
Has no effect when <code>existing</code> is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame of:
</p>

<ul>
<li><p>strata - Strata ID.
</p>
</li>
<li><p>total - Number of samples to be allocated. Values correspond to under representation (samples needed; positive value) or over representation
(too many samples; negative value) based on the <code>nSamp</code> provided.
</p>
</li>
<li><p>need - Required samples per strata based on allocation method. Rounded.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Gregoire, T.G., &amp; Valentine, H.T. (2007). Sampling Strategies for Natural Resources and the Environment (1st ed.).
Chapman and Hall/CRC. https://doi.org/10.1201/9780203498880
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Load strata raster and existing samples---#
r &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sr &lt;- terra::rast(r)

e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

#--- proportional allocation ---#
calculate_allocation(
  sraster = sr,
  nSamp = 10,
  allocation = "prop"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='calculate_allocation_existing'>Sample allocation type and count</h2><span id='topic+calculate_allocation_existing'></span>

<h3>Description</h3>

<p>Determine how many samples to allocate within strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_allocation_existing(
  existing,
  nSamp,
  allocation = "prop",
  weights = NULL,
  metric = NULL,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_allocation_existing_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT' or data.frame.  Existing plot network.</p>
</td></tr>
<tr><td><code id="calculate_allocation_existing_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="calculate_allocation_existing_+3A_allocation">allocation</code></td>
<td>
<p>Character. Allocation algorithm to be used. Either <code>prop</code> (default) for proportional allocation,
<code>optim</code> for optimal allocation (equal sampling cost), <code>equal</code> for equal number of samples (defined by <code>nSamp</code>)
for each strata, or <code>"manual"</code> for user defined strata weights defined using <code>weights</code>.</p>
</td></tr>
<tr><td><code id="calculate_allocation_existing_+3A_weights">weights</code></td>
<td>
<p>Numeric. Only applicable when <code>allocation = "manual"</code>. Vector of weights where <code>sum(weights) == 1</code>. Vector length
must be equal to the number of unique strata where the first numeric value corresponds to stratum 1, second stratum 2 etc.</p>
</td></tr>
<tr><td><code id="calculate_allocation_existing_+3A_force">force</code></td>
<td>
<p>Logical. <code>Default = FALSE</code> - force <code>nSamp</code> to be exactly the user defined value
in cases where <code>nSamp</code> and <code>sraster</code> strata count are not equally divisible. Additional samples often need to be allocated or removed
based on rounding differences resulting from proportional differences between <code>nSamp</code> and strata coverages in <code>sraster</code>.
In these instances samples are either added to strata with the lowest number of samples or are removed from strata with the highest number of samples.
Has no effect when <code>existing</code> is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame of:
</p>

<ul>
<li><p>strata - Strata ID.
</p>
</li>
<li><p>total - Number of samples to be allocated. Values correspond to under representation (samples needed; positive value) or over representation
(too many samples; negative value) based on the <code>nSamp</code> provided.
</p>
</li>
<li><p>need - Required samples per strata based on allocation method. Rounded.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Gregoire, T.G., &amp; Valentine, H.T. (2007). Sampling Strategies for Natural Resources and the Environment (1st ed.).
Chapman and Hall/CRC. https://doi.org/10.1201/9780203498880
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>

<hr>
<h2 id='calculate_coobs'>coobs algorithm sampling</h2><span id='topic+calculate_coobs'></span>

<h3>Description</h3>

<p>Perform the COunt of OBServations (coobs) algorithm using existing site data
and raster metrics. This algorithm aids the user in determining where additional samples
could be located by comparing existing samples to each pixel and associated covariates.
The output coobs raster could be used to constrain clhs sampling to areas that are underreprented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_coobs(
  mraster,
  existing,
  cores = 1,
  threshold = 0.95,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_coobs_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster. Requires at least 2 layers to calculate covariance matrix.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_cores">cores</code></td>
<td>
<p>Numeric. Number of cores to use for parallel processing. <code>default = 1</code>.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Proxy maximum pixel quantile to avoid outliers. <code>default = 0.95</code>.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="calculate_coobs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output raster with coobs and classified coobs layers.
</p>


<h3>Note</h3>

<p>Special thanks to Dr. Brendan Malone for the original implementation of this algorithm.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Malone BP, Minasny B, Brungard C. 2019. Some methods to improve the utility of conditioned Latin hypercube sampling. PeerJ 7:e6451 DOI 10.7717/peerj.6451
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Load raster and existing plots---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

calculate_coobs(
  mraster = mr,
  existing = e,
  cores = 4
)

## End(Not run)
</code></pre>

<hr>
<h2 id='calculate_distance'>Distance to access layer</h2><span id='topic+calculate_distance'></span>

<h3>Description</h3>

<p>Per pixel distance to nearest access vector. Intended to be used as a 'cost' constraint
within the <code><a href="#topic+sample_clhs">sample_clhs</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_distance(
  raster,
  access,
  slope = FALSE,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_distance_+3A_raster">raster</code></td>
<td>
<p>spatRaster. Raster to be used to calculate pixel level distance to access layer.</p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_slope">slope</code></td>
<td>
<p>Logical. Calculate slope distance instead of geographic distance. <code>raster</code> needs 
to be a digital terrain model for this to make sense.</p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input raster with <code>dist2access</code> layer appended.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster_small.tif", package = "sgsR")
mr &lt;- terra::rast(r)

a &lt;- system.file("extdata", "access.shp", package = "sgsR")
ac &lt;- sf::st_read(a)

calculate_distance(
  raster = mr,
  access = ac,
)

## End(Not run)

</code></pre>

<hr>
<h2 id='calculate_lhsOpt'>Analyze optimal Latin hypercube sample number</h2><span id='topic+calculate_lhsOpt'></span>

<h3>Description</h3>

<p>Population level analysis of metric raster data to determine optimal Latin Hypercube sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lhsOpt(
  mats,
  PCA = TRUE,
  quant = TRUE,
  KLdiv = TRUE,
  minSamp = 10,
  maxSamp = 100,
  step = 10,
  rep = 10,
  iter = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_lhsOpt_+3A_mats">mats</code></td>
<td>
<p>List. Output from <code><a href="#topic+calculate_pop">calculate_pop</a></code> function.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_pca">PCA</code></td>
<td>
<p>Logical. Calculates principal component loadings of the population for PCA similarity factor testing.
<code>default = FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_quant">quant</code></td>
<td>
<p>Logical. Perform quantile comparison testing.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_kldiv">KLdiv</code></td>
<td>
<p>Logical. Perform Kullback–Leibler divergence testing.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_minsamp">minSamp</code></td>
<td>
<p>Numeric. Minimum sample size to test. <code>default = 10</code>.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_maxsamp">maxSamp</code></td>
<td>
<p>Numeric. Maximum sample size to test. <code>default = 100</code>.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_step">step</code></td>
<td>
<p>Numeric. Sample step size for each iteration. <code>default = 10</code>.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_rep">rep</code></td>
<td>
<p>Numeric. Internal repetitions for each sample size. <code>default = 10</code>.</p>
</td></tr>
<tr><td><code id="calculate_lhsOpt_+3A_iter">iter</code></td>
<td>
<p>Positive Numeric. The number of iterations for the Metropolis-Hastings
annealing process. Defaults to <code>10000</code>. Internal to <code><a href="clhs.html#topic+clhs">clhs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with summary statistics.
</p>


<h3>Note</h3>

<p>Special thanks to Dr. Brendan Malone for the original implementation of this algorithm.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Malone BP, Minasny B, Brungard C. 2019. Some methods to improve the utility of conditioned Latin hypercube sampling. PeerJ 7:e6451 DOI 10.7717/peerj.6451
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#--- calculate lhsPop details ---#
mats &lt;- calculate_pop(mraster = mr)

calculate_lhsOpt(mats = mats)

calculate_lhsOpt(
  mats = mats,
  PCA = FALSE,
  iter = 200
)

## End(Not run)

</code></pre>

<hr>
<h2 id='calculate_pcomp'>Raster principal components</h2><span id='topic+calculate_pcomp'></span>

<h3>Description</h3>

<p>Calculate and rasterize principal components from a metric raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_pcomp(
  mraster,
  nComp,
  center = TRUE,
  scale = TRUE,
  maxcells = Inf,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_pcomp_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_ncomp">nComp</code></td>
<td>
<p>Numeric. Value indicating number of principal components to be rasterized.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_center">center</code></td>
<td>
<p>Logical. Value indicating whether the variables should be shifted to be zero centered.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_scale">scale</code></td>
<td>
<p>Logical. Value indicating whether the variables should be scaled to have unit variance.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_maxcells">maxcells</code></td>
<td>
<p>Numeric. Maximum number of samples to use to generate principal components.
For objects that are too large to feed into <code><a href="stats.html#topic+prcomp">prcomp</a></code>.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="calculate_pcomp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+prcomp">prcomp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output raster with specified number of principal components as layers.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

calculate_pcomp(
  mraster = mr,
  nComp = 2
)

pcomp &lt;- calculate_pcomp(
  mraster = mr,
  nComp = 3,
  details = TRUE
)

#--- Display principal component details ---#
# pcomp$pca

#--- Display importance of components ---#
# summary(pcomp$pca)
</code></pre>

<hr>
<h2 id='calculate_pop'>Population descriptors</h2><span id='topic+calculate_pop'></span>

<h3>Description</h3>

<p>Population matrices and descriptions of metric raster data
</p>
<p>Calculates population level statistics including principal components, quantile matrix, and covariance matrix
needed necessary for <code><a href="#topic+calculate_lhsOpt">calculate_lhsOpt</a></code>. Outputs can also be used as an input for <code><a href="#topic+sample_ahels">sample_ahels</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_pop(mraster, PCA = FALSE, matQ = TRUE, nQuant = 10, matCov = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_pop_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="calculate_pop_+3A_pca">PCA</code></td>
<td>
<p>Logical. Calculates principal component loadings of the population for PCA similarity factor testing.
<code>default = FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_pop_+3A_matq">matQ</code></td>
<td>
<p>Logical. Calculates quantile matrix of the population for quantile comparison testing.
<code>default = TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculate_pop_+3A_nquant">nQuant</code></td>
<td>
<p>Numeric. Number of quantiles to divide the population into for <code>matQ</code>.
<code>default = 10</code>.</p>
</td></tr>
<tr><td><code id="calculate_pop_+3A_matcov">matCov</code></td>
<td>
<p>Logical. Calculates covariate matrix of the population. Needed for Kullback–Leibler divergence testing.
<code>default = TRUE</code>. Requires <code>matQ = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrices to be used as input for <code><a href="#topic+calculate_lhsOpt">calculate_lhsOpt</a></code>.
</p>


<h3>Note</h3>

<p>Special thanks to Dr. Brendan Malone for the original implementation of this algorithm.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Malone BP, Minasny B, Brungard C. 2019. Some methods to improve the utility of conditioned Latin hypercube sampling. PeerJ 7:e6451 DOI 10.7717/peerj.6451
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

calculate_pop(mraster = mr)

</code></pre>

<hr>
<h2 id='calculate_representation'>Compare sample representation within sraster strata</h2><span id='topic+calculate_representation'></span>

<h3>Description</h3>

<p>Compare sample representation within sraster strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_representation(sraster, existing, drop = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_representation_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratification raster.</p>
</td></tr>
<tr><td><code id="calculate_representation_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="calculate_representation_+3A_drop">drop</code></td>
<td>
<p>Numeric. Numeric value between 0-1 representing the <code>sraster</code> frequency
(<code>srasterFreq</code>) below which strata will be dropped from comparison (e.g..
This parameter can be useful for when comparing stratum where percent coverage of strata
may be ~ 0 percent and should be dropped. This could occur when mapping multiple stratifications.</p>
</td></tr>
<tr><td><code id="calculate_representation_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot frequency of strata coverage and sampling coverage
for <code>sraster</code> and <code>existing</code>. Will return a list if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate how sraster strata are represented in existing samples
</p>


<h3>Value</h3>

<p>Returns a tibble where:
</p>

<ul>
<li><p>strata - <code>sraster</code> strata ID.
</p>
</li>
<li><p>srasterFreq - <code>sraster</code> coverage frequency.
</p>
</li>
<li><p>sampleFreq - Sampling frequency within <code>sraster</code> strata.
</p>
</li>
<li><p>diffFreq - Difference between <code>srasterFreq</code> &amp; <code>sampleFreq</code>. Positive values indicate over representation.
</p>
</li>
<li><p>nSamp - Number of samples within each strata in <code>existing</code>.
</p>
</li>
<li><p>need - <code>srasterFreq * sum(nSamp)</code>. Total theoretical number of required samples to be representative of strata coverage.
This values is rounded. It is important for the user to consider <code>diffFreq</code>. A small difference - e.g. 1 
in <code>sampleFreq</code> vs. <code>srasterFreq</code> frequency could make the algorithm allocate or remove samples that could likely be ignored.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody, Martin Queinnec
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_sampsize">calculate_sampsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### --- generate example stratification ---###

#--- load ALS metrics from sgsR internal data ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")

#--- read ALS metrics using the terra package ---#
mraster &lt;- terra::rast(r)

#--- perform stratification ---#
sraster &lt;- strat_kmeans(
  mraster = mraster$zq90,
  nStrata = 6
)

### --- create existing sample network ---###

#--- simple random sampling ---#
existing &lt;- sample_srs(
  raster = mraster$zq90,
  nSamp = 100
)

#--- calculate representation ---#

calculate_representation(
  sraster = sraster,
  existing = existing
)
</code></pre>

<hr>
<h2 id='calculate_sampsize'>Sample size determination</h2><span id='topic+calculate_sampsize'></span>

<h3>Description</h3>

<p>Determine a samples size for simple random sampling using relative standard error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sampsize(
  mraster,
  rse = NULL,
  start = 0.01,
  end = 0.05,
  increment = 0.001,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_sampsize_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. Metrics raster. All values must be numeric.</p>
</td></tr>
<tr><td><code id="calculate_sampsize_+3A_rse">rse</code></td>
<td>
<p>Numeric. Desired relative standard error (coefficient of variation of the mean)
threshold to determine sample size.</p>
</td></tr>
<tr><td><code id="calculate_sampsize_+3A_start">start</code></td>
<td>
<p>Numeric. First rse value to begin rse sequence. default = <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="calculate_sampsize_+3A_end">end</code></td>
<td>
<p>Numeric. Final rse value to end rse sequence. default = <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="calculate_sampsize_+3A_increment">increment</code></td>
<td>
<p>Numeric. Value to increment between <code>start</code> &amp; <code>end</code>. default = <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="calculate_sampsize_+3A_plot">plot</code></td>
<td>
<p>Logical. if <code>TRUE</code> output graphical representation of estimated sample size vs. rse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of sample size and rse by raster variable.
</p>


<h3>Note</h3>

<p style="text-align: center;"><code class="reqn">rse = (100 * SE) / mean)</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code>SE</code> - Standard error of the mean
</p>
</li>
<li> <p><code>s</code> - Standard deviation of the observations
</p>
</li>
<li> <p><code>n</code> - Number of observations
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Benedetti, R., Piersimoni, F., &amp; Postiglione, P. (2015).
Sampling spatial units for agricultural surveys. pp 202-203. Berlin: Springer.
</p>


<h3>See Also</h3>

<p>Other calculate functions: 
<code><a href="#topic+calculate_allocation">calculate_allocation</a>()</code>,
<code><a href="#topic+calculate_allocation_existing">calculate_allocation_existing</a>()</code>,
<code><a href="#topic+calculate_coobs">calculate_coobs</a>()</code>,
<code><a href="#topic+calculate_distance">calculate_distance</a>()</code>,
<code><a href="#topic+calculate_pcomp">calculate_pcomp</a>()</code>,
<code><a href="#topic+calculate_pop">calculate_pop</a>()</code>,
<code><a href="#topic+calculate_representation">calculate_representation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- Load raster ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

calculate_sampsize(
  mraster = mr,
  rse = 0.01
)

calculate_sampsize(
  mraster = mr
)

calculate_sampsize(
  mraster = mr,
  rse = 0.025,
  start = 0.01,
  end = 0.08,
  increment = 0.01
)

#--- higher variance leads to need for more samples ---#
</code></pre>

<hr>
<h2 id='check_existing'>Check existing sample data against requirements</h2><span id='topic+check_existing'></span>

<h3>Description</h3>

<p>This function checks whether the existing sample data meets certain requirements for use in downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_existing(existing, raster, nSamp, plot = FALSE, details = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_existing_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="check_existing_+3A_raster">raster</code></td>
<td>
<p>SpatRaster. Raster to guide the location of the samples. If <code>type = "clhs"</code> this raster can also
be used to define the population distributions to be used for sampling.</p>
</td></tr>
<tr><td><code id="check_existing_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="check_existing_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
systematic samples. If <code>TRUE</code> returns a list of sf objects where <code>tessellation</code>
is the tessellation grid for sampling, and <code>samples</code> are the systematic samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If requirements are met, the function returns the prepared existing sample data.
Otherwise, it raises a stop error with a relevant message.
</p>

<hr>
<h2 id='coords_existing'>Get existing and XY coordinates</h2><span id='topic+coords_existing'></span>

<h3>Description</h3>

<p>This function extracts the 'X' and 'Y' coordinates from an 'sf' object and returns them in a data.frame format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords_existing(existing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coords_existing_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>existing</code> with respective 'X' and 'Y' columns representing the coordinates of the input <code>sf</code> object.
</p>

<hr>
<h2 id='extract_metrics'>Extract metrics</h2><span id='topic+extract_metrics'></span>

<h3>Description</h3>

<p>Extract metric values to existing samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_metrics(
  mraster,
  existing,
  quiet = FALSE,
  data.frame = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_metrics_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. Metrics Raster.</p>
</td></tr>
<tr><td><code id="extract_metrics_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="extract_metrics_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If <code>TRUE</code> the user will not get messages
about samples with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="extract_metrics_+3A_data.frame">data.frame</code></td>
<td>
<p>Logical. Output as data.frame if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="extract_metrics_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="extract_metrics_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf or data.frame object of samples with metrics attributes.
</p>


<h3>Note</h3>

<p>If <code>data.frame = TRUE</code> output will be written using <code><a href="utils.html#topic+write.table">write.table</a></code>
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other extract functions: 
<code><a href="#topic+extract_strata">extract_strata</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load mraster ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#' #--- load existing samples ---#
e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

extract_metrics(
  mraster = mr,
  existing = e
)

</code></pre>

<hr>
<h2 id='extract_strata'>Extract strata</h2><span id='topic+extract_strata'></span>

<h3>Description</h3>

<p>Extract stratum values to existing samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_strata(
  sraster,
  existing,
  quiet = FALSE,
  data.frame = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_strata_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratification raster.</p>
</td></tr>
<tr><td><code id="extract_strata_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="extract_strata_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If <code>TRUE</code> the user will not get messages
about samples with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="extract_strata_+3A_data.frame">data.frame</code></td>
<td>
<p>Logical. Output as data.frame if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="extract_strata_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="extract_strata_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf or data.frame object of samples with strata attribute.
</p>


<h3>Note</h3>

<p>If <code>data.frame = TRUE</code> output will be written using <code><a href="utils.html#topic+write.table">write.table</a></code>
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other extract functions: 
<code><a href="#topic+extract_metrics">extract_metrics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load sraster ---#
r &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sr &lt;- terra::rast(r)

#--- load existing samples ---#
e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

extract_strata(
  sraster = sr,
  existing = e
)

</code></pre>

<hr>
<h2 id='masking'>Masking</h2><span id='topic+masking'></span><span id='topic+mask_access'></span><span id='topic+mask_existing'></span>

<h3>Description</h3>

<p>Mask covariates and existing samples by access
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_access(raster, access, buff_inner = NULL, buff_outer)

mask_existing(access, existing, buff_inner = NULL, buff_outer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="masking_+3A_raster">raster</code></td>
<td>
<p>SpatRaster. Raster to be masked.</p>
</td></tr>
<tr><td><code id="masking_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="masking_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="masking_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="masking_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster/existing samples masked by provided <code>access</code> layer and buffers.
</p>

<hr>
<h2 id='matrices'>Matrices</h2><span id='topic+matrices'></span><span id='topic+mat_quant'></span><span id='topic+mat_cov'></span><span id='topic+mat_covNB'></span>

<h3>Description</h3>

<p>Create covariate and sample matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_quant(vals, nQuant, nb)

mat_cov(vals, nQuant, nb, matQ)

mat_covNB(vals, nQuant, nb, matQ)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrices_+3A_vals">vals</code></td>
<td>
<p>Covariate / sample data</p>
</td></tr>
<tr><td><code id="matrices_+3A_nquant">nQuant</code></td>
<td>
<p>Number of quantiles</p>
</td></tr>
<tr><td><code id="matrices_+3A_nb">nb</code></td>
<td>
<p>Number of bands</p>
</td></tr>
<tr><td><code id="matrices_+3A_matq">matQ</code></td>
<td>
<p>Quantile matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariate quantile and/or covariance matrices.
</p>

<hr>
<h2 id='plot'>Plot</h2><span id='topic+plot'></span><span id='topic+classPlot'></span><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>Plot
</p>
<p>Class Plot
</p>
<p>Scatter Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classPlot(dfc, coordsgrps, mraster, mraster2, samp = 0.01)

plot_scatter(mraster, existing, reverse = FALSE, samp = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_dfc">dfc</code></td>
<td>
<p>data.frame. Values for mraster and mraster2</p>
</td></tr>
<tr><td><code id="plot_+3A_coordsgrps">coordsgrps</code></td>
<td>
<p>List. Cartesian coordinates of each strata</p>
</td></tr>
<tr><td><code id="plot_+3A_mraster">mraster</code></td>
<td>
<p>Spatraster. Raster to stratify. Layers in <code>mraster</code> must match the number of
<code>breaks</code> vectors provided.</p>
</td></tr>
<tr><td><code id="plot_+3A_samp">samp</code></td>
<td>
<p>Numeric. Determines proportion of cells to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="plot_+3A_reverse">reverse</code></td>
<td>
<p>Logical. Reverse x and y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scatter plot of available raster cells coloured and delineated by stratum.
</p>


<h3>Note</h3>

<p>Population in viridis and samples in red.
</p>

<hr>
<h2 id='prepare_existing'>Prepare existing sample data</h2><span id='topic+prepare_existing'></span>

<h3>Description</h3>

<p>This function prepares the existing sample data by ensuring that it meets the necessary requirements for downstream analysis.
If the 'existing' object is not of class 'sf', this function checks that the data contains columns named &quot;X&quot; and &quot;Y&quot;, and
converts lowercase &quot;x&quot; and &quot;y&quot; column names to uppercase if necessary. If the 'raster' object is supplied, this function
checks if 'existing' contains attributes with the same names as 'raster'. If it does not, this function extracts metrics
at existing sample locations using the 'raster' object. If 'access' is not null, the function masks the existing sample
locations with a buffered access area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_existing(
  existing,
  raster = NULL,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_existing_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="prepare_existing_+3A_raster">raster</code></td>
<td>
<p>SpatRaster. Raster to guide the location of the samples. If <code>type = "clhs"</code> this raster can also
be used to define the population distributions to be used for sampling.</p>
</td></tr>
<tr><td><code id="prepare_existing_+3A_access">access</code></td>
<td>
<p>sf. Road access network - must be lines.</p>
</td></tr>
<tr><td><code id="prepare_existing_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="prepare_existing_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
</table>

<hr>
<h2 id='rules'>Sampling rules</h2><span id='topic+rules'></span><span id='topic+strat_rule1'></span><span id='topic+strat_rule2'></span><span id='topic+ahels_nSamp'></span><span id='topic+ahels_threshold'></span>

<h3>Description</h3>

<p>Sampling rules
</p>
<p>Stratified rule 1
</p>
<p>Stratified rule 2
</p>
<p>AHELS nSamp
</p>
<p>AHELS threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_rule1(n, s, i, strat_mask, add_strata, extraCols, mindist)

strat_rule2(n, s, add_strata, nCount, strata_m, extraCols, mindist)

ahels_nSamp(
  nSamp,
  nQuant,
  tolerance,
  nb,
  underRep,
  ratio,
  ratOrderUnder,
  matCovDens,
  matCovSampDens,
  samples,
  mats,
  vals
)

ahels_threshold(
  threshold,
  tolerance,
  nQuant,
  nb,
  ratio,
  underRep,
  ratOrderUnder,
  matCovDens,
  matCovSampDens,
  samples,
  mats,
  vals
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rules_+3A_mindist">mindist</code></td>
<td>
<p>Numeric. Minimum allowable distance between selected
samples. <code>Default = NULL</code>.</p>
</td></tr>
<tr><td><code id="rules_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples. <code>existing</code>, <code>include</code> and <code>force</code> influence this value.</p>
</td></tr>
<tr><td><code id="rules_+3A_nquant">nQuant</code></td>
<td>
<p>Numeric. Number of quantiles to divide covariates and samples into. Quantiles that do not
cover at least 1 percent of the area of interest will be excluded and be returned as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="rules_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric. Allowable tolerance (&lt;= 0.1 (10
added until the <code>1 - tolerance</code> density is reached. If <code>threshold</code> is used, samples will be added until the
<code>threshold - tolerance</code> value is reached. This parameter allows the user to define a buffer around desired quantile densities
to permit the algorithm to not add additional samples if quantile density is very close to 1, or user-defined <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="rules_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Sample quantile ratio threshold. After the threshold <code>default = 0.9</code> is reached,
no additional samples will be added. Values close to 1 can cause the algorithm to continually loop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Allocated samples to be returned by <code>sample_strat()</code> &amp; <code>sample_ahels()</code>.
</p>

<hr>
<h2 id='sample_ahels'>Adapted Hypercube Evaluation of a Legacy Sample (ahels)</h2><span id='topic+sample_ahels'></span>

<h3>Description</h3>

<p>Perform the adapted Hypercube Evaluation of a Legacy Sample (ahels) algorithm using
existing site data and raster metrics. New samples are allocated based on quantile ratios between
the existing sample and covariate dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_ahels(
  mraster,
  existing,
  nQuant = 10,
  nSamp = NULL,
  threshold = 0.9,
  tolerance = 0,
  matrices = NULL,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_ahels_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_nquant">nQuant</code></td>
<td>
<p>Numeric. Number of quantiles to divide covariates and samples into. Quantiles that do not
cover at least 1 percent of the area of interest will be excluded and be returned as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Maximum number of new samples to allocate.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Sample quantile ratio threshold. After the threshold <code>default = 0.9</code> is reached,
no additional samples will be added. Values close to 1 can cause the algorithm to continually loop.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric. Allowable tolerance (&lt;= 0.1 (10
added until the <code>1 - tolerance</code> density is reached. If <code>threshold</code> is used, samples will be added until the
<code>threshold - tolerance</code> value is reached. This parameter allows the user to define a buffer around desired quantile densities
to permit the algorithm to not add additional samples if quantile density is very close to 1, or user-defined <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_matrices">matrices</code></td>
<td>
<p>List. Quantile and covariance matrices generated from <code>calculate_pop(mraster = mraster, nQuant = nQuant)</code>.
Both <code>mraster</code> &amp; <code>nQuant</code> inputs must be the same to supply the covariance matrix. Supplying the matrix allows users
with very large <code>mrasters</code> to pre-process the covariance matrix to avoid longer sampling processing times. If <code>matrices</code> is
provided, the <code>nQuant</code> parameter is ignored and taken from the covariance matrix.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots samples of type <code>existing</code> (if provided; crosses) and <code>new</code> (circles) along with <code>mraster</code>.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
systematic samples. If <code>TRUE</code> returns a list of sf objects where <code>tessellation</code>
is the tessellation grid for sampling, and <code>samples</code> are the systematic samples.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_ahels_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns sf point object with existing samples and supplemental samples added by the ahels algorithm.
</p>


<h3>Note</h3>

<p>Messages in the algorithm will state that samples have been added to under-represented quantiles. The number between
square brackets that follow represent the matrix row and column respectively that can be printed using <code>details = TRUE</code>.
</p>
<p>In some cases, generally when a single metric is used as <code>mraster</code>, sampling ratios all be &gt;= 1 before the
<code>nSamp</code> number of samples are allocated. The algorithm will stop in this scenario.
</p>
<p>Special thanks to Dr. Brendan Malone for the original implementation of this algorithm.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Malone BP, Minasny B, Brungard C. 2019. Some methods to improve the utility of conditioned Latin hypercube sampling. PeerJ 7:e6451 DOI 10.7717/peerj.6451
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Load raster and existing plots---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

sample_ahels(
  mraster = mr,
  existing = e,
  plot = TRUE
)

#--- supply quantile and covariance matrices ---#
mat &lt;- calculate_pop(mraster = mr)

sample_ahels(
  mraster = mr,
  existing = e,
  matrices = mat,
  nSamp = 300
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sample_balanced'>Balanced sampling</h2><span id='topic+sample_balanced'></span>

<h3>Description</h3>

<p>Balanced raster sampling using <code><a href="BalancedSampling.html#topic+lcube">lcube</a></code> and
<code><a href="SamplingBigData.html#topic+lpm2_kdtree">lpm2_kdtree</a></code> methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_balanced(
  mraster,
  nSamp,
  algorithm = "lpm2_kdtree",
  p = NULL,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_balanced_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. One of <code>lpm2_kdtree, lcube, lcubestratified</code>.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_p">p</code></td>
<td>
<p>Numeric. Vector with length equal to the number of cells in <code>mraster</code> representing
the inclusion probability for each candidate sample. Default = <code>nSamp / N</code>, where <code>N</code>
is the number of cells.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="sample_balanced_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with <code>nSamp</code> samples.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Anton Grafström and Jonathan Lisic (2019). BalancedSampling: Balanced and Spatially
Balanced Sampling. R package version 1.5.5. https://CRAN.R-project.org/package=BalancedSampling
</p>
<p>Jonathan Lisic and Anton Grafström (2018). SamplingBigData: Sampling Methods for
Big Data. R package version 1.0.0. https://CRAN.R-project.org/package=SamplingBigData
</p>
<p>Grafström, A. Lisic, J (2018). BalancedSampling: Balanced and Spatially Balanced Sampling.
R package version 1.5.4. http://www.antongrafstrom.se/balancedsampling
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and existing plots---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

sample_balanced(
  mraster = mr,
  nSamp = 200
)

</code></pre>

<hr>
<h2 id='sample_clhs'>Conditioned Latin Hypercube Sampling</h2><span id='topic+sample_clhs'></span>

<h3>Description</h3>

<p>Conditioned Latin Hypercube Sampling using <code><a href="clhs.html#topic+clhs">clhs</a></code> functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_clhs(
  mraster,
  nSamp,
  iter = 10000,
  cost = NULL,
  existing = NULL,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_clhs_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_iter">iter</code></td>
<td>
<p>Numeric. Value giving the number of iterations within the Metropolis-Hastings process.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_cost">cost</code></td>
<td>
<p>Numeric/Character. Index or name of covariate within <code>mraster</code> to be used to constrain cLHS sampling.
If default (<code>NULL</code>), a cost constraint is not used.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="sample_clhs_+3A_...">...</code></td>
<td>
<p>Additional arguments for clhs sampling. See <code><a href="clhs.html#topic+clhs">clhs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with <code>nSamp</code> stratified samples.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>Minasny, B. and McBratney, A.B. 2006. A conditioned Latin hypercube method
for sampling in the presence of ancillary information. Computers and
Geosciences, 32:1378-1388.
</p>
<p>Minasny, B. and A. B. McBratney, A.B.. 2010. Conditioned Latin Hypercube
Sampling for Calibrating Soil Sensor Data to Soil Properties. In: Proximal
Soil Sensing, Progress in Soil Science, pages 111-119.
</p>
<p>Roudier, P., Beaudette, D.E. and Hewitt, A.E. 2012. A conditioned Latin
hypercube sampling algorithm incorporating operational constraints. In:
Digital Soil Assessments and Beyond. Proceedings of the 5th Global Workshop
on Digital Soil Mapping, Sydney, Australia.
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and existing plots---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

e &lt;- system.file("extdata", "existing.shp", package = "sgsR")
e &lt;- sf::st_read(e)

a &lt;- system.file("extdata", "access.shp", package = "sgsR")
ac &lt;- sf::st_read(a)

sample_clhs(
  mraster = mr,
  nSamp = 200,
  plot = TRUE,
  iter = 100
)

sample_clhs(
  mraster = mr,
  nSamp = 400,
  existing = e,
  iter = 250,
  details = TRUE
)

</code></pre>

<hr>
<h2 id='sample_existing'>Sample existing</h2><span id='topic+sample_existing'></span>

<h3>Description</h3>

<p>Sub-sample an existing sample. Four sampling methods are available:
<code>clhs</code>, <code>balanced</code>, <code>srs</code> and <code>strat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_existing(
  existing,
  nSamp,
  raster = NULL,
  type = "clhs",
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_existing_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_raster">raster</code></td>
<td>
<p>SpatRaster. Raster to guide the location of the samples. If <code>type = "clhs"</code> this raster can also
be used to define the population distributions to be used for sampling.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_type">type</code></td>
<td>
<p>Character. A string indicating the type of sampling method to use.
Possible values are <code>"clhs"</code>, <code>"balanced"</code>, <code>"srs"</code> and <code>"strat"</code>.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_access">access</code></td>
<td>
<p>sf. Road access network - must be lines.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
systematic samples. If <code>TRUE</code> returns a list of sf objects where <code>tessellation</code>
is the tessellation grid for sampling, and <code>samples</code> are the systematic samples.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="sample_existing_+3A_...">...</code></td>
<td>
<p>Additional arguments for the sampling method selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object of samples or a list object if <code>details = TRUE</code>
</p>


<h3>Note</h3>

<p>When <code>type = "clhs"</code> or <code>type = "balanced"</code> all attributes in <code>existing</code> will be used for sampling.
Remove attributes not indented for sampling' prior to using this algorithm.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#--- generate an existing sample adn extract metrics ---#
e &lt;- sample_systematic(raster = mr, cellsize = 200)
e &lt;- extract_metrics(existing = e, mraster = mr)

#--- perform clhs (default) sub-sampling ---#
sample_existing(
  existing = e,
  nSamp = 50
)

#--- perform balanced sub-sampling ---#
sample_existing(
  existing = e,
  nSamp = 50,
  type = "balanced"
)

#--- perform simple random sub-sampling ---#
sample_existing(
  existing = e,
  nSamp = 50,
  type = "srs"
)

</code></pre>

<hr>
<h2 id='sample_existing_balanced'>Sample Existing Data Using Balanced Sampling</h2><span id='topic+sample_existing_balanced'></span>

<h3>Description</h3>

<p>This function samples a given set of existing data using balanced sampling techniques,
which ensures that each stratum or subgroup of data is proportionally represented in the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_existing_balanced(
  existing,
  nSamp,
  algorithm = "lpm2_kdtree",
  p = NULL,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_existing_balanced_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. One of <code>lpm2_kdtree, lcube, lcubestratified</code>.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_p">p</code></td>
<td>
<p>Numeric. Vector with length equal to the number of cells in <code>mraster</code> representing
the inclusion probability for each candidate sample. Default = <code>nSamp / N</code>, where <code>N</code>
is the number of cells.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
<tr><td><code id="sample_existing_balanced_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the selected sampling algorithm.
This is leveraged when used by <code>sample_existing()</code> internally</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object that is a sub-sample of <code>existing</code>
</p>

<hr>
<h2 id='sample_existing_clhs'>Sub-sample using the conditional Latin hypercube sampling (CLHS)</h2><span id='topic+sample_existing_clhs'></span>

<h3>Description</h3>

<p>This function takes an existing <code>sf</code> object and returns a random sub-sample of size <code>nSamp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_existing_clhs(
  existing,
  nSamp,
  raster = NULL,
  cost = NULL,
  iter = 10000,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_existing_clhs_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_cost">cost</code></td>
<td>
<p>Numeric/Character. Index or name of covariate within <code>mraster</code> to be used to constrain cLHS sampling.
If default (<code>NULL</code>), a cost constraint is not used.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_iter">iter</code></td>
<td>
<p>Numeric. Value giving the number of iterations within the Metropolis-Hastings process.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="sample_existing_clhs_+3A_...">...</code></td>
<td>
<p>Additional arguments for clhs sampling. See <code><a href="clhs.html#topic+clhs">clhs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subsampled SpatialPointsDataFrame object.
</p>

<hr>
<h2 id='sample_existing_srs'>Randomly sample from an existing dataset</h2><span id='topic+sample_existing_srs'></span>

<h3>Description</h3>

<p>This function takes an existing <code>sf</code> object and returns a random sub-sample of size <code>nSamp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_existing_srs(existing, nSamp, filename = NULL, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_existing_srs_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_existing_srs_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_existing_srs_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_existing_srs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or spatial data frame containing the random sample.
</p>

<hr>
<h2 id='sample_existing_strat'>Sample Existing Data Based on Strata</h2><span id='topic+sample_existing_strat'></span>

<h3>Description</h3>

<p>This function takes a data frame of existing data, a data frame of desired sample sizes
for each strata, the number of samples to take, and optionally a file name and overwrite
parameter. It returns a sample of the existing data based on the desired sample sizes for
each strata, and optionally writes the resulting samples to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_existing_strat(
  existing,
  toSample,
  nSamp,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_existing_strat_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT'.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_existing_strat_+3A_tosample">toSample</code></td>
<td>
<p>A data frame specifying the desired sample sizes for each strata.</p>
</td></tr>
<tr><td><code id="sample_existing_strat_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples. <code>existing</code>, <code>include</code> and <code>force</code> influence this value.</p>
</td></tr>
<tr><td><code id="sample_existing_strat_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_existing_strat_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object that is a sub-sample of <code>existing</code>
</p>

<hr>
<h2 id='sample_nc'>Nearest centroid (NC) sampling</h2><span id='topic+sample_nc'></span>

<h3>Description</h3>

<p>Sampling using the nearest centroid (NC) approach described in Melville &amp; Stone (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_nc(
  mraster,
  nSamp,
  k = 1,
  iter = 500,
  algorithm = "Lloyd",
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_nc_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_k">k</code></td>
<td>
<p>Numeric. The number of nearest neighbours to take for each k-means center.
When <code>k = 1</code> (default), the output number of samples will match <code>nSamp</code>.
Increases to <code>k</code> results in a multiplicative result total number of samples <code>nSamp * k</code>.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_iter">iter</code></td>
<td>
<p>Numeric. The maximum number of kmeans iterations allowed.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. <code>Lloyd</code> (default) or
<code>MacQueen</code> kmeans algorithms.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_plot">plot</code></td>
<td>
<p>Logical. Plot <code>mraster</code> with allocated samples.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="sample_nc_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with <code>nSamp</code> randomly sampled points.
</p>


<h3>Note</h3>

<p>When <code>details = TRUE</code>, a list is returned where:
</p>

<ol>
<li> <p><code>samples</code> output nearest centroid samples with <code>kcenter</code> attribute linking
to associated kmeans centers.
</p>
</li>
<li> <p><code>kmeans</code> is a list output of the <code><a href="stats.html#topic+kmeans">kmeans</a></code> function
</p>
</li>
<li> <p><code>centers</code> Un-scaled kmeans center values for each layer in <code>mraster</code>
with <code>kcenter</code> attribute to link with the same attribute in <code>samples</code>.
</p>
</li>
<li> <p><code>kplot</code> is a <code>ggplot</code> scatterplot object visualizing the kmeans centers
and associated nearest neighbor samples.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>References</h3>

<p>G. Melville &amp; C. Stone (2016) Optimising nearest neighbour information—a simple,
efficient sampling strategy for forestry plot imputation using remotely sensed data,
Australian Forestry, 79:3, 217-228, DOI: 10.1080/00049158.2016.1218265
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#--- perform simple random sampling ---#
sample_nc(
  mraster = mr,
  nSamp = 5,
)

</code></pre>

<hr>
<h2 id='sample_srs'>Simple random sampling</h2><span id='topic+sample_srs'></span>

<h3>Description</h3>

<p>Randomly sample within a stratification raster extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_srs(
  raster,
  nSamp,
  mindist = NULL,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_srs_+3A_raster">raster</code></td>
<td>
<p>spatRaster. Raster to be used for random sampling.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_mindist">mindist</code></td>
<td>
<p>Numeric. Minimum allowable distance between selected
samples. <code>Default = NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_srs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with <code>nSamp</code> randomly sampled points.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody &amp; Martin Queinnec
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sr &lt;- terra::rast(r)

a &lt;- system.file("extdata", "access.shp", package = "sgsR")
ac &lt;- sf::st_read(a)

#--- perform simple random sampling ---#
sample_srs(
  raster = sr,
  nSamp = 200,
)

</code></pre>

<hr>
<h2 id='sample_strat'>Stratified sampling</h2><span id='topic+sample_strat'></span>

<h3>Description</h3>

<p>Sampling based on a stratified raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_strat(
  sraster,
  nSamp,
  allocation = "prop",
  method = "Queinnec",
  weights = NULL,
  force = FALSE,
  mraster = NULL,
  mindist = NULL,
  existing = NULL,
  include = FALSE,
  remove = FALSE,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  wrow = 3,
  wcol = 3,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_strat_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratification raster to be used for sampling.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. Number of desired samples. <code>existing</code>, <code>include</code> and <code>force</code> influence this value.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_allocation">allocation</code></td>
<td>
<p>Character. Allocation algorithm to be used. Either <code>prop</code> (default) for proportional allocation,
<code>optim</code> for optimal allocation (equal sampling cost), <code>equal</code> for equal number of samples (defined by <code>nSamp</code>)
for each strata, or <code>"manual"</code> for user defined strata weights defined using <code>weights</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_method">method</code></td>
<td>
<p>Character. Sampling design approach <code>"Queinnec"</code> (default) or <code>"random"</code>. <code>"Queinnec"</code> method is
described in notes below. <code>"random"</code> performs traditional stratified random sampling where probability to sample each
cell within each stratum is equal assuming default parameters for <code>mindist</code>. <code>existing, include, remove</code> are ignored when <code>method = "random"</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_weights">weights</code></td>
<td>
<p>Numeric. Only applicable when <code>allocation = "manual"</code>. Vector of weights where <code>sum(weights) == 1</code>. Vector length
must be equal to the number of unique strata where the first numeric value corresponds to stratum 1, second stratum 2 etc.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_force">force</code></td>
<td>
<p>Logical. <code>Default = FALSE</code> - force <code>nSamp</code> to be exactly the user defined value
in cases where <code>nSamp</code> and <code>sraster</code> strata count are not equally divisible. Additional samples often need to be allocated or removed
based on rounding differences resulting from proportional differences between <code>nSamp</code> and strata coverages in <code>sraster</code>.
In these instances samples are either added to strata with the lowest number of samples or are removed from strata with the highest number of samples.
Has no effect when <code>existing</code> is provided.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metric raster. Required when <code>allocation = optim</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_mindist">mindist</code></td>
<td>
<p>Numeric. Minimum allowable distance between selected
samples. <code>Default = NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_existing">existing</code></td>
<td>
<p>sf 'POINT' or data.frame.  Existing plot network.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_include">include</code></td>
<td>
<p>Logical. If <code>TRUE</code> include <code>existing</code> plots in <code>nSamp</code> total.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_remove">remove</code></td>
<td>
<p>Logical. If <code>TRUE</code> randomly remove samples from over represented strata to meet allocated sample numbers.
Used only when <code>existing</code> and <code>include</code> are both <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_access">access</code></td>
<td>
<p>sf 'LINESTRING' or 'MULTILINESTRING'. Access network.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_wrow">wrow</code></td>
<td>
<p>Numeric. Number of row in the focal window (<code>default = 3</code>).</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_wcol">wcol</code></td>
<td>
<p>Numeric. Number of columns in the focal window (<code>default = 3</code>).</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots samples of type 'existing' (if provided; croses) and 'new' (circles) along with <code>sraster</code>.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
stratified samples. If <code>TRUE</code> return a list
where <code>$details</code> additional sampling information and <code>$raster</code>
is an sf object of stratified samples.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_strat_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with <code>nSamp</code> stratified samples.
</p>


<h3>Note</h3>

<p>The sampling is performed in 2 stages when <code>method = "Queinnec"</code>:
</p>

<ol>
<li> <p><code>Rule 1</code> - Sample within grouped stratum pixels defined within the
<code>wrow, wcol</code> parameters
</p>
</li>
<li> <p><code>Rule 2</code> - If no samples exist to satisfy Rule 1
individual stratum pixels are sampled.
</p>
<p>The rule applied to allocate each sample is defined in the <code>rule</code> attribute of output samples.
</p>
</li></ol>

<p><code>existing</code> may contain samples that fall in <code>sraster</code> cells that are 'NA'. If this occurs and <code>include = TRUE</code>, 'NA' samples
are separated during sampling and re-appended at the end of the sampling process.
</p>
<p>If the <code>sraster</code> provided contains factor values, the algorithm will automatically convert these into the numeric factor levels and
perform sampling using those values. The categories (factor values) will be extracted and appended to the algorithm output as the 'category' attribute.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody &amp; Martin Queinnec
</p>


<h3>References</h3>

<p>Queinnec, M., White, J. C., &amp; Coops, N. C. (2021).
Comparing airborne and spaceborne photon-counting LiDAR canopy
structural estimates across different boreal forest types.
Remote Sensing of Environment, 262 (August 2020), 112510.
https://doi.org/10.1016/j.rse.2021.112510
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sr &lt;- terra::rast(r)


#--- perform stratified sampling random sampling ---#
sraster &lt;- sample_strat(
  sraster = sr,
  nSamp = 50
)

</code></pre>

<hr>
<h2 id='sample_sys_strat'>Systematic stratified sampling</h2><span id='topic+sample_sys_strat'></span>

<h3>Description</h3>

<p>Systematic stratified sampling with random start point and translation within a square or hexagonal tessellation for each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sys_strat(
  sraster,
  cellsize,
  square = TRUE,
  location = "centers",
  force = FALSE,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_sys_strat_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster. Stratified raster with name <code>"strata"</code>.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_cellsize">cellsize</code></td>
<td>
<p>Numeric. Desired cellsize for tessellation.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_square">square</code></td>
<td>
<p>Logical. Tessellation shape. Default is regular square grid,
if <code>FALSE</code> hexagons are used.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_location">location</code></td>
<td>
<p>Character. Sample location within tessellation. <code>Default = "centers"</code>)
returns samples at tessellation centers, <code>"corners"</code> - corners of tessellation are returned,
<code>"random"</code> - samples are randomly located within tessellations.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_force">force</code></td>
<td>
<p>Logical. Only applies when <code>location = "random"</code>. If <code>TRUE</code>, random samples are
forced to fall in areas where <code>raster</code> does not have <code>NA</code> values. This will considerably slow processing.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_access">access</code></td>
<td>
<p>sf. Road access network - must be lines.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="sample_sys_strat_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
systematic samples. If <code>TRUE</code> returns a list of sf objects where <code>tessellation</code>
is the tessellation grid for sampling, and <code>samples</code> are the systematic samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with sampled points over unique tessellations.
</p>


<h3>Note</h3>

<p>Specifying <code>location = "random"</code> can result in tessellations with no samples.
This results from <code>raster</code> have <code>NA</code> values at the random location chosen.
Using <code>force = TRUE</code> removes areas of <code>NA</code> from sampling entirely, but
considerably slows processing speeds. Thanks to R. Hijmans for help in debugging and
providing suggestions for this script.
</p>
<p>All stratum are sampled using random tessellation start points and translations.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_systematic">sample_systematic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sr &lt;- terra::rast(r)

#--- perform grid sampling ---#
sample_sys_strat(
  sraster = sr,
  cellsize = 1000
)

sample_sys_strat(
  sraster = sr,
  cellsize = 1000,
  square = FALSE,
  location = "corners"
)

</code></pre>

<hr>
<h2 id='sample_systematic'>Systematic sampling</h2><span id='topic+sample_systematic'></span>

<h3>Description</h3>

<p>Systematic sampling with random start point and translation within a square or hexagonal tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_systematic(
  raster,
  cellsize,
  square = TRUE,
  location = "centers",
  force = FALSE,
  access = NULL,
  buff_inner = NULL,
  buff_outer = NULL,
  plot = FALSE,
  filename = NULL,
  overwrite = FALSE,
  details = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_systematic_+3A_raster">raster</code></td>
<td>
<p>spatRaster. Raster used to define extent of fishnet grid.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_cellsize">cellsize</code></td>
<td>
<p>Numeric. Desired cellsize for tessellation.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_square">square</code></td>
<td>
<p>Logical. Tessellation shape. Default is regular square grid,
if <code>FALSE</code> hexagons are used.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_location">location</code></td>
<td>
<p>Character. Sample location within tessellation. <code>Default = "centers"</code>)
returns samples at tessellation centers, <code>"corners"</code> - corners of tessellation are returned,
<code>"random"</code> - samples are randomly located within tessellations.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_force">force</code></td>
<td>
<p>Logical. Only applies when <code>location = "random"</code>. If <code>TRUE</code>, random samples are
forced to fall in areas where <code>raster</code> does not have <code>NA</code> values. This will considerably slow processing.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_access">access</code></td>
<td>
<p>sf. Road access network - must be lines.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_buff_inner">buff_inner</code></td>
<td>
<p>Numeric. Inner buffer boundary specifying distance
from access where plots cannot be sampled.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_buff_outer">buff_outer</code></td>
<td>
<p>Numeric. Outer buffer boundary specifying distance
from access where plots can be sampled.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster with samples.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is sf object of
systematic samples. If <code>TRUE</code> returns a list of sf objects where <code>tessellation</code>
is the tessellation grid for sampling, and <code>samples</code> are the systematic samples.</p>
</td></tr>
<tr><td><code id="sample_systematic_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="sf.html#topic+st_make_grid">st_make_grid</a></code>. Options include <code>offset</code>
to offset grid by providing lower left coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with sampled points over a tessellation.
</p>


<h3>Note</h3>

<p>Specifying <code>location = "random"</code> can result in tessellations with no samples.
This results from <code>raster</code> have <code>NA</code> values at the random location chosen.
Using <code>force = TRUE</code> removes areas of <code>NA</code> from sampling entirely, but
considerably slows processing speeds. Thanks to R. Hijmans for help in debugging and
providing suggestions for this script.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody, Lukas Winiwarter
</p>


<h3>See Also</h3>

<p>Other sample functions: 
<code><a href="#topic+sample_ahels">sample_ahels</a>()</code>,
<code><a href="#topic+sample_balanced">sample_balanced</a>()</code>,
<code><a href="#topic+sample_clhs">sample_clhs</a>()</code>,
<code><a href="#topic+sample_existing">sample_existing</a>()</code>,
<code><a href="#topic+sample_nc">sample_nc</a>()</code>,
<code><a href="#topic+sample_srs">sample_srs</a>()</code>,
<code><a href="#topic+sample_strat">sample_strat</a>()</code>,
<code><a href="#topic+sample_sys_strat">sample_sys_strat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)
#--- perform grid sampling ---#
sample_systematic(
  raster = mr,
  cellsize = 1000
)

sample_systematic(
  raster = mr,
  cellsize = 1000,
  location = "corners",
  plot = TRUE
)

sample_systematic(
  raster = mr,
  cellsize = 1000,
  square = FALSE,
  location = "random",
  plot = TRUE
)

</code></pre>

<hr>
<h2 id='strat_breaks'>Breaks stratification</h2><span id='topic+strat_breaks'></span>

<h3>Description</h3>

<p>Stratify metrics raster using user defined breaks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_breaks(
  mraster,
  breaks,
  map = FALSE,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_breaks_+3A_mraster">mraster</code></td>
<td>
<p>Spatraster. Raster to stratify. Layers in <code>mraster</code> must match the number of
<code>breaks</code> vectors provided.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_breaks">breaks</code></td>
<td>
<p>Numeric. Vector of breakpoints for each layer of <code>mraster</code>. If <code>mraster</code> has multiple layers,
<code>breaks</code> must be a list with an equal number of objects.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_map">map</code></td>
<td>
<p>Logical. Map individual stratified layers to a combined stratification. Will output a multi-layer
<code>SpatRaster</code> with individual stratifications for each <code>mraster</code> layer and an additional mapped stratification
named <code>"strata"</code>.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="strat_breaks_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an output stratification <code>spatRaster</code> or a list when <code>details = TRUE</code>.
</p>
<p>When a list is returned:
</p>

<ol>
<li> <p><code>raster</code> is a stratified <code>spatRaster</code> based on quantiles. If <code>stack = TRUE</code> will
be the number of layers of <code>mraster</code> plus the final output
</p>
</li>
<li> <p><code>breaks</code> is a list output of <code>breaks</code>
</p>
</li>
<li> <p><code>plot</code> is a <code>ggplot</code> histogram object showing distribution(s) and break point(s).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other stratify functions: 
<code><a href="#topic+strat_kmeans">strat_kmeans</a>()</code>,
<code><a href="#topic+strat_map">strat_map</a>()</code>,
<code><a href="#topic+strat_poly">strat_poly</a>()</code>,
<code><a href="#topic+strat_quantiles">strat_quantiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#--- create vector breaks ---#
br.zq90 &lt;- c(3, 5, 11, 18)
br.pz2 &lt;- c(20, 40, 60, 80)

strat_breaks(
  mraster = mr$zq90,
  breaks = br.zq90
)


strat_breaks(
  mraster = mr[[1:2]],
  breaks = list(br.zq90, br.pz2),
  details = TRUE
)
</code></pre>

<hr>
<h2 id='strat_kmeans'>k-means stratification</h2><span id='topic+strat_kmeans'></span>

<h3>Description</h3>

<p>Stratify metrics raster using <code><a href="stats.html#topic+kmeans">kmeans</a></code> algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_kmeans(
  mraster,
  nStrata,
  iter = 500,
  algorithm = "Lloyd",
  center = TRUE,
  scale = TRUE,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_kmeans_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_nstrata">nStrata</code></td>
<td>
<p>Numeric. Number of desired strata.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_iter">iter</code></td>
<td>
<p>Numeric. The maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. <code>"Lloyd"</code> (default) or
<code>"MacQueen"</code> algorithms.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_center">center</code></td>
<td>
<p>Logical. Value indicating whether the variables should be shifted to be zero centered.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_scale">scale</code></td>
<td>
<p>Logical. Value indicating whether the variables should be scaled to have unit variance.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
<tr><td><code id="strat_kmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output stratification <code>spatRaster</code>, or a list when <code>details = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other stratify functions: 
<code><a href="#topic+strat_breaks">strat_breaks</a>()</code>,
<code><a href="#topic+strat_map">strat_map</a>()</code>,
<code><a href="#topic+strat_poly">strat_poly</a>()</code>,
<code><a href="#topic+strat_quantiles">strat_quantiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and access files ---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

#--- perform stratification using k-means ---#
kmeans &lt;- strat_kmeans(
  mraster = mr,
  nStrata = 5
)

kmeans &lt;- strat_kmeans(
  mraster = mr,
  nStrata = 5,
  iter = 1000,
  algorithm = "MacQueen",
  details = TRUE
)

</code></pre>

<hr>
<h2 id='strat_map'>Map a raster stack of a list of rasters</h2><span id='topic+strat_map'></span>

<h3>Description</h3>

<p>Map stratified rasters to a combined stratification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_map(
  sraster,
  stack = FALSE,
  filename = NULL,
  overwrite = FALSE,
  plot = FALSE,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_map_+3A_sraster">sraster</code></td>
<td>
<p>spatRaster or list. Stratification raster stack or list of rasters. If <code>sraster</code>
is of class <code>list</code>, then it is internally converted into a raster stack.</p>
</td></tr>
<tr><td><code id="strat_map_+3A_stack">stack</code></td>
<td>
<p>Logical. Default = <code>FALSE</code>. If <code>TRUE</code>, inputs and output will be stacked:
<code>strata_1, strata_2, ..., strata</code>.</p>
</td></tr>
<tr><td><code id="strat_map_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="strat_map_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
<tr><td><code id="strat_map_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="strat_map_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is a mapped stratified spatRaster object.
If <code>TRUE</code> return a list where <code>$outRaster</code> is the mapped stratified raster, and
<code>$lookUp</code> is the lookup table for the stratification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatRaster object.
</p>


<h3>Mapping</h3>

<p>The mapping algorithm will take the stratification from <code>sraster</code> and combine it with
overlying strata values across all layers. This will result in a <code>strata</code> attribute
where the values from all inputs are combined.
</p>
<p>i.e.
</p>
<p>If <code>strata_1 = 1</code> and <code>strata_2 = 1</code> then <code>strata = 11</code>.
</p>
<p>If <code>strata_1 = 2</code> and <code>strata_2 = 14</code> then <code>strata = 214</code>.
</p>
<p>If <code>strata_1 = "A"</code> and <code>strata_2 = 14</code> then <code>strata = "A14"</code>.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody, Tommaso Trotto, Robert Hijmans
</p>


<h3>See Also</h3>

<p>Other stratify functions: 
<code><a href="#topic+strat_breaks">strat_breaks</a>()</code>,
<code><a href="#topic+strat_kmeans">strat_kmeans</a>()</code>,
<code><a href="#topic+strat_poly">strat_poly</a>()</code>,
<code><a href="#topic+strat_quantiles">strat_quantiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- load input metrics rasters ---#
raster &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sraster &lt;- terra::rast(raster)

#--- read polygon coverage ---#
poly &lt;- system.file("extdata", "inventory_polygons.shp", package = "sgsR")
fri &lt;- sf::st_read(poly)

#--- stratify polygon coverage ---#
#--- specify polygon attribute to stratify ---#

attribute &lt;- "NUTRIENTS"

#--- specify features within attribute &amp; how they should be grouped ---#
#--- as a single vector ---#

features &lt;- c("poor", "rich", "medium")

srasterfri &lt;- strat_poly(
  poly = fri,
  attribute = attribute,
  features = features,
  raster = sraster
)

#--- map srasters with raster stack ---#
stack &lt;- c(srasterfri, sraster)
strat_map(
  sraster = stack
)

#--- map sraster with list of rasters ---#
rast_list &lt;- list(srasterfri, sraster)
strat_map(
  sraster = rast_list,
  stack = TRUE,
  details = TRUE
)
</code></pre>

<hr>
<h2 id='strat_poly'>Stratify using polygons</h2><span id='topic+strat_poly'></span>

<h3>Description</h3>

<p>Stratify based on polygon coverage attributes and features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_poly(
  poly,
  attribute,
  features,
  raster,
  filename = NULL,
  overwrite = FALSE,
  plot = FALSE,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_poly_+3A_poly">poly</code></td>
<td>
<p>sf. Input polygon coverage. e.g. - forest resources inventory coverage.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_attribute">attribute</code></td>
<td>
<p>Character. Name of attribute within <code>poly</code> that will be stratified.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_features">features</code></td>
<td>
<p>Vector / list of vectors. Features within <code>attribute</code>
to guide stratification.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_raster">raster</code></td>
<td>
<p>spatRaster. Raster template to enable polygon to raster conversion.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output spatRaster.</p>
</td></tr>
<tr><td><code id="strat_poly_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is spatRaster object of
stratified polygon attributes. If <code>TRUE</code> return a list
where <code>$outRaster</code> is the stratified attributes, <code>$lookUp</code> is the lookup table
for the stratification, and <code>poly</code> is the defined polygon <code>attribute</code> with corresponding
<code>features / strata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatRaster object.
</p>


<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other stratify functions: 
<code><a href="#topic+strat_breaks">strat_breaks</a>()</code>,
<code><a href="#topic+strat_kmeans">strat_kmeans</a>()</code>,
<code><a href="#topic+strat_map">strat_map</a>()</code>,
<code><a href="#topic+strat_quantiles">strat_quantiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- load input metrics raster ---#
raster &lt;- system.file("extdata", "sraster.tif", package = "sgsR")
sraster &lt;- terra::rast(raster)

#--- read polygon coverage ---#
poly &lt;- system.file("extdata", "inventory_polygons.shp", package = "sgsR")
fri &lt;- sf::st_read(poly)

#--- stratify polygon coverage ---#
#--- specify polygon attribute to stratify ---#

attribute &lt;- "NUTRIENTS"

#--- specify features within attribute &amp; how they should be grouped ---#
#--- as a single vector ---#

features &lt;- c("poor", "rich", "medium")

srasterpoly &lt;- strat_poly(
  poly = fri,
  attribute = attribute,
  features = features,
  raster = sraster
)

#--- or as multiple lists ---#

g1 &lt;- "poor"
g2 &lt;- c("rich", "medium")

features &lt;- list(g1, g2)

srasterpoly &lt;- strat_poly(
  poly = fri,
  attribute = attribute,
  features = features,
  raster = sraster,
  details = TRUE
)
</code></pre>

<hr>
<h2 id='strat_quantiles'>Quantiles stratification</h2><span id='topic+strat_quantiles'></span>

<h3>Description</h3>

<p>Stratify metric raster using metric quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_quantiles(
  mraster,
  nStrata,
  map = FALSE,
  plot = FALSE,
  details = FALSE,
  filename = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_quantiles_+3A_mraster">mraster</code></td>
<td>
<p>spatRaster. ALS metrics raster.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_nstrata">nStrata</code></td>
<td>
<p>Numeric. A positive integer representing the number of desired classes
or a numeric vector of probabilities with values between <code>0-1</code>. If <code>mraster</code> has multiple layers,
<code>nStrata</code> must be a list with an equal number of objects.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_map">map</code></td>
<td>
<p>Logical. Map individual stratified layers to a combined stratification. Will output a multi-layer
<code>SpatRaster</code> with individual stratifications for each <code>mraster</code> layer and an additional mapped stratification
named <code>"strata"</code>.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots output strata raster and visualized
strata with boundary dividers.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_details">details</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default) output is only
stratification raster. If <code>TRUE</code> return a list where <code>$details</code> is additional
stratification information and <code>$raster</code> is the output stratification spatRaster.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write stratified raster to disc.</p>
</td></tr>
<tr><td><code id="strat_quantiles_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Specify whether <code>filename</code> should be overwritten on disc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an output stratification <code>spatRaster</code> or a list when <code>details = TRUE</code>.
</p>
<p>When a list is returned:
</p>

<ol>
<li> <p><code>details</code> lookUp table for stratification(s).
</p>
</li>
<li> <p><code>raster</code> is a stratified <code>spatRaster</code> based on quantiles
</p>
</li>
<li> <p><code>plot</code> is a <code>ggplot</code> histogram / scatter plot object (depends on whether metric2 was supplied).
Histogram shows distribution and break points.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Tristan R.H. Goodbody
</p>


<h3>See Also</h3>

<p>Other stratify functions: 
<code><a href="#topic+strat_breaks">strat_breaks</a>()</code>,
<code><a href="#topic+strat_kmeans">strat_kmeans</a>()</code>,
<code><a href="#topic+strat_map">strat_map</a>()</code>,
<code><a href="#topic+strat_poly">strat_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Load raster and existing plots---#
r &lt;- system.file("extdata", "mraster.tif", package = "sgsR")
mr &lt;- terra::rast(r)

strat_quantiles(
  mraster = mr$zq90,
  nStrata = 4
)

strat_quantiles(
  mraster = mr[[1:2]],
  nStrata = list(c(0.2, 0.4, 0.8), 3),
  map = TRUE
)

</code></pre>

<hr>
<h2 id='take_samples'>Take Samples Based on Strata</h2><span id='topic+take_samples'></span>

<h3>Description</h3>

<p>This function takes a data frame of existing data, a data frame of desired sample sizes
for each strata, and a strata variable name, and returns a sample of the existing data
based on the sample sizes for the specified strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>take_samples(existing, toSample, strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="take_samples_+3A_existing">existing</code></td>
<td>
<p>A data frame containing existing data.</p>
</td></tr>
<tr><td><code id="take_samples_+3A_tosample">toSample</code></td>
<td>
<p>A data frame specifying the desired sample sizes for each strata.</p>
</td></tr>
<tr><td><code id="take_samples_+3A_strata">strata</code></td>
<td>
<p>A string specifying the name of the variable used to define strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a sample of the existing data based on the sample sizes
for the specified strata.
</p>

<hr>
<h2 id='vectorize'>Vectorization helpers</h2><span id='topic+vectorize'></span><span id='topic+calculate_breaks'></span><span id='topic+calculate_quantile_breaks'></span><span id='topic+quantile_breaks_integer'></span><span id='topic+quantile_breaks'></span>

<h3>Description</h3>

<p>Vectorization helpers
</p>
<p>Breaks vectorize
</p>
<p>Quantile breaks
</p>
<p>Quantile vectorize by integer helper
</p>
<p>Quantile vectorize by probabilities vector helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_breaks(mraster, breaks)

calculate_quantile_breaks(mraster, nStrata)

quantile_breaks_integer(mraster, nStrata)

quantile_breaks(mraster, nStrata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectorize_+3A_mraster">mraster</code></td>
<td>
<p>Spatraster. Raster to stratify. Layers in <code>mraster</code> must match the number of
<code>breaks</code> vectors provided.</p>
</td></tr>
<tr><td><code id="vectorize_+3A_breaks">breaks</code></td>
<td>
<p>Numeric. Vector of breakpoints for each layer of <code>mraster</code>. If <code>mraster</code> has multiple layers,
<code>breaks</code> must be a list with an equal number of objects.</p>
</td></tr>
<tr><td><code id="vectorize_+3A_nstrata">nStrata</code></td>
<td>
<p>Numeric. A positive integer representing the number of desired classes
or a numeric vector of probabilities with values between <code>0-1</code>. If <code>mraster</code> has multiple layers,
<code>nStrata</code> must be a list with an equal number of objects.</p>
</td></tr>
</table>

<hr>
<h2 id='write'>Write</h2><span id='topic+write'></span><span id='topic+write_samples'></span><span id='topic+write_samples_df'></span><span id='topic+write_raster'></span>

<h3>Description</h3>

<p>Write
</p>
<p>Write samples
</p>
<p>Write table
</p>
<p>Write raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_samples(samples, filename = NULL, overwrite = FALSE)

write_samples_df(samples, filename = NULL, overwrite = FALSE)

write_raster(raster, filename = NULL, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_+3A_filename">filename</code></td>
<td>
<p>Character. Path to write output samples.</p>
</td></tr>
<tr><td><code id="write_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Choice to overwrite existing <code>filename</code> if it exists.</p>
</td></tr>
<tr><td><code id="write_+3A_raster">raster</code></td>
<td>
<p>SpatRaster. Raster to be written to disc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No explicit output but files are written to disc if specified.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
