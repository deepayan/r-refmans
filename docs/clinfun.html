<!DOCTYPE html><html lang="en"><head><title>Help for package clinfun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clinfun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aucVardiTest'><p>Two-Sample Tests for Growth Curves under Dependent Right Censoring</p></a></li>
<li><a href='#calogrank'><p>Survival curves analysis of covariance</p></a></li>
<li><a href='#clinfun-internal'><p>Internal clinfun functions</p></a></li>
<li><a href='#coxphCPE'><p>Concordance Probability Estimate for Cox model</p></a></li>
<li><a href='#coxphERR'><p>Heller Explained Relative Risk</p></a></li>
<li><a href='#coxphQuantile'><p>Survival time quantile as a function of covariate</p></a></li>
<li><a href='#deltaAUC'><p>Comparing the AUC from ROC curves from nested binary regression</p></a></li>
<li><a href='#fedesign'><p>Trial Designs Based On Fisher's Exact Test</p></a></li>
<li><a href='#gsdesign'><p>Group Sequential Designs</p></a></li>
<li><a href='#jonckheere.test'><p>Exact/permutation version of Jonckheere-Terpstra test</p></a></li>
<li><a href='#ktau'><p>Kendall's tau-b estimate</p></a></li>
<li><a href='#oc.twostage.bdry'><p>Two-stage boundary operating characteristics</p></a></li>
<li><a href='#permlogrank'><p>Permutation version of survdiff</p></a></li>
<li><a href='#ph2simon'><p>Simon's 2-stage Phase II design</p></a></li>
<li><a href='#ph2single'><p>Exact single stage Phase II design</p></a></li>
<li><a href='#power.ladesign'><p>Power of k-sample rank test under Lehmann alternative</p></a></li>
<li><a href='#pselect'><p>Probability of selection under pick the winner rule</p></a></li>
<li><a href='#roc.area.test'><p>Nonparametric area under the ROC curve</p></a></li>
<li><a href='#roc.curve'><p>Empirical ROC curve</p></a></li>
<li><a href='#roc.perm.test'><p>Permutation test to compare ROC curve</p></a></li>
<li><a href='#ROCanalysis'>
<p>Functions to plot and compare ROC curves.</p></a></li>
<li><a href='#toxbdry'><p>Stopping rule for toxicity/futility monitoring</p></a></li>
<li><a href='#twostage.admissible'><p>Admissible design options between Minimax and Optimal</p></a></li>
<li><a href='#twostage.inference'><p>Inference following a two-stage design for binary response</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Clinical Trial Design and Data Analysis Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), graphics, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, survival</td>
</tr>
<tr>
<td>Author:</td>
<td>Venkatraman E. Seshan [aut, cre],
  Karissa Whiting [aut]</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities to make your clinical collaborations easier if not
          fun. It contains functions for designing studies such as Simon
          2-stage and group sequential designs and for data analysis such
          as Jonckheere-Terpstra test and estimating survival quantiles.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Venkatraman E. Seshan &lt;seshanv@mskcc.org&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 19:15:13 UTC; seshanv</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 19:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aucVardiTest'>Two-Sample Tests for Growth Curves under Dependent Right Censoring</h2><span id='topic+aucVardiTest'></span>

<h3>Description</h3>

<p>Permutation test for comparing growth curves across tow groups under
dependent right censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aucVardiTest(meas, grp, tim=NULL, cgrps=NULL, nperm=5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aucVardiTest_+3A_meas">meas</code></td>
<td>
<p>Matrix of measurements where the rows are the subjects and
columns the timepoints. At least one value should not be missing in
each row. For example they can be tumor sizes measured over time.</p>
</td></tr> 
<tr><td><code id="aucVardiTest_+3A_grp">grp</code></td>
<td>
<p>Group indicator for each subject. There must be at least
two different groups. This can represent each subject's treatment.</p>
</td></tr>
<tr><td><code id="aucVardiTest_+3A_tim">tim</code></td>
<td>
<p>Times at which the measurements in <code>meas</code> are taken.
If missing, the times are set to 1 through <code>ncol(meas)</code>.</p>
</td></tr> 
<tr><td><code id="aucVardiTest_+3A_cgrps">cgrps</code></td>
<td>
<p>The two groups that are being compared. If missing the
first two groups will be compared.</p>
</td></tr>
<tr><td><code id="aucVardiTest_+3A_nperm">nperm</code></td>
<td>
<p>Number of permutations for the reference distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is defined as the sum of pairwise differences in
the partial areas under the growth curve. For each pair of subjects
the partial area is computed until the smaller of the maximum followup
times. For each subject, linear interpolation is is used to fill-in
missing values prior to the maximum followup time. The reference
distribution of obtained by permuting the group labels.
</p>


<h3>Value</h3>

<p>returns a list with objects ostat, pstat and p.value which are the
observed test statistic for the two groups being compared, values of
the statistics when the group labels are permuted
</p>


<h3>References</h3>

<p>Vardi Y., Ying Z. and Zhang C.H. (2001). Two-Sample Tests for Growth
Curves under Dependent Right Censoring. <em>Biometrika</em> 88, 949-960. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  grp &lt;- sample(1:3, 100, replace=TRUE)
  grp0 &lt;- LETTERS[grp]
  maxfup &lt;- sample(5:20, 100, replace=TRUE)
  meas &lt;- matrix(NA, 100, 20)
  for(i in 1:100) {
    meas[i, 1:maxfup[i]] &lt;- cumsum((3+0.04*grp[i]) + rnorm(maxfup[i]))
  }
  aucVardiTest(meas, grp)
  aucVardiTest(meas, grp0, cgrps=c("C","B"))
</code></pre>

<hr>
<h2 id='calogrank'>Survival curves analysis of covariance</h2><span id='topic+calogrank'></span>

<h3>Description</h3>

<p>Logrank test to compare survival curves adjusting for covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calogrank(ftime, fstatus, grp, cvt, strat=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calogrank_+3A_ftime">ftime</code></td>
<td>
<p>failure times</p>
</td></tr>
<tr><td><code id="calogrank_+3A_fstatus">fstatus</code></td>
<td>
<p>status indicator</p>
</td></tr>
<tr><td><code id="calogrank_+3A_grp">grp</code></td>
<td>
<p>group indicator</p>
</td></tr>
<tr><td><code id="calogrank_+3A_cvt">cvt</code></td>
<td>
<p>continuous covariates used for adjusted analysis</p>
</td></tr>
<tr><td><code id="calogrank_+3A_strat">strat</code></td>
<td>
<p>stratification variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calogrank is the covariate adjusted version of k-sample survdiff.  The
function in its current form only does basic error checking.
</p>


<h3>References</h3>

<p>Heller G. and Venkatraman E.S. (2004) A nonparametric test to compare
survival distributions with covariate adjustment. <em>JRSS-B</em> 66,
719-733.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   library(survival)
  data(pbc)
  pbc1 &lt;- pbc
  pbc1$trt[pbc1$trt == -9] &lt;- NA
  pbc1$copper[pbc1$copper == -9] &lt;- NA
  # only death (2) is considered; transplant(1) is censored
  calogrank(pbc1$time, pbc1$status==2, pbc1$trt, pbc1[,c("copper")])
  calogrank(pbc1$time, pbc1$status==2, pbc1$trt,
                                  pbc1[,c("protime", "copper")])
## End(Not run)
</code></pre>

<hr>
<h2 id='clinfun-internal'>Internal clinfun functions</h2><span id='topic+compareROC.paired'></span><span id='topic+compareROC.unpaired'></span><span id='topic+exactNull'></span><span id='topic+getBoundary'></span><span id='topic+gsd.bdryconstant'></span><span id='topic+gsd.drift.efficacy'></span><span id='topic+gsd.drift.both'></span><span id='topic+gsd.drift'></span><span id='topic+mrcobj'></span><span id='topic+smmrcobj'></span><span id='topic+rocauc'></span><span id='topic+smrocauc'></span>

<h3>Description</h3>

<p>Internal functions used by the functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareROC.paired(x,y,d,nperm=2500)
compareROC.unpaired(x, dx, y, dy, nperm=2500, mp=NULL)
exactNull(gsize, kw)
getBoundary(pLo, pHi, n, cP0=0.1, cP1=0.9, ngrid=6, niter=10, delta=0,
    priorityNull=TRUE) 
gsd.bdryconstant(ifrac, eprob = 0.05, delta = 0.5,
    alternative = c("two.sided", "one.sided"), tol = 0.00001, ...)
gsd.drift.efficacy(ifrac, delta.eb, sig.level=0.05, pow = 0.8,
    alternative = c("two.sided", "one.sided"), tol = 0.00001, ...)
gsd.drift.both(ifrac, delta.eb, delta.fb, sig.level = 0.05, pow=0.8,
    alternative = c("two.sided", "one.sided"), tol = 0.00001, ...)
gsd.drift(ifrac, sig.level = 0.05, pow = 0.8, delta.eb = 0.5, delta.fb = NULL,
    alternative = c("two.sided", "one.sided"), tol = 0.00001, ...)
mrcobj(coefs, xmat, n, nn)
smmrcobj(coefs, xmat, n, nn, bw)
rocauc(marker, n, nn)
smrocauc(marker, n, nn)
</code></pre>


<h3>Details</h3>

<p>These functions are not to be called by the user.
</p>

<hr>
<h2 id='coxphCPE'>Concordance Probability Estimate for Cox model</h2><span id='topic+coxphCPE'></span>

<h3>Description</h3>

<p>Calculates the Concordance Probability Estimate for a Cox proportional 
hazards model. Both the Gonen and Heller (2005) version for continuous 
risk score and Heller and Mo (2016) for discrete risk score can be
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coxphCPE(phfit, out.ties=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxphCPE_+3A_phfit">phfit</code></td>
<td>
<p>output from a proportional hazards fit.</p>
</td></tr>
<tr><td><code id="coxphCPE_+3A_out.ties">out.ties</code></td>
<td>
<p>binary flag to decide if pairs with tied risk scores
should be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coxphCPE returns a vector with CPE, smooth.CPE and se.CPE which are the
estimate, the smoothed estimate and its standard error respectively.
</p>


<h3>References</h3>

<p>Gonen M and Heller G. (2005) Concordance probability and discriminatory
power in proportional hazards regression. <em>Biometrika</em> 92, 965-970.
</p>
<p>Heller G and Mo Q. (2016). Estimating the concordance probability in a
survival analysis with a discrete number of risk groups.
<em>Lifetime Data Analysis</em>, 22,263-79.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  library(survival)
  data(pbc)
  pbcfit &lt;- coxph(Surv(time, status==2) ~ trt + log(copper), pbc,
    subset=(trt&gt;0 &amp; copper&gt;0))
  coxphCPE(pbcfit)

## End(Not run)</code></pre>

<hr>
<h2 id='coxphERR'>Heller Explained Relative Risk</h2><span id='topic+coxphERR'></span>

<h3>Description</h3>

<p>Calculates the contribution of a subset of covariates to the explained
relative risk derived from the full Cox proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coxphERR(phfit, ngamma=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxphERR_+3A_phfit">phfit</code></td>
<td>
<p>The output from a proportional hazards fit.</p>
</td></tr>
<tr><td><code id="coxphERR_+3A_ngamma">ngamma</code></td>
<td>
<p>A vector of indices corresponding to covariates of
interest. If missing (default), the explained relative risk is
computed for the full model.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The object phfit should be the result of a call to coxph with the
option x=TRUE.
</p>


<h3>Value</h3>

<p>The function coxphERR returns the vector (ERR, se.ERR).
The first component ERR represents the contribution of a subset of
covariates to the explained relative risk estimate of the full
model. If a set of covariates is not provided, then it computes the
estimate of the full model. The second component se.ERR is the
standard error of the estimate.
</p>


<h3>References</h3>

<p>Heller G. (2012) A measure of explained risk in the proportional hazards
model. <em>Biostatistics</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 library(survival)
 ovarianfit &lt;- coxph(Surv(futime, fustat) ~ age + resid.ds + rx +
                                           ecog.ps, data=ovarian,x=T) 
 # Compute the explained relative risk (ERR) and
 # its standard error (se.ERR) for the full model.
 coxphERR(ovarianfit)       
 # Compute the contribution of age and ECOG performance status to
 # the explained relative risk. Age and ECOG performance status are 
 # the first and fourth covariates in the model.
 coxphERR(ovarianfit, c(1,4))

## End(Not run)</code></pre>

<hr>
<h2 id='coxphQuantile'>Survival time quantile as a function of covariate</h2><span id='topic+coxphQuantile'></span>

<h3>Description</h3>

<p>Draws a quantile curve of survival distribution as a function of covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coxphQuantile(phfit, xrange, p=0.5, whichx=1, otherx=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxphQuantile_+3A_phfit">phfit</code></td>
<td>
<p>output from a proportional hazards fit.</p>
</td></tr>
<tr><td><code id="coxphQuantile_+3A_xrange">xrange</code></td>
<td>
<p>the range of covariate values for which the quantiles of
survival times are computed.</p>
</td></tr>
<tr><td><code id="coxphQuantile_+3A_p">p</code></td>
<td>
<p>the probability level for the quantile (default is median).</p>
</td></tr>
<tr><td><code id="coxphQuantile_+3A_whichx">whichx</code></td>
<td>
<p>if there are more than one covariates in the Cox model,
the one chosen for the quantile plot.</p>
</td></tr>
<tr><td><code id="coxphQuantile_+3A_otherx">otherx</code></td>
<td>
<p>the values for other covariates in the Cox model.  If
missing uses their average values.</p>
</td></tr>
<tr><td><code id="coxphQuantile_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to the lines command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to draw quantile curves.  It requires a plot of
the data (time &amp; covariate of interest) to be present.  See example.
</p>
<p>It invisibly returns the observed failure times and the covariate
values at which the estimated survival probability is (exactly) p.
</p>


<h3>References</h3>

<p>Heller G. and Simonoff J.S. (1992) Prediction in censored survival data:
A comparison of the proportional hazards and linear regression models.
<em>Biometrics</em> 48, 101-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   library(survival)
data(pbc)
pbcfit &lt;- coxph(Surv(time, status==2) ~ trt + log(copper), pbc,
                      subset=(trt&gt;0 &amp; copper&gt;0)) 
plot(log(pbc$copper[pbc$trt&gt;0 &amp; pbc$copper&gt;0]), pbc$time[pbc$trt&gt;0 &amp;
  pbc$copper&gt;0], pch=c("o","x")[1+pbc$status[pbc$trt&gt;0 &amp; pbc$copper&gt;0]], 
  xlab="log Copper", ylab="Survival time")
coxphQuantile(pbcfit, c(2.5,6), whichx=2, otherx=1)
coxphQuantile(pbcfit, c(2.5,6), p=0.75, whichx=2, otherx=2, col=2)
## End(Not run)
</code></pre>

<hr>
<h2 id='deltaAUC'>Comparing the AUC from ROC curves from nested binary regression</h2><span id='topic+deltaAUC'></span><span id='topic+ipmn'></span>

<h3>Description</h3>

<p>Conducts the test 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  deltaAUC(y, x, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaAUC_+3A_y">y</code></td>
<td>
<p>binary response variable</p>
</td></tr>
<tr><td><code id="deltaAUC_+3A_x">x</code></td>
<td>
<p>matrix of set of covariates that is the basis of the existing
(reduced) model</p>
</td></tr>
<tr><td><code id="deltaAUC_+3A_z">z</code></td>
<td>
<p>matrix of set of covariates that are added to to get the new
(full) model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are fit using maximum rank correlation (MRC) method which
is an alternate approach to logistic regression. In MRC the area under
the ROC curve (AUC) is maximized as opposed to the likelihood in
logistic regression. Due to invariance of AUC to location and scale 
shifts one of the parameters (anchor variable) is set to 1.
</p>
<p>The first variable (column) in x is used as the anchor variable.
</p>
<p>The IPMN data set used as an example in the paper below is included.
The columns are high risk lesion (V1), recent weight loss (V2), main
duct involvement (V4), presence of a solid component in imaging (V3),
and lesion size (V5).
</p>


<h3>Value</h3>

<p>It returns a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>par.full</code></td>
<td>
<p>the MRC estimate of parameters for the full model</p>
</td></tr>
<tr><td><code>par.red</code></td>
<td>
<p>the MRC estimate of parameters for the reduced model</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>matrix od results which gives the full reduced model
AUCs along with the test statistic and p-value</p>
</td></tr>
</table>


<h3>References</h3>

<p>Heller G., Seshan V.E., Moskowitz C.S. and Gonen M. (2016) Inference
for the difference in the area under the ROC curve derived from nested
binary regression models. <em>Biostatistics</em> 18, 260-274.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ipmn)
  deltaAUC(ipmn$V1, cbind(ipmn$V4, ipmn$V3, ipmn$V5), ipmn$V2)
</code></pre>

<hr>
<h2 id='fedesign'>Trial Designs Based On Fisher's Exact Test</h2><span id='topic+fedesign'></span><span id='topic+fe.ssize'></span><span id='topic+CPS.ssize'></span><span id='topic+fe.mdor'></span><span id='topic+mdrr'></span><span id='topic+fe.power'></span><span id='topic+or2pcase'></span>

<h3>Description</h3>

<p>Calculates sample size, effect size and power based on
Fisher's exact test</p>


<h3>Usage</h3>

<pre><code class='language-R'>fe.ssize(p1, p2, alpha=0.05, power=0.8, r=1, npm=5, mmax=1000)
CPS.ssize(p1, p2, alpha=0.05, power=0.8, r=1)
fe.mdor(ncase, ncontrol, pcontrol, alpha=0.05, power=0.8)
mdrr(n, cprob, presp, alpha=0.05, power=0.8, niter=15)
fe.power(d, n1, n2, p1, alpha = 0.05)
or2pcase(pcontrol, OR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fedesign_+3A_p1">p1</code></td>
<td>
<p>response rate of standard treatment</p>
</td></tr>
<tr><td><code id="fedesign_+3A_p2">p2</code></td>
<td>
<p>response rate of experimental treatment</p>
</td></tr>
<tr><td><code id="fedesign_+3A_d">d</code></td>
<td>
<p>difference = p2-p1</p>
</td></tr>
<tr><td><code id="fedesign_+3A_pcontrol">pcontrol</code></td>
<td>
<p>control group probability</p>
</td></tr>
<tr><td><code id="fedesign_+3A_n1">n1</code></td>
<td>
<p>sample size for the standard treatment group</p>
</td></tr>
<tr><td><code id="fedesign_+3A_n2">n2</code></td>
<td>
<p>sample size for the standard treatment group</p>
</td></tr>
<tr><td><code id="fedesign_+3A_ncontrol">ncontrol</code></td>
<td>
<p>control group sample size</p>
</td></tr>
<tr><td><code id="fedesign_+3A_ncase">ncase</code></td>
<td>
<p>case group sample size</p>
</td></tr>
<tr><td><code id="fedesign_+3A_alpha">alpha</code></td>
<td>
<p>size of the test (default 5%)</p>
</td></tr>
<tr><td><code id="fedesign_+3A_power">power</code></td>
<td>
<p>power of the test (default 80%)</p>
</td></tr>
<tr><td><code id="fedesign_+3A_r">r</code></td>
<td>
<p>treatments are randomized in 1:r ratio (default r=1)</p>
</td></tr>
<tr><td><code id="fedesign_+3A_npm">npm</code></td>
<td>
<p>the sample size program searches for sample sizes in a
range (+/- npm) to get the exact power</p>
</td></tr>
<tr><td><code id="fedesign_+3A_mmax">mmax</code></td>
<td>
<p>the maximum group size for which exact power is
calculated</p>
</td></tr>
<tr><td><code id="fedesign_+3A_n">n</code></td>
<td>
<p>total number of subjects</p>
</td></tr>
<tr><td><code id="fedesign_+3A_cprob">cprob</code></td>
<td>
<p>proportion of patients who are marger positive</p>
</td></tr>
<tr><td><code id="fedesign_+3A_presp">presp</code></td>
<td>
<p>probability of response in all subjects</p>
</td></tr>
<tr><td><code id="fedesign_+3A_niter">niter</code></td>
<td>
<p>number of iterations in binary search</p>
</td></tr>
<tr><td><code id="fedesign_+3A_or">OR</code></td>
<td>
<p>odds-ratio</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CPS.ssize returns Casagrande, Pike, Smith sample size which is a very
close to the exact.  Use this for small differences p2-p1 (hence large
sample sizes) to get the result instantaneously.
</p>
<p>Since Fisher's exact test orders the tables by their probability the
test is naturally two-sided.
</p>
<p>fe.ssize return a 2x3 matrix with CPS and Fisher's exact sample sizes
with power.
</p>
<p>fe.mdor return a 3x2 matrix with Schlesselman, CPS and Fisher's exact
minimum detectable odds ratios and the corresponding power.
</p>
<p>fe.power returns a Kx2 matrix with probabilities (p2) and exact power.
</p>
<p>mdrr computes the minimum detectable P(resp|marker+) and P(resp|marker-)
configurations when total sample size (n), P(response) (presp) and
proportion of subjects who are marker positive (cprob) are specified.
</p>
<p>or2pcase give the probability of disease among the cases for a given
probability of disease in controls (pcontrol) and odds-ratio (OR).
</p>


<h3>References</h3>

<p>Casagrande, JT., Pike, MC. and Smith PG. (1978). An improved
approximate formula for calculating sample sizes for comparing two
binomial distributions. <em>Biometrics</em> 34, 483-486.
</p>
<p>Fleiss, J. (1981) Statistical Methods for Rates and Proportions.
</p>
<p>Schlesselman, J. (1987) Re: Smallest Detectable Relative Risk With
Multiple Controls Per Case.  <em>Am. J. Epi.</em>
</p>

<hr>
<h2 id='gsdesign'>Group Sequential Designs</h2><span id='topic+gsdesign'></span><span id='topic+gsdesign.binomial'></span><span id='topic+gsdesign.normal'></span><span id='topic+gsdesign.survival'></span>

<h3>Description</h3>

<p>Functions to calculate sample size for group sequential designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsdesign.binomial(ifrac, pC, pE, r = 1, sig.level = 0.05, power = 0.8,
  delta.eb=0.5, delta.fb = NULL, alternative = c("two.sided",
  "one.sided"), pooled.variance = FALSE, CPS = TRUE, tol=0.00001, ...) 
gsdesign.normal(ifrac, delta, sd = 1, r = 1, sig.level = 0.05,
  power = 0.8, delta.eb = 0.5, delta.fb = NULL, alternative = 
  c("two.sided", "one.sided"), tol=0.00001, ...)
gsdesign.survival(ifrac, haz.ratio, r = 1, sig.level = 0.05, 
  power = 0.8, delta.eb = 0.5, delta.fb = NULL, alternative = 
  c("two.sided", "one.sided"), tol=0.00001, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsdesign_+3A_ifrac">ifrac</code></td>
<td>
<p>information fraction or the ratio of current sample size
or number of events to the total sample size or number of events.
This should be an increasing vector of numbers from 0 to 1 with the
last one being 1.  If just 1 is given a fixed sample design is derived.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_pc">pC</code></td>
<td>
<p>prob of success of the standard therapy (for binomial data)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_pe">pE</code></td>
<td>
<p>prob of success of the experimental therapy (for binomial data)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_delta">delta</code></td>
<td>
<p>true difference in means (for normal data)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_sd">sd</code></td>
<td>
<p>standard deviation (for normal data)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_haz.ratio">haz.ratio</code></td>
<td>
<p>hazard ratio (for survival comparison)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_r">r</code></td>
<td>
<p>treatment allocation of r (default=1) experimental per 1 control.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (type I error probability)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_power">power</code></td>
<td>
<p>power of test (1 minus type II error probability)</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_delta.eb">delta.eb</code></td>
<td>
<p>power for efficacy boundary in the Pocock (=0) to
O'Brien-Fleming (=0.5) family (default is 0.5) </p>
</td></tr>
<tr><td><code id="gsdesign_+3A_delta.fb">delta.fb</code></td>
<td>
<p>power for futility boundary in the Pocock (=0) to
O'Brien-Fleming (=0.5) family (default is NULL i.e. no futility
boundary is requested.) </p>
</td></tr>
<tr><td><code id="gsdesign_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_pooled.variance">pooled.variance</code></td>
<td>
<p>whether the test statistic is standardized by
pooled (2*pbar*(1-pbar)) or unpooled variance (pC*(1-pC) + pE*(1-pE)).
Default is unpooled variance.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_cps">CPS</code></td>
<td>
<p>whether continuity correction is used for sample size
calculation as in Casagrande, Pike &amp; Smith. Default is to use it.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_tol">tol</code></td>
<td>
<p>tolerance level for multivariate normal probability
computation.</p>
</td></tr>
<tr><td><code id="gsdesign_+3A_...">...</code></td>
<td>
<p>additional options passed on the pmvnorm function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The futility boundary is not returned when delta.fb is not specified
i.e. stopping for futility is not requested.  The futility boundary is
non-binding.  That is the significance level is not adjusted to account
for early stopping for futility.  This makes the test a bit conservative 
in that the true size is less than the nominal level.
</p>
<p>If the alternative is two-sided by default the futility boundary will
also be two-sided i.e. continuation region is wedge shaped. However,
if the goal is to show the superiority of the experimental treatment
then futility boundary should be one sided. This can be achieved by
deriving the boundaries for one-sided alternative and significance
level set at half of the value used for two sided alternative. See the
examples section for a representative design for which the trial
cannot be stopped at the first look for futility.
</p>
<p>The Casagrande-Pike-Smith type continuity correction is obtained using
the formula </p>
<p style="text-align: center;"><code class="reqn">n*[1 + \sqrt{1+4/(|pC-pE|*n)}]^2</code>
</p>
<p> where n is
the uncorrected sample size.
</p>


<h3>Value</h3>

<p>a list with ifrac, sig.level, power, alternative, delta.eb, delta.fb and:
</p>
<table role = "presentation">
<tr><td><code>efbdry</code></td>
<td>
<p>the critical value to use at the different looks. For
two-sided alternative the absolute test statistic should exceed this.</p>
</td></tr>
<tr><td><code>futbdry</code></td>
<td>
<p>the critical value to use at the different looks. For
two-sided alternative the absolute test statistic should be below this.</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p>the sample size per arm for binomial/normal data.</p>
</td></tr>
<tr><td><code>num.events</code></td>
<td>
<p>the total number of failures which should be
converted to number of subjects using censoring proportion.</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  gsdesign.normal(1:4/4, 0.25, sig.level=0.05, alt="t", delta.fb=0.5)
  gsdesign.normal(1:4/4, 0.25, sig.level=0.025, alt="o", delta.fb=0.5)
</code></pre>

<hr>
<h2 id='jonckheere.test'>Exact/permutation version of Jonckheere-Terpstra test</h2><span id='topic+jonckheere.test'></span>

<h3>Description</h3>

<p>Jonckheere-Terpstra test to test for ordered differences among classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jonckheere.test(x, g, alternative = c("two.sided", "increasing",
                 "decreasing"), nperm=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jonckheere.test_+3A_x">x</code>, <code id="jonckheere.test_+3A_g">g</code></td>
<td>
<p>data and group vector</p>
</td></tr>
<tr><td><code id="jonckheere.test_+3A_alternative">alternative</code></td>
<td>
<p>means are monotonic (two.sided), increasing, or
decreasing</p>
</td></tr>
<tr><td><code id="jonckheere.test_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the reference distribution.
The default is null in which case the permutation p-value is not
computed. Recommend that the user set nperm to be 1000 or higher if
permutation p-value is desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>jonckheere.test is the exact (permutation) version of the
Jonckheere-Terpstra test.  It uses the statistic
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k&lt;l} \sum_{ij} I(X_{ik} &lt; X_{jl}) + 0.5 I(X_{ik} =
    X_{jl}),</code>
</p>
<p> where <code class="reqn">i, j</code> are observations in groups <code class="reqn">k</code> and
<code class="reqn">l</code> respectively.  The asymptotic version is equivalent to
cor.test(x, g, method=&quot;k&quot;). The exact calculation requires that there
be no ties and that the sample size is less than 100. When data are
tied and sample size is at most 100 permutation p-value is returned.
</p>


<h3>References</h3>

<p>Jonckheere, A. R. (1954). A distribution-free k-sample test again
ordered alternatives. <em>Biometrika</em> 41:133-145.
</p>
<p>Terpstra, T. J. (1952). The asymptotic normality and consistency of
Kendall's test against trend, when ties are present in one ranking.
<em>Indagationes Mathematicae</em> 14:327-333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1234)
  g &lt;- rep(1:5, rep(10,5))
  x &lt;- rnorm(50)
  jonckheere.test(x+0.3*g, g)
  x[1:2] &lt;- mean(x[1:2]) # tied data
  jonckheere.test(x+0.3*g, g)
  jonckheere.test(x+0.3*g, g, nperm=5000)
</code></pre>

<hr>
<h2 id='ktau'>Kendall's tau-b estimate</h2><span id='topic+ktau'></span>

<h3>Description</h3>

<p>Calculates the Kendall's tau-b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ktau(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ktau_+3A_x">x</code></td>
<td>
<p>first variable</p>
</td></tr>
<tr><td><code id="ktau_+3A_y">y</code></td>
<td>
<p>second variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ktau computes the same quantity as cor(x, y, method=&quot;kendall&quot;).
It uses a faster algorithm than pairwise comparisons used by cor.
</p>


<h3>Value</h3>

<p>ktau returns Kendall's tau-b.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1234)
  x &lt;- rnorm(10000); y &lt;- x+rnorm(10000)
  cor(x, y, method="k")
  clinfun:::ktau(x,y)  
</code></pre>

<hr>
<h2 id='oc.twostage.bdry'>Two-stage boundary operating characteristics</h2><span id='topic+oc.twostage.bdry'></span>

<h3>Description</h3>

<p>Calculates the operating characteristics of a two-stage boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oc.twostage.bdry(pu, pa, r1, n1, r, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oc.twostage.bdry_+3A_pu">pu</code></td>
<td>
<p>unacceptable response rate</p>
</td></tr>
<tr><td><code id="oc.twostage.bdry_+3A_pa">pa</code></td>
<td>
<p>response rate that is desirable</p>
</td></tr>
<tr><td><code id="oc.twostage.bdry_+3A_r1">r1</code></td>
<td>
<p>first stage threshold to declare treatment undesirable</p>
</td></tr>
<tr><td><code id="oc.twostage.bdry_+3A_n1">n1</code></td>
<td>
<p>first stage sample size</p>
</td></tr>
<tr><td><code id="oc.twostage.bdry_+3A_r">r</code></td>
<td>
<p>overall threshold to declare treatment undesirable</p>
</td></tr>
<tr><td><code id="oc.twostage.bdry_+3A_n">n</code></td>
<td>
<p>total sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>oc.twostage.bdry returns the type I and II error rates as well as the
probability of early temination and expected sample size under pu for
a specific boundary.
</p>

<hr>
<h2 id='permlogrank'>Permutation version of survdiff</h2><span id='topic+permlogrank'></span>

<h3>Description</h3>

<p>Small sample survdiff using permutation reference distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  permlogrank(formula, data, subset, na.action, rho=0, nperm=5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permlogrank_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the reference distribution</p>
</td></tr>
<tr><td><code id="permlogrank_+3A_formula">formula</code>, <code id="permlogrank_+3A_data">data</code>, <code id="permlogrank_+3A_subset">subset</code>, <code id="permlogrank_+3A_na.action">na.action</code>, <code id="permlogrank_+3A_rho">rho</code></td>
<td>
<p>see survdiff for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>permlogrank is the permutation version of k-sample survdiff. see
survdiff in survival package for details.
</p>


<h3>References</h3>

<p>Heller G, Venkatraman ES. (1996). Resampling procedures to compare two
survival distributions in the presence of right censored data.
<em>Biometrics</em> 52:1204-1213.
</p>

<hr>
<h2 id='ph2simon'>Simon's 2-stage Phase II design</h2><span id='topic+ph2simon'></span><span id='topic+print.ph2simon'></span><span id='topic+plot.ph2simon'></span>

<h3>Description</h3>

<p>Calculates Optimal and Minimax 2-stage Phase II designs given by
Richard Simon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph2simon(pu, pa, ep1, ep2, nmax=100)
## S3 method for class 'ph2simon'
print(x, ...)
## S3 method for class 'ph2simon'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ph2simon_+3A_pu">pu</code></td>
<td>
<p>unacceptable response rate; baseline response rate that needs to
be exceeded for treatment to be deemed promising</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_pa">pa</code></td>
<td>
<p>response rate that is desirable; should be larger than pu</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_ep1">ep1</code></td>
<td>
<p>threshold for the probability of declaring drug desirable
under pu (target type 1 error rate); between 0 and 1</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_ep2">ep2</code></td>
<td>
<p>threshold for the probability of rejecting the drug under
pa (target type 2 error rate); between 0 and 1</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_nmax">nmax</code></td>
<td>
<p>maximum total sample size (default 100; can be at most 1000)</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_x">x</code></td>
<td>
<p>object returned by ph2simon</p>
</td></tr>
<tr><td><code id="ph2simon_+3A_...">...</code></td>
<td>
<p>arguments to be passed onto plot and print commands called
within</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ph2simon returns a list with pu, pa, alpha, beta and nmax as above
and: </p>
<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>matrix of best 2 stage designs for each value of total
sample size n.  The 6 columns in the matrix are:
</p>

<table>
<tr>
 <td style="text-align: right;">
      r1 </td><td style="text-align: left;"> number of responses needed to exceeded in first stage </td>
</tr>
<tr>
 <td style="text-align: right;">
      n1 </td><td style="text-align: left;"> number of subjects treated in first stage </td>
</tr>
<tr>
 <td style="text-align: right;">
      r </td><td style="text-align: left;"> number of responses needed to exceeded at the end of trial </td>
</tr>
<tr>
 <td style="text-align: right;"> 
      n </td><td style="text-align: left;"> total number of subjects to be treated in the trial </td>
</tr>
<tr>
 <td style="text-align: right;">
      EN(pu) </td><td style="text-align: left;"> expected number pf patients in the trial under pu </td>
</tr>
<tr>
 <td style="text-align: right;">
      PET(pu) </td><td style="text-align: left;"> probability of stopping after the first stage under pu 
    </td>
</tr>

</table>
</td></tr>
</table>
<p>Trial is stopped early if &lt;= r1 responses are seen in the first stage
and treatment is considered desirable only when &gt;r responses seen.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(ph2simon)</code>: formats and returns the minimax,
optimal and any admissible designs.
</p>
</li>
<li> <p><code>plot(ph2simon)</code>: plots the expected sample size against
the maximum sample size as in Jung et al., 2001
</p>
</li></ul>



<h3>References</h3>

<p>Simon R. (1989).  Optimal Two-Stage Designs for Phase II Clinical
Trials. <em>Controlled Clinical Trials</em> 10, 1-10.
</p>
<p>Jung SH, Carey M and Kim KM. (2001). Graphical Search for Two-Stage
Designs for Phase II Clinical Trials. <em>Controlled Clinical
Trials</em>  22, 367-372.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twostage.inference">twostage.inference</a></code>, <code><a href="#topic+oc.twostage.bdry">oc.twostage.bdry</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ph2simon(0.2, 0.4, 0.1, 0.1)
  ph2simon(0.2, 0.35, 0.05, 0.05)
  ph2simon(0.2, 0.35, 0.05, 0.05, nmax=150)
</code></pre>

<hr>
<h2 id='ph2single'>Exact single stage Phase II design</h2><span id='topic+ph2single'></span>

<h3>Description</h3>

<p>Calculates the exact one stage Phase II design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph2single(pu,pa,ep1,ep2,nsoln=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ph2single_+3A_pu">pu</code></td>
<td>
<p>unacceptable response rate</p>
</td></tr>
<tr><td><code id="ph2single_+3A_pa">pa</code></td>
<td>
<p>response rate that is desirable</p>
</td></tr>
<tr><td><code id="ph2single_+3A_ep1">ep1</code></td>
<td>
<p>threshold for the probability of declaring drug desirable
under p0</p>
</td></tr>
<tr><td><code id="ph2single_+3A_ep2">ep2</code></td>
<td>
<p>threshold for the probability of rejecting the drug under
p1</p>
</td></tr>
<tr><td><code id="ph2single_+3A_nsoln">nsoln</code></td>
<td>
<p>number of designs with given alpha and beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ph2single returns a data frame with variables: n, r, and the Type I
and Type II errors. Treatment desirable if &gt;r respenses seen.
</p>

<hr>
<h2 id='power.ladesign'>Power of k-sample rank test under Lehmann alternative</h2><span id='topic+power.ladesign'></span><span id='topic+print.ladesign'></span>

<h3>Description</h3>

<p>Functions to calculate the power of rank tests for animal studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  power.ladesign(gsize, odds.ratio, sig.level = 0.05, statistic =
     c("Kruskal-Wallis", "Jonckheere-Terpstra"), alternative =
     c("two.sided", "one.sided"), nrep=1e+6) 
  ## S3 method for class 'ladesign'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.ladesign_+3A_gsize">gsize</code></td>
<td>
<p>sample size of the k (= length of vector) groups.</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_odds.ratio">odds.ratio</code></td>
<td>
<p>odds ratio parameters for the k-1 groups.  The first
group is considered the control.</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_sig.level">sig.level</code></td>
<td>
<p>the significance level of the test (default = 0.05)</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_statistic">statistic</code></td>
<td>
<p>the test statistic for the k-group comparison. Is one
of Kruskal-Wallis (default) or Jonckeere-Terpstra.</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Valid only for the
Jonckheere-Terpstra test.</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_nrep">nrep</code></td>
<td>
<p>number of reps (default 1 million) for Monte Carlo.</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_x">x</code></td>
<td>
<p>object of class ladesign returned by power.ladesign</p>
</td></tr>
<tr><td><code id="power.ladesign_+3A_...">...</code></td>
<td>
<p>arguments to be passed on left for S3 method consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the power for Jonckheere-Terpstra test is calculated for any
set of odds ratio, the test is meant for monotone alternative.  Thus
it is preferable to specify odds ratios that are monotonically
increasing with all values larger than 1 or decreasing with all values
smaller than 1.
</p>


<h3>Value</h3>

<p>returns a list with objects group.size, odds.ratio, statistic,
sig.level and power.   The &quot;print&quot; method formats the output.
</p>


<h3>References</h3>

<p>Heller G. (2006).  Power calculations for preclinical studies using a
K-sample rank test and the Lehmann alternative hypothesis.
<em>Statistics in Medicine</em> 25, 2543-2553. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  power.ladesign(c(9,7), 4, statistic="K")
  power.ladesign(c(9,7,9), c(2,4), statistic="J")
  power.ladesign(c(9,7,9), c(2,4), statistic="J", alt="o")
</code></pre>

<hr>
<h2 id='pselect'>Probability of selection under pick the winner rule</h2><span id='topic+pselect'></span>

<h3>Description</h3>

<p>Calculates the probability of selecting the treatment with the higher
response rate under the pick the winner rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pselect(n, p, min.diff=NULL, min.resp=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pselect_+3A_n">n</code></td>
<td>
<p>sample size for each treatment arm.  This is either a single
integer or a vector of two integers for the special case of
comparing two treatments with unequal sample sizes</p>
</td></tr>  
<tr><td><code id="pselect_+3A_p">p</code></td>
<td>
<p>vector of response rates for the treatments.</p>
</td></tr>
<tr><td><code id="pselect_+3A_min.diff">min.diff</code></td>
<td>
<p>this is the number of responses or the rate by which
the best treatment should be superior to the others to be chosen.
This must be a positive integer or a rate between 0 and 1.  If
missing it defaults to 1 for the equal sample size case but quits
with a warning for the unequal sample size case.</p>
</td></tr>
<tr><td><code id="pselect_+3A_min.resp">min.resp</code></td>
<td>
<p>the minimum number of responses in each treatment arm
for it to be considered further. If missing defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns a list with:
</p>
<table role = "presentation">
<tr><td><code>prob.none.worthy</code></td>
<td>
<p>is the probability that no treatment has the
minimum number of responses specified in min.resp. this element is
present only if min.resp is greater than 0 for at least one arm.</p>
</td></tr>
<tr><td><code>prob.inconclusive</code></td>
<td>
<p>this is the probability that the best treatment
has the requisite min.resp responses but exceeds the second best by
less than min.diff responses (rate) provided the second best also
has at least min.resp responses.</p>
</td></tr>
<tr><td><code>prob.selection</code></td>
<td>
<p>this is a matrix which for each treatment gives
the response probability and the probability of selecting it
i.e. the number of responses in the chosen arm is at least min.resp
and either none of the remaining arms exceed the min.resp threshold
or the chosen (best) arm is better than the second best by at least
min.diff responses (rate).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Simon R, Wittes RE, Ellenberg SS. (1985). Randomized phase II clinical
trials. <em>Cancer Treat Rep</em> 69, 1375-1381.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # selection when no diffrence i.e. type I error
  pselect(18, c(0.2, 0.2, 0.2))
  # selection probability
  pselect(18, c(0.2, 0.2, 0.4))
  pselect(26, c(0.2, 0.2, 0.4), min.diff=2, min.resp=3)
  # unequal sample size case
  pselect(c(27,54), c(0.5, 0.65), min.diff=0.05)
  # unequal sample size case
  pselect(c(27,54), c(0.5, 0.65), min.diff=0.05, min.resp=c(14,27))
</code></pre>

<hr>
<h2 id='roc.area.test'>Nonparametric area under the ROC curve</h2><span id='topic+roc.area.test'></span><span id='topic+print.roc.area.test'></span>

<h3>Description</h3>

<p>Computes the nonparametric area under the ROC curve and its variance
based on U-statistic theory (DDCP). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  roc.area.test(markers, status)
  ## S3 method for class 'roc.area.test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc.area.test_+3A_markers">markers</code></td>
<td>
<p>The marker values for each subject.  If there are more
than one markers then this should be a matrix.</p>
</td></tr>
<tr><td><code id="roc.area.test_+3A_status">status</code></td>
<td>
<p>binary disease status indicator</p>
</td></tr>
<tr><td><code id="roc.area.test_+3A_x">x</code></td>
<td>
<p>object of class roc.area.test output from this function.</p>
</td></tr>
<tr><td><code id="roc.area.test_+3A_...">...</code></td>
<td>
<p>optional arguments to the print function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates the area and its variance.  For more than one marker it
calculates the statistic to test for the equality of all AUCs.  This
statistic has a standard normal reference distribution for two
variables and chi-square with number of variables minus 1.
</p>


<h3>Value</h3>

<p>a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>area</code></td>
<td>
<p>estimated area.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>estimated variance (matrix).</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>test statistic for equality of AUCs. Is not returned when
only one diagnostic marker is present.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test of equality (2-sided).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the chi-square.</p>
</td></tr>
</table>
<p>The &quot;print&quot; method formats and returns the output.
</p>


<h3>References</h3>

<p>DeLong, E. R., D. M. DeLong, and D. L. Clarke-Pearson. 1988. Comparing
the areas under two or more correlated receiver operating characteristic
curves:  A nonparametric approach. <em>Biometrics</em> 44:837-845.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rep(0:1, 50)
x &lt;- rnorm(100) + g
y &lt;- rnorm(100) + g
z &lt;- rnorm(100) + g
roc.area.test(cbind(x,y), g)
roc.area.test(cbind(x,y,z), g)
y1 &lt;- y + 0.75*g
roc.area.test(cbind(x,y1), g)
</code></pre>

<hr>
<h2 id='roc.curve'>Empirical ROC curve</h2><span id='topic+roc.curve'></span><span id='topic+print.roc.curve'></span><span id='topic+plot.roc.curve'></span><span id='topic+lines.roc.curve'></span>

<h3>Description</h3>

<p>Computes the empricial ROC curve for a diagnostic tool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  roc.curve(marker, status, method=c("empirical"))
  ## S3 method for class 'roc.curve'
print(x, ...)
  ## S3 method for class 'roc.curve'
plot(x, PRC=FALSE, ...)
  ## S3 method for class 'roc.curve'
lines(x, PRC=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc.curve_+3A_marker">marker</code></td>
<td>
<p>the marker values for each subject.</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_status">status</code></td>
<td>
<p>binary disease status indicator</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_method">method</code></td>
<td>
<p>the method for estimating the ROC curve.  Currently only
the empirical curve is implemented.</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_x">x</code></td>
<td>
<p>object of class roc.area.test output from this function.</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_prc">PRC</code></td>
<td>
<p>flag to tell whether ROC or Precision-Recall curve plotted.</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_...">...</code></td>
<td>
<p>optional arguments to the print, plot and lines functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is based on assuming that larger values of the marker
is indicative of the disease.  So for a given threshold x0, TPR is
P(marker &gt;= x0|status =1) and FPR is P(marker &gt;= x0|status =0).  This
function computes the empirical estimates of TPR and FPR.
</p>


<h3>Value</h3>

<p>a list with the following elements
</p>
<table role = "presentation">
<tr><td><code>marker</code></td>
<td>
<p>the diagnostic marker being studied.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>binary disease </p>
</td></tr>
<tr><td><code>tpr</code></td>
<td>
<p>true positive rates for all thresholds.</p>
</td></tr>
<tr><td><code>fpr</code></td>
<td>
<p>true positive rates for all thresholds.</p>
</td></tr>
<tr><td><code>ppv</code></td>
<td>
<p>positive predictive values for all thresholds.</p>
</td></tr>
<tr><td><code>npv</code></td>
<td>
<p>negative predictive values for all thresholds.</p>
</td></tr>
</table>
<p>The &quot;print&quot; method returns the nonparametric AUC and its s.e.
</p>
<p>The &quot;plot&quot; and &quot;lines&quot; methods can be used to draw a new plot and add
to an existing plot of ROC curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rep(0:1, 50)
x &lt;- rnorm(100) + g
y &lt;- rnorm(100) + 1.5*g
o &lt;- roc.curve(x, g)
plot(o)
lines(roc.curve(y, g), col=2)
</code></pre>

<hr>
<h2 id='roc.perm.test'>Permutation test to compare ROC curve</h2><span id='topic+roc.perm.test'></span><span id='topic+print.roc.perm.test'></span><span id='topic+plot.roc.perm.test'></span>

<h3>Description</h3>

<p>Computes the test statistic and permutation reference distribution for
comparing paired or unpaired ROC curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.perm.test(marker, status, marker2=NULL, group=NULL,
              nperm=2500, mp=NULL)
## S3 method for class 'roc.perm.test'
print(x, ...)
## S3 method for class 'roc.perm.test'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc.perm.test_+3A_marker">marker</code></td>
<td>
<p>marker values for each subject.</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_status">status</code></td>
<td>
<p>binary disease status indicator.</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_marker2">marker2</code></td>
<td>
<p>second diagnostic marker for the same subjects (paired).</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_group">group</code></td>
<td>
<p>indicator of which diagnostic test was used (unpaired).</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the reference distribution.</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_mp">mp</code></td>
<td>
<p>mixing proportion for the unpaired case when proportion of
diseased subjects can differ.</p>
</td></tr> 
<tr><td><code id="roc.perm.test_+3A_x">x</code></td>
<td>
<p>object of class roc.perm.test output from this function.</p>
</td></tr>
<tr><td><code id="roc.perm.test_+3A_...">...</code></td>
<td>
<p>optional arguments to print and plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the permutation method described in the
Venkatraman and Begg (1996) paper for the paired case and the
Venkatraman (2000) paper for the unpaired case.
</p>
<p>The function detects whether the data are paired or unpaired by
testing which of the options marker2 and group is specified.  If both
are missing it will stop with an error message.  At present exactly
one should be missing.
</p>


<h3>Value</h3>

<p>an object of class roc.perm.test with the following elements
</p>
<table role = "presentation">
<tr><td><code>ostat</code></td>
<td>
<p>test statistic from the observed data.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>test statistic from permuted data.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test of equality (2-sided).</p>
</td></tr>
</table>
<p>The &quot;print&quot; method formats and returns the statistic and p-value.
The &quot;plot&quot; method plots the density from the permutation reference
distribution and marks the location of the observed statistic.
</p>


<h3>References</h3>

<p>Venkatraman, E.S. and Begg, C.B. (1996). A distribution-free procedure
for comparing receiver operating characteristic curves from a paired
experiment. <em>Biometrika</em> 83, 835-848.
</p>
<p>Venkatraman, E.S. (2000) A permutation test to compare receiver
operating characteristic curves. <em>Biometrics</em> 56(4):1134-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- rep(0:1, 50)
x &lt;- rnorm(100) + 1.2*d
y &lt;- rnorm(100) + 1.2*d
oo &lt;- roc.perm.test(x, d, marker2=y)
plot(oo)
oo &lt;- roc.perm.test(c(x,y), c(d,d), group=rep(1:2,each=100))
plot(oo)
</code></pre>

<hr>
<h2 id='ROCanalysis'>
Functions to plot and compare ROC curves.
</h2><span id='topic+ROCanalysis'></span><span id='topic+rocanalysis'></span>

<h3>Description</h3>

<p>These functions can be used for nonparametric analysis of ROC curves.
</p>


<h3>Details</h3>

<p>The relevant functions are <code>roc.curve</code>, <code>roc.area.test</code> and
<code>roc.perm.test</code>.  See the individual functions for usage details.
</p>

<hr>
<h2 id='toxbdry'>Stopping rule for toxicity/futility monitoring</h2><span id='topic+toxbdry'></span><span id='topic+futilbdry'></span><span id='topic+bdrycross.prob'></span><span id='topic+print.toxbdry'></span><span id='topic+print.futilbdry'></span>

<h3>Description</h3>

<p>Computes a stopping rule and its operating characteristics for
toxicity monitoring based repeated significance testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toxbdry(pLo, pHi, n, cP0=0.1, cP1=0.9, ngrid=6, niter=10, delta=0,
          priority=c("null","alt"))
futilbdry(rLo, rHi, n, size=0.1, power=0.9, ngrid=3, niter=10, delta=0.5)
bdrycross.prob(n, r, ptox)
## S3 method for class 'toxbdry'
print(x, ...)
## S3 method for class 'futilbdry'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toxbdry_+3A_plo">pLo</code></td>
<td>
<p>the toxicity rate that is acceptable.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_rlo">rLo</code></td>
<td>
<p>baseline (null) response rate.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_phi">pHi</code></td>
<td>
<p>the toxicity rate that is too high and hence unacceptable.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_rhi">rHi</code></td>
<td>
<p>desirable response rate. Stop when it is too unlikely.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_n">n</code></td>
<td>
<p>vector of times (sample size) when toxicty/response is monitored.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_r">r</code></td>
<td>
<p>vector of maximum acceptable toxicities (non-responders for
futility) corresponding to n.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_ptox">ptox</code></td>
<td>
<p>the toxicity rates for which the operating characteristics
are calculated. For futility this is the non-response rate.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_cp0">cP0</code></td>
<td>
<p>boundary crossing probability under pLo i.e. type I error
or the probability of declaring a treatment with toxicity rate pLo
unacceptable.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_cp1">cP1</code></td>
<td>
<p>boundary crossing probability under pHi i.e. power or the
probability of declaring a treatment with toxicity rate pHi
unacceptable.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_size">size</code></td>
<td>
<p>probability of calling drug effective if response rate is rLo.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_power">power</code></td>
<td>
<p>probability of calling drug effective if response rate is rHi.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of toxicity rates from pLo to pHi for which
the operating characteristics are computed.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_niter">niter</code></td>
<td>
<p>the number of iterations run to obtain the boundary.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_delta">delta</code></td>
<td>
<p>power determining the shape of the boundary. Should be
between 0 (default) and 0.5.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_priority">priority</code></td>
<td>
<p>the error threshold to prioritize when the max sample 
size is too small to have both error thresholds satisfied. Default
is the null i.e. error under pLo.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_x">x</code></td>
<td>
<p>object returned by the function toxbdry.</p>
</td></tr>
<tr><td><code id="toxbdry_+3A_...">...</code></td>
<td>
<p>additional arguments to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape parameter delta is used to determine the stopping boundary
with 0 corresponding to the Pocock boundary where the same
significance level is used for all looks and 0.5 corresponding to the
O'Brien-Fleming boundary which has smaller probability of stopping at
early looks.
</p>
<p>Default value of delta for toxicity monitoring is 0; value between 0.1
and 0.2 is a reasonable choice to make it less likely to stop early.
Default values of delta for futility stopping is 0.5.
</p>
<p>For toxicity monitoring two sets of probabilities - pstop and pcross -
are given which correspond to probability of stopping early and
probability of declaring the treatment too toxic with the full
complement of study subjects accrued and treated.
</p>
<p>For futility monitoring instead two sets of probabilities - pstop and
peffective - are given corresponding to the probability of stopping
early for futility and probability of finishing the trial and
declaring it a success. Note that peffective is the complement of
pcross in toxicity monitoring.
</p>
<p>The futility boundary can have a -1 in earlier looks which means that
even zero responses is not sufficient for stopping at that look.
</p>
<p>The exact calculations in this function are done along the lines of
the method in Chapter 12 of Jennison and Turnbull (2000). Ivanova,
Qaqish and Schell (2005) have an illustrative paper.
</p>


<h3>Value</h3>

<p>the function returns a list with:
</p>
<table role = "presentation">
<tr><td><code>looks</code></td>
<td>
<p>when toxicty is monitored - same as input n.</p>
</td></tr>
<tr><td><code>lo.bdry</code></td>
<td>
<p>lower boundary is a vector of maximum acceptable number
of toxicities corresponding the number of subjects in n.  The
boundary crossing probability for this is slightly above cP0.</p>
</td></tr>
<tr><td><code>hi.bdry</code></td>
<td>
<p>upper boundary is a vector of maximum acceptable number
of toxicities corresponding the number of subjects in n.  The
boundary crossing probability for this is slightly below cP0.</p>
</td></tr>
<tr><td><code>bdry.oc</code></td>
<td>
<p>the operating characteristics i.e the toxicity
rate, the probability of crossing, stopping (i.e. cross before the
last observation) and the expected sample size for both the low (lo)
and high (hi) boundaries.</p>
</td></tr>
<tr><td><code>bdry.alpha</code></td>
<td>
<p>the alpha levels for testing at each look for the
two boundaries.</p>
</td></tr>
</table>
<p>stopping for toxicity is done when the number of toxicities exceeds
the boundary i.e. the boundary gives the maximum acceptable number.
</p>


<h3>References</h3>

<p>Jennison C and Turnbull BW. (2000).  Group Sequential Methods with
Applications to Clinical Trials.  <em>Chapman and Hall/CRC</em>
</p>
<p>Ivanova A, Qaqish BF and Schell MJ. (2005). Continuous Toxicity
Monitoring in Phase II Trials in Oncology. <em>Biometrics</em> 61, 540-545.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  toxbdry(0.2, 0.35, c(20,40,60,75))
  toxbdry(0.2, 0.3, c(20,40,60,75), cP0=0.15, cP1=0.8)
  # continuous monitoring
  toxbdry(0.1, 0.3, 2:30)
  # prioritize cP1 error threshold
  toxbdry(0.1, 0.3, 2:25, priority="alt")
</code></pre>

<hr>
<h2 id='twostage.admissible'>Admissible design options between Minimax and Optimal</h2><span id='topic+twostage.admissible'></span>

<h3>Description</h3>

<p>Lists the admissible design options between
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twostage.admissible(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twostage.admissible_+3A_x">x</code></td>
<td>
<p>output from <code>ph2simon</code> call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>twostage.admissible returns design options that are admissible (Jung
et al, 2004). The output is a matrix with 8 columns: r1, n1, r, n,
EN(p0), PET(p0), qLo, qHi. The columns qLo and qHi give the range of
probability values for which the particular design is admissible. 
</p>


<h3>References</h3>

<p>Jung SH, Lee T, Kim K, and George, SL. (2004). Admissible two-stage
designs for phase II cancer clinical trials. <em>Statistics in 
medicine</em> 23(4), 561-569.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oo = ph2simon(0.5, 0.7, 0.05, 0.1)
  twostage.admissible(oo)
</code></pre>

<hr>
<h2 id='twostage.inference'>Inference following a two-stage design for binary response</h2><span id='topic+twostage.inference'></span>

<h3>Description</h3>

<p>Calculates the p-value, UMVUE and CI for the data from a study using a
two stage design for response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twostage.inference(x, r1, n1, n, pu, alpha=0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twostage.inference_+3A_x">x</code></td>
<td>
<p>number of responses observed at the end of the study</p>
</td></tr>
<tr><td><code id="twostage.inference_+3A_r1">r1</code></td>
<td>
<p>first stage threshold to declare treatment undesirable</p>
</td></tr>
<tr><td><code id="twostage.inference_+3A_n1">n1</code></td>
<td>
<p>first stage sample size</p>
</td></tr>
<tr><td><code id="twostage.inference_+3A_n">n</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="twostage.inference_+3A_pu">pu</code></td>
<td>
<p>unacceptable response rate (null hypothesis)</p>
</td></tr>
<tr><td><code id="twostage.inference_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level. For consistency with the design use
the same value from the design. (default is 0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>twostage.inference returns the UMVUE (Jung &amp; Kim, 2004), p-value and
CI (Koyama &amp; Chen, 2008). The CI has confidence level 1-2*alpha and
the one-sided (1-alpha) interval consistent with the design is
obtained by changing the upper confidence limit (UCL) to 1.
</p>


<h3>References</h3>

<p>Jung SH and Kim KM. (2004). On the estimation of the binomial
probability in multistage clinical trials. <em>Statistics in
Medicine</em>  23, 881-896.
</p>
<p>Koyama T and Chen H. (2008). Proper inference from Simon's two-stage
designs. <em>Statistics in Medicine</em> 27, 3145-3154.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
