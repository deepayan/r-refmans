<!DOCTYPE html><html><head><title>Help for package BANOVA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BANOVA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BAnova'><p>Function to print the table of effect sizes</p></a></li>
<li><a href='#BANOVA-package'>
<p>BANOVA: Hierarchical Bayesian ANOVA Models</p></a></li>
<li><a href='#BANOVA.Bernoulli'><p>Estimation of BANOVA with a Bernoulli dependent variable</p></a></li>
<li><a href='#BANOVA.Binomial'><p>Estimation of BANOVA with a Binomial dependent variable</p></a></li>
<li><a href='#BANOVA.build'><p>Build BANOVA models</p></a></li>
<li><a href='#BANOVA.floodlight'><p>Floodlight analysis based on BANOVA models</p></a></li>
<li><a href='#BANOVA.mediation'><p>Mediation analysis based on BANOVA models</p></a></li>
<li><a href='#BANOVA.model'><p>Extract BANOVA models</p></a></li>
<li><a href='#BANOVA.multi.mediation'><p>Mediation analysis with multiple possibly correlated mediators</p></a></li>
<li><a href='#BANOVA.Multinomial'><p>Estimation of BANOVA with a Multinomial dependent variable</p></a></li>
<li><a href='#BANOVA.Normal'><p>Estimation of BANOVA with a normally distributed dependent variable</p></a></li>
<li><a href='#BANOVA.ordMultinomial'><p>Estimation of BANOVA with a ordered Multinomial response variable</p></a></li>
<li><a href='#BANOVA.Poisson'><p>Estimation of BANOVA with Poisson dependent variables</p></a></li>
<li><a href='#BANOVA.run'><p>Estimation of BANOVA models</p></a></li>
<li><a href='#BANOVA.simple'><p>Simple effects calculation</p></a></li>
<li><a href='#BANOVA.T'><p>Estimation of BANOVA with T-distributin of the dependent variable</p></a></li>
<li><a href='#bernlogtime'><p>Data for analysis of effects of typicality, blur and color on gist perception of ads</p></a></li>
<li><a href='#bpndata'><p>Eye-movement data for analysis of print ad designs</p></a></li>
<li><a href='#choicedata'><p>Household Panel Data on Margarine Purchases</p></a></li>
<li><a href='#colorad'><p>Data for gist perception of advertising, study 1</p></a></li>
<li><a href='#colorad2'><p>Data for gist perception of advertising, study 2</p></a></li>
<li><a href='#condstudy'><p>Data for the study of how brand attitudes were influenced by showing brands together with pleasant pictures</p></a></li>
<li><a href='#condstudy_sub'><p>A subset of data for the study of how brand attitudes were influenced by showing brands together with pleasant pictures</p></a></li>
<li><a href='#conv.diag'><p>Function to display the convergence diagnostics</p></a></li>
<li><a href='#goalstudy'><p>Data for the study of the impact of the variety among means on motivation to pursue a goal</p></a></li>
<li><a href='#ipadstudy'><p>Data for the study of relation between Conspicuous, Brand Usage, Self-Brand Connection and attitudes toward the brand</p></a></li>
<li><a href='#pairs.BANOVA'><p>Create a matrix of output plots from a <code>BANOVA</code> object</p></a></li>
<li><a href='#table.predictions'><p>Function to print the table of means</p></a></li>
<li><a href='#table.pvalues'><p>Function to print the table of p-values</p></a></li>
<li><a href='#trace.plot'><p>Function to plot the trace of parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Bayesian ANOVA Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Chen Dong, Michel Wedel, Anna Kopyakova</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS-4.3.0, C++11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chen Dong &lt;chendong.math.umd@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rjags(&ge; 3-13), runjags (&ge; 1.2.1-0), coda (&ge; 0.16-1),
rstan(&ge; 2.15.1), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>It covers several Bayesian Analysis of Variance (BANOVA) models used in analysis of experimental designs in which both within- and between- subjects factors are manipulated. They can be applied to data that are common in the behavioral and social sciences. The package includes: Hierarchical Bayes ANOVA models with normal response, t response, Binomial (Bernoulli) response, Poisson response, ordered multinomial response and multinomial response variables. All models accommodate unobserved heterogeneity by including a normal distribution of the parameters across individuals. Outputs of the package include tables of sums of squares, effect sizes and p-values, and tables of predictions, which are easily interpretable for behavioral and social researchers. The floodlight analysis and mediation analysis based on these models are also provided. BANOVA uses 'Stan' and 'JAGS' as the computational platform. References: Dong and Wedel (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v081.i09">doi:10.18637/jss.v081.i09</a>&gt;; Wedel and Dong (2020) &lt;<a href="https://doi.org/10.1002%2Fjcpy.1111">doi:10.1002/jcpy.1111</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-21 04:06:12 UTC; chendong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-21 07:30:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='BAnova'>Function to print the table of effect sizes</h2><span id='topic+BAnova'></span>

<h3>Description</h3>

<p>The analysis of variance is performed at level 1 (for the single level model) and level 2 equation of the Bayesian ANOVA see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>. This makes it possible to capture the effects of level-1 or level-2 variables on the heterogeneity distribution of subjects, and compute sums of squares and effect sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAnova(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BAnova_+3A_x">x</code></td>
<td>
<p>the object from BANOVA.*</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measures of effect size in regression are measures of the degree of association between an effect (e.g., a main effect, an interaction, a linear contrast) and the dependent variable. They can be considered as the correlation between a categorical factor(effect) and the dependent variable. They are usually interpreted as the proportion of variance in the dependent variable that is attributable to each effect. In the package, partial Eta squared is calculated and displayed. It is defined as follows, <br />
</p>
<p><code class="reqn">\eta^2= \frac{(SS_{effect})}{(SS_{effect} + SS_{error})}</code> <br />
</p>
<p>Where:
SS_effect= the sums of squares for the effect of interest <br />
SS_error= the sums of squares for the error in the regression.
</p>
<p>This equation is evaluated at each draw of the parameters, which allows for the calculation of not only the posterior mean, but also the credible interval of the effect size. 
</p>


<h3>References</h3>

 
<p>Fox, J. (2008)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Second Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2011) 
<em>An R Companion to Applied Regression</em>, Second Edition, Sage.
</p>
<p>Lakens, D. (2013) 
<em>Calculating and Reporting Effect Sizes to Facilitate Cumulative Science: A Practical Primer for T-tests and ANOVAs</em>, Frontiers in Psychology, Vol. 4, pp.863.
</p>
<p>Gelman, A. and  Pardoe, I. (2006)
<em>Bayesian Measures of Explained Variance and Pooling in Multilevel (Hierarchical) Models</em>, TECHNOMETRICS, Vol. 48, NO. 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

library(rstan)
# or use BANOVA.run based on 'Stan'
res2 &lt;- BANOVA.run(bid~progress*prodvar,  model_name = 'Normal', 
data = goalstudy, id = 'id', iter = 1000, chains = 2)
BAnova(res2)

</code></pre>

<hr>
<h2 id='BANOVA-package'>
BANOVA: Hierarchical Bayesian ANOVA Models
</h2><span id='topic+BANOVA-package'></span><span id='topic+BANOVA'></span>

<h3>Description</h3>

<p>This package includes several hierarchical Bayes Analysis of Variance models. These models are suited for the analysis of experimental designs in which both within- and between- subjects factors are manipulated, and account for a wide variety of distributions of the dependent variable. Floodlight analysis and mediation analysis basaed on these models are also provided. The package uses 'Stan' and 'JAGS' as the computational platform.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> BANOVA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-06-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Model: <br />
<code class="reqn">E(y_i) = g^{-1}(\eta_i)</code> <br />
where <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of data response <code class="reqn">i</code>. Missing values (NAs) of <code class="reqn">y_i</code> are allowed. The within-subjects factors and their interactions are indexed by <code class="reqn">p (p = 1,2,.,P)</code>. Each index <code class="reqn">p</code> represents a batch of <code class="reqn">J_p</code> coefficients: <code class="reqn">\beta_{j,s}^p, j = 1,.,J_p</code>;<code class="reqn">s = 1,.,S</code> indexes subjects. Note that if the subject-level covariate is continuous, <code class="reqn">J_p=1</code>, so that ANCOVA models are also accommodated (relaxing their &quot;constant slope&quot; assumption).  <br />
</p>
<p>The population-level model allows for heterogeneity among subjects, because the subject-level coefficients <code class="reqn">\beta_{j,s}^p</code> are assumed to follow a multivariate normal distribution.The between-subjects factors and their interactions are indexed by <code class="reqn">q,(q = 1,2,.,Q)</code>, <code class="reqn">q = 0</code> denotes the constant term. The population-level ANOVA can be written as: <br />
<code class="reqn">\beta_{j,s}^p = \sum_{q = 0}^Q \theta_{j,k_s^q}^{pq} + \delta_{j,s}^p</code> <br />
</p>
<p>The population-level ANCOVA model can be expressed as a linear model with a design matrix <code class="reqn">Z</code> that contains all between-subjects factors and their interactions and a constant term: <br />
<code class="reqn">\beta_{j,s}^p = \sum_{k = 1}^Q Z_{s,k}\theta_{j,k}^{p} + \delta_{j,s}^p</code> <br />
where <code class="reqn">Z_{s,k} </code>is an element of <code class="reqn">Z</code>, a <code class="reqn">S \times Q</code> matrix of covariates. <code class="reqn">\theta_{j,k}^p</code> is a hyperparameter which captures the effects of between-subjects factor <code class="reqn">q</code> on the parameter <code class="reqn">\beta_{j,s}^p</code> of within-subjects factor p. The error <code class="reqn">\delta_{j,s}^p</code> is assumed to be normal: <code class="reqn">\delta_{j,s}^p</code> ~ <code class="reqn">N(0,\sigma_p^{-2} )</code>. Proper, but diffuse priors are assumed: <code class="reqn">\theta_{j,k}^p</code> ~ <code class="reqn">N(0,\gamma)</code>, and <code class="reqn">\sigma_p^{-2}</code> ~ <code class="reqn">Gamma(a,b)</code>, where <code class="reqn">\gamma,a,b</code> are hyper-parameters. The default setting is <code class="reqn">\gamma = 10^{-4}, a = 1, b = 1</code>. <br />
</p>
<p>Note that missing values of independent variables are currently not allowed in the package.
</p>


<h3>Author(s)</h3>

<p>Chen Dong;
Michel Wedel
</p>
<p>Maintainer: Chen Dong &lt;cdong@math.umd.edu&gt;
</p>


<h3>References</h3>

<p>Dong, C. and Wedel, M. (2017) 
<em>BANOVA: An R Package for Hierarchical Bayesian ANOVA</em>, Journal of Statistical Software, Vol. 81, No.9, pp. 1-46. 
</p>
<p>McCullagh, P., Nelder, JA. (1989)
<em>Generalized linear models</em>, New York, NY: Chapman and Hall.
</p>
<p>Gelman, A. (2005)
<em>Analysis of variance-why it is more important than ever</em>, Ann. Statist., Vol. 33, No. 1, pp. 1-53.
</p>
<p>Rossi, P., Allenby,G., McCulloch, R. (2005)
<em>Bayesian Statistics and Marketing</em>, John Wiley and Sons.
</p>
<p>Gill, J. (2007) 
<em>Bayesian Methods for the Social and Behavioral Sciences</em>, Chapman and Hall, Second Edition.
</p>
<p>Gelman, A., Carlin, J., Stern, H. and Dunson, D. (2013)
<em>Bayesian Data Analysis</em>, London: Chapman and Hall.
</p>
<p>Wedel, M. and Dong, C. (2016) <em>BANOVA: Bayesian Analysis of Variance for Consumer Research</em>. Submitted.
</p>

<hr>
<h2 id='BANOVA.Bernoulli'>Estimation of BANOVA with a Bernoulli dependent variable</h2><span id='topic+BANOVA.Bernoulli'></span><span id='topic+predict.BANOVA.Bernoulli'></span><span id='topic+print.BANOVA.Bernoulli'></span><span id='topic+summary.BANOVA.Bernoulli'></span>

<h3>Description</h3>

<p><code>BANOVA.Bernoulli</code> implements a Bayesian ANOVA for binary dependent variable, using a logit link and a normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.Bernoulli(l1_formula = "NA", l2_formula = "NA", data,
  id, l2_hyper = c(1, 1, 0.0001), burnin = 5000, sample = 2000, thin = 10, 
  adapt = 0, conv_speedup = F, jags = runjags.getOption('jagspath'))

## S3 method for class 'BANOVA.Bernoulli'
summary(object, ...)
## S3 method for class 'BANOVA.Bernoulli'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.Bernoulli'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.Bernoulli_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_data">data</code></td>
<td>
<p>a data.frame in long format including all features in level 1 and level 2(covariates and categorical factors) and responses</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.Bern</code> (returned by <code>BANOVA.Bern</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data.frame. It must have the same format with the original data (the same number of features and the same data classes)</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.Bern</code> (returned by <code>BANOVA.Bern</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Bernoulli_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i</code> ~ <code class="reqn">Binomial(1,p_i)</code>, <code class="reqn">p_i = logit^{-1}(\eta_i)</code> <br />
where <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of data record <code class="reqn">i</code>. see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>
</p>


<h3>Value</h3>

<p><code>BANOVA.Bernoulli</code> returns an object of class <code>"BANOVA.Bernoulli"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bernlogtime)
# model with the dependent variable : response
res &lt;- BANOVA.Bernoulli(response~typical, ~blur + color, bernlogtime,
bernlogtime$subject, burnin = 5000, sample = 2000, thin = 10)
summary(res)


</code></pre>

<hr>
<h2 id='BANOVA.Binomial'>Estimation of BANOVA with a Binomial dependent variable</h2><span id='topic+BANOVA.Binomial'></span><span id='topic+predict.BANOVA.Binomial'></span><span id='topic+print.BANOVA.Binomial'></span><span id='topic+summary.BANOVA.Binomial'></span>

<h3>Description</h3>

<p><code>BANOVA.Binomial</code> implements a Hierarchical Bayesian ANOVA for a binomial response variable using a logit link and a normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.Binomial(l1_formula = "NA", l2_formula = "NA", data,
  id, num_trials, l2_hyper = c(1, 1, 0.0001), burnin = 5000, sample = 2000, 
  thin = 10, adapt = 0, conv_speedup = F, jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.Binomial'
summary(object, ...)
## S3 method for class 'BANOVA.Binomial'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.Binomial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.Binomial_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_data">data</code></td>
<td>
<p>a data.frame in long format including all features in level 1 and level 2(covariates and categorical factors) and responses</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_num_trials">num_trials</code></td>
<td>
<p>the number of trials of each
observation(=1, if it is bernoulli), the type is forced to be 'integer'</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.Bin</code> (returned by <code>BANOVA.Bin</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format with the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.Bin</code> (returned by <code>BANOVA.Bin</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Binomial_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i</code> ~ <code class="reqn">Binomial(ntrials,p_i)</code>, <code class="reqn">p_i = logit^{-1}(\eta_i)</code> <br />
where ntrials is the binomial total for each record i, <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>. see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>
</p>


<h3>Value</h3>

<p><code>BANOVA.Binomial</code> returns an object of class <code>"BANOVA.Bin"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(colorad)

# mean center Blur for effect coding
colorad$blur &lt;- colorad$blur - mean(colorad$blur)
res &lt;- BANOVA.Binomial(y~typic, ~color*blur, colorad, colorad$id, as.integer(16), 
burnin = 5000, sample = 2000, thin = 10)
summary(res)
# or use BANOVA.run
require(rstan)
res0 &lt;- BANOVA.run(y~typic, ~color*blurfac, data = colorad, model_name = 'Binomial',
id = 'id', num_trials = as.integer(16), iter = 100, thin = 1, chains = 2)
summary(res0)
table.predictions(res0)
# only in-model variables(except numeric variables) will be used
predict(res0, c(1, 0, 8, 2, 1, 0.03400759))


</code></pre>

<hr>
<h2 id='BANOVA.build'>Build BANOVA models</h2><span id='topic+BANOVA.build'></span>

<h3>Description</h3>

<p><code>BANOVA.build</code> builds(compiles) BANOVA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.build(BANOVA_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.build_+3A_banova_model">BANOVA_model</code></td>
<td>
<p>an object of class <code>"BANOVA.model"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BANOVA.build</code> returns an object of class <code>"BANOVA.build"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>stanmodel</code></td>
<td>
<p>the compiled 'Stan' model</p>
</td></tr>
<tr><td><code>model_name</code></td>
<td>
<p>the model name</p>
</td></tr>
<tr><td><code>single_level</code></td>
<td>
<p>if the model is a single level model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- BANOVA.model('Poisson', single_level = FALSE) 
Poisson_model &lt;- BANOVA.build(model)
# visualize the model
cat(model$model_code)
# modify the model code and rebuild
# be careful to change any parameters
model$model_code &lt;-"
data {
  int&lt;lower=0&gt; N;
  int&lt;lower=0&gt; J;
  int&lt;lower=0&gt; M;
  int&lt;lower=0&gt; K;
  matrix[N, J] X;
  matrix[M, K] Z;
  int&lt;lower=0&gt; id[N];
  int y[N];
}

parameters {
  matrix[J, M] beta1;
  matrix[K, J] beta2; 
  vector&lt;lower=0&gt;[J] tau_beta1Sq;
} 

model {
  vector[N] y_hat;
  matrix[M, J] mu_beta1;
  vector[J] tau_beta1;
  tau_beta1 = sqrt(tau_beta1Sq);
  for (i in 1:N){
    y_hat[i] = X[i,]*beta1[,id[i]];
  }
  y ~ poisson_log(y_hat);
  mu_beta1 = Z*beta2;
  for (i in 1:J){
    beta1[i,] ~ normal(mu_beta1[,i], tau_beta1[i]);
  }
  tau_beta1Sq ~ inv_gamma(1, 1);
  for (i in 1:J){
    beta2[,i] ~ normal(0, 10);
  }
}
"
Poisson_model_new &lt;- BANOVA.build(model)


</code></pre>

<hr>
<h2 id='BANOVA.floodlight'>Floodlight analysis based on BANOVA models</h2><span id='topic+BANOVA.floodlight'></span><span id='topic+print.BANOVA.floodlight'></span>

<h3>Description</h3>

<p><code>BANOVA.floodlight</code> conducts floodlight analysis based on various BANOVA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.floodlight(sol, var_numeric, var_factor, flood_values = list())
## S3 method for class 'BANOVA.floodlight'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.floodlight_+3A_sol">sol</code></td>
<td>
<p>a BANOVA.* object</p>
</td></tr>
<tr><td><code id="BANOVA.floodlight_+3A_var_numeric">var_numeric</code></td>
<td>
<p>the numeric variable</p>
</td></tr>
<tr><td><code id="BANOVA.floodlight_+3A_var_factor">var_factor</code></td>
<td>
<p>the factor variable</p>
</td></tr>
<tr><td><code id="BANOVA.floodlight_+3A_flood_values">flood_values</code></td>
<td>
<p>a list of values of the other numeric variables which interact with var_factor and var_numeric, the floodlight analysis will be based on these values, default 0</p>
</td></tr>
<tr><td><code id="BANOVA.floodlight_+3A_x">x</code></td>
<td>
<p>a BANOVA.floodlight object</p>
</td></tr>
<tr><td><code id="BANOVA.floodlight_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A floodlight analysis (Spiller et al. 2013; Johnson and Neyman 1936) based on BANOVA models is conducted, which identifies regions of the numeric variable for which differences between the levels of the factor are significant. The endpoints of the 95% credible interval of the numeric variable provide the Johnson-Neyman points; for values outside of that interval there is 'strong' evidence that there is a difference between the levels of the factor.
</p>


<h3>Value</h3>

<p><code>BANOVA.floodlight</code> returns an object of class <code>"BANOVA.floodlight"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>sol</code></td>
<td>
<p>table of the floodlight analysis including the 95% credible interval</p>
</td></tr>
<tr><td><code>num_range</code></td>
<td>
<p>range of the numeric variable</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Spiller, S., Fitzsimons, G., Lynch Jr., J. and McClelland, G. (2013) <em>Spotlights, Floodlights, and the Magic Number Zero: Simple Effects Tests in Moderated Regression</em>. Journal of Marketing Research,  Vol. L, pp. 277-288.
</p>
<p>Wedel, M. and Dong, C. (2016) <em>BANOVA: Bayesian Analysis of Variance for Consumer Research</em>. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(condstudy_sub)

library(rstan)
# use BANOVA.run
model &lt;- BANOVA.model('Normal')
stanmodel &lt;- BANOVA.build(model)
res &lt;- BANOVA.run(att~cond+pict, ~type, fit = stanmodel, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)
BANOVA.floodlight(res, var_factor = 'type', var_numeric = 'pict')


</code></pre>

<hr>
<h2 id='BANOVA.mediation'>Mediation analysis based on BANOVA models</h2><span id='topic+BANOVA.mediation'></span>

<h3>Description</h3>

<p><code>BANOVA.mediation</code> conducts mediation and moderated mediation analysis based on various BANOVA models with a single mediator and a casual variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.mediation(sol_1, sol_2, xvar, mediator, individual = F,
return_posterior_samples = F,  multi_samples_beta1_raw_m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.mediation_+3A_sol_1">sol_1</code></td>
<td>
<p>an  object  of  class  <code>"BANOVA"</code>  returned  by  BANOVA.run  function with  a fitted model for an outcome variable regressed on a causal variable, a mediator, and, possibly, moderators and control variables. The outcome variable can follow Normal, T, Poisson, Bernoulli, Binomial, and ordered Multinomial distributions.</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_sol_2">sol_2</code></td>
<td>
<p>an  object  of  class  <code>"BANOVA"</code> returned  by  BANOVA.run  function with  a fitted model for a Normal outcome variable regressed on a causal variable, and, possibly, moderators and control variables.</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_xvar">xvar</code></td>
<td>
<p>a character string which specifies the name of the causal variable used in both models.</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_mediator">mediator</code></td>
<td>
<p>a character string which specifies the name of the mediator variable used in the model.</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_individual">individual</code></td>
<td>
<p>logical  indicator  of  whether to output effects for individual units in the analysis (TRUE or FALSE). This analysis requires a multilevel <code>sol_1</code>.</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_return_posterior_samples">return_posterior_samples</code></td>
<td>
<p>logical indicator of whether posterior samples of mediated effects should be returned (TRUE or FALSE).</p>
</td></tr>
<tr><td><code id="BANOVA.mediation_+3A_multi_samples_beta1_raw_m">multi_samples_beta1_raw_m</code></td>
<td>
<p>argument for an internal use in the package. Please do not change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts a correlational mediation and moderated mediation analysis (Baron and Kenny 1986; Zao, Lynch and Chen 2010; Zhang, Wedel and Pieters 2008) based on BANOVA models. Based on the samples from posterior distributions, the function calculates the direct effect and indirect effect for which posterior means and 95% credible intervals are reported. The effect size of the indirect effect is computed as a generalized partial eta-squared. For details about this metric, see the publication of Wedel and Dong (2019).
</p>
<p>When the algorithm is calculating the effects of a given causal variable it first identifies all moderators which are interacting with the investigated variable. Based on each interaction, moderated coefficients are computed and summarized in a table. If the causal variable is a part of an interaction term with three or more variables, separate results are computed for each of the moderators and all of their possible combinations. This results in multiple tables with the effects. If a continuous variable is involved in the interaction the effects are evaluated at its mean value, which is zero by default. This is equivalent to omitting the continuous variable from the interaction. 
</p>
<p>The function combines the effects of the mediator on the dependent variable with the effect of the causal variable on the mediator in a multiplicative manner to obtain the indirect effect of the treatment. If multiple tables with moderated effects of the mediator or the causal variable on mediator are obtained in the previous steps of the analysis, the indirect effects are computed for each combination of these table. 
</p>
<p>For models with a Normal outcome variable, it is possible to interpret the effects as causal by explicitly encoding the causal variable with dummy coding and including an interaction between the causal and mediating variables in the model. For further details, see the publication of MacKinnon et al. (2020).
</p>


<h3>Value</h3>

<p><code>BANOVA.mediation</code> returns an object of class <code>"BANOVA.mediation"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>dir_effects</code></td>
<td>
<p>tables of the direct effect</p>
</td></tr>
<tr><td><code>individual_direct</code></td>
<td>
<p>a table of the direct effect at the individual level if individual = T and the causal variable is a within-subject variable</p>
</td></tr>
<tr><td><code>m1_effects</code></td>
<td>
<p>tables of the effect of the mediator on the outcome</p>
</td></tr>
<tr><td><code>m2_effects</code></td>
<td>
<p>tables of the effect of the causal variable on the mediator</p>
</td></tr>
<tr><td><code>indir_effects</code></td>
<td>
<p>tables of the indirect effect</p>
</td></tr>
<tr><td><code>individual_indirect</code></td>
<td>
<p>the table of the indirect effect at the individual level if individual = T and the mediator is a within-subject variable</p>
</td></tr>
<tr><td><code>effect_size</code></td>
<td>
<p>a table with the effect size of the mediator</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>the name of the causal variable</p>
</td></tr>
<tr><td><code>mediator</code></td>
<td>
<p>the name of the mediating variable</p>
</td></tr>
<tr><td><code>individual</code></td>
<td>
<p>the value of the argument individual (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Baron, R.M., and Kenny, D.A. (1986) <em>Moderator Mediator Variables Distinction in Social Psychological Research: Conceptual, Strategic, and Statistical Considerations</em>, Journal of Personality and Social Psychology, Vol. 51, No. 6, pp. 1173-82.
</p>
<p>Zhang, J., Wedel, M. and Pieters, R.G.M.  (2009) <em>Sales Effects of Attention to Feature Advertisements: A Bayesian Mediation Analysis</em>, Journal of Marketing Research, Vol.46, No.5, pp. 669-681.
</p>
<p>Ying, Y. and MacKinnon, D.P. (2009) <em>Bayesian Mediation Analysis</em>, Psychological Methods, Vol. 14, No.4, pp. 301-322.
</p>
<p>Zhao, X., John G.L., and Chen, Q. (2010) <em>Reconsidering Baron and Kenny: Myths and Truths About Mediation Analysis</em>, Journal of Consumer Research, Vol.37, No.2, pp. 197-206.
</p>
<p>Wedel, M., and Dong, C. (2019) <em>BANOVA: Bayesian Analysis of Variance for Consumer Research</em>, Journal of Consumer Psychology, Vol. 30, No. 1, pp. 3-23.
</p>
<p>MacKinnon, D.P., Valente,  M.J., and Gonzalez, O. (2020) <em>The correspondence between causal and traditional mediation analysis: the link is the mediator by treatment interaction</em>, Prevention Science,  Vol. 21, No. 2, pp. 147-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(condstudy_sub)

# use BANOVA.run based on 'Stan'
model &lt;- BANOVA.model('Normal')
banova_model &lt;- BANOVA.build(model)
res_1 &lt;- BANOVA.run(att~cond+pict, ~type, fit = banova_model, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)
res_2 &lt;- BANOVA.run(pict~cond, ~type, fit = banova_model, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)
# (moderated) mediation
sol &lt;- BANOVA.mediation(res_1, res_2, xvar='cond', mediator='pict')
print(sol)
print(sol$dir_effects)

</code></pre>

<hr>
<h2 id='BANOVA.model'>Extract BANOVA models</h2><span id='topic+BANOVA.model'></span>

<h3>Description</h3>

<p><code>BANOVA.model</code> extracts BANOVA models from the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.model(model_name, single_level = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.model_+3A_model_name">model_name</code></td>
<td>
<p>a character string in c('Normal', 'T', 'Bernoulli', 'Binomial', 'Poisson', 'ordMultinomial', 'Multinomial', 'multiNormal', 'truncNormal')</p>
</td></tr>
<tr><td><code id="BANOVA.model_+3A_single_level">single_level</code></td>
<td>
<p>if the model is a single level model, default False</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loads a pre-specified 'Stan' model for the analysis in BANOVA.
</p>
<p><code>'Normal'</code> model: A model suitable for a continuous dependent variable, which follows a Normal distribution.
</p>
<p><code>'T'</code> model: A model suitable for a continuous dependent variable, which might be prone to 'outliers' or fatter tails than the Normal.
</p>
<p><code>'Bernoulli'</code> model: A model suitable for a binary dependent variable, which can take values 0 and 1.
</p>
<p><code>'Binomial'</code> model: A model suitable for a dependent variable, which represents a number of successes in a sequence of B independent Bernoulli experiments.
</p>
<p><code>'Poisson'</code> model: A model suitable for a dependent variable, which represents count data. A Poisson distributed dependent variable can take values 0, 1, 2 ....
</p>
<p><code>'ordMultinomial'</code> model: A model suitable for an ordered categorical (ordinal) dependent variable, which follows an ordered Multinomial distribution. This dependent variable can take values from 1 to K, where possible alternatives are ordered according to some principal.
</p>
<p><code>'Multinomial'</code> model: A model suitable for a categorical (nominal) dependent variable, which follows a Multinomial distribution. This dependent variable can take values from 1 to K, where possible alternatives are unordered.
</p>
<p><code>'multiNormal'</code> model: A model suitable for a Multivariate Normal dependent variable, which represents L possibly correlated Normal dependent variables with shared predictors. The analysis corresponds to the seemingly unrelated regressions (SUR) technique. 
</p>
<p><code>'truncNormal'</code> model: A model suitable a dependent variable, which values can only be observed if they lie within a certain range. The variable can be bounded from below, above, or from two sides.
</p>


<h3>Value</h3>

<p><code>BANOVA.model</code> returns an object of class <code>"BANOVA.model"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>model_code</code></td>
<td>
<p>the model code of the extracted model</p>
</td></tr>
<tr><td><code>model_name</code></td>
<td>
<p>the model name</p>
</td></tr>
<tr><td><code>single_level</code></td>
<td>
<p>if the model is a single level model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- BANOVA.model('Poisson', single_level = FALSE) 
cat(model$model_code)

</code></pre>

<hr>
<h2 id='BANOVA.multi.mediation'>Mediation analysis with multiple possibly correlated mediators</h2><span id='topic+BANOVA.multi.mediation'></span>

<h3>Description</h3>

<p><code>BANOVA.multi.mediation</code> is a function for analysis of multiple possibly correlated mediators.
These mediators are assumed to have no causal influence on each other. 
Both single-level and multi-level models can be analyzed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.multi.mediation(sol_1, sol_2, xvar, mediators, individual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.multi.mediation_+3A_sol_1">sol_1</code></td>
<td>
<p>an  object  of  class  &quot;BANOVA&quot;  returned  by  BANOVA.run  function with  a fitted 
model for an outcome variable regressed on a causal variable, a mediator, and, possibly, 
moderators and control variables. The outcome variable can follow Normal, T, Poisson, Bernoulli, 
Binomial, Truncated Normal and ordered Multinomial distributions.</p>
</td></tr>
<tr><td><code id="BANOVA.multi.mediation_+3A_sol_2">sol_2</code></td>
<td>
<p>an object of class &quot;BANOVA&quot; returned by BANOVA.run function, which contains an 
outcome of the analysis for multiple Multivariate Normal mediators regressed on a casual variable
and other possible moderators and control variables.</p>
</td></tr>
<tr><td><code id="BANOVA.multi.mediation_+3A_xvar">xvar</code></td>
<td>
<p>a character string that specifies the name of the causal variable used in both models.</p>
</td></tr>
<tr><td><code id="BANOVA.multi.mediation_+3A_mediators">mediators</code></td>
<td>
<p>a vector with character strings, which specifies the names of the mediator 
variables used in the models.</p>
</td></tr>
<tr><td><code id="BANOVA.multi.mediation_+3A_individual">individual</code></td>
<td>
<p>logical  indicator  of  whether to output effects for individual units in the 
analysis (TRUE or FALSE). This analysis requires a multilevel <code>sol_1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extends <code>BANOVA.mediation</code> to the case with multiple possibly 
correlated mediators. For details about mediation analysis performed in BANOVA see
the help page for the <a href="#topic+BANOVA.mediation">BANOVA.mediation</a>.
</p>
<p><code>BANOVA.multi.mediation</code> estimates and tests specific indirect effects of the causal 
variable conveyed through each mediator. Furthermore, the total indirect effect of the causal
variables are computed as a sum of the specific indirect effects.
</p>
<p>The function prints multiple tables with mediated effects. Tables with direct effects of the 
causal variable and mediators on the outcome variable, as well as direct effects of the causal
variable on the mediators include a posterior mean and 95% credible intervals of the effects. 
Next, the function displays on the console tables with specific indirect effects and effect sizes 
of the mediators, followed by the TIE of the causal variable. These tables include the mean, 
95% credible intervals, and two-sided Bayesian p-values.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"BANOVA.multi.mediation"</code>. The returned object is a list 
containing:
</p>
<table>
<tr><td><code>dir_effects</code></td>
<td>
<p>table or tables with the direct effect.</p>
</td></tr>
<tr><td><code>individual_direct</code></td>
<td>
<p>is returned if <code>individual</code> is set to <code>TRUE</code> and the 
causal variable is a within-subject variable. Contains a table or tables of the direct effect at 
the individual levels of the analysis</p>
</td></tr>
<tr><td><code>m1_effects</code></td>
<td>
<p>a list with tables of the effects of the mediator on the outcome</p>
</td></tr>
<tr><td><code>m2_effects</code></td>
<td>
<p>a list with tables of the effect of the causal variable on the mediator</p>
</td></tr>
<tr><td><code>indir_effects</code></td>
<td>
<p>tables of the indirect effect</p>
</td></tr>
<tr><td><code>individual_indirect</code></td>
<td>
<p>is returned if <code>individual</code> is set to <code>TRUE</code> and the
mediator is a within-subject variable. Contains the table or tables with the indirect effect</p>
</td></tr>
<tr><td><code>effect_sizes</code></td>
<td>
<p>a list with effect sizes on individual mediators</p>
</td></tr>
<tr><td><code>total_indir_effects</code></td>
<td>
<p>table or tables with the total indirect effect of the causal variable</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>the name of the causal variable</p>
</td></tr>
<tr><td><code>mediators</code></td>
<td>
<p>the names of the mediating variables</p>
</td></tr>
<tr><td><code>individual</code></td>
<td>
<p>the value of the argument individual (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anna Kopyakova
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the colorad data set
data(colorad)
# Add a second mediator to the data set
colorad$blur_squared &lt;- (colorad$blur)^2
# Prepare mediators to be analyzed in the Multivariate Normal model
mediators &lt;- cbind(colorad$blur, colorad$blur_squared)
colnames(mediators) &lt;- c("blur", "blur_squared")
colorad$mediators &lt;- mediators

# Build and analyze the model for the outcome variable
model &lt;- BANOVA.model('Binomial')
banova_binom_model &lt;- BANOVA.build(model)
res_1 &lt;- BANOVA.run(y ~ typic, ~ color + blur + blur_squared, fit = banova_binom_model,
                    data = colorad, id = 'id', num_trials = as.integer(16), 
                    iter = 2000, thin = 1, chains = 2)
# Build and analyze the model for the mediators
model &lt;- BANOVA.model('multiNormal')
banova_multi_norm_model &lt;- BANOVA.build(model)
res_2 &lt;- BANOVA.run(mediators ~ typic, ~ color, fit = banova_multi_norm_model,
                    data = colorad, id = 'id', iter = 2000, thin = 1, chains = 2)
                    
# Calculate (moderated) effects of "typic" mediated by "blur" and "blur_squared"
results &lt;- BANOVA.multi.mediation(res_1, res_2, xvar='typic', mediators=c("blur", "blur_squared"))

</code></pre>

<hr>
<h2 id='BANOVA.Multinomial'>Estimation of BANOVA with a Multinomial dependent variable</h2><span id='topic+BANOVA.Multinomial'></span><span id='topic+predict.BANOVA.Multinomial'></span><span id='topic+print.BANOVA.Multinomial'></span><span id='topic+summary.BANOVA.Multinomial'></span>

<h3>Description</h3>

<p><code>BANOVA.Multinomial</code> implements a Hierarchical Bayesian ANOVA for multinomial response variable using a logit link and a normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.Multinomial(l1_formula = "NA", l2_formula = "NA",
  dataX, dataZ, y, id, l2_hyper = c(1, 1, 0.0001), burnin = 5000, sample = 2000, 
  thin = 10, adapt = 0, conv_speedup = F, jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.Multinomial'
summary(object, ...)
## S3 method for class 'BANOVA.Multinomial'
predict(object, Xsamples = NULL, Zsamples = NULL,...)
## S3 method for class 'BANOVA.Multinomial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.Multinomial_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. '~X1+X2',
response variable must not be included</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_datax">dataX</code></td>
<td>
<p>a list of data frames(each corresponds to the choice set of each observation) that includes all covariates and factors</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_dataz">dataZ</code></td>
<td>
<p>a data frame(long format) that includes all level 2 covariates and factors</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_y">y</code></td>
<td>
<p>choice responses, 1,2,3...</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_id">id</code></td>
<td>
<p>subject id</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.Multinomial</code>(returned by <code>BANOVA.Multinomial</code>) </p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_xsamples">Xsamples</code></td>
<td>
<p>new data samples in level one, must be a
list( the same format with the traning data), numeric
variables must be mean centered.</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_zsamples">Zsamples</code></td>
<td>
<p>new data samples in level two( the same
format with the traning data), numeric variables must be
mean centered.</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.Multinomial</code> (returned by <code>BANOVA.Multinomial</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Multinomial_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">P(y_i = \ell) = \frac{exp(\eta_{i\ell})}{\sum_{\ell=1}^L exp(\eta_{i\ell})}</code> <br />
where <code class="reqn">\eta_{i\ell} = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^{k,p} \beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>, see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>. <code class="reqn">X_{i,j}^{k,p}</code> is the design matrix corresponding to each class <code class="reqn">\ell(\ell=1,.,L)</code> of <code class="reqn">y_i</code>. 
The first level of the response is the base level, thus the intercept corresponding to this level will not be included.
</p>


<h3>Value</h3>

<p><code>BANOVA.Multinomial</code> returns an object of class <code>"BANOVA.Multinomial"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>dataX</code></td>
<td>
<p>original dataX</p>
</td></tr>
<tr><td><code>dataZ</code></td>
<td>
<p>original dataZ</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>n_categories</code></td>
<td>
<p>the number of categories of the response</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# see 'choicedata'
data(choicedata)
# generate dataX(convert the within-subject variables to a list)
dataX &lt;- list()
for (i in 1:nrow(choicedata)){
  logP &lt;- as.numeric(log(choicedata[i,3:8]))
  # all numeric variables must be mean centered
  dataX[[i]] &lt;- as.data.frame(logP) - mean(logP)
}
dataZ &lt;- choicedata[,9:13]

res &lt;- BANOVA.Multinomial(~ logP, ~ college, dataX, dataZ, 
  choicedata$choice, choicedata$hhid, burnin = 100, sample = 100, thin = 10)
# or use BANOVA.run based on 'Stan'
require(rstan)
res &lt;- BANOVA.run(~ logP, ~ college, dataX = dataX, dataZ = dataZ, 
                    model_name = 'Multinomial', y_value = choicedata$choice, 
                    id = choicedata$hhid, iter = 100, thin = 1, chains = 2)

</code></pre>

<hr>
<h2 id='BANOVA.Normal'>Estimation of BANOVA with a normally distributed dependent variable</h2><span id='topic+BANOVA.Normal'></span><span id='topic+predict.BANOVA.Normal'></span><span id='topic+print.BANOVA.Normal'></span><span id='topic+summary.BANOVA.Normal'></span>

<h3>Description</h3>

<p><code>BANOVA.Normal</code> implements a Hierarchical Bayesian ANOVA for linear models with normal response and a normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.Normal(l1_formula = "NA", l2_formula = "NA", data,
  id, l1_hyper = c(1, 1), l2_hyper = c(1, 1, 0.0001), burnin = 5000, 
  sample = 2000, thin = 10, adapt = 0, conv_speedup = F, 
  jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.Normal'
summary(object, ...)
## S3 method for class 'BANOVA.Normal'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.Normal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.Normal_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included, if missing, the single level model will be generated</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_data">data</code></td>
<td>
<p>a data.frame in long format including all features in level 1 and level 2(covariates and categorical factors) and responses</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_l1_hyper">l1_hyper</code></td>
<td>
<p>level 1 hyperparameters, c(<code class="reqn">\alpha, \beta)</code>) for two-level models and c(<code class="reqn">\alpha, \beta, \sigma_p</code>) for single level models, default c(1,1)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.Normal</code> (returned by <code>BANOVA.Normal</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format with the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.Normal</code> (returned by <code>BANOVA.Normal</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Normal_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i</code> ~ <code class="reqn">Normal(\eta_i,\sigma^{-2})</code> <br />
where <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>, <code class="reqn">\sigma^{-2}</code> ~ Gamma(<code class="reqn">\alpha,\beta</code>). see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>
</p>


<h3>Value</h3>

<p><code>BANOVA.Normal</code> returns an object of class <code>"BANOVA.Normal"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use the ipadstudy data set
data(ipadstudy)
# mean center covariates
ipadstudy$age &lt;- ipadstudy$age - mean(ipadstudy$age) 
ipadstudy$owner &lt;- ipadstudy$owner - mean(ipadstudy$owner)
ipadstudy$gender &lt;- ipadstudy$gender - mean(ipadstudy$gender)

# or use BANOVA.run based on 'Stan'
require(rstan)
res &lt;- BANOVA.run(attitude~owner + age + gender + selfbrand*conspic, 
data = ipadstudy, model_name = 'Normal', id = 'id', 
iter = 100, thin = 1, chains = 2)

</code></pre>

<hr>
<h2 id='BANOVA.ordMultinomial'>Estimation of BANOVA with a ordered Multinomial response variable</h2><span id='topic+BANOVA.ordMultinomial'></span><span id='topic+predict.BANOVA.ordMultinomial'></span><span id='topic+print.BANOVA.ordMultinomial'></span><span id='topic+summary.BANOVA.ordMultinomial'></span>

<h3>Description</h3>

<p><code>BANOVA.ordMultinomial</code> implements a Hierarchical Bayesian ANOVA for ordered multinomial responses, with
a normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.ordMultinomial(l1_formula = "NA",
  l2_formula = "NA", data, id, l1_hyper = c(0.0001, 100), 
  l2_hyper = c(1, 1, 0.0001, 100), burnin = 5000, 
  sample = 2000, thin = 10, adapt = 0, conv_speedup = F, 
  jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.ordMultinomial'
summary(object, ...)
## S3 method for class 'BANOVA.ordMultinomial'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.ordMultinomial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.ordMultinomial_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included, if missing, the single level model will be generated</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_l1_hyper">l1_hyper</code></td>
<td>
<p>level 1 hyperparameters for single level models, default c(0.0001,100)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>, d), default c(1,1,0.0001,100)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.ordMultinomial</code> (returned by <code>BANOVA.ordMultinomial</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format with the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.ordMultinomial</code> (returned by <code>BANOVA.ordMultinomial</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.ordMultinomial_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i = 1</code>, if <code class="reqn">l_i &lt; 0</code> <br />
<code class="reqn">y_i = 2</code>, if <code class="reqn">0 &lt; l_i &lt; c_2</code> <br />
... <br />
<code class="reqn">y_i = \ell</code>, if <code class="reqn">c_{\ell-1} &lt; l_i &lt; \infty</code> <br />
<code class="reqn">l_i = \eta_i + \epsilon_i</code>
where <code class="reqn">\epsilon_i</code> ~ logistic <code class="reqn">(0,1)</code>, <code class="reqn">c_\ell, (\ell = 2,...L-1)</code> are cut points, <code class="reqn">c_\ell</code> ~ <code class="reqn">N(0, \bar{\sigma}_\ell^2)</code>, and <code class="reqn">\bar{\sigma}_\ell^2</code> ~ <code class="reqn">Uniform(0, d)</code>, with <code class="reqn">d</code> a hyper-parameter. <br /> <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>. see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>
</p>


<h3>Value</h3>

<p><code>BANOVA.ordMultinomial</code> returns an object of class <code>"BANOVA.ordMultinomial"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>samples_cutp_param</code></td>
<td>
<p>posterior samples of cutpoints</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

res &lt;- BANOVA.ordMultinomial (perceivedsim~1, ~progress*prodvar,  goalstudy,
goalstudy$id, burnin = 1000, sample = 1000, thin = 2)
summary(res)
# or use BANOVA.run based on 'Stan'
require(rstan)
res &lt;- BANOVA.run(perceivedsim~progress*prodvar, data = goalstudy, 
model_name = 'ordMultinomial', id = 'id', iter = 100, thin = 1, chains = 2)

</code></pre>

<hr>
<h2 id='BANOVA.Poisson'>Estimation of BANOVA with Poisson dependent variables</h2><span id='topic+BANOVA.Poisson'></span><span id='topic+predict.BANOVA.Poisson'></span><span id='topic+print.BANOVA.Poisson'></span><span id='topic+summary.BANOVA.Poisson'></span>

<h3>Description</h3>

<p><code>BANOVA.Poisson</code> implements a Hierarchical Bayesian ANOVA for models with a count-data response variable and normal heterogeneity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.Poisson(l1_formula = "NA", l2_formula = "NA",
  data, id, l2_hyper = c(1, 1, 0.0001), burnin = 5000, sample = 2000, thin = 10, 
  adapt = 0, conv_speedup = F, jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.Poisson'
summary(object, ...)
## S3 method for class 'BANOVA.Poisson'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.Poisson'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.Poisson_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included, if missing, the single level model will be generated</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_data">data</code></td>
<td>
<p>a data.frame in long format including all features in level 1 and level 2(covariates and categorical factors) and responses</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.Poisson</code> (returned by <code>BANOVA.Poisson</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format with the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.Poisson</code> (returned by <code>BANOVA.Poisson</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.Poisson_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i</code> ~ <code class="reqn">Poisson(\lambda_i)</code>, <code class="reqn">\lambda_i = exp(\eta_i + \epsilon_i)</code> <br />
where <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>, see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>. <code class="reqn">\epsilon_i</code> is a dispersion term.
</p>


<h3>Value</h3>

<p><code>BANOVA.Poisson</code> returns an object of class <code>"BANOVA.Poisson"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>samples_l2_sigma_param</code></td>
<td>
<p>posterior samples of level 2 standard deviations</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the bpndata dataset
data(bpndata)
# within-subjects model using the dependent variable : PIC_FIX 
res1 &lt;- BANOVA.Poisson(PIC_FIX ~ AD_ID + PIC_SIZE+ PAGE_NUM 
+ PAGE_POS, ~1, bpndata, bpndata$RESPONDENT_ID, burnin = 500, 
sample = 200, thin = 5)
summary(res1)

# use the goalstudy dataset
data(goalstudy)
goalstudy$bid &lt;- as.integer(goalstudy$bid + 0.5)
res2&lt;-BANOVA.Poisson(bid~1, ~progress*prodvar,  goalstudy, goalstudy$id, 
burnin = 5000, sample = 2000, thin = 10)
summary(res2)

# or use the BANOVA.run based on 'Stan'
require(rstan)
res3 &lt;- BANOVA.run(bid~progress*prodvar, data = goalstudy, 
model_name = 'Poisson', id = 'id', iter = 100, thin = 1, chains = 2)


</code></pre>

<hr>
<h2 id='BANOVA.run'>Estimation of BANOVA models</h2><span id='topic+BANOVA.run'></span><span id='topic+predict.BANOVA'></span><span id='topic+print.BANOVA'></span><span id='topic+summary.BANOVA'></span>

<h3>Description</h3>

<p><code>BANOVA.run</code> implements Hierarchical Bayesian ANOVA models using 'Stan'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.run(l1_formula = "NA", l2_formula = "NA", fit = NULL, model_name = 'NA', 
dataX = NULL, dataZ = NULL, data = NULL, y_value = NULL, id, iter = 2000, 
num_trials = 1, contrast = NULL, y_lowerBound = -Inf, y_upperBound = Inf, ...)
## S3 method for class 'BANOVA'
summary(object, ...)
## S3 method for class 'BANOVA'
predict(object, newdata = NULL, Xsamples = NULL, Zsamples = 
                        NULL, ...)
## S3 method for class 'BANOVA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.run_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included. If NULL, the single-level model is used</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_fit">fit</code></td>
<td>
<p>a fitted BANOVA models, an object of class <code>"BANOVA.build"</code>, default NULL which needs compilation</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_model_name">model_name</code></td>
<td>
<p>a character string in c('Normal', 'T', 'Bernoulli', 'Binomial', 'Poisson', 'ordMultinomial', 'Multinomial', 'multiNormal', 'truncNormal')</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_datax">dataX</code></td>
<td>
<p>a list of data frames (each corresponds to the choice set of each observation) that includes all covariates and factors, for the Multinomial model only, default NULL</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_dataz">dataZ</code></td>
<td>
<p>a data frame (long format) that includes all level 2 covariates and factors, for the Multinomial model only, default NULL</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_data">data</code></td>
<td>
<p>a data.frame in a long format including all features in level 1 and level 2 (covariates and categorical factors) and responses, default NULL. For the Multivariate Normal model the data must be specially prepared: first, combine the set of dependent variables in a single matrix; next, add this matrix to an original data frame used in the analysis. For an example of the specification of the data, please, see below.</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_id">id</code></td>
<td>
<p>subject ID (string) of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_y_value">y_value</code></td>
<td>
<p>choice responses, 1,2,3..., for the Multinomial model only, default NULL</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_iter">iter</code></td>
<td>
<p>target samples in the 'Stan' algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_num_trials">num_trials</code></td>
<td>
<p>the number of trials of each
observation(=1, if it is Bernoulli), the type is forced to be 'integer', for the Binomial model only, default 0</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_contrast">contrast</code></td>
<td>
<p>a list of contrasts for planned comparisons, default: effect coding (NULL value)</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_y_lowerbound">y_lowerBound</code></td>
<td>
<p>lower bound of the dependent variable, for the Truncated Normal model only, 
default -Inf.</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_y_upperbound">y_upperBound</code></td>
<td>
<p>upper bound of the dependent variable, for the Truncated Normal model only, 
default Inf.</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_object">object</code></td>
<td>
<p>an object of class <code>BANOVA</code> (returned by <code>BANOVA.run</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_x">x</code></td>
<td>
<p>an object of class <code>BANOVA</code> (returned by <code>BANOVA.run</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format as the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_xsamples">Xsamples</code></td>
<td>
<p>a list of sample data frames(each corresponds to the choice set of each observation) that includes all covariates and factors, for the Multinomial model only, default NULL</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_zsamples">Zsamples</code></td>
<td>
<p>a data frame(long format) that includes all level 2 covariates and factors, for the Multinomial model only, default NULL</p>
</td></tr>
<tr><td><code id="BANOVA.run_+3A_...">...</code></td>
<td>
<p>additional arguments, for <code>BANOVA.run</code>, it can include standard 'Stan' arguments, e.g. warmup, thin, chains, etc., see sampling for more details, for other functions, ignored currently</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BANOVA.run</code> returns an object of class <code>"BANOVA"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l1_param</code></td>
<td>
<p>posterior samples of level 1 parameters</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>samples_l2_sigma_param</code></td>
<td>
<p>posterior samples of level 2 standard deviations</p>
</td></tr>
<tr><td><code>samples_cutp_param</code></td>
<td>
<p>posterior samples of cutpoints</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>model_code</code></td>
<td>
<p>'Stan' code</p>
</td></tr>
<tr><td><code>single_level</code></td>
<td>
<p>if this is a single level model</p>
</td></tr>
<tr><td><code>stan_fit</code></td>
<td>
<p>fitted samples</p>
</td></tr>
<tr><td><code>model_name</code></td>
<td>
<p>the name of the model</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>contrasts for planned comparisons</p>
</td></tr>
<tr><td><code>new_id</code></td>
<td>
<p>id values coded in 1,2,3,...</p>
</td></tr>
<tr><td><code>old_id</code></td>
<td>
<p>original id values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# Analysis of a single-level Normal dependent variable
# Use the ipadstudy data set
data(ipadstudy)
library(rstan)
# build the BANOVA model first so that it can be reused
model &lt;- BANOVA.model('Normal', single_level = TRUE)
banova_model &lt;- BANOVA.build(model)
res_1 &lt;- BANOVA.run(attitude~owner + age + gender + selfbrand*conspic, 
fit = banova_model, data = ipadstudy, id = 'id', iter = 2000, chains = 2)
summary(res_1)
# or call the function directly without specifying the fit argument
# but it needs compilation
res_1 &lt;- BANOVA.run(attitude~owner + age + gender + selfbrand*conspic,
model_name = 'Normal', data = ipadstudy, id = 'id', iter = 2000, chains = 2)

# Hierarchical analysis of multiple dependent variables (Multivariate Normal distribution)
# Use the colorad data set
data(colorad)
# Prepare dependent variables to be analyzed
colorad$blur_squared &lt;- (colorad$blur)^2
dv &lt;- cbind(colorad$blur, colorad$blur_squared)
colnames(dv) &lt;- c("blur", "blur_squared")
colorad$dv &lt;- dv
# Build and analyze the model for the dependent variables
model &lt;- BANOVA.model('multiNormal')
banova_multi_norm_model &lt;- BANOVA.build(model)
res_2 &lt;- BANOVA.run(dv ~ typic, ~ color, fit = banova_multi_norm_model,
                    data = colorad, id = 'id', iter = 2000, thin = 1, chains = 2)

</code></pre>

<hr>
<h2 id='BANOVA.simple'>Simple effects calculation</h2><span id='topic+BANOVA.simple'></span>

<h3>Description</h3>

<p><code>BANOVA.simple</code> is a function for probing interaction effects in models where
both  moderator  and  explanatory  variables  are  factors  with an arbitrary  number 
of levels. The function estimates and tests simple or partial effects, also known as simple main
or conditional effects. Both single-level and multi-level models with any of the distributions accommodated in 
the package can be analyzed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.simple(BANOVA_output, base = NULL, quantiles = c(0.025, 0.975), 
dep_var_name = NULL, return_posterior_samples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.simple_+3A_banova_output">BANOVA_output</code></td>
<td>
<p>an object of class &quot;BANOVA&quot; returned by BANOVA.run function with 
an outcome of the hierarchical Bayesian ANOVA analysis.</p>
</td></tr>
<tr><td><code id="BANOVA.simple_+3A_base">base</code></td>
<td>
<p>a character string which specifies the name of the mediator variable used as a base 
for calculation.</p>
</td></tr>
<tr><td><code id="BANOVA.simple_+3A_quantiles">quantiles</code></td>
<td>
<p>a numeric vector with quantiles for the posterior interval of the simple effects.
Must include two elements with values between 0 and 1 in ascending order, default c(0.025, 0.975)</p>
</td></tr>
<tr><td><code id="BANOVA.simple_+3A_dep_var_name">dep_var_name</code></td>
<td>
<p>a character string with a name of the dependent variable, for the Multinomial model only, 
default NULL.</p>
</td></tr>
<tr><td><code id="BANOVA.simple_+3A_return_posterior_samples">return_posterior_samples</code></td>
<td>
<p>logical indicator of whether samples of the posterior simple effects
distributions should be returned, default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function identifies all factors and their combinations that are interacting with a moderating of &quot;base&quot;
variable. For each interaction, it determines all possible level combinations of the involved regressors,
which are further used to combine the posterior samples of the selected regression coefficients to calculate 
simple effects. 
</p>
<p>When the default effect coding scheme is used the simple effects are calculated for all levels of the 
interacting variables, as specified in the data. If a user specifies different contrasts for any of the interacting 
variables the simple effects for these variables are reported for the user-defined 
regressors. This distinction is reflected in the labels of the reported results: in the default case labels from the 
original factors are displayed; in the case of user-defined contrasts, the name of the regressor is displayed instead. 
</p>
<p>The summary of the posterior distribution of each simple effect contains the mean, 
standard deviation, posterior interval, which by default reports a central 95% interval, 
but can also be specified by the user, and a two-sided Bayesian p-value. 
</p>
<p>Note that for a Multinomial model intercepts and between-subject regressors have choice specific 
coefficients and thus simple effects are reported for each possible choice outcome. To perform the 
calculation for a Multinomial model an additional argument <code>dep_var_name</code> with a name of the 
dependent variable must be specified.
</p>


<h3>Value</h3>

<p>Returns a list with the summary tables of the results; optionally returns the 
samples drawn from the posterior simple effects distributions.
</p>
<table>
<tr><td><code>results_summary</code></td>
<td>
<p>a list of tables with summaries of the posterior simple effects distributions
for all factors and their combinations that are interacting with a moderating variable.</p>
</td></tr>
<tr><td><code>samples_simple_effects</code></td>
<td>
<p>if <code>return_posterior_samples</code> is set to <code>TRUE</code> 
a list of tables with samples of the posterior simple effects is returned. The tables include results
for all levels of all factors and their combinations that are interacting with a moderating variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anna Kopyakova
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the colorad data set
data(colorad)

# Build and analyze the model
model &lt;- BANOVA.model('Binomial')
banova_model &lt;- BANOVA.build(model)
res_1 &lt;- BANOVA.run(y ~ typic, ~ color*blurfac, fit = banova_model,
                    data = colorad, id = 'id', num_trials = as.integer(16), 
                    iter = 2000, thin = 1, chains = 2)
# Calculate simple effects with "blurfac" as a moderating vriable
simple_effects &lt;- BANOVA.simple(BANOVA_output = res_1, base = "blurfac")

</code></pre>

<hr>
<h2 id='BANOVA.T'>Estimation of BANOVA with T-distributin of the dependent variable</h2><span id='topic+BANOVA.T'></span><span id='topic+predict.BANOVA.T'></span><span id='topic+print.BANOVA.T'></span><span id='topic+summary.BANOVA.T'></span>

<h3>Description</h3>

<p><code>BANOVA.T</code> implements a Hierarchical Bayesian ANOVA for linear models with T-distributed response. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BANOVA.T(l1_formula = "NA", l2_formula = "NA", data, id, l1_hyper = c(1, 1, 1), 
l2_hyper = c(1, 1, 0.0001), burnin = 5000, sample = 2000, thin = 10, 
adapt = 0, conv_speedup = F, jags = runjags.getOption('jagspath'))
## S3 method for class 'BANOVA.T'
summary(object, ...)
## S3 method for class 'BANOVA.T'
predict(object, newdata = NULL,...)
## S3 method for class 'BANOVA.T'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BANOVA.T_+3A_l1_formula">l1_formula</code></td>
<td>
<p>formula for level 1 e.g. 'Y~X1+X2'</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_l2_formula">l2_formula</code></td>
<td>
<p>formula for level 2 e.g. '~Z1+Z2',
response variable must not be included, if missing, the single level model will be generated</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_data">data</code></td>
<td>
<p>a data.frame in long format including all features in level 1 and level 2(covariates and categorical factors) and responses</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_id">id</code></td>
<td>
<p>subject ID of each response unit</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_l1_hyper">l1_hyper</code></td>
<td>
<p>level 1 hyperparameters, c(<code class="reqn">\alpha, \beta, \lambda</code>) for two-level models and c(<code class="reqn">\alpha, \beta, \lambda, \sigma_p</code>) for single level models, default c(1,1,1)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_l2_hyper">l2_hyper</code></td>
<td>
<p>level 2 hyperparameters, c(a, b, <code class="reqn">\gamma</code>), default c(1,1,0.0001)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn in draws in the MCMC algorithm, default 5000</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_sample">sample</code></td>
<td>
<p>target samples in the MCMC algorithm after thinning, default 2000</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_thin">thin</code></td>
<td>
<p>the number of samples in the MCMC algorithm that needs to be thinned, default 10</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_adapt">adapt</code></td>
<td>
<p>the number of adaptive iterations, default 0 (see <a href="runjags.html#topic+run.jags">run.jags</a>)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_conv_speedup">conv_speedup</code></td>
<td>
<p>whether to speedup convergence, default F</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_jags">jags</code></td>
<td>
<p>the system call or path for activating 'JAGS'. Default calls findjags() to attempt to locate 'JAGS' on your system</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_object">object</code></td>
<td>
<p>object of class <code>BANOVA.T</code> (returned by <code>BANOVA.T</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_newdata">newdata</code></td>
<td>
<p>test data, either a matrix, vector or a
data frame. It must have the same format with the original data (the same column number)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_x">x</code></td>
<td>
<p>object of class <code>BANOVA.T</code> (returned by <code>BANOVA.T</code>)</p>
</td></tr>
<tr><td><code id="BANOVA.T_+3A_...">...</code></td>
<td>
<p>additional arguments,currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 model: <br />
<code class="reqn">y_i</code> ~ <code class="reqn">t(\nu, \eta_i,\sigma^{-2})</code> <br />
where <code class="reqn">\eta_i = \sum_{p = 0}^{P}\sum_{j=1}^{J_p}X_{i,j}^p\beta_{j,s_i}^p</code>, <code class="reqn">s_i</code> is the subject id of response <code class="reqn">i</code>, see <code><a href="#topic+BANOVA-package">BANOVA-package</a></code>. The hyper parameters: <code class="reqn">\nu</code> is the degree of freedom, <code class="reqn">\nu</code> ~ Piosson(<code class="reqn">\lambda</code>) and <code class="reqn">\sigma</code> is the scale parameter, <code class="reqn">\sigma^{-2}</code> ~ Gamma(<code class="reqn">\alpha, \beta</code>).
</p>


<h3>Value</h3>

<p><code>BANOVA.T</code> returns an object of class <code>"BANOVA.T"</code>. The returned object is a list containing:
</p>
<table>
<tr><td><code>anova.table</code></td>
<td>
<p>table of effect sizes <code><a href="#topic+BAnova">BAnova</a></code></p>
</td></tr>
<tr><td><code>coef.tables</code></td>
<td>
<p>table of estimated coefficients</p>
</td></tr>
<tr><td><code>pvalue.table</code></td>
<td>
<p>table of p-values <code><a href="#topic+table.pvalues">table.pvalues</a></code></p>
</td></tr>
<tr><td><code>dMatrice</code></td>
<td>
<p>design matrices at level 1 and level 2</p>
</td></tr>
<tr><td><code>samples_l2_param</code></td>
<td>
<p>posterior samples of level 2 parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame</p>
</td></tr>
<tr><td><code>mf1</code></td>
<td>
<p>model.frame of level 1</p>
</td></tr>
<tr><td><code>mf2</code></td>
<td>
<p>model.frame of level 2</p>
</td></tr>
<tr><td><code>JAGSmodel</code></td>
<td>
<p>'JAGS' model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the ipadstudy data set
data(ipadstudy)
res &lt;- BANOVA.T(attitude~1, ~owner + age + gender + selfbrand*conspic, ipadstudy,
ipadstudy$id, burnin = 5000, sample = 2000, thin = 10)
summary(res)

# or use BANOVA.run based on 'Stan'
require(rstan)
res19 &lt;- BANOVA.run(attitude~owner + age + gender + selfbrand*conspic, 
data = ipadstudy, model_name = 'T', id = 'id', iter = 100, 
thin = 1, chains = 2)

</code></pre>

<hr>
<h2 id='bernlogtime'>Data for analysis of effects of typicality, blur and color on gist perception of ads</h2><span id='topic+bernlogtime'></span>

<h3>Description</h3>

<p>Data from a mixed design experiment, where respondents were exposed to 32 ads, for 100 millisec. The ads were either typical or atypical (typical: 1 or 2). Respondents were exposed to ads that were either in full color or black-and-white (color: 1 or 2), and at different levels of blur (1=normal,5 = very high blur). These are between-subjects factors. The dependent variables are the response 0/1, and the response time. Typicality is a within-subjects variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bernlogtime)</code></pre>


<h3>Format</h3>

<p>This R object contains within-subject variable: $typical is a factor with 2 levels &quot;0&quot; (typical ads) and &quot;1&quot;(atypical ads); between-subjects variables: $blur is a factor with two levels (1=normal,5 = very high blur). $color denotes a factor with 2 levels &quot;1&quot;(full color) and &quot;2&quot;(grayscale). $subject is the ID of subjects. $response denotes if the ad is correctly identified. $logtime is the response time.
</p>
<p>$bernlogtime: 'data.frame':  3072 obs. of  6 variables:<br />
... $ subject : int  5 5 5 5 5 5 5 5 5 5 ...<br />
... $ typical : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 1 2 1 1 1 2 2 2 2 1 ...<br />
... $ blur    : Factor w/ 2 levels &quot;1&quot;,&quot;5&quot;: 1 1 1 1 1 1 1 1 1 1 ...<br />
... $ color   : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 2 2 2 2 2 2 2 2 2 2 ...<br />
... $ response: int  1 1 1 1 1 1 1 1 1 1 ...<br />
... $ logtime : num  0.977 1.73 1.784 1 1.149 ...<br />
</p>


<h3>References</h3>

 
<p>Wedel, M and R. Pieters (2015). 
<em>The Buffer Effect: The Role of Color when Advertising Exposures are Brief and Blurred</em>, Marketing Science, Vol. 34, No. 1, pp. 134-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bernlogtime)
# model using the dependent variable : log of the response time(logtime) 
res1 &lt;- BANOVA.Normal(logtime~typical, ~blur + color, bernlogtime, 
bernlogtime$subject, burnin = 1000, sample = 1000, thin = 1)
summary(res1)
table.predictions(res1)

# model using the dependent variable : response
res2 &lt;- BANOVA.Bernoulli(response~typical, ~blur + color, bernlogtime, 
bernlogtime$subject, burnin = 1000, sample = 1000, thin = 1)
summary(res2)
table.predictions(res2)

</code></pre>

<hr>
<h2 id='bpndata'>Eye-movement data for analysis of print ad designs</h2><span id='topic+bpndata'></span>

<h3>Description</h3>

<p>Data were collected in an experimental study in which 88 participants freely paged through a magazine at home or in a waiting room. While flipping through pages at their own pace, participants' eye-movements were recorded with infra-red corneal reflection eye-tracking methodology. In a subsequent memory task, participants were asked to identify the target brand in the ad as soon as possible by touching the correct brand name on the screen. <b>Accuracy</b> (accurate=1, inaccurate =0) of brand memory and <b>response time</b> were recorded for each ad and participant. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bpndata)</code></pre>


<h3>Format</h3>

<p>This R object contains 3080 observations in the data (35 ads x 88 participants). The goal is to examine the effects of several ad design variables on both eye movements and memory. The variables include:
</p>
<p>1.  RESPONDENT_ID: ID number of a respondent;<br />
2.  AD_ID: ID number of an ad;<br />
3.	PAGE_NUM: page number in the magazine where an ad appears (1,2,3,...);<br />
4.	PAGE_POS: the right-side vs. left-side position on a page, 1 = right, 0 = left;<br />
5.	PIC_FIX: fixation count of the pictorial element (0, 1, 2, 3, ...);<br />
6.	PIC_SIZE: surface size of the pictorial element, in inches2;<br />
7.	RECALL_ACCU: whether a respondent accurately recalls the brand name, 1= yes, 0 = no;<br />
8.	RECALL_TIME: the time it takes a respondent to answer the brand recall question, in seconds.<br />
</p>
<p>$ bpndata: 'data.frame':  3080 obs. of  8 variables:<br />
... $ RESPONDENT_ID: int  1 1 1 1 1 1 1 1 1 1 ...<br />
... $ AD_ID        : int  1 2 3 4 5 6 7 8 9 10 ...<br />
... $ PAGE_NUM     : int  2 5 6 11 13 14 17 18 21 22 ...<br />
... $ PAGE_POS     : int  0 1 0 1 1 0 1 0 1 0 ...<br />
... $ PIC_FIX      : int  0 2 1 1 1 2 0 3 3 8 ...<br />
... $ PIC_SIZE     : num  74.2 52.6 77.6 71.4 52.4 ...<br />
... $ RECALL_ACCU  : int  0 0 0 0 0 0 1 1 0 0 ...<br />
... $ RECALL_TIME  : num  2.56 1.04 2.76 2.8 2.28 2.32 2.04 2.04 2.48 0.6 ...<br />
</p>


<h3>References</h3>

 
<p>Wedel, M. and Pieters, R. (Autumn, 2000). <em>Eye Fixations on Advertisements and Memory for Brands: A Model and Findings</em>, Marketing Science, Vol. 19, No. 4, pp. 297-312
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(bpndata)
# within-subjects model using the dependent variable : PIC_FIX
library(rstan)
model &lt;- BANOVA.model('Poisson')
stanmodel &lt;- BANOVA.build(model)
res0 &lt;- BANOVA.run(PIC_FIX ~ PIC_SIZE + PAGE_NUM + PAGE_POS, ~1, 
fit = stanmodel, data = bpndata, id = 'RESPONDENT_ID', 
iter = 200, thin = 1, chains = 2)
res0
# or
res1 &lt;- BANOVA.Poisson(PIC_FIX ~ PIC_SIZE + PAGE_NUM 
+ PAGE_POS, ~1, bpndata, bpndata$RESPONDENT_ID, burnin = 1000, sample = 1000, thin = 1)
res1

# within-subjects model using the dependent variable : RECALL_ACCU
model_bern &lt;- BANOVA.model('Bernoulli')
stanmodel_bern &lt;- BANOVA.build(model_bern)
res2 &lt;- BANOVA.run(RECALL_ACCU ~ RECALL_TIME + PAGE_NUM + PAGE_POS, ~1, 
fit = stanmodel_bern, data = bpndata, id = 'RESPONDENT_ID', 
iter = 200, thin = 1, chains = 2)
res2
# or
res3 &lt;- BANOVA.Bernoulli(RECALL_ACCU ~ RECALL_TIME + PAGE_NUM 
+ PAGE_POS, ~1, bpndata, bpndata$RESPONDENT_ID, burnin = 1000, sample = 1000, thin = 1)
res3

</code></pre>

<hr>
<h2 id='choicedata'>Household Panel Data on Margarine Purchases</h2><span id='topic+choicedata'></span>

<h3>Description</h3>

<p>Panel data on purchases of margarine by 204 households. 
Demographic variables are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(choicedata)</code></pre>


<h3>Format</h3>

<p>This is an R object that contains within-subjects variables and between-subjects variables:
</p>
<p>$ choicePrice:&lsquo;data.frame&rsquo;:  1500 obs. of  13 variables:<br />
... $ hhid    : int  2100016 2100016 2100016 2100016 <br />
... $ choice  : int  1 1 1 1 1 4 1 1 4 1 <br />
</p>
<p>Within-subject variables: <br />
</p>
<p>... $ PPk_Stk : num 0.66 0.63 0.29 0.62 0.5 0.58 0.29 ...<br />
... $ PBB_Stk : num 0.67 0.67 0.5 0.61 0.58 0.45 0.51 ...<br />
... $ PFl_Stk : num 1.09 0.99 0.99 0.99 0.99 0.99 0.99 ...<br />
... $ PHse_Stk: num 0.57 0.57 0.57 0.57 0.45 0.45 0.29 ...<br />
... $ PGen_Stk: num 0.36 0.36 0.36 0.36 0.33 0.33 0.33 ...<br />
... $ PSS_Tub : num 0.85 0.85 0.79 0.85 0.85 0.85 0.85 ...<br />
</p>
<p>Pk is Parkay; BB is BlueBonnett, Fl is Fleischmanns, Hse is house,
Gen is generic, SS is Shed Spread.  _Stk indicates 
stick, _Tub indicates Tub form.
</p>
<p>Between-subject variables: <br />
</p>
<p>... $ Income   : num 32.5 17.5 37.5 17.5 87.5 12.5 ... <br />
... $ Fam_Size : int 2 3 2 1 1 2 2 2 5 2 ...<br />
... $ college  : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...<br />
... $ whtcollar: Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 0 0 0 0 0 0 0 1 1 1 ...<br />
... $ retired  : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...<br />
</p>


<h3>Details</h3>

<p>choice is a multinomial indicator of one of the 6 brands (in order listed under format). 
All prices are in $.
</p>


<h3>Source</h3>

<p>Allenby, G. and Rossi, P. (1991), <em>Quality Perceptions and Asymmetric Switching Between Brands</em>, <em>Marketing Science</em>, Vol. 10, No.3, pp. 185-205.
</p>


<h3>References</h3>

<p>Chapter 5, <em>Bayesian Statistics and Marketing</em> by Rossi et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(choicedata)
# generate dataX(convert the within-subjects variables to a list)
dataX &lt;- list()
for (i in 1:nrow(choicedata)){
  logP &lt;- as.numeric(log(choicedata[i,3:8]))
  # Note: Before the model initialization, all numeric variables(covariates) 
  # must be mean centered
  dataX[[i]] &lt;- as.data.frame(logP) - mean(logP)
}
dataZ &lt;- choicedata[,9:13]
res &lt;- BANOVA.Multinomial(~ logP, ~ college, dataX, dataZ, choicedata$choice, 
choicedata$hhid, burnin = 100, sample = 100, thin = 1)
summary(res)
predict(res,dataX[1:4], dataZ[1:4,])

</code></pre>

<hr>
<h2 id='colorad'>Data for gist perception of advertising, study 1</h2><span id='topic+colorad'></span>

<h3>Description</h3>

<p>Data from an experiment in which one hundred and sixteen subjects (53 men; mean age 23, ranging from 21 to 28) were randomly assigned to one condition of a 5 (blur: normal, low, medium, high, very high) x 2 (color: full color, grayscale) between-participants, x 2 (image: typical ads, atypical ads) within-participants, mixed design. Participants were exposed to 40 images, 32 full-page ads and 8 editorial pages. There were 8 ads per product category, with 4 typical and 4 atypical ones, the categories being car, financial services, food, and skincare. Subjects were asked to identify each image being flashed for 100msec. as being an ad or not. The total number of correct ad identifications, for typical and atypical ads, are used as a dependent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colorad)</code></pre>


<h3>Format</h3>

<p>This R object contains within-subject variable $typic which is a factor with 2 levels &quot;0&quot; (typical ads) and &quot;1&quot;(atypical ads); between-subjects variables: $blur which is a numerical vairable denotes 5 different levels of blur (which must be mean centered), $blurfac is a categorical data corresponding to the levels of $blur, $color which is a factor with 2 levels &quot;0&quot;(full color) and &quot;1&quot;(grayscale). $id is the ID of subjects. $y is the number of correct identifications of the 16 ads of each subject for each level of $typic. 
</p>
<p>$ colorad:&lsquo;data.frame&rsquo;:  474 obs. of  8 variables:<br />
... $ id      : int  1 1 2 2 3 3 4 4 5 5 ... <br />
... $ typic   : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 0 1 0 1 0 1 0 1 0 1 ...<br />
... $ y       : int  8 6 12 6 11 9 9 11 14 14 ... <br />
... $ blurfac    : Factor w/ 5 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 2 2 4 4 2 2 3 3 1 1 ... <br />
... $ color   : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 0 0 0 0 0 0 1 1 ... <br />
... $ blur: num  3.69 3.69 4.79 4.79 3.69 ... <br />
</p>


<h3>References</h3>

 
<p>Wedel, M and R. Pieters (2015). 
<em>The Buffer Effect: The Role of Color when Advertising Exposures are Brief and Blurred</em>, Marketing Science, Vol. 34, No. 1, pp. 134-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(colorad)
library(rstan)
# Build the model
model_bin &lt;- BANOVA.model('Binomial')
stanmodel_bin &lt;- BANOVA.build(model_bin)
out0 = BANOVA.run(y ~ typic, ~ color*blurfac, fit = stanmodel_bin,
                   data = colorad, id = 'id', num_trials = as.integer(16), 
                   iter = 100, thin = 2, chains = 1)
summary(out0)
# planned comparison
out0_contra = BANOVA.run(y ~ typic, ~ color*blurfac, fit = stanmodel_bin,
                          data = colorad, id = 'id', num_trials = as.integer(16), 
                          iter = 100, thin = 2, chains = 1, 
                          contrast = list(typic = c(-1,1)))
summary(out0_contra)


</code></pre>

<hr>
<h2 id='colorad2'>Data for gist perception of advertising, study 2</h2><span id='topic+colorad2'></span>

<h3>Description</h3>

<p>Data from an experiment in which One hundred and forty eight subjects (71 men; age ranging from 21 to 28) were randomly assigned to one condition of a 2 (blur: normal, very high) x 2 (color: full color, grayscale, inverted) between-participants design. Participants were exposed to 25 ads for five brands in each of five categories. Ads were selected to be typical for the category, using the same procedure as in <code><a href="#topic+colorad">colorad</a></code>. The product categories used were cars, financial services, food, skincare and fragrance. Images were flashed for 100 msec. and subjects were asked to identify whether the image was an ad or not, and if they identified it correctly as an ad, they were asked to indicate which category (out of five) was advertised. The total number of correct ad identifications and category identifications are used as dependent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colorad2)</code></pre>


<h3>Format</h3>

<p>This R object contains between-subjects variables: $B is a factor corresponding to the levels of blur (normal = 0, very high = 1), $C1 and $C2 are dummy variables denote 'grayscale' and 'inverted' levels of color. $C is the original factor denote the color with 3 levels. $ID is the ID of subjects. $Y1 is the number of correct identifications of the 25 ads of each subject. $Y2 is the number of correct identifications of the category, given the number of correct ad identifications.
</p>
<p>$ colorad2:&lsquo;data.frame&rsquo;:   148 obs. of  7 variables:<br />
... $ ID  : int  1 2 3 4 5 6 7 8 9 10 ... <br />
... $ C1  : int  0 1 1 0 0 0 0 0 1 1 ...<br />
... $ C2  : int  0 0 0 1 1 0 0 0 0 0 ...<br />
... $ B   : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 0 0 1 0 0 1 0 1 ... <br />
... $ Y1  : int  14 6 23 21 8 23 24 5 23 6 ... <br />
... $ Y2  : int  2 3 8 8 2 15 10 1 13 0 ... <br />
... $ C   : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 2 2 3 3 1 1 1 2 2 ... <br />
</p>


<h3>References</h3>

 
<p>Wedel, M and R. Pieters (2015). 
<em>The Buffer Effect: The Role of Color when Advertising Exposures are Brief and Blurred</em>, Marketing Science, Vol. 34, No. 1, pp. 134-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(colorad2)
# factor C is effect coded
model_bin &lt;- BANOVA.model('Binomial')
stanmodel_bin &lt;- BANOVA.build(model_bin)
res0 &lt;- BANOVA.run(Y1 ~ 1, ~ C + B + C*B, fit = stanmodel_bin, 
data = colorad2, id = 'id', num_trials = as.integer(25), 
iter = 100, thin = 1, chains = 2)
res0
# or use BANOVA.Binomial
res1 &lt;- BANOVA.Binomial(Y1 ~ 1, ~ C + B + C*B, colorad2, colorad2$id, as.integer(25), 
burnin = 100, sample = 100, thin = 1) 


</code></pre>

<hr>
<h2 id='condstudy'>Data for the study of how brand attitudes were influenced by showing brands together with pleasant pictures</h2><span id='topic+condstudy'></span>

<h3>Description</h3>

<p>The study investigated how brand attitudes were influenced by showing brands together with pleasant pictures. Attitude change via conditioning can result from either a direct transfer of affect from the picture to the brand, or from an indirect association of the brand and the picture in memory. In Sweldens' et al. (2010) experiment 1, indirect conditioning was implemented by presenting a brand repeatedly with the same picture, direct conditioning by presenting it simultaneously with different pictures. The pictures used were either neutral or positive. This study involved a mixed design, with a within-subject factor (cond = neutral, positive), and a between-subject factor (type = indirect, direct), as well as a within-subject mediator. Although the original mediation hypotheses are more intricate, here the mediation of the conditioning effect is investigated by measurements of attitudes towards the pictures that were shown with the brands (pict).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(condstudy)</code></pre>


<h3>Format</h3>

<p>This R object contains a between-subjects variable: type, which denotes a between-subject moderator. It has two levels, &quot;indirect&quot; and &quot;direct&quot;. In the &quot;indirect&quot; condition the brands were shown with the same images, in the indirect condition the brands were shown with different images; Within-subject variables: cond, a within-subject factor with 2 levels: &quot;pos&quot;, and &quot;xneu&quot;, which indicates whether each brand was shown with a neutral (xneu) or positive (pos) emotional image. pict,  a within-subject mediator variable measuring the valence (positive/negative) of the emotional image the respondent remembers the brand to have been shown with. att, a dependent variable which denotes the ratings of attitudes toward brands. 
</p>
<p>$ condstudy: 'data.frame':  888 obs. of  5 variables:<br />
... $ id  : int  2 2 2 2 2 2 3 3 3 3 ... <br />
... $ att : num  2.94 2.44 3.44 1.67 1.67 ... <br />
... $ cond: Factor w/ 2 levels &quot;pos&quot;,&quot;xneu&quot;: 1 1 1 2 2 2 1 1 1 2 ... <br />
... $ type: Factor w/ 2 levels &quot;direct&quot;,&quot;indirect&quot;: 2 2 2 2 2 2 2 2 2 2 ... <br />
... $ pict: int  6 7 6 2 4 5 9 3 2 5 ... <br />
</p>


<h3>References</h3>

 
<p>Sweldens, S., Osselaer, S. and Janiszewski, C. (2010) <em>Evaluative Conditioning Procedures and the Resilience of Conditioned Brand Attitudes</em>. Journal of Consumer Research,  Vol. 37.
</p>
<p>Wedel, M. and Dong, C. (2016) <em>BANOVA: Bayesian Analysis of Variance for Consumer Research</em>. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# condstudy_sub is a subset of condstudy with 180 obs. and the same variables
data(condstudy_sub)
model &lt;- BANOVA.model('Normal')
stanmodel &lt;- BANOVA.build(model)
out2 &lt;- BANOVA.run(att~cond+pict, ~type, fit = stanmodel, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)    
conv.diag(out2)
summary(out2) 
table.predictions(out2)  
BANOVA.floodlight(out2, var_factor = 'type', var_numeric = 'pict')
cat(out2$model_code)

out3 &lt;- BANOVA.run(pict~cond, ~type, fit = stanmodel, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)
conv.diag(out3)
summary(out3)
BANOVA.mediation(out2, out3, xvar='cond', mediator='pict')

</code></pre>

<hr>
<h2 id='condstudy_sub'>A subset of data for the study of how brand attitudes were influenced by showing brands together with pleasant pictures</h2><span id='topic+condstudy_sub'></span>

<h3>Description</h3>

<p>This is a subset of the data 'condstudy' with 180 obs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(condstudy_sub)</code></pre>


<h3>Format</h3>

<p>This R object contains a between-subjects variable: type, which denotes a between-subject moderator. It has two levels, &quot;indirect&quot; and &quot;direct&quot;. In the &quot;indirect&quot; condition the brands were shown with the same images, in the indirect condition the brands were shown with different images; Within-subject variables: cond, a within-subject factor with 2 levels: &quot;pos&quot;, and &quot;xneu&quot;, which indicates whether each brand was shown with a neutral (xneu) or positive (pos) emotional image. pict,  a within-subject mediator variable measuring the valence (positive/negative) of the emotional image the respondent remembers the brand to have been shown with. att, a dependent variable which denotes the ratings of attitudes toward brands. 
</p>
<p>$ condstudy_sub: 'data.frame':  180 obs. of  5 variables:<br />
... $ id  : int  2 2 2 2 2 2 3 3 3 3 ... <br />
... $ att : num  2.94 2.44 3.44 1.67 1.67 ... <br />
... $ cond: Factor w/ 2 levels &quot;pos&quot;,&quot;xneu&quot;: 1 1 1 2 2 2 1 1 1 2 ... <br />
... $ type: Factor w/ 2 levels &quot;direct&quot;,&quot;indirect&quot;: 2 2 2 2 2 2 2 2 2 2 ... <br />
... $ pict: int  6 7 6 2 4 5 9 3 2 5 ... <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# condstudy_sub is a subset of condstudy with 180 obs. and the same variables
data(condstudy_sub)
library(rstan)
model &lt;- BANOVA.model('Normal')
stanmodel &lt;- BANOVA.build(model)
out2 &lt;- BANOVA.run(att~cond+pict, ~type, fit = stanmodel, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)    
conv.diag(out2)
summary(out2) 
table.predictions(out2)  
BANOVA.floodlight(out2, var_factor = 'type', var_numeric = 'pict')
cat(out2$model_code)

out3 &lt;- BANOVA.run(pict~cond, ~type, fit = stanmodel, data = condstudy_sub, 
                  id = 'id', iter = 500, thin = 1, chains = 2)
conv.diag(out3)
summary(out3)
BANOVA.mediation(out2, out3, xvar='cond', mediator='pict')

</code></pre>

<hr>
<h2 id='conv.diag'>Function to display the convergence diagnostics</h2><span id='topic+conv.diag'></span>

<h3>Description</h3>

<p>The Geweke diagnostic and the Heidelberg and Welch diagnostic are reported. These two convergence diagnostics are calculated based on only a single MCMC chain. Both diagnostics require a single chain and may be applied with any MCMC method. The functions <code><a href="coda.html#topic+geweke.diag">geweke.diag</a></code>, <code><a href="coda.html#topic+heidel.diag">heidel.diag</a></code> in <b>coda</b> package is used to compute this diagnostic. 
</p>
<p>Geweke's convergence diagnostic is calculated by taking the difference between the means from the first <code class="reqn">n_A</code> iterations and the last <code class="reqn">n_B</code> iterations. If the ratios <code class="reqn">n_A/n</code>  and <code class="reqn">n_B/n</code> are fixed and <code class="reqn">nA +nB &lt; n</code>, then by the central limit theorem, the distribution of this diagnostic approaches a standard normal as  <code class="reqn">n</code> tends to infinity. In our package, <code class="reqn">n_A= .2*n</code> and <code class="reqn">n_B= .5*n</code>. 
</p>
<p>The Heidelberg and Welch diagnostic is based on a test statistic to accept or reject the null hypothesis that the Markov chain is from a stationary distribution. The present package reports the stationary test.The convergence test uses the Cramer-von Mises statistic to test for stationary. The test is successively applied on the chain. If the null hypothesis is rejected, the first 10% of the iterations are discarded and the stationarity test repeated. If the stationary test fails again, an additional 10% of the iterations are discarded and the test repeated again. The process continues until 50% of the iterations have been discarded and the test still rejects. In our package, <code class="reqn">eps = 0.1, pvalue = 0.05</code> are used as parameters of the function <code><a href="coda.html#topic+heidel.diag">heidel.diag</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.diag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.diag_+3A_x">x</code></td>
<td>
<p>the object from BANOVA.*</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conv.diag</code> returns a list of two diagnostics:
</p>
<table>
<tr><td><code>sol_geweke</code></td>
<td>
<p>The Geweke diagnostic</p>
</td></tr>
<tr><td><code>sol_heidel</code></td>
<td>
<p>The Heidelberg and Welch diagnostic</p>
</td></tr>
</table>


<h3>References</h3>

<p>Plummer, M., Best, N., Cowles, K. and Vines K. (2006) <em>CODA: Convergence Diagnosis and Output Analysis for MCMC</em>, R News, Vol 6, pp. 7-11.
</p>
<p>Geweke, <em>J. Evaluating the accuracy of sampling-based approaches
to calculating posterior moments</em>, In <em>Bayesian Statistics 4</em>
(ed JM Bernado, JO Berger, AP Dawid and AFM Smith). Clarendon Press,
Oxford, UK.
</p>
<p>Heidelberger, P. and Welch, PD. (1981)
<em>A spectral method for confidence interval generation and run length control in simulations</em>, Comm. ACM. Vol. 24, No.4, pp. 233-245. 
</p>
<p>Heidelberger, P. and Welch, PD. (1983)
<em>Simulation run length control in the 
presence of an initial transient</em>, Opns Res., Vol.31, No.6, pp. 1109-44.
</p>
<p>Schruben, LW. (1982)
<em>Detecting initialization bias in simulation experiments</em>,
Opns. Res., Vol. 30, No.3, pp. 569-590.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

library(rstan)
res1 &lt;- BANOVA.run(bid~progress*prodvar, model_name = "Normal", data = goalstudy, 
id = 'id', iter = 100, thin = 1) 
conv.diag(res1)
# might need pairs() to confirm the convergence

</code></pre>

<hr>
<h2 id='goalstudy'>Data for the study of the impact of the variety among means on motivation to pursue a goal</h2><span id='topic+goalstudy'></span>

<h3>Description</h3>

<p>The study investigated how the perceived variety (high vs. low) among products, as means to a subjects' goal, affects their motivation to pursue that goal. The hypothesis was that only when progress toward a goal is low, product variety increases motivation to pursue the goal. In the study,  one hundred and five subjects were randomly assigned to conditions in a 2 (goal progress: low vs. high) by 2 (variety among means: low vs. high) between-subjects design. The final goal was a &quot;fitness goal&quot;, and the products used were protein bars; variety was manipulated by asking subjects to think about how the products were similar (low) or different (high); goal progress was primed by asking subjects questions regarding the frequency of their recent workouts on low (0,1,...,5 or more) versus high (5 or less, 6,7,..., 10) frequency scales. Subjects were asked questions regarding the similarity of protein bars, and the bid they were willing to make for the bars, used as dependent variables in the study. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(goalstudy)</code></pre>


<h3>Format</h3>

<p>This R object contains between-subjects variables: progress, which denotes the progress toward a goal (1:low , 2: high ); prodvar, which denotes the amount of variety within the means to goal attainment (1:low , 2:high); perceivedsim, which is a seven-point scale dependent variable measuring the perceived similarity of the set of products (1 = not at all similar, 7 = very similar); and bid which denotes the amount that subjects would be willing to pay for the products . 
</p>
<p>$ goalstudy: 'data.frame':  105 obs. of  5 variables:<br />
... $ id            : int  1 2 3 4 5 6 7 8 9 10 ...<br />
... $ perceivedsim  : int  5 7 2 2 5 5 5 4 5 7 ... <br />
... $ progress      : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 1 1 2 2 2 1 2 1 2 1 ... <br />
... $ prodvar      : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 2 1 2 1 1 1 1 2 1 1 ...<br />
... $ bid         : num  5 0 1 15 3 10 5 4.5 3 0.75 ...<br />
</p>


<h3>References</h3>

 
<p>Etkin, J. and Ratner, R. (2012) <em>The Dynamic Impact of Variety among Means on Motivation</em>. Journal of Consumer Research,  Vol. 38, No. 6, pp. 1076 - 1092.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(goalstudy)
library(rstan)

# single level model
res1 &lt;- BANOVA.run(bid~progress*prodvar, model_name = "Normal", 
data = goalstudy, id = 'id', iter = 1000, thin = 1, chains = 2) 
BAnova(res1)
table.pvalues(res1)
trace.plot(res1)
table.predictions(res1)
# pairs(res1, pars = c("beta1[1]", "tau_ySq"))


</code></pre>

<hr>
<h2 id='ipadstudy'>Data for the study of relation between Conspicuous, Brand Usage, Self-Brand Connection and attitudes toward the brand</h2><span id='topic+ipadstudy'></span>

<h3>Description</h3>

<p>The study is a between-subjects experiment which has factor (conspicuousness: low vs. high) and one measured variable (self-brand connection). The goal is to show that conspicuous brand use negatively affects attitudes toward the user and the brand only for observers low in self-brand connection. One hundred fifty-four participants were exposed to a video manipulating conspicuous brand usage. Participants completed the study by answering several questions which are used to measure the dependent (attitude) and independent (self-brand connection) variables in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ipadstudy)</code></pre>


<h3>Format</h3>

<p>This R object contains between-subjects variables: $owner is an indicator variable. If the subject owns iPad or iPhone, then owner = 1. It is equal to 0 otherwise. $age denotes the age of subjects. $gender denotes the gender of subjects. gender = 1 if the subject is a female, 0 otherwise. $conspic is an indicator variable related to conspicuousness. conspic = 1 if conspicuousness is high. $selfbrand denotes the self-brand connection for Apple. $id is the id of subjects. $attitude denotes the attitudes towards the brand which is the continuous dependent variable. $apple_dl is a seven-point scale variable which denotes the attitudes (dislike = 1,..., like = 7)
</p>
<p>$ ipadstudy: 'data.frame':  154 obs. of  9 variables:<br />
... $ id            : int  1 2 3 4 5 6 7 8 9 10 ...<br />
... $ attitude      : num  3 5.33 5.67 5.33 6 ...<br />
... $ owner         : num  0 0 0 1 1 0 1 0 1 0 ...<br />
... $ age           : int  19 33 25 41 38 33 37 46 41 55 ...<br />
... $ gender        : num  0 0 1 0 1 1 1 0 1 1 ...<br />
... $ conspic       : num  0 1 0 1 1 0 0 1 0 1 ...<br />
... $ selfbrand     : num  -2.304 1.696 -0.161 -0.447 0.267 ...<br />
... $ apple_dl      : int  3 6 6 5 6 4 7 7 5 5 ...<br />
</p>


<h3>References</h3>

 
<p>Ferraro,R., Kirmani, A. and Matherly, T., (2013) <em>Look at Me! Look at Me! Conspicuous Brand Usage, Self-Brand Connection, and Dilution</em>. Journal of Marketing Research, Vol. 50, No. 4, pp. 477-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ipadstudy)

# mean center covariates
ipadstudy$age &lt;- ipadstudy$age - mean(ipadstudy$age) 
ipadstudy$owner &lt;- ipadstudy$owner - mean(ipadstudy$owner )
ipadstudy$gender &lt;- ipadstudy$gender - mean(ipadstudy$gender)

res &lt;- BANOVA.Normal(attitude~1, ~owner + age + gender + selfbrand*conspic, 
ipadstudy, ipadstudy$id, burnin = 100, sample = 100, thin = 1 )
summary(res)
# use apple_dl as the dependent variable
res &lt;- BANOVA.ordMultinomial(apple_dl~1, ~owner + age + gender + selfbrand*conspic, 
ipadstudy, ipadstudy$id, burnin = 100, sample = 100, thin = 2 )
summary(res)
table.predictions(res)

</code></pre>

<hr>
<h2 id='pairs.BANOVA'>Create a matrix of output plots from a <code>BANOVA</code> object</h2><span id='topic+pairs.BANOVA'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+graphics">pairs</a></code> 
method that is customized for MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BANOVA'
pairs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.BANOVA_+3A_x">x</code></td>
<td>
<p>an object of class <code>"BANOVA"</code></p>
</td></tr>
<tr><td><code id="pairs.BANOVA_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to 
<code>pairs.stanfit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description see <code>pairs.stanfit</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rstan)
data(ipadstudy)
res_1 &lt;- BANOVA.run(attitude~owner + age + gender + selfbrand*conspic, 
model_name = 'Normal', data = ipadstudy, id = 'id', iter = 1000, 
thin = 1, chains = 2)
# pairs(res_1, pars = c("beta1[1]","beta1[2]"))

</code></pre>

<hr>
<h2 id='table.predictions'>Function to print the table of means</h2><span id='topic+table.predictions'></span>

<h3>Description</h3>

<p>Output of this function is a table of means for the categorical predictors (and their interactions) at either within- or between- subjects level. Statistics of interest such as credible intervals and standard deviations of the means are also computed. Means of numeric variables and their interactions will not be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.predictions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.predictions_+3A_x">x</code></td>
<td>
<p>the object from BANOVA.*</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

library(rstan)
# or use BANOVA.run based on 'Stan'
res &lt;- BANOVA.run(bid~progress*prodvar, model_name = "Normal", 
data = goalstudy, id = 'id', iter = 1000, thin = 1, chains = 2)
table.predictions(res)

</code></pre>

<hr>
<h2 id='table.pvalues'>Function to print the table of p-values</h2><span id='topic+table.pvalues'></span>

<h3>Description</h3>

<p>Computes the Baysian p-values for the test concerning all coefficients/parameters: <br />
</p>
<p>For <code class="reqn">p = 1,...,P</code> <br />
<code class="reqn">H_0:\theta_{j,k}^{p,q}=0</code> <br />
<code class="reqn">H_1:\theta_{j,k}^{p,q} \neq 0</code> <br />
</p>
<p>The two-sided P-value for the sample outcome is obtained by first finding the one sided P-value, <code class="reqn">min(P(\theta_{j,k}^{p,q}&lt;0),P(\theta_{j,k}^{p,q}&gt;0 ))</code> which can be estimated from posterior samples. For example, <code class="reqn">P(\theta_{j,k}^{p,q}&gt;0) = \frac{n_+}{n}</code>, where <code class="reqn">n_+</code> is the number of posterior samples that are greater than 0, <code class="reqn">n</code> is the target sample size. The two sided P-value is <code class="reqn">P_\theta(\theta_{j,k}^{p,q}) = 2*min(P(\theta_{j,k}^{p,q}&lt;0),P(\theta_{j,k}^{p,q}&gt;0 ))</code>.
</p>
<p>If there are <code class="reqn">\theta_{j,k_1}^{p,q},\theta_{j,k_2}^{p,q},...,\theta_{j,k_J}^{p,q}</code> representing J levels of a multi-level variable, we use a single P-value to represent the significance of all levels. The two alternatives are:
</p>
<p><code class="reqn">H_0:\theta_{j,k_1}^{p,q} = \theta_{j,k_2}^{p,q} = \cdots = \theta_{j,k_J}^{p,q}=0</code> <br />
<code class="reqn">H_1</code> : some <code class="reqn">\theta_{j,k_j}^{p,q} \neq 0</code>
</p>
<p>Let <code class="reqn">\theta_{j,k_{min}}^{p,q}</code> and <code class="reqn">\theta_{j,k_{max}}^{p,q}</code> denote the coefficients with the smallest and largest posterior mean. Then the overall P-value is defined as 
</p>
<p><code class="reqn">min(P_\theta (\theta_{j,k_{min}}^{p,q}), P_\theta(\theta_{j,k_{max}}^{p,q}))</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.pvalues(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.pvalues_+3A_x">x</code></td>
<td>
<p>the object from BANOVA.*</p>
</td></tr>
</table>


<h3>Source</h3>

<p>It borrows the idea of Sheffe F-test for multiple testing: the F-stat for testing the contrast with maximal difference from zero. Thank Dr. P. Lenk of the University of Michigan for this suggestion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

library(rstan)
# or use BANOVA.run
res1 &lt;- BANOVA.run(bid~progress*prodvar, model_name = "Normal", 
data = goalstudy, id = 'id', iter = 1000, thin = 1, chains = 2) 
table.pvalues(res1)

</code></pre>

<hr>
<h2 id='trace.plot'>Function to plot the trace of parameters</h2><span id='topic+trace.plot'></span>

<h3>Description</h3>

<p>Function to plot the trace of all coefficients/parameters. The plots can be saved as a pdf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.plot(x, save = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace.plot_+3A_x">x</code></td>
<td>
<p>the object from BANOVA.*</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_save">save</code></td>
<td>
<p>whether to save the trace plot as a pdf file, the default is FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(goalstudy)

library(rstan)
# or use BANOVA.run
res1 &lt;- BANOVA.run(bid~progress*prodvar, model_name = "Normal", 
data = goalstudy, id = 'id', iter = 1000, thin = 1, chains = 2)
trace.plot(res1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
