<!DOCTYPE html><html><head><title>Help for package geojsonio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geojsonio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geojsonio'><p><strong>I/O for GeoJSON</strong></p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#as.json'><p>Convert inputs to JSON</p></a></li>
<li><a href='#as.location'><p>Convert a path or URL to a location object.</p></a></li>
<li><a href='#bounds'><p>Get bounds for a list or geo_list</p></a></li>
<li><a href='#canada_cities'><p>This is the same data set from the maps library, named differently</p></a></li>
<li><a href='#centroid'><p>Get centroid for a geo_list</p></a></li>
<li><a href='#file_to_geojson'><p>Convert spatial data files to GeoJSON from various formats.</p></a></li>
<li><a href='#geo2topo'><p>GeoJSON to TopoJSON and back</p></a></li>
<li><a href='#geojson_atomize'><p>Atomize</p></a></li>
<li><a href='#geojson_json'><p>Convert many input types with spatial data to geojson specified as a json</p>
string</a></li>
<li><a href='#geojson_list'><p>Convert many input types with spatial data to geojson specified as a list</p></a></li>
<li><a href='#geojson_read'><p>Read geojson or other formats from a local file or a URL</p></a></li>
<li><a href='#geojson_sf'><p>Convert objects to an sf class</p></a></li>
<li><a href='#geojson_sp'><p>Convert objects to spatial classes</p></a></li>
<li><a href='#geojson_style'><p>Style a data.frame or list prior to converting to geojson</p></a></li>
<li><a href='#geojson_write'><p>Convert many input types with spatial data to a geojson file</p></a></li>
<li><a href='#geojson-add'><p>Add together geo_list or json objects</p></a></li>
<li><a href='#map_gist'><p>Publish an interactive map as a GitHub gist</p></a></li>
<li><a href='#map_leaf'><p>Make an interactive map locally</p></a></li>
<li><a href='#postgis'><p>PostGIS setup</p></a></li>
<li><a href='#pretty'><p>Convert json input to pretty printed output</p></a></li>
<li><a href='#projections'><p>topojson projections and extensions</p></a></li>
<li><a href='#states'><p>This is the same data set from the ggplot2 library</p></a></li>
<li><a href='#topojson_json'><p>Convert many input types with spatial data to TopoJSON</p>
as a JSON string</a></li>
<li><a href='#topojson_list'><p>Convert many input types with spatial data to TopoJSON</p>
as a list</a></li>
<li><a href='#topojson_read'><p>Read topojson from a local file or a URL</p></a></li>
<li><a href='#topojson_write'><p>Write TopoJSON from various inputs</p></a></li>
<li><a href='#us_cities'><p>This is the same data set from the maps library, named differently</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Convert Data from and to 'GeoJSON' or 'TopoJSON'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Convert data to 'GeoJSON' or 'TopoJSON' from various R
    classes, including vectors, lists, data frames, shape files, and
    spatial classes.  'geojsonio' does not aim to replace packages like
    'sp', 'rgdal', 'rgeos', but rather aims to be a high level client to
    simplify conversions of data from and to 'GeoJSON' and 'TopoJSON'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/geojsonio">https://github.com/ropensci/geojsonio</a>,
<a href="https://docs.ropensci.org/geojsonio/">https://docs.ropensci.org/geojsonio/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/geojsonio/issues">https://github.com/ropensci/geojsonio/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>crul, geojson (&ge; 0.2.0), geojsonsf, jqr, jsonlite (&ge;
0.9.21), magrittr, methods, readr (&ge; 0.2.2), sf (&ge; 0.6), sp,
V8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, DBI, gistr, leaflet, maps, RPostgres, testthat (&ge;
3.0.0), withr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>RColorBrewer</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Geospatial</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>geojson, topojson, geospatial, conversion, data,
input-output</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 17:07:47 UTC; mikemahoney218</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain [aut],
  Andy Teucher [aut],
  Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahoney &lt;mike.mahoney.218@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 17:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='geojsonio'><strong>I/O for GeoJSON</strong></h2><span id='topic+geojsonio'></span><span id='topic+geojsonio-package'></span>

<h3>Description</h3>

<p>Convert various data formats to/from GeoJSON or TopoJSON. This
package focuses mostly on converting lists, data.frame's, numeric,
SpatialPolygons, SpatialPolygonsDataFrame, and more to GeoJSON with the
help of <span class="pkg">sf</span>. You can currently read TopoJSON - writing
TopoJSON will come in a future version of this package.
</p>


<h3>Package organization</h3>

<p>The core functions in this package are organized first around what you're
working with or want to get, GeoJSON or TopoJSON, then convert to or read
from various formats:
</p>

<ul>
<li> <p><code><a href="#topic+geojson_list">geojson_list()</a></code> / <code><a href="#topic+topojson_list">topojson_list()</a></code> - convert
to GeoJSON or TopoJSON as R list format
</p>
</li>
<li> <p><code><a href="#topic+geojson_json">geojson_json()</a></code> / <code><a href="#topic+topojson_json">topojson_json()</a></code> - convert
to GeoJSON or TopoJSON as JSON
</p>
</li>
<li> <p><code><a href="#topic+geojson_sp">geojson_sp()</a></code> - convert to a spatial object from
<code>geojson_list</code> or <code>geojson_json</code>
</p>
</li>
<li> <p><code><a href="#topic+geojson_sf">geojson_sf()</a></code> - convert to an sf object from
<code>geojson_list</code> or <code>geojson_json</code>
</p>
</li>
<li> <p><code><a href="#topic+geojson_read">geojson_read()</a></code> / <code><a href="#topic+topojson_read">topojson_read()</a></code> - read a
GeoJSON/TopoJSON file from file path or URL
</p>
</li>
<li> <p><code><a href="#topic+geojson_write">geojson_write()</a></code> / <code><a href="#topic+topojson_write">topojson_write()</a></code> - write
a GeoJSON file locally (TopoJSON coming later)
</p>
</li></ul>

<p>Other interesting functions:
</p>

<ul>
<li> <p><code><a href="#topic+map_gist">map_gist()</a></code> - Create a GitHub gist (renders as an
interactive map)
</p>
</li>
<li> <p><code><a href="#topic+map_leaf">map_leaf()</a></code> - Create a local interactive map using the
<code>leaflet</code> package
</p>
</li>
<li> <p><code><a href="#topic+geo2topo">geo2topo()</a></code> - Convert GeoJSON to TopoJSON
</p>
</li>
<li> <p><code><a href="#topic+topo2geo">topo2geo()</a></code> - Convert TopoJSON to GeoJSON
</p>
</li></ul>

<p>All of the above functions have methods for various classes, including
<code>numeric</code> vectors, <code>data.frame</code>, <code>list</code>, <code>SpatialPolygons</code>, <code>SpatialLines</code>,
<code>SpatialPoints</code>, and many more - which will try to do the right thing
based on the data you give as input.
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>
<p>Andy Teucher <a href="mailto:andy.teucher@gmail.com">andy.teucher@gmail.com</a>
</p>
<p>Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/geojsonio">https://github.com/ropensci/geojsonio</a>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/geojsonio/">https://docs.ropensci.org/geojsonio/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/geojsonio/issues">https://github.com/ropensci/geojsonio/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='as.json'>Convert inputs to JSON</h2><span id='topic+as.json'></span>

<h3>Description</h3>

<p>Convert inputs to JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.json(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.json_+3A_x">x</code></td>
<td>
<p>Input</p>
</td></tr>
<tr><td><code id="as.json_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>when the output of <code><a href="#topic+topojson_list">topojson_list()</a></code> is given to
this function we use a special internal fxn <code>astjl()</code> to
parse the object - see that fxn and let us know if any
problems you run in to
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(res &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long"))
as.json(res)
as.json(res, pretty = TRUE)

vec &lt;- c(-99.74, 32.45)
as.json(geojson_list(vec))
as.json(geojson_list(vec), pretty = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.location'>Convert a path or URL to a location object.</h2><span id='topic+as.location'></span>

<h3>Description</h3>

<p>Convert a path or URL to a location object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.location(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.location_+3A_x">x</code></td>
<td>
<p>Input.</p>
</td></tr>
<tr><td><code id="as.location_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A file
file &lt;- system.file("examples", "zillow_or.geojson", package = "geojsonio")
as.location(file)

# A URL
url &lt;- "https://raw.githubusercontent.com/glynnbird/usstatesgeojson/master/california.geojson"
as.location(url)

## End(Not run)
</code></pre>

<hr>
<h2 id='bounds'>Get bounds for a list or geo_list</h2><span id='topic+bounds'></span>

<h3>Description</h3>

<p>Get bounds for a list or geo_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_x">x</code></td>
<td>
<p>An object of class list or geo_list</p>
</td></tr>
<tr><td><code id="bounds_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the form min longitude, min latitude, max longitude,
max latitude
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numeric
vec &lt;- c(-99.74, 32.45)
x &lt;- geojson_list(vec)
bounds(x)

# list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
x &lt;- geojson_list(mylist)
bounds(x)

# data.frame
x &lt;- geojson_list(states[1:20, ])
bounds(x)
</code></pre>

<hr>
<h2 id='canada_cities'>This is the same data set from the maps library, named differently</h2><span id='topic+canada_cities'></span>

<h3>Description</h3>

<p>This database is of Canadian cities of population greater than about 1,000.
Also included are province capitals of any population size.
</p>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;name&quot;, &quot;country.etc&quot;, &quot;pop&quot;,
&quot;lat&quot;, &quot;long&quot;, and &quot;capital&quot;, containing the city name, the province
abbreviation, approximate population (as at January 2006), latitude,
longitude and capital status indication (0 for non-capital, 1 for capital,
2 for provincial
</p>

<hr>
<h2 id='centroid'>Get centroid for a geo_list</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p>Get centroid for a geo_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_x">x</code></td>
<td>
<p>An object of class geo_list</p>
</td></tr>
<tr><td><code id="centroid_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the form longitude, latitude
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numeric
vec &lt;- c(-99.74, 32.45)
x &lt;- geojson_list(vec)
centroid(x)

# list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
x &lt;- geojson_list(mylist)
centroid(x)

# data.frame
x &lt;- geojson_list(states[1:20, ])
centroid(x)
</code></pre>

<hr>
<h2 id='file_to_geojson'>Convert spatial data files to GeoJSON from various formats.</h2><span id='topic+file_to_geojson'></span>

<h3>Description</h3>

<p>You can use a web interface called Ogre, or do conversions locally using the
sf package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_to_geojson(
  input,
  method = "web",
  output = ".",
  parse = FALSE,
  encoding = "CP1250",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_to_geojson_+3A_input">input</code></td>
<td>
<p>The file being uploaded, path to the file on your machine.</p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_method">method</code></td>
<td>
<p>(character) One of &quot;web&quot; (default) or &quot;local&quot;. Matches on
partial strings. This parameter determines how the data is
read. &quot;web&quot; means we use the Ogre web service, and &quot;local&quot; means we use
<span class="pkg">sf</span>. See Details fore more.</p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_output">output</code></td>
<td>
<p>Destination for output geojson file. Defaults to current
working directory, and gives a random alphanumeric file name</p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_parse">parse</code></td>
<td>
<p>(logical) To parse geojson to data.frame like structures if
possible. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_encoding">encoding</code></td>
<td>
<p>(character) The encoding passed to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>.
Default: CP1250</p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Printing of <code><a href="sf.html#topic+st_read">sf::st_read()</a></code> progress.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="file_to_geojson_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="sf.html#topic+st_read">st_read</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>path for the geojson file
</p>


<h3>Method parameter</h3>

<p>The web option uses the Ogre web API. Ogre currently has an output size
limit of 15MB. See here <a href="http://ogre.adc4gis.com/">http://ogre.adc4gis.com/</a> for info on the
Ogre web API. The local option uses the function <code><a href="sf.html#topic+st_write">st_write</a></code>
from the package rgdal.
</p>


<h3>Ogre</h3>

<p>Note that for Shapefiles, GML, MapInfo, and VRT, you need to send zip files
to Ogre. For other file types (.bna, .csv, .dgn, .dxf, .gxt, .txt, .json,
.geojson, .rss, .georss, .xml, .gmt, .kml, .kmz) you send the actual file
with that file extension.
</p>


<h3>Linting GeoJSON</h3>

<p>If you're having trouble rendering GeoJSON files, ensure you have a valid
GeoJSON file by running it through the package <span class="pkg">geojsonlint</span>, which
has a variety of different GeoJSON linters.
</p>


<h3>File size</h3>

<p>When using <code>method="web"</code>, be aware of file sizes.
https://ogre.adc4gis.com that we use for this option does not document
what file size is too large, but you should get an error message like
&quot;maximum file length exceeded&quot; when that happens. <code>method="local"</code>
shouldn't be sensitive to file sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;- system.file("examples", "norway_maple.kml", package = "geojsonio")

# KML type file - using the web method
file_to_geojson(input = file, method = "web", output = "kml_web")
## read into memory
file_to_geojson(input = file, method = "web", output = ":memory:")
file_to_geojson(input = file, method = "local", output = ":memory:")

# KML type file - using the local method
file_to_geojson(input = file, method = "local", output = "kml_local")

# Shp type file - using the web method - input is a zipped shp bundle
file &lt;- system.file("examples", "bison.zip", package = "geojsonio")
file_to_geojson(file, method = "web", output = "shp_web")

# Shp type file - using the local method - input is the actual .shp file
file &lt;- system.file("examples", "bison.zip", package = "geojsonio")
dir &lt;- tempdir()
unzip(file, exdir = dir)
list.files(dir)
shpfile &lt;- file.path(dir, "bison-Bison_bison-20130704-120856.shp")
file_to_geojson(shpfile, method = "local", output = "shp_local")

# geojson with .json extension
## this doesn't work anymore, hmmm
# x &lt;- gsub("\n", "", paste0('https://gist.githubusercontent.com/hunterowens/
# 25ea24e198c80c9fbcc7/raw/7fd3efda9009f902b5a991a506cea52db19ba143/
# wards2014.json', collapse = ""))
# res &lt;- file_to_geojson(x)
# jsonlite::fromJSON(res)
# res &lt;- file_to_geojson(x, method = "local")
# jsonlite::fromJSON(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='geo2topo'>GeoJSON to TopoJSON and back</h2><span id='topic+geo2topo'></span><span id='topic+topo2geo'></span>

<h3>Description</h3>

<p>GeoJSON to TopoJSON and back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo2topo(x, object_name = "foo", quantization = 0, ...)

topo2geo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo2topo_+3A_x">x</code></td>
<td>
<p>GeoJSON or TopoJSON as a character string, json, a file path, or
url</p>
</td></tr>
<tr><td><code id="geo2topo_+3A_object_name">object_name</code></td>
<td>
<p>(character) name to give to the TopoJSON object created.
Default: &quot;foo&quot;</p>
</td></tr>
<tr><td><code id="geo2topo_+3A_quantization">quantization</code></td>
<td>
<p>(numeric) quantization parameter, use this to
quantize geometry prior to computing topology. Typical values are powers of
ten (<code>1e4</code>, <code>1e5</code>, ...), default is <code>0</code> to not perform quantization.
For more information about quantization, see this by Mike Bostock
https://stackoverflow.com/questions/18900022/topojson-quantization-vs-simplification/18921214#18921214</p>
</td></tr>
<tr><td><code id="geo2topo_+3A_...">...</code></td>
<td>
<p>for <code>geo2topo</code> args passed  on to
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>, and for <code>topo2geo</code> args passed  on to
<code><a href="sf.html#topic+st_read">sf::st_read()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>json</code>, of either GeoJSON or TopoJSON
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topojson_write">topojson_write()</a></code>, <code><a href="#topic+topojson_read">topojson_read()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># geojson to topojson
x &lt;- '{"type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
z &lt;- geo2topo(x)
jsonlite::prettify(z)
## Not run: 
library(leaflet)
leaflet() %&gt;%
  addProviderTiles(provider = "Stamen.Terrain") %&gt;%
  addTopoJSON(z)

## End(Not run)

# geojson to topojson as a list
x &lt;- list(
  '{"type": "LineString", "coordinates": [ [100, 0], [101, 1] ]}',
  '{"type": "LineString", "coordinates": [ [110, 0], [110, 1] ]}',
  '{"type": "LineString", "coordinates": [ [120, 0], [121, 1] ]}'
)
geo2topo(x)

# change the object name created
x &lt;- '{"type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
geo2topo(x, object_name = "HelloWorld")
geo2topo(x, object_name = "4")

x &lt;- list(
  '{"type": "LineString", "coordinates": [ [100, 0], [101, 1] ]}',
  '{"type": "LineString", "coordinates": [ [110, 0], [110, 1] ]}',
  '{"type": "LineString", "coordinates": [ [120, 0], [121, 1] ]}'
)
geo2topo(x, "HelloWorld")
geo2topo(x, c("A", "B", "C"))


# topojson to geojson
w &lt;- topo2geo(z)
jsonlite::prettify(w)

## larger examples
file &lt;- system.file("examples", "us_states.topojson", package = "geojsonio")
topo2geo(file)
</code></pre>

<hr>
<h2 id='geojson_atomize'>Atomize</h2><span id='topic+geojson_atomize'></span>

<h3>Description</h3>

<p>Atomize
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_atomize(x, combine = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_atomize_+3A_x">x</code></td>
<td>
<p>(geo_list/geo_json/json/character) input object, either
<code>geo_json</code>, <code>geo_list</code>, <code>json</code>, or <code>character</code> class.
If <code>character</code>, must be valid JSON</p>
</td></tr>
<tr><td><code id="geojson_atomize_+3A_combine">combine</code></td>
<td>
<p>(logical) only applies to <code>geo_json/json</code> type inputs.
combine valid JSON objects into a single valid JSON object. Default:
<code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A FeatureCollection is split into many Feature's, and
a GeometryCollection is split into many geometries
</p>
<p>Internally we use <span class="pkg">jqr</span> for JSON parsing
</p>


<h3>Value</h3>

<p>same class as input object, but modified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# lists
# featurecollection -&gt; features
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
(x &lt;- geojson_list(mylist))
geojson_atomize(x)

# geometrycollection -&gt; geometries
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
(x &lt;- geojson_list(mylist, type = "GeometryCollection"))
geojson_atomize(x)

# sf class
library(sf)
p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
poly &lt;- rbind(c(1, 1), c(1, 2), c(2, 2), c(1, 1))
poly_sfg &lt;- st_polygon(list(p1))
(x &lt;- geojson_list(poly_sfg))
geojson_atomize(x)

################# json
# featurecollection -&gt; features
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
(x &lt;- geojson_json(mylist))
geojson_atomize(x)
geojson_atomize(x, FALSE)

# geometrycollection -&gt; geometries
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
(x &lt;- geojson_json(mylist, type = "GeometryCollection"))
geojson_atomize(x)
geojson_atomize(x, FALSE)

# sf class
library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
(x &lt;- geojson_json(nc))
geojson_atomize(x)
geojson_atomize(x, FALSE)

################# character
# featurecollection -&gt; features
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
(x &lt;- geojson_json(mylist))
geojson_atomize(unclass(x))
</code></pre>

<hr>
<h2 id='geojson_json'>Convert many input types with spatial data to geojson specified as a json
string</h2><span id='topic+geojson_json'></span>

<h3>Description</h3>

<p>Convert many input types with spatial data to geojson specified as a json
string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_json(
  input,
  lat = NULL,
  lon = NULL,
  group = NULL,
  geometry = "point",
  type = "FeatureCollection",
  convert_wgs84 = FALSE,
  crs = NULL,
  precision = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_json_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class. Inputs can
also be dplyr <code>tbl_df</code> class since it inherits from <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_type">type</code></td>
<td>
<p>(character) The type of collection. One of 'auto' (default
for 'sf' objects), 'FeatureCollection' (default for everything else), or
'GeometryCollection'. &quot;skip&quot; skips the coercion with package <span class="pkg">geojson</span>
functions; skipping can save significant run time on larger geojson
objects. <code>Spatial</code> objects can only accept &quot;FeatureCollection&quot; or &quot;skip&quot;.
&quot;skip&quot; is not available as an option for <code>numeric</code>, <code>list</code>,
and <code>data.frame</code> classes</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS system for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference system, using
the WGS84 datum, with longitude and latitude units of decimal degrees;
EPSG: 4326). Default is <code>FALSE</code> though this may change in a future
package version. This will only work for <code>sf</code> or <code>Spatial</code>
objects with a CRS already defined. If one is not defined but you know
what it is, you may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can be
an epsg code as a four or five digit integer or a valid proj4 string.
This argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code> or
the object already has a CRS.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_precision">precision</code></td>
<td>
<p>(integer) desired number of decimal places for coordinates.
Using fewer decimal places decreases object sizes (at the
cost of precision). This changes the underlying precision stored in the
data. <code style="white-space: pre;">&#8288;options(digits = &lt;some number&gt;)&#8288;</code> changes the maximum number of
digits displayed (to find out what yours is set at see
<code>getOption("digits")</code>); the value of this parameter will change what's
displayed in your console up to the value of <code>getOption("digits")</code>.
See Precision section for more.</p>
</td></tr>
<tr><td><code id="geojson_json_+3A_...">...</code></td>
<td>
<p>Further args passed on to internal functions. For Spatial*
classes, it is passed through to
<code><a href="sf.html#topic+st_write">sf::st_write()</a></code>. For sf classes, data.frames, lists, numerics,
and geo_lists, it is passed through to <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a geojson structure as a json character
string; it does not write a file - see <code><a href="#topic+geojson_write">geojson_write()</a></code> for that
</p>
<p>Note that all sp class objects will output as <code>FeatureCollection</code>
objects, while other classes (numeric, list, data.frame) can be output as
<code>FeatureCollection</code> or <code>GeometryCollection</code> objects. We're working
on allowing <code>GeometryCollection</code> option for sp class objects.
</p>
<p>Also note that with sp classes we do make a round-trip, using
<code><a href="sf.html#topic+st_write">sf::st_write()</a></code> to write GeoJSON to disk, then read it back
in. This is fast and we don't have to think about it too much, but this
disk round-trip is not ideal.
</p>
<p>For sf classes (sf, sfc, sfg), the following conversions are made:
</p>

<ul>
<li><p> sfg: the appropriate geometry <code style="white-space: pre;">&#8288;Point, LineString, Polygon,  MultiPoint, MultiLineString, MultiPolygon, GeometryCollection&#8288;</code>
</p>
</li>
<li><p> sfc: <code>GeometryCollection</code>, unless the sfc is length 1, then
the geometry as above
</p>
</li>
<li><p> sf: <code>FeatureCollection</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>geo_json</code> (and <code>json</code>)
</p>


<h3>Precision</h3>

<p>Precision is handled in different ways depending on the class.
</p>
<p>The <code>digits</code> parameter of <code>jsonlite::toJSON</code> controls precision for classes
<code>numeric</code>, <code>list</code>, <code>data.frame</code>, and <code>geo_list</code>.
</p>
<p>For <code>sp</code> classes, precision is controlled by <code>sf::st_write</code>, being passed
down through <code><a href="#topic+geojson_write">geojson_write()</a></code>, then through internal function
<code>write_geojson()</code>, then another internal function <code>write_ogr_sf()</code>
</p>
<p>For <code>sf</code> classes, precision isn't quite working yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a numeric vector of length 2, making a point type
geojson_json(c(-99.74134244, 32.451323223))
geojson_json(c(-99.74134244, 32.451323223))[[1]]
geojson_json(c(-99.74134244, 32.451323223), precision = 2)[[1]]
geojson_json(c(-99.74, 32.45), type = "GeometryCollection")

## polygon type
### this requires numeric class input, so inputting a list will dispatch
### on the list method
poly &lt;- c(
  c(-114.345703125, 39.436192999314095),
  c(-114.345703125, 43.45291889355468),
  c(-106.61132812499999, 43.45291889355468),
  c(-106.61132812499999, 39.436192999314095),
  c(-114.345703125, 39.436192999314095)
)
geojson_json(poly, geometry = "polygon")

# Lists
## From a list of numeric vectors to a polygon
vecs &lt;- list(
  c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0),
  c(100.0, 0.0)
)
geojson_json(vecs, geometry = "polygon")

## from a named list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
geojson_json(mylist, lat = "latitude", lon = "longitude")

# From a data.frame to points
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long")
geojson_json(us_cities[1:2, ],
  lat = "lat", lon = "long",
  type = "GeometryCollection"
)

# from data.frame to polygons
head(states)
## make list for input to e.g., rMaps
geojson_json(states[1:351, ],
  lat = "lat", lon = "long", geometry = "polygon",
  group = "group"
)

# from a geo_list
a &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long")
geojson_json(a)

# sp classes

## From SpatialPolygons class
library("sp")
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
geojson_json(sp_poly)

## data.frame to geojson
geojson_write(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;% as.json()

# From SpatialPoints class
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(3, 2, 5, 1, 4)
s &lt;- SpatialPoints(cbind(x, y))
geojson_json(s)

## From SpatialPointsDataFrame class
s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
geojson_json(s)

## From SpatialLines class
library("sp")
c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
L1 &lt;- Line(c1)
L2 &lt;- Line(c2)
L3 &lt;- Line(c3)
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
geojson_json(sl1)
geojson_json(sl12)

## From SpatialLinesDataFrame class
dat &lt;- data.frame(
  X = c("Blue", "Green"),
  Y = c("Train", "Plane"),
  Z = c("Road", "River"), row.names = c("a", "b")
)
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
geojson_json(sldf)
geojson_json(sldf)

## From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
geojson_json(y)

## From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
geojson_json(sgdf)

# From SpatialPixels
library("sp")
pixels &lt;- suppressWarnings(
  SpatialPixels(SpatialPoints(us_cities[c("long", "lat")]))
)
summary(pixels)
geojson_json(pixels)

# From SpatialPixelsDataFrame
library("sp")
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(
    points = canada_cities[c("long", "lat")],
    data = canada_cities
  )
)
geojson_json(pixelsdf)

# From sf classes:
if (require(sf)) {
  ## sfg (a single simple features geometry)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  poly &lt;- rbind(c(1, 1), c(1, 2), c(2, 2), c(1, 1))
  poly_sfg &lt;- st_polygon(list(p1))
  geojson_json(poly_sfg)

  ## sfc (a collection of geometries)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  geojson_json(poly_sfc)

  ## sf (collection of geometries with attributes)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  poly_sf &lt;- st_sf(foo = c("a", "b"), bar = 1:2, poly_sfc)
  geojson_json(poly_sf)
}

## Pretty print a json string
geojson_json(c(-99.74, 32.45))
geojson_json(c(-99.74, 32.45)) %&gt;% pretty()

# skipping the pretty geojson class coercion with the geojson pkg
if (require(sf)) {
  library(sf)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  geojson_json(poly_sfc)
  geojson_json(poly_sfc, type = "skip")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson_list'>Convert many input types with spatial data to geojson specified as a list</h2><span id='topic+geojson_list'></span>

<h3>Description</h3>

<p>Convert many input types with spatial data to geojson specified as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_list(
  input,
  lat = NULL,
  lon = NULL,
  group = NULL,
  geometry = "point",
  type = "FeatureCollection",
  convert_wgs84 = FALSE,
  crs = NULL,
  precision = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_list_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class. Inputs can
also be dplyr <code>tbl_df</code> class since it inherits from <code>data.frame</code></p>
</td></tr>
<tr><td><code id="geojson_list_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_type">type</code></td>
<td>
<p>(character) The type of collection. One of FeatureCollection
(default) or GeometryCollection.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference system, using the WGS84 datum, with
longitude and latitude units of decimal degrees; EPSG: 4326).
Default is <code>FALSE</code> though this may change in a future package version.
This will only work for <code>sf</code> or <code>Spatial</code> objects with a CRS
already defined. If one is not defined but you know what it is, you
may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can
be an epsg code as a four or five digit integer or a valid proj4 string.
This argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code>
or the object already has a CRS.</p>
</td></tr>
<tr><td><code id="geojson_list_+3A_precision">precision</code></td>
<td>
<p>(integer) desired number of decimal places for coordinates.
Only used with classes from <span class="pkg">sp</span> classes; ignored for other
classes. Using fewer decimal places decreases object sizes (at the
cost of precision). This changes the underlying precision stored in the
data. <code style="white-space: pre;">&#8288;options(digits = &lt;some number&gt;)&#8288;</code> changes the maximum number of
digits displayed (to find out what yours is set at see
<code>getOption("digits")</code>); the value of this parameter will change what's
displayed in your console up to the value of <code>getOption("digits")</code></p>
</td></tr>
<tr><td><code id="geojson_list_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a geojson structure as an R list; it does
not write a file - see <code><a href="#topic+geojson_write">geojson_write()</a></code> for that.
</p>
<p>Note that all sp class objects will output as <code>FeatureCollection</code> objects,
while other classes (numeric, list, data.frame) can be output as
<code>FeatureCollection</code> or <code>GeometryCollection</code> objects. We're working
on allowing <code>GeometryCollection</code> option for sp class objects.
</p>
<p>Also note that with sp classes we do make a round-trip,
using <code><a href="sf.html#topic+st_write">sf::st_write()</a></code> to write GeoJSON to disk, then read it back in.
This is fast and we don't have to think
about it too much, but this disk round-trip is not ideal.
</p>
<p>For sf classes (sf, sfc, sfg), the following conversions are made:
</p>

<ul>
<li><p> sfg: the appropriate geometry <code style="white-space: pre;">&#8288;Point, LineString, Polygon, MultiPoint,  MultiLineString, MultiPolygon, GeometryCollection&#8288;</code>
</p>
</li>
<li><p> sfc: <code>GeometryCollection</code>, unless the sfc is length 1, then the geometry
as above
</p>
</li>
<li><p> sf: <code>FeatureCollection</code>
</p>
</li></ul>

<p>For <code>list</code> and <code>data.frame</code> objects, you don't have to pass in <code>lat</code> and
<code>lon</code> parameters if they are named appropriately (e.g., lat/latitude,
lon/long/longitude), as they will be auto-detected. If they can not be
found, the function will stop and warn you to specify the parameters
specifically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a numeric vector of length 2 to a point
vec &lt;- c(-99.74, 32.45)
geojson_list(vec)

# Lists
## From a list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
geojson_list(mylist)

## From a list of numeric vectors to a polygon
vecs &lt;- list(
  c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0),
  c(100.0, 1.0), c(100.0, 0.0)
)
geojson_list(vecs, geometry = "polygon")

# from data.frame to points
(res &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long"))
as.json(res)
## guess lat/long columns
geojson_list(us_cities[1:2, ])
geojson_list(states[1:3, ])
geojson_list(states[1:351, ], geometry = "polygon", group = "group")
geojson_list(canada_cities[1:30, ])
## a data.frame with columsn not named appropriately, but you can
## specify them
# dat &lt;- data.frame(a = c(31, 41), b = c(-120, -110))
# geojson_list(dat)
# geojson_list(dat, lat="a", lon="b")

# from data.frame to polygons
head(states)
geojson_list(states[1:351, ],
  lat = "lat", lon = "long",
  geometry = "polygon", group = "group"
)

# From SpatialPolygons class
library("sp")
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
geojson_list(sp_poly)

# From SpatialPolygons class with precision agreement
x_coord &lt;- c(
  -114.345703125, -114.345703125, -106.61132812499999,
  -106.61132812499999, -114.345703125
)
y_coord &lt;- c(
  39.436192999314095, 43.45291889355468, 43.45291889355468,
  39.436192999314095, 39.436192999314095
)
coords &lt;- cbind(x_coord, y_coord)
poly &lt;- Polygon(coords)
polys &lt;- Polygons(list(poly), 1)
sp_poly2 &lt;- SpatialPolygons(list(polys))
geojson_list(sp_poly2, geometry = "polygon", precision = 4)
geojson_list(sp_poly2, geometry = "polygon", precision = 3)
geojson_list(sp_poly2, geometry = "polygon", precision = 2)

# From SpatialPoints class with precision
points &lt;- SpatialPoints(cbind(x_coord, y_coord))
geojson_list(points)

# From SpatialPolygonsDataFrame class
sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
geojson_list(input = sp_polydf)

# From SpatialPoints class
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(3, 2, 5, 1, 4)
s &lt;- SpatialPoints(cbind(x, y))
geojson_list(s)

# From SpatialPointsDataFrame class
s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
geojson_list(s)

# From SpatialLines class
library("sp")
c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
L1 &lt;- Line(c1)
L2 &lt;- Line(c2)
L3 &lt;- Line(c3)
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
geojson_list(sl1)
geojson_list(sl12)
as.json(geojson_list(sl12))
as.json(geojson_list(sl12), pretty = TRUE)

# From SpatialLinesDataFrame class
dat &lt;- data.frame(
  X = c("Blue", "Green"),
  Y = c("Train", "Plane"),
  Z = c("Road", "River"), row.names = c("a", "b")
)
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
geojson_list(sldf)
as.json(geojson_list(sldf))
as.json(geojson_list(sldf), pretty = TRUE)

# From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
geojson_list(y)

# From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
geojson_list(sgdf)

# From SpatialPixels
library("sp")
pixels &lt;- suppressWarnings(
  SpatialPixels(SpatialPoints(us_cities[c("long", "lat")]))
)
summary(pixels)
geojson_list(pixels)

# From SpatialPixelsDataFrame
library("sp")
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(
    points = canada_cities[c("long", "lat")],
    data = canada_cities
  )
)
geojson_list(pixelsdf)

# From sf classes:
if (require(sf)) {
  ## sfg (a single simple features geometry)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  poly &lt;- rbind(c(1, 1), c(1, 2), c(2, 2), c(1, 1))
  poly_sfg &lt;- st_polygon(list(p1))
  geojson_list(poly_sfg)

  ## sfc (a collection of geometries)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  geojson_list(poly_sfc)

  ## sf (collection of geometries with attributes)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  poly_sf &lt;- st_sf(foo = c("a", "b"), bar = 1:2, poly_sfc)
  geojson_list(poly_sf)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='geojson_read'>Read geojson or other formats from a local file or a URL</h2><span id='topic+geojson_read'></span>

<h3>Description</h3>

<p>Read geojson or other formats from a local file or a URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_read(
  x,
  parse = FALSE,
  what = "list",
  stringsAsFactors = FALSE,
  query = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_read_+3A_x">x</code></td>
<td>
<p>(character) Path to a local file or a URL.</p>
</td></tr>
<tr><td><code id="geojson_read_+3A_parse">parse</code></td>
<td>
<p>(logical) To parse geojson to data.frame like structures if
possible. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="geojson_read_+3A_what">what</code></td>
<td>
<p>(character) What to return. One of &quot;list&quot;, &quot;sp&quot; (for
Spatial class), or &quot;json&quot;. Default: &quot;list&quot;. &quot;list&quot; &quot;and&quot; sp run through
package <span class="pkg">sf</span>. if &quot;json&quot;, returns json as character class</p>
</td></tr>
<tr><td><code id="geojson_read_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert strings to Factors? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geojson_read_+3A_query">query</code></td>
<td>
<p>(character) A SQL query, see also <a href="#topic+postgis">postgis</a></p>
</td></tr>
<tr><td><code id="geojson_read_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supports various geospatial file formats from a URL,
as well as local kml, shp, and geojson file formats.
</p>


<h3>Value</h3>

<p>various, depending on what's chosen in <code>what</code> parameter
</p>

<ul>
<li><p> list: geojson as a list using <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>
</p>
</li>
<li><p> sp: geojson as an sp class object using <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>
</p>
</li>
<li><p> json: geojson as character string, to parse downstream as you wish
</p>
</li></ul>



<h3>File size</h3>

<p>We previously used <code><a href="#topic+file_to_geojson">file_to_geojson()</a></code> in this function, leading to
file size problems; this should no longer be a concern, but let us know
if you run into file size problems
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topojson_read">topojson_read()</a></code>, <code><a href="#topic+geojson_write">geojson_write()</a></code> <a href="#topic+postgis">postgis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a file
file &lt;- system.file("examples", "california.geojson", package = "geojsonio")
(out &lt;- geojson_read(file))
geojson_read(file)

# From a URL
url &lt;- "https://raw.githubusercontent.com/glynnbird/usstatesgeojson/master/california.geojson"
geojson_read(url)
geojson_read(url, parse = TRUE)

# Use as.location first if you want
geojson_read(as.location(file))

# output a SpatialClass object
## read kml
file &lt;- system.file("examples", "norway_maple.kml", package = "geojsonio")
geojson_read(as.location(file), what = "sp")
## read geojson
file &lt;- system.file("examples", "california.geojson", package = "geojsonio")
geojson_read(as.location(file), what = "sp")
## read geojson from a url
url &lt;- "https://raw.githubusercontent.com/glynnbird/usstatesgeojson/master/california.geojson"
geojson_read(url, what = "sp")
## read from a shape file
file &lt;- system.file("examples", "bison.zip", package = "geojsonio")
dir &lt;- tempdir()
unzip(file, exdir = dir)
shpfile &lt;- list.files(dir, pattern = ".shp", full.names = TRUE)
geojson_read(shpfile, what = "sp")

x &lt;- "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json"
geojson_read(x, what = "sp")
geojson_read(x, what = "list")

utils::download.file(x, destfile = basename(x))
geojson_read(basename(x), what = "sp")

# from a Postgres database - your Postgres instance must be running
## MAKE SURE to run the setup in the postgis manual file first!
if (requireNamespace("DBI") &amp;&amp; requireNamespace("RPostgres")) {
  library(DBI)
  conn &lt;- tryCatch(dbConnect(RPostgres::Postgres(), dbname = "postgistest"),
    error = function(e) e
  )
  if (inherits(conn, "PqConnection")) {
    state &lt;- "SELECT row_to_json(fc)
   FROM (SELECT 'FeatureCollection' As type, array_to_json(array_agg(f)) As features
   FROM (SELECT 'Feature' As type
     , ST_AsGeoJSON(lg.geog)::json As geometry
     , row_to_json((SELECT l FROM (SELECT loc_id, loc_name) As l
       )) As properties
    FROM locations As lg   ) As f )  As fc;"
    json &lt;- geojson_read(conn, query = state, what = "json")
    map_leaf(json)
  }
}

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson_sf'>Convert objects to an sf class</h2><span id='topic+geojson_sf'></span>

<h3>Description</h3>

<p>Convert objects to an sf class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_sf(x, stringsAsFactors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_sf_+3A_x">x</code></td>
<td>
<p>Object of class <code>geo_list</code>, <code>geo_json</code>, string, or json</p>
</td></tr>
<tr><td><code id="geojson_sf_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert strings to Factors? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geojson_sf_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type of sf object returned will depend on the input GeoJSON.
Sometimes you will get back a <code>POINTS</code> class, and sometimes a
<code>POLYGON</code> class, etc., depending on what the structure of the GeoJSON.
</p>
<p>The reading and writing of the CRS to/from geojson is inconsistent. You can
directly set the CRS by passing a valid PROJ4 string or epsg code to the crs
argument in <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>
</p>


<h3>Value</h3>

<p>An sf class object, see Details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

# geo_list ------------------
## From a numeric vector of length 2 to a point
vec &lt;- c(-99.74, 32.45)
geojson_list(vec) %&gt;% geojson_sf()

## Lists
## From a list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
geojson_list(mylist) %&gt;% geojson_sf()
geojson_list(mylist) %&gt;%
  geojson_sf() %&gt;%
  plot()

## From a list of numeric vectors to a polygon
vecs &lt;- list(c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0), c(100.0, 0.0))
geojson_list(vecs, geometry = "polygon") %&gt;% geojson_sf()
geojson_list(vecs, geometry = "polygon") %&gt;%
  geojson_sf() %&gt;%
  plot()

# geo_json ------------------
## from point
geojson_json(c(-99.74, 32.45)) %&gt;% geojson_sf()
geojson_json(c(-99.74, 32.45)) %&gt;%
  geojson_sf() %&gt;%
  plot()

# from featurecollectino of points
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;% geojson_sf()
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;%
  geojson_sf() %&gt;%
  plot()

# Set the CRS via the crs argument
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;% geojson_sf(crs = "+init=epsg:4326")

# json ----------------------
x &lt;- geojson_json(us_cities[1:2, ], lat = "lat", lon = "long")
geojson_sf(x)

# character string ----------------------
x &lt;- unclass(geojson_json(c(-99.74, 32.45)))
geojson_sf(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson_sp'>Convert objects to spatial classes</h2><span id='topic+geojson_sp'></span>

<h3>Description</h3>

<p>Convert objects to spatial classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_sp(x, disambiguateFIDs = FALSE, stringsAsFactors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_sp_+3A_x">x</code></td>
<td>
<p>Object of class <code>geo_list</code>, <code>geo_json</code>, string, or json</p>
</td></tr>
<tr><td><code id="geojson_sp_+3A_disambiguatefids">disambiguateFIDs</code></td>
<td>
<p>Ignored, and will be removed in a future version.
Previously was passed to <code>rgdal::readOGR()</code>, which is no longer used.</p>
</td></tr>
<tr><td><code id="geojson_sp_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert strings to Factors? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geojson_sp_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial class object returned will depend on the input GeoJSON.
Sometimes you will get back a <code>SpatialPoints</code> class, and sometimes a
<code>SpatialPolygonsDataFrame</code> class, etc., depending on what the
structure of the GeoJSON.
</p>
<p>The reading and writing of the CRS to/from geojson is inconsistent. You can
directly set the CRS by passing a valid PROJ4 string or epsg code to the crs
argument in <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>
</p>


<h3>Value</h3>

<p>A spatial class object, see Details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)

# geo_list ------------------
## From a numeric vector of length 2 to a point
vec &lt;- c(-99.74, 32.45)
geojson_list(vec) %&gt;% geojson_sp()

## Lists
## From a list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
geojson_list(mylist) %&gt;% geojson_sp()
geojson_list(mylist) %&gt;%
  geojson_sp() %&gt;%
  plot()

## From a list of numeric vectors to a polygon
vecs &lt;- list(c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0), c(100.0, 0.0))
geojson_list(vecs, geometry = "polygon") %&gt;% geojson_sp()
geojson_list(vecs, geometry = "polygon") %&gt;%
  geojson_sp() %&gt;%
  plot()

# geo_json ------------------
## from point
geojson_json(c(-99.74, 32.45)) %&gt;% geojson_sp()
geojson_json(c(-99.74, 32.45)) %&gt;%
  geojson_sp() %&gt;%
  plot()

# from featurecollectino of points
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;% geojson_sp()
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;%
  geojson_sp() %&gt;%
  plot()

# Set the CRS via the crs argument
geojson_json(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;%
  geojson_sp(crs = "+init=epsg:4326")

# json ----------------------
x &lt;- geojson_json(us_cities[1:2, ], lat = "lat", lon = "long")
geojson_sp(x)

# character string ----------------------
x &lt;- unclass(geojson_json(c(-99.74, 32.45)))
geojson_sp(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson_style'>Style a data.frame or list prior to converting to geojson</h2><span id='topic+geojson_style'></span>

<h3>Description</h3>

<p>This helps you add styling following the Simplestyle Spec. See Details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_style(
  input,
  var = NULL,
  var_col = NULL,
  var_sym = NULL,
  var_size = NULL,
  var_stroke = NULL,
  var_stroke_width = NULL,
  var_stroke_opacity = NULL,
  var_fill = NULL,
  var_fill_opacity = NULL,
  color = NULL,
  symbol = NULL,
  size = NULL,
  stroke = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  fill = NULL,
  fill_opacity = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_style_+3A_input">input</code></td>
<td>
<p>A data.frame or a list</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var">var</code></td>
<td>
<p>(character) A single variable to map colors, symbols,
and/or sizes to</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_col">var_col</code></td>
<td>
<p>(character) A single variable to map colors to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_sym">var_sym</code></td>
<td>
<p>(character) A single variable to map symbols to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_size">var_size</code></td>
<td>
<p>(character) A single variable to map size to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_stroke">var_stroke</code></td>
<td>
<p>(character) A single variable to map stroke to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_stroke_width">var_stroke_width</code></td>
<td>
<p>(character) A single variable to map stroke
width to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_stroke_opacity">var_stroke_opacity</code></td>
<td>
<p>(character) A single variable to map stroke
opacity to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_fill">var_fill</code></td>
<td>
<p>(character) A single variable to map fill to.</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_var_fill_opacity">var_fill_opacity</code></td>
<td>
<p>(character) A single variable to map fill opacity to</p>
</td></tr>
<tr><td><code id="geojson_style_+3A_color">color</code></td>
<td>
<p>(character) Valid RGB hex color. Assigned to the variable
<code>marker-color</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_symbol">symbol</code></td>
<td>
<p>(character) An icon ID from the Maki project
https://labs.mapbox.com/maki-icons/
or a single alphanumeric character (a-z or 0-9). Assigned to the variable
<code>marker-symbol</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_size">size</code></td>
<td>
<p>(character) One of 'small', 'medium', or 'large'. Assigned
to the variable <code>marker-size</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_stroke">stroke</code></td>
<td>
<p>(character) Color of a polygon edge or line (RGB). Assigned
to the variable <code>stroke</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_stroke_width">stroke_width</code></td>
<td>
<p>(numeric) Width of a polygon edge or line (number &gt; 0).
Assigned  to the variable <code>stroke-width</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>(numeric) Opacity of a polygon edge or line
(0.0 - 1.0). Assigned to the variable <code>stroke-opacity</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_fill">fill</code></td>
<td>
<p>(character) The color of the interior of a polygon (GRB).
Assigned to the variable <code>fill</code></p>
</td></tr>
<tr><td><code id="geojson_style_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>(character) The opacity of the interior of a polygon
(0.0-1.0). Assigned to the variable <code>fill-opacity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters color, symbol, size, stroke, stroke_width,
stroke_opacity, fill, and fill_opacity expect a vector of size 1 (recycled),
or exact length of vector being applied to in your input data.
</p>
<p>This function helps add styling data to a list or data.frame following the
Simplestyle Spec
(https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0),
used by MapBox and GitHub Gists (that renders geoJSON/topoJSON
as interactive maps).
</p>
<p>There are a few other style variables, but deal with polygons
</p>
<p>GitHub has a nice help article on geoJSON files
https://help.github.com/articles/mapping-geojson-files-on-github/
</p>
<p>Please do get in touch if you think anything should change in this
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## from data.frames - point data
library("RColorBrewer")
smalluscities &lt;-
  subset(us_cities, country.etc == "OR" | country.etc == "NY" | country.etc == "CA")

### Just color
geojson_style(smalluscities,
  var = "country.etc",
  color = brewer.pal(length(unique(smalluscities$country.etc)), "Blues")
)
### Just size
geojson_style(smalluscities, var = "country.etc", size = c("small", "medium", "large"))
### Color and size
geojson_style(smalluscities,
  var = "country.etc",
  color = brewer.pal(length(unique(smalluscities$country.etc)), "Blues"),
  size = c("small", "medium", "large")
)

## from lists - point data
mylist &lt;- list(
  list(latitude = 30, longitude = 120, state = "US"),
  list(latitude = 32, longitude = 130, state = "OR"),
  list(latitude = 38, longitude = 125, state = "NY"),
  list(latitude = 40, longitude = 128, state = "VT")
)
# just color
geojson_style(mylist,
  var = "state",
  color = brewer.pal(length(unique(sapply(mylist, "[[", "state"))), "Blues")
)
# color and size
geojson_style(mylist,
  var = "state",
  color = brewer.pal(length(unique(sapply(mylist, "[[", "state"))), "Blues"),
  size = c("small", "medium", "large", "large")
)
# color, size, and symbol
geojson_style(mylist,
  var = "state",
  color = brewer.pal(length(unique(sapply(mylist, "[[", "state"))), "Blues"),
  size = c("small", "medium", "large", "large"),
  symbol = "zoo"
)
# stroke, fill
geojson_style(mylist,
  var = "state",
  stroke = brewer.pal(length(unique(sapply(mylist, "[[", "state"))), "Blues"),
  fill = brewer.pal(length(unique(sapply(mylist, "[[", "state"))), "Greens")
)

# from data.frame - polygon data
smallstates &lt;- states[states$group %in% 1:3, ]
head(smallstates)
geojson_style(smallstates,
  var = "group",
  stroke = brewer.pal(length(unique(smallstates$group)), "Blues"),
  stroke_width = c(1, 2, 3),
  fill = brewer.pal(length(unique(smallstates$group)), "Greens")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson_write'>Convert many input types with spatial data to a geojson file</h2><span id='topic+geojson_write'></span>

<h3>Description</h3>

<p>Convert many input types with spatial data to a geojson file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson_write(
  input,
  lat = NULL,
  lon = NULL,
  geometry = "point",
  group = NULL,
  file = "myfile.geojson",
  overwrite = TRUE,
  precision = NULL,
  convert_wgs84 = FALSE,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson_write_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class.
Inputs can  also be dplyr <code>tbl_df</code> class since it inherits
from <code>data.frame</code></p>
</td></tr>
<tr><td><code id="geojson_write_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_file">file</code></td>
<td>
<p>(character) A path and file name (e.g., myfile), with the
<code>.geojson</code> file extension. Default writes to current working
directory.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) Overwrite the file given in <code>file</code> with
<code>input</code>. Default: <code>TRUE</code>. If this param is <code>FALSE</code> and
the file already exists, we stop with error message.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_precision">precision</code></td>
<td>
<p>desired number of decimal places for the coordinates in the
geojson file. Using fewer decimal places can decrease file sizes (at the
cost of precision).</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference
system, using the WGS84 datum, with longitude and latitude units of decimal
degrees; EPSG: 4326). Default is <code>FALSE</code> though this may change in a
future package version. This will only work for <code>sf</code> or <code>Spatial</code>
objects with a CRS already defined. If one is not defined but you know what
it is, you may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can be
an epsg code as a four or five digit integer or a valid proj4 string. This
argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code> or the
object already has a CRS.</p>
</td></tr>
<tr><td><code id="geojson_write_+3A_...">...</code></td>
<td>
<p>Further args passed on to internal functions. For Spatial*
classes, data.frames,
regular lists, and numerics, it is passed through to
<code><a href="sf.html#topic+st_write">sf::st_write()</a></code>. For sf classes,
geo_lists and json classes, it is passed through to
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geojson_write</code> class, with two elements:
</p>

<ul>
<li><p> path: path to the file with the GeoJSON
</p>
</li>
<li><p> type: type of object the GeoJSON came from, e.g., SpatialPoints
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geojson_list">geojson_list()</a></code>, <code><a href="#topic+geojson_json">geojson_json()</a></code>, <code><a href="#topic+topojson_write">topojson_write()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a data.frame
## to points
geojson_write(us_cities[1:2, ], lat = "lat", lon = "long")

## to polygons
head(states)
geojson_write(
  input = states, lat = "lat", lon = "long",
  geometry = "polygon", group = "group"
)

## partial states dataset to points (defaults to points)
geojson_write(input = states, lat = "lat", lon = "long")

## Lists
### list of numeric pairs
poly &lt;- list(
  c(-114.345703125, 39.436192999314095),
  c(-114.345703125, 43.45291889355468),
  c(-106.61132812499999, 43.45291889355468),
  c(-106.61132812499999, 39.436192999314095),
  c(-114.345703125, 39.436192999314095)
)
geojson_write(poly, geometry = "polygon")

### named list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
geojson_write(mylist)

# From a numeric vector of length 2
## Expected order is lon, lat
vec &lt;- c(-99.74, 32.45)
geojson_write(vec)

## polygon from a series of numeric pairs
### this requires numeric class input, so inputting a list will
### dispatch on the list method
poly &lt;- c(
  c(-114.345703125, 39.436192999314095),
  c(-114.345703125, 43.45291889355468),
  c(-106.61132812499999, 43.45291889355468),
  c(-106.61132812499999, 39.436192999314095),
  c(-114.345703125, 39.436192999314095)
)
geojson_write(poly, geometry = "polygon")

# Write output of geojson_list to file
res &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long")
class(res)
geojson_write(res)

# Write output of geojson_json to file
res &lt;- geojson_json(us_cities[1:2, ], lat = "lat", lon = "long")
class(res)
geojson_write(res)

# From SpatialPolygons class
library("sp")
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
geojson_write(sp_poly)

# From SpatialPolygonsDataFrame class
sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
geojson_write(input = sp_polydf)

# From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
geojson_write(y)

# From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
geojson_write(sgdf)


# From SpatialPixels
library("sp")
pixels &lt;- suppressWarnings(SpatialPixels(SpatialPoints(us_cities[c("long", "lat")])))
summary(pixels)
geojson_write(pixels)

# From SpatialPixelsDataFrame
library("sp")
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(points = canada_cities[c("long", "lat")], data = canada_cities)
)
geojson_write(pixelsdf)


# From sf classes:
if (require(sf)) {
  file &lt;- system.file("examples", "feature_collection.geojson", package = "geojsonio")
  sf_fc &lt;- st_read(file, quiet = TRUE)
  geojson_write(sf_fc)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='geojson-add'>Add together geo_list or json objects</h2><span id='topic+geojson-add'></span><span id='topic++2B.geo_list'></span><span id='topic++2B.json'></span>

<h3>Description</h3>

<p>Add together geo_list or json objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geo_list'
x1 + x2

## S3 method for class 'json'
x1 + x2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geojson-add_+3A_x1">x1</code></td>
<td>
<p>An object of class <code>geo_list</code> or <code>json</code></p>
</td></tr>
<tr><td><code id="geojson-add_+3A_x2">x2</code></td>
<td>
<p>A component to add to <code>x1</code>, of class <code>geo_list</code> or <code>json</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the first object is an object of class <code>geo_list</code>, you
can add another object of class <code>geo_list</code> or of class <code>json</code>,
and will result  in a <code>geo_list</code> object.
</p>
<p>If the first object is an object of class <code>json</code>, you can add
another object of class <code>json</code> or of class <code>geo_list</code>, and will result
in a <code>json</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geojson_list">geojson_list()</a></code>, <code><a href="#topic+geojson_json">geojson_json()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# geo_list + geo_list
## Note: geo_list is the output type from geojson_list, it's just a list with
## a class attached so we know it's geojson :)
vec &lt;- c(-99.74, 32.45)
a &lt;- geojson_list(vec)
vecs &lt;- list(
  c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0),
  c(100.0, 1.0), c(100.0, 0.0)
)
b &lt;- geojson_list(vecs, geometry = "polygon")
a + b

# json + json
c &lt;- geojson_json(c(-99.74, 32.45))
vecs &lt;- list(
  c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0),
  c(100.0, 1.0), c(100.0, 0.0)
)
d &lt;- geojson_json(vecs, geometry = "polygon")
c + d
(c + d) %&gt;% pretty()

## End(Not run)
</code></pre>

<hr>
<h2 id='map_gist'>Publish an interactive map as a GitHub gist</h2><span id='topic+map_gist'></span>

<h3>Description</h3>

<p>There are two ways to authorize to work with your GitHub
account:
</p>

<ul>
<li><p> PAT - Generate a personal access token (PAT) at
https://help.github.com/articles/creating-an-access-token-for-command-line-use
and record it in the <code>GITHUB_PAT</code> envar in your <code>.Renviron</code> file.
</p>
</li>
<li><p> Interactive - Interactively login into your GitHub account and authorise
with OAuth.
</p>
</li></ul>

<p>Using the PAT method is recommended.
</p>
<p>Using the <code>gist_auth()</code> function you can authenticate separately first, or
if you're not authenticated, this function will run internally with each
function call. If you have a PAT, that will be used, if not, OAuth will
be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_gist(
  input,
  lat = "lat",
  lon = "long",
  geometry = "point",
  group = NULL,
  type = "FeatureCollection",
  file = "myfile.geojson",
  description = "",
  public = TRUE,
  browse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_gist_+3A_input">input</code></td>
<td>
<p>Input object</p>
</td></tr>
<tr><td><code id="map_gist_+3A_lat">lat</code></td>
<td>
<p>Name of latitude variable</p>
</td></tr>
<tr><td><code id="map_gist_+3A_lon">lon</code></td>
<td>
<p>Name of longitude variable</p>
</td></tr>
<tr><td><code id="map_gist_+3A_geometry">geometry</code></td>
<td>
<p>(character) Are polygons in the object</p>
</td></tr>
<tr><td><code id="map_gist_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="map_gist_+3A_type">type</code></td>
<td>
<p>(character) One of FeatureCollection or GeometryCollection</p>
</td></tr>
<tr><td><code id="map_gist_+3A_file">file</code></td>
<td>
<p>File name to use to put up as the gist file</p>
</td></tr>
<tr><td><code id="map_gist_+3A_description">description</code></td>
<td>
<p>Description for the GitHub gist, or leave to default
(=no description)</p>
</td></tr>
<tr><td><code id="map_gist_+3A_public">public</code></td>
<td>
<p>(logical) Want gist to be public or not? Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="map_gist_+3A_browse">browse</code></td>
<td>
<p>If <code>TRUE</code> (default) the map opens in your default browser.</p>
</td></tr>
<tr><td><code id="map_gist_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>httr::POST</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (!identical(Sys.getenv("GITHUB_PAT"), "")) {

  # From file
  file &lt;- "myfile.geojson"
  geojson_write(us_cities[1:20, ], lat = "lat", lon = "long", file = file)
  map_gist(file = as.location(file))

  # From SpatialPoints class
  library("sp")
  x &lt;- c(1, 2, 3, 4, 5)
  y &lt;- c(3, 2, 5, 1, 4)
  s &lt;- SpatialPoints(cbind(x, y))
  map_gist(s)

  # from SpatialPointsDataFrame class
  x &lt;- c(1, 2, 3, 4, 5)
  y &lt;- c(3, 2, 5, 1, 4)
  s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
  map_gist(s)

  # from SpatialPolygons class
  poly1 &lt;- Polygons(list(Polygon(cbind(
    c(-100, -90, -85, -100),
    c(40, 50, 45, 40)
  ))), "1")
  poly2 &lt;- Polygons(list(Polygon(cbind(
    c(-90, -80, -75, -90),
    c(30, 40, 35, 30)
  ))), "2")
  sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
  map_gist(sp_poly)

  # From SpatialPolygonsDataFrame class
  sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
  map_gist(sp_poly)

  # From SpatialLines class
  c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
  c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
  c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
  L1 &lt;- Line(c1)
  L2 &lt;- Line(c2)
  L3 &lt;- Line(c3)
  Ls1 &lt;- Lines(list(L1), ID = "a")
  Ls2 &lt;- Lines(list(L2, L3), ID = "b")
  sl1 &lt;- SpatialLines(list(Ls1))
  sl12 &lt;- SpatialLines(list(Ls1, Ls2))
  map_gist(sl1)

  # From SpatialLinesDataFrame class
  dat &lt;- data.frame(
    X = c("Blue", "Green"),
    Y = c("Train", "Plane"),
    Z = c("Road", "River"), row.names = c("a", "b")
  )
  sldf &lt;- SpatialLinesDataFrame(sl12, dat)
  map_gist(sldf)

  # From SpatialGrid
  x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
  y &lt;- SpatialGrid(x)
  map_gist(y)

  # From SpatialGridDataFrame
  sgdim &lt;- c(3, 4)
  sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
  sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
  map_gist(sgdf)

  # from data.frame
  ## to points
  map_gist(us_cities)

  ## to polygons
  head(states)
  map_gist(states[1:351, ], lat = "lat", lon = "long", geometry = "polygon", group = "group")

  ## From a list
  mylist &lt;- list(
    list(lat = 30, long = 120, marker = "red"),
    list(lat = 30, long = 130, marker = "blue")
  )
  map_gist(mylist, lat = "lat", lon = "long")

  # From a numeric vector
  ## of length 2 to a point
  vec &lt;- c(-99.74, 32.45)
  map_gist(vec)

  ## this requires numeric class input, so inputting a list will dispatch on the list method
  poly &lt;- c(
    c(-114.345703125, 39.436192999314095),
    c(-114.345703125, 43.45291889355468),
    c(-106.61132812499999, 43.45291889355468),
    c(-106.61132812499999, 39.436192999314095),
    c(-114.345703125, 39.436192999314095)
  )
  map_gist(poly, geometry = "polygon")

  # From a json object
  (x &lt;- geojson_json(c(-99.74, 32.45)))
  map_gist(x)
  ## another example
  map_gist(geojson_json(us_cities[1:10, ], lat = "lat", lon = "long"))

  # From a geo_list object
  (res &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long"))
  map_gist(res)

  # From SpatialPixels
  pixels &lt;- suppressWarnings(SpatialPixels(SpatialPoints(us_cities[c("long", "lat")])))
  summary(pixels)
  map_gist(pixels)

  # From SpatialPixelsDataFrame
  pixelsdf &lt;- suppressWarnings(
    SpatialPixelsDataFrame(points = canada_cities[c("long", "lat")], data = canada_cities)
  )
  map_gist(pixelsdf)

}

## End(Not run)
</code></pre>

<hr>
<h2 id='map_leaf'>Make an interactive map locally</h2><span id='topic+map_leaf'></span>

<h3>Description</h3>

<p>Make an interactive map locally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_leaf(input, lat = NULL, lon = NULL, basemap = "Stamen.Toner", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_leaf_+3A_input">input</code></td>
<td>
<p>Input object</p>
</td></tr>
<tr><td><code id="map_leaf_+3A_lat">lat</code></td>
<td>
<p>Name of latitude variable</p>
</td></tr>
<tr><td><code id="map_leaf_+3A_lon">lon</code></td>
<td>
<p>Name of longitude variable</p>
</td></tr>
<tr><td><code id="map_leaf_+3A_basemap">basemap</code></td>
<td>
<p>Basemap to use. See <code>leaflet::addProviderTiles</code>.
Default: <code>Stamen.Toner</code></p>
</td></tr>
<tr><td><code id="map_leaf_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>leaflet::addPolygons</code>,
<code>leaflet::addMarkers</code>, <code>leaflet::addGeoJSON</code>, or <code>leaflet::addPolylines</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We'll need leaflet below
library("leaflet")

# From file
file &lt;- "myfile.geojson"
geojson_write(us_cities[1:20, ], lat = "lat", lon = "long", file = file)
map_leaf(as.location(file))

# From SpatialPoints class
library("sp")
x &lt;- c(1, 2, 3, 4, 20)
y &lt;- c(3, 2, 5, 3, 4)
s &lt;- SpatialPoints(cbind(x, y))
map_leaf(s)

# from SpatialPointsDataFrame class
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(3, 2, 5, 1, 4)
s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
map_leaf(s)

# from SpatialPolygons class
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
map_leaf(sp_poly)

# From SpatialPolygonsDataFrame class
sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
map_leaf(sp_poly)

# From SpatialLines class
c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
L1 &lt;- Line(c1)
L2 &lt;- Line(c2)
L3 &lt;- Line(c3)
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
map_leaf(sl1)
map_leaf(sl12)

# From SpatialLinesDataFrame class
dat &lt;- data.frame(
  X = c("Blue", "Green"),
  Y = c("Train", "Plane"),
  Z = c("Road", "River"), row.names = c("a", "b")
)
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
map_leaf(sldf)

# From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
map_leaf(y)

# From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
map_leaf(sgdf)

# from data.frame
map_leaf(us_cities)

## another example
head(states)
map_leaf(states[1:351, ])

## From a named list
mylist &lt;- list(
  list(lat = 30, long = 120, marker = "red"),
  list(lat = 30, long = 130, marker = "blue")
)
map_leaf(mylist, lat = "lat", lon = "long")

## From an unnamed list
poly &lt;- list(
  c(-114.345703125, 39.436192999314095),
  c(-114.345703125, 43.45291889355468),
  c(-106.61132812499999, 43.45291889355468),
  c(-106.61132812499999, 39.436192999314095),
  c(-114.345703125, 39.436192999314095)
)
map_leaf(poly)
## NOTE: Polygons from lists aren't supported yet

# From a json object
map_leaf(geojson_json(c(-99.74, 32.45)))
map_leaf(geojson_json(c(-119, 45)))
map_leaf(geojson_json(c(-99.74, 32.45)))
## another example
map_leaf(geojson_json(us_cities[1:10, ], lat = "lat", lon = "long"))

# From a geo_list object
(res &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long"))
map_leaf(res)

# From SpatialPixels
pixels &lt;- suppressWarnings(SpatialPixels(SpatialPoints(us_cities[c("long", "lat")])))
summary(pixels)
map_leaf(pixels)

# From SpatialPixelsDataFrame
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(points = canada_cities[c("long", "lat")], data = canada_cities)
)
map_leaf(pixelsdf)

# basemap toggling ------------------------
map_leaf(us_cities, basemap = "Acetate.terrain")
map_leaf(us_cities, basemap = "CartoDB.Positron")
map_leaf(us_cities, basemap = "OpenTopoMap")

# leaflet options ------------------------
map_leaf(us_cities) %&gt;%
  addPopups(-122.327298, 47.597131, "foo bar", options = popupOptions(closeButton = FALSE))

####### not working yet
# From a numeric vector
## of length 2 to a point
## vec &lt;- c(-99.74,32.45)
## map_leaf(vec)

## End(Not run)
</code></pre>

<hr>
<h2 id='postgis'>PostGIS setup</h2><span id='topic+postgis'></span>

<h3>Description</h3>

<p><code><a href="#topic+geojson_read">geojson_read()</a></code> allows you to get data out of a PostgreSQL
database set up with PostGIS. Below are steps for setting up data
that we can at the end query with <code><a href="#topic+geojson_read">geojson_read()</a></code>
</p>


<h3>Details</h3>

<p>If you don't already have PostgreSQL or PostGIS:
</p>

<ul>
<li><p> PostgreSQL installation: https://www.postgresql.org/download/
</p>
</li>
<li><p> PostGIS installation: https://postgis.net/install/
</p>
</li></ul>

<p>Once you have both of those installed, you can proceed below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("DBI") &amp;&amp; requireNamespace("RPostgres")) {
  library("DBI")
  library("RPostgres")

  # Create connection
  conn &lt;- tryCatch(dbConnect(RPostgres::Postgres()), error = function(e) e)
  if (inherits(conn, "PqConnection")) {

    # Create database
    dbSendQuery(conn, "CREATE DATABASE postgistest")

    # New connection to the created database
    conn &lt;- dbConnect(RPostgres::Postgres(), dbname = "postgistest")

    # Initialize PostGIS in Postgres
    dbSendQuery(conn, "CREATE EXTENSION postgis")
    dbSendQuery(conn, "SELECT postgis_full_version()")

    # Create table
    dbSendQuery(conn, "CREATE TABLE locations(loc_id integer primary key
   , loc_name varchar(70), geog geography(POINT) );")

    # Insert data
    dbSendQuery(conn, "INSERT INTO locations(loc_id, loc_name, geog)
 VALUES (1, 'Waltham, MA', ST_GeogFromText('POINT(42.40047 -71.2577)') )
   , (2, 'Manchester, NH', ST_GeogFromText('POINT(42.99019 -71.46259)') )
   , (3, 'TI Blvd, TX', ST_GeogFromText('POINT(-96.75724 32.90977)') );")


    # Get data (notice warnings of unknown field type for geog)
    dbGetQuery(conn, "SELECT * from locations")


    # Once you're setup, use geojson_read()
    conn &lt;- dbConnect(RPostgres::Postgres(), dbname = "postgistest")
    state &lt;- "SELECT row_to_json(fc)
 FROM (SELECT 'FeatureCollection' As type, array_to_json(array_agg(f)) As features
 FROM (SELECT 'Feature' As type
    , ST_AsGeoJSON(lg.geog)::json As geometry
    , row_to_json((SELECT l FROM (SELECT loc_id, loc_name) As l
      )) As properties
   FROM locations As lg   ) As f )  As fc;"
    json &lt;- geojson_read(conn, query = state, what = "json")

    ## map the geojson with map_leaf()
    map_leaf(json)
  }
}

## End(Not run)
</code></pre>

<hr>
<h2 id='pretty'>Convert json input to pretty printed output</h2><span id='topic+pretty'></span>

<h3>Description</h3>

<p>Convert json input to pretty printed output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty(x, indent = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_+3A_x">x</code></td>
<td>
<p>Input, character string</p>
</td></tr>
<tr><td><code id="pretty_+3A_indent">indent</code></td>
<td>
<p>(integer) Number of spaces to indent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only works with json class input. This is a simple wrapper around
<code><a href="jsonlite.html#topic+prettify">jsonlite::prettify()</a></code>, so you can easily use that yourself.
</p>

<hr>
<h2 id='projections'>topojson projections and extensions</h2><span id='topic+projections'></span>

<h3>Description</h3>

<p>topojson projections and extensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projections(
  proj,
  rotate = NULL,
  center = NULL,
  translate = NULL,
  scale = NULL,
  clipAngle = NULL,
  precision = NULL,
  parallels = NULL,
  clipExtent = NULL,
  invert = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projections_+3A_proj">proj</code></td>
<td>
<p>Map projection name. One of albers, albersUsa, azimuthalEqualArea,
azimuthalEquidistant, conicEqualArea, conicConformal, conicEquidistant, equirectangular,
gnomonic, mercator, orthographic, stereographic, or transverseMercator.</p>
</td></tr>
<tr><td><code id="projections_+3A_rotate">rotate</code></td>
<td>
<p>If rotation is specified, sets the projection's three-axis rotation to the
specified angles yaw, pitch and roll (or equivalently longitude, latitude and roll)
in degrees and returns the projection. If rotation is not specified, returns the current
rotation which defaults <code style="white-space: pre;">&#8288;[0, 0, 0]&#8288;</code>. If the specified rotation has only two values, rather than
three, the roll is assumed to be 0.</p>
</td></tr>
<tr><td><code id="projections_+3A_center">center</code></td>
<td>
<p>If center is specified, sets the projection's center to the specified location, a
two-element array of longitude and latitude in degrees and returns the projection. If center is
not specified, returns the current center which defaults to (0,0)</p>
</td></tr>
<tr><td><code id="projections_+3A_translate">translate</code></td>
<td>
<p>If point is specified, sets the projection's translation offset to the
specified two-element array <code style="white-space: pre;">&#8288;[x, y]&#8288;</code> and returns the projection. If point is not specified,
returns the current translation offset which defaults to <code style="white-space: pre;">&#8288;[480, 250]&#8288;</code>. The translation offset
determines the pixel coordinates of the projection's center. The default translation offset
places (0,0) at the center of a 960x500 area.</p>
</td></tr>
<tr><td><code id="projections_+3A_scale">scale</code></td>
<td>
<p>If scale is specified, sets the projection's scale factor to the specified value
and returns the projection. If scale is not specified, returns the current scale factor which
defaults to 150. The scale factor corresponds linearly to the distance between projected points.
However, scale factors are not consistent across projections.</p>
</td></tr>
<tr><td><code id="projections_+3A_clipangle">clipAngle</code></td>
<td>
<p>If angle is specified, sets the projection's clipping circle radius to the
specified angle in degrees and returns the projection. If angle is null, switches to
antimeridian cutting rather than small-circle clipping. If angle is not specified, returns the
current clip angle which defaults to null. Small-circle clipping is independent of viewport
clipping via clipExtent.</p>
</td></tr>
<tr><td><code id="projections_+3A_precision">precision</code></td>
<td>
<p>If precision is specified, sets the threshold for the projection's adaptive
resampling to the specified value in pixels and returns the projection. This value corresponds
to the Douglas-Peucker distance. If precision is not specified, returns the projection's current
resampling precision which defaults to Math.SQRT(1/2).</p>
</td></tr>
<tr><td><code id="projections_+3A_parallels">parallels</code></td>
<td>
<p>Depends on the projection used! See
https://github.com/mbostock/d3/wiki/Geo-Projections#standard-projections for help</p>
</td></tr>
<tr><td><code id="projections_+3A_clipextent">clipExtent</code></td>
<td>
<p>If extent is specified, sets the projection's viewport clip extent to the
specified bounds in pixels and returns the projection. The extent bounds are specified as an
array <code style="white-space: pre;">&#8288;[[x0, y0], [x1, y1]]&#8288;</code>, where x0 is the left-side of the viewport, y0 is the top, x1 is
the right and y1 is the bottom. If extent is null, no viewport clipping is performed. If extent
is not specified, returns the current viewport clip extent which defaults to null. Viewport
clipping is independent of small-circle clipping via clipAngle.</p>
</td></tr>
<tr><td><code id="projections_+3A_invert">invert</code></td>
<td>
<p>Projects backward from Cartesian coordinates (in pixels) to spherical coordinates
(in degrees). Returns an array <code style="white-space: pre;">&#8288;[longitude, latitude]&#8288;</code> given the input array <code style="white-space: pre;">&#8288;[x, y]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>projections(proj = "albers")
projections(proj = "albers", rotate = "[98 + 00 / 60, -35 - 00 / 60]", scale = 5700)
projections(proj = "albers", scale = 5700)
projections(proj = "albers", translate = "[55 * width / 100, 52 * height / 100]")
projections(proj = "albers", clipAngle = 90)
projections(proj = "albers", precision = 0.1)
projections(proj = "albers", parallels = "[30, 62]")
projections(proj = "albers", clipExtent = "[[105 - 87, 40], [105 + 87 + 1e-6, 82 + 1e-6]]")
projections(proj = "albers", invert = 60)
projections("orthographic")
</code></pre>

<hr>
<h2 id='states'>This is the same data set from the ggplot2 library</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>This is a data.frame with &quot;long&quot;, &quot;lat&quot;, &quot;group&quot;, &quot;order&quot;, &quot;region&quot;, and
&quot;subregion&quot; columns specifying polygons for each US state.
</p>

<hr>
<h2 id='topojson_json'>Convert many input types with spatial data to TopoJSON
as a JSON string</h2><span id='topic+topojson_json'></span>

<h3>Description</h3>

<p>Convert many input types with spatial data to TopoJSON
as a JSON string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topojson_json(
  input,
  lat = NULL,
  lon = NULL,
  group = NULL,
  geometry = "point",
  type = "FeatureCollection",
  convert_wgs84 = FALSE,
  crs = NULL,
  object_name = "foo",
  quantization = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topojson_json_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class. Inputs can
also be dplyr <code>tbl_df</code> class since it inherits from <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_type">type</code></td>
<td>
<p>(character) The type of collection. One of 'auto' (default
for 'sf' objects), 'FeatureCollection' (default for everything else), or
'GeometryCollection'. &quot;skip&quot; skips the coercion with package <span class="pkg">geojson</span>
functions; skipping can save significant run time on larger geojson
objects. <code>Spatial</code> objects can only accept &quot;FeatureCollection&quot; or &quot;skip&quot;.
&quot;skip&quot; is not available as an option for <code>numeric</code>, <code>list</code>,
and <code>data.frame</code> classes</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS system for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference system, using
the WGS84 datum, with longitude and latitude units of decimal degrees;
EPSG: 4326). Default is <code>FALSE</code> though this may change in a future
package version. This will only work for <code>sf</code> or <code>Spatial</code>
objects with a CRS already defined. If one is not defined but you know
what it is, you may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can be
an epsg code as a four or five digit integer or a valid proj4 string.
This argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code> or
the object already has a CRS.</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_object_name">object_name</code></td>
<td>
<p>(character) name to give to the TopoJSON object created.
Default: &quot;foo&quot;</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_quantization">quantization</code></td>
<td>
<p>(numeric) quantization parameter, use this to
quantize geometry prior to computing topology. Typical values are powers of
ten (<code>1e4</code>, <code>1e5</code>, ...), default is <code>0</code> to not perform quantization.
For more information about quantization, see this by Mike Bostock
https://stackoverflow.com/questions/18900022/topojson-quantization-vs-simplification/18921214#18921214</p>
</td></tr>
<tr><td><code id="topojson_json_+3A_...">...</code></td>
<td>
<p>args passed down to <code><a href="#topic+geojson_json">geojson_json()</a></code>; see <code><a href="#topic+geojson_json">geojson_json()</a></code> for
help on what's supported here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>type</code> parameter is automatically converted to
<code>type="auto"</code> if a sf, sfc, or sfg class is passed to <code>input</code>
</p>


<h3>Value</h3>

<p>An object of class <code>geo_json</code> (and <code>json</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a numeric vector of length 2, making a point type
topojson_json(c(-99.74, 32.45), pretty = TRUE)
topojson_json(c(-99.74, 32.45), type = "GeometryCollection")

## polygon type
### this requires numeric class input, so inputting a list will dispatch on the list method
poly &lt;- c(
  c(-114.345703125, 39.436192999314095),
  c(-114.345703125, 43.45291889355468),
  c(-106.61132812499999, 43.45291889355468),
  c(-106.61132812499999, 39.436192999314095),
  c(-114.345703125, 39.436192999314095)
)
topojson_json(poly, geometry = "polygon", pretty = TRUE)

# Lists
## From a list of numeric vectors to a polygon
vecs &lt;- list(c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0), c(100.0, 0.0))
topojson_json(vecs, geometry = "polygon", pretty = TRUE)

## from a named list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
topojson_json(mylist, lat = "latitude", lon = "longitude")

# From a data.frame to points
topojson_json(us_cities[1:2, ], lat = "lat", lon = "long", pretty = TRUE)
topojson_json(us_cities[1:2, ],
  lat = "lat", lon = "long",
  type = "GeometryCollection", pretty = TRUE
)

# from data.frame to polygons
head(states)
## make list for input to e.g., rMaps
topojson_json(states[1:351, ], lat = "lat", lon = "long", geometry = "polygon", group = "group")

# from a geo_list
a &lt;- geojson_list(us_cities[1:2, ], lat = "lat", lon = "long")
topojson_json(a)

# sp classes

## From SpatialPolygons class
library("sp")
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
topojson_json(sp_poly)
topojson_json(sp_poly, pretty = TRUE)

## data.frame to geojson
geojson_write(us_cities[1:2, ], lat = "lat", lon = "long") %&gt;% as.json()

# From SpatialPoints class
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(3, 2, 5, 1, 4)
s &lt;- SpatialPoints(cbind(x, y))
topojson_json(s)

## From SpatialPointsDataFrame class
s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
topojson_json(s)

## From SpatialLines class
library("sp")
c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
L1 &lt;- Line(c1)
L2 &lt;- Line(c2)
L3 &lt;- Line(c3)
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
topojson_json(sl1)
topojson_json(sl12)

## From SpatialLinesDataFrame class
dat &lt;- data.frame(
  X = c("Blue", "Green"),
  Y = c("Train", "Plane"),
  Z = c("Road", "River"), row.names = c("a", "b")
)
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
topojson_json(sldf)
topojson_json(sldf, pretty = TRUE)

## From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
topojson_json(y)

## From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
topojson_json(sgdf)

# From SpatialPixels
library("sp")
pixels &lt;- suppressWarnings(SpatialPixels(SpatialPoints(us_cities[c("long", "lat")])))
summary(pixels)
topojson_json(pixels)

# From SpatialPixelsDataFrame
library("sp")
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(points = canada_cities[c("long", "lat")], data = canada_cities)
)
topojson_json(pixelsdf)

# From sf classes:
if (require(sf)) {
  ## sfg (a single simple features geometry)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  poly &lt;- rbind(c(1, 1), c(1, 2), c(2, 2), c(1, 1))
  poly_sfg &lt;- st_polygon(list(p1))
  topojson_json(poly_sfg)

  ## sfc (a collection of geometries)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  topojson_json(poly_sfc)

  ## sf (collection of geometries with attributes)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  poly_sf &lt;- st_sf(foo = c("a", "b"), bar = 1:2, poly_sfc)
  topojson_json(poly_sf)
}

## Pretty print a json string
topojson_json(c(-99.74, 32.45))
topojson_json(c(-99.74, 32.45)) %&gt;% pretty()

## End(Not run)
</code></pre>

<hr>
<h2 id='topojson_list'>Convert many input types with spatial data to TopoJSON
as a list</h2><span id='topic+topojson_list'></span>

<h3>Description</h3>

<p>Convert many input types with spatial data to TopoJSON
as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topojson_list(
  input,
  lat = NULL,
  lon = NULL,
  group = NULL,
  geometry = "point",
  type = "FeatureCollection",
  convert_wgs84 = FALSE,
  crs = NULL,
  object_name = "foo",
  quantization = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topojson_list_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class. Inputs can
also be dplyr <code>tbl_df</code> class since it inherits from <code>data.frame</code></p>
</td></tr>
<tr><td><code id="topojson_list_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_type">type</code></td>
<td>
<p>(character) The type of collection. One of FeatureCollection
(default) or GeometryCollection.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference system, using the WGS84 datum, with
longitude and latitude units of decimal degrees; EPSG: 4326).
Default is <code>FALSE</code> though this may change in a future package version.
This will only work for <code>sf</code> or <code>Spatial</code> objects with a CRS
already defined. If one is not defined but you know what it is, you
may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can
be an epsg code as a four or five digit integer or a valid proj4 string.
This argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code>
or the object already has a CRS.</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_object_name">object_name</code></td>
<td>
<p>(character) name to give to the TopoJSON object created.
Default: &quot;foo&quot;</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_quantization">quantization</code></td>
<td>
<p>(numeric) quantization parameter, use this to
quantize geometry prior to computing topology. Typical values are powers of
ten (<code>1e4</code>, <code>1e5</code>, ...), default is <code>0</code> to not perform quantization.
For more information about quantization, see this by Mike Bostock
https://stackoverflow.com/questions/18900022/topojson-quantization-vs-simplification/18921214#18921214</p>
</td></tr>
<tr><td><code id="topojson_list_+3A_...">...</code></td>
<td>
<p>args passed down through <code><a href="#topic+topojson_json">topojson_json()</a></code> to <code><a href="#topic+geojson_json">geojson_json()</a></code>;
see <code><a href="#topic+geojson_json">geojson_json()</a></code> for help on what's supported here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, we call <code><a href="#topic+topojson_json">topojson_json()</a></code>, then use
an internal function to convert that JSON output to a list
</p>
<p>The <code>type</code> parameter is automatically converted to
<code>type="auto"</code> if a sf, sfc, or sfg class is passed to <code>input</code>
</p>


<h3>Value</h3>

<p>a list with TopoJSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a numeric vector of length 2 to a point
vec &lt;- c(-99.74, 32.45)
topojson_list(vec)

# Lists
## From a list
mylist &lt;- list(
  list(latitude = 30, longitude = 120, marker = "red"),
  list(latitude = 30, longitude = 130, marker = "blue")
)
topojson_list(mylist)

## From a list of numeric vectors to a polygon
vecs &lt;- list(c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0), c(100.0, 0.0))
topojson_list(vecs, geometry = "polygon")

# from data.frame to points
(res &lt;- topojson_list(us_cities[1:2, ], lat = "lat", lon = "long"))
as.json(res)
## guess lat/long columns
topojson_list(us_cities[1:2, ])
topojson_list(states[1:3, ])
topojson_list(states[1:351, ], geometry = "polygon", group = "group")
topojson_list(canada_cities[1:30, ])

# from data.frame to polygons
head(states)
topojson_list(states[1:351, ], lat = "lat", lon = "long", geometry = "polygon", group = "group")

# From SpatialPolygons class
library("sp")
poly1 &lt;- Polygons(list(Polygon(cbind(
  c(-100, -90, -85, -100),
  c(40, 50, 45, 40)
))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(
  c(-90, -80, -75, -90),
  c(30, 40, 35, 30)
))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
topojson_list(sp_poly)

# From SpatialPolygonsDataFrame class
sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
topojson_list(input = sp_polydf)

# From SpatialPoints class
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(3, 2, 5, 1, 4)
s &lt;- SpatialPoints(cbind(x, y))
topojson_list(s)

# From SpatialPointsDataFrame class
s &lt;- SpatialPointsDataFrame(cbind(x, y), mtcars[1:5, ])
topojson_list(s)

# From SpatialLines class
library("sp")
c1 &lt;- cbind(c(1, 2, 3), c(3, 2, 2))
c2 &lt;- cbind(c1[, 1] + .05, c1[, 2] + .05)
c3 &lt;- cbind(c(1, 2, 3), c(1, 1.5, 1))
L1 &lt;- Line(c1)
L2 &lt;- Line(c2)
L3 &lt;- Line(c3)
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
topojson_list(sl1)
topojson_list(sl12)
as.json(topojson_list(sl12))
as.json(topojson_list(sl12), pretty = TRUE)

# From SpatialLinesDataFrame class
dat &lt;- data.frame(
  X = c("Blue", "Green"),
  Y = c("Train", "Plane"),
  Z = c("Road", "River"), row.names = c("a", "b")
)
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
topojson_list(sldf)
as.json(topojson_list(sldf))
as.json(topojson_list(sldf), pretty = TRUE)

# From SpatialGrid
x &lt;- GridTopology(c(0, 0), c(1, 1), c(5, 5))
y &lt;- SpatialGrid(x)
topojson_list(y)

# From SpatialGridDataFrame
sgdim &lt;- c(3, 4)
sg &lt;- SpatialGrid(GridTopology(rep(0, 2), rep(10, 2), sgdim))
sgdf &lt;- SpatialGridDataFrame(sg, data.frame(val = 1:12))
topojson_list(sgdf)

# From SpatialPixels
library("sp")
pixels &lt;- suppressWarnings(SpatialPixels(SpatialPoints(us_cities[c("long", "lat")])))
summary(pixels)
topojson_list(pixels)

# From SpatialPixelsDataFrame
library("sp")
pixelsdf &lt;- suppressWarnings(
  SpatialPixelsDataFrame(points = canada_cities[c("long", "lat")], data = canada_cities)
)
topojson_list(pixelsdf)


## End(Not run)

# From sf classes:
if (require(sf)) {
  ## sfg (a single simple features geometry)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  poly &lt;- rbind(c(1, 1), c(1, 2), c(2, 2), c(1, 1))
  poly_sfg &lt;- st_polygon(list(p1))
  topojson_list(poly_sfg)

  ## sfc (a collection of geometries)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  topojson_list(poly_sfc)

  ## sf (collection of geometries with attributes)
  p1 &lt;- rbind(c(0, 0), c(1, 0), c(3, 2), c(2, 4), c(1, 4), c(0, 0))
  p2 &lt;- rbind(c(5, 5), c(5, 6), c(4, 5), c(5, 5))
  poly_sfc &lt;- st_sfc(st_polygon(list(p1)), st_polygon(list(p2)))
  poly_sf &lt;- st_sf(foo = c("a", "b"), bar = 1:2, poly_sfc)
  topojson_list(poly_sf)
}

</code></pre>

<hr>
<h2 id='topojson_read'>Read topojson from a local file or a URL</h2><span id='topic+topojson_read'></span>

<h3>Description</h3>

<p>Read topojson from a local file or a URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topojson_read(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topojson_read_+3A_x">x</code></td>
<td>
<p>Path to a local file or a URL.</p>
</td></tr>
<tr><td><code id="topojson_read_+3A_...">...</code></td>
<td>
<p>Further args passed on to <code><a href="sf.html#topic+st_read">sf::st_read()</a></code>. Can use any args
from <code>sf::st_read()</code> except <code>quiet</code>, which we have set as <code>quiet = TRUE</code>
internally already</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a <code>sf</code> class, but you can easily and quickly get
this to geojson, see examples.
</p>
<p>Note that this does not give you Topojson, but gives you a <code>sf</code>
class - which you can use then to turn it into geojson as a list or json
</p>


<h3>Value</h3>

<p>an object of class <code>sf</code>/<code>data.frame</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geojson_read">geojson_read()</a></code>, <code><a href="#topic+topojson_write">topojson_write()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a file
file &lt;- system.file("examples", "us_states.topojson", package = "geojsonio")
topojson_read(file)

# From a URL
url &lt;- "https://raw.githubusercontent.com/shawnbot/d3-cartogram/master/data/us-states.topojson"
topojson_read(url)

# Use as.location first if you want
topojson_read(as.location(file))

# quickly convert to geojson as a list
file &lt;- system.file("examples", "us_states.topojson", package = "geojsonio")
tmp &lt;- topojson_read(file)
geojson_list(tmp)
geojson_json(tmp)

# pass on args
topojson_read(file, quiet = TRUE)
topojson_read(file, stringsAsFactors = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='topojson_write'>Write TopoJSON from various inputs</h2><span id='topic+topojson_write'></span>

<h3>Description</h3>

<p>Write TopoJSON from various inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topojson_write(
  input,
  lat = NULL,
  lon = NULL,
  geometry = "point",
  group = NULL,
  file = "myfile.topojson",
  overwrite = TRUE,
  precision = NULL,
  convert_wgs84 = FALSE,
  crs = NULL,
  object_name = "foo",
  quantization = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topojson_write_+3A_input">input</code></td>
<td>
<p>Input list, data.frame, spatial class, or sf class.
Inputs can  also be dplyr <code>tbl_df</code> class since it inherits
from <code>data.frame</code></p>
</td></tr>
<tr><td><code id="topojson_write_+3A_lat">lat</code></td>
<td>
<p>(character) Latitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_lon">lon</code></td>
<td>
<p>(character) Longitude name. The default is <code>NULL</code>, and we
attempt to guess.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_geometry">geometry</code></td>
<td>
<p>(character) One of point (Default) or polygon.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_group">group</code></td>
<td>
<p>(character) A grouping variable to perform grouping for
polygons - doesn't apply for points</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_file">file</code></td>
<td>
<p>(character) A path and file name (e.g., myfile), with the
<code>.geojson</code> file extension. Default writes to current working
directory.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) Overwrite the file given in <code>file</code> with
<code>input</code>. Default: <code>TRUE</code>. If this param is <code>FALSE</code> and
the file already exists, we stop with error message.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_precision">precision</code></td>
<td>
<p>desired number of decimal places for the coordinates in the
geojson file. Using fewer decimal places can decrease file sizes (at the
cost of precision).</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_convert_wgs84">convert_wgs84</code></td>
<td>
<p>Should the input be converted to the
standard CRS for GeoJSON (https://tools.ietf.org/html/rfc7946)
(geographic coordinate reference
system, using the WGS84 datum, with longitude and latitude units of decimal
degrees; EPSG: 4326). Default is <code>FALSE</code> though this may change in a
future package version. This will only work for <code>sf</code> or <code>Spatial</code>
objects with a CRS already defined. If one is not defined but you know what
it is, you may define it in the <code>crs</code> argument below.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_crs">crs</code></td>
<td>
<p>The CRS of the input if it is not already defined. This can be
an epsg code as a four or five digit integer or a valid proj4 string. This
argument will be ignored if <code>convert_wgs84</code> is <code>FALSE</code> or the
object already has a CRS.</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_object_name">object_name</code></td>
<td>
<p>(character) name to give to the TopoJSON object created.
Default: &quot;foo&quot;</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_quantization">quantization</code></td>
<td>
<p>(numeric) quantization parameter, use this to
quantize geometry prior to computing topology. Typical values are powers of
ten (<code>1e4</code>, <code>1e5</code>, ...), default is <code>0</code> to not perform quantization.
For more information about quantization, see this by Mike Bostock
https://stackoverflow.com/questions/18900022/topojson-quantization-vs-simplification/18921214#18921214</p>
</td></tr>
<tr><td><code id="topojson_write_+3A_...">...</code></td>
<td>
<p>Further args passed on to internal functions. For Spatial*
classes, data.frames,
regular lists, and numerics, it is passed through to
<code><a href="sf.html#topic+st_write">sf::st_write()</a></code>. For sf classes,
geo_lists and json classes, it is passed through to
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood we simply wrap <code><a href="#topic+geojson_write">geojson_write()</a></code>, then
take the GeoJSON output of that operation, then convert to TopoJSON with
<code><a href="#topic+geo2topo">geo2topo()</a></code>, then write to disk.
</p>
<p>Unfortunately, this process requires a number of round trips to disk, so
speed ups will hopefully come soon.
</p>
<p>Any intermediate geojson files are cleaned up (deleted).
</p>


<h3>Value</h3>

<p>A <code>topojson_write</code> class, with two elements:
</p>

<ul>
<li><p> path: path to the file with the TopoJSON
</p>
</li>
<li><p> type: type of object the TopoJSON came from, e.g., SpatialPoints
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geojson_write">geojson_write()</a></code>, <code><a href="#topic+topojson_read">topojson_read()</a></code>
</p>

<hr>
<h2 id='us_cities'>This is the same data set from the maps library, named differently</h2><span id='topic+us_cities'></span>

<h3>Description</h3>

<p>This database is of us cities of population greater than about 40,000.
Also included are state capitals of any population size.
</p>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;name&quot;, &quot;country.etc&quot;, &quot;pop&quot;,
&quot;lat&quot;, &quot;long&quot;, and &quot;capital&quot;, containing the city name, the state
abbreviation, approximate population (as at January 2006), latitude,
longitude and capital status indication (0 for non-capital, 1 for capital,
2 for state capital.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
