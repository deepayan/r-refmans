<!DOCTYPE html><html lang="en"><head><title>Help for package powerNLSEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {powerNLSEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FSR'><p>Factor Score Regression approach</p></a></li>
<li><a href='#LMS'><p>Latent moderated strctural equations by Klein and Moosbrugger (2000), the ML approach to nonlinear SEM</p></a></li>
<li><a href='#plot.powerNLSEM'><p>plot powerNLSEM object</p></a></li>
<li><a href='#power_search'><p>Search function to find N for desired power</p></a></li>
<li><a href='#powerNLSEM'><p>powerNLSEM function</p></a></li>
<li><a href='#print.powerNLSEM'><p>print powerNLSEM objects</p></a></li>
<li><a href='#print.summary.powerNLSEM'><p>print summary for powerNLSEM objects</p></a></li>
<li><a href='#reanalyse.powerNLSEM'><p>Reanalyse powerNLSEM object</p></a></li>
<li><a href='#simulateNLSEM'><p>simulate data from lavModel object</p></a></li>
<li><a href='#SR'><p>Scale Regression approach</p></a></li>
<li><a href='#summary.powerNLSEM'><p>Summary function for powerNLSEM objects</p></a></li>
<li><a href='#UPI'><p>Unconstrained Product Indicator approach by Marsh et al. (2004), with extensions by Kelava and Brandt (2009)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation-Based Power Estimation (MSPE) for Nonlinear SEM</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Patrick Irmer
    <a href="https://orcid.org/0000-0002-7544-6483"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Patrick Irmer &lt;jpirmer@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Model-implied simulation-based power estimation (MSPE) for
    nonlinear (and linear) SEM, path analysis and regression analysis. A
    theoretical framework is used to approximate the relation between
    power and sample size for given type I error rates and effect sizes.
    The package offers an adaptive search algorithm to find the optimal N for
    given effect sizes and type I error rates. Plots can be used to visualize
    the power relation to N for different parameters of interest (POI). 
    Theoretical justifications are given in Irmer et al. 
    (2024a) &lt;<a href="https://doi.org/10.31219%2Fosf.io%2Fpe5bj">doi:10.31219/osf.io/pe5bj</a>&gt; and detailed description
    are given in Irmer et al. (2024b) &lt;<a href="https://doi.org/10.3758%2Fs13428-024-02476-3">doi:10.3758/s13428-024-02476-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jpirmer/powerNLSEM">https://github.com/jpirmer/powerNLSEM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jpirmer/powerNLSEM/issues">https://github.com/jpirmer/powerNLSEM/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2, stats, utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, lavaan (&ge; 0.6.16), mvtnorm, numDeriv, pbapply, rlang
(&ge; 1.1.0), stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MplusAutomation (&ge; 0.7-2), rmarkdown, semTools,
simsem</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-27 07:05:15 UTC; irmer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-27 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FSR'>Factor Score Regression approach</h2><span id='topic+FSR'></span>

<h3>Description</h3>

<p>Factor Score Regression approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSR(lavModel_Analysis, data, FSmethod = "SL", data_transformations = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSR_+3A_lavmodel_analysis">lavModel_Analysis</code></td>
<td>
<p>the lavModel_Analysis object</p>
</td></tr>
<tr><td><code id="FSR_+3A_data">data</code></td>
<td>
<p>set to fit</p>
</td></tr>
<tr><td><code id="FSR_+3A_fsmethod">FSmethod</code></td>
<td>
<p>Method to be used to extract factor scores. Default to <code>"SL"</code> for the Skrondal and Laake approach that uses regression (<code>"regression"</code>) factor scores for the independendent variables and <code>"Bartlett"</code> factor scores for the dependent variables.</p>
</td></tr>
<tr><td><code id="FSR_+3A_data_transformations">data_transformations</code></td>
<td>
<p>Data transformations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> that includes parameter estimates estimated using FSR.
</p>


<h3>References</h3>

<p><strong>Similar to:</strong> Ng, J. C. K., &amp; Chan, W. (2020). Latent moderation analysis: A factor score approach. <em>Structural Equation Modeling: A Multidisciplinary Journal, 27</em>(4), 629–648. <a href="https://doi.org/10.1080/10705511.2019.1664304">doi:10.1080/10705511.2019.1664304</a>.
</p>
<p>Skrondal, A., &amp; Laake, P. (2001). Regression among factor scores. <em>Psychometrika, 66</em>(4), 563-575. <a href="https://doi.org/10.1007/BF02296196">doi:10.1007/BF02296196</a>
</p>

<hr>
<h2 id='LMS'>Latent moderated strctural equations by Klein and Moosbrugger (2000), the ML approach to nonlinear SEM</h2><span id='topic+LMS'></span>

<h3>Description</h3>

<p>Latent moderated strctural equations by Klein and Moosbrugger (2000), the ML approach to nonlinear SEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMS(
  lavModel_Analysis,
  data,
  data_transformations = NULL,
  prefix = 1,
  pathLMS = tempdir(),
  algorithm = "INTEGRATION"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMS_+3A_lavmodel_analysis">lavModel_Analysis</code></td>
<td>
<p>the lavModel_Analysis object</p>
</td></tr>
<tr><td><code id="LMS_+3A_data">data</code></td>
<td>
<p>set to fit</p>
</td></tr>
<tr><td><code id="LMS_+3A_data_transformations">data_transformations</code></td>
<td>
<p>Object containing info on possible data transformations.</p>
</td></tr>
<tr><td><code id="LMS_+3A_prefix">prefix</code></td>
<td>
<p>an arbitrary prefix for the data set. This prevents issues when using parallelization and Mplus.</p>
</td></tr>
<tr><td><code id="LMS_+3A_pathlms">pathLMS</code></td>
<td>
<p>path where (temporal) data and scripts for running LMS using Mplus are stored (using <code>MplusAutomation</code>). Default to <code>NULL</code>, then <code>tempdir()</code> is used.</p>
</td></tr>
<tr><td><code id="LMS_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm to use. Default to INTEGRATION.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> that includes parameter estimates estimated using LMS.
</p>


<h3>References</h3>

<p>Klein, A. G., &amp; Moosbrugger, H. (2000). Maximum likelihood estimation of latent interaction effects with the LMS method. <em>Psychometrika, 65</em>(4), 457–474. <a href="https://doi.org/10.1007/BF02296338">doi:10.1007/BF02296338</a>
</p>

<hr>
<h2 id='plot.powerNLSEM'>plot powerNLSEM object</h2><span id='topic+plot.powerNLSEM'></span>

<h3>Description</h3>

<p>plot powerNLSEM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerNLSEM'
plot(
  x,
  test = NULL,
  plot = "power_model",
  power_modeling_method = NULL,
  se = FALSE,
  power_aim = NULL,
  alpha = NULL,
  alpha_power_modeling = NULL,
  min_num_bins = 10,
  defaultgg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powerNLSEM_+3A_x">x</code></td>
<td>
<p>object of class powerNLSEM</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_test">test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>NULL</code>, then the same as in fitted <code>powerNLSEM</code> object in <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_plot">plot</code></td>
<td>
<p>Character indicating what type of plot to create. Default to <code>"power_model"</code>, referencing to the prediction of significant parameters using the model specified in <code>power_modeling_method</code>.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_power_modeling_method">power_modeling_method</code></td>
<td>
<p>Character indicating the power modeling method used. This is only relevant when <code>plot = "power_model"</code> is used. Default to <code>NULL</code>, indicating to use the same power modeling method as was used in the <code>powerNLSEM</code> function.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_se">se</code></td>
<td>
<p>Logical indicating to use confidence intervals based on normal approximation using the standard errors. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_power_aim">power_aim</code></td>
<td>
<p>Power level to be included into the plot with respective N. If <code>NULL</code> the same power level as in the <code>powerNLSEM</code> function will be used. If set to <code>0</code> no power level and corresponding N will be plotted. Default to <code>NULL</code>, indicating to use the same power modeling method as was used in the <code>powerNLSEM</code> function.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value used for confidence intervals, when <code>se = TRUE</code>. Default to <code>NULL</code>, indicating to use the same alpha as was used in the powerNLSEM function. This does not influence the significance decision, although same alpha is used per default.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_alpha_power_modeling">alpha_power_modeling</code></td>
<td>
<p>Type I-error rate for confidence band around predicted power rate. Used to ensure that the computed <code>N</code> keeps the desired power value (with the given Type I-error rate <code>alpha_power_modeling</code> divided by 2). If set to 1, no confidence band is used. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_min_num_bins">min_num_bins</code></td>
<td>
<p>minimal number of bins used for aggregating results. Default to 10.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_defaultgg">defaultgg</code></td>
<td>
<p>Logical to return default ggplot object. Default to <code>FALSE</code>, which returns <code>theme_minimal</code> and other changes in theme.</p>
</td></tr>
<tr><td><code id="plot.powerNLSEM_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>ggplot</code> object of the type specified in plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# write model in lavaan syntax
model &lt;- "
# measurement models
          X =~ 1*x1 + 0.8*x2 + 0.7*x3
          Y =~ 1*y1 + 0.85*y2 + 0.78*y3
          Z =~ 1*z1 + 0.9*z2 + 0.6*z3

# structural models
          Y ~ 0.3*X + .2*Z +  .2*X:Z

# residual variances
         Y~~.7975*Y
         X~~1*X
         Z~~1*Z

# covariances
         X~~0.5*Z

# measurement error variances
         x1~~.1*x1
         x2~~.2*x2
         x3~~.3*x3
         z1~~.2*z1
         z2~~.3*z2
         z3~~.4*z3
         y1~~.5*y1
         y2~~.4*y2
         y3~~.3*y3
"
# run model-implied simulation-based power estimation
# for the effects: c("Y~X", "Y~Z", "Y~X:Z")
Result_Power &lt;- powerNLSEM(model = model, POI = c("Y~X", "Y~Z", "Y~X:Z"),
                           method = "UPI", search_method = "adaptive",
                           steps = 10, power_modeling_method = "probit",
                           R = 1000, power_aim = .8, alpha = .05,
                           alpha_power_modeling = .05,
                           CORES = 1, seed = 2024)

Result_Power
plot(Result_Power)

</code></pre>

<hr>
<h2 id='power_search'>Search function to find N for desired power</h2><span id='topic+power_search'></span>

<h3>Description</h3>

<p>The function that initializes the search process. The <code>powerNLSEM</code> function actually is a wrapper function for <code>power_search</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_search(
  POI,
  method,
  lavModel,
  lavModel_Analysis,
  data_transformations,
  search_method,
  power_modeling_method,
  R = 1000,
  power_aim = 0.8,
  alpha = 0.05,
  alpha_power_modeling = 0.05,
  CORES,
  verbose,
  Ns = NULL,
  N_start = nrow(lavModel[lavModel$op != "~1", ]) * 10,
  distRj = "increasing",
  steps = 10,
  nlb = nrow(lavModel[lavModel$op != "~1", ]) * 5,
  switchStep = round(steps/2),
  FSmethod = "SL",
  test = "onesided",
  matchPI = TRUE,
  PIcentering = "doubleMC",
  liberalInspection = FALSE,
  constrainRelChange = TRUE,
  seeds,
  pathLMS = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_search_+3A_poi">POI</code></td>
<td>
<p>Parameter Of Interest as a vector of strings. Must be in lavaan-syntax without any spaces. Nonlinear effects should have the same ordering as in model.</p>
</td></tr>
<tr><td><code id="power_search_+3A_method">method</code></td>
<td>
<p>Method used to fit to the data. Can be LMS or UPI.</p>
</td></tr>
<tr><td><code id="power_search_+3A_lavmodel">lavModel</code></td>
<td>
<p>lavModel object describing the model.</p>
</td></tr>
<tr><td><code id="power_search_+3A_lavmodel_analysis">lavModel_Analysis</code></td>
<td>
<p>lavModel object containg the parameters to be estimated.</p>
</td></tr>
<tr><td><code id="power_search_+3A_data_transformations">data_transformations</code></td>
<td>
<p>Object containing info on data transformations.</p>
</td></tr>
<tr><td><code id="power_search_+3A_search_method">search_method</code></td>
<td>
<p>String stating the search method. Default to <code>"adaptive"</code> (synonyme is <code>"smart"</code>). Alternative is <code>"bruteforce"</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_power_modeling_method">power_modeling_method</code></td>
<td>
<p>Power modeling method used to model significant parameter estimates. Default to <code>"probit"</code> indicating glm with probit link function with sqrt(n) as predictor. Alternative is <code>"logit"</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_r">R</code></td>
<td>
<p>Total number of models to be fitted. Higher number results in higher precision and longer runtime.</p>
</td></tr>
<tr><td><code id="power_search_+3A_power_aim">power_aim</code></td>
<td>
<p>Minimal power value to approximate. Default to .8.</p>
</td></tr>
<tr><td><code id="power_search_+3A_alpha">alpha</code></td>
<td>
<p>Type I-error rate for significance decision. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_alpha_power_modeling">alpha_power_modeling</code></td>
<td>
<p>Type I-error rate for confidence band around predicted power rate. Used to ensure that the computed <code>N</code> keeps the desired power value (with the given Type I-error rate <code>alpha_power_modeling</code> divided by 2). If set to 1, no confidence band is used. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_cores">CORES</code></td>
<td>
<p>Number of cores used for parallelization. Default to number of available cores - 2.</p>
</td></tr>
<tr><td><code id="power_search_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether progress should be printed in console. Default to TRUE.</p>
</td></tr>
<tr><td><code id="power_search_+3A_ns">Ns</code></td>
<td>
<p>Sample sizes used in power estimation process. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_n_start">N_start</code></td>
<td>
<p>Starting sample size for smart algorithm. Default to  <code>10*nrow(lavModel[lavModel$op != "~1", ])</code> (10 times the number of parameters, excluding the mean structure, without the generation of e.g., factor scores or product indicators).</p>
</td></tr>
<tr><td><code id="power_search_+3A_distrj">distRj</code></td>
<td>
<p>Indicator how the samples sizes should be used in the steps of the smart algorithm: <code>"u"</code> for many to few to many, <code>"increasing"</code> for increasing replications and <code>"even"</code> for evenly distributed replications across steps. Default to <code>"u"</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_steps">steps</code></td>
<td>
<p>Steps used in <code>search_method = "smart"</code>, i.e., the smart algorithm. This is ignored if bruteforce is used. Default to 10.</p>
</td></tr>
<tr><td><code id="power_search_+3A_nlb">nlb</code></td>
<td>
<p>Lower bound of N used in search. Default to <code>5*nrow(lavModel[lavModel$op != "~1", ])</code> (5 times the number of parameters, excluding the mean structure, in the model without the generation of e.g., factor scores or product indicators), however, some methods can deal with much smaller sample sizes so this can be adjusted. The rule of thumb of 5 times number of parameters is motivated by Wolf et al. (2013)</p>
</td></tr>
<tr><td><code id="power_search_+3A_switchstep">switchStep</code></td>
<td>
<p>Steps after which smart search method changes from exploration to exploitation. Default to <code>round(steps/2)</code>. Exploration phase searches for the interval for N so that the resulting power is within <code>[.15, .85]</code> since the power curve is steepest at .5 and becomes less step towards plus/min <code>Inf</code>. Exploitation phase searches for an interval for N around the <code>power_aim</code> argument which shrinks from plus/minus .1 to .01. If <code>swicthStep = Inf</code>, then only exploration is used. If <code>switchStep</code> is used then the search process is reset at that point, which results in a new estimation in the bounds of the interval of N independent of the previous ones which might be restricted in change (see also argument( <code>constrainRelChange</code>).</p>
</td></tr>
<tr><td><code id="power_search_+3A_fsmethod">FSmethod</code></td>
<td>
<p>Method to be used to extract factor scores. Default to <code>"SL"</code> for the Skrondal and Laake approach that uses regression (<code>"regression"</code>) factor scores for the independendent variables and <code>"Bartlett"</code> factor scores for the dependent variables.</p>
</td></tr>
<tr><td><code id="power_search_+3A_test">test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>"onesided"</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_matchpi">matchPI</code></td>
<td>
<p>Logical passed to <code>semTools::indProd</code> in order to compute the product indicators: Specify TRUE to use match-paired approach (Marsh, Wen, &amp; Hau, 2004). If FALSE, the resulting products are all possible products. Default to <code>TRUE</code>. The observations are matched by order given when specifying the measurement model.</p>
</td></tr>
<tr><td><code id="power_search_+3A_picentering">PIcentering</code></td>
<td>
<p>String indicating which method of centering should be used when constructing product indicators. String is converted to the arguments <code>meanC</code>, <code>doubleMC</code>, and <code>residualMC</code>, of the <code>semTools::indProd</code> function. Default to <code>"doubleMC"</code> for double mean centering the resulting products (Lin et. al., 2010). Use <code>"meanC"</code> for mean centering the main effect indicator before making the products or <code>"residualC"</code> for residual centering the products by the main effect indicators (Little, Bovaird, &amp; Widaman, 2006). <code>"none"</code> or any other input than the previously described results in no centering (use with caution!).</p>
</td></tr>
<tr><td><code id="power_search_+3A_liberalinspection">liberalInspection</code></td>
<td>
<p>Logical whether the inspection of estimation truthworthiness should be very liberal (i.e., allowing for non-positive definite Hessians in standard error estimation or non-positive residual covariance matrices or latent covariance matrices). Default to <code>FALSE</code>. Being liberal is not adviced and should be checked for a single data set!</p>
</td></tr>
<tr><td><code id="power_search_+3A_constrainrelchange">constrainRelChange</code></td>
<td>
<p>Logical whether the change in the bounds of the interval for N using the smart algorithm should be constrained. This prevents divergence (which is especially an issue for small effect sizes and small <code>R</code>) but results in biased estimates if the number of steps is too small. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="power_search_+3A_seeds">seeds</code></td>
<td>
<p>Seeds for reproducibility.</p>
</td></tr>
<tr><td><code id="power_search_+3A_pathlms">pathLMS</code></td>
<td>
<p>path where (temporal) data and scripts for running LMS using Mplus are stored (using <code>MplusAutomation</code>). Default to <code>NULL</code>, then <code>tempdir()</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> that includes the results on model-implied simulation-based power estimation.
</p>


<h3>References</h3>

<p>Wolf, E. J., Harrington, K. M., Clark, S. L., &amp; Miller, M. W. (2013). Sample Size Requirements for Structural Equation Models: An Evaluation of Power, Bias, and Solution Propriety. <em>Educational and Psychological Measurement, 76</em>(6), 913–934. <a href="https://doi.org/10.1177/0013164413495237">doi:10.1177/0013164413495237</a>
</p>
<p>Irmer, J. P., Klein, A. G., &amp; Schermelleh-Engel, K. (2024).  <em>Behavior Research Methods, 0</em>(00), Advance Online Publication.
</p>

<hr>
<h2 id='powerNLSEM'>powerNLSEM function</h2><span id='topic+powerNLSEM'></span>

<h3>Description</h3>

<p>powerNLSEM function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerNLSEM(
  model,
  POI,
  method,
  test = "onesided",
  power_modeling_method = "probit",
  search_method = "adaptive",
  R = 2000,
  power_aim = 0.8,
  alpha = 0.05,
  alpha_power_modeling = 0.05,
  CORES = max(c(parallel::detectCores() - 2, 1)),
  verbose = TRUE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerNLSEM_+3A_model">model</code></td>
<td>
<p>Model in lavaan syntax. See documentation for help and examples.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_poi">POI</code></td>
<td>
<p>Parameter Of Interest as a vector of strings. Must be in lavaan-syntax without any spaces. Nonlinear effects should have the same ordering as in model.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_method">method</code></td>
<td>
<p>Method used to fit to the data. Implemented methods are <code>"LMS"</code> (Klein &amp; Moosbrugger, 2000) (requires an installation of <code>Mplus</code> and the <code>MplusAutomation</code> pacakge), <code>"UPI"</code> (Kelava &amp; Brandt, 2009, Marsh et al., 2004) for the unconstrained product indicator approach, <code>"FSR"</code> (Ng and Chan, 2020) for the naïve factor score approach, and <code>"SR"</code>, for using scale means (i.e., scale regression/path modeling).</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_test">test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>"onesided"</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_power_modeling_method">power_modeling_method</code></td>
<td>
<p>Power modeling method used to model significant parameter estimates. Default to <code>"probit"</code> indicating glm with probit link function with sqrt(n) as predictor. Alternative is <code>"logit"</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_search_method">search_method</code></td>
<td>
<p>String stating the search method. Default to <code>"adaptive"</code> (synonyme is <code>"smart"</code>). Alternative is <code>"bruteforce"</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_r">R</code></td>
<td>
<p>Total number of models to be fitted. Higher number results in higher precision and longer runtime. Default to 2000.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_power_aim">power_aim</code></td>
<td>
<p>Minimal power value to approximate. Default to <code>.8</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_alpha">alpha</code></td>
<td>
<p>Type I-error rate for significance decision. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_alpha_power_modeling">alpha_power_modeling</code></td>
<td>
<p>Type I-error rate for confidence band around predicted power rate. Used to ensure that the computed <code>N</code> keeps the desired power value (with the given Type I-error rate <code>alpha_power_modeling</code> divided by 2). If set to 1, no confidence band is used. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_cores">CORES</code></td>
<td>
<p>Number of cores used for parallelization. Default to number of available cores - 2.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether progress should be printed in console. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_seed">seed</code></td>
<td>
<p>Seed for replicability. Default to <code>NULL</code>, then a seed is drawn at random, which will also be saved in the output.</p>
</td></tr>
<tr><td><code id="powerNLSEM_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the search functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an list object of class <code>powerNLSEM</code>.
</p>


<h3>References</h3>

<p>Klein, A. G., &amp; Moosbrugger, H. (2000). Maximum likelihood estimation of latent interaction effects with the LMS method. <em>Psychometrika, 65</em>(4), 457–474. <a href="https://doi.org/10.1007/BF02296338">doi:10.1007/BF02296338</a>
</p>
<p>Kelava, A., &amp; Brandt, H. (2009). Estimation of nonlinear latent structural equation models using the extended unconstrained approach. <em>Review of Psychology, 16</em>(2), 123–132.
</p>
<p>Lin, G. C., Wen, Z., Marsh, H. W., &amp; Lin, H. S. (2010). Structural equation models of latent interactions: Clarification of orthogonalizing and double-mean-centering strategies. <em>Structural Equation Modeling, 17</em>(3), 374–391. <a href="https://doi.org/10.1080/10705511.2010.488999">doi:10.1080/10705511.2010.488999</a>
</p>
<p>Little, T. D., Bovaird, J. A., &amp; Widaman, K. F. (2006). On the merits of orthogonalizing powered and product terms: Implications for modeling interactions among latent variables. <em>Structural Equation Modeling, 13</em>(4), 497–519. <a href="https://doi.org/10.1207/s15328007sem1304_1">doi:10.1207/s15328007sem1304_1</a>
</p>
<p>Marsh, H. W., Wen, Z. &amp; Hau, K. T. (2004). Structural equation models of latent interactions: Evaluation of alternative estimation strategies and indicator construction. <em>Psychological Methods, 9</em>(3), 275–300. <a href="https://doi.org/10.1037/1082-989X.9.3.275">doi:10.1037/1082-989X.9.3.275</a>
</p>
<p>Ng, J. C. K., &amp; Chan, W. (2020). Latent moderation analysis: A factor score approach. <em>Structural Equation Modeling: A Multidisciplinary Journal, 27</em>(4), 629–648. <a href="https://doi.org/10.1080/10705511.2019.1664304">doi:10.1080/10705511.2019.1664304</a>.
</p>
<p>Irmer, J. P., Klein, A. G., &amp; Schermelleh-Engel, K. (2024a). A General Model-Implied Simulation-Based Power Estimation Method for Correctly and Misspecfied Models: Applications to Nonlinear and Linear Structural Equation Models. <em>Behavior Research Methods.</em>  <a href="https://doi.org/10.31219/osf.io/pe5bj">doi:10.31219/osf.io/pe5bj</a>
</p>
<p>Irmer, J. P., Klein, A. G., &amp; Schermelleh-Engel, K. (2024b). Estimating Power in Complex Nonlinear Structural Equation Modeling Including Moderation Effects: The <code style="white-space: pre;">&#8288;powerNLSEM R&#8288;</code>-Package. <em>Behavior Research Methods.</em> <a href="https://doi.org/10.3758/s13428-024-02476-3">doi:10.3758/s13428-024-02476-3</a>
</p>


<h3>See Also</h3>

<p>For further details for specific uses see corresponding functions: <code><a href="#topic+power_search">power_search()</a></code> for all inputs possible, <code><a href="#topic+UPI">UPI()</a></code> for specifics for the unconstrained product indicator approach, <code><a href="#topic+LMS">LMS()</a></code> for the latent moderated structural equations approach, <code><a href="#topic+FSR">FSR()</a></code> for factor score approaches, <code><a href="#topic+SR">SR()</a></code> for scale regression approaches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# write model in lavaan syntax
model &lt;- "
# measurement models
          X =~ 1*x1 + 0.8*x2 + 0.7*x3
          Y =~ 1*y1 + 0.85*y2 + 0.78*y3
          Z =~ 1*z1 + 0.9*z2 + 0.6*z3

# structural models
          Y ~ 0.3*X + .2*Z +  .2*X:Z

# residual variances
         Y~~.7975*Y
         X~~1*X
         Z~~1*Z

# covariances
         X~~0.5*Z

# measurement error variances
         x1~~.1*x1
         x2~~.2*x2
         x3~~.3*x3
         z1~~.2*z1
         z2~~.3*z2
         z3~~.4*z3
         y1~~.5*y1
         y2~~.4*y2
         y3~~.3*y3
"
# run model-implied simulation-based power estimation
# for the effects: c("Y~X", "Y~Z", "Y~X:Z")
Result_Power &lt;- powerNLSEM(model = model, POI = c("Y~X", "Y~Z", "Y~X:Z"),
                           method = "UPI", search_method = "adaptive",
                           steps = 10, power_modeling_method = "probit",
                           R = 1000, power_aim = .8, alpha = .05,
                           alpha_power_modeling = .05,
                           CORES = 1, seed = 2024)

Result_Power


</code></pre>

<hr>
<h2 id='print.powerNLSEM'>print powerNLSEM objects</h2><span id='topic+print.powerNLSEM'></span>

<h3>Description</h3>

<p>print powerNLSEM objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerNLSEM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.powerNLSEM_+3A_x">x</code></td>
<td>
<p>object of class powerNLSEM</p>
</td></tr>
<tr><td><code id="print.powerNLSEM_+3A_...">...</code></td>
<td>
<p>Additional parameters for print</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>powerNLSEM</code> object
</p>

<hr>
<h2 id='print.summary.powerNLSEM'>print summary for powerNLSEM objects</h2><span id='topic+print.summary.powerNLSEM'></span>

<h3>Description</h3>

<p>print summary for powerNLSEM objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.powerNLSEM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.powerNLSEM_+3A_x">x</code></td>
<td>
<p>Prints the summary of a <code>powerNLSEM</code> object. <code>x</code> must be of class <code>"summary.powerNLSEM"</code>.</p>
</td></tr>
<tr><td><code id="print.summary.powerNLSEM_+3A_...">...</code></td>
<td>
<p>Further arguments to use in <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints output of summmary of <code>powerNLSEM</code> object into the console (objects of class <code>summary.powerNLSEM</code>), but does not change object itself.
</p>

<hr>
<h2 id='reanalyse.powerNLSEM'>Reanalyse powerNLSEM object</h2><span id='topic+reanalyse.powerNLSEM'></span>

<h3>Description</h3>

<p>Reanalyse powerNLSEM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reanalyse.powerNLSEM(
  out,
  test = NULL,
  powerLevels = NULL,
  power_modeling_method = NULL,
  alpha = NULL,
  alpha_power_modeling = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reanalyse.powerNLSEM_+3A_out">out</code></td>
<td>
<p>object of class powerNLSEM</p>
</td></tr>
<tr><td><code id="reanalyse.powerNLSEM_+3A_test">test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>NULL</code>, then the same as in fitted <code>powerNLSEM</code> object is used.</p>
</td></tr>
<tr><td><code id="reanalyse.powerNLSEM_+3A_powerlevels">powerLevels</code></td>
<td>
<p>Power levels for which the desired sample sizes should be computed. Needs to be a vector. Default to <code>NULL</code> indicating to use same power rate used in <code>powerNLSEM</code> object.</p>
</td></tr>
<tr><td><code id="reanalyse.powerNLSEM_+3A_power_modeling_method">power_modeling_method</code></td>
<td>
<p>Character indicating the power modeling method used. Default to <code>NULL</code>, indicating to use the same power modeling method as was used in the <code>powerNLSEM</code> object.</p>
</td></tr>
<tr><td><code id="reanalyse.powerNLSEM_+3A_alpha">alpha</code></td>
<td>
<p>Type I-error rate for significance decision. Default to <code>.05</code>.</p>
</td></tr>
<tr><td><code id="reanalyse.powerNLSEM_+3A_alpha_power_modeling">alpha_power_modeling</code></td>
<td>
<p>Type I-error rate for confidence band around predicted power rate. Used to ensure that the computed <code>N</code> keeps the desired power value (with the given Type I-error rate <code>alpha_power_modeling</code> divided by 2). If set to 1, no confidence band is used. Default to <code>.05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of desired sample sizes per effect for each <code>powerLevel</code>. <code>Nall</code> refers to the sample size required per power level for all coefficients. <code>Npower</code> is a matrix containing the desired sample sizes per effect for every power level.
</p>

<hr>
<h2 id='simulateNLSEM'>simulate data from lavModel object</h2><span id='topic+simulateNLSEM'></span>

<h3>Description</h3>

<p>simulate data from lavModel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateNLSEM(
  n,
  lavModel,
  appendLVs = FALSE,
  lavModel_attributes = NULL,
  matrices = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateNLSEM_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simulateNLSEM_+3A_lavmodel">lavModel</code></td>
<td>
<p>lavModel object</p>
</td></tr>
<tr><td><code id="simulateNLSEM_+3A_appendlvs">appendLVs</code></td>
<td>
<p>logical whether latent variables should be observed. Default to <code>FALSE</code>. (For developmental purposes)</p>
</td></tr>
<tr><td><code id="simulateNLSEM_+3A_lavmodel_attributes">lavModel_attributes</code></td>
<td>
<p>attributes of the lavModel object. If <code>NULL</code>, this is computed from lavModel. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulateNLSEM_+3A_matrices">matrices</code></td>
<td>
<p>computed matrices for simulation. If <code>NULL</code>, this is computed from lavModel and lavModel_attributes. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulateNLSEM_+3A_seed">seed</code></td>
<td>
<p>a seed for reproducability. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> of a simulated NLSEM.
</p>

<hr>
<h2 id='SR'>Scale Regression approach</h2><span id='topic+SR'></span>

<h3>Description</h3>

<p>Scale Regression approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SR(lavModel_Analysis, data, data_transformations = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SR_+3A_lavmodel_analysis">lavModel_Analysis</code></td>
<td>
<p>the lavModel_Analysis object</p>
</td></tr>
<tr><td><code id="SR_+3A_data">data</code></td>
<td>
<p>set to fit</p>
</td></tr>
<tr><td><code id="SR_+3A_data_transformations">data_transformations</code></td>
<td>
<p>Data transformations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> that includes parameter estimates estimated using SR.
</p>

<hr>
<h2 id='summary.powerNLSEM'>Summary function for powerNLSEM objects</h2><span id='topic+summary.powerNLSEM'></span>

<h3>Description</h3>

<p>Summary function for powerNLSEM objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerNLSEM'
summary(object, test = NULL, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.powerNLSEM_+3A_object">object</code></td>
<td>
<p>Result of powerNLSEM function estimating the MSPE. <code>object</code> must be of class <code>"powerNLSEM"</code>.</p>
</td></tr>
<tr><td><code id="summary.powerNLSEM_+3A_test">test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>NULL</code> (if <code>NULL</code>, <code>test</code> of the original MSPE is used).</p>
</td></tr>
<tr><td><code id="summary.powerNLSEM_+3A_alpha">alpha</code></td>
<td>
<p>Type I-error rate for significance decision. Default to <code>NULL</code> (if <code>NULL</code>, <code>alpha</code> of the original MSPE is used).</p>
</td></tr>
<tr><td><code id="summary.powerNLSEM_+3A_...">...</code></td>
<td>
<p>Further arguments to use in <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary of powerNLSEM object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# write model in lavaan syntax
model &lt;- "
# measurement models
          X =~ 1*x1 + 0.8*x2 + 0.7*x3
          Y =~ 1*y1 + 0.85*y2 + 0.78*y3
          Z =~ 1*z1 + 0.9*z2 + 0.6*z3

# structural models
          Y ~ 0.3*X + .2*Z +  .2*X:Z

# residual variances
         Y~~.7975*Y
         X~~1*X
         Z~~1*Z

# covariances
         X~~0.5*Z

# measurement error variances
         x1~~.1*x1
         x2~~.2*x2
         x3~~.3*x3
         z1~~.2*z1
         z2~~.3*z2
         z3~~.4*z3
         y1~~.5*y1
         y2~~.4*y2
         y3~~.3*y3
"
# run model-implied simulation-based power estimation
# for the effects: c("Y~X", "Y~Z", "Y~X:Z")
Result_Power &lt;- powerNLSEM(model = model, POI = c("Y~X", "Y~Z", "Y~X:Z"),
                           method = "UPI", search_method = "adaptive",
                           steps = 10, power_modeling_method = "probit",
                           R = 1000, power_aim = .8, alpha = .05,
                           alpha_power_modeling = .05,
                           CORES = 1, seed = 2024)

Result_Power
summary(Result_Power)

</code></pre>

<hr>
<h2 id='UPI'>Unconstrained Product Indicator approach by Marsh et al. (2004), with extensions by Kelava and Brandt (2009)</h2><span id='topic+UPI'></span>

<h3>Description</h3>

<p>Unconstrained Product Indicator approach by Marsh et al. (2004), with extensions by Kelava and Brandt (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPI(
  lavModel_Analysis,
  data,
  data_transformations = NULL,
  matchPI = TRUE,
  PIcentering = "doubleMC",
  liberalInspection = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UPI_+3A_lavmodel_analysis">lavModel_Analysis</code></td>
<td>
<p>the lavModel_Analysis object</p>
</td></tr>
<tr><td><code id="UPI_+3A_data">data</code></td>
<td>
<p>set to fit</p>
</td></tr>
<tr><td><code id="UPI_+3A_data_transformations">data_transformations</code></td>
<td>
<p>Data transformations</p>
</td></tr>
<tr><td><code id="UPI_+3A_matchpi">matchPI</code></td>
<td>
<p>Logical passed to <code>semTools::indProd</code> in order to compute the product indicators: Specify TRUE to use match-paired approach (Marsh, Wen, &amp; Hau, 2004). If FALSE, the resulting products are all possible products. Default to <code>TRUE</code>. The observations are matched by order given when specifying the measurement model.</p>
</td></tr>
<tr><td><code id="UPI_+3A_picentering">PIcentering</code></td>
<td>
<p>String indicating which method of centering should be used when constructing product indicators. String is converted to the arguments <code>meanC</code>, <code>doubleMC</code>, and <code>residualMC</code>, of the <code>semTools::indProd</code> function. Default to <code>"doubleMC"</code> for double mean centering the resulting products (Lin et. al., 2010). Use <code>"meanC"</code> for mean centering the main effect indicator before making the products or <code>"residualC"</code> for residual centering the products by the main effect indicators (Little, Bovaird, &amp; Widaman, 2006). <code>"none"</code> or any other input than the previously described results in no centering (use with caution!).</p>
</td></tr>
<tr><td><code id="UPI_+3A_liberalinspection">liberalInspection</code></td>
<td>
<p>Logical whether the inspection of estimation truthworthiness should be very liberal (i.e., allowing for non-positive definite Hessians in standard error estimation or non-positive residual covariance matrices or latent covariance matrices). Default to <code>FALSE</code>. Being liberal is not adviced and should be checked for a single data set!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> that includes parameter estimates estimated using UPI.
</p>


<h3>References</h3>

<p>Kelava, A., &amp; Brandt, H. (2009). Estimation of nonlinear latent structural equation models using the extended unconstrained approach. <em>Review of Psychology, 16</em>(2), 123–132.
</p>
<p>Lin, G. C., Wen, Z., Marsh, H. W., &amp; Lin, H. S. (2010). Structural equation models of latent interactions: Clarification of orthogonalizing and double-mean-centering strategies. <em>Structural Equation Modeling, 17</em>(3), 374–391. <a href="https://doi.org/10.1080/10705511.2010.488999">doi:10.1080/10705511.2010.488999</a>
</p>
<p>Little, T. D., Bovaird, J. A., &amp; Widaman, K. F. (2006). On the merits of orthogonalizing powered and product terms: Implications for modeling interactions among latent variables. <em>Structural Equation Modeling, 13</em>(4), 497–519. <a href="https://doi.org/10.1207/s15328007sem1304_1">doi:10.1207/s15328007sem1304_1</a>
</p>
<p>Marsh, H. W., Wen, Z. &amp; Hau, K. T. (2004). Structural equation models of latent interactions: Evaluation of alternative estimation strategies and indicator construction. <em>Psychological Methods, 9</em>(3), 275–300. <a href="https://doi.org/10.1037/1082-989X.9.3.275">doi:10.1037/1082-989X.9.3.275</a>
</p>
<p>Marsh, H. W.,  Wen, Z., Hau, K. T., Little, T. D., Bovaird, J. A., &amp; Widaman, K. F. (2007). Unconstrained Structural Equation Models of Latent Interactions: Contrasting Residual- and Mean-Centered Approaches. <em>Structural Equation Modeling: A Multidisciplinary Journal, 14</em>(4), 570-580. <a href="https://doi.org/10.1080/10705510701303921">doi:10.1080/10705510701303921</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
