<!DOCTYPE html><html><head><title>Help for package domir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {domir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#domir-package'><p>Tools to Support Relative Importance Analysis</p></a></li>
<li><a href='#domin'><p>Dominance analysis supporting <code>formula</code>-based modeling functions</p></a></li>
<li><a href='#dominance_scalar'><p>Scalar-returning internal dominance analysis meta-function</p></a></li>
<li><a href='#domir'><p>Dominance analysis methods</p></a></li>
<li><a href='#fmllst2Fml'><p>Translate <code>formula_list</code> into <code>Formula::Formula</code></p></a></li>
<li><a href='#formula_list'><p>A <code>list</code> composed of <code>formulas</code></p></a></li>
<li><a href='#formula_parse'><p>Internal formula parsing function</p></a></li>
<li><a href='#print.domin'><p>Print method for <code>domin</code></p></a></li>
<li><a href='#print.domir'><p>Print method for <code>domir</code></p></a></li>
<li><a href='#summary.domin'><p>Summary method for <code>domin</code></p></a></li>
<li><a href='#summary.domir'><p>Summary method for <code>domir</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools to Support Relative Importance Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-1</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to apply decomposition-based relative importance 
  analysis for R functions. This package supports the application of 
  decomposition methods by providing 'lapply'- or 'Map'-like meta-functions that 
  compute dominance analysis (Azen, R., &amp; Budescu, D. V. (2003) 
  &lt;<a href="https://doi.org/10.1037%2F1082-989X.8.2.129">doi:10.1037/1082-989X.8.2.129</a>&gt;; Grömping, U. (2007) 
  &lt;<a href="https://doi.org/10.1198%2F000313007X188252">doi:10.1198/000313007X188252</a>&gt;) or Shapley value regression 
  (Lipovetsky, S., &amp; Conklin, M. (2001) &lt;<a href="https://doi.org/10.1002%2Fasmb.446">doi:10.1002/asmb.446</a>&gt;)
  based on the values returned from other functions.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, forcats, Formula, ggplot2, knitr, lme4, parameters,
performance, pscl, purrr, relaimpo, rlang, rmarkdown, stringr,
systemfit, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jluchman/domir">https://github.com/jluchman/domir</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jluchman/domir/issues">https://github.com/jluchman/domir/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-01 20:48:12 UTC; josephluchman</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Luchman <a href="https://orcid.org/0000-0002-8886-9717"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Luchman &lt;jluchman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-01 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='domir-package'>Tools to Support Relative Importance Analysis</h2><span id='topic+domir-package'></span>

<h3>Description</h3>

<p>Methods to apply dominance analysis-based relative importance analysis for
predictive modeling functions.
</p>


<h3>Details</h3>

<p>This package supports relative importance analysis by implementing several
functions that compute dominance analysis (Azen &amp; Budescu, 2004;
Budescu, 1993). Dominance analysis produces the well-known Shapley value
decomposition (e.g., Grömping, 2007; Lipovetsky &amp; Conklin, 2001) as one
of its methods called general dominance statistics.
</p>
<p>Dominance analysis is a method for determining the relative importance of
inputs (i.e., independent variables, predictors, features,
parameter estimates) to a predictive model that evaluates how a returned
value, such as a model fit metric or statistic, is associated with each
input. It is also a common, and generally well accepted, method for
determining the relative importance of inputs to predictive models that
is effective at separating the effects of correlated inputs.
</p>


<h3>Author(s)</h3>

<p>Joseph Luchman <a href="mailto:jluchman@gmail.com">jluchman@gmail.com</a>
</p>


<h3>References</h3>


<ul>
<li><p> Azen, R., &amp; Budescu, D. V. (2003). The dominance analysis approach
for comparing predictors in multiple regression. Psychological Methods,
8(2), 129-148. doi:10.1037/1082-989X.8.2.129
</p>
</li>
<li><p> Budescu, D. V. (1993). Dominance analysis: A new approach to the
problem of relative importance of predictors in multiple regression.
Psychological Bulletin, 114(3), 542-551. doi:10.1037/0033-2909.114.3.542
</p>
</li>
<li><p> Grömping, U. (2007). Estimators of relative importance in linear
regression based on variance decomposition. The American Statistician,
61(2), 139-147. doi:10.1198/000313007X188252
</p>
</li>
<li><p> Lipovetsky, S, &amp; and Conklin, M. (2001). Analysis of regression in
game theory approach. Applied Stochastic Models in Business and Industry,
17(4), 319-330. doi:10.1002/asmb.446
</p>
</li></ul>


<hr>
<h2 id='domin'>Dominance analysis supporting <code>formula</code>-based modeling functions</h2><span id='topic+domin'></span>

<h3>Description</h3>

<p>Computes dominance statistics for predictive modeling functions that accept a <code><a href="stats.html#topic+formula">formula</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domin(
  formula_overall,
  reg,
  fitstat,
  sets = NULL,
  all = NULL,
  conditional = TRUE,
  complete = TRUE,
  consmodel = NULL,
  reverse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domin_+3A_formula_overall">formula_overall</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code> or that can be coerced to class <code>formula</code> for use in the modeling function in <code>reg</code>.  The <code><a href="stats.html#topic+terms">terms</a></code> on the right hand side of this formula are used as separate entries to the dominance analysis.
</p>
<p>A valid <code>formula_overall</code> entry is necessary, even if only submitting entries in <code>sets</code>, to define a valid left hand side of the prediction equation (see examples).  The function called in <code>reg</code> must accept one or more responses on the left hand side.</p>
</td></tr>
<tr><td><code id="domin_+3A_reg">reg</code></td>
<td>
<p>A function implementing the predictive (or &quot;reg&quot;ression) model called.
</p>
<p>String function names (e.g., &quot;lm&quot;), function names (e.g., <code>lm</code>), or anonymous functions (e.g., <code>function(x) lm(x)</code>) are acceptable entries.  This argument's contents are passed to <code><a href="base.html#topic+do.call">do.call</a></code> and thus any function call <code>do.call</code> would accept is valid.
</p>
<p>The predictive model in <code>reg</code> must accept a <code>formula</code> object as its first argument or must be adapted to do so with a wrapper function.</p>
</td></tr>
<tr><td><code id="domin_+3A_fitstat">fitstat</code></td>
<td>
<p>List providing arguments to call a fit statistic extracting function (see details). The <code>fitstat</code> list must be of at least length two.
</p>
<p>The first element of <code>fitstat</code> must be a function implementing the fit statistic extraction. String function names (e.g., &quot;summary&quot;), function names (e.g., <code>summary</code>), or anonymous functions (e.g., <code>function(x) summary(x)</code>) are acceptable entries. This element's contents are passed to <code><a href="base.html#topic+do.call">do.call</a></code> and thus any function call <code>do.call</code> would accept is valid.
</p>
<p>The second element of <code>fitstat</code> must be the named element of the list or vector produced by the fit extractor function called in the first element of <code>fitstat</code>.  This element must be a string (e.g., &quot;r.squared&quot;).
</p>
<p>All list elements beyond the second are submitted as additional arguments to the fit extractor function call.
</p>
<p>The fit statistic extractor function in the first list element of <code>fitstat</code> must accept the model object produced by the predictive modeling function in <code>reg</code> as its first argument or be adapted to do so with a wrapper function.
</p>
<p>The fit statistic produced must be scalar valued (i.e., vector of length 1).</p>
</td></tr>
<tr><td><code id="domin_+3A_sets">sets</code></td>
<td>
<p>A list with each element comprised of vectors containing variable/factor names or <code>formula</code> coercible strings.
</p>
<p>Each separate list element-vector in <code>sets</code> is concatenated (when the list element-vector is of length &gt; 1) and used as an entry to the dominance analysis along with the terms in <code>formula_overall</code>.</p>
</td></tr>
<tr><td><code id="domin_+3A_all">all</code></td>
<td>
<p>A vector of variable/factor names or <code>formula</code> coercible strings.  The entries in this vector are concatenated (when of length &gt; 1) but are not used in the dominance analysis.  Rather the value of the fit statistic associated with these terms is removed from the dominance analysis; this vector is used like a set of covariates.
</p>
<p>The entries in <code>all</code> are removed from and considered an additional component that explains the fit metric.  As a result, the general dominance statistics will no longer sum to the overall fit metric and the standardized vector will no longer sum to 1.</p>
</td></tr>
<tr><td><code id="domin_+3A_conditional">conditional</code></td>
<td>
<p>Logical.  If <code>FALSE</code> then conditional dominance matrix is not computed.
</p>
<p>If conditional dominance is not desired as an importance criterion, avoiding computing the conditional dominance matrix can save computation time.</p>
</td></tr>
<tr><td><code id="domin_+3A_complete">complete</code></td>
<td>
<p>Logical.  If <code>FALSE</code> then complete dominance matrix is not computed.
</p>
<p>If complete dominance is not desired as an importance criterion, avoiding computing complete dominance designations can save computation time.</p>
</td></tr>
<tr><td><code id="domin_+3A_consmodel">consmodel</code></td>
<td>
<p>A vector of variable/factor names, <code>formula</code> coercible strings, or other formula terms (i.e., 1 to indicate an intercept).  The entries in this vector are concatenated (when of length &gt; 1) and, like the entries of <code>all</code>, are not used in the dominance analysis; this vector is used as an adjustment to the baseline value of the overall fit statistic.
</p>
<p>The use of <code>consmodel</code> changes the interpretation of the the general and conditional dominance statistics.  When <code>consmodel</code> is used, the general and conditional dominance statistics are reflect the difference between the constant model and the overall fit statistic values.
</p>
<p>Typical usage of <code>consmodel</code> is to pass &quot;1&quot; to set the intercept as the baseline and control for its value when the baseline model's fit statistic value is not 0 (e.g., if using the AIC or BIC as a fit statistic; see examples).
</p>
<p>As such, this vector is used to set a baseline for the fit statistic when it is non-0.</p>
</td></tr>
<tr><td><code id="domin_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code> then standardized vector, ranks, and complete dominance designations are reversed in their interpretation.
</p>
<p>This argument should be changed to <code>TRUE</code> if the fit statistic used decreases with better fit to the data (e.g., AIC, BIC).</p>
</td></tr>
<tr><td><code id="domin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function call in the <code>reg</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>domin</code> automates the computation of all possible combination of entries to the dominance analysis (DA), the creation of <code>formula</code> objects based on those entries, the modeling calls/fit statistic capture, and the computation of all the dominance statistics for the user.
</p>
<p><code>domin</code> accepts only a &quot;deconstructed&quot; set of inputs and &quot;reconstructs&quot; them prior to formulating a coherent predictive modeling call.
</p>
<p>One specific instance of this deconstruction is in generating the number of entries to the DA. The number of entries is taken as all the <code>terms</code> from <code>formula_overall</code> and the separate list element vectors from <code>sets</code>. The entries themselves are concatenated into a single formula, combined with the entries in <code>all</code>, and submitted to the predictive modeling function in <code>reg</code>.  Each different combination of entries to the DA forms a different <code>formula</code> and thus a different model to estimate.
</p>
<p>For example, consider this <code>domin</code> call:
</p>
<p><code>domin(y ~ x1 + x2, lm, list(summary, "r.squared"), sets = list(c("x3", "x4")), all = c("c1", "c2"), data = mydata))</code>
</p>
<p>This call records three entries and results in seven (i.e., <code class="reqn">2^3 - 1</code>) different combinations:
</p>

<ol>
<li><p> x1
</p>
</li>
<li><p> x2
</p>
</li>
<li><p> x3, x4
</p>
</li>
<li><p> x1, x2
</p>
</li>
<li><p> x1, x3, x4
</p>
</li>
<li><p> x2, x3, x4
</p>
</li>
<li><p> x1, x2, x3, x4
</p>
</li></ol>

<p><code>domin</code> parses <code>formula_overall</code> to obtain all the terms in it and combines them with <code>sets</code>.  When parsing <code>formula_overall</code>, only the processing that is available in the <code>stats</code> package is applied.  Note that <code>domin</code> is not programmed to process terms of order &gt; 1 (i.e., interactions/products) appropriately (i.e., only include in the presence of lower order component terms). <code>domin</code> also does not allow <code>offset</code> terms.
</p>
<p>From these combinations, the predictive models are constructed and called. The predictive model call includes the entries in <code>all</code>, applies the appropriate formula, and reconstructs the function itself. The seven combinations above imply the following series of predictive model calls:
</p>

<ol>
<li> <p><code>lm(y ~ x1 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x2 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x3 + x4 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x1 + x2 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x1 + x3 + x4 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x2 + x3 + x4 + c1 + c2, data = mydata</code>)
</p>
</li>
<li> <p><code>lm(y ~ x1 + x2 + x3 + x4 + c1 + c2, data = mydata</code>)
</p>
</li></ol>

<p>It is possible to use a <code>domin</code> with only sets (i.e., no IVs in <code>formula_overall</code>; see examples below). There must be at least two entries to the DA for <code>domin</code> to run.
</p>
<p>All the called predictive models are submitted to the fit extractor function implied by the entries in <code>fitstat</code>. Again applying the example above, all seven predictive models' objects would be individually passed as follows:
</p>
<p><code>summary(lm_obj)["r.squared"]</code>
</p>
<p>where <code>lm_obj</code> is the model object returned by <code>lm</code>.
</p>
<p>The entries to <code>fitstat</code> must be as a list and follow a specific structure:
<code>list(fit_function, element_name, ...)</code>
</p>

<dl>
<dt><code>fit_function</code></dt><dd><p>First element and function to be applied to the object produced by the <code>reg</code> function</p>
</dd>
<dt><code>element_name</code></dt><dd><p>Second element and name of the element from the object returned by <code>fit_function</code> to be used as a fit statistic.  The fit statistic must be scalar-valued/length 1</p>
</dd>
<dt><code>...</code></dt><dd><p>Subsequent elements and are additional arguments passed to <code>fit_function</code></p>
</dd>
</dl>

<p>In the case that the model object returned by <code>reg</code> includes its own fit statistic without the need for an extractor function, the user can apply an anonymous function following the required format to extract it.
</p>


<h3>Value</h3>

<p>Returns an object of <code><a href="base.html#topic+class">class</a></code> &quot;domin&quot;.
An object of class &quot;domin&quot; is a list composed of the following elements:
</p>

<dl>
<dt><code>General_Dominance</code></dt><dd><p>Vector of general dominance statistics.</p>
</dd>
<dt><code>Standardized</code></dt><dd><p>Vector of general dominance statistics normalized to sum to 1.</p>
</dd>
<dt><code>Ranks</code></dt><dd><p>Vector of ranks applied to the general dominance statistics.</p>
</dd>
<dt><code>Conditional_Dominance</code></dt><dd><p>Matrix of conditional dominance statistics.  Each row represents a term; each column represents an order of terms.</p>
</dd>
<dt><code>Complete_Dominance</code></dt><dd><p>Logical matrix of complete dominance designations. The term represented in each row indicates dominance status; the terms represented in each columns indicates dominated-by status.</p>
</dd>
<dt><code>Fit_Statistic_Overall</code></dt><dd><p>Value of fit statistic for the full model.</p>
</dd>
<dt><code>Fit_Statistic_All_Subsets</code></dt><dd><p>Value of fit statistic associated with terms in <code>all</code>.</p>
</dd>
<dt><code>Fit_Statistic_Constant_Model</code></dt><dd><p>Value of fit statistic associated with terms in <code>consmodel</code>.</p>
</dd>
<dt><code>Call</code></dt><dd><p>The matched call.</p>
</dd>
<dt><code>Subset_Details</code></dt><dd><p>List containing the full model and descriptions of terms in the full model by source.</p>
</dd>
</dl>



<h3>Notes</h3>

<p><code>domin</code> is an R port of the Stata command with the same name (see Luchman, 2021).
</p>
<p><code>domin</code> has been superseded by <code><a href="#topic+domir">domir</a></code>.
</p>


<h3>References</h3>

<p>Luchman, J. N. (2021). Relative importance analysis in Stata using dominance analysis: domin and domme.
The Stata Journal, 21, 2. doi: 10.1177/1536867X211025837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic linear model with r-square

domin(mpg ~ am + vs + cyl, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars)


## Linear model including sets

domin(mpg ~ am + vs + cyl, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars, 
  sets = list(c("carb", "gear"), c("disp", "wt")))


## Multivariate linear model with custom multivariate r-square function 
## and all subsets variable

Rxy &lt;- function(obj, names, data) {
   return(list("r2" = cancor(predict(obj), 
       as.data.frame(mget(names, as.environment(data))))[["cor"]][1]^2)) 
       }
       
domin(cbind(wt, mpg) ~ vs + cyl + am, 
  lm, 
  list(Rxy, "r2", c("mpg", "wt"), mtcars), 
  data = mtcars, 
  all = c("carb"))


## Sets only

domin(mpg ~ 1, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars, 
  sets = list(c("am", "vs"), c("cyl", "disp"), c("qsec", "carb")))
  
## Constant model using AIC

domin(mpg ~ am + carb + cyl, 
  lm, 
  list(function(x) list(aic = extractAIC(x)[[2]]), "aic"), 
  data = mtcars, 
  reverse = TRUE, consmodel = "1")
</code></pre>

<hr>
<h2 id='dominance_scalar'>Scalar-returning internal dominance analysis meta-function</h2><span id='topic+dominance_scalar'></span>

<h3>Description</h3>

<p>Internal dominance analysis computation function assuming scalar
or vector of length 1 returned value.
</p>
<p>Not intended to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominance_scalar(
  function2call,
  args_list,
  adj_model_args,
  value_w_all_names,
  do_cdl,
  do_cpt,
  reverse
)
</code></pre>

<hr>
<h2 id='domir'>Dominance analysis methods</h2><span id='topic+domir'></span><span id='topic+domir.formula'></span><span id='topic+domir.formula_list'></span>

<h3>Description</h3>

<p>Parses input object to obtain list of names, determines all required
combinations of subsets of the name list, submits name list subsets to
a function as the input type, and computes dominance decomposition
statistics based on the returned values from the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domir(.obj, ...)

## S3 method for class 'formula'
domir(
  .obj,
  .fct,
  .set = NULL,
  .wst = NULL,
  .all = NULL,
  .adj = FALSE,
  .cdl = TRUE,
  .cpt = TRUE,
  .rev = FALSE,
  ...
)

## S3 method for class 'formula_list'
domir(
  .obj,
  .fct,
  .set = NULL,
  .wst = NULL,
  .all = NULL,
  .adj = FALSE,
  .cdl = TRUE,
  .cpt = TRUE,
  .rev = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domir_+3A_.obj">.obj</code></td>
<td>
<p>A <code>formula</code> or <code>formula_list</code>.
</p>
<p>Parsed to produce list of names. Combinations of subsets the name list are
<code><a href="base.html#topic+sapply">sapply</a></code>-ed to <code>.fct</code>.
The name list subsets submitted to <code>.fct</code> are formatted to be of
the same <code><a href="base.html#topic+class">class</a></code> as <code>.obj</code> and are submitted to
<code>.fct</code> as the first, unnamed argument.</p>
</td></tr>
<tr><td><code id="domir_+3A_...">...</code></td>
<td>
<p>Passes arguments to other methods during method dispatch;
passes arguments to the function in <code>.fct</code> during function execution.</p>
</td></tr>
<tr><td><code id="domir_+3A_.fct">.fct</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> or string function name.
</p>
<p>Applied to all subsets of elements as received from <code>.obj</code>.
Must return a length 1/scalar, numeric, atomic vector.</p>
</td></tr>
<tr><td><code id="domir_+3A_.set">.set</code></td>
<td>
<p>A <code>list</code>.
</p>
<p>Must be comprised of elements of the same class as <code>.obj</code>.
Elements of the list can be named.</p>
</td></tr>
<tr><td><code id="domir_+3A_.wst">.wst</code></td>
<td>
<p>Not yet used.</p>
</td></tr>
<tr><td><code id="domir_+3A_.all">.all</code></td>
<td>
<p>A <code>formula</code> or <code>formula_list</code>.
</p>
<p>Must be the same class as <code>.obj</code>.</p>
</td></tr>
<tr><td><code id="domir_+3A_.adj">.adj</code></td>
<td>
<p>Logical.
</p>
<p>If <code>TRUE</code> then a model including only an intercept is submitted to <code>.fct</code>
and the value returned is subtracted from the values returned from all
subsets in the dominance analysis.</p>
</td></tr>
<tr><td><code id="domir_+3A_.cdl">.cdl</code></td>
<td>
<p>Logical.
</p>
<p>If <code>FALSE</code> then conditional dominance matrix is not computed and
method to produce general dominance statistics changes.</p>
</td></tr>
<tr><td><code id="domir_+3A_.cpt">.cpt</code></td>
<td>
<p>Logical.
</p>
<p>If <code>FALSE</code> then complete dominance matrix is not computed.</p>
</td></tr>
<tr><td><code id="domir_+3A_.rev">.rev</code></td>
<td>
<p>Logical.
</p>
<p>If <code>TRUE</code> then standardized vector, ranks, and complete dominance
designations are reversed in their interpretation.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Element Parsing</h4>

<p><code>.obj</code>s is parsed into a name list that is used to determine
the required number of combinations of subsets of the name list
included the dominance analysis.  How the name list is obtained
depends on <code>.obj</code>'s class.
</p>


<h5><code>formula</code></h5>

<p>The <code>formula</code> creates a name list using all terms in the formula.
The terms are obtained using <code><a href="stats.html#topic+terms.formula">terms.formula</a></code>. All processing
that is normally applied to the right hand side of a formula is
implemented (see <code><a href="stats.html#topic+formula">formula</a></code>).
</p>
<p>A response/left hand side is not required but, if present, is
included in all <code>formula</code>s passed to <code>.fct</code>.
</p>



<h5><code>formula_list</code></h5>

<p>The <code><a href="#topic+formula_list">formula_list</a></code> creates a name list out of response-term pairs.
The terms are obtained using <code>terms.formula</code> applied to each individual
formula in the list.
</p>



<h5>Additional Details</h5>

<p>By default, names obtained from <code>.obj</code> are all considered separate
'value-generating names' with the same priority.
Each value-generating name will be a separate element when
computing combination subsets and will be compared to all other
value-generating names.
</p>
<p><code>formula</code>s and <code>formula_list</code> elements are assumed to have an intercept
except if explicitly removed with a <code>- 1</code> in the <code>formula</code>(s) in <code>.obj</code>.
If removed, the intercept will be removed in all <code>formula</code>(s) in each
<code>sapply</code>-ed subset to <code>.fct</code>.
</p>
<p>If <code><a href="stats.html#topic+offset">offset</a></code>s are included, they are passed, like intercepts, while
<code>sapply</code>-ing subsets to <code>.fct</code>. Currently, only the <code>formula_list</code> method
allows <code>offsets</code>.
</p>




<h4>Changing Element Parsing</h4>

<p>All methods' default behavior that considers all value-generating names
to be of equal priority can be overriden using <code>.set</code> and <code>.all</code> arguments.
</p>
<p>Names in <code>.set</code> and <code>.all</code> must also be present in <code>.obj</code>.
</p>


<h5><code>.set</code></h5>

<p><code>.set</code> binds together value-generating names such that
they are of equal priority and are never separated when submitted to
<code>.fct</code>.
Thus, the elements in <code>.obj</code> bound together contribute jointly to the
returned value and are considered, effectively, a single
value-generating name.
</p>
<p>If list elements in <code>.set</code> are named, this name will be used in all
returned results as the name of the set of value-generating names bound
together.
</p>
<p><code>.set</code> thus considers the value-generating names an 'inseparable set' in the
dominance analysis and are always included or excluded together.
</p>



<h5><code>.all</code></h5>

<p><code>.all</code> gives immediate priority to value-generating names.
The value-generating names in <code>.all</code> are bound together, are
ascribed their full amount of the returned value from <code>.fct</code>, and
are not adjusted for contribution of other value-generating names.
</p>
<p>The value of <code>.fct</code> ascribed to the value-generating names bound
together in <code>.all</code> is returned separately from, and not directly
compared to, the other value-generating names.
</p>
<p>The <code>formula</code> method for <code>.all</code> does not allow a left hand side.
</p>
<p><code>.all</code> includes the value-generating names in 'all subsets' submitted to
the dominance analysis which effectively removes the value associated with
this set of names.
</p>



<h5><code>.adj</code></h5>

<p><code>.adj</code> indicates that an intercept-only model should be supplied to <code>.fct</code>.
This intercept-only subset is given most immediate priority and the
value of <code>.fct</code> ascribed to it is removed from all other
value-generating names and groups including those in <code>.all</code>.
</p>
<p>The <code>formula</code> method will submit an intercept-only formula to <code>.fct</code>.
The <code>formula_list</code> method creates a separate, intercept-only subset for each
of the <code>formula</code>s in the list.
Both the <code>formula</code> and <code>formula_list</code> methods will respect the user's
removal of an intercept. The <code>formula_list</code> method will also respect the
user's inclusion of an <code>offset</code> and will include them in the submission to
<code>.fct</code>.
</p>
<p><code>.adj</code> then 'adjusts' the returned value for a non-0 value-returning
null model when no value generating names are included.
</p>



<h5>Additional Details</h5>

<p>All methods submit combinations of subsets of names as an
object of the same class as <code>.obj</code>.
A <code>formula</code> in <code>.obj</code> will submit all combinations of subsets of names
as <code>formula</code>s to <code>.fct</code>.
A <code>formula_list</code> in <code>.obj</code> will submit all combinations of subsets of names
as <code>formula_list</code>s to <code>.fct</code>.
In the case that <code>.fct</code> requires a different <code>class</code> (i.e.,
a vector of names, a <code><a href="Formula.html#topic+Formula">Formula::Formula</a></code> see <code><a href="#topic+fmllst2Fml">fmllst2Fml</a></code>) the
subsets of names will have to be processed in <code>.fct</code> to
obtain the correct <code>class</code>.
</p>
<p>The all subsets of names will be submitted to <code>.fct</code> as the first, unnamed
argument.
</p>




<h4><code>.fct</code> as Analysis Pipeline</h4>

<p>The function <code>sapply</code>-ed and to which the combinations of subsets of
names will be applied.
</p>
<p><code>.fct</code> is expected to be a complete analysis pipeline that receives a
subset of names of the same <code>class</code> as <code>.obj</code>, uses the names in the
<code>class</code> as submitted to generate a returned value of the appropriate
type to dominance analyze. Typically, this returned value is a
fit statistic extracted from a predictive model.
</p>
<p>At current, only atomic (i.e., non-<code>list</code>), numeric scalars (i.e.,
vectors of length 1) are allowed as returned values.
</p>
<p>The <code>.fct</code> argument is strict about names submitted and returned value
requirements for functions used and applies a series of checks to
ensure the submitted names and returned value adhere to these requirements.
The checks include whether the <code>.obj</code> can be submitted to <code>.fct</code> without
producing an error and whether the
returned value from <code>.fct</code> is a length 1, atomic, numeric vector.
In most circumstances, the user will have to make their own named or
anonymous function to supply as <code>.fct</code> to satisfy the checks.
</p>



<h3>Value</h3>

<p>Returns an object of <code><a href="base.html#topic+class">class</a></code> &quot;domir&quot; composed of:
</p>

<dl>
<dt><code>General_Dominance</code></dt><dd><p>Vector of general dominance values.</p>
</dd>
<dt><code>Standardized</code></dt><dd><p>Vector of general dominance values normalized
to sum to 1.</p>
</dd>
<dt><code>Ranks</code></dt><dd><p>Vector of ranks applied to the general dominance values.</p>
</dd>
<dt><code>Conditional_Dominance</code></dt><dd><p>Matrix of conditional dominance values.
Each row represents an element in <code>.obj</code>;
each column represents a number of elements from <code>.obj</code> in a subset.</p>
</dd>
<dt><code>Complete_Dominance</code></dt><dd><p>Logical matrix of complete dominance
designations.
The <code>.obj</code> elements represented in each row indicates dominance status;
the <code>.obj</code> elements represented in each column indicates
dominated-by status.</p>
</dd>
<dt><code>Value</code></dt><dd><p>Value returned by <code>.fct</code> with all elements (i.e.,
from <code>.obj</code>, <code>.all</code>, and <code>.adj</code>.</p>
</dd>
<dt><code>Value_All</code></dt><dd><p>Value of <code>.fct</code> associated with elements included
in <code>.all</code>;
when elements are in <code>.adj</code>, will be adjusted for <code>Value_Adjust</code>.</p>
</dd>
<dt><code>Value_Adjust</code></dt><dd><p>Value of <code>.fct</code> associated with elements in <code>.adj</code>.</p>
</dd>
<dt><code>Call</code></dt><dd><p>The matched call.</p>
</dd>
</dl>



<h3>Notes</h3>



<h4><code>formula</code> method</h4>

<p>Prior to version 1.1.0, the <code>formula</code> method allowed a <code>formula</code>
to be submitted to <code>.adj</code>.
Submitting an intercept-only <code>formula</code> as opposed to a
logical has been depreciated and submitting a <code>formula</code> with more than an
intercept is defunct.
</p>
<p>The <code>formula</code> and <code>formula_list</code> methods can be used to pass responses,
intercepts, and in some cases, <code>offset</code>s to all combinations of subsets
of names.
If the user seeks to include other model components integral to
estimation
(i.e., a random effect term in <code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code>) include them as
<code><a href="stats.html#topic+update.formula">update</a></code> to the submitted <code>formula</code> or <code>formula_list</code>
imbedded in <code>.fct</code>.
</p>
<p>Second-order or higher terms (i.e., interactions like<code>~ a*b</code>) are parsed
by default but not used differently from first-order terms for producing
subsets. The values ascribed to such terms may not be valid unless
the user ensures that second-order and
higher terms are used appropriately in <code>.fct</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## Linear model returning r-square
lm_r2 &lt;- 
  function(fml, data) { 
    lm_res &lt;- lm(fml, data = data)
    summary(lm_res)[["r.squared"]]
 }

domir(mpg ~ am + vs + cyl, lm_r2, data = mtcars)


## Linear model including set
domir(
  mpg ~ am + vs + cyl + carb + gear + disp + wt,
  lm_r2,
  .set = list(~ carb + gear, ~ disp + wt),
  data = mtcars
)


## Multivariate regression with multivariate r-square and 
## all subsets variable
mlm_rxy &lt;- 
  function(fml, data, dvnames) {
    mlm_res &lt;- lm(fml, data = data)
    mlm_pred &lt;- predict(mlm_res)
    cancor(mlm_pred, data[dvnames])$cor[[1]]^2
  }
       
domir(
  cbind(wt, mpg) ~ vs + cyl + am + carb,
  mlm_rxy, 
  .all = ~ carb,
  data = mtcars, 
  dvnames = c("wt", "mpg")
)


## Named sets
domir(
  mpg ~ am + gear + cyl + vs + qsec + drat,
  lm_r2,
  data = mtcars, 
  .set = 
    list( trns = ~ am + gear, 
          eng = ~ cyl + vs, misc = ~ qsec + drat
    )
)
  
  
## Linear model returning AIC
lm_aic &lt;- 
  function(fml, data) { 
    lm_res &lt;- lm(fml, data = data)
    AIC(lm_res)
 }

domir(
  mpg ~ am + carb + cyl, 
  lm_aic, 
  .adj = TRUE,
  .rev = TRUE,
  data = mtcars
 )


## 'systemfit' with 'formula_list' method returning AIC
if (requireNamespace("systemfit", quietly = TRUE)) {
  domir(
    formula_list(mpg ~ am + cyl + carb, qsec ~ wt + cyl + carb),
    function(fml) {
      res &lt;- systemfit::systemfit(fml, data = mtcars)
      AIC(res)
    }, 
    .adj = TRUE, .rev = TRUE
  )
}
  
</code></pre>

<hr>
<h2 id='fmllst2Fml'>Translate <code>formula_list</code> into <code>Formula::Formula</code></h2><span id='topic+fmllst2Fml'></span>

<h3>Description</h3>

<p>Translates <code><a href="#topic+formula_list">formula_list</a></code> objects into a <code><a href="Formula.html#topic+Formula">Formula::Formula</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmllst2Fml(fmllst, drop_lhs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmllst2Fml_+3A_fmllst">fmllst</code></td>
<td>
<p>A <code>formula_list</code> classed object.</p>
</td></tr>
<tr><td><code id="fmllst2Fml_+3A_drop_lhs">drop_lhs</code></td>
<td>
<p>An integer vector.
</p>
<p>Used as a selection vector to remove left hand side names prior to
generating the <code>Formula</code> object. This vector must be composed of
integers (e.g., 1L and not 1).
</p>
<p>This is useful for some <code>Formulas</code> that do not have a separate
LHS for each LHS model part (e.g., <code><a href="pscl.html#topic+zeroinfl">pscl::zeroinfl</a></code>) but are required
to have separte LHS parts by <code>formula_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Formula::Formula</code> object.
</p>

<hr>
<h2 id='formula_list'>A <code><a href="base.html#topic+list">list</a></code> composed of <code>formulas</code></h2><span id='topic+formula_list'></span>

<h3>Description</h3>

<p>Defines a list object class composed of <code>formula</code> objects that
is used to obtain RHS-LHS pairs in its <code><a href="#topic+domir">domir</a></code> S3 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_list_+3A_...">...</code></td>
<td>
<p><code>formula</code>s, possibly named</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code>formula_list</code>s enforce requirements that the list are composed of
individual <code>formula</code>s and that each formula is unique with its own,
different, non-<code>NULL</code> dependent variable/response.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>formula_list</code>.
</p>

<hr>
<h2 id='formula_parse'>Internal formula parsing function</h2><span id='topic+formula_parse'></span>

<h3>Description</h3>

<p>Internal formula parsing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_parse(.obj)
</code></pre>

<hr>
<h2 id='print.domin'>Print method for <code>domin</code></h2><span id='topic+print.domin'></span>

<h3>Description</h3>

<p>Reports formatted results from <code>domin</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'domin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.domin_+3A_x">x</code></td>
<td>
<p>an object of class &quot;domin&quot;.</p>
</td></tr>
<tr><td><code id="print.domin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method for class <code>domin</code> objects reports out the following results:
</p>

<ul>
<li><p>Fit statistic for the full model.  The fit statistic for the all subsets model is reported here if there are any entries in <code>all</code>.  The fit statistic for the constant model is reported here if there are any entries in <code>consmodel</code>.
</p>
</li>
<li><p>Matrix describing general dominance statistics, standardized general dominance statistics, and the ranking of the general dominance statistics
</p>
</li>
<li><p>If <code>conditional</code> is <code>TRUE</code>, matrix describing the conditional dominance designations
</p>
</li>
<li><p>If <code>complete</code> is <code>TRUE</code>, matrix describing the complete dominance designations
</p>
</li>
<li><p>If following <code>summary.domin</code>, matrix describing the strongest dominance designations between all independent variables
</p>
</li>
<li><p>If there are entries in <code>sets</code> and/or <code>all</code> the terms included in each set as well as the terms in all subsets are reported</p>
</li></ul>

<p>The <code>domin</code> print method alters dimension names for readability and they do not display as stored in the original <code>domin</code> object.
</p>


<h3>Value</h3>

<p>The &quot;domin&quot; object with altered column and row names for conditional and complete dominance results as displayed in the console.
</p>

<hr>
<h2 id='print.domir'>Print method for <code>domir</code></h2><span id='topic+print.domir'></span>

<h3>Description</h3>

<p>Reports formatted results from <code>domir</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'domir'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.domir_+3A_x">x</code></td>
<td>
<p>an object of class &quot;domir&quot;.</p>
</td></tr>
<tr><td><code id="print.domir_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method for class <code>domir</code> objects reports out the
following results:
</p>

<ul>
<li><p>Value when all elements are included in <code>obj</code>.
</p>
</li>
<li><p>Value for the elements included in <code>.all</code>, if any.
</p>
</li>
<li><p>Value for the elements included in <code>.adj</code>, if any.
</p>
</li>
<li><p>Matrix describing general dominance values, standardized
general dominance values, and the ranking of the general
dominance values.
</p>
</li>
<li><p>Matrix describing the conditional dominance values, if computed
</p>
</li>
<li><p>Matrix describing the complete dominance designations, if evaluated
</p>
</li>
<li><p>If following <code><a href="#topic+summary.domir">summary.domir</a></code>, matrix describing the strongest
dominance designations between all elements.</p>
</li></ul>

<p>The <code>domir</code> print method alters dimension names for readability and they
do not display as stored in the <code>domir</code> object.
</p>


<h3>Value</h3>

<p>The submitted &quot;domir&quot; object, invisibly.
</p>

<hr>
<h2 id='summary.domin'>Summary method for <code>domin</code></h2><span id='topic+summary.domin'></span>

<h3>Description</h3>

<p>Reports dominance designation results from the <code>domin</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'domin'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.domin_+3A_object">object</code></td>
<td>
<p>an object of class &quot;domin&quot;.</p>
</td></tr>
<tr><td><code id="summary.domin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary method for class <code>domin</code> is used for obtaining the strongest dominance designations (i.e., general, conditional, or complete) among the independent variables.
</p>


<h3>Value</h3>

<p>The originally submitted &quot;domin&quot; object with an additional <code>Strongest_Dominance</code> element added.
</p>

<dl>
<dt><code>Strongest_Dominance</code></dt><dd><p>Matrix comparing the independent variable in the first row to the independent variable in the third row.  The second row denotes the strongest designation between the two independent variables.</p>
</dd>
</dl>


<hr>
<h2 id='summary.domir'>Summary method for <code>domir</code></h2><span id='topic+summary.domir'></span>

<h3>Description</h3>

<p>Reports dominance designation results from the <code>domir</code>
class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'domir'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.domir_+3A_object">object</code></td>
<td>
<p>an object of class &quot;domir&quot;.</p>
</td></tr>
<tr><td><code id="summary.domir_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.
Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary method for class <code>domir</code> objects is used for obtaining
the strongest dominance designations (i.e., general, conditional, or
complete) among all pairs of dominance analyzed elements.
</p>


<h3>Value</h3>

<p>The submitted &quot;domir&quot; object with an additional
<code>Strongest_Dominance</code> element added.
</p>

<dl>
<dt><code>Strongest_Dominance</code></dt><dd><p>Matrix comparing the element in the first
row to the element in the third row.  The second row denotes the strongest
designation between the two elements.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
