<!DOCTYPE html><html><head><title>Help for package LUCIDus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LUCIDus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot_lucid'><p>Inference of LUCID model based on bootstrap resampling</p></a></li>
<li><a href='#check_na'><p>Check missing patterns in one layer of omics data Z</p></a></li>
<li><a href='#estimate_lucid'><p>Fit LUCID models with one or multiple omics layers</p></a></li>
<li><a href='#fill_data'><p>Impute missing data by optimizing the likelihood function</p></a></li>
<li><a href='#gen_ci'><p>generate bootstrp ci (normal, basic and percentile)</p></a></li>
<li><a href='#Istep_Z'><p>I-step of LUCID</p></a></li>
<li><a href='#lucid'><p>Fit a lucid model for integrated analysis on exposure, outcome and multi-omics data, allowing for tuning</p></a></li>
<li><a href='#plot_lucid'><p>Visualize LUCID model through a Sankey diagram</p></a></li>
<li><a href='#predict_lucid'><p>Predict cluster assignment and outcome based on LUCID model</p></a></li>
<li><a href='#print.sumlucid'><p>Print the output of LUCID in a nicer table</p></a></li>
<li><a href='#sim_data'><p>A simulated dataset for LUCID</p></a></li>
<li><a href='#simulated_HELIX_data'><p>A simulated HELIX dataset for LUCID</p></a></li>
<li><a href='#summary_lucid'><p>Summarize results of the LUCID model</p></a></li>
<li><a href='#tune_lucid'><p>A wrapper function to perform model selection for LUCID</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>LUCID with Multiple Omics Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of estimating the Latent Unknown Clusters By Integrating Multi-omics Data (LUCID) model (Peng (2019) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz667">doi:10.1093/bioinformatics/btz667</a>&gt;). LUCID conducts integrated clustering using exposures, omics data (and outcome as an option). This is a major update from the last version while conserving all the previous features. This package implements three different integration strategies for multiple omics data analysis within the LUCID framework: LUCID early integration (the original LUCID model), LUCID in parallel (intermediate), and LUCID in serial (late). Automated model selection for each LUCID model is available to obtain the optimal number of latent clusters, and an integrated imputation approach is implemented to handle sporadic and list-wise missing multiple omics data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>mclust, nnet, boot, jsonlite, networkD3, progress, stats,
utils, glasso, glmnet</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 23:47:30 UTC; qiranjia19961112</td>
</tr>
<tr>
<td>Author:</td>
<td>Qiran Jia <a href="https://orcid.org/0000-0002-0790-5967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Yinqi Zhao <a href="https://orcid.org/0000-0003-2413-732X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  David Conti <a href="https://orcid.org/0000-0002-2941-7833"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths],
  Jesse Goodrich <a href="https://orcid.org/0000-0001-6615-0472"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qiran Jia &lt;qiranjia@usc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 11:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot_lucid'>Inference of LUCID model based on bootstrap resampling</h2><span id='topic+boot_lucid'></span>

<h3>Description</h3>

<p>Generate <code>R</code> bootstrap replicates of LUCID parameters and
derive confidence interval (CI) base on bootstrap. Bootstrap replicates are
generated based on nonparameteric resampling, implemented by <code>ordinary</code>
method of <code>boot::boot</code> function. Now only achieved for LUCID early integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_lucid(
  G,
  Z,
  Y,
  lucid_model = c("early", "parallel", "serial"),
  CoG = NULL,
  CoY = NULL,
  model,
  conf = 0.95,
  R = 100,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_lucid_+3A_g">G</code></td>
<td>
<p>Exposures, a numeric vector, matrix, or data frame. Categorical variable
should be transformed into dummy variables. If a matrix or data frame, rows
represent observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_z">Z</code></td>
<td>
<p>Omics data for LUCID early integration, a numeric matrix or data frame. Rows correspond to observations
and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_y">Y</code></td>
<td>
<p>Outcome, a numeric vector. Categorical variable is not allowed. Binary
outcome should be coded as 0 and 1.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for LUCID in serial.Now only work for LUCID early.
If &quot;parallel&quot; or &quot;serial&quot;, the function will do nothing.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_cog">CoG</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the latent cluster.
A numeric vector, matrix or data frame. Categorical variable should be transformed
into dummy variables.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_coy">CoY</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the association
between latent cluster and the outcome. A numeric vector, matrix or data frame.
Categorical variable should be transformed into dummy variables.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_model">model</code></td>
<td>
<p>A LUCID model fitted by <code>estimate_lucid</code>.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_conf">conf</code></td>
<td>
<p>A numeric scalar between 0 and 1 to specify confidence level(s)
of the required interval(s).</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_r">R</code></td>
<td>
<p>An integer to specify number of bootstrap replicates for LUCID model.
If feasible, it is recommended to set R &gt;= 1000.</p>
</td></tr>
<tr><td><code id="boot_lucid_+3A_verbose">verbose</code></td>
<td>
<p>A flag indicates whether detailed information
is printed in console. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>effect estimate for each exposure</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>cluster-specific mean for each omics feature</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>effect estiamte for the association btween latent cluster and
outcome</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>The <code>boot</code> object returned by <code>boot:boot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# use simulated data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal

# fit lucid model
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", 
family = "normal", K = 2,
seed = 1008)

# conduct bootstrap resampling
boot1 &lt;- boot_lucid(G = G, Z = Z, Y = Y_normal, 
lucid_model = "early",model = fit1, R = 100)

# check distribution for bootstrap replicates of the variable of interest
plot(boot1$bootstrap, 1)

# use 90% CI
boot2 &lt;- boot_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", 
model = fit1, R = 100, conf = 0.9)

</code></pre>

<hr>
<h2 id='check_na'>Check missing patterns in one layer of omics data Z</h2><span id='topic+check_na'></span>

<h3>Description</h3>

<p>Check missing patterns in one layer of omics data Z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_na(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_na_+3A_z">Z</code></td>
<td>
<p>A data matrix representing one layer of omics data</p>
</td></tr>
</table>


<h3>Value</h3>


<ol>
<li><p> index:indeces for missing values in the omics data
</p>
</li>
<li><p> indicator_na: missing pattern for each observation
</p>
</li>
<li><p> impute_flag: - flag to initialize imputation. Only happens when sporadic missing
pattern is observed
</p>
</li></ol>


<hr>
<h2 id='estimate_lucid'>Fit LUCID models with one or multiple omics layers</h2><span id='topic+estimate_lucid'></span>

<h3>Description</h3>

<p>EM algorithm to estimate LUCID with one or multiple omics layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_lucid(
  lucid_model = c("early", "parallel", "serial"),
  G,
  Z,
  Y,
  CoG = NULL,
  CoY = NULL,
  K,
  init_omic.data.model = "EEV",
  useY = TRUE,
  tol = 0.001,
  max_itr = 1000,
  max_tot.itr = 10000,
  Rho_G = 0,
  Rho_Z_Mu = 0,
  Rho_Z_Cov = 0,
  family = c("normal", "binary"),
  seed = 123,
  init_impute = c("mix", "lod"),
  init_par = c("mclust", "random"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_lucid_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for lucid in serial</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_g">G</code></td>
<td>
<p>an N by P matrix representing exposures</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_z">Z</code></td>
<td>
<p>Omics data, if &quot;early&quot;, an N by M matrix; If &quot;parallel&quot;, a list, each element i is a matrix with N rows and P_i features;
If &quot;serial&quot;, a list, each element i is a matrix with N rows and p_i features or a list with two or more matrices with N rows and a certain number of features</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_y">Y</code></td>
<td>
<p>a length N vector</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_cog">CoG</code></td>
<td>
<p>an N by V matrix representing covariates to be adjusted for G -&gt; X</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_coy">CoY</code></td>
<td>
<p>an N by K matrix representing covariates to be adjusted for X -&gt; Y</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_k">K</code></td>
<td>
<p>Number of latent clusters. If &quot;early&quot;, an integer greater or equal to 2; If &quot;parallel&quot;,an integer vector, same length as Z, with each element being an interger greater or equal to 2;
If &quot;serial&quot;, a list, each element is either an integer like that for &quot;early&quot; or an list of integers like that for &quot;parallel&quot;, same length as Z</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_init_omic.data.model">init_omic.data.model</code></td>
<td>
<p>a vector of strings specifies the geometric model of omics
data. If NULL, See more in ?mclust::mclustModelNames</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_usey">useY</code></td>
<td>
<p>logical, if TRUE, EM algorithm fits a supervised LUCID; otherwise
unsupervised LUCID.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for the EM algorithm</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_max_itr">max_itr</code></td>
<td>
<p>Maximum iterations of the EM algorithm. If the EM algorithm iterates
more than max_itr without converging, the EM algorithm is forced to stop.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_max_tot.itr">max_tot.itr</code></td>
<td>
<p>Max number of total iterations for <code>estimate_lucid</code> function.
<code>estimate_lucid</code> may conduct EM algorithm for multiple times if the algorithm
fails to converge.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_rho_g">Rho_G</code></td>
<td>
<p>A scalar. This parameter is the LASSO penalty to regularize
exposures. If user wants to tune the penalty, use the wrapper
function <code>lucid</code>. Now only achieved for LUCID early integration.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_rho_z_mu">Rho_Z_Mu</code></td>
<td>
<p>A scalar. This parameter is the LASSO penalty to
regularize cluster-specific means for omics data (Z). If user wants to tune the
penalty, use the wrapper function <code>lucid</code>.Now only achieved for LUCID early integration.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_rho_z_cov">Rho_Z_Cov</code></td>
<td>
<p>A scalar. This parameter is the graphical LASSO
penalty to estimate sparse cluster-specific variance-covariance matrices for omics
data (Z). If user wants to tune the penalty, use the wrapper function <code>lucid</code>.
Now only achieved for LUCID early integration.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_family">family</code></td>
<td>
<p>The distribution of the outcome</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_seed">seed</code></td>
<td>
<p>Random seed to initialize the EM algorithm</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_init_impute">init_impute</code></td>
<td>
<p>Method to initialize the imputation of missing values in
LUCID. <code>mix</code> will use <code>mclust:imputeData</code> to implement EM Algorithm
for Unrestricted General Location Model by the mix package to impute the missing values in omics
data; <code>lod</code> will initialize the imputation via replacing missing values by
LOD / sqrt(2). LOD is determined by the minimum of each variable in omics data.</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_init_par">init_par</code></td>
<td>
<p>For &quot;early&quot;, an interface to initialize EM algorithm, if mclust,
initiate the parameters using the <code>mclust</code> package, if random, initiate the parameters
by drawing from a uniform distribution;
For &quot;parallel&quot;, mclust is the default for quick convergence;
For &quot;serial&quot;, each sub-model follows the above depending on it is a &quot;early&quot; or &quot;parallel&quot;</p>
</td></tr>
<tr><td><code id="estimate_lucid_+3A_verbose">verbose</code></td>
<td>
<p>A flag indicates whether detailed information for each iteration
of EM algorithm is printed in console. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains the object below:
</p>

<ol>
<li><p> res_Beta: estimation for G-&gt;X associations
</p>
</li>
<li><p> res_Mu: estimation for the mu of the X-&gt;Z associations
</p>
</li>
<li><p> res_Sigma: estimation for the sigma of the X-&gt;Z associations
</p>
</li>
<li><p> res_Gamma: estimation for X-&gt;Y associations
</p>
</li>
<li><p> inclusion.p: inclusion probability of cluster assignment for each observation
</p>
</li>
<li><p> K: umber of latent clusters for &quot;early&quot;/list of numbers of latent clusters for &quot;parallel&quot; and &quot;serial&quot;
</p>
</li>
<li><p> var.names: names for the G, Z, Y variables
</p>
</li>
<li><p> init_omic.data.model: pre-specified geometric model of multi-omics data
</p>
</li>
<li><p> likelihood: converged LUCID model log likelihood
</p>
</li>
<li><p> family: the distribution of the outcome
</p>
</li>
<li><p> select: for LUCID early integration only, indicators of whether each exposure and omics feature is selected
</p>
</li>
<li><p> useY: whether this LUCID model is supervised
</p>
</li>
<li><p> Z: multi-omics data
</p>
</li>
<li><p> init_impute: pre-specified imputation method
</p>
</li>
<li><p> init_par: pre-specified parameter initialization method
</p>
</li>
<li><p> Rho: for LUCID early integration only, pre-specified regularity tuning parameter
</p>
</li>
<li><p> N: number of observations
</p>
</li>
<li><p> submodel: for LUCID in serial only, storing all the submodels
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- 1008
set.seed(i)
G &lt;- matrix(rnorm(500), nrow = 100)
Z1 &lt;- matrix(rnorm(1000),nrow = 100)
Z2 &lt;- matrix(rnorm(1000), nrow = 100)
Z3 &lt;- matrix(rnorm(1000), nrow = 100)
Z4 &lt;- matrix(rnorm(1000), nrow = 100)
Z5 &lt;- matrix(rnorm(1000), nrow = 100)
Z &lt;- list(Z1 = Z1, Z2 = Z2, Z3 = Z3, Z4 = Z4, Z5 = Z5)
Y &lt;- rnorm(100)
CoY &lt;- matrix(rnorm(200), nrow = 100)
CoG &lt;- matrix(rnorm(200), nrow = 100)
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y, K = list(2,2,2,2,2),
lucid_model = "serial",
family = "normal",
seed = i,
CoG = CoG, CoY = CoY,
useY = TRUE)
</code></pre>

<hr>
<h2 id='fill_data'>Impute missing data by optimizing the likelihood function</h2><span id='topic+fill_data'></span>

<h3>Description</h3>

<p>Impute missing data by optimizing the likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_data(obs, mu, sigma, p, index, lucid_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_data_+3A_obs">obs</code></td>
<td>
<p>a vector of length M</p>
</td></tr>
<tr><td><code id="fill_data_+3A_mu">mu</code></td>
<td>
<p>a matrix of size M x K</p>
</td></tr>
<tr><td><code id="fill_data_+3A_sigma">sigma</code></td>
<td>
<p>a matrix of size M x M x K</p>
</td></tr>
<tr><td><code id="fill_data_+3A_p">p</code></td>
<td>
<p>a vector of length K</p>
</td></tr>
<tr><td><code id="fill_data_+3A_index">index</code></td>
<td>
<p>a vector of length M, indicating whether a value is missing
or not in the raw data</p>
</td></tr>
<tr><td><code id="fill_data_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for lucid in serial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an observation with updated imputed value
</p>

<hr>
<h2 id='gen_ci'>generate bootstrp ci (normal, basic and percentile)</h2><span id='topic+gen_ci'></span>

<h3>Description</h3>

<p>generate bootstrp ci (normal, basic and percentile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_ci(x, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_ci_+3A_x">x</code></td>
<td>
<p>an object return by boot function</p>
</td></tr>
<tr><td><code id="gen_ci_+3A_conf">conf</code></td>
<td>
<p>A numeric scalar between 0 and 1 to specify confidence level(s)
of the required interval(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, the first column is t0 statistic from original model
</p>

<hr>
<h2 id='Istep_Z'>I-step of LUCID</h2><span id='topic+Istep_Z'></span>

<h3>Description</h3>

<p>Impute missing data in Z by maximizing the likelihood given fixed
parameters of LUCID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Istep_Z(Z, p, mu, sigma, index, lucid_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Istep_Z_+3A_z">Z</code></td>
<td>
<p>an N by P matrix representing the omics data</p>
</td></tr>
<tr><td><code id="Istep_Z_+3A_p">p</code></td>
<td>
<p>an N by K matrix representing inclusion probability for each
latent cluster</p>
</td></tr>
<tr><td><code id="Istep_Z_+3A_mu">mu</code></td>
<td>
<p>an M by K matrix representing cluster-specific means</p>
</td></tr>
<tr><td><code id="Istep_Z_+3A_sigma">sigma</code></td>
<td>
<p>an M by M by K array representing cluster-specific covariance</p>
</td></tr>
<tr><td><code id="Istep_Z_+3A_index">index</code></td>
<td>
<p>an N by M matrix representing missing values in Z</p>
</td></tr>
<tr><td><code id="Istep_Z_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for lucid in serial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a complete dataset of Z
</p>

<hr>
<h2 id='lucid'>Fit a lucid model for integrated analysis on exposure, outcome and multi-omics data, allowing for tuning</h2><span id='topic+lucid'></span>

<h3>Description</h3>

<p>Fit a lucid model for integrated analysis on exposure, outcome and multi-omics data, allowing for tuning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lucid(
  G,
  Z,
  Y,
  CoG = NULL,
  CoY = NULL,
  family = c("normal", "binary"),
  K = 2,
  lucid_model = c("early", "parallel", "serial"),
  Rho_G = 0,
  Rho_Z_Mu = 0,
  Rho_Z_Cov = 0,
  verbose_tune = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lucid_+3A_g">G</code></td>
<td>
<p>Exposures, a numeric vector, matrix, or data frame. Categorical variable
should be transformed into dummy variables. If a matrix or data frame, rows
represent observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="lucid_+3A_z">Z</code></td>
<td>
<p>Omics data. If &quot;early&quot;, an N by M matrix; If &quot;parallel&quot;, a list, each element i is a matrix with N rows and P_i features;
If &quot;serial&quot;, a list, each element i is a matrix with N rows and p_i features or a list with two or more matrices with N rows and a certain number of features
If &quot;serial&quot;, a list, each element is a matrix with N rows or a list with two or more matrices with N rows</p>
</td></tr>
<tr><td><code id="lucid_+3A_y">Y</code></td>
<td>
<p>Outcome, a numeric vector. Categorical variable is not allowed. Binary
outcome should be coded as 0 and 1.</p>
</td></tr>
<tr><td><code id="lucid_+3A_cog">CoG</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the latent cluster.
A numeric vector, matrix or data frame. Categorical variable should be transformed
into dummy variables.</p>
</td></tr>
<tr><td><code id="lucid_+3A_coy">CoY</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the association
between latent cluster and the outcome. A numeric vector, matrix or data frame.
Categorical variable should be transformed into dummy variables.</p>
</td></tr>
<tr><td><code id="lucid_+3A_family">family</code></td>
<td>
<p>Distribution of outcome. For continuous outcome, use &quot;normal&quot;;
for binary outcome, use &quot;binary&quot;. Default is &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="lucid_+3A_k">K</code></td>
<td>
<p>Number of latent clusters to be tuned. For lucid_model = &quot;early&quot;, number of latent clusters (should be greater or equal than 2).
Either an integer or a vector of integer. If K is a vector, model selection
on K is performed. For lucid_model = &quot;parallel&quot;,a list with vectors of integers or just integers, same length as Z,
if the element itself is a vector, model selection on K is performed;
For lucid_model = &quot;serial&quot;, a list, each element is either an integer or an list of integers, same length as Z,
if the smallest element (integer) itself is a vector, model selection on K is performed</p>
</td></tr>
<tr><td><code id="lucid_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for lucid in serial</p>
</td></tr>
<tr><td><code id="lucid_+3A_rho_g">Rho_G</code></td>
<td>
<p>A scalar or a vector. This parameter is the LASSO penalty to regularize
exposures. If it is a vector, <code>lucid</code> will call <code>tune_lucid</code> to conduct
model selection and variable selection. User can try penalties from 0 to 1. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="lucid_+3A_rho_z_mu">Rho_Z_Mu</code></td>
<td>
<p>A scalar or a vector. This parameter is the LASSO penalty to
regularize cluster-specific means for omics data (Z). If it is a vector,
<code>lucid</code> will call <code>tune_lucid</code> to conduct model selection and
variable selection. User can try penalties from 1 to 100. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="lucid_+3A_rho_z_cov">Rho_Z_Cov</code></td>
<td>
<p>A scalar or a vector. This parameter is the graphical LASSO
penalty to estimate sparse cluster-specific variance-covariance matrices for omics
data (Z). If it is a vector, <code>lucid</code> will call <code>tune_lucid</code> to conduct
model selection and variable selection. User can try penalties from 0 to 1. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="lucid_+3A_verbose_tune">verbose_tune</code></td>
<td>
<p>A flag to print details of tuning process.</p>
</td></tr>
<tr><td><code id="lucid_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>estimate_lucid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An optimal LUCID model
</p>

<ol>
<li><p> res_Beta: estimation for G-&gt;X associations
</p>
</li>
<li><p> res_Mu: estimation for the mu of the X-&gt;Z associations
</p>
</li>
<li><p> res_Sigma: estimation for the sigma of the X-&gt;Z associations
</p>
</li>
<li><p> res_Gamma: estimation for X-&gt;Y associations
</p>
</li>
<li><p> inclusion.p: inclusion probability of cluster assignment for each observation
</p>
</li>
<li><p> K: umber of latent clusters for &quot;early&quot;/list of numbers of latent clusters for &quot;parallel&quot; and &quot;serial&quot;
</p>
</li>
<li><p> var.names: names for the G, Z, Y variables
</p>
</li>
<li><p> init_omic.data.model: pre-specified geometric model of multi-omics data
</p>
</li>
<li><p> likelihood: converged LUCID model log likelihood
</p>
</li>
<li><p> family: the distribution of the outcome
</p>
</li>
<li><p> select: for LUCID early integration only, indicators of whether each exposure and omics feature is selected
</p>
</li>
<li><p> useY: whether this LUCID model is supervised
</p>
</li>
<li><p> Z: multi-omics data
</p>
</li>
<li><p> init_impute: pre-specified imputation method
</p>
</li>
<li><p> init_par: pre-specified parameter initialization method
</p>
</li>
<li><p> Rho: for LUCID early integration only, pre-specified regularity tuning parameter
</p>
</li>
<li><p> N: number of observations
</p>
</li>
<li><p> submodel: for LUCID in serial only, storing all the submodels
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# LUCID early integration
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal
Y_binary &lt;- sim_data$Y_binary
cov &lt;- sim_data$Covariate

# fit lucid model
fit1 &lt;- lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", family = "normal")
fit2 &lt;- lucid(G = G, Z = Z, Y = Y_binary, lucid_model = "early", family = "binary", useY = FALSE)

# including covariates
fit3 &lt;- lucid(G = G, Z = Z, Y = Y_binary, lucid_model = "early", family = "binary", CoG = cov)
fit4 &lt;- lucid(G = G, Z = Z, Y = Y_binary, lucid_model = "early", family = "binary", CoY = cov)

# tune K
fit5 &lt;- lucid(G = G, Z = Z, Y = Y_binary, lucid_model = "early", family = "binary", K = 2:3)

# variable selection
fit6 &lt;- lucid(G = G, Z = Z, Y = Y_binary, lucid_model = "early", 
family = "binary", Rho_G = seq(0.01, 0.1, by = 0.01))

# LUCID in parallel
i &lt;- 1008
set.seed(i)
G &lt;- matrix(rnorm(500), nrow = 100)
Z1 &lt;- matrix(rnorm(1000),nrow = 100)
Z2 &lt;- matrix(rnorm(1000), nrow = 100)
Z &lt;- list(Z1 = Z1, Z2 = Z2)
CoY &lt;- matrix(rnorm(200), nrow = 100)
CoG &lt;- matrix(rnorm(200), nrow = 100)
Y &lt;- rnorm(100)
best_parallel &lt;- lucid(G = G, Z = Z, Y = Y, K = list(2:4,2),
CoG = CoG, CoY = CoY, lucid_model = "parallel",
family = "normal", init_omic.data.model = "VVV",
seed = i, init_impute = "mix", init_par = "mclust",
useY = TRUE)

# LUCID in serial
best_serial &lt;- lucid(G = G, Z = Z, Y = Y, K = list(2:4,2),
CoG = CoG, CoY = CoY, lucid_model = "serial",
family = "normal", init_omic.data.model = "VVV",
seed = i, init_impute = "mix", init_par = "mclust",
useY = TRUE)

</code></pre>

<hr>
<h2 id='plot_lucid'>Visualize LUCID model through a Sankey diagram</h2><span id='topic+plot_lucid'></span>

<h3>Description</h3>

<p>In the Sankey diagram, each node either represents a variable (exposure,
omics or outcome) or a latent cluster. Each line represents an association. The
color of the node represents variable type, either exposure, omics or outcome.
The width of the line represents the effect size of a certain association; the
color of the line represents the direction of a certain association. Only work for LUCID early for now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lucid(
  x,
  G_color = "dimgray",
  X_color = "#eb8c30",
  Z_color = "#2fa4da",
  Y_color = "#afa58e",
  pos_link_color = "#67928b",
  neg_link_color = "#d1e5eb",
  fontsize = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lucid_+3A_x">x</code></td>
<td>
<p>A LUCID model fitted by <code><a href="#topic+estimate_lucid">estimate_lucid</a></code></p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_g_color">G_color</code></td>
<td>
<p>Color of node for exposure</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_x_color">X_color</code></td>
<td>
<p>Color of node for latent cluster</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_z_color">Z_color</code></td>
<td>
<p>Color of node for omics data</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_y_color">Y_color</code></td>
<td>
<p>Color of node for outcome</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_pos_link_color">pos_link_color</code></td>
<td>
<p>Color of link corresponds to positive association</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_neg_link_color">neg_link_color</code></td>
<td>
<p>Color of link corresponds to negative association</p>
</td></tr>
<tr><td><code id="plot_lucid_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size for annotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG graph created by <code><a href="networkD3.html#topic+sankeyNetwork">sankeyNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal
Y_binary &lt;- sim_data$Y_binary
cov &lt;- sim_data$Covariate

# plot lucid model
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", 
CoY = NULL, family = "normal", K = 2, seed = 1008)
plot_lucid(fit1)

# change node color
plot_lucid(fit1, G_color = "yellow")
plot_lucid(fit1, Z_color = "red")

# change link color
plot_lucid(fit1, pos_link_color = "red", neg_link_color = "green")
</code></pre>

<hr>
<h2 id='predict_lucid'>Predict cluster assignment and outcome based on LUCID model</h2><span id='topic+predict_lucid'></span>

<h3>Description</h3>

<p>Predict cluster assignment and outcome based on LUCID model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_lucid(
  model,
  lucid_model = c("early", "parallel", "serial"),
  G,
  Z,
  Y = NULL,
  CoG = NULL,
  CoY = NULL,
  response = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_lucid_+3A_model">model</code></td>
<td>
<p>A model fitted and returned by <code><a href="#topic+estimate_lucid">estimate_lucid</a></code></p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel
&quot;serial&quot; for lucid in serial.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_g">G</code></td>
<td>
<p>Exposures, a numeric vector, matrix, or data frame. Categorical variable
should be transformed into dummy variables. If a matrix or data frame, rows
represent observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_z">Z</code></td>
<td>
<p>Omics data, if &quot;early&quot;, an N by M matrix; If &quot;parallel&quot;, a list, each element i is a matrix with N rows and P_i features;
If &quot;serial&quot;, a list, each element i is a matrix with N rows and p_i features or a list with two or more matrices with N rows and a certain number of features</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_y">Y</code></td>
<td>
<p>Outcome, a numeric vector. Categorical variable is not allowed. Binary
outcome should be coded as 0 and 1.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_cog">CoG</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the latent cluster.
A numeric vector, matrix or data frame. Categorical variable should be transformed
into dummy variables.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_coy">CoY</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the association
between latent cluster and the outcome. A numeric vector, matrix or data frame.
Categorical variable should be transformed into dummy variables.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_response">response</code></td>
<td>
<p>If TRUE, when predicting binary outcome, the response will be
returned. If FALSE, the linear predictor is returned.</p>
</td></tr>
<tr><td><code id="predict_lucid_+3A_verbose">verbose</code></td>
<td>
<p>A flag indicates whether detailed information
is printed in console. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ol>
<li><p> inclusion.p: A list of inclusion probabilities for each sub-model in the LUCID model.
</p>
</li>
<li><p> pred.x: A list of predicted values for the data matrix G.
</p>
</li>
<li><p> pred.y: Predicted values for the response variable Y (if response is TRUE).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># prepare data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal

# fit lucid model
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", K = 2, family = "normal")

# prediction on training set
pred1 &lt;- predict_lucid(model = fit1, G = G, Z = Z, Y = Y_normal, lucid_model = "early")
pred2 &lt;- predict_lucid(model = fit1, G = G, Z = Z, lucid_model = "early")

</code></pre>

<hr>
<h2 id='print.sumlucid'>Print the output of LUCID in a nicer table</h2><span id='topic+print.sumlucid'></span>

<h3>Description</h3>

<p>Print the output of LUCID in a nicer table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sumlucid'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sumlucid_+3A_x">x</code></td>
<td>
<p>An object returned by <code>summary_lucid</code></p>
</td></tr>
<tr><td><code id="print.sumlucid_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>print.sumlucid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nice table/several nice tables of the summary of the LUCID model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use simulated data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal

# fit lucid model
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", family = "normal", K = 2,
seed = 1008)

# conduct bootstrap resampling
boot1 &lt;- boot_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", model = fit1, R = 100)

# print the summary of the lucid model in a table
print.sumlucid(summary_lucid(fit1))

# print the summary of the lucid model with bootstrap CIs in a table
print.sumlucid(summary_lucid(fit1, boot.se = boot1))

</code></pre>

<hr>
<h2 id='sim_data'>A simulated dataset for LUCID</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>This is an example dataset to illustrate LUCID model. It is simulated
by assuming there are 2 latent clusters in the data. We assume the exposures
are associated with latent cluster which ultimately affects the PFAS concentration
and liver injury in children. The latent clusters are also characterized by
differential levels of metabolites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data
</code></pre>


<h3>Format</h3>

<p>A list with 5 matrices corresponding to exposures (G), omics data (Z),
a continuous outcome, a binary outcome and 2 covariates (can be used either
as CoX or CoY). Each matrice contains 2000 observations.
</p>

<dl>
<dt>G</dt><dd><p>10 exposures</p>
</dd>
<dt>Z</dt><dd><p>10 metabolites</p>
</dd>
<dt>Y_normal</dt><dd><p>Outcome, PFAS concentration in children</p>
</dd>
<dt>Y_bninary</dt><dd><p>Bianry outcome, liver injury status</p>
</dd>
<dt>Covariates</dt><dd><p>2 continous covariates, can be treated as either CoX or
CoY</p>
</dd>
<dt>X</dt><dd><p>Latent clusters</p>
</dd>
</dl>


<hr>
<h2 id='simulated_HELIX_data'>A simulated HELIX dataset for LUCID</h2><span id='topic+simulated_HELIX_data'></span>

<h3>Description</h3>

<p>The Human Early-Life Exposome (HELIX) project is multi-center
research project that aims to characterize early-life environmental exposures
and associate these with omics biomarkers and child health outcomes (Vrijheid, 2014. doi: 10.1289/ehp.1307204).
We used a subset of HELIX data from Exposome Data Challenge 2021 (hold by
ISGlobal) as an example to illustrate LUCID model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated_HELIX_data
</code></pre>


<h3>Format</h3>

<p>A list with 4 matrices corresponding to exposures (G), omics data (Z),
outcome (Y) and covariates (CoY), a total of 420 observations
</p>

<dl>
<dt>exposure</dt><dd><p>1 exposures measuring the maternal exposure to utero mercury.</p>
</dd>
<dt>omics</dt><dd><p>10 methylomics, 10 transcriptomics, 10 miRNA</p>
</dd>
<dt>outcome</dt><dd><p>A continuous outcome as an indicator of metabolic-dysfunciton-associated fatty liver
disease (MAFLD)</p>
</dd>
<dt>covariate</dt><dd><p>3 covariates including fish_preg_ter, child sex, maternal
age</p>
</dd>
</dl>


<hr>
<h2 id='summary_lucid'>Summarize results of the LUCID model</h2><span id='topic+summary_lucid'></span>

<h3>Description</h3>

<p>Summarize results of the LUCID model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_lucid(object, boot.se = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_lucid_+3A_object">object</code></td>
<td>
<p>A LUCID model fitted by <code><a href="#topic+estimate_lucid">estimate_lucid</a></code></p>
</td></tr>
<tr><td><code id="summary_lucid_+3A_boot.se">boot.se</code></td>
<td>
<p>An object returned by <code><a href="#topic+boot_lucid">boot_lucid</a></code>,
which contains the bootstrap confidence intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the extracted key parameters from the LUCID model that can be used to print the summary table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use simulated data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal

# fit lucid model
fit1 &lt;- estimate_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", family = "normal", K = 2,
seed = 1008)

# conduct bootstrap resampling
boot1 &lt;- boot_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", model = fit1, R = 100)

# summarize lucid model
summary_lucid(fit1)

# summarize lucid model with bootstrap CIs
summary_lucid(fit1, boot.se = boot1)

</code></pre>

<hr>
<h2 id='tune_lucid'>A wrapper function to perform model selection for LUCID</h2><span id='topic+tune_lucid'></span>

<h3>Description</h3>

<p>Given a grid of K and L1 penalties (incluing Rho_G, Rho_Z_mu and
Rho_Z_Cov; for LUCID early only), fit LUCID model over all combinations of K and L1 penalties to
determine the optimal penalty. Note that the input of the grid of K differs for different
LUCID models. i.e. For LUCID Early, K = 3:5; for LUCID in parallel, K = list(2:3, 2:3);
for LUCID in serial, K = list(list(2:3,2),2:3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_lucid(
  G,
  Z,
  Y,
  CoG = NULL,
  CoY = NULL,
  family = c("normal", "binary"),
  K,
  lucid_model = c("early", "parallel", "serial"),
  Rho_G = 0,
  Rho_Z_Mu = 0,
  Rho_Z_Cov = 0,
  verbose_tune = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_lucid_+3A_g">G</code></td>
<td>
<p>Exposures, a numeric vector, matrix, or data frame. Categorical variable
should be transformed into dummy variables. If a matrix or data frame, rows
represent observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_z">Z</code></td>
<td>
<p>Omics data, if &quot;early&quot;, an N by M matrix; If &quot;parallel&quot;, a list, each element i is a matrix with N rows and P_i features;
If &quot;serial&quot;, a list, each element i is a matrix with N rows and p_i features or a list with two or more matrices with N rows and a certain number of features</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_y">Y</code></td>
<td>
<p>Outcome, a numeric vector. Categorical variable is not allowed. Binary
outcome should be coded as 0 and 1.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_cog">CoG</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the latent cluster.
A numeric vector, matrix or data frame. Categorical variable should be transformed
into dummy variables.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_coy">CoY</code></td>
<td>
<p>Optional, covariates to be adjusted for estimating the association
between latent cluster and the outcome. A numeric vector, matrix or data frame.
Categorical variable should be transformed into dummy variables.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_family">family</code></td>
<td>
<p>Distribution of outcome. For continuous outcome, use &quot;normal&quot;;
for binary outcome, use &quot;binary&quot;. Default is &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_k">K</code></td>
<td>
<p>Number of latent clusters. If &quot;early&quot;, an integer;If &quot;parallel&quot;,a list, each element is an integer/integer vector, same length as Z;
If &quot;serial&quot;, a list, each element is either an integer or an list of integers, same length as Z.
If K is given as a grid, the input of the grid of K differs for different
LUCID models. i.e. For LUCID Early, K = 3:5; for LUCID in parallel, K = list(2:3, 2:3);
for LUCID in serial, K = list(list(2:3,2),2:3)</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_lucid_model">lucid_model</code></td>
<td>
<p>Specifying LUCID model, &quot;early&quot; for early integration, &quot;parallel&quot; for lucid in parallel,
&quot;serial&quot; for lucid in serial</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_rho_g">Rho_G</code></td>
<td>
<p>A scalar or a vector. This parameter is the LASSO penalty to regularize
exposures. If it is a vector, <code>tune_lucid</code> will conduct
model selection and variable selection. User can try penalties from 0 to 1. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_rho_z_mu">Rho_Z_Mu</code></td>
<td>
<p>A scalar or a vector. This parameter is the LASSO penalty to
regularize cluster-specific means for omics data (Z). If it is a vector,
<code>tune_lucid</code> will conduct model selection and
variable selection. User can try penalties from 1 to 100. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_rho_z_cov">Rho_Z_Cov</code></td>
<td>
<p>A scalar or a vector. This parameter is the graphical LASSO
penalty to estimate sparse cluster-specific variance-covariance matrices for omics
data (Z). If it is a vector, <code>tune_lucid</code> will conduct
model selection and variable selection. User can try penalties from 0 to 1. Work for LUCID early only.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_verbose_tune">verbose_tune</code></td>
<td>
<p>A flag to print details of tuning process.</p>
</td></tr>
<tr><td><code id="tune_lucid_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>estimate_lucid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list:
</p>
<table>
<tr><td><code>best_model</code></td>
<td>
<p>the best model over different combination of tuning parameters</p>
</td></tr>
<tr><td><code>tune_list</code></td>
<td>
<p>a data frame contains combination of tuning parameters and c
orresponding BIC</p>
</td></tr>
<tr><td><code>res_model</code></td>
<td>
<p>a list of LUCID models corresponding to each combination of
tuning parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# use simulated data
G &lt;- sim_data$G
Z &lt;- sim_data$Z
Y_normal &lt;- sim_data$Y_normal

# find the optimal model over the grid of K
tune_K &lt;- tune_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early",
 useY = FALSE, tol = 1e-3,
seed = 1, K = 2:5)

# tune penalties
tune_Rho_G &lt;- tune_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early",
 useY = FALSE, tol = 1e-3,
seed = 1, K = 2, Rho_G = c(0.1, 0.2, 0.3, 0.4))
tune_Rho_Z_Mu &lt;- tune_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", 
useY = FALSE, tol = 1e-3,
seed = 1, K = 2, Rho_Z_Mu = c(10, 20, 30, 40))
tune_Rho_Z_Cov &lt;- tune_lucid(G = G, Z = Z, Y = Y_normal, lucid_model = "early", 
useY = FALSE, tol = 1e-3,
seed = 1, K = 2, Rho_Z_Cov = c(0.1, 0.2, 0.3))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
