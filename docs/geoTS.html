<!DOCTYPE html><html lang="en"><head><title>Help for package geoTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geoTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geoTS-package'><p>Methods for Handling and Analyzing Time Series of Satellite Images</p></a></li>
<li><a href='#haRmonics'><p>Harmonic analysis for time series</p></a></li>
<li><a href='#hetervar'><p>Heteroscedastic variance estimation for remotely-sensed data</p></a></li>
<li><a href='#master'><p>Land Mask of eastern Yucatan Peninsula</p></a></li>
<li><a href='#matrixToRaster'><p>Creates a RasterLayer object from a matrix</p></a></li>
<li><a href='#maxLagMissVal'><p>Get maximum lag of missing values</p></a></li>
<li><a href='#MOD13Q1_NDVI_2000129_009'><p>MOD13Q1 NDVI binary file</p></a></li>
<li><a href='#MOD13Q1_NDVI_Mohinora'><p>16-day MOD13Q1 NDVI RasterStack</p></a></li>
<li><a href='#raster_intersect_sp'><p>Intersects raster and sp objects</p></a></li>
<li><a href='#shp_mohinora'><p>SpatialPolygonsDataFrame for Cerro Mohinora</p></a></li>
<li><a href='#split_replace'><p>Splits a Raster* object into smaller chunks and allows to replace cell values</p></a></li>
<li><a href='#transfer_bin_raster'><p>Transfer values from a binary image file to a raster file</p></a></li>
<li><a href='#transfer_raster_RData'><p>Transfer values from a Raster* object to an RData file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Handling and Analyzing Time Series of Satellite
Images</td>
</tr>
<tr>
<td>Author:</td>
<td>Inder Tecuapetla-Gómez [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Inder Tecuapetla-Gómez
&lt;itecuapetla@conabio.gob.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions and methods for: splitting large raster objects
             into smaller chunks, transferring images from a binary format into raster 
             layers, transferring raster layers into an 'RData' file, calculating the 
             maximum gap (amount of consecutive missing values) of a numeric vector, 
             and fitting harmonic regression models to periodic time series. The homoscedastic
             harmonic regression model is based on G. Roerink, M. Menenti and W. Verhoef (2000) &lt;<a href="https://doi.org/10.1080%2F014311600209814">doi:10.1080/014311600209814</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), raster (&ge; 2.9.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel (&ge; 1.0.14), ff (&ge; 2.2-14), foreach (&ge; 1.4.4),
parallel (&ge; 3.6.1), robustbase (&ge; 0.95-0), sp (&ge; 1.2-0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-17 00:48:07 UTC; itecuapetla</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-17 18:10:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='geoTS-package'>Methods for Handling and Analyzing Time Series of Satellite Images</h2><span id='topic+geoTS-package'></span>

<h3>Description</h3>

<p>We provide tools for handling time series of satellite images as well
as some statistical methods for spatio-temporal analysis
</p>


<h3>Tools for handling time series of satellite images</h3>

<p><code><a href="#topic+transfer_bin_raster">transfer_bin_raster</a></code> transfers data from images originally
recorded in a binary format to images in any of the formats
allowed by the <code><a href="raster.html#topic+raster-package">raster-package</a></code>. Similarly, 
<code><a href="#topic+transfer_raster_RData">transfer_raster_RData</a></code> extracts the entries of
images originally recorded in <code><a href="grDevices.html#topic+tiff">tiff</a></code> format, virtually stores them 
in an <code><a href="base.html#topic+array">array</a></code> object and, finally, this array is saved in an <code>RData</code> file.
<code><a href="#topic+split_replace">split_replace</a></code> allows us to split <code>Raster*</code> objects, which can
be arguably large, into smaller chunks. These chunks can be saved
in any of the formats allowed by <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>. Often, satellite
images come with missing values (or fill values assigned by other computer
programs), <code><a href="#topic+split_replace">split_replace</a></code> allows to replace these values by
values of users' convenience; see also <code>reclassify</code>. 
<code><a href="#topic+raster_intersect_sp">raster_intersect_sp</a></code> allows us to obtain data in the intersection of
<code>Raster*</code> and <code>SpatialPolygonsDataFrame</code> objects.
</p>


<h3>Methods for analyzing time series of satellite images</h3>

<p><code><a href="#topic+haRmonics">haRmonics</a></code> allows us to fit harmonic regression models
to numeric vectors; the method <code>hants</code> is based on <cite>Roerink et al. (2000)</cite>
whereas the method <code>harmR</code> is based on <cite>Jakubauskas et al. (2001)</cite>.
The <code>wls_harmR</code> is the weighted least squares method which requires pre-estimation
of heteroscedastic variance; <code><a href="#topic+hetervar">hetervar</a></code> allows for heteroscedastic variance
estimation for numeric vectors extracted from time series of satellite imagery. 
</p>
<p>geoTS include the following datasets:
</p>

<ul>
<li> <p><code><a href="#topic+master">master</a></code>: <code>RasterLayer</code> with a land mask of eastern Yucatan 
Peninsula, Mexico.
</p>
</li>
<li> <p><code><a href="#topic+MOD13Q1_NDVI_2000129_009">MOD13Q1_NDVI_2000129_009</a></code>: A spatial subset of NDVI measurements
taken over the eastern Yucatan Peninsula, Mexico in 2000.
</p>
</li>
<li> <p><code><a href="#topic+MOD13Q1_NDVI_Mohinora">MOD13Q1_NDVI_Mohinora</a></code>: <code>RasterStack</code> containing 23 spatial 
subsets of 16-day NDVI images of <b>Cerro Mohinora</b> acquired in 2001.
</p>
</li>
<li> <p><code><a href="#topic+shp_mohinora">shp_mohinora</a></code>: <code>SpatialPolygonsDataFrame</code> delimiting
the smallest Protected Area of Flora and Fauna in Mexico (<b>Cerro Mohinora</b>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tecuapetla-Gomez, I. <a href="mailto:itecuapetla@conabio.gob.mx">itecuapetla@conabio.gob.mx</a>
</p>


<h3>References</h3>

<p>Roerink, G.J., Menenti, M., Verhoef, W. (2000).
<em>Reconstructing clodfree NDVI composites using Fourier analysis of time series</em>, 
Int. J. Remote Sensing, <b>21(9)</b>, 1911&ndash;1917.
</p>
<p>Jakubauskas, M., Legates, D., Kastens, J. (2001).
<em>Harmonic analysis of time-series AVHRR NDVI data</em>,
Photogrammetric Engineering and Remote Sensing, <b>67(4)</b>, 461&ndash;470.
</p>
<p>The Matlab implementation of HANTS can be found 
<a href="https://nl.mathworks.com/matlabcentral/fileexchange/38841-matlab-implementation-of-harmonic-analysis-of-time-series-hants">here</a>.
</p>

<hr>
<h2 id='haRmonics'>Harmonic analysis for time series</h2><span id='topic+haRmonics'></span>

<h3>Description</h3>

<p>Fits harmonic regression models, that is, computes amplitudes and phase angles 
in the typical harmonic regression framework. When <code>method=harmR</code> the ordinary
least squares method is used, when <code>method=wls_harmR</code> then, weighted least squares
are employed. Based on these estimates a harmonic regression function is fitted. 
Also fits <code>hants</code>, a popular iterative algorithm that computes amplitudes and phase angles in the 
harmonic regression framework. As part of the iterative algorithm, observations
are being excluded from the design matrix of the regression model if the distance
between them and the fitted curve exceeds the value of the parameter <code>fitErrorTol</code>.
<code>hants</code> is based on implementations with the same name written in Fortran 
and Matlab computer languages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haRmonics(
  y,
  method = c("harmR", "wls_harmR", "hants"),
  sigma = NULL,
  ts = 1:length(y),
  lenPeriod = length(y),
  numFreq,
  HiLo = c("Hi", "Lo"),
  low,
  high,
  fitErrorTol,
  degreeOverDeter,
  delta
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haRmonics_+3A_y">y</code></td>
<td>
<p>numeric vector containing time series on which harmonic 
regression will be fitted. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_method">method</code></td>
<td>
<p>character specifying algorithm to apply: <code>harmR</code> (default),
<code>wls_harmR</code> (heteroscedastic model) or <code>hants</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector of length <code>lenPeriod</code> containing variance estimates.
Default set <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_ts">ts</code></td>
<td>
<p>numeric vector of <code>length(y)</code> with the sampling
points for <code>y</code>. Default is <code class="reqn">ts[i] = i, i=1,\ldots, 
\code{length(y)}</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_lenperiod">lenPeriod</code></td>
<td>
<p>numeric giving the length of the base period, reported in 
samples, e.g. days, dekads, months, years, etc.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_numfreq">numFreq</code></td>
<td>
<p>numeric indicating the total number of frequencies to be 
used in harmonic regression. For technical reasons, <code>2*numFreq+1</code>
must be lesser than <code>length(y)</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_hilo">HiLo</code></td>
<td>
<p>character indicating whether high or low outliers must be rejected
when <code>method=hants</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_low">low</code></td>
<td>
<p>numeric giving minimum valid value of fitted harmonic regression 
function when <code>method=hants</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_high">high</code></td>
<td>
<p>numeric giving maximum valid value of fitted harmonic regression
function when <code>method=hants</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_fiterrortol">fitErrorTol</code></td>
<td>
<p>numeric giving maximum allowed distance between observations and fitted
curve; if difference between a given observation and its fitted value 
exceeds <code>fitErrorTol</code> then this observation will not be included
in the fitting procedure in the next iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_degreeoverdeter">degreeOverDeter</code></td>
<td>
<p>numeric; iteration stops when number of observations equals
number of observations for curve fitting plus <code>degreeOverDeter</code>;
the latter in turns is by definition <code>length(y)</code> minus
<code>min(2 * numFreq+1, length(y))</code>.</p>
</td></tr>
<tr><td><code id="haRmonics_+3A_delta">delta</code></td>
<td>
<p>numeric (positive) giving a (small) regularization parameter to prevent 
non-invertible hat matrix (see <b>Details</b>), probably caused by high
amplitudes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods <code>harmR</code> and <code>wls_harmR</code> do not allow missing values 
and utilize parameters <code>y</code>, <code>lenPeriod</code>, <code>numFreq</code> and <code>delta</code> 
only. 
</p>
<p>Method <code>hants</code> utilizes all the parameters presented above. This method 
does not allow missing values. Missing values in <code>y</code> must be substituted by values 
considerably out of observations range.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>a.coef</code></td>
<td>
<p>a numeric vector with estimates of cosine coefficients</p>
</td></tr>
<tr><td><code>b.coef</code></td>
<td>
<p>a numeric vector with estimates of sine coefficients</p>
</td></tr>
<tr><td><code>amplitude</code></td>
<td>
<p>a numeric vector with amplitude estimates.</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>a numeric vector with phase estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a numeric vector with fitted values via harmonic regression.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>lenBasePeriod</code> was used until version 0.1.3, this argument has been
replaced by <code>lenPeriod</code>.
</p>


<h3>References</h3>

<p>Roerink, G.J., Menenti, M., Verhoef, W. (2000).
<em>Reconstructing cloudfree NDVI composites using Fourier analysis of time series</em>, 
Int. J. Remote Sensing, <b>21(9)</b>, 1911&ndash;1917.
</p>
<p>Jakubauskas, M., Legates, D., Kastens, J. (2001).
<em>Harmonic analysis of time-series AVHRR NDVI data</em>,
Photogrammetric Engineering and Remote Sensing, <b>67(4)</b>, 461&ndash;470.
</p>
<p>The Matlab implementation of HANTS can be found 
<a href="https://nl.mathworks.com/matlabcentral/fileexchange/38841-matlab-implementation-of-harmonic-analysis-of-time-series-hants">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(5, 2, 5, 10, 12, 18, 20, 23, 27, 30, 40, 60, 66,
70, 90, 120, 160, 190, 105, 210, 104, 200, 90, 170,
50, 120, 80, 60, 50, 40, 30, 28, 24, 20, 15, 10)
# -------------------------------------------------------------------------- 
fit_harmR &lt;- haRmonics(y = y, numFreq = 3, delta = 0.1)
fitLow_hants &lt;- haRmonics(y = y, method = "hants", numFreq = 3, HiLo = "Lo", 
                         low = 0, high = 255, fitErrorTol = 5, degreeOverDeter = 1, 
                         delta = 0.1)
fitHigh_hants &lt;- haRmonics(y = y, method = "hants", numFreq = 3, HiLo = "Hi", 
                          low = 0, high = 255, fitErrorTol = 5, degreeOverDeter = 1, 
                          delta = 0.1)
plot(y, pch = 16, main = "haRmonics fitting")
lines(fit_harmR$fitted ,lty = 4, col = "green")
lines(fitLow_hants$fitted, lty = 4, col = "red")
lines(fitHigh_hants$fitted, lty = 2, col = "blue")
# -------------------------------------------------------------------------- 
# Substituting missing value by a number outside observations range
# -------------------------------------------------------------------------- 
y1 &lt;- y
y1[20] &lt;- -10

fitLow_hants_missing &lt;- haRmonics(y = y1, method = "hants", numFreq = 3, HiLo = "Lo", 
                                 low = 0, high = 255, fitErrorTol = 5, degreeOverDeter = 1, 
                                 delta = 0.1)
fitHigh_hants_missing &lt;- haRmonics(y = y1, method = "hants", numFreq = 3, HiLo = "Hi", 
                                  low = 0, high = 255, fitErrorTol = 5, degreeOverDeter = 1, 
                                  delta = 0.1)
fit_harmR_missing &lt;- haRmonics(y = y1, numFreq = 3, delta = 0.1)

plot(y1, pch = 16, main = "haRmonics fitting (missing values)", ylim = c(-1,210))
lines(fitLow_hants_missing$fitted, lty = 4, col = "red")
lines(fitHigh_hants_missing$fitted, lty = 2, col = "blue")
lines(fit_harmR_missing$fitted, lty = 4, col = "green")

</code></pre>

<hr>
<h2 id='hetervar'>Heteroscedastic variance estimation for remotely-sensed data</h2><span id='topic+hetervar'></span>

<h3>Description</h3>

<p>Variance of some remotely-sensed Earth data is time-varying. Utilizing the 
observations per period (season, year), this function allows for estimation
of variability in data either as numeric vector or matricial form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetervar(
  x,
  m = NULL,
  lenPeriod = 23,
  method = c("standard", "robust-mad", "robust-Qn")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hetervar_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="hetervar_+3A_m">m</code></td>
<td>
<p>matrix with <code>nrow</code> equal to the number of periods (seasons 
or years) analyzed and <code>ncol</code> equal to the number of observations 
per period</p>
</td></tr>
<tr><td><code id="hetervar_+3A_lenperiod">lenPeriod</code></td>
<td>
<p>numeric giving the number of observations per period.
Default, 23.</p>
</td></tr>
<tr><td><code id="hetervar_+3A_method">method</code></td>
<td>
<p>character specifying whether <code>standard</code> variance,
the median absolute deviation (<code>robust-mad</code>) or
the more efficient robust variance estimator (<code>robust-Qn</code>) 
should be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed for data extracted from time series of satellite imagery. Then, it is expected that 
<code>length(x)</code> be a multiple of <code>lenPeriod</code>. When <code>m</code> is provided,
<code>ncol(m)</code> must be equal to <code>lenPeriod</code>. Default of <code>lenPeriod</code> corresponds to the 
temporal resolution of some MODIS products.
</p>
<p>Method <code>standard</code> invokes <code><a href="stats.html#topic+sd">sd</a></code> whereas <code>robust-mad</code>
uses the median absolute deviation of <code><a href="stats.html#topic+mad">mad</a></code> and <code>robust-Qn</code>
utilizes the robust scale estimator implemented in <code><a href="robustbase.html#topic+Qn">Qn</a></code>.
</p>
<p>This function does not allow missing values.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>lenPeriod</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>, <code><a href="robustbase.html#topic+Qn">Qn</a></code>
</p>

<hr>
<h2 id='master'>Land Mask of eastern Yucatan Peninsula</h2><span id='topic+master'></span>

<h3>Description</h3>

<p>A <code>RasterLayer</code> with a spatial subset covering eastern Yucatan Peninsula
of Mexico. A land mask is a binary layer where <code>1=Land</code>, <code>0=Water</code>.
</p>


<h3>master.tif</h3>

<p>A <code>RasterLayer</code> object with 500 rows, 600 columns. Each cell has a resolution
of 250m.
</p>

<hr>
<h2 id='matrixToRaster'>Creates a RasterLayer object from a matrix</h2><span id='topic+matrixToRaster'></span>

<h3>Description</h3>

<p>Transforms a <code>matrix</code> into a <code>RasterLayer</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToRaster(matrix, raster = NULL, projection = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixToRaster_+3A_matrix">matrix</code></td>
<td>
<p>a matrix object. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="matrixToRaster_+3A_raster">raster</code></td>
<td>
<p>a <code>RasterLayer</code> object whose extent and projection are used to
create a raster from <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="matrixToRaster_+3A_projection">projection</code></td>
<td>
<p>a character vector providing a coordinate reference system. 
Required when <code>ncol(matrix)=3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>ncol(matrix)=3</code>, this function assumes that the first two
columns of argument <code>matrix</code> provide coordinates to create a <code>RasterLayer</code>,
hence argument <code>projection</code> must be provided. When argument <code>matrix</code> has 
only 2 columns, then the argument <code>raster</code> must be provided because its 
<code><a href="sp.html#topic+coordinates">coordinates</a></code> and <code><a href="raster.html#topic+projection">projection</a></code> will be used 
to rasterize <code>matrix</code>.
</p>


<h3>Value</h3>

<p>A <code>RasterLayer</code>
</p>


<h3>Note</h3>

<p>In previous versions, <code>raster</code> argument was written in capital letters.
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+Raster-class">Raster-class</a></code>
</p>

<hr>
<h2 id='maxLagMissVal'>Get maximum lag of missing values</h2><span id='topic+maxLagMissVal'></span>

<h3>Description</h3>

<p>This function computes the maximum amount of consecutive missing values in a vector.
This quantity is also known as maximum lag, run, or record, and can be used as a
rough estimate of the quality of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLagMissVal(x, type = c("NA", "numeric"), value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxLagMissVal_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="maxLagMissVal_+3A_type">type</code></td>
<td>
<p>character specifying the type of missing value to consider. Default is 
<code>type="NA"</code>; when <code>type="numeric"</code>, <code>value</code> must be provided.</p>
</td></tr>
<tr><td><code id="maxLagMissVal_+3A_value">value</code></td>
<td>
<p>numeric giving a figure to be used to fill missing values; often as part
of a pre-processing, missing values in a dataset (vector, time series, etc.)
are fill in with pre-established values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>maxLag</code></td>
<td>
<p>numeric giving the maximum lag of missing values in <code>x</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>numeric vector with the original data</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>a numeric when <code>type=numeric</code>, <code>NA</code> otherwise</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rle">rle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(NA, 0.12, 0.58, 0.75, NA, NA, NA, 0.46, 0.97, 0.39,
       NA, 0.13, 0.46, 0.95, 0.30, 0.98, 0.23, 0.98,
       0.68, NA, NA, NA, NA, NA, 0.11, 0.10, 0.79, 0.46, 0.27,
       0.44, 0.93, 0.20, 0.44, 0.66, 0.11, 0.88)
maxLagMissVal(x=v, type="NA")

w &lt;- c(23,3,14,3,8,3,3,3,3,3,3,3,10,14,15,3,10,3,3,6)
maxLagMissVal(x = w, type = "numeric", value = 3)
       
</code></pre>

<hr>
<h2 id='MOD13Q1_NDVI_2000129_009'>MOD13Q1 NDVI binary file</h2><span id='topic+MOD13Q1_NDVI_2000129_009'></span>

<h3>Description</h3>

<p>Spatial subset of a MOD13Q1 NDVI layer, in binary format, covering eastern 
Yucatan Peninsula, Mexico. <a href="https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index">NDVI</a> stands for Normalized Difference
Vegetation Index; NDVI = (NIR-RED)/(NIR+RED) where NIR and RED are the Near
Infrared and Red bands of the MODIS product, respectively. More information
about the MODIS mission can be found <a href="https://modis.gsfc.nasa.gov/about/">here</a>.
</p>


<h3>MOD13Q1_NDVI_2000129_009.bin</h3>

<p>This image contains NDVI measurements for the 129-th Julian day of 2000; the
subscript <em>_009</em> signifies that this was the 9th NDVI observation of 2000.
</p>

<hr>
<h2 id='MOD13Q1_NDVI_Mohinora'>16-day MOD13Q1 NDVI RasterStack</h2><span id='topic+MOD13Q1_NDVI_Mohinora'></span>

<h3>Description</h3>

<p>A <code>RasterStack</code> containing 23 layers of NDVI for 2001. This <code>RasterStack</code> 
is a spatial subset covering the Protected Area of Flora and Fauna <b>Cerro Mohinora</b> 
at Chihuahua, Mexico.
</p>


<h3>MOD13Q1_NDVI_Mohinora.tif</h3>

<p>A <code>RasterStack</code> object with 59 rows, 93 columns, 5487 cells and 23 layers.
</p>

<hr>
<h2 id='raster_intersect_sp'>Intersects raster and sp objects</h2><span id='topic+raster_intersect_sp'></span>

<h3>Description</h3>

<p>Straightforward application of <code><a href="raster.html#topic+crop">crop</a></code> and 
<code><a href="raster.html#topic+mask">mask</a></code> to extract the data in the intersection of
<code>Raster*</code> and <code>SpatialPolygonsDataframe</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_intersect_sp(
  x,
  y,
  features,
  save = FALSE,
  dirToSave,
  baseName = "x_intersect_y",
  format = "GTiff"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster_intersect_sp_+3A_x">x</code></td>
<td>
<p><code>Raster*</code> object</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_y">y</code></td>
<td>
<p><code>SpatialPolygonsDataFrame</code> object</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_features">features</code></td>
<td>
<p>integer vector. Should some specifying features (polygons) of <code>y</code>
be intersected with <code>x</code>? When not provided, whole <code>y</code>
is intersected with <code>x</code>.</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_save">save</code></td>
<td>
<p>logical. Should the output be saved? Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_dirtosave">dirToSave</code></td>
<td>
<p>character specifying where to save output. Required when <code>save=TRUE</code>.</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_basename">baseName</code></td>
<td>
<p>character. What should be the base name of output file? Default,
<code>x_intersect_y</code>.</p>
</td></tr>
<tr><td><code id="raster_intersect_sp_+3A_format">format</code></td>
<td>
<p>character specifying output file format. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code>
for all supported formats. Default, <code>"GTiff"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>save=TRUE</code>, <code><a href="raster.html#topic+writeRaster">writeRaster</a></code> is used with
argument <code>datatype=dataType(subset(x,1))</code>.
</p>


<h3>Value</h3>

<p>An object of class identical to that of argument <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raster_path = system.file("extdata", "MOD13Q1_NDVI_Mohinora.tif", package = "geoTS")
rasterSTACK &lt;- stack(raster_path)
dir.create(path=paste0(system.file("extdata", package="geoTS"), "/output_raster_inter_sp"),
          showWarnings=FALSE)
dirToSave = paste0(system.file("extdata", package="geoTS"), "/output_raster_inter_sp")

raster_intersect_sp(x=rasterSTACK, y=shp_mohinora, save=TRUE, dirToSave=dirToSave, 
                    baseName="mohinora_NDVI_2001")


</code></pre>

<hr>
<h2 id='shp_mohinora'>SpatialPolygonsDataFrame for Cerro Mohinora</h2><span id='topic+shp_mohinora'></span>

<h3>Description</h3>

<p>A <code>RData</code> file containing a <code>SpatialPolygonsDataFrame</code> object
delimiting <b>Cerro Mohinora</b> at Chihuhua, the smallest Protected Area 
of Flora and Fauna in Mexico.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shp_mohinora)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>SpatialPolygonsDataFrame</code>.
</p>

<hr>
<h2 id='split_replace'>Splits a Raster* object into smaller chunks and allows to replace cell values</h2><span id='topic+split_replace'></span>

<h3>Description</h3>

<p>This function will split a Raster* object into smaller chunks. The size of these chunks (number of cells) 
is controlled by <code>partPerSide</code>, <code>h</code> or <code>v</code>. Additionally, it allows to replace cell values (<code>valToReplace</code>) 
within Raster* object by another value of user's choice (<code>replacedBy</code>). When <code>save = TRUE</code>, 
the resulting <code>cellsToProcess</code> Raster* objects are saved in directory <code>outputPath</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_replace(
  raster,
  partPerSide,
  h,
  v,
  outputPath,
  name,
  save = TRUE,
  replace = FALSE,
  valToReplace,
  replacedBy,
  dataType,
  format = "GTiff",
  parallelProcessing = FALSE,
  numCores = 20,
  cellsToProcess,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_replace_+3A_raster">raster</code></td>
<td>
<p>Raster* object.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_partperside">partPerSide</code></td>
<td>
<p>integer indicating number of cells in which <code>raster</code> will be split 
in each direction (horizontally and vertically). Use when <code>nrow(raster)</code> and 
<code>ncol(raster)</code> are multiples of <code>partPerSide</code>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_h">h</code></td>
<td>
<p>integer indicating number of horizontal cells in which <code>raster</code> will be split.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_v">v</code></td>
<td>
<p>integer indicating number of vertical cells in which <code>raster</code> will be split.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_outputpath">outputPath</code></td>
<td>
<p>character with full path name where the resulting Raster* objects will be saved.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_name">name</code></td>
<td>
<p>character with the name to assign to final products.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_save">save</code></td>
<td>
<p>logical, should the output be saved, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_replace">replace</code></td>
<td>
<p>logical, default <code>FALSE</code>, when <code>TRUE</code>, <code>valToReplace</code> and <code>replacedBy</code> must by specified.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_valtoreplace">valToReplace</code></td>
<td>
<p>indicates a value to be replaced across <code>raster</code> cells.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_replacedby">replacedBy</code></td>
<td>
<p>indicates the value by which <code>valToReplace</code> is replaced.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_datatype">dataType</code></td>
<td>
<p>character, output data type. See <code><a href="raster.html#topic+dataType">dataType</a></code>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_format">format</code></td>
<td>
<p>character, output file type, default <code>"GTiff"</code>. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_parallelprocessing">parallelProcessing</code></td>
<td>
<p>logical, default <code>FALSE</code>, when <code>TRUE</code> raster splitting is done in parallel. See
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_numcores">numCores</code></td>
<td>
<p>numeric indicating the number of cores used in parallel processing.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_cellstoprocess">cellsToProcess</code></td>
<td>
<p>numeric vector indicating which smaller cells should be processed/saved. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="split_replace_+3A_...">...</code></td>
<td>
<p>additional arguments used by <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before processing any of the <code>cellsToProcess</code> the temporary raster 
directory is re-directed. Basically, prior to process the i-th cell, 
at <code>outputPath</code> a new subdirectory is created, which, in turn, is erased 
automatically once the i-th cell has been processed. As a result of several tests 
we found that this measure avoids memory overflow.
</p>
<p>When <code>partPerSide</code> is used, <code>cellsToProcess = 1:(partPerSide^2)</code>. When <code>h</code>
and <code>v</code> are used, <code>cellsToProcess = 1:(ncells(raster)/(h*v))</code>. Since the code
assumes that <code>nrow(raster)</code> and <code>ncol(raster)</code> are multiples of <code>partPerSide</code>
or <code>h</code> and <code>v</code>, respectively, the user must be careful when selecting these
parameters.
</p>
<p>For <code>parallelProcessing</code> the backend <code><a href="doParallel.html#topic+doParallel">doParallel</a></code> is employed.
</p>


<h3>Value</h3>

<p>At <code>outputPath</code> the user will find <code>length(cellsToProcess)</code> Raster* files
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+writeRaster">writeRaster</a></code>, <code><a href="raster.html#topic+aggregate">aggregate</a></code>, 
<code><a href="raster.html#topic+rasterOptions">rasterOptions</a></code>
</p>

<hr>
<h2 id='transfer_bin_raster'>Transfer values from a binary image file to a raster file</h2><span id='topic+transfer_bin_raster'></span>

<h3>Description</h3>

<p>Get the values of a binary file (in integer format) and transfer them to a raster file. All formats
considered in <code><a href="raster.html#topic+writeRaster">writeRaster</a></code> are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_bin_raster(
  inputPath,
  outputPath,
  master,
  what = integer(),
  signed = TRUE,
  endian = "little",
  size = 2,
  format = "GTiff",
  dataType = "INT2S",
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transfer_bin_raster_+3A_inputpath">inputPath</code></td>
<td>
<p>character with full path name of input file(s).</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_outputpath">outputPath</code></td>
<td>
<p>character with full path name (where the raster files will be saved).</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_master">master</code></td>
<td>
<p>character with full path name of a raster file; extent and projection
of this file are applied to this function output.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_what">what</code></td>
<td>
<p>See <code><a href="base.html#topic+readBin">readBin</a></code>. Default <code>integer()</code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_signed">signed</code></td>
<td>
<p>See <code><a href="base.html#topic+readBin">readBin</a></code>. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_endian">endian</code></td>
<td>
<p>See <code><a href="base.html#topic+readBin">readBin</a></code>. Default <code>"little"</code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_size">size</code></td>
<td>
<p>integer, number of bytes per element in the byte stream, default 2. See <code><a href="base.html#topic+readBin">readBin</a></code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_format">format</code></td>
<td>
<p>character, output file type. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_datatype">dataType</code></td>
<td>
<p>character, output data type. See <code><a href="raster.html#topic+dataType">dataType</a></code>.</p>
</td></tr>
<tr><td><code id="transfer_bin_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>logical, default <code>TRUE</code>, should the resulting raster be overwritten.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>At the designated path (<code>outputPath</code>) the user will find <code>TIF</code> file(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
inputPath = system.file("extdata", package = "geoTS")
masterFile = system.file("extdata", "master.tif", package = "geoTS") 
transfer_bin_raster(inputPath = inputPath, outputPath = inputPath, 
                    master = masterFile, what = integer(),
                    signed = TRUE, endian = "little", size = 2,
                    format = "GTiff", dataType = "INT2S", overwrite = TRUE)


</code></pre>

<hr>
<h2 id='transfer_raster_RData'>Transfer values from a Raster* object to an RData file</h2><span id='topic+transfer_raster_RData'></span>

<h3>Description</h3>

<p>Get the values of a Raster*, storage them into an <code><a href="base.html#topic+array">array</a></code> and
finally save the array in an <code>RData</code> which allows for compatibility with multiple 
R functions as well as great portability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_raster_RData(
  inputFile,
  outputPath,
  transferOneFile = TRUE,
  vmode = c("integer", "single", "double")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transfer_raster_RData_+3A_inputfile">inputFile</code></td>
<td>
<p>character with full path name of input file.</p>
</td></tr>
<tr><td><code id="transfer_raster_RData_+3A_outputpath">outputPath</code></td>
<td>
<p>character with full path name (where the <code>RData</code> file will be saved). 
No need to provide extension <code>.RData</code>.</p>
</td></tr>
<tr><td><code id="transfer_raster_RData_+3A_transferonefile">transferOneFile</code></td>
<td>
<p>logical, default <code>TRUE</code> indicates that one file will be transferred.
<code>FALSE</code> indicates that more than one file will be transferred. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="transfer_raster_RData_+3A_vmode">vmode</code></td>
<td>
<p>a character specifying the type of virtual storage mode <code><a href="ff.html#topic+vmode">vmode</a></code> 
needed. Only <code>integer</code>, <code>single</code> and <code>double</code> are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior to embark the user in a transfer that may not be successful due to the
lack of RAM, this function provides an estimate of the amount of bytes to be used
in the transfer process. The estimate is obtained by multiplying the number of rows by the number of 
columns by the number of layers of the <code>Raster*</code> object to transfer by the amount of 
bites used by <code>vmode</code> (32-bit float for <code>integer</code> or <code>single</code> and 
64-bit float for <code>double</code>). A question is displayed in the console requesting whether
the process should continue. Should the user decide not to continue with the 
importation <code>transfer_raster_RData</code> returns the message <code>"Did not transfer anything"</code>.
</p>
<p>When <code>transferOneFile=FALSE</code>, it is assumed that the system has enough RAM to support full files
transfer -no question is asked in the console. This option is useful when this function is used within
a <code>for</code> loop.
</p>


<h3>Value</h3>

<p>At the designated path (<code>outputPath</code>) the user will find an <code>RData</code> file.
</p>


<h3>See Also</h3>

<p><code><a href="ff.html#topic+vmode">vmode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
inputFile = system.file("extdata", "master.tif", package = "geoTS")
outputPath = paste0(system.file("extdata", package = "geoTS"), "/master")
transfer_raster_RData(inputFile = inputFile, outputPath = outputPath, 
                      vmode = "single")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
