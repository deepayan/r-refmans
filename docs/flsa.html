<!DOCTYPE html><html lang="en"><head><title>Help for package flsa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flsa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flsa'><p>Fused Lasso Signal Approximator</p></a></li>
<li><a href='#is.connListObj'><p>Connection List Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Path Algorithm for the General Fused Lasso Signal Approximator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Holger Hoefling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Holger Hoefling &lt;hhoeflin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a path algorithm for the Fused Lasso Signal Approximator.
    For more details see the help files or the article by Hoefling (2009) &lt;<a href="https://doi.org/10.48550/arXiv.0910.0526">doi:10.48550/arXiv.0910.0526</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 18:51:10 UTC; hhoeflin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 23:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='flsa'>Fused Lasso Signal Approximator</h2><span id='topic+flsa'></span><span id='topic+FLSA'></span><span id='topic+flsaGetSolution'></span><span id='topic+flsaTopDown'></span>

<h3>Description</h3>

<p>These functions are the main interface functions for calculating FLSA solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flsa(y, lambda1=0, lambda2=NULL, connListObj = NULL, splitCheckSize=1e+09, 
    verbose=FALSE, thr = 1e-09, maxGrpNum=4*length(y))
flsaTopDown(y, lambda1=0, groups=1:length(y), lambda2=NULL)
flsaGetSolution(solObj, lambda1=0, lambda2=NULL, dim=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flsa_+3A_y">y</code></td>
<td>
<p> response variable; numeric </p>
</td></tr>
<tr><td><code id="flsa_+3A_lambda1">lambda1</code></td>
<td>
<p> penalty parameter vector (non-negative) for the absolute values uf the coefficients; numeric </p>
</td></tr>
<tr><td><code id="flsa_+3A_lambda2">lambda2</code></td>
<td>
<p> penalty parameter vector (non-negative) for the difference of certain coefficients; numeric </p>
</td></tr>
<tr><td><code id="flsa_+3A_groups">groups</code></td>
<td>
<p> Return solutions for which the given number of groups is present - solutions found exactly at the breakpoint</p>
</td></tr>	
<tr><td><code id="flsa_+3A_connlistobj">connListObj</code></td>
<td>
<p>an object specifying which differences are to be penalized by lambda2. If NULL, then the dimensionalty of y is being used. If y is a vector, the differences of neighbouring coefficients are penalized. If y is a matrix, differences of neighbouring coefficients in 2 dimensions are being penalized. For more information see <code><a href="#topic+connListObj">connListObj</a></code></p>
</td></tr>
<tr><td><code id="flsa_+3A_splitchecksize">splitCheckSize</code></td>
<td>
<p>a parameter specifying from which size on, groups of variables are not being checked for breaking up; can be used to reduce computation time; may lead to inaccurate results</p>
</td></tr>
<tr><td><code id="flsa_+3A_solobj">solObj</code></td>
<td>
<p>Solution object as returned by FLSA if lambda2=NULL</p>
</td></tr>
<tr><td><code id="flsa_+3A_dim">dim</code></td>
<td>
<p>dimensions how the result should be formatted for a specific lambda. Used to format the 2-dimensional FLSA as a matrix in the response. For this, just include the dimensions of <code>y</code> as <code>dim</code></p>
</td></tr>
<tr><td><code id="flsa_+3A_verbose">verbose</code></td>
<td>
<p>print status messages during fitting</p>
</td></tr>
<tr><td><code id="flsa_+3A_thr">thr</code></td>
<td>
<p>the error threshold used in the algorithm</p>
</td></tr>
<tr><td><code id="flsa_+3A_maxgrpnum">maxGrpNum</code></td>
<td>
<p>if every step of the algorithm, a group with a higher number is generated; this limits the number of steps the algorithm can take</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flsa</code> is the main function for calculate a <code>flsa</code> fit. If lambda2=NULL, then it returns an object that encodes the whole solution path. Solutions for specific values of lambda1 and lambda2 can then be obtained by using <code>flsaGetSolution</code>.
</p>
<p><code>flsaTopDown</code> calculates the solution of the 1-dimensional FLSA, starting at large values of lambda2. If only solutions for large values of lambda2 are needed, this is more efficient.
</p>


<h3>Author(s)</h3>

<p>Holger Hoefling</p>


<h3>See Also</h3>

<p><code><a href="#topic+connListObj">connListObj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(flsa)
# generate some artificial data, 1 and 2 dimensional
y &lt;- rnorm(100)
y2Dim = matrix(rnorm(100), ncol=10)

### apply function flsa and get solution directly
lambda2= 0:10/10
res &lt;- flsa(y, lambda2=lambda2)
res2Dim &lt;- flsa(y2Dim, lambda2=lambda2)

### apply the function and get the solution later
resSolObj &lt;- flsa(y, lambda2=NULL)
resSolObjTopDown &lt;- flsaTopDown(y)
resSolObj2Dim &lt;- flsa(y2Dim, lambda2=NULL)

res2 &lt;- flsaGetSolution(resSolObj, lambda2=lambda2)
### here note that the solution object does not store that the input was 2 dimensional
### therefore, res2Dim does not give out the solution as a 2 
### dimensional matrix (unlike the direct version above)
res2Dim2 &lt;- flsaGetSolution(resSolObj2Dim, lambda2=lambda2)

</code></pre>

<hr>
<h2 id='is.connListObj'>Connection List Objects</h2><span id='topic+ConnListObj'></span><span id='topic+is.connListObj'></span><span id='topic+connListObj'></span>

<h3>Description</h3>

<p>Describes the makeup of a connection list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connListObj(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.connListObj_+3A_obj">obj</code></td>
<td>
<p>the object to be tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A connection list object can be used to specifiy which differences in
<code>fusedlasso</code> or <code>flsa</code> functions are to be penalized. Here, it
is assumed that the n coefficients in the model are numbered from 0 to
n-1. The connection list object is a list of length n with each element
corresponding to one of the coefficients. The i-th element of the list
here corresponds to coefficient with number i-1. Each element of the
list is a vector of integers, naming the numbers of the coefficients to
which the coefficient corresponding to the current list element is
linked (i.e. the difference of the two coefficients is being penalized).
I.e., assume that value $j$ is a member of the list under list element
$i$. Then this means that coeffient $i-1$ and coefficient $j$ are being
penalized. To understand this, consider that R-lists when viewed in
C-code are being numbered starting with 0, not 1 and note that all
computation is being done in C-code.
</p>
<p>Furthermore, the connection list object has class <code>connListObj</code>.
</p>
<p>Also note that the vectors in the list are of type <code>integer</code> not <code>numeric</code>. An empty vector should be set to <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Holger Hoefling</p>


<h3>See Also</h3>

<p><code><a href="#topic+connListObj">connListObj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
connList &lt;- vector("list", 4)
y &lt;- 1:4

class(connList) = "connListObj"
connList[[1]] = as.integer(c(1,2))
connList[[2]] = as.integer(c(0,3))
connList[[3]] = as.integer(c(3,0))
connList[[4]] = as.integer(c(2,1))
names(connList) &lt;- as.character(0:3) ## not necessary, just for illustration

res &lt;- flsa(y, connListObj=connList)
res2 &lt;- flsa(matrix(y, nrow=2))

res$BeginLambda
res2$BeginLambda
flsaGetSolution(res, lambda2=c(0, 0.5, 1))
flsaGetSolution(res2, lambda2=c(0, 0.5, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
