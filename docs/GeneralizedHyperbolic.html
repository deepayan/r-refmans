<!DOCTYPE html><html lang="en"><head><title>Help for package GeneralizedHyperbolic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeneralizedHyperbolic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GeneralizedHyperbolic'>
<p>The Package &lsquo;GeneralizedHyperbolic&rsquo;: Summary Information</p></a></li>
<li><a href='#ArkansasRiver'>
<p>Soil Electrical Conductivity</p></a></li>
<li><a href='#Functions+20for+20Moments'><p>Functions for Calculating Moments</p></a></li>
<li><a href='#Generalized+20Inverse+20Gaussian'><p>Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#GeneralizedHyperbolic-internal'><p>Internal Generalized Hyperbolic Functions</p></a></li>
<li><a href='#GeneralizedHyperbolicDistribution'><p>Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#GeneralizedHyperbolicPlots'><p>Generalized Hyperbolic Quantile-Quantile and Percent-Percent Plots</p></a></li>
<li><a href='#ghypCalcRange'><p>Range of a Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghypChangePars'><p>Change Parameterizations of the Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghypCheckPars'><p>Check Parameters of the Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghypMom'><p>Calculate Moments of the Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghypParam'><p>Parameter Sets for the Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghypScale'>
<p>Rescale a generalized hyperbolic distribution</p></a></li>
<li><a href='#gigCalcRange'><p>Range of a Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#gigChangePars'><p>Change Parameterizations of the Generalized Inverse Gaussian</p>
Distribution</a></li>
<li><a href='#gigCheckPars'><p>Check Parameters of the Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#gigFit'><p>Fit the Generalized Inverse Gausssian Distribution to Data</p></a></li>
<li><a href='#gigFitStart'><p>Find Starting Values for Fitting a</p>
Generalized Inverse Gaussian Distribution</a></li>
<li><a href='#gigHessian'>
<p>Calculate Two-Sided Hessian for the Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#gigMom'><p>Calculate Moments of the Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#gigParam'><p>Parameter Sets for the Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#GIGPlots'><p>Generalized Inverse Gaussian Quantile-Quantile and Percent-Percent Plots</p></a></li>
<li><a href='#hyperbCalcRange'><p>Range of a Hyperbolic Distribution</p></a></li>
<li><a href='#hyperbChangePars'><p>Change Parameterizations of the Hyperbolic Distribution</p></a></li>
<li><a href='#hyperbCvMTest'><p>Cramer-von~Mises Test of a Hyperbolic Distribution</p></a></li>
<li><a href='#hyperbFit'><p>Fit the Hyperbolic Distribution to Data</p></a></li>
<li><a href='#hyperbFitStart'><p>Find Starting Values for Fitting a Hyperbolic Distribution</p></a></li>
<li><a href='#hyperbHessian'>
<p>Calculate Two-Sided Hessian for the Hyperbolic Distribution</p></a></li>
<li><a href='#hyperblm'><p>Fitting Linear Models with Hyperbolic Errors</p></a></li>
<li><a href='#Hyperbolic'><p>Hyperbolic Distribution</p></a></li>
<li><a href='#hyperbParam'><p>Parameter Sets for the Hyperbolic Distribution</p></a></li>
<li><a href='#HyperbPlots'><p>Hyperbolic Quantile-Quantile and Percent-Percent Plots</p></a></li>
<li><a href='#hyperbWSqTable'><p>Percentage Points for the Cram'er-von Mises Test of the Hyperbolic Distribution</p></a></li>
<li><a href='#mamquam'><p>Size of Gravels from Mamquam River</p></a></li>
<li><a href='#momRecursion'><p>Computes the moment coefficients recursively for generalized</p>
hyperbolic and related distributions</a></li>
<li><a href='#nervePulse'><p>Intervals Between Pulses Along a Nerve Fibre</p></a></li>
<li><a href='#NIG'><p>Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#nigCalcRange'><p>Range of a normal inverse Gaussian Distribution</p></a></li>
<li><a href='#nigFit'><p>Fit the normal inverse Gaussian Distribution to Data</p></a></li>
<li><a href='#nigFitStart'><p>Find Starting Values for Fitting a normal inverse Gaussian Distribution</p></a></li>
<li><a href='#nigHessian'>
<p>Calculate Two-Sided Hessian for the Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#nigParam'><p>Parameter Sets for the Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#nigPlots'><p>Normal inverse Gaussian Quantile-Quantile and Percent-Percent Plots</p></a></li>
<li><a href='#plotShapeTriangle'>
<p>Plot the Shape Triangle</p></a></li>
<li><a href='#resistors'><p>Resistance of One-half-ohm Resistors</p></a></li>
<li><a href='#SandP500'><p>S&amp;P 500</p></a></li>
<li><a href='#SkewLaplace'><p>Skew-Laplace Distribution</p></a></li>
<li><a href='#SkewLaplacePlots'><p>Skew-Laplace Quantile-Quantile and Percent-Percent Plots</p></a></li>
<li><a href='#Specific+20Generalized+20Hyperbolic+20Moments+20and+20Mode'><p>Moments and Mode of the Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#Specific+20Generalized+20Inverse+20Gaussian+20Moments+20and+20Mode'><p>Moments and Mode of the Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#Specific+20Hyperbolic+20Distribution+20Moments+20and+20Mode'><p>Moments and Mode of the Hyperbolic Distribution</p></a></li>
<li><a href='#Specific+20Normal+20Inverse+20Gaussian+20Distribution+20Moments+20and+20Mode'><p>Moments and Mode of the Normal Inverse Gaussian  Distribution</p></a></li>
<li><a href='#summary.gigFit'><p>Summarizing Normal Inverse Gaussian Distribution Fit</p></a></li>
<li><a href='#summary.hyperbFit'><p>Summarizing Hyperbolic Distribution Fit</p></a></li>
<li><a href='#summary.hyperblm'><p>Summary Output of Hyperbolic Regression</p></a></li>
<li><a href='#summary.nigFit'><p>Summarizing Normal Inverse Gaussian Distribution Fit</p></a></li>
<li><a href='#traffic'><p>Intervals Between Vehicles on a Road</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.8-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-26</td>
</tr>
<tr>
<td>Title:</td>
<td>The Generalized Hyperbolic Distribution</td>
</tr>
<tr>
<td>Author:</td>
<td>David Scott &lt;d.scott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Scott &lt;d.scott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DistributionUtils, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>VarianceGamma, actuar, SkewHyperbolic, RUnit</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the hyperbolic and related distributions.
  Density, distribution and quantile functions and random number generation
  are provided for the hyperbolic distribution, the generalized hyperbolic
        distribution, the generalized inverse Gaussian distribution and
        the skew-Laplace distribution. Additional functionality is
        provided for the hyperbolic distribution, normal inverse
	Gaussian distribution and generalized inverse Gaussian distribution,
	including fitting of these distributions to data. Linear models with
        hyperbolic errors may be fitted using hyperblmFit.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics/">https://r-forge.r-project.org/projects/rmetrics/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-26 08:08:04 UTC; dsco036</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-26 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GeneralizedHyperbolic'>
The Package &lsquo;GeneralizedHyperbolic&rsquo;: Summary Information
</h2><span id='topic+GeneralizedHyperbolic-package'></span>

<h3>Description</h3>

<p>This package provides a collection of functions for working with the generalized
hyperbolic and related distributions.
</p>
<p>For the hyperbolic distribution functions are provided for the density
function, distribution function, quantiles, random number generation and
fitting the hyperbolic distribution to data (<code>hyperbFit</code>). The
function <code>hyperbChangePars</code> will interchange parameter values
between different parameterizations.  The mean, variance, skewness,
kurtosis and mode of a given hyperbolic distribution are given by
<code>hyperbMean</code>, <code>hyperbVar</code>, <code>hyperbSkew</code>,
<code>hyperbKurt</code>, and <code>hyperbMode</code> respectively. For assessing the
fit of the hyperbolic distribution to a set of data, the log-histogram
is useful.  See <code><a href="DistributionUtils.html#topic+logHist">logHist</a></code> from package
<a href="https://CRAN.R-project.org/package=DistributionUtils"><span class="pkg">DistributionUtils</span></a>. Q-Q and P-P
plots are also provided for assessing the fit of a hyperbolic
distribution. A Cramér-von~Mises test of the goodness of
fit of data to a hyperbolic distribution is given by
<code>hyperbCvMTest</code>. S3 <code>print</code>, <code>plot</code> and <code>summary</code>
methods are provided for the output of <code>hyperbFit</code>.
</p>
<p>For the generalized hyperbolic distribution functions are provided for
the density function, distribution function, quantiles, and for random
number generation. The function <code>ghypChangePars</code> will interchange
parameter values between different parameterizations.  The mean, variance, and
mode of a given generalized hyperbolic distribution are given by
<code>ghypMean</code>, <code>ghypVar</code>, <code>ghypSkew</code>, <code>ghypKurt</code>, and
<code>ghypMode</code> respectively.  Q-Q and P-P plots are also provided for
assessing the fit of a generalized hyperbolic distribution.
</p>
<p>For the generalized inverse Gaussian distribution functions are provided for
the density function, distribution function, quantiles, and for random
number generation. The function <code>gigChangePars</code> will interchange
parameter values between different parameterizations.  The mean,
variance, skewness, kurtosis and mode of a given generalized inverse
Gaussian distribution are given by <code>gigMean</code>, <code>gigVar</code>,
<code>gigSkew</code>, <code>gigKurt</code>, and <code>gigMode</code> respectively.  Q-Q and
P-P plots are also provided for assessing the fit of a generalized
inverse Gaussian distribution.
</p>
<p>For the skew-Laplace distribution functions are provided for
the density function, distribution function, quantiles, and for random
number generation. Q-Q and P-P plots are also provided for assessing the
fit of a skew-Laplace distribution.
</p>


<h3>Acknowledgements</h3>

<p>A number of students have worked on the package: Ai-Wei Lee, Jennifer Tso,
Richard Trendall, Thomas Tran, Simon Potter and David Cusack.
</p>
<p>Thanks to Ross Ihaka and Paul Murrell for their willingness to answer
my questions, and to all the core group for the development of R.
</p>
<p>Special thanks also to Diethelm Würtz without whose
advice, this package would be far inferior.
</p>


<h3>LICENCE</h3>

<p>This package and its documentation are usable under the terms of the
&quot;GNU General Public License&quot;, a copy of which is distributed with the
package.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>
<p>Jörgensen, B. (1982). <em>Statistical Properties of
the Generalized Inverse Gaussian Distribution</em>. Lecture Notes in
Statistics, Vol. 9, Springer-Verlag, New York.
</p>
<p>Prause, K. (1999)
<em>The generalized hyperbolic models: Estimation, financial
derivatives and risk measurement.</em> PhD Thesis, Mathematics Faculty,
University of Freiburg.
</p>

<hr>
<h2 id='ArkansasRiver'>
Soil Electrical Conductivity
</h2><span id='topic+ArkansasRiver'></span>

<h3>Description</h3>

<p>Electrical conductivity of soil paste extracts from the Lower Arkansas
River Valley, at sites upstream and downstream of the John Martin
Reservoir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ArkansasRiver)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 2
$ upstream  : num [1:823] 2.37 3.53 3.06 3.35 3.07 ...
$ downstream: num [1:435] 8.75 6.59 5.09 6.03 5.64 ...
</p>


<h3>Details</h3>

<p>Electrical conductivity is a measure of soil water salinity.
</p>


<h3>Source</h3>

<p>This data set was supplied by Eric Morway (<a href="mailto:emorway@usgs.gov">emorway@usgs.gov</a>).
</p>


<h3>References</h3>

<p>Eric D. Morway and Timothy K. Gates (2011)
Regional assessment of soil water salinity across an extensively
irrigated river valley.
Journal of Irrigation and Drainage Engineering,
doi:10.1061/(ASCE)IR.1943-4774.0000411
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ArkansasRiver)
lapply(ArkansasRiver, summary)
upstream &lt;- ArkansasRiver[[1]]
downstream &lt;- ArkansasRiver[[2]]
## Fit normal inverse Gaussian
## Hyperbolic can also be fitted but fit is not as good
fitUpstream &lt;- nigFit(upstream)
summary(fitUpstream)
par(mfrow = c(2,2))
plot(fitUpstream)
fitDownstream &lt;- nigFit(downstream)
summary(fitDownstream)
plot(fitDownstream)
par(mfrow = c(1,1))
## Combined plot to compare
## Reproduces Figure 3 from Morway and Gates (2011)
hist(upstream, col = "grey", xlab = "", ylab = "", cex.axis = 1.25,
     main = "", breaks = seq(0,20, by = 1), xlim = c(0,15), las = 1,
     ylim = c(0,0.5), freq = FALSE)
param &lt;- coef(fitUpstream)
nigDens &lt;- function(x) dnig(x, param = param)
curve(nigDens, 0, 15, n = 201, add = TRUE,
      ylab = NULL, col = "red", lty = 1, lwd = 1.7)

hist(downstream, add = TRUE, col = "black", angle = 45, density = 15,
     breaks = seq(0,20, by = 1), freq = FALSE)
param &lt;- coef(fitDownstream)
nigDens &lt;- function(x) dnig(x, param = param)
curve(nigDens, 0, 15, n = 201, add = TRUE,
      ylab = NULL, col = "red", lty = 1, lwd = 1.7)

mtext(expression(EC[e]), side = 1, line = 3, cex = 1.25)
mtext("Frequency", side = 2, line = 3, cex = 1.25)
legend(x = 7.5, y = 0.250, c("Upstream Region","Downstream Region"),
       col = c("black","black"), density = c(NA,25),
       fill = c("grey","black"), angle = c(NA,45),
       cex = 1.25, bty = "n", xpd = TRUE)
</code></pre>

<hr>
<h2 id='Functions+20for+20Moments'>Functions for Calculating Moments</h2><span id='topic+RLambda'></span><span id='topic+SLambda'></span><span id='topic+MLambda'></span><span id='topic+WLambda1'></span><span id='topic+WLambda2'></span><span id='topic+WLambda3'></span><span id='topic+WLambda4'></span><span id='topic+gammaLambda1'></span><span id='topic+gammaLambda2'></span>

<h3>Description</h3>

<p>Functions used to calculate the mean, variance, skewness and kurtosis
of a hyperbolic distribution. Not expected to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RLambda(zeta, lambda = 1)
SLambda(zeta, lambda = 1)
MLambda(zeta, lambda = 1)
WLambda1(zeta, lambda = 1)
WLambda2(zeta, lambda = 1)
WLambda3(zeta, lambda = 1)
WLambda4(zeta, lambda = 1)
gammaLambda1(hyperbPi, zeta, lambda = 1)
gammaLambda1(hyperbPi, zeta, lambda = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Functions+2B20for+2B20Moments_+3A_hyperbpi">hyperbPi</code></td>
<td>
<p>Value of the parameter <code class="reqn">\pi</code> of the
hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="Functions+2B20for+2B20Moments_+3A_zeta">zeta</code></td>
<td>
<p>Value of the parameter <code class="reqn">\zeta</code> of the
hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="Functions+2B20for+2B20Moments_+3A_lambda">lambda</code></td>
<td>
<p>Parameter related to order of Bessel functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>RLambda</code> and <code>SLambda</code> are used in the
calculation of the mean and variance. They are functions of the Bessel
functions of the third kind, implemented in <span class="rlang"><b>R</b></span> as
<code><a href="base.html#topic+besselK">besselK</a></code>. The other functions are used in calculation of
higher moments. See Barndorff-Nielsen, O. and Blæsild,
P. (1981) for details of the calculations.
</p>
<p>The parameterization of the hyperbolic distribution used for this
and other components of the <code>HyperbolicDist</code> package is the
<code class="reqn">(\pi,\zeta)</code> one. See <code>hyperbChangePars</code> to
transfer between parameterizations.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Richard Trendall,
Thomas Tran</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1981).
Hyperbolic distributions and ramifications: contributions to theory
and application.
In <em>Statistical Distributions in Scientific Work</em>,
eds., Taillie, C., Patil, G. P., and Baldessari, B. A., Vol. 4,
pp. 19&ndash;44. Dordrecht: Reidel.
</p>
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code>,
<code><a href="#topic+hyperbMean">hyperbMean</a></code>,<code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>,
<code><a href="base.html#topic+besselK">besselK</a></code>
</p>

<hr>
<h2 id='Generalized+20Inverse+20Gaussian'>Generalized Inverse Gaussian Distribution</h2><span id='topic+dgig'></span><span id='topic+pgig'></span><span id='topic+qgig'></span><span id='topic+rgig'></span><span id='topic+rgig1'></span><span id='topic+ddgig'></span>

<h3>Description</h3>

<p>Density function, cumulative distribution function, quantile function
and random number generation for the generalized inverse Gaussian
distribution with parameter vector <code>param</code>. Utility routines are
included for the derivative of the density function and to find
suitable break points for use in determining the distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgig(x, chi = 1, psi = 1, lambda = 1,
     param = c(chi, psi, lambda), KOmega = NULL)
pgig(q, chi = 1, psi = 1, lambda = 1,
     param = c(chi,psi,lambda), lower.tail = TRUE,
     ibfTol = .Machine$double.eps^(0.85), nmax = 200)
qgig(p, chi = 1, psi = 1, lambda = 1,
     param = c(chi, psi, lambda), lower.tail = TRUE,
     method = c("spline", "integrate"),
     nInterpol = 501, uniTol = 10^(-7),
     ibfTol = .Machine$double.eps^(0.85), nmax =200, ...)
rgig(n, chi = 1, psi = 1, lambda = 1,
     param = c(chi, psi, lambda))
rgig1(n, chi = 1, psi = 1, param = c(chi, psi))
ddgig(x, chi = 1, psi = 1, lambda = 1,
      param = c(chi, psi, lambda), KOmega = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_x">x</code>, <code id="Generalized+2B20Inverse+2B20Gaussian_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_n">n</code></td>
<td>
<p>Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_chi">chi</code></td>
<td>
<p>A shape parameter that by default holds a value of 1.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_psi">psi</code></td>
<td>
<p>Another shape parameter that is set to 1 by default.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter of the GIG distribution. Common to all
forms of parameterization. By default this is set to 1.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_param">param</code></td>
<td>
<p>Parameter vector taking the form <code>c(chi, psi, lambda)</code>
for <code>rgig</code>, or <code>c(chi, psi)</code> for <code>rgig1</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code>, probabilities are
<code class="reqn">P(X\leq x)</code>, otherwise as <code class="reqn">P(X&gt;x)</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_komega">KOmega</code></td>
<td>
<p>Sets the value of the Bessel function in the density or
derivative of the density. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_ibftol">ibfTol</code></td>
<td>
<p>Value of tolerance to be passed to
<code>incompleteBesselK</code> by <code>pgig</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_nmax">nmax</code></td>
<td>
<p>Value of maximum order of the approximating series to be
passed to <code>incompleteBesselK</code> by <code>pgig</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_ninterpol">nInterpol</code></td>
<td>
<p>The number of points used in qgig for cubic spline
interpolation (see <code>splinefun</code>) of the distribution function.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in
calls to <code>uniroot</code>. See <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>uniroot</code>.  See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized inverse Gaussian distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{(\psi/\chi)^{\frac{\lambda}{2}}}%
    {2K_\lambda(\sqrt{\psi\chi})}x^{\lambda-1}%
    e^{-\frac{1}{2}\left(\chi x^{-1}+\psi x\right)}</code>
</p>

<p>for <code class="reqn">x&gt;0</code>, where <code class="reqn">K_\lambda()</code> is the
modified Bessel function of the third kind with order
<code class="reqn">\lambda</code>.
</p>
<p>The generalized inverse Gaussian distribution is investigated in
detail in Jörgensen (1982).
</p>
<p>Use <code>gigChangePars</code> to convert from the
<code class="reqn">(\delta,\gamma)</code>,
<code class="reqn">(\alpha,\beta)</code>, or
<code class="reqn">(\omega,\eta)</code> parameterizations to the
<code class="reqn">(\chi,\psi)</code>, parameterization used above.
</p>
<p><code>pgig</code> calls the function
<code><a href="DistributionUtils.html#topic+incompleteBesselK">incompleteBesselK</a></code> from the package
<span class="pkg">DistributionUtils</span> to integrate the density function
<code>dgig</code>. This can be expected to be accurate to about 13 decimal
places on a 32-bit computer, often more accurate. The algorithm used
is due to Slavinsky and Safouhi (2010).
</p>
<p>Calculation of quantiles using <code>qgig</code> permits the use of two
different methods. Both methods use <code>uniroot</code> to find the value
of <code class="reqn">x</code> for which a given <code class="reqn">q</code> is equal <code class="reqn">F(x)</code> where <code class="reqn">F</code>
denotes the cumulative distribution function. The difference is in how
the numerical approximation to <code class="reqn">F</code> is obtained. The obvious
and more accurate method is to calculate the value of <code class="reqn">F(x)</code>
whenever it is required using a call to <code>pghyp</code>. This is what
is done if the method is specified as <code>"integrate"</code>. It is clear
that the time required for this approach is roughly linear in the
number of quantiles being calculated. A Q-Q plot of a large data set
will clearly take some time. The alternative (and default) method is
that for the major part of the distribution a spline approximation to
<code class="reqn">F(x)</code> is calculated and quantiles found using <code>uniroot</code> with
this approximation. For extreme values (for which the tail probability
is less than <code class="reqn">10^{-7}</code>), the integration method is still
used even when the method specifed is <code>"spline"</code>.
</p>
<p>If accurate probabilities or quantiles are required, tolerances
(<code>intTol</code> and <code>uniTol</code>) should be set to small values, say
<code class="reqn">10^{-10}</code> or <code class="reqn">10^{-12}</code> with <code>method
  = "integrate"</code>. Generally then accuracy might be expected to be at
least <code class="reqn">10^{-9}</code>. If the default values of the functions
are used, accuracy can only be expected to be around
<code class="reqn">10^{-4}</code>. Note that on 32-bit systems
<code>.Machine$double.eps^0.25 = 0.0001220703</code> is a typical value.
</p>
<p>Generalized inverse Gaussian observations are obtained via the
algorithm of Dagpunar (1989).
</p>


<h3>Value</h3>

<p><code>dgig</code> gives the density, <code>pgig</code> gives the distribution
function, <code>qgig</code> gives the quantile function, and <code>rgig</code>
generates random variates. <code>rgig1</code> generates random variates in
the special case where <code class="reqn">\lambda = 1</code>.
</p>
<p><code>ddgig</code> gives the derivative of <code>dgig</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Richard Trendall,
and Melanie Luen.</p>


<h3>References</h3>

<p>Dagpunar, J.S. (1989). An easily implemented generalised inverse
Gaussian generator. <em>Commun. Statist. -Simula.</em>, <b>18</b>,
703&ndash;710.
</p>
<p>Jörgensen, B. (1982). <em>Statistical Properties of
the Generalized Inverse Gaussian Distribution</em>. Lecture Notes in
Statistics, Vol. 9, Springer-Verlag, New York.
</p>
<p>Slevinsky, Richard M., and Safouhi, Hassan (2010) A recursive
algorithm for the G transformation and accurate computation of
incomplete Bessel functions. <em>Appl. Numer. Math.</em>, In press.
</p>


<h3>See Also</h3>

<p><code><a href="DistributionUtils.html#topic+safeIntegrate">safeIntegrate</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code> for its shortfalls, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code> and <code><a href="#topic+gigChangePars">gigChangePars</a></code> for changing
parameters to the <code class="reqn">(\chi,\psi)</code> parameterization,
<code><a href="#topic+dghyp">dghyp</a></code> for the generalized hyperbolic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 3, 1)
gigRange &lt;- gigCalcRange(param = param, tol = 10^(-3))
par(mfrow = c(1, 2))
curve(dgig(x, param = param), from = gigRange[1], to = gigRange[2],
      n = 1000)
title("Density of the\n Generalized Inverse Gaussian")
curve(pgig(x, param = param), from = gigRange[1], to = gigRange[2],
      n = 1000)
title("Distribution Function of the\n Generalized Inverse Gaussian")
dataVector &lt;- rgig(500, param = param)
curve(dgig(x, param = param), range(dataVector)[1], range(dataVector)[2],
      n = 500)
hist(dataVector, freq = FALSE, add = TRUE)
title("Density and Histogram\n of the Generalized Inverse Gaussian")
DistributionUtils::logHist(dataVector, main =
        "Log-Density and Log-Histogram\n of the Generalized Inverse Gaussian")
curve(log(dgig(x, param = param)), add = TRUE,
      range(dataVector)[1], range(dataVector)[2], n = 500)
par(mfrow = c(2, 1))
curve(dgig(x, param = param), from = gigRange[1], to = gigRange[2],
      n = 1000)
title("Density of the\n Generalized Inverse Gaussian")
curve(ddgig(x, param = param), from = gigRange[1], to = gigRange[2],
      n = 1000)
title("Derivative of the Density\n of the Generalized Inverse Gaussian")
</code></pre>

<hr>
<h2 id='GeneralizedHyperbolic-internal'>Internal Generalized Hyperbolic Functions</h2><span id='topic+ghypMomBNS'></span><span id='topic+ghypCreateParameters'></span><span id='topic+gigCreateParameters'></span><span id='topic+nigCreateParameters'></span><span id='topic+hyperbCreateParameters'></span><span id='topic+ghypStandPars'></span><span id='topic+hyperbStandPars'></span><span id='topic+kappaLambda'></span><span id='topic+alphaStand'></span><span id='topic+betaStand'></span><span id='topic+dgigScaled'></span><span id='topic+dsghyp'></span><span id='topic+dshyperb'></span><span id='topic+hyperbFitStand'></span><span id='topic+hyperbFitStandStart'></span><span id='topic+hyperblmFit'></span>

<h3>Description</h3>

<p>Internal functions for the package GeneralizedHyperbolic
</p>


<h3>Details</h3>

<p>Functions which are either not intended to be called by the user or
are waiting to be documented.
</p>

<hr>
<h2 id='GeneralizedHyperbolicDistribution'>Generalized Hyperbolic Distribution</h2><span id='topic+dghyp'></span><span id='topic+pghyp'></span><span id='topic+qghyp'></span><span id='topic+rghyp'></span><span id='topic+ddghyp'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and random number
generation for the generalized hyperbolic distribution, with
parameters <code class="reqn">\alpha</code> (tail), <code class="reqn">\beta</code> (skewness),
<code class="reqn">\delta</code> (peakness), <code class="reqn">\mu</code> (location) and
<code class="reqn">\lambda</code> (shape).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dghyp(x, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda))
pghyp(q, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda),
      lower.tail = TRUE, subdivisions = 100,
      intTol = .Machine$double.eps^0.25, valueOnly = TRUE, ...)
qghyp(p, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda),
      lower.tail = TRUE, method = c("spline","integrate"),
      nInterpol = 501, uniTol = .Machine$double.eps^0.25,
      subdivisions = 100, intTol = uniTol, ...)
rghyp(n, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda))
ddghyp(x, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
       param = c(mu, delta, alpha, beta, lambda))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_x">x</code>, <code id="GeneralizedHyperbolicDistribution_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_n">n</code></td>
<td>
<p>Number of random variates to be generated.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_mu">mu</code></td>
<td>
<p>Location parameter <code class="reqn">\mu</code>, default is 0.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_delta">delta</code></td>
<td>
<p>Scale parameter <code class="reqn">\delta</code>, default is 1.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_alpha">alpha</code></td>
<td>
<p>Tail parameter <code class="reqn">\alpha</code>, default is 1.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_beta">beta</code></td>
<td>
<p>Skewness parameter <code class="reqn">\beta</code>, default is 0.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter <code class="reqn">\lambda</code>, default is 1.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_param">param</code></td>
<td>
<p>Specifying the parameters as a vector of the form<br />
<code>c(mu,delta,alpha,beta,lambda)</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code>, probabilities are
<code class="reqn">P(X\leq x)</code>, otherwise they are <code class="reqn">P(X&gt;x)</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subdivisions used to
integrate the density and determine the accuracy of the distribution
function calculation.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_inttol">intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in
calls to <code>integrate</code>. See <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_valueonly">valueOnly</code></td>
<td>
<p>Logical. If <code>valueOnly = TRUE</code> calls to
<code>pghyp</code> only return the value obtained for the integral.
If <code>valueOnly = FALSE</code> an estimate of the
accuracy of the numerical integration is also returned.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_ninterpol">nInterpol</code></td>
<td>
<p>Number of points used in <code>qghyp</code> for cubic
spline interpolation of the distribution function.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in
calls to <code>uniroot</code>. See <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicDistribution_+3A_...">...</code></td>
<td>
<p>Passes additional arguments to <code><a href="stats.html#topic+integrate">integrate</a></code> in
<code>pghyp</code> and <code>qghyp</code>, and to <code><a href="stats.html#topic+uniroot">uniroot</a></code> in
<code>qghyp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users may either specify the values of the parameters individually or
as a vector. If both forms are specified, then the values specified by
the vector <code>param</code> will overwrite the other ones. In addition the
parameter values are examined by calling the function
<code>ghypCheckPars</code> to see if they are valid.
</p>
<p>The density function is
</p>
<p style="text-align: center;"><code class="reqn">f(x)=c(\lambda,\alpha,\beta,\delta)\times%
    \frac{K_{\lambda-1/2}(\alpha\sqrt{\delta^2+(x-\mu)^2})}%
    {(\frac{\sqrt{\delta^2+(x-\mu)^2}}{\alpha})^{1/2-\lambda}}%
    e^{\beta(x-\mu)}</code>
</p>

<p>where <code class="reqn">K_\nu()</code> is the modified Bessel function of the
third kind with order <code class="reqn">\nu</code>, and
</p>
<p style="text-align: center;"><code class="reqn">c(\lambda,\alpha,\beta,\delta)=%
    \frac{(\frac{\sqrt{\alpha^2-\beta^2}}{\delta})^\lambda}%
    {\sqrt{2\pi}K_\lambda(\delta\sqrt{\alpha^2-\beta^2})}</code>
</p>

<p>Use <code>ghypChangePars</code> to convert from the
<code class="reqn">(\rho, \zeta)</code>,
<code class="reqn">(\xi, \chi)</code>,
<code class="reqn">(\bar\alpha, \bar\beta)</code>, or
<code class="reqn">(\pi, \zeta)</code> parameterizations
to the <code class="reqn">(\alpha, \beta)</code> parameterization used
above.
</p>
<p><code>pghyp</code> uses the function <code><a href="stats.html#topic+integrate">integrate</a></code> to
numerically integrate the density function. The integration is from
<code>-Inf</code> to <code>x</code> if <code>x</code> is to the left of the mode, and
from <code>x</code> to <code>Inf</code> if <code>x</code> is to the right of the
mode. The probability calculated this way is subtracted from 1 if
required. Integration in this manner appears to make calculation of
the quantile function more stable in extreme cases.
</p>
<p>Calculation of quantiles using <code>qghyp</code> permits the use of two
different methods. Both methods use <code>uniroot</code> to find the value
of <code class="reqn">x</code> for which a given <code class="reqn">q</code> is equal <code class="reqn">F(x)</code> where <code class="reqn">F</code>
denotes the cumulative distribution function. The difference is in how
the numerical approximation to <code class="reqn">F</code> is obtained. The obvious
and more accurate method is to calculate the value of <code class="reqn">F(x)</code>
whenever it is required using a call to <code>pghyp</code>. This is what
is done if the method is specified as <code>"integrate"</code>. It is clear
that the time required for this approach is roughly linear in the
number of quantiles being calculated. A Q-Q plot of a large data set
will clearly take some time. The alternative (and default) method is
that for the major part of the distribution a spline approximation to
<code class="reqn">F(x)</code> is calculated and quantiles found using <code>uniroot</code> with
this approximation. For extreme values (for which the tail probability
is less than <code class="reqn">10^{-7}</code>), the integration method is still
used even when the method specifed is <code>"spline"</code>.
</p>
<p>If accurate probabilities or quantiles are required, tolerances
(<code>intTol</code> and <code>uniTol</code>) should be set to small values, say
<code class="reqn">10^{-10}</code> or <code class="reqn">10^{-12}</code> with <code>method
  = "integrate"</code>. Generally then accuracy might be expected to be at
least <code class="reqn">10^{-9}</code>. If the default values of the functions
are used, accuracy can only be expected to be around
<code class="reqn">10^{-4}</code>. Note that on 32-bit systems
<code>.Machine$double.eps^0.25 = 0.0001220703</code> is a typical value.
</p>


<h3>Value</h3>

<p><code>dghyp</code> gives the density function, <code>pghyp</code> gives the
distribution function, <code>qghyp</code> gives the quantile function and
<code>rghyp</code> generates random variates.
</p>
<p>An estimate of the accuracy of the approximation to the distribution
function can be found by setting <code>valueOnly = FALSE</code> in the call to
<code>pghyp</code> which returns a list with components <code>value</code> and
<code>error</code>.
</p>
<p><code>ddghyp</code> gives the derivative of <code><a href="#topic+dghyp">dghyp</a></code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O., and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S., and Read, C. B., Vol. 3,
pp. 700&ndash;707.-New York: Wiley.
</p>
<p>Bibby, B. M., and Sörenson,M. (2003).
Hyperbolic processes in finance.
In <em>Handbook of Heavy Tailed Distributions in Finance</em>,ed.,
Rachev, S. T. pp. 212&ndash;248. Elsevier Science B.~V.
</p>
<p>Dagpunar, J.S. (1989).
An easily implemented generalised inverse Gaussian generator
<em>Commun. Statist.-Simula.</em>, <b>18</b>, 703&ndash;710.
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code> for the hyperbolic distribution,
<code><a href="#topic+dgig">dgig</a></code> for the generalized inverse Gaussian distribution,
<code><a href="DistributionUtils.html#topic+safeIntegrate">safeIntegrate</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code> for its shortfalls, also
<code><a href="stats.html#topic+splinefun">splinefun</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code> and
<code><a href="#topic+ghypChangePars">ghypChangePars</a></code> for changing parameters to the
<code class="reqn">(\alpha,\beta)</code> parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(0, 1, 3, 1, 1/2)
ghypRange &lt;- ghypCalcRange(param = param, tol = 10^(-3))
par(mfrow = c(1, 2))

### curves of density and distribution
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Density of the \n Generalized  Hyperbolic Distribution")
curve(pghyp(x, param = param), ghypRange[1], ghypRange[2], n = 500)
title("Distribution Function of the \n Generalized Hyperbolic Distribution")

### curves of density and log density
par(mfrow = c(1, 2))
data &lt;- rghyp(1000, param = param)
curve(dghyp(x, param = param), range(data)[1], range(data)[2],
      n = 1000, col = 2)
hist(data, freq = FALSE, add = TRUE)
title("Density and Histogram of the\n Generalized Hyperbolic Distribution")
DistributionUtils::logHist(data,
    main = "Log-Density and Log-Histogram of\n the Generalized Hyperbolic Distribution")
curve(log(dghyp(x, param = param)),
      range(data)[1], range(data)[2],
      n = 500, add = TRUE, col = 2)

### plots of density and derivative
par(mfrow = c(2, 1))
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Density of the\n Generalized  Hyperbolic Distribution")
curve(ddghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Derivative of the Density of the\n Generalized Hyperbolic Distribution")
</code></pre>

<hr>
<h2 id='GeneralizedHyperbolicPlots'>Generalized Hyperbolic Quantile-Quantile and Percent-Percent Plots</h2><span id='topic+qqghyp'></span><span id='topic+ppghyp'></span>

<h3>Description</h3>

<p><code>qqghyp</code> produces a generalized hyperbolic Q-Q plot of the values in
<code>y</code>.
</p>
<p><code>ppghyp</code> produces a generalized hyperbolic P-P (percent-percent) or
probability plot of the values in <code>y</code>.	
</p>
<p>Graphical parameters may be given as arguments to <code>qqghyp</code>,
and <code>ppghyp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqghyp(y, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
       param = c(mu, delta, alpha, beta, lambda),
       main = "Generalized Hyperbolic Q-Q Plot",
       xlab = "Theoretical Quantiles",
       ylab = "Sample Quantiles",
       plot.it = TRUE, line = TRUE, ...)

ppghyp(y, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
       param = c(mu, delta, alpha, beta, lambda),
       main = "Generalized Hyperbolic P-P Plot",
       xlab = "Uniform Quantiles",
       ylab = "Probability-integral-transformed Data",
       plot.it = TRUE, line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_y">y</code></td>
<td>
<p>The data sample.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_lambda">lambda</code></td>
<td>
<p><code class="reqn">\lambda</code> is the shape parameter and dictates the
shape that the distribution shall take. Default value is 1.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_param">param</code></td>
<td>
<p>Parameters of the generalized hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_xlab">xlab</code>, <code id="GeneralizedHyperbolicPlots_+3A_ylab">ylab</code>, <code id="GeneralizedHyperbolicPlots_+3A_main">main</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical. Should the result be plotted?</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_line">line</code></td>
<td>
<p>Add line through origin with unit slope.</p>
</td></tr>
<tr><td><code id="GeneralizedHyperbolicPlots_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qqghyp</code> and <code>ppghyp</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that are to be plotted.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates of the points that are to be plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilk, M. B. and Gnanadesikan, R. (1968)
Probability plotting methods for the analysis of data.
<em>Biometrika</em>.
<b>55</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ppoints">ppoints</a></code>, <code><a href="#topic+dghyp">dghyp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
y &lt;- rghyp(200, param = c(2, 2, 2, 1, 2))
qqghyp(y, param = c(2, 2, 2, 1, 2), line = FALSE)
abline(0, 1, col = 2)
ppghyp(y, param = c(2, 2, 2, 1, 2))
</code></pre>

<hr>
<h2 id='ghypCalcRange'>Range of a Generalized Hyperbolic Distribution</h2><span id='topic+ghypCalcRange'></span>

<h3>Description</h3>

<p>Given the parameter vector Theta of a generalized hyperbolic distribution,
this function determines the range outside of which the density
function is negligible, to a specified tolerance. The parameterization used
is the <code class="reqn">(\alpha, \beta)</code> one (see
<code><a href="#topic+dghyp">dghyp</a></code>). To use another parameterization, use
<code><a href="#topic+ghypChangePars">ghypChangePars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypCalcRange(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
              param = c(mu, delta, alpha, beta, lambda),
              tol = 10^(-5), density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghypCalcRange_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_lambda">lambda</code></td>
<td>
<p><code class="reqn">\lambda</code> is the shape parameter and dictates the
shape that the distribution shall take. Default value is 1.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_param">param</code></td>
<td>
<p>Value of parameter vector specifying the generalized
hyperbolic distribution. This takes the form <br />
<code>c(mu, delta,alpha, beta, lambda)</code>.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_density">density</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the bounds are for the density
function. If <code>FALSE</code>, they should be for the probability
distribution, but this has not yet been implemented.
</p>
</td></tr>
<tr><td><code id="ghypCalcRange_+3A_...">...</code></td>
<td>
<p>Extra arguments for calls to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The particular generalized hyperbolic distribution being considered is
specified by the value of the parameter value <code>param</code>.
</p>
<p>If <code>density = TRUE</code>, the function gives a range, outside of which
the density is less than the given tolerance. Useful for plotting the
density. Also used in determining break points for the separate
sections over which numerical integration is used to determine the
distribution function. The points are found by using
<code><a href="stats.html#topic+uniroot">uniroot</a></code> on the density function.
</p>
<p>If <code>density = FALSE</code>, the function returns the message:
&quot;<code>Distribution function bounds not yet implemented</code>&quot;.
</p>


<h3>Value</h3>

<p>A two-component vector giving the lower and upper ends of the range.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dghyp">dghyp</a></code>, <code><a href="#topic+ghypChangePars">ghypChangePars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(0, 1, 5, 3, 1)
maxDens &lt;- dghyp(ghypMode(param = param), param = param)
ghypRange &lt;- ghypCalcRange(param = param, tol = 10^(-3) * maxDens)
ghypRange
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2])
## Not run: ghypCalcRange(param = param, tol = 10^(-3), density = FALSE)
</code></pre>

<hr>
<h2 id='ghypChangePars'>Change Parameterizations of the Generalized Hyperbolic Distribution</h2><span id='topic+ghypChangePars'></span>

<h3>Description</h3>

<p>This function interchanges between the following 5 parameterizations
of the generalized hyperbolic distribution:
</p>
<p>1. <code class="reqn">\mu, \delta, \alpha, \beta, \lambda</code>
</p>
<p>2. <code class="reqn">\mu, \delta, \rho, \zeta, \lambda</code>
</p>
<p>3. <code class="reqn">\mu, \delta, \xi, \chi, \lambda</code>
</p>
<p>4. <code class="reqn">\mu, \delta, \bar\alpha, \bar\beta, \lambda</code>
</p>
<p>5. <code class="reqn">\mu, \delta, \pi, \zeta, \lambda</code>
</p>
<p>The first four are the parameterizations given in Prause (1999). The
final parameterization has proven useful in fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypChangePars(from, to, param, noNames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghypChangePars_+3A_from">from</code></td>
<td>
<p>The set of parameters to change from.
</p>
</td></tr>
<tr><td><code id="ghypChangePars_+3A_to">to</code></td>
<td>
<p>The set of parameters to change to.
</p>
</td></tr>
<tr><td><code id="ghypChangePars_+3A_param">param</code></td>
<td>
<p>&quot;from&quot; parameter vector consisting of 5 numerical
elements.
</p>
</td></tr>
<tr><td><code id="ghypChangePars_+3A_nonames">noNames</code></td>
<td>
<p>Logical. When <code>TRUE</code>, suppresses the parameter
<code>names</code> in the output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the 5 parameterizations, the following must be positive:
</p>
<p>1. <code class="reqn">\alpha, \delta</code>
</p>
<p>2. <code class="reqn">\zeta, \delta</code>
</p>
<p>3. <code class="reqn">\xi, \delta</code>
</p>
<p>4. <code class="reqn">\bar\alpha, \delta</code>
</p>
<p>5. <code class="reqn">\zeta, \delta</code>
</p>
<p>Furthermore, note that in the first parameterization
<code class="reqn">\alpha</code> must be greater than the absolute value of
<code class="reqn">\beta</code>; in the third parameterization, <code class="reqn">\xi</code>
must be less than one, and the absolute value of <code class="reqn">\chi</code> must
be less than <code class="reqn">\xi</code>; and in the fourth parameterization,
<code class="reqn">\bar\alpha</code> must be greater than the absolute value of
<code class="reqn">\bar\beta</code>.
</p>


<h3>Value</h3>

<p>A numerical vector of length 5 representing <code>param</code> in the
<code>to</code> parameterization.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Jennifer Tso, Richard Trendall</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P. (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dghyp">dghyp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>param1 &lt;- c(0, 3, 2, 1, 2)               # Parameterization 1
param2 &lt;- ghypChangePars(1, 2, param1)   # Convert to parameterization 2
param2                                   # Parameterization 2
ghypChangePars(2, 1, param2)             # Back to parameterization 1
</code></pre>

<hr>
<h2 id='ghypCheckPars'>Check Parameters of the Generalized Hyperbolic Distribution</h2><span id='topic+ghypCheckPars'></span>

<h3>Description</h3>

<p>Given a putative set of parameters for the generalized hyperbolic
distribution, the functions checks if they are in the correct range,
and if they correspond to the boundary cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypCheckPars(param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghypCheckPars_+3A_param">param</code></td>
<td>
<p>Numeric. Putative parameter values for a generalized
hyperblic distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>param</code> takes the form <code>c(mu, delta, alpha, beta,
  lambda)</code>.
</p>
<p>If <code>alpha</code> is negative, an error is returned.
</p>
<p>If lambda is 0 then the absolute value of <code>beta</code> must be less
than <code>alpha</code> and delta must be greater than zero. If either of
these conditions are false, than a error is returned.
</p>
<p>If <code>lambda</code> is greater than 0 the absolute value of <code>beta</code>
must be less than <code>alpha</code>. <code>delta</code> must also be
non-negative. When either one of these is not true, an error is
returned.
</p>
<p>If <code>lambda</code> is less than 0 then the absolute value of <code>beta</code>
must be equal to <code>alpha</code>. <code>delta</code> must be greater than 0, if
both conditions are not true, an error is returned.  </p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>case</code></td>
<td>
<p>Either <code>""</code> or <code>"error"</code>.</p>
</td></tr>
<tr><td><code>errMessage</code></td>
<td>
<p>An appropriate error message if an error was found,
the empty string <code>""</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dghyp">dghyp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ghypCheckPars(c(0, 2.5, -0.5, 1, 0))      # error
ghypCheckPars(c(0, 2.5, 0.5, 0, 0))       # normal
ghypCheckPars(c(0, 1, 1, -1, 0))          # error
ghypCheckPars(c(2, 0, 1, 0.5, 0))         # error
ghypCheckPars(c(0, 5, 2, 1.5, 0))         # normal
ghypCheckPars(c(0, -2.5, -0.5, 1, 1))     # error
ghypCheckPars(c(0, -1, 0.5, 1, 1))        # error
ghypCheckPars(c(0, 0, -0.5, -1, 1))       # error
ghypCheckPars(c(2, 0, 0.5, 0, -1))        # error
ghypCheckPars(c(2, 0, 1, 0.5, 1))         # skew laplace
ghypCheckPars(c(0, 1, 1, 1, -1))          # skew hyperbolic
</code></pre>

<hr>
<h2 id='ghypMom'>Calculate Moments of the Generalized Hyperbolic Distribution</h2><span id='topic+ghypMom'></span>

<h3>Description</h3>

<p>Function to calculate raw moments, mu moments, central moments and
moments about any other given location for the generalized hyperbolic
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypMom(order, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
        param = c(mu, delta, alpha, beta, lambda),
        momType = c("raw", "central", "mu"), about = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghypMom_+3A_order">order</code></td>
<td>
<p>Numeric. The order of the moment to be calculated. Not
permitted to be a vector. Must be a positive whole number except for
moments about zero.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_lambda">lambda</code></td>
<td>
<p><code class="reqn">\lambda</code> is the shape parameter and dictates the
shape that the distribution shall take. Default value is 1.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_param">param</code></td>
<td>
<p>Numeric. The parameter vector specifying the generalized
hyperbolic  distribution. Of the form <br />
<code>c(mu, delta, alpha, beta, lambda)</code>
(see <code><a href="#topic+dghyp">dghyp</a></code>).</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_momtype">momType</code></td>
<td>
<p>Common types of moments to be calculated, default is &quot;raw&quot;.
See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="ghypMom_+3A_about">about</code></td>
<td>
<p>Numeric. The point around which the moment is to be
calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checking whether <code>order</code> is a whole number is carried out using
the function <code><a href="DistributionUtils.html#topic+is.wholenumber">is.wholenumber</a></code>.
</p>
<p><code>momType</code> can be either &quot;raw&quot; (moments about zero), &quot;mu&quot; (moments
about mu), or &quot;central&quot; (moments about mean). If one of these moment
types is specified, then there is no need to specify the <code>about</code>
value. For moments about any other location, the <code>about</code> value
must be specified. In the case that both <code>momType</code> and
<code>about</code> are specified and contradicting, the function will always
calculate the moments based on <code>about</code> rather than
<code>momType</code>.
</p>
<p>To calculate moments of the generalized hyperbolic distribution, the
function firstly calculates mu moments by formula defined below and
then transforms mu moments to central moments or raw moments or
moments about any other locations as required by calling
<code>momChangeAbout</code>.
</p>
<p>The mu moments are obtained from the recursion formula given in Scott,
Würtz and Tran (2011).
</p>


<h3>Value</h3>

<p>The moment specified.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Scott, D. J., Würtz, D., Dong, C. and Tran, T. T. (2011)
Moments of the generalized hyperbolic distribution.
<em>Comp. Statistics.</em>, <b>26</b>, 459&ndash;476.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ghypChangePars">ghypChangePars</a></code> and from package <a href="https://CRAN.R-project.org/package=DistributionUtils"><span class="pkg">DistributionUtils</span></a>:
<code><a href="DistributionUtils.html#topic+logHist">logHist</a></code>,
<code><a href="DistributionUtils.html#topic+is.wholenumber">is.wholenumber</a></code>,
<code><a href="DistributionUtils.html#topic+momChangeAbout">momChangeAbout</a></code>, and
<code><a href="DistributionUtils.html#topic+momIntegrated">momIntegrated</a></code>.
</p>
<p>Further, <code><a href="#topic+ghypMean">ghypMean</a></code>, <code><a href="#topic+ghypVar">ghypVar</a></code>, <code><a href="#topic+ghypSkew">ghypSkew</a></code>,
<code><a href="#topic+ghypKurt">ghypKurt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(1, 2, 2, 1, 2)
mu &lt;- param[1]
### mu moments
m1 &lt;- ghypMean(param = param)
m1 - mu
ghypMom(1, param = param, momType = "mu")

## Comparison, using momIntegrated from pkg 'DistributionUtils':
momIntegrated &lt;- DistributionUtils :: momIntegrated

momIntegrated("ghyp", order = 1, param = param, about = mu)
ghypMom(2, param = param, momType = "mu")
momIntegrated("ghyp", order = 2, param = param, about = mu)
ghypMom(10, param = param, momType = "mu")
momIntegrated("ghyp", order = 10, param = param, about = mu)

### raw moments
ghypMean(param = param)
ghypMom(1, param = param, momType = "raw")
momIntegrated("ghyp", order = 1, param = param, about = 0)
ghypMom(2, param = param, momType = "raw")
momIntegrated("ghyp", order = 2, param = param, about = 0)
ghypMom(10, param = param, momType = "raw")
momIntegrated("ghyp", order = 10, param = param, about = 0)

### central moments
ghypMom(1, param = param, momType = "central")
momIntegrated("ghyp", order = 1, param = param, about = m1)
ghypVar(param = param)
ghypMom(2, param = param, momType = "central")
momIntegrated("ghyp", order = 2, param = param, about = m1)
ghypMom(10, param = param, momType = "central")
momIntegrated("ghyp", order = 10, param = param, about = m1)
</code></pre>

<hr>
<h2 id='ghypParam'>Parameter Sets for the Generalized Hyperbolic Distribution</h2><span id='topic+ghypParam'></span><span id='topic+ghypSmallShape'></span><span id='topic+ghypLargeShape'></span><span id='topic+ghypSmallParam'></span><span id='topic+ghypLargeParam'></span>

<h3>Description</h3>

<p>These objects store different parameter sets of the generalized
hyperbolic distribution as matrices for testing or demonstration
purposes.
</p>
<p>The parameter sets <code>ghypSmallShape</code> and
<code>ghypLargeShape</code> have a constant location parameter of
<code class="reqn">\mu</code> = 0, and constant scale parameter <code class="reqn">\delta</code> =
1. In <code>ghypSmallParam</code> and <code>ghypLargeParam</code> the values of
the location and scale parameters vary. In these parameter sets the
location parameter <code class="reqn">\mu</code> = 0 takes values from {0, 1} and
{-1, 0, 1, 2}  respectively. For the scale parameter
<code class="reqn">\delta</code>, values are drawn from {1, 5} and {1, 2, 5,
10} respectively.
</p>
<p>For the shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> the
approach is more complex. The values for these shape parameters were
chosen by choosing values of <code class="reqn">\xi</code> and <code class="reqn">\chi</code> which
range over the shape triangle, then the function <code>ghypChangePars</code>
was applied to convert them to the <code class="reqn">\alpha, \beta</code>
parameterization. The resulting <code class="reqn">\alpha, \beta</code>
values were then rounded to three decimal places. See the examples for
the values of <code class="reqn">\xi</code> and <code class="reqn">\chi</code> for the large
parameter sets.
</p>
<p>The values of <code class="reqn">\lambda</code> are drawn from {-0.5, 0, 1} in
<code>ghypSmallShape</code> and {-1, -0.5, 0, 0.5, 1, 2} in
<code>ghypLargeShape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ghypSmallShape
  ghypLargeShape
  ghypSmallParam
  ghypLargeParam
</code></pre>


<h3>Format</h3>

<p><code>ghypSmallShape</code>: a 22 by 5 matrix;
<code>ghypLargeShape</code>: a 90 by 5 matrix;
<code>ghypSmallParam</code>: a 84 by 5 matrix;
<code>ghypLargeParam</code>: a 1440 by 5 matrix.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghypParam)
plotShapeTriangle()
xis &lt;- rep(c(0.1,0.3,0.5,0.7,0.9), 1:5)
chis &lt;- c(0,-0.25,0.25,-0.45,0,0.45,-0.65,-0.3,0.3,0.65,
          -0.85,-0.4,0,0.4,0.85)
points(chis, xis, pch = 20, col = "red")


## Testing the accuracy of ghypMean
for (i in 1:nrow(ghypSmallParam)) {
  param &lt;- ghypSmallParam[i, ]
  x &lt;- rghyp(1000, param = param)
  sampleMean &lt;- mean(x)
  funMean &lt;- ghypMean(param = param)
  difference &lt;- abs(sampleMean - funMean)
  print(difference)
}

</code></pre>

<hr>
<h2 id='ghypScale'>
Rescale a generalized hyperbolic distribution
</h2><span id='topic+ghypScale'></span>

<h3>Description</h3>

<p>Given a specific mean and standard deviation will rescale any given
generalized hyperbolic distribution to have the same shape but the
specified mean and standard deviation. Can be used to standardize a
generalized hyperbolic distribution to have mean zero and standard
deviation one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypScale(newMean, newSD,
          mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
          param = c(mu, delta, alpha, beta, lambda))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghypScale_+3A_newmean">newMean</code></td>
<td>

<p>Numeric. The required mean of the rescaled distribution.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_newsd">newSD</code></td>
<td>

<p>Numeric. The required standard deviation of the rescaled distribution.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_mu">mu</code></td>
<td>
<p>Numeric. Location parameter <code class="reqn">\mu</code> of the starting
distribution, default is0.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_delta">delta</code></td>
<td>
<p>Numeric. Scale parameter <code class="reqn">\delta</code> of the starting
distribution, default is 1.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Tail parameter <code class="reqn">\alpha</code> of the starting
distribution, default is 1.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_beta">beta</code></td>
<td>
<p>Numeric. Skewness parameter <code class="reqn">\beta</code> of the starting
distribution, default is 0.
</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_lambda">lambda</code></td>
<td>
<p>Numeric. Shape parameter <code class="reqn">\lambda</code> of the starting
distribution, default is 1.</p>
</td></tr>
<tr><td><code id="ghypScale_+3A_param">param</code></td>
<td>
<p>Numeric. Specifying the parameters of the starting
distribution as a vector of the form<br />
<code>c(mu,delta,alpha,beta,lambda)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of length 5 giving the value of the parameters in
the rescaled generalized hyperbolic distribution in the usual
(<code class="reqn">\alpha, \beta</code>) parameterization.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2,10,0.1,0.07,-0.5) # a normal inverse Gaussian
ghypMean(param = param)
ghypVar(param = param)
## convert to standardized parameters
(newParam &lt;- ghypScale(0, 1, param = param))
ghypMean(param = newParam)
ghypVar(param = newParam)

## try some other mean and sd
(newParam &lt;- ghypScale(1, 1, param = param))
ghypMean(param = newParam)
sqrt(ghypVar(param = newParam))
(newParam &lt;- ghypScale(10, 2, param = param))
ghypMean(param = newParam)
sqrt(ghypVar(param = newParam))
</code></pre>

<hr>
<h2 id='gigCalcRange'>Range of a Generalized Inverse Gaussian Distribution</h2><span id='topic+gigCalcRange'></span>

<h3>Description</h3>

<p>Given the parameter vector param of a generalized inverse Gaussian
distribution, this function determines the range outside of which the density
function is negligible, to a specified tolerance. The parameterization
used is the <code class="reqn">(\chi, \psi)</code> one (see
<code><a href="#topic+dgig">dgig</a></code>). To use another parameterization, use
<code><a href="#topic+gigChangePars">gigChangePars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigCalcRange(chi = 1, psi = 1, lambda = 1,
             param = c(chi, psi, lambda),
             tol = 10^(-5), density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigCalcRange_+3A_chi">chi</code></td>
<td>
<p>A shape parameter that by default holds a value of 1.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_psi">psi</code></td>
<td>
<p>Another shape parameter that is set to 1 by default.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter of the GIG distribution. Common to all forms of 
parameterization. By default this is set to 1.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_param">param</code></td>
<td>
<p>Value of parameter vector specifying the generalized
inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_density">density</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the bounds are for the density
function. If <code>FALSE</code>, they should be for the probability
distribution, but this has not yet been implemented.</p>
</td></tr>
<tr><td><code id="gigCalcRange_+3A_...">...</code></td>
<td>
<p>Extra arguments for calls to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The particular generalized inverse Gaussian distribution being
considered is specified by the value of the parameter value
<code>param</code>.
</p>
<p>If <code>density = TRUE</code>, the function gives a range, outside of which
the density is less than the given tolerance. Useful for plotting the
density. Also used in determining break points for the separate
sections over which numerical integration is used to determine the
distribution function. The points are found by using
<code><a href="stats.html#topic+uniroot">uniroot</a></code> on the density function.
</p>
<p>If <code>density = FALSE</code>, the function returns the message:
&quot;<code>Distribution function bounds not yet implemented</code>&quot;.
</p>


<h3>Value</h3>

<p>A two-component vector giving the lower and upper ends of the range.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Jörgensen, B. (1982).
<em>Statistical Properties of the Generalized Inverse Gaussian
Distribution</em>.
Lecture Notes in Statistics, Vol. 9, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgig">dgig</a></code>, <code><a href="#topic+gigChangePars">gigChangePars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2.5, 0.5, 5)
maxDens &lt;- dgig(gigMode(param = param), param = param)
gigRange &lt;- gigCalcRange(param = param, tol = 10^(-3) * maxDens)
gigRange
curve(dgig(x, param = param), gigRange[1], gigRange[2])
## Not run: gigCalcRange(param = param, tol = 10^(-3), density = FALSE)
</code></pre>

<hr>
<h2 id='gigChangePars'>Change Parameterizations of the Generalized Inverse Gaussian
Distribution</h2><span id='topic+gigChangePars'></span>

<h3>Description</h3>

<p>This function interchanges between the following 4 parameterizations
of the generalized inverse Gaussian distribution:
</p>
<p>1. <code class="reqn">(\chi, \psi, \lambda)</code>
</p>
<p>2. <code class="reqn">(\delta, \gamma, \lambda)</code>
</p>
<p>3. <code class="reqn">(\alpha, \beta, \lambda)</code>
</p>
<p>4. <code class="reqn">(\omega, \eta, \lambda)</code>
</p>
<p>See Jörgensen (1982) and Dagpunar (1989)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigChangePars(from, to, param, noNames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigChangePars_+3A_from">from</code></td>
<td>
<p>The set of parameters to change from.</p>
</td></tr>
<tr><td><code id="gigChangePars_+3A_to">to</code></td>
<td>
<p>The set of parameters to change to.</p>
</td></tr>
<tr><td><code id="gigChangePars_+3A_param">param</code></td>
<td>
<p>&ldquo;<code>from</code>&rdquo; parameter vector consisting of 3
numerical elements.</p>
</td></tr>
<tr><td><code id="gigChangePars_+3A_nonames">noNames</code></td>
<td>
<p>Logical. When <code>TRUE</code>, suppresses the parameter
<code>names</code> in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The range of <code class="reqn">\lambda</code> is the whole real line.
In each parameterization, the other two parameters must take positive
values.
</p>


<h3>Value</h3>

<p>A numerical vector of length 3 representing <code>param</code> in the
&ldquo;<code>to</code>&rdquo; parameterization.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Jörgensen, B. (1982).
<em>Statistical Properties of the Generalized Inverse Gaussian
Distribution</em>.
Lecture Notes in Statistics, Vol. 9, Springer-Verlag, New York.
</p>
<p>Dagpunar, J. S. (1989).
An easily implemented generalised inverse Gaussian generator,
<em>Commun. Statist.&mdash;Simula.</em>, <b>18</b>, 703&ndash;710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgig">dgig</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>param1 &lt;- c(2.5, 0.5, 5)                # Parameterisation 1
param2 &lt;- gigChangePars(1, 2, param1)   # Convert to parameterization 2
param2                                  # Parameterization 2
gigChangePars(2, 1, as.numeric(param2)) # Convert back to parameterization 1
</code></pre>

<hr>
<h2 id='gigCheckPars'>Check Parameters of the Generalized Inverse Gaussian Distribution</h2><span id='topic+gigCheckPars'></span>

<h3>Description</h3>

<p>Given a putative set of parameters for the generalized inverse Gaussian
distribution, the functions checks if they are in the correct range,
and if they correspond to the boundary cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigCheckPars(param, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigCheckPars_+3A_param">param</code></td>
<td>
<p>Numeric. Putative parameter values for a generalized
inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code id="gigCheckPars_+3A_...">...</code></td>
<td>
<p>Further arguments for calls to <code>all.equal</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>param</code> takes the form <code>c(chi, psi, lambda)</code>.
</p>
<p>If either <code>chi</code> or <code>psi</code> is negative, an error is returned.
</p>
<p>If <code>chi</code> is 0 (to within tolerance allowed by <code>all.equal</code>)
then <code>psi</code> and <code>lambda</code> must be positive or an error is
returned. If these conditions are satisfied, the distribution is
identified as a gamma distribution.
</p>
<p>If <code>psi</code> is 0 (to within tolerance allowed by <code>all.equal</code>)
then <code>chi</code> must be positive and <code>lambda</code> must be negative or
an error is returned. If these conditions are satisfied, the
distribution is identified as an inverse gamma distribution.
</p>
<p>If both <code>chi</code> and <code>psi</code> are positive, then the distribution
is identified as a normal generalized inverse Gaussian distribution.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>case</code></td>
<td>
<p>Whichever of <code>"error"</code>, <code>"gamma"</code>,
<code>invgamma</code>, or <code>"normal"</code> is identified by the function.</p>
</td></tr>
<tr><td><code>errMessage</code></td>
<td>
<p>An appropriate error message if an error was found,
the empty string <code>""</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgig">dgig</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>gigCheckPars(c(5, 2.5, -0.5))      # normal
gigCheckPars(c(-5, 2.5, 0.5))      # error
gigCheckPars(c(5, -2.5, 0.5))      # error
gigCheckPars(c(-5, -2.5, 0.5))     # error
gigCheckPars(c(0, 2.5, 0.5))       # gamma
gigCheckPars(c(0, 2.5, -0.5))      # error
gigCheckPars(c(0, 0, 0.5))         # error
gigCheckPars(c(0, 0, -0.5))        # error
gigCheckPars(c(5, 0, 0.5))         # error
gigCheckPars(c(5, 0, -0.5))        # invgamma
</code></pre>

<hr>
<h2 id='gigFit'>Fit the Generalized Inverse Gausssian Distribution to Data</h2><span id='topic+gigFit'></span><span id='topic+print.gigFit'></span><span id='topic+plot.gigFit'></span><span id='topic+coef.gigFit'></span><span id='topic+vcov.gigFit'></span>

<h3>Description</h3>

<p>Fits a generalized inverse Gaussian distribution to data.
Displays the histogram, log-histogram (both with fitted densities),
Q-Q plot and P-P plot for the fit which has the maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gigFit(x, freq = NULL, paramStart = NULL,
         startMethod = c("Nelder-Mead","BFGS"),
         startValues = c("LM","GammaIG","MoM","Symb","US"),
         method = c("Nelder-Mead","BFGS","nlm"),
         stand = TRUE, plots = FALSE, printOut = FALSE,
         controlBFGS = list(maxit = 200),
         controlNM = list(maxit = 1000),
         maxitNLM = 1500, ...)


  ## S3 method for class 'gigFit'
print(x,
        digits = max(3, getOption("digits") - 3), ...)

  ## S3 method for class 'gigFit'
plot(x, which = 1:4,
       plotTitles = paste(c("Histogram of ", "Log-Histogram of ",
                          "Q-Q Plot of ", "P-P Plot of "),
                          x$obsName, sep = ""),
       ask = prod(par("mfcol")) &lt; length(which) &amp; dev.interactive(), ...)

  ## S3 method for class 'gigFit'
coef(object, ...)

  ## S3 method for class 'gigFit'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigFit_+3A_x">x</code></td>
<td>
<p>Data vector for <code>gigFit</code>. Object of class
<code>"gigFit"</code> for <code>print.gigFit</code> and <code>plot.gigFit</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_freq">freq</code></td>
<td>
<p>A vector of weights with length equal to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_paramstart">paramStart</code></td>
<td>
<p>A user specified starting parameter vector
<code>param</code> taking the form <code>c(chi, psi, lambda)</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_startmethod">startMethod</code></td>
<td>
<p>Method used by <code>gigFitStartMoM</code> in calls to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_startvalues">startValues</code></td>
<td>
<p>Code giving the method of determining starting
values for finding the maximum likelihood estimate of <code>param</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_method">method</code></td>
<td>
<p>Different optimisation methods to consider.
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_stand">stand</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the data is first standardized
by dividing by the sample standard deviation.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_plots">plots</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of the
histogram, log-histogram, Q-Q plot and P-P plot.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_printout">printOut</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of
results of fitting.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_controlbfgs">controlBFGS</code></td>
<td>
<p>A list of control parameters for <code>optim</code> when using
the <code>"BFGS"</code> optimisation.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_controlnm">controlNM</code></td>
<td>
<p>A list of control parameters for <code>optim</code>
when using the <code>"Nelder-Mead"</code> optimisation.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_maxitnlm">maxitNLM</code></td>
<td>
<p>A positive integer specifying the maximum number of
iterations when using the <code>"nlm"</code> optimisation.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_digits">digits</code></td>
<td>
<p>Desired number of digits when the object is printed.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of
the numbers <code>1:4</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_plottitles">plotTitles</code></td>
<td>
<p>Titles to appear above the plots.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, see <code><a href="graphics.html#topic+par">par</a>(ask = .)</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>optim</code>, <code>par</code>,
<code>hist</code>, <code>logHist</code>, <code>qqgig</code> and <code>ppgig</code>.</p>
</td></tr>
<tr><td><code id="gigFit_+3A_object">object</code></td>
<td>
<p>Object of class <code>"gigFit"</code> for <code>coef.gigFit</code>
and for <code>vcov.gigFit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the argument <code>startValues</code> are the following:
</p>

<dl>
<dt><code>"LM"</code></dt><dd><p>Based on fitting linear models to the upper tails
of the data <code>x</code> and the inverse of the data <code>1/x</code>.</p>
</dd>
<dt><code>"GammaIG"</code></dt><dd><p>Based on fitting gamma and inverse gamma
distributions.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
<dt><code>"Symb"</code></dt><dd><p>Not yet implemented.</p>
</dd>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
</dl>

<p>If <code>startValues = "US"</code> then a value must be supplied for
<code>paramStart</code>.
</p>
<p>For the details concerning the use of <code>paramStart</code>,
<code>startMethod</code>, and <code>startValues</code>, see
<code><a href="#topic+gigFitStart">gigFitStart</a></code>.
</p>
<p>The three optimisation methods currently available are:
</p>

<dl>
<dt><code>"BFGS"</code></dt><dd><p>Uses the quasi-Newton method <code>"BFGS"</code> as
documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"Nelder-Mead"</code></dt><dd><p>Uses an implementation of the Nelder and
Mead method as documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"nlm"</code></dt><dd><p>Uses the <code><a href="stats.html#topic+nlm">nlm</a></code> function in R.</p>
</dd>
</dl>

<p>For details of how to pass control information for optimisation using
<code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code>, see <code><a href="stats.html#topic+optim">optim</a></code> and
<code><a href="stats.html#topic+nlm">nlm</a>.</code>
</p>
<p>When <code>method = "nlm"</code> is used, warnings may be produced. These do
not appear to be a problem.
</p>


<h3>Value</h3>

<p><code>gigFit</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>A vector giving the maximum likelihood estimate of
param, as <code>c(chi, psi, lambda)</code>.</p>
</td></tr>
<tr><td><code>maxLik</code></td>
<td>
<p>The value of the maximised log-likelihood.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Optimisation method used.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>Convergence code. See the relevant documentation (either
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlm">nlm</a></code>) for details on
convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations of optimisation routine.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>The data used to fit the generalized inverse Gaussian
distribution.</p>
</td></tr>
<tr><td><code>obsName</code></td>
<td>
<p>A character string with the actual <code>x</code> argument
name.</p>
</td></tr>
<tr><td><code>paramStart</code></td>
<td>
<p>Starting value of <code>param</code> returned by call to
<code><a href="#topic+gigFitStart">gigFitStart</a></code>.</p>
</td></tr>
<tr><td><code>svName</code></td>
<td>
<p>Descriptive name for the method finding start values.</p>
</td></tr>
<tr><td><code>startValues</code></td>
<td>
<p>Acronym for the method of finding start values.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, David Cusack</p>


<h3>References</h3>

<p>Jörgensen, B. (1982). <em>Statistical Properties of
the Generalized Inverse Gaussian Distribution</em>. Lecture Notes in
Statistics, Vol. 9, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="DistributionUtils.html#topic+logHist">logHist</a></code> (pkg <a href="https://CRAN.R-project.org/package=DistributionUtils"><span class="pkg">DistributionUtils</span></a>),
<code><a href="#topic+qqgig">qqgig</a></code>, <code><a href="#topic+ppgig">ppgig</a></code>, and <code><a href="#topic+gigFitStart">gigFitStart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(1, 1, 1)
dataVector &lt;- rgig(500, param = param)
## See how well gigFit works
gigFit(dataVector)
##gigFit(dataVector, plots = TRUE)

## See how well gigFit works in the limiting cases
## Gamma case
dataVector2 &lt;- rgamma(500, shape = 1, rate = 1)
gigFit(dataVector2)

## Inverse gamma
require(actuar)
dataVector3 &lt;- rinvgamma(500, shape = 1, rate = 1)
gigFit(dataVector3)

## Use nlm instead of default
gigFit(dataVector, method = "nlm")

</code></pre>

<hr>
<h2 id='gigFitStart'>Find Starting Values for Fitting a
Generalized Inverse Gaussian Distribution</h2><span id='topic+gigFitStart'></span><span id='topic+gigFitStartMoM'></span><span id='topic+gigFitStartLM'></span>

<h3>Description</h3>

<p>Finds starting values for input to a maximum likelihood routine for
fitting the generalized inverse Gaussian distribution to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gigFitStart(x, startValues = c("LM","GammaIG","MoM","Symb","US"),
              paramStart = NULL,
              startMethodMoM = c("Nelder-Mead","BFGS"), ...)
  gigFitStartMoM(x, paramStart = NULL,
                 startMethodMoM = "Nelder-Mead", ...)
  gigFitStartLM(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigFitStart_+3A_x">x</code></td>
<td>
<p>Data vector.</p>
</td></tr>
<tr><td><code id="gigFitStart_+3A_startvalues">startValues</code></td>
<td>
<p>Acronym indicating the method to use for obtaining
starting values to be used as input to <code>gigFit</code>. See
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="gigFitStart_+3A_paramstart">paramStart</code></td>
<td>
<p>Starting values for param if <code>startValues =
      "US"</code>.</p>
</td></tr>
<tr><td><code id="gigFitStart_+3A_startmethodmom">startMethodMoM</code></td>
<td>
<p>Method used by call to <code><a href="stats.html#topic+optim">optim</a></code> in
finding method of moments estimates.</p>
</td></tr>
<tr><td><code id="gigFitStart_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="stats.html#topic+optim">optim</a></code> and calls to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the argument <code>startValues</code> are the following:
</p>

<dl>
<dt><code>"LM"</code></dt><dd><p>Based on fitting linear models to the upper tails
of the data <code>x</code> and the inverse of the data <code>1/x</code>.</p>
</dd>
<dt><code>"GammaIG"</code></dt><dd><p>Based on fitting gamma and inverse gamma
distributions.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
<dt><code>"Symb"</code></dt><dd><p>Not yet implemented.</p>
</dd>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
</dl>

<p>If <code>startValues = "US"</code> then a value must be supplied for
<code>paramStart</code>.
</p>
<p>When <code>startValues = "MoM"</code> an initial optimisation is needed to
find the starting values. This optimisations starts from arbitrary
values, <code>c(1,1,1)</code> for the parameters
<code class="reqn">(\chi,\psi,\lambda)</code> and calls
<code><a href="stats.html#topic+optim">optim</a></code> with the method given by
<code>startMethodMoM</code>. Other starting values for the method of moments
can be used by supplying a value for <code>paramStart</code>.
</p>
<p>The default method of finding starting values is
<code>"LM"</code>. Testing indicates this is quite fast and finds good
starting values. In addition, it does not require any starting values
itself.
</p>
<p><code>gigFitStartMoM</code> is called by <code>gigFitStart</code> and implements
the method of moments approach.
</p>
<p><code>gigFitStartLM</code> is called by <code>gigFitStart</code> and implements
the linear models approach.
</p>


<h3>Value</h3>

<p><code>gigFitStart</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>paramStart</code></td>
<td>
<p>A vector with elements <code>chi</code>, <code>psi</code>,
and <code>lambda</code> giving the starting value of <code>param</code>.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>
<p><code>gigFitStartMoM</code> and <code>gigFitStartLM</code> each return
<code>paramStart</code>, the starting value of <code>param</code>, to the calling
function <code>gigFitStart</code>
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
David Cusack</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgig">dgig</a></code>, <code><a href="#topic+gigFit">gigFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(1, 1, 1)
dataVector &lt;- rgig(500, param = param)
gigFitStart(dataVector)
</code></pre>

<hr>
<h2 id='gigHessian'>
Calculate Two-Sided Hessian for the Generalized Inverse Gaussian Distribution
</h2><span id='topic+gigHessian'></span>

<h3>Description</h3>

<p>Calculates the Hessian of a function, either exactly or approximately. Used to
obtaining the information matrix for maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigHessian(x, param, hessianMethod = "tsHessian",
           whichParam = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigHessian_+3A_x">x</code></td>
<td>
<p>Data vector.</p>
</td></tr>
<tr><td><code id="gigHessian_+3A_param">param</code></td>
<td>
<p>The maximum likelihood estimates parameter vector of the
generalized inverse Gaussian distribution. There are five different sets of
parameterazations can be used in this function, the first four sets
are listed in <code>gigChangePars</code> and the last set is the log
scale of the first set of the parameterization, i.e.,
<code>mu,log(delta),Pi,log(zeta)</code>.  </p>
</td></tr>
<tr><td><code id="gigHessian_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>Only the approximate method (<code>"tsHessian"</code>)
has actually been implemented so far.</p>
</td></tr>
<tr><td><code id="gigHessian_+3A_whichparam">whichParam</code></td>
<td>
<p>Numeric. A number between indicating which
parameterization the argument <code>param</code> relates to. Only
parameterization 1 is available so far.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate Hessian is obtained via a call to <code>tsHessian</code>
from the package <code>DistributionUtils</code>.  <code>summary.gigFit</code>
calls the function <code>gigHessian</code> to calculate the Hessian matrix
when the argument <code>hessian = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>gigHessian</code> gives the approximate Hessian matrix for
the data vector <code>x</code> and the estimated parameter vector
<code>param</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, David Cusack
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Calculate the approximate Hessian using gigHessian:
param &lt;- c(1,1,1)
dataVector &lt;- rgig(500, param = param)
fit &lt;- gigFit(dataVector)
coef &lt;- coef(fit)
gigHessian(x = dataVector, param = coef, hessianMethod = "tsHessian",
              whichParam = 1)

### Or calculate the approximate Hessian using summary.gigFit method:
summary(fit, hessian = TRUE)
</code></pre>

<hr>
<h2 id='gigMom'>Calculate Moments of the Generalized Inverse Gaussian Distribution</h2><span id='topic+gigMom'></span><span id='topic+gigRawMom'></span><span id='topic+gammaRawMom'></span>

<h3>Description</h3>

<p>Functions to calculate raw moments and moments about a given location
for the generalized inverse Gaussian (GIG) distribution, including the
gamma and inverse gamma distributions as special cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigRawMom(order, chi = 1, psi = 1, lambda = 1,
          param = c(chi, psi, lambda))
gigMom(order, chi = 1, psi = 1, lambda = 1,
       param = c(chi, psi, lambda), about = 0)
gammaRawMom(order, shape = 1, rate = 1, scale = 1/rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gigMom_+3A_order">order</code></td>
<td>
<p>Numeric. The order of the moment to be calculated. Not
permitted to be a vector. Must be a positive whole number except for
moments about zero.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_chi">chi</code></td>
<td>
<p>A shape parameter that by default holds a value of 1.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_psi">psi</code></td>
<td>
<p>Another shape parameter that is set to 1 by default.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter of the GIG distribution. Common to all
forms of parameterization. By default this is set to 1.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_param">param</code></td>
<td>
<p>Numeric. The parameter vector specifying the GIG
distribution. Of the form <code>c(chi, psi, lambda)</code> (see
<code><a href="#topic+dgig">dgig</a></code>).</p>
</td></tr>
<tr><td><code id="gigMom_+3A_about">about</code></td>
<td>
<p>Numeric. The point around which the moment is to be
calculated.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_shape">shape</code></td>
<td>
<p>Numeric. The shape parameter, must be non-negative, not
permitted to be a vector.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_scale">scale</code></td>
<td>
<p>Numeric. The scale parameter, must be positive, not
permitted to be a vector.</p>
</td></tr>
<tr><td><code id="gigMom_+3A_rate">rate</code></td>
<td>
<p>Numeric. The rate parameter, an alternative way to specify
the scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>param</code> of parameters is examined using
<code><a href="#topic+gigCheckPars">gigCheckPars</a></code> to see if the parameters are valid for the GIG
distribution and if they correspond to the special cases which are the
gamma and inverse gamma distributions. Checking of special cases and
valid parameter vector values is carried out using the function
<code><a href="#topic+gigCheckPars">gigCheckPars</a></code>. Checking whether <code>order</code>
is a whole number is carried out using the function
<code><a href="DistributionUtils.html#topic+is.wholenumber">is.wholenumber</a></code>.
</p>
<p>Raw moments (moments about zero) are calculated using the functions
<code>gigRawMom</code> or <code>gammaRawMom</code>. For moments not about zero,
the function <code><a href="DistributionUtils.html#topic+momChangeAbout">momChangeAbout</a></code> is used
to derive moments about another point from raw moments. Note that raw
moments of the inverse gamma distribution can be obtained from the raw
moments of the gamma distribution because of the relationship between
the two distributions. An alternative implementation of raw moments of
the gamma and inverse gamma distributions may be found in the package
<span class="pkg">actuar</span> and these may be faster since they are written in C.
</p>
<p>To calculate the raw moments of the GIG distribution it is convenient to
use the alternative parameterization of the GIG in terms of
<code class="reqn">\omega</code> and <code class="reqn">\eta</code>, given as parameterization 3
in <code><a href="#topic+gigChangePars">gigChangePars</a></code>. Then the raw moment of the GIG
distribution of order <code class="reqn">k</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\eta^k K_{\lambda+k}(\omega)/K_{\lambda}(\omega)</code>
</p>

<p>where <code class="reqn">K_\lambda()</code> is the modified Bessel function of
the third kind of order <code class="reqn">\lambda</code>.
</p>
<p>The raw moment of the gamma distribution of order <code class="reqn">k</code> with
shape parameter <code class="reqn">\alpha</code> and rate parameter
<code class="reqn">\beta</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\beta^{-k}\Gamma(\alpha+k)/\Gamma(\alpha)</code>
</p>

<p>The raw moment of order <code class="reqn">k</code> of the inverse gamma distribution
with shape parameter <code class="reqn">\alpha</code> and rate parameter
<code class="reqn">\beta</code> is the raw moment of order <code class="reqn">-k</code> of the gamma
distribution with shape parameter <code class="reqn">\alpha</code> and rate parameter
<code class="reqn">1/\beta</code>.
</p>


<h3>Value</h3>

<p>The moment specified. In the case of raw moments, <code>Inf</code> is
returned if the moment is infinite.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gigCheckPars">gigCheckPars</a></code>, <code><a href="#topic+gigChangePars">gigChangePars</a></code>
and from package <a href="https://CRAN.R-project.org/package=DistributionUtils"><span class="pkg">DistributionUtils</span></a>:
<code><a href="DistributionUtils.html#topic+is.wholenumber">is.wholenumber</a></code>,
<code><a href="DistributionUtils.html#topic+momChangeAbout">momChangeAbout</a></code>,
<code><a href="DistributionUtils.html#topic+momIntegrated">momIntegrated</a></code>
</p>
<p>Further, <code><a href="#topic+gigMean">gigMean</a></code>,
<code><a href="#topic+gigVar">gigVar</a></code>, <code><a href="#topic+gigSkew">gigSkew</a></code>, <code><a href="#topic+gigKurt">gigKurt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Computations, using momIntegrated from pkg 'DistributionUtils':
momIntegrated &lt;- DistributionUtils :: momIntegrated

### Raw moments of the generalized inverse Gaussian distribution
param &lt;- c(5, 2.5, -0.5)
gigRawMom(1, param = param)
momIntegrated("gig", order = 1, param = param, about = 0)
gigRawMom(2, param = param)
momIntegrated("gig", order = 2, param = param, about = 0)
gigRawMom(10, param = param)
momIntegrated("gig", order = 10, param = param, about = 0)
gigRawMom(2.5, param = param)

### Moments of the generalized inverse Gaussian distribution
param &lt;- c(5, 2.5, -0.5)
(m1 &lt;- gigRawMom(1, param = param))
gigMom(1, param = param)
gigMom(2, param = param, about = m1)
(m2 &lt;- momIntegrated("gig", order = 2, param = param, about = m1))
gigMom(1, param = param, about = m1)
gigMom(3, param = param, about = m1)
momIntegrated("gig", order = 3, param = param, about = m1)

### Raw moments of the gamma distribution
shape &lt;- 2
rate &lt;- 3
param &lt;- c(shape, rate)
gammaRawMom(1, shape, rate)
momIntegrated("gamma", order = 1, shape = shape, rate = rate, about = 0)
gammaRawMom(2, shape, rate)
momIntegrated("gamma", order = 2, shape = shape, rate = rate, about = 0)
gammaRawMom(10, shape, rate)
momIntegrated("gamma", order = 10, shape = shape, rate = rate, about = 0)

### Moments of the inverse gamma distribution
param &lt;- c(5, 0, -0.5)
gigRawMom(2, param = param)             # Inf
gigRawMom(-2, param = param)
momIntegrated("invgamma", order = -2, shape = -param[3],
              rate = param[1]/2, about = 0)

### An example where the moment is infinite: inverse gamma
param &lt;- c(5, 0, -0.5)
gigMom(1, param = param)
gigMom(2, param = param)
</code></pre>

<hr>
<h2 id='gigParam'>Parameter Sets for the Generalized Inverse Gaussian Distribution</h2><span id='topic+gigParam'></span><span id='topic+gigSmallParam'></span><span id='topic+gigLargeParam'></span>

<h3>Description</h3>

<p>These objects store different parameter sets of the generalized
inverse Gaussian distribution as matrices for testing or demonstration
purposes.
</p>
<p>The parameter sets <code>gigSmallParam</code> and <code>gigLargeParam</code> give
combinations of values of the parameters <code class="reqn">\chi</code>,
<code class="reqn">\psi</code> and <code class="reqn">\lambda</code>. For <code>gigSmallParam</code>,
the values of <code class="reqn">\chi</code> and <code class="reqn">\psi</code> are chosen from {0.1,
0.5, 2, 5, 20, 50}, and the values of <code class="reqn">\lambda</code> from
{-0.5, 0, 0.5, 1, 5}.  For <code>gigLargeParam</code>, the values of
<code class="reqn">\chi</code> and <code class="reqn">\psi</code> are chosen from {0.1, 0.2, 0.5, 1,
2, 5, 10, 20, 50, 100}, and the values of <code class="reqn">\lambda</code> from
{-2, -1, -0.5, 0, 0.1, 0.2, 0.5, 1, 2, 5, 10}.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gigSmallParam
  gigLargeParam
</code></pre>


<h3>Format</h3>

<p><code>gigSmallParam</code>: a 125 by 3 matrix;
<code>gigLargeParam</code>: a 1100 by 3 matrix.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gigParam)
## Check values of chi and psi
plot(gigLargeParam[, 1], gigLargeParam[, 2])
### Check all three parameters
pairs(gigLargeParam,
  labels = c(expression(chi),expression(psi),expression(lambda)))

## Testing the accuracy of gigMean
for (i in 1:nrow(gigSmallParam)) {
  param &lt;- gigSmallParam[i, ]
  x &lt;- rgig(1000, param = param)
  sampleMean &lt;- mean(x)
  funMean &lt;- gigMean(param = param)
  difference &lt;- abs(sampleMean - funMean)
  print(difference)
}

</code></pre>

<hr>
<h2 id='GIGPlots'>Generalized Inverse Gaussian Quantile-Quantile and Percent-Percent Plots</h2><span id='topic+qqgig'></span><span id='topic+ppgig'></span>

<h3>Description</h3>

<p><code>qqgig</code> produces a generalized inverse Gaussian QQ plot of the
values in <code>y</code>.
</p>
<p><code>ppgig</code> produces a generalized inverse Gaussian PP (percent-percent) or
probability plot of the values in <code>y</code>.
</p>
<p>If <code>line = TRUE</code>, a line with zero intercept and unit slope is
added to the plot.
</p>
<p>Graphical parameters may be given as arguments to <code>qqgig</code>, and
<code>ppgig</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqgig(y, chi = 1, psi = 1, lambda = 1,
      param = c(chi, psi, lambda),
      main = "GIG Q-Q Plot",
      xlab = "Theoretical Quantiles",
      ylab = "Sample Quantiles",
      plot.it = TRUE, line = TRUE, ...)

ppgig(y, chi = 1, psi = 1, lambda = 1,
      param = c(chi, psi, lambda),
      main = "GIG P-P Plot",
      xlab = "Uniform Quantiles",
      ylab = "Probability-integral-transformed Data",
      plot.it = TRUE, line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GIGPlots_+3A_y">y</code></td>
<td>
<p>The data sample.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_chi">chi</code></td>
<td>
<p>A shape parameter that by default holds a value of 1.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_psi">psi</code></td>
<td>
<p>Another shape parameter that is set to 1 by default.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter of the GIG distribution. Common to all forms of 
parameterization. By default this is set to 1.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_param">param</code></td>
<td>
<p>Parameters of the generalized inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_xlab">xlab</code>, <code id="GIGPlots_+3A_ylab">ylab</code>, <code id="GIGPlots_+3A_main">main</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical.  TRUE denotes the results should be plotted.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_line">line</code></td>
<td>
<p>Logical. If TRUE, a line with zero intercept and unit slope
is added to the plot.</p>
</td></tr>
<tr><td><code id="GIGPlots_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qqgig</code> and <code>ppgig</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that are be plotted.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates of the points that are be plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilk, M. B. and Gnanadesikan, R. (1968)
Probability plotting methods for the analysis of data.
<em>Biometrika</em>.
<b>55</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ppoints">ppoints</a></code>, <code><a href="#topic+dgig">dgig</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
y &lt;- rgig(1000, param = c(2, 3, 1))
qqgig(y, param = c(2, 3, 1), line = FALSE)
abline(0, 1, col = 2)
ppgig(y, param = c(2, 3, 1))
</code></pre>

<hr>
<h2 id='hyperbCalcRange'>Range of a Hyperbolic Distribution</h2><span id='topic+hyperbCalcRange'></span>

<h3>Description</h3>

<p>Given the parameter vector param of a hyperbolic distribution,
this function calculates the range outside of which the distribution
has negligible probability, or the density function is negligible, to
a specified tolerance. The parameterization used
is the <code class="reqn">(\alpha, \beta)</code> one (see
<code><a href="#topic+dhyperb">dhyperb</a></code>). To use another parameterization, use
<code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbCalcRange(mu = 0, delta = 1, alpha = 1, beta = 0,
                param = c(mu, delta, alpha, beta),
                tol = 10^(-5), density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbCalcRange_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_param">param</code></td>
<td>
<p>Value of parameter vector specifying the hyperbolic
distribution. This takes the form <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_density">density</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the bounds are for the probability
distribution. If <code>TRUE</code>, they are for the density function.</p>
</td></tr>
<tr><td><code id="hyperbCalcRange_+3A_...">...</code></td>
<td>
<p>Extra arguments for calls to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The particular hyperbolic distribution being considered is specified
by the value of the parameter value <code>param</code>.
</p>
<p>If <code>density = FALSE</code>, the function calculates
the effective range of the distribution, which is used in calculating
the distribution function and quantiles, and may be used in determining
the range when plotting the distribution. By effective range is meant that
the probability of an observation being greater than the upper end is
less than the specified tolerance <code>tol</code>. Likewise for being smaller
than the lower end of the range. Note that this has not been implemented
yet.
</p>
<p>If <code>density = TRUE</code>, the function gives a range, outside of which
the density is less than the given tolerance. Useful for plotting the
density.
</p>


<h3>Value</h3>

<p>A two-component vector giving the lower and upper ends of the range.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Jennifer Tso, Richard Trendall</p>


<h3>References</h3>

 
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions. 
In <em>Encyclopedia of Statistical Sciences</em>, 
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code>, <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
param &lt;- c(0, 1, 3, 1)
hyperbRange &lt;- hyperbCalcRange(param = param, tol = 10^(-3))
hyperbRange
curve(phyperb(x, param = param), hyperbRange[1], hyperbRange[2])
maxDens &lt;- dhyperb(hyperbMode(param = param), param = param)
hyperbRange &lt;- hyperbCalcRange(param = param, tol = 10^(-3) * maxDens, density = TRUE)
hyperbRange
curve(dhyperb(x, param = param), hyperbRange[1], hyperbRange[2])
</code></pre>

<hr>
<h2 id='hyperbChangePars'>Change Parameterizations of the Hyperbolic Distribution</h2><span id='topic+hyperbChangePars'></span>

<h3>Description</h3>

<p>This function interchanges between the following 4 parameterizations
of the hyperbolic distribution:
</p>
<p>1. <code class="reqn">\mu, \delta, \pi, \zeta</code>
</p>
<p>2. <code class="reqn">\mu, \delta, \alpha, \beta</code>
</p>
<p>3. <code class="reqn">\mu, \delta, \phi, \gamma</code>
</p>
<p>4. <code class="reqn">\mu, \delta, \xi, \chi</code>
</p>
<p>The first three are given in Barndorff-Nielsen and
Blæsild (1983), and the fourth in Prause (1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbChangePars(from, to, param, noNames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbChangePars_+3A_from">from</code></td>
<td>
<p>The set of parameters to change from.</p>
</td></tr>
<tr><td><code id="hyperbChangePars_+3A_to">to</code></td>
<td>
<p>The set of parameters to change to.</p>
</td></tr>
<tr><td><code id="hyperbChangePars_+3A_param">param</code></td>
<td>
<p>&quot;from&quot; parameter vector consisting of 4 numerical elements.</p>
</td></tr>
<tr><td><code id="hyperbChangePars_+3A_nonames">noNames</code></td>
<td>
<p>Logical. When <code>TRUE</code>, suppresses the parameter
<code>names</code> in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the 4 parameterizations, the following must be positive:
</p>
<p>1. <code class="reqn">\zeta, \delta</code>
</p>
<p>2. <code class="reqn">\alpha, \delta</code>
</p>
<p>3. <code class="reqn">\phi, \gamma, \delta</code>
</p>
<p>4. <code class="reqn">\xi, \delta</code>
</p>
<p>Furthermore, note that in the second parameterization
<code class="reqn">\alpha</code> must be greater than the absolute value of
<code class="reqn">\beta</code>, while in the fourth parameterization, <code class="reqn">\xi</code>
must be less than one, and the absolute value of <code class="reqn">\chi</code> must
be less than <code class="reqn">\xi</code>.
</p>


<h3>Value</h3>

<p>A numerical vector of length 4 representing <code>param</code> in the
<code>to</code> parameterization.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Jennifer Tso, Richard Trendall</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P. (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>param1 &lt;- c(2, 1, 3, 1)                    # Parameterization 1
param2 &lt;- hyperbChangePars(1, 2, param1)   # Convert to parameterization 2
param2                                     # Parameterization 2
hyperbChangePars(2, 1, param2)             # Back to parameterization 1
</code></pre>

<hr>
<h2 id='hyperbCvMTest'>Cramer-von~Mises Test of a Hyperbolic Distribution</h2><span id='topic+hyperbCvMTest'></span><span id='topic+hyperbCvMTestPValue'></span><span id='topic+print.hyperbCvMTest'></span>

<h3>Description</h3>

<p>Carry out a Cramér-von~Mises test of a hyperbolic
distribution where the parameters of the distribution are estimated,
or calculate the p-value for such a test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbCvMTest(x, mu = 0, delta = 1, alpha = 1, beta = 0,
              param = c(mu, delta, alpha, beta),
              conf.level = 0.95, ...)
hyperbCvMTestPValue(delta = 1, alpha = 1, beta = 0, Wsq, digits = 3)
## S3 method for class 'hyperbCvMTest'
print(x, prefix = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbCvMTest_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values for <code>hyperbCvMTest</code>, or
object of class <code>"hyperbCvMTest"</code> for <code>print.hyperbCvMTest</code>.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_param">param</code></td>
<td>
<p>Parameters of the hyperbolic distribution taking the form
<code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level of the the confidence interval.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_wsq">Wsq</code></td>
<td>
<p>Value of the test statistic in the
Cramér-von~Mises test of the hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places for p-value.</p>
</td></tr>
<tr><td><code id="hyperbCvMTest_+3A_prefix">prefix</code></td>
<td>
<p>Character(s) to be printed before the description of the
test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hyperbCvMTest</code> carries out a Cramér-von~Mises
goodness-of-fit test of the hyperbolic distribution. The parameter
<code>param</code> must be given in the <code class="reqn">(\alpha, \beta)</code>
parameterization.
</p>
<p><code>hyperbCvMTestPValue</code> calculates the p-value of the test, and is
not expected to be called by the user. The method used is
interpolation in Table 5 given in Puig &amp; Stephens (2001), which
assumes all the parameters of the distribution are unknown. Since the
table used is limited, large p-values are simply given as
&ldquo;&gt;~0.25&rdquo; and very small ones as &ldquo;&lt;~0.01&rdquo;. The table is
created as the matrix <code>wsqTable</code> when the package
<code>GeneralizedHyperbolic</code> is invoked.
</p>
<p><code>print.hyperbCvMTest</code> prints the output
from the
Cramér-von~Mises goodness-of-fit test for
the hyperbolic distribution in very similar format to that provided by
<code>print.htest</code>. The only reason for having a special print method
is that p-values can be given as less than some value or greater than
some value, such as &ldquo;&lt;\ ~0.01&rdquo;, or &ldquo;&gt;\ ~0.25&rdquo;.
</p>


<h3>Value</h3>

<p><code>hyperbCvMTest</code> returns a list with class <code>hyperbCvMTest</code>
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>The value of the test statistic.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string with the value
&ldquo;Cramér-von~Mises test of hyperbolic
distribution&rdquo;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The value of the parameter param</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
<tr><td><code>warn</code></td>
<td>
<p>A warning if the parameter values are outside the limits
of the table given in Puig &amp; Stephens (2001).</p>
</td></tr>
</table>
<p><code>hyperbCvMTestPValue</code> returns a list with the elements
<code>p.value</code> and <code>warn</code> only.
</p>


<h3>Author(s)</h3>

<p>David Scott, Thomas Tran</p>


<h3>References</h3>

<p>Puig, Pedro and Stephens, Michael A. (2001),
Goodness-of-fit tests for the hyperbolic distribution.
<em>The Canadian Journal of Statistics/La Revue Canadienne de
Statistique</em>, <b>29</b>, 309&ndash;320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1.5)
dataVector &lt;- rhyperb(500, param = param)
fittedparam &lt;- hyperbFit(dataVector)$param
hyperbCvMTest(dataVector, param = fittedparam)
dataVector &lt;- rnorm(1000)
fittedparam &lt;- hyperbFit(dataVector, startValues = "FN")$param
hyperbCvMTest(dataVector, param = fittedparam)
</code></pre>

<hr>
<h2 id='hyperbFit'>Fit the Hyperbolic Distribution to Data</h2><span id='topic+hyperbFit'></span><span id='topic+print.hyperbFit'></span><span id='topic+plot.hyperbFit'></span><span id='topic+coef.hyperbFit'></span><span id='topic+vcov.hyperbFit'></span>

<h3>Description</h3>

<p>Fits a hyperbolic distribution to data.
Displays the histogram, log-histogram (both with fitted densities),
Q-Q plot and P-P plot for the fit which has the maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  hyperbFit(x, freq = NULL, paramStart = NULL,
            startMethod = c("Nelder-Mead","BFGS"),
            startValues = c("BN","US","FN","SL","MoM"),
            criterion = "MLE",
            method = c("Nelder-Mead","BFGS","nlm",
                       "L-BFGS-B","nlminb","constrOptim"),
            plots = FALSE, printOut = FALSE,
            controlBFGS = list(maxit = 200),
            controlNM = list(maxit = 1000), maxitNLM = 1500,
            controlLBFGSB = list(maxit = 200),
            controlNLMINB = list(),
            controlCO = list(), ...)

  ## S3 method for class 'hyperbFit'
print(x,
        digits = max(3, getOption("digits") - 3), ...)

  ## S3 method for class 'hyperbFit'
plot(x, which = 1:4,
     plotTitles = paste(c("Histogram of ","Log-Histogram of ",
                        "Q-Q Plot of ","P-P Plot of "), x$obsName,
                        sep = ""),
     ask = prod(par("mfcol")) &lt; length(which) &amp; dev.interactive(), ...)

  ## S3 method for class 'hyperbFit'
coef(object, ...)

  ## S3 method for class 'hyperbFit'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbFit_+3A_x">x</code></td>
<td>
<p>Data vector for <code>hyperbFit</code>. Object of class
<code>"hyperbFit"</code> for <code>print.hyperbFit</code> and <code>plot.hyperbFit</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_freq">freq</code></td>
<td>
<p>A vector of weights with length equal to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_paramstart">paramStart</code></td>
<td>
<p>A user specified starting parameter vector
<code>param</code> taking the form <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_startmethod">startMethod</code></td>
<td>
<p>Method used by <code>hyperbFitStart</code> in calls to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_startvalues">startValues</code></td>
<td>
<p>Code giving the method of determining starting
values for finding the maximum likelihood estimate of <code>param</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_criterion">criterion</code></td>
<td>
<p>Currently only <code>"MLE"</code> is implemented.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_method">method</code></td>
<td>
<p>Different optimisation methods to consider.
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_plots">plots</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of the
histogram, log-histogram, Q-Q plot and P-P plot.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_printout">printOut</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of
results of fitting.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_controlbfgs">controlBFGS</code></td>
<td>
<p>A list of control parameters for <code>optim</code> when using
the <code>"BFGS"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_controlnm">controlNM</code></td>
<td>
<p>A list of control parameters for <code>optim</code>
when using the <code>"Nelder-Mead"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_maxitnlm">maxitNLM</code></td>
<td>
<p>A positive integer specifying the maximum number of
iterations when using the <code>"nlm"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_controllbfgsb">controlLBFGSB</code></td>
<td>
<p>A list of control parameters for <code>optim</code> when using
the <code>"L-BFGS-B"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_controlnlminb">controlNLMINB</code></td>
<td>
<p>A list of control parameters for <code>nlminb</code>
when using the <code>"nlminb"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_controlco">controlCO</code></td>
<td>
<p>A list of control parameters for <code>constrOptim</code>
when using the <code>"constrOptim"</code> optimisation.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_digits">digits</code></td>
<td>
<p>Desired number of digits when the object is printed.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of
the numbers <code>1:4</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_plottitles">plotTitles</code></td>
<td>
<p>Titles to appear above the plots.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, see <code><a href="graphics.html#topic+par">par</a>(ask = .)</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>par</code>, <code>hist</code>,
<code>logHist</code>, <code>qqhyperb</code> and <code>pphyperb</code>.</p>
</td></tr>
<tr><td><code id="hyperbFit_+3A_object">object</code></td>
<td>
<p>Object of class <code>"hyperbFit"</code> for <code>coef.hyperbFit</code>
and for <code>vcov.hyperbFit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>startMethod</code> can be either <code>"BFGS"</code> or
<code>"Nelder-Mead"</code>.
</p>
<p><code>startValues</code> can be one of the following:
</p>

<dl>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
<dt><code>"BN"</code></dt><dd><p>Based on Barndorff-Nielsen (1977).</p>
</dd>
<dt><code>"FN"</code></dt><dd><p>A fitted normal distribution.</p>
</dd>
<dt><code>"SL"</code></dt><dd><p>Based on a fitted skew-Laplace distribution.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
</dl>

<p>For the details concerning the use of <code>paramStart</code>,
<code>startMethod</code>, and <code>startValues</code>, see
<code><a href="#topic+hyperbFitStart">hyperbFitStart</a></code>.
</p>
<p>The six optimisation methods currently available are:
</p>

<dl>
<dt><code>"BFGS"</code></dt><dd><p>Uses the quasi-Newton method <code>"BFGS"</code> as
documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"Nelder-Mead"</code></dt><dd><p>Uses an implementation of the Nelder and
Mead method as documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"nlm"</code></dt><dd><p>Uses the <code><a href="stats.html#topic+nlm">nlm</a></code> function in R.</p>
</dd>
<dt><code>"L-BFGS-B"</code></dt><dd><p>Uses the quasi-Newton method with box
constraints <code>"L-BFGS-B"</code> as documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"nlminb"</code></dt><dd><p>Uses the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function in R.</p>
</dd>
<dt><code>"constrOptim"</code></dt><dd><p>Uses the <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
function in R.</p>
</dd>
</dl>

<p>For details of how to pass control information for optimisation using
<code>optim</code>, <code>nlm</code>, <code>nlminb</code> and <code>constrOptim</code>, see
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code> and
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.
</p>
<p>When <code>method = "nlm"</code> is used, warnings may be produced. These do
not appear to be a problem.
</p>


<h3>Value</h3>

<p><code>hyperbFit</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>A vector giving the maximum likelihood estimate of
param, as <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code>maxLik</code></td>
<td>
<p>The value of the maximised log-likelihood.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Optimisation method used.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>Convergence code. See the relevant documentation (either
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlm">nlm</a></code>) for details on
convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations of optimisation routine.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>The data used to fit the hyperbolic distribution.</p>
</td></tr>
<tr><td><code>obsName</code></td>
<td>
<p>A character string with the actual <code>x</code> argument
name.</p>
</td></tr>
<tr><td><code>paramStart</code></td>
<td>
<p>Starting value of param returned by call to
<code><a href="#topic+hyperbFitStart">hyperbFitStart</a></code>.</p>
</td></tr>
<tr><td><code>svName</code></td>
<td>
<p>Descriptive name for the method finding start values.</p>
</td></tr>
<tr><td><code>startValues</code></td>
<td>
<p>Acronym for the method of finding start values.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Ai-Wei Lee, Jennifer Tso, Richard Trendall, Thomas Tran,
Christine Yang Dong
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em> A<b>353</b>, 401&ndash;419.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em> <b>41</b>, 127&ndash;146.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="DistributionUtils.html#topic+logHist">logHist</a></code> (pkg <a href="https://CRAN.R-project.org/package=DistributionUtils"><span class="pkg">DistributionUtils</span></a>),
<code><a href="#topic+qqhyperb">qqhyperb</a></code>, <code><a href="#topic+pphyperb">pphyperb</a></code>, <code><a href="#topic+dskewlap">dskewlap</a></code>
and <code><a href="#topic+hyperbFitStart">hyperbFitStart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rhyperb(500, param = param)
## See how well hyperbFit works
hyperbFit(dataVector)
hyperbFit(dataVector, plots = TRUE)
fit &lt;- hyperbFit(dataVector)
par(mfrow = c(1, 2))
plot(fit, which = c(1, 3))

## Use nlm instead of default
hyperbFit(dataVector, method = "nlm")

</code></pre>

<hr>
<h2 id='hyperbFitStart'>Find Starting Values for Fitting a Hyperbolic Distribution</h2><span id='topic+hyperbFitStart'></span><span id='topic+hyperbFitStartMoM'></span>

<h3>Description</h3>

<p>Finds starting values for input to a maximum likelihood routine for
fitting hyperbolic distribution to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  hyperbFitStart(x, startValues = c("BN","US","FN","SL","MoM"),
                 paramStart = NULL,
                 startMethodSL = c("Nelder-Mead","BFGS"),
                 startMethodMoM = c("Nelder-Mead","BFGS"), ...)
  hyperbFitStartMoM(x, startMethodMoM = "Nelder-Mead", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbFitStart_+3A_x">x</code></td>
<td>
<p>Data vector.</p>
</td></tr>
<tr><td><code id="hyperbFitStart_+3A_startvalues">startValues</code></td>
<td>
<p>Vector of the different starting values to consider.
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperbFitStart_+3A_paramstart">paramStart</code></td>
<td>
<p>Starting values for param if <code>startValues =
      "US"</code>.</p>
</td></tr>
<tr><td><code id="hyperbFitStart_+3A_startmethodsl">startMethodSL</code></td>
<td>
<p>Method used by call to <code><a href="stats.html#topic+optim">optim</a></code> in
finding skew Laplace estimates.</p>
</td></tr>
<tr><td><code id="hyperbFitStart_+3A_startmethodmom">startMethodMoM</code></td>
<td>
<p>Method used by call to <code><a href="stats.html#topic+optim">optim</a></code> in
finding method of moments estimates.</p>
</td></tr>
<tr><td><code id="hyperbFitStart_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="graphics.html#topic+hist">hist</a></code> and
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the argument <code>startValues</code> are the following:
</p>

<dl>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
<dt><code>"BN"</code></dt><dd><p>Based on Barndorff-Nielsen (1977).</p>
</dd>
<dt><code>"FN"</code></dt><dd><p>A fitted normal distribution.</p>
</dd>
<dt><code>"SL"</code></dt><dd><p>Based on a fitted skew-Laplace distribution.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
</dl>

<p>If <code>startValues = "US"</code> then a value must be supplied for
<code>paramStart</code>.
</p>
<p>If <code>startValues = "MoM"</code>, <code>hyperbFitStartMoM</code> is
called. These starting values are based on Barndorff-Nielsen <em>et
al</em> (1985).
</p>
<p>If <code>startValues = "SL"</code>, or <code>startValues = "MoM"</code> an initial
optimisation is needed to find the starting values. These
optimisations call <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p><code>hyperbFitStart</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>paramStart</code></td>
<td>
<p>A vector with elements <code>mu</code>, <code>delta</code>,
<code>alpha</code> and <code>beta</code> giving the
starting value of param.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>
<p><code>hyperbFitStartMoM</code> returns only the method of moments estimates
as a vector with elements <code>mu</code>, <code>delta</code>, <code>alpha</code> and
<code>beta</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Ai-Wei Lee, Jennifer Tso, Richard Trendall, Thomas Tran</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Barndorff-Nielsen, O., Blæsild, P., Jensen, J.,
and  Sörenson, M. (1985).
The fascination of sand.
In <em>A celebration of statistics, The ISI Centenary Volume</em>,
eds., Atkinson, A. C. and Fienberg, S. E.,
pp. 57&ndash;87. New York: Springer-Verlag.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code>, <code><a href="#topic+dskewlap">dskewlap</a></code>,
<code><a href="#topic+hyperbFit">hyperbFit</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, and
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rhyperb(500, param = param)
hyperbFitStart(dataVector, startValues = "FN")
hyperbFitStartMoM(dataVector)
hyperbFitStart(dataVector, startValues = "MoM")
</code></pre>

<hr>
<h2 id='hyperbHessian'>
Calculate Two-Sided Hessian for the Hyperbolic Distribution
</h2><span id='topic+hyperbHessian'></span><span id='topic+sumX'></span>

<h3>Description</h3>

<p>Calculates the Hessian of a function, either exactly or approximately. Used to
obtain the information matrix for maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbHessian(x, param, hessianMethod = "exact",
              whichParam = 1:5)
sumX(x, mu, delta, r, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperbHessian_+3A_x">x</code></td>
<td>
<p>Data vector.</p>
</td></tr>
<tr><td><code id="hyperbHessian_+3A_param">param</code></td>
<td>
<p>The maximum likelihood estimates parameter vector of the
hyperbolic distribution. There are five different sets of
parameterazations can be used in this function, the first four sets
are listed in <code>hyperbChangePars</code> and the last set is the log
scale of the first set of the parameterization, i.e.,
<code>mu,log(delta),Pi,log(zeta)</code>.  </p>
</td></tr>
<tr><td><code id="hyperbHessian_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>Two methods are available to calculate the
Hessian exactly ( <code>"exact"</code>) or approximately
(<code>"tsHessian")</code>.  </p>
</td></tr>   
<tr><td><code id="hyperbHessian_+3A_whichparam">whichParam</code></td>
<td>
<p>Numeric. A number between 1 to 5 indicating which
set of the parameterization is the specified value in argument
<code>param</code> belong to.</p>
</td></tr> 
<tr><td><code id="hyperbHessian_+3A_mu">mu</code></td>
<td>
<p>Value of the parameter <code class="reqn">\mu</code> of the
hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="hyperbHessian_+3A_delta">delta</code></td>
<td>
<p>Value of the parameter <code class="reqn">\delta</code> of the
hyperbolic distribution.</p>
</td></tr> 
<tr><td><code id="hyperbHessian_+3A_r">r</code></td>
<td>
<p>Parameter used in calculating a cumulative sum of the data
vector x.</p>
</td></tr> 
<tr><td><code id="hyperbHessian_+3A_k">k</code></td>
<td>
<p>Parameter used in calculating a cumulative sum of the data
vector x.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>The formulae for the exact Hessian are derived by <code>Maple</code>
software with some simplifications. For now, the exact Hessian can
only be obtained based on the first, second or the last
parameterization sets.  The approximate Hessian is obtained via a
call to <code>tsHessian</code> from the package <code>DistributionUtils</code>.
<code>summary.hyperbFit</code> calls the function <code>hyperbHessian</code> to
calculate the Hessian matrix when the argument <code>hessian =
    TRUE</code>.   
</p>


<h3>Value</h3>

<p><code>hyperbHessian</code> gives the approximate or exact Hessian matrix for
the data vector <code>x</code> and the estimated parameter vector
<code>param</code>.  <code>sumX</code> is a sum term used in calculating the exact
Hessian. It is called by <code>hyperbHessian</code> when the argument
<code>hessianMethod = "exact"</code>.  It is not expected to be called
directly by users.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Calculate the exact Hessian using hyperbHessian:
param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rhyperb(500, param = param)
fit &lt;- hyperbFit(dataVector, method = "BFGS")
coef &lt;- coef(fit)
hyperbHessian(x = dataVector, param = coef, hessianMethod = "exact",
              whichParam = 2)
              
### Or calculate the exact Hessian using summary.hyperbFit method:
summary(fit, hessian = TRUE)


## Calculate the approximate Hessian:
summary(fit, hessian = TRUE, hessianMethod = "tsHessian")
</code></pre>

<hr>
<h2 id='hyperblm'>Fitting Linear Models with Hyperbolic Errors</h2><span id='topic+hyperblm'></span><span id='topic+print.hyperblm'></span><span id='topic+coef.hyperblm'></span><span id='topic+plot.hyperblm'></span>

<h3>Description</h3>

<p>Fits linear models with hyperbolic errors. Can be used to carry out
linear regression for data exhibiting heavy tails and skewness.
Displays the histogram, log-histogram (both with fitted error
distribution), Q-Q plot and residuals vs. fitted values plot for the
fitted linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperblm(formula, data, subset, weights, na.action,
         xx = FALSE, y = FALSE, contrasts = NULL,
         offset, method = "Nelder-Mead",
         startMethod = "Nelder-Mead", startStarts = "BN",
         paramStart = NULL,
         maxiter = 100, tolerance = 0.0001,
         controlBFGS = list(maxit = 1000),
         controlNM = list(maxit = 10000),
         maxitNLM = 10000,
         controlCO = list(), silent = TRUE, ...)

## S3 method for class 'hyperblm'
print(x, digits = max(3, getOption("digits")-3), ...)

## S3 method for class 'hyperblm'
coef(object, ...)

## S3 method for class 'hyperblm'
plot(x, breaks = "FD",
                        plotTitles = c("Residuals vs Fitted Values",
                                       "Histogram of residuals",
                                       "Log-Histogram of residuals",
                                       "Q-Q Plot"),
                        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyperblm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.
If non-NULL, weighted least squares is used with weights
<code>weights</code> (that is, minimizing <code>sum(w*e^2)</code>); otherwise
ordinary least squares is used.  See also &lsquo;Details&rsquo;,</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_xx">xx</code>, <code id="hyperblm_+3A_y">y</code></td>
<td>
<p>Logicals. If <code>TRUE</code>, the corresponding components of the
fit (the explanatory matrix and the response vector) are returned.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_offset">offset</code></td>
<td>
<p>An optional vector. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_method">method</code></td>
<td>
<p>Character. Possible values are <code>"BFGS"</code>,
<code>"Nelder-Mead"</code> and <code>"nlm"</code>. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_startmethod">startMethod</code></td>
<td>
<p>Character. Possible values are <code>"BFGS"</code> and
<code>"Nelder-Mead"</code>. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_startstarts">startStarts</code></td>
<td>
<p>Character. Possible values are <code>"BN"</code>,
<code>"FN"</code>, <code>"SL"</code>, <code>"US"</code> and <code>"MoM"</code>. See
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_paramstart">paramStart</code></td>
<td>
<p>An optional vector. A vector of parameter
start values for the optimization routine. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_maxiter">maxiter</code></td>
<td>
<p>Numeric. The maximum number of two-stage optimization
alternating iterations. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric. The two-stage optimization convergence
ratio. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_controlbfgs">controlBFGS</code>, <code id="hyperblm_+3A_controlnm">controlNM</code></td>
<td>
<p>Lists. Lists of control parameters for
<code>optim</code> when using corresponding (BFGS, Nelder-Mead) optimisation
method in first stage. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_maxitnlm">maxitNLM</code></td>
<td>
<p>Numeric. The maximum number of iterations for the NLM
optimizer.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_controlco">controlCO</code></td>
<td>
<p>List. A list of control parameters for
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code> in second stage.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the error messgae of optimizer will
not be displayed.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"hyperblm"</code>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_object">object</code></td>
<td>
<p>An object of class <code>"hyperblm"</code>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_breaks">breaks</code></td>
<td>
<p>May be a vector, a single number or a character
string. See <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_plottitles">plotTitles</code></td>
<td>
<p>Titles to appear above the plots.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_digits">digits</code></td>
<td>
<p>Numeric. Desired number of digits when the object is
printed.</p>
</td></tr>
<tr><td><code id="hyperblm_+3A_...">...</code></td>
<td>
<p>Passes additional arguments to function
<code><a href="#topic+hyperbFitStand">hyperbFitStand</a></code>, <code><a href="stats.html#topic+optim">optim</a></code> and
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>hyperblm</code> are specified symbolically.  A typical
model has the form <code>response ~ terms</code> where <code>response</code> is
the (numeric) response vector and <code>terms</code> is a series of terms
which specifies a linear predictor for <code>response</code>.  A terms
specification of the form <code>first + second</code> indicates all the
terms in <code>first</code> together with all the terms in <code>second</code>
with duplicates removed.  A specification of the form
<code>first:second</code> indicates the set of terms obtained by taking the
interactions of all terms in <code>first</code> with all terms in
<code>second</code>.  The specification <code>first*second</code> indicates the
<em>cross</em> of <code>first</code> and <code>second</code>.  This is the same as
<code>first + second + first:second</code>.
</p>
<p>If the formula includes an <code><a href="stats.html#topic+offset">offset</a></code>, this is evaluated and
subtracted from the response.
</p>
<p>If <code>response</code> is a matrix a linear model is fitted separately by
least-squares to each column of the matrix.
</p>
<p>See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for some further details.  The terms in
the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so
on.
</p>
<p>A formula has an implied intercept term.  To remove this use either
<code>y ~ x - 1</code> or <code>y ~ 0 + x</code>.  See <code><a href="stats.html#topic+formula">formula</a></code> for
more details of allowed formulae.
</p>
<p>Non-<code>NULL</code> <code>weights</code> can be used to indicate that different
observations have different variances (with the values in
<code>weights</code> being inversely proportional to the variances); or
equivalently, when the elements of <code>weights</code> are positive
integers <code class="reqn">w_i</code>, that each response <code class="reqn">y_i</code> is the mean of
<code class="reqn">w_i</code> unit-weight observations (including the case that there are
<code class="reqn">w_i</code> observations equal to <code class="reqn">y_i</code> and the data have been
summarized).
</p>
<p><code>hyperblm</code> calls the lower level function
<code><a href="#topic+hyperblmFit">hyperblmFit</a></code> for the actual numerical computations.
</p>
<p>All of <code>weights</code>, <code>subset</code> and <code>offset</code> are evaluated
in the same way as variables in <code>formula</code>, that is first in
<code>data</code> and then in the environment of <code>formula</code>.
</p>
<p><code>hyperblmFit</code> uses a two-stage alternating optimization
routine. The quality of parameter start values (especially the error
distribution parameters) is crucial to the routine's convergence. The
user can specify the start values via the <code>paramStart</code> argument,
otherwise the function finds reliable start values by calling the
<code><a href="#topic+hyperbFitStand">hyperbFitStand</a></code> function.
</p>
<p><code>startMethod</code> in the argument list is the optimization method for
function <code><a href="#topic+hyperbFitStandStart">hyperbFitStandStart</a></code> which finds the start
values for function <code><a href="#topic+hyperbFitStand">hyperbFitStand</a></code>. It is set to
<code>"Nelder-Mead"</code> by default due to the robustness of this
optimizer. The <code>"BFGS"</code> method is also implemented as it is
relatively fast to converge. Since <code>"BFGS"</code> method is a
quasi-Newton method it will not as robust and for some data will not
achieve convergence.
</p>
<p><code>startStarts</code> is the method used to find the start values for function
<code>hyperbFitStandStart</code> which includes:
</p>

<dl>
<dt><code>"BN"</code></dt><dd><p>A method from Barndorff-Nielsen (1977) based on
estimates of <code class="reqn">\psi</code> and <code class="reqn">\gamma</code> the absolute
slopes of the left and right asymptotes to the log density function</p>
</dd>
<dt><code>"FN"</code></dt><dd><p>Based on a fitted normal distribution as it is a
limit of the hyperbolic distribution</p>
</dd>
<dt><code>"SL"</code></dt><dd><p>Based on a fitted skew-Laplace distribution for
which the log density has the form of two straight line with
absolute slopes <code class="reqn">1/\alpha</code>, <code class="reqn">1/\beta</code></p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>A method of moment approach</p>
</dd>
<dt><code>"US"</code></dt><dd><p>User specified</p>
</dd>
</dl>

<p><code>method</code> is the method used in stage one of the two-stage
alternating optimization routine. As the <code>startMethod</code>, it is set
to <code>"Nelder-Mead"</code> by default. Besides <code>"BFGS"</code>,<code>"nlm"</code>
is also implemented as a alternative. Since <code>BFGS</code> method is a
quasi-Newton method it will not as robust and for some data will not
achieve convergence.
</p>
<p>If the maximum of the ratio the change of the individual coefficients
is smaller than <code>tolerance</code> then the routine assumes convergence,
otherwise if the alternating iteration number exceeds <code>maxiter</code>
with the maximum of the ratio the change of the individual
coefficients larger than <code>tolerance</code>, the routine is considered
not to have converged.
</p>


<h3>Value</h3>

<p><code>hyperblm</code> returns an object of class <code>"hyperblm"</code> which is a list
containing:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector of regression coefficients.</p>
</td></tr>
<tr><td><code>distributionParams</code></td>
<td>
<p>A named vector of fitted hyperbolic error
distribution parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The remainder after subtracting fitted values from
response.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>The maximum likelihood value of the model.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The optimization method for stage one.</p>
</td></tr>
<tr><td><code>paramStart</code></td>
<td>
<p>The start values of parameters that the user
specified (only where relevant).</p>
</td></tr>
<tr><td><code>residsParamStart</code></td>
<td>
<p>The start values of parameters obtained by
<code>hyperbFitStand</code> (only where relevant).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The <code>terms</code> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>The contrasts used (only where relevant).</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>The levels of the factors used in the fitting (only where
relevant).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>The offset used (only where relevant)</p>
</td></tr>
<tr><td><code>xNames</code></td>
<td>
<p>The names of each explanatory variables. If explanatory
variables don't have names then they will be named <code>x</code>.</p>
</td></tr>
<tr><td><code>yVec</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code>xMatrix</code></td>
<td>
<p>The explanatory variables matrix.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of two-stage alternating iterations to
convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>The convergence code for two stage optimization: 0
is the system converged, 1 is first stage does not converge, 2 is
second stage does not converge, 3 is the both stages do not
converge.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call the
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Xinxing Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Prause, K. (1999). <em>The generalized hyperbolic models:
Estimation, financial derivatives and risk measurement</em>.
PhD Thesis, Mathematics Faculty, University of Freiburg.
</p>
<p>Trendall, Richard (2005). <em>hypReg: A Function for Fitting a Linear
Regression Model in R with Hyperbolic Error</em>.
Masters Thesis, Statistics Faculty, University of Auckland.
</p>
<p>Paolella, Marc S. (2007). <em>Intermediate Probability: A Computational
Approach</em>. pp. 415 -Chichester: Wiley.
</p>
<p>Scott, David J. and Würtz, Diethelm and Chalabi, Yohan, (2011).
<em>Fitting the Hyperbolic Distribution with R: A Case Study of
Optimization Techniques</em>. In preparation.
</p>
<p>Stryhn, H. and Christensen, J. (2003). <em>Confidence intervals by
the profile likelihood method, with applications in veterinary
epidemiology</em>.
ISVEE X.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.hyperblm">print.hyperblm</a></code> prints the regression result in a table.
<code><a href="#topic+coef.hyperblm">coef.hyperblm</a></code> obtains the regression coefficients and
error distribution parameters of the fitted model.
<code><a href="#topic+summary.hyperblm">summary.hyperblm</a></code> obtains a summary output of class
<code>hyperblm</code> object.
<code><a href="#topic+print.summary.hyperblm">print.summary.hyperblm</a></code> prints the summary output in a
table.
<code><a href="#topic+plot.hyperblm">plot.hyperblm</a></code> obtains a residual vs fitted value plot, a
histgram of residuals with error distribution density curve on top, a
histgram of log residuals with error distribution error density curve
on top and a QQ plot.
<code><a href="#topic+hyperblmFit">hyperblmFit</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>,
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="#topic+hyperbFitStand">hyperbFitStand</a></code>, <code><a href="#topic+hyperbFitStandStart">hyperbFitStandStart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### stackloss data example
## Not run: 
 airflow &lt;- stackloss[, 1]
 temperature &lt;- stackloss[, 2]
 acid &lt;- stackloss[, 3]
 stack &lt;- stackloss[, 4]

 hyperblm.fit &lt;- hyperblm(stack ~ airflow + temperature + acid)

 coef.hyperblm(hyperblm.fit)
 plot.hyperblm(hyperblm.fit, breaks = 20)
 summary.hyperblm(hyperblm.fit, hessian = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Hyperbolic'>Hyperbolic Distribution</h2><span id='topic+dhyperb'></span><span id='topic+phyperb'></span><span id='topic+qhyperb'></span><span id='topic+rhyperb'></span><span id='topic+ddhyperb'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and
random number generation for the hyperbolic distribution
with parameter vector <code>param</code>. Utility routines are included for
the derivative of the density function and to find suitable break
points for use in determining the distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhyperb(x, mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
phyperb(q, mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta),
        lower.tail = TRUE, subdivisions = 100,
        intTol = .Machine$double.eps^0.25,
        valueOnly = TRUE, ...)
qhyperb(p, mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta),
        lower.tail = TRUE, method = c("spline", "integrate"),
        nInterpol = 501, uniTol = .Machine$double.eps^0.25,
        subdivisions = 100, intTol = uniTol, ...)
rhyperb(n, mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
ddhyperb(x, mu = 0, delta = 1, alpha = 1, beta = 0,
         param = c(mu, delta, alpha, beta))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hyperbolic_+3A_x">x</code>, <code id="Hyperbolic_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_n">n</code></td>
<td>
<p>Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_param">param</code></td>
<td>
<p>Parameter vector taking the form
<code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>lower.tail = TRUE</code>, the cumulative
density is taken from the lower tail.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subdivisions used to
integrate the density and determine the accuracy of the distribution
function calculation.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_inttol">intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in
calls to <code>integrate</code>. See <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_valueonly">valueOnly</code></td>
<td>
<p>Logical. If <code>valueOnly = TRUE</code> calls to
<code>pghyp</code> only return the value obtained for the integral.
If <code>valueOnly = FALSE</code> an estimate of the
accuracy of the numerical integration is also returned.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_ninterpol">nInterpol</code></td>
<td>
<p>Number of points used in <code>qghyp</code> for cubic
spline interpolation of the distribution function.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in
calls to <code>uniroot</code>. See <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="Hyperbolic_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>uniroot</code>. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyperbolic distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{1}{2\delta\sqrt{1+\pi^2}K_1(\zeta)} %
    e^{-\zeta[\sqrt{1+\pi^2}\sqrt{1+(\frac{x-\mu}{\delta})^2}-%
    \pi\frac{x-\mu}{\delta}]}</code>
</p>

<p>where <code class="reqn">K_1()</code> is the modified Bessel function of the
third kind with order 1.
</p>
<p>A succinct description of the hyperbolic distribution is given in
Barndorff-Nielsen and Blæsild (1983). Three different
possible parameterizations are described in that paper. A fourth
parameterization is given in Prause (1999). All use location and scale
parameters <code class="reqn">\mu</code> and <code class="reqn">\delta</code>. There are two other
parameters in each case.
</p>
<p>Use <code>hyperbChangePars</code> to convert from the
<code class="reqn">(\pi, \zeta)</code> <code class="reqn">(\phi, \gamma)</code> or
<code class="reqn">(\xi, \chi)</code> parameterizations to the
<code class="reqn">(\alpha, \beta)</code> parameterization used above.
</p>
<p>Each of the functions are wrapper functions for their equivalent
generalized hyperbolic counterpart. For example, <code>dhyperb</code> calls
<code>dghyp</code>. See <code><a href="#topic+dghyp">dghyp</a></code>.
</p>
<p>The hyperbolic distribution is a special case of the generalized
hyperbolic distribution (Barndorff-Nielsen and Bæsild
(1983)). The generalized hyperbolic distribution can be represented as
a particular mixture of the normal distribution where the mixing
distribution is the generalized inverse Gaussian.  <code>rhyperb</code> uses
this representation to generate observations from the hyperbolic
distribution. Generalized inverse Gaussian observations are obtained
via the algorithm of Dagpunar (1989).</p>


<h3>Value</h3>

<p><code>dhyperb</code> gives the density, <code>phyperb</code> gives the distribution
function, <code>qhyperb</code> gives the quantile function and <code>rhyperb</code>
generates random variates. An estimate of the accuracy of the
approximation to the distribution function may be found by setting
<code>accuracy = TRUE</code> in the call to <code>phyperb</code> which then returns
a list with components <code>value</code> and <code>error</code>.
</p>
<p><code>ddhyperb</code> gives the derivative of <code>dhyperb</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Ai-Wei Lee, Jennifer Tso, Richard Trendall</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Dagpunar, J.S. (1989).
An easily implemented generalized inverse Gaussian generator
<em>Commun. Statist. -Simula.</em>,
<b>18</b>, 703&ndash;710.
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="DistributionUtils.html#topic+safeIntegrate">safeIntegrate</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code> for its shortfalls, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code> and <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code> for changing
parameters to the <code class="reqn">(\alpha,\beta)</code>
parameterization, <code><a href="#topic+dghyp">dghyp</a></code> for the generalized hyperbolic
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(0, 2, 1, 0)
hyperbRange &lt;- hyperbCalcRange(param = param, tol = 10^(-3))
par(mfrow = c(1, 2))
curve(dhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
      n = 1000)
title("Density of the\n Hyperbolic Distribution")
curve(phyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
      n = 1000)
title("Distribution Function of the\n Hyperbolic Distribution")
dataVector &lt;- rhyperb(500, param = param)
curve(dhyperb(x, param = param), range(dataVector)[1], range(dataVector)[2],
      n = 500)
hist(dataVector, freq = FALSE, add =TRUE)
title("Density and Histogram\n of the Hyperbolic Distribution")
DistributionUtils::logHist(dataVector, main =
        "Log-Density and Log-Histogram\n of the Hyperbolic Distribution")
curve(log(dhyperb(x, param = param)), add = TRUE,
      range(dataVector)[1], range(dataVector)[2], n = 500)
par(mfrow = c(2, 1))
curve(dhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
      n = 1000)
title("Density of the\n Hyperbolic Distribution")
curve(ddhyperb(x, param = param), from = hyperbRange[1], to = hyperbRange[2],
      n = 1000)
title("Derivative of the Density\n of the Hyperbolic Distribution")
</code></pre>

<hr>
<h2 id='hyperbParam'>Parameter Sets for the Hyperbolic Distribution</h2><span id='topic+hyperbParam'></span><span id='topic+hyperbSmallShape'></span><span id='topic+hyperbLargeShape'></span><span id='topic+hyperbSmallParam'></span><span id='topic+hyperbLargeParam'></span>

<h3>Description</h3>

<p>These objects store different parameter sets of the hyperbolic
distribution as matrices for testing or demonstration purposes.
</p>
<p>The parameter sets <code>hyperbSmallShape</code> and
<code>hyperbLargeShape</code> have a constant location parameter of
<code class="reqn">\mu</code> = 0, and constant scale parameter <code class="reqn">\delta</code> =
1. In <code>hyperbSmallParam</code> and <code>hyperbLargeParam</code> the values of
the location and scale parameters vary. In these parameter sets the
location parameter <code class="reqn">\mu</code> = 0 takes values from {0, 1} and
{-1, 0, 1, 2}  respectively. For the scale parameter
<code class="reqn">\delta</code>, values are drawn from {1, 5} and {1, 2, 5,
10} respectively.
</p>
<p>For the shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> the
approach is more complex. The values for these shape parameters were
chosen by choosing values of <code class="reqn">\xi</code> and <code class="reqn">\chi</code> which
range over the shape triangle, then the function
<code>hyperbChangePars</code> was applied to convert them to the
<code class="reqn">\alpha, \beta</code> parameterization. The resulting
<code class="reqn">\alpha, \beta</code> values were then rounded to three
decimal places. See the examples for the values of <code class="reqn">\xi</code> and
<code class="reqn">\chi</code> for the large parameter sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  hyperbSmallShape
  hyperbLargeShape
  hyperbSmallParam
  hyperbLargeParam
</code></pre>


<h3>Format</h3>

<p><code>hyperbSmallShape</code>: a 7 by 4 matrix;
<code>hyperbLargeShape</code>: a 15 by 4 matrix;
<code>hyperbSmallParam</code>: a 28 by 4 matrix;
<code>hyperbLargeParam</code>: a 240 by 4 matrix.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hyperbParam)
plotShapeTriangle()
xis &lt;- rep(c(0.1,0.3,0.5,0.7,0.9), 1:5)
chis &lt;- c(0,-0.25,0.25,-0.45,0,0.45,-0.65,-0.3,0.3,0.65,
          -0.85,-0.4,0,0.4,0.85)
points(chis, xis, pch = 20, col = "red")


## Testing the accuracy of hyperbMean
for (i in 1:nrow(hyperbSmallParam)) {
  param &lt;- hyperbSmallParam[i, ]
  x &lt;- rhyperb(1000, param = param)
  sampleMean &lt;- mean(x)
  funMean &lt;- hyperbMean(param = param)
  difference &lt;- abs(sampleMean - funMean)
  print(difference)
}

</code></pre>

<hr>
<h2 id='HyperbPlots'>Hyperbolic Quantile-Quantile and Percent-Percent Plots</h2><span id='topic+qqhyperb'></span><span id='topic+pphyperb'></span>

<h3>Description</h3>

<p><code>qqhyperb</code> produces a hyperbolic Q-Q plot of the values in
<code>y</code>.
</p>
<p><code>pphyperb</code> produces a hyperbolic P-P (percent-percent) or
probability plot of the values in <code>y</code>.	
</p>
<p>Graphical parameters may be given as arguments to <code>qqhyperb</code>,
and <code>pphyperb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqhyperb(y, mu = 0, delta = 1, alpha = 1, beta = 0,
         param = c(mu, delta, alpha, beta),
         main = "Hyperbolic Q-Q Plot",
         xlab = "Theoretical Quantiles",
         ylab = "Sample Quantiles",
         plot.it = TRUE, line = TRUE, ...)

pphyperb(y, mu = 0, delta = 1, alpha = 1, beta = 0,
         param = c(mu, delta, alpha, beta),
         main = "Hyperbolic P-P Plot",
         xlab = "Uniform Quantiles",
         ylab = "Probability-integral-transformed Data",
         plot.it = TRUE, line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HyperbPlots_+3A_y">y</code></td>
<td>
<p>The data sample.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_param">param</code></td>
<td>
<p>Parameters of the hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_xlab">xlab</code>, <code id="HyperbPlots_+3A_ylab">ylab</code>, <code id="HyperbPlots_+3A_main">main</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical. Should the result be plotted?</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_line">line</code></td>
<td>
<p>Add line through origin with unit slope.</p>
</td></tr>
<tr><td><code id="HyperbPlots_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qqhyperb</code> and <code>pphyperb</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that are to be plotted.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates of the points that are to be plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilk, M. B. and Gnanadesikan, R. (1968)
Probability plotting methods for the analysis of data.
<em>Biometrika</em>.
<b>55</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ppoints">ppoints</a></code>, <code><a href="#topic+dhyperb">dhyperb</a></code>, <code><a href="#topic+hyperbFit">hyperbFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
param &lt;- c(2, 2, 2, 1.5)
y &lt;- rhyperb(200, param = param)
qqhyperb(y, param = param, line = FALSE)
abline(0, 1, col = 2)
pphyperb(y, param = param)
</code></pre>

<hr>
<h2 id='hyperbWSqTable'>Percentage Points for the Cram'er-von Mises Test of the Hyperbolic Distribution</h2><span id='topic+hyperbWSqTable'></span>

<h3>Description</h3>

<p>This gives Table 5 of Puig &amp; Stephens (2001) which is used for testing
the goodness-of-fit of the hyperbolic distribution using the
Cramér-von~Mises test.  It is for internal use by
<code><a href="#topic+hyperbCvMTest">hyperbCvMTest</a></code> and <code><a href="#topic+hyperbCvMTestPValue">hyperbCvMTestPValue</a></code> only and is not
intended to be accessed by the user.  It is loaded automatically when
the package <span class="pkg">HyperbolicDist</span> is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbWSqTable
</code></pre>


<h3>Format</h3>

<p>The <code>hyperbWSqTable</code> matrix has 55 rows and 5 columns, giving
percentage points of <code class="reqn">W^2</code> for different values of
<code class="reqn">\xi</code> and <code class="reqn">\alpha</code> (the rows), and of
<code class="reqn">\chi</code> (the columns).
</p>


<h3>Source</h3>

<p>Puig, Pedro and Stephens, Michael A. (2001),
Goodness-of-fit tests for the hyperbolic distribution.
<em>The Canadian Journal of Statistics/La Revue Canadienne de
Statistique</em>, <b>29</b>, 309&ndash;320.
</p>

<hr>
<h2 id='mamquam'>Size of Gravels from Mamquam River</h2><span id='topic+mamquam'></span>

<h3>Description</h3>

<p>Size of gravels collected from a sandbar in the Mamquam River,
British Columbia, Canada. Summary data, giving the frequency of
observations in 16 different size classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mamquam)</code></pre>


<h3>Format</h3>

<p>The <code>mamquam</code> data frame has 16 rows and 2 columns.
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> midpoints  </td><td style="text-align: left;"> midpoints of intervals (psi units) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> counts      </td><td style="text-align: left;"> number of observations in interval </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Gravel sizes are determined by passing clasts through templates of
particular sizes. This gives a range in which the size of each clast
lies. Sizes (in mm) are then converted into psi units by taking the
base 2 logarithm of the size. The midpoints specified are the midpoints
of the psi unit ranges, and counts gives the number of observations
in each size range. The classes are of length 0.5 psi units.
There are 3574 observations.
</p>


<h3>Source</h3>

<p>Rice, Stephen and Church, Michael (1996)
Sampling surficial gravels: the precision of size distribution
percentile estimates.
<em>J. of Sedimentary Research</em>,
<b>66</b>, 654&ndash;665.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mamquam)
str(mamquam)
### Construct data from frequency summary, taking all observations
### at midpoints of intervals
psi &lt;- rep(mamquam$midpoints, mamquam$counts)
barplot(table(psi))
### Fit the hyperbolic distribution
hyperbFit(psi)

### Actually hyperbFit can deal with frequency data
hyperbFit(mamquam$midpoints, freq = mamquam$counts)
</code></pre>

<hr>
<h2 id='momRecursion'>Computes the moment coefficients recursively for generalized
hyperbolic and related distributions
</h2><span id='topic+momRecursion'></span>

<h3>Description</h3>

<p>This function computes all of the moments coefficients by recursion based on
Scott, Würtz and Tran (2008). See <b>Details</b> for the
formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  momRecursion(order = 12, printMatrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momRecursion_+3A_order">order</code></td>
<td>
<p>Numeric. The order of the moment coefficients to be calculated.
Not permitted to be a vector. Must be a positive whole number except for
moments about zero.</p>
</td></tr>
<tr><td><code id="momRecursion_+3A_printmatrix">printMatrix</code></td>
<td>
<p>Logical. Should the coefficients matrix be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The moment coefficients recursively as <code class="reqn">a_{1,1}=1</code> and
</p>
<p style="text-align: center;"><code class="reqn">a_{k,\ell} = a_{k-1, \ell-1} + (2 \ell - k + 1) a_{k-1, \ell}</code>
</p>
<p> with
<code class="reqn">a_{k,\ell} = 0</code> for <code class="reqn">\ell&lt;\lfloor(k+1)/2\rfloor</code> or <code class="reqn">\ell&gt;k</code>
where <code class="reqn">k</code> = <code>order</code>, <code class="reqn">\ell</code> is equal to the integers from
<code class="reqn">(k+1)/2</code> to <code class="reqn">k</code>.
</p>
<p>This formula is given in Scott, Würtz and Tran (2008,
working paper).
</p>
<p>The function also calculates M which is equal to <code class="reqn">2\ell - k</code>.
It is a common term which will appear in the formulae
for calculating moments of generalized hyperbolic and related distributions.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>The non-zero moment coefficients for the specified order.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>Integers from (<code>order</code>+1)/2 to <code>order</code>. It is used when
computing the moment coefficients and the mu moments.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>The common term used when computing mu moments for generalized
hyperbolic and related distributions, M = <code class="reqn">2\ell - k</code>,
<code class="reqn">k</code>=<code>order</code></p>
</td></tr>
<tr><td><code>lmin</code></td>
<td>
<p>The minimum of <code class="reqn">\ell</code>, which is equal to
(<code>order</code>+1)/2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Scott, D. J., Würtz, D. and Tran, T. T. (2008)
Moments of the Generalized Hyperbolic Distribution. Preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  momRecursion(order = 12)

  #print out the matrix
  momRecursion(order = 12, "true")
</code></pre>

<hr>
<h2 id='nervePulse'>Intervals Between Pulses Along a Nerve Fibre</h2><span id='topic+nervePulse'></span>

<h3>Description</h3>

<p>Times between successive electric pulses on the surface of isolated
muscle fibres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nervePulse)</code></pre>


<h3>Format</h3>

<p>The <code>nervePulse</code> data is a vector with 799 observations.
</p>


<h3>Details</h3>

<p>The end-plates of resting muscle fibres are the seat of spontaneous
electric discharges. The occurence of these spontaneous discharges at
apparently normal synapses is studied in depth in Fatt and Katz
(1951).
The frequency and amplitute of these discharges was recorded. The
times between each discharge were taken in milliseconds and this has
been converted into the number of 1/50 sec intervals between
successive pulses.
There are 799 observations.
</p>


<h3>Source</h3>

<p>Fatt, P., Katz, B. (1952)
Spontaneous subthreshold activity at motor nerve endings.
<em>J. of Physiology</em>,
<b>117</b>, 109&ndash;128.
</p>
<p>Jörgensen, B. (1982)
Statistical Properties of the Generalized Inverse Gaussian Distribution.
<em>Lecture Notes in Statistics, Vol. 9, Springer-Verlag, New York</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nervePulse)
str(nervePulse)

### Fit the generalized inverse Gaussian distribution
gigFit(nervePulse)

</code></pre>

<hr>
<h2 id='NIG'>Normal Inverse Gaussian Distribution</h2><span id='topic+dnig'></span><span id='topic+pnig'></span><span id='topic+qnig'></span><span id='topic+rnig'></span><span id='topic+ddnig'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and
random number generation for the normal inverse Gaussian distribution
with parameter vector <code>param</code>. Utility routines are included for
the derivative of the density function and to find suitable break
points for use in determining the distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnig(x, mu = 0, delta = 1, alpha = 1, beta = 0,
     param = c(mu, delta, alpha, beta))
pnig(q, mu = 0, delta = 1, alpha = 1, beta = 0,
     param = c(mu, delta, alpha, beta),
     lower.tail = TRUE, subdivisions = 100,
     intTol = .Machine$double.eps^0.25, valueOnly = TRUE, ...)
qnig(p, mu = 0, delta = 1, alpha = 1, beta = 0,
     param = c(mu, delta, alpha, beta),
     lower.tail = TRUE, method = c("spline","integrate"),
     nInterpol = 501, uniTol = .Machine$double.eps^0.25,
     subdivisions = 100, intTol = uniTol, ...)
rnig(n, mu = 0, delta = 1, alpha = 1, beta = 0,
     param = c(mu, delta, alpha, beta))
ddnig(x, mu = 0, delta = 1, alpha = 1, beta = 0,
     param = c(mu, delta, alpha, beta))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NIG_+3A_x">x</code>, <code id="NIG_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="NIG_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="NIG_+3A_n">n</code></td>
<td>
<p>Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="NIG_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="NIG_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the
distribution. A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="NIG_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.</p>
</td></tr>
<tr><td><code id="NIG_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.</p>
</td></tr>
<tr><td><code id="NIG_+3A_param">param</code></td>
<td>
<p>Parameter vector taking the form
<code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="NIG_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="NIG_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>lower.tail = TRUE</code>, the cumulative
density is taken from the lower tail.</p>
</td></tr>
<tr><td><code id="NIG_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subdivisions used to
integrate the density and determine the accuracy of the distribution
function calculation.</p>
</td></tr>
<tr><td><code id="NIG_+3A_inttol">intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in
calls to <code>integrate</code>. See <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="NIG_+3A_valueonly">valueOnly</code></td>
<td>
<p>Logical. If <code>valueOnly = TRUE</code> calls to
<code>pghyp</code> only return the value obtained for the integral.
If <code>valueOnly = FALSE</code> an estimate of the
accuracy of the numerical integration is also returned.</p>
</td></tr>
<tr><td><code id="NIG_+3A_ninterpol">nInterpol</code></td>
<td>
<p>Number of points used in <code>qghyp</code> for cubic
spline interpolation of the distribution function.</p>
</td></tr>
<tr><td><code id="NIG_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in
calls to <code>uniroot</code>. See <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="NIG_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>uniroot</code>. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal inverse Gaussian distribution has density
</p>
<p style="text-align: center;"><code class="reqn">e^{\delta \sqrt{\alpha^2 - \beta^2}}%
        \frac{\alpha \delta}{\pi \sqrt{\delta^2 + (x - \mu)^2}}%
        K_1(\alpha \sqrt{\delta^2 + (x - \mu)^2})%
        e^{\beta (x - \mu)}</code>
</p>

<p>where <code class="reqn">K_1()</code> is the modified Bessel function of the
third kind with order 1.
</p>
<p>A succinct description of the normal inverse Gaussian distribution is
given in Paolella(2007). Because both of the normal inverse Gaussian
distribution and the hyperbolic distribution are special cases of the
generalized hyperbolic distribution (with different values of
<code class="reqn">\lambda</code>), the normal inverse Gaussian distribution has
the same sets of parameterizations as the hyperbolic distribution.
And therefore one can use <code>hyperbChangePars</code> to interchange between
different parameterizations for the normal inverse Gaussian distribution as
well (see <code>hyperbChangePars</code> for details).
</p>
<p>Each of the functions are wrapper functions for their equivalent
generalized hyperbolic distribution. For example, <code>dnig</code> calls
<code>dghyp</code>.
</p>
<p><code>pnig</code> breaks the real line into eight regions in order to
determine the integral of <code>dnig</code>. The break points determining
the regions are found by <code>nigBreaks</code>, based on the values of
<code>small</code>, <code>tiny</code>, and <code>deriv</code>. In the extreme tails of
the distribution where the probability is <code>tiny</code> according to
<code>nigCalcRange</code>, the probability is taken to be zero. In the range
between where the probability is <code>tiny</code> and <code>small</code>
according to <code>nigCalcRange</code>, an exponential approximation to the
hyperbolic distribution is used. In the inner part of the
distribution, the range is divided in 4 regions, 2 above the mode, and
2 below. On each side of the mode, the break point which forms the 2
regions is where the derivative of the density function is
<code>deriv</code> times the maximum value of the derivative on that side of
the mode. In each of the 4 inner regions the numerical integration
routine <code><a href="DistributionUtils.html#topic+safeIntegrate">safeIntegrate</a></code> (which is a
wrapper for <code><a href="stats.html#topic+integrate">integrate</a></code>) is used to integrate the density
<code>dnig</code>.
</p>
<p><code>qnig</code> uses the breakup of the real line into the same 8
regions as <code>pnig</code>. For quantiles which fall in the 2 extreme
regions, the quantile is returned as <code>-Inf</code> or <code>Inf</code> as
appropriate. In the range between where the probability is <code>tiny</code>
and <code>small</code> according to <code>nigCalcRange</code>, an exponential
approximation to the hyperbolic distribution is used from which the
quantile may be found in closed form. In the 4 inner regions
<code>splinefun</code> is used to fit values of the distribution function
generated by <code>pnig</code>.  The quantiles are then found
using the <code>uniroot</code> function.
</p>
<p><code>pnig</code> and <code>qnig</code> may generally be expected to be
accurate to 5 decimal places.
</p>
<p>Recall that the normal inverse Gaussian distribution is a special case
of the generalized hyperbolic distribution and the generalized
hyperbolic distribution can be represented as a particular mixture of
the normal distribution where the mixing distribution is the
generalized inverse Gaussian.  <code>rnig</code> uses this representation to
generate observations from the normal inverse Gaussian distribution.
Generalized inverse Gaussian observations are obtained via the algorithm of
Dagpunar (1989).</p>


<h3>Value</h3>

<p><code>dnig</code> gives the density, <code>pnig</code> gives the distribution
function, <code>qnig</code> gives the quantile function and <code>rnig</code>
generates random variates. An estimate of the accuracy of the
approximation to the distribution function may be found by setting
<code>accuracy = TRUE</code> in the call to <code>pnig</code> which then returns
a list with components <code>value</code> and <code>error</code>.
</p>
<p><code>ddnig</code> gives the derivative of <code>dnig</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Christine Yang Dong</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="DistributionUtils.html#topic+safeIntegrate">safeIntegrate</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code> for its shortfalls, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code> and <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code> for changing
parameters to the <code class="reqn">(\alpha,\beta)</code>
parameterization, <code><a href="#topic+dghyp">dghyp</a></code> for the generalized hyperbolic
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(0, 2, 1, 0)
nigRange &lt;- nigCalcRange(param = param, tol = 10^(-3))
par(mfrow = c(1, 2))
curve(dnig(x, param = param), from = nigRange[1], to = nigRange[2],
      n = 1000)
title("Density of the\n Normal Inverse Gaussian Distribution")
curve(pnig(x, param = param), from = nigRange[1], to = nigRange[2],
      n = 1000)
title("Distribution Function of the\n Normal Inverse Gaussian Distribution")
dataVector &lt;- rnig(500, param = param)
curve(dnig(x, param = param), range(dataVector)[1], range(dataVector)[2],
      n = 500)
hist(dataVector, freq = FALSE, add =TRUE)
title("Density and Histogram\n of the Normal Inverse Gaussian Distribution")
DistributionUtils::logHist(dataVector, main =
        "Log-Density and Log-Histogram\n of the Normal Inverse Gaussian Distribution")
curve(log(dnig(x, param = param)), add = TRUE,
      range(dataVector)[1], range(dataVector)[2], n = 500)
par(mfrow = c(2, 1))
curve(dnig(x, param = param), from = nigRange[1], to = nigRange[2],
      n = 1000)
title("Density of the\n Normal Inverse Gaussian Distribution")
curve(ddnig(x, param = param), from = nigRange[1], to = nigRange[2],
      n = 1000)
title("Derivative of the Density\n of the Normal Inverse Gaussian Distribution")
</code></pre>

<hr>
<h2 id='nigCalcRange'>Range of a normal inverse Gaussian Distribution</h2><span id='topic+nigCalcRange'></span>

<h3>Description</h3>

<p>Given the parameter vector param of a normal inverse Gaussian distribution,
this function calculates the range outside of which the distribution
has negligible probability, or the density function is negligible, to
a specified tolerance. The parameterization used
is the <code class="reqn">(\alpha, \beta)</code> one (see
<code><a href="#topic+dnig">dnig</a></code>). To use another parameterization, use
<code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigCalcRange(mu = 0, delta = 1, alpha = 1, beta = 0,
                param = c(mu, delta, alpha, beta),
                tol = 10^(-5), density = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nigCalcRange_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_param">param</code></td>
<td>
<p>Value of parameter vector specifying the normal inverse Gaussian
distribution. This takes the form <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_density">density</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the bounds are for the probability
distribution. If <code>TRUE</code>, they are for the density function.</p>
</td></tr>
<tr><td><code id="nigCalcRange_+3A_...">...</code></td>
<td>
<p>Extra arguments for calls to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The particular normal inverse Gaussian distribution being considered is 
specified by the parameter value <code>param</code>.
</p>
<p>If <code>density = FALSE</code>, the function calculates
the effective range of the distribution, which is used in calculating
the distribution function and quantiles, and may be used in determining
the range when plotting the distribution. By effective range is meant that
the probability of an observation being greater than the upper end is
less than the specified tolerance <code>tol</code>. Likewise for being smaller
than the lower end of the range. Note that this has not been implemented
yet.
</p>
<p>If <code>density = TRUE</code>, the function gives a range, outside of which
the density is less than the given tolerance. Useful for plotting the
density.
</p>


<h3>Value</h3>

<p>A two-component vector giving the lower and upper ends of the range.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Christine Yang Dong</p>


<h3>References</h3>

 
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions. 
In <em>Encyclopedia of Statistical Sciences</em>, 
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnig">dnig</a></code>, <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
param &lt;- c(0, 1, 3, 1)
nigRange &lt;- nigCalcRange(param = param, tol = 10^(-3))
nigRange
curve(pnig(x, param = param), nigRange[1], nigRange[2])
maxDens &lt;- dnig(nigMode(param = param), param = param)
nigRange &lt;- nigCalcRange(param = param, tol = 10^(-3) * maxDens, density = TRUE)
nigRange
curve(dnig(x, param = param), nigRange[1], nigRange[2])
</code></pre>

<hr>
<h2 id='nigFit'>Fit the normal inverse Gaussian Distribution to Data</h2><span id='topic+nigFit'></span><span id='topic+print.nigFit'></span><span id='topic+plot.nigFit'></span><span id='topic+coef.nigFit'></span><span id='topic+vcov.nigFit'></span>

<h3>Description</h3>

<p>Fits a normal inverse Gaussian distribution to data.
Displays the histogram, log-histogram (both with fitted densities),
Q-Q plot and P-P plot for the fit which has the maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nigFit(x, freq = NULL, paramStart = NULL,
         startMethod = c("Nelder-Mead","BFGS"),
         startValues = c("FN","Cauchy","MoM","US"),
         criterion = "MLE",
         method = c("Nelder-Mead","BFGS","nlm",
                   "L-BFGS-B","nlminb","constrOptim"),
         plots = FALSE, printOut = FALSE,
         controlBFGS = list(maxit = 200),
         controlNM = list(maxit = 1000), maxitNLM = 1500,
         controlLBFGSB = list(maxit = 200),
         controlNLMINB = list(),
         controlCO = list(), ...)

  ## S3 method for class 'nigFit'
print(x,
        digits = max(3, getOption("digits") - 3), ...)

  ## S3 method for class 'nigFit'
plot(x, which = 1:4,
       plotTitles = paste(c("Histogram of ","Log-Histogram of ",
                            "Q-Q Plot of ","P-P Plot of "), x$obsName,
                          sep = ""),
       ask = prod(par("mfcol")) &lt; length(which) &amp; dev.interactive(), ...)

  ## S3 method for class 'nigFit'
coef(object, ...)

  ## S3 method for class 'nigFit'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nigFit_+3A_x">x</code></td>
<td>
<p>Data vector for <code>nigFit</code>. Object of class
<code>"nigFit"</code> for <code>print.nigFit</code> and <code>plot.nigFit</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_freq">freq</code></td>
<td>
<p>A vector of weights with length equal to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_paramstart">paramStart</code></td>
<td>
<p>A user specified starting parameter vector param taking
the form <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_startmethod">startMethod</code></td>
<td>
<p>Method used by <code>nigFitStart</code> in calls to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_startvalues">startValues</code></td>
<td>
<p>Code giving the method of determining starting
values for finding the maximum likelihood estimate of <code>param</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_criterion">criterion</code></td>
<td>
<p>Currently only <code>"MLE"</code> is implemented.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_method">method</code></td>
<td>
<p>Different optimisation methods to consider.
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_plots">plots</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of the
histogram, log-histogram, Q-Q plot and P-P plot.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_printout">printOut</code></td>
<td>
<p>Logical. If <code>FALSE</code> suppresses printing of
results of fitting.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_controlbfgs">controlBFGS</code></td>
<td>
<p>A list of control parameters for <code>optim</code> when using
the <code>"BFGS"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_controlnm">controlNM</code></td>
<td>
<p>A list of control parameters for <code>optim</code>
when using the <code>"Nelder-Mead"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_maxitnlm">maxitNLM</code></td>
<td>
<p>A positive integer specifying the maximum number of
iterations when using the <code>"nlm"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_controllbfgsb">controlLBFGSB</code></td>
<td>
<p>A list of control parameters for <code>optim</code> when using
the <code>"L-BFGS-B"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_controlnlminb">controlNLMINB</code></td>
<td>
<p>A list of control parameters for <code>nlminb</code>
when using the <code>"nlminb"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_controlco">controlCO</code></td>
<td>
<p>A list of control parameters for <code>constrOptim</code>
when using the <code>"constrOptim"</code> optimisation.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_digits">digits</code></td>
<td>
<p>Desired number of digits when the object is printed.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of
the numbers <code>1:4</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_plottitles">plotTitles</code></td>
<td>
<p>Titles to appear above the plots.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, see <code><a href="graphics.html#topic+par">par</a>(ask = .)</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code>par</code>, <code>hist</code>,
<code>logHist</code>, <code>qqnig</code> and <code>ppnig</code>.</p>
</td></tr>
<tr><td><code id="nigFit_+3A_object">object</code></td>
<td>
<p>Object of class <code>"nigFit"</code> for <code>coef.nigFit</code>
and for <code>vcov.nigFit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>startMethod</code> can be either <code>"BFGS"</code> or
<code>"Nelder-Mead"</code>.
</p>
<p><code>startValues</code> can be one of the following:
</p>

<dl>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
<dt><code>"FN"</code></dt><dd><p>A fitted normal distribution.</p>
</dd>
<dt><code>"Cauchy"</code></dt><dd><p>Based on a fitted Cauchy distribution.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
</dl>

<p>For the details concerning the use of <code>paramStart</code>,
<code>startMethod</code>, and <code>startValues</code>, see
<code><a href="#topic+nigFitStart">nigFitStart</a></code>.
</p>
<p>The three optimisation methods currently available are:
</p>

<dl>
<dt><code>"BFGS"</code></dt><dd><p>Uses the quasi-Newton method <code>"BFGS"</code> as
documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"Nelder-Mead"</code></dt><dd><p>Uses an implementation of the Nelder and
Mead method as documented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>"nlm"</code></dt><dd><p>Uses the <code><a href="stats.html#topic+nlm">nlm</a></code> function in R.</p>
</dd>
</dl>

<p>For details of how to pass control information for optimisation using
<code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code>, see <code><a href="stats.html#topic+optim">optim</a></code> and
<code><a href="stats.html#topic+nlm">nlm</a>.</code>
</p>
<p>When <code>method = "nlm"</code> is used, warnings may be produced. These do
not appear to be a problem.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>A vector giving the maximum likelihood estimate of
param, as <code>c(mu, delta, alpha, beta)</code>.</p>
</td></tr>
<tr><td><code>maxLik</code></td>
<td>
<p>The value of the maximised log-likelihood.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Optimisation method used.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>Convergence code. See the relevant documentation (either
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlm">nlm</a></code>) for details on
convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations of optimisation routine.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The data used to fit the normal inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code>xName</code></td>
<td>
<p>A character string with the actual <code>x</code> argument
name.</p>
</td></tr>
<tr><td><code>paramStart</code></td>
<td>
<p>Starting value of param returned by call to
<code><a href="#topic+nigFitStart">nigFitStart</a></code>.</p>
</td></tr>
<tr><td><code>svName</code></td>
<td>
<p>Descriptive name for the method finding start values.</p>
</td></tr>
<tr><td><code>startValues</code></td>
<td>
<p>Acronym for the method of finding start values.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Christine Yang Dong</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>
<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="DistributionUtils.html#topic+logHist">logHist</a></code>,
<code><a href="#topic+qqnig">qqnig</a></code>, <code><a href="#topic+ppnig">ppnig</a></code>, <code><a href="#topic+dskewlap">dskewlap</a></code>
and <code><a href="#topic+nigFitStart">nigFitStart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rnig(500, param = param)
## See how well nigFit works
nigFit(dataVector)
nigFit(dataVector, plots = TRUE)
fit &lt;- nigFit(dataVector)
par(mfrow = c(1, 2))
plot(fit, which = c(1, 3))

## Use nlm instead of default
nigFit(dataVector, method = "nlm")

</code></pre>

<hr>
<h2 id='nigFitStart'>Find Starting Values for Fitting a normal inverse Gaussian Distribution</h2><span id='topic+nigFitStart'></span><span id='topic+nigFitStartMoM'></span>

<h3>Description</h3>

<p>Finds starting values for input to a maximum likelihood routine for
fitting normal inverse Gaussian distribution to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nigFitStart(x, startValues = c("FN","Cauchy","MoM","US"),
              paramStart = NULL,
              startMethodMoM = c("Nelder-Mead","BFGS"), ...)
  nigFitStartMoM(x, startMethodMoM = "Nelder-Mead", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nigFitStart_+3A_x">x</code></td>
<td>
<p>data vector.</p>
</td></tr>
<tr><td><code id="nigFitStart_+3A_startvalues">startValues</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> strin specifying the
method for starting values to consider.  See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="nigFitStart_+3A_paramstart">paramStart</code></td>
<td>
<p>starting values for param if <code>startValues = "US"</code>.</p>
</td></tr>
<tr><td><code id="nigFitStart_+3A_startmethodmom">startMethodMoM</code></td>
<td>
<p>Method used by call to <code><a href="stats.html#topic+optim">optim</a></code> in
finding method of moments estimates.</p>
</td></tr>
<tr><td><code id="nigFitStart_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="graphics.html#topic+hist">hist</a></code> and
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of the argument <code>startValues</code> are the following:
</p>

<dl>
<dt><code>"US"</code></dt><dd><p>User-supplied.</p>
</dd>
<dt><code>"FN"</code></dt><dd><p>A fitted normal distribution.</p>
</dd>
<dt><code>"Cauchy"</code></dt><dd><p>Based on a fitted Cauchy distribution, from
<code><a href="MASS.html#topic+fitdistr">fitdistr</a>()</code> of the <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a> package.</p>
</dd>
<dt><code>"MoM"</code></dt><dd><p>Method of moments.</p>
</dd>
</dl>

<p>If <code>startValues = "US"</code> then a value must be supplied for
<code>paramStart</code>.
</p>
<p>If <code>startValues = "MoM"</code>, <code>nigFitStartMoM</code> is
called. If <code>startValues = "MoM"</code> an initial
optimisation is needed to find the starting values. These
optimisations call <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p><code>nigFitStart</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>paramStart</code></td>
<td>
<p>A vector with elements <code>mu</code>, <code>delta</code>,
<code>alpha</code> and <code>beta</code> giving the
starting value of param.</p>
</td></tr>
<tr><td><code>xName</code></td>
<td>
<p>A character string with the actual <code>x</code> argument name.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>midpoints</code></td>
<td>
<p>The cell midpoints found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>empDens</code></td>
<td>
<p>The estimated density found by a call to
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>
<p><code>nigFitStartMoM</code> returns only the method of moments estimates
as a vector with elements <code>mu</code>, <code>delta</code>, <code>alpha</code> and
<code>beta</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Christine Yang Dong</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Barndorff-Nielsen, O., Blæsild, P., Jensen, J.,
and  Sörenson, M. (1985).
The fascination of sand.
In <em>A celebration of statistics, The ISI Centenary Volume</em>,
eds., Atkinson, A. C. and Fienberg, S. E.,
pp. 57&ndash;87. New York: Springer-Verlag.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnig">dnig</a></code>, <code><a href="#topic+dskewlap">dskewlap</a></code>,
<code><a href="#topic+nigFit">nigFit</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rnig(500, param = param)
nigFitStart(dataVector, startValues = "FN")
nigFitStartMoM(dataVector)
nigFitStart(dataVector, startValues = "MoM")
</code></pre>

<hr>
<h2 id='nigHessian'>
Calculate Two-Sided Hessian for the Normal Inverse Gaussian Distribution
</h2><span id='topic+nigHessian'></span>

<h3>Description</h3>

<p>Calculates the Hessian of a function, either exactly or approximately. Used to
obtaining the information matrix for maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigHessian(x, param, hessianMethod = "tsHessian",
              whichParam = 1:5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nigHessian_+3A_x">x</code></td>
<td>
<p>Data vector.</p>
</td></tr>
<tr><td><code id="nigHessian_+3A_param">param</code></td>
<td>
<p>The maximum likelihood estimates parameter vector of the
normal inverse Gaussian distribution. The normal inverse Gaussian 
distribution has the same sets of parameterizations as the hyperbolic 
distribution.There are five different sets of
parameterazations can be used in this function, the first four sets
are listed in <code>hyperbChangePars</code> and the last set is the log
scale of the first set of the parameterization, i.e.,
<code>mu,log(delta),Pi,log(zeta)</code>.  </p>
</td></tr>
<tr><td><code id="nigHessian_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>Only the approximate method (<code>"tsHessian"</code>)
has actually been implemented so far.</p>
</td></tr>  
<tr><td><code id="nigHessian_+3A_whichparam">whichParam</code></td>
<td>
<p>Numeric. A number between 1 to 5 indicating which
set of the parameterization is the specified value in argument
<code>param</code> belong to.</p>
</td></tr> 
<tr><td><code id="nigHessian_+3A_...">...</code></td>
<td>
<p>Values of other parameters of the function <code>fun</code> if
required.</p>
</td></tr> 
</table>


<h3>Details</h3>

  
<p>The approximate Hessian is obtained via a call to <code>tsHessian</code>
from the package <code>DistributionUtils</code>.  <code>summary.nigFit</code>
calls the function <code>nigHessian</code> to calculate the Hessian matrix
when the argument <code>hessian = TRUE</code>.  
</p>


<h3>Value</h3>

<p><code>nigHessian</code> gives the approximate or exact Hessian matrix for
the data vector <code>x</code> and the estimated parameter vector
<code>param</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Calculate the exact Hessian using nigHessian:
param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rnig(500, param = param)
fit &lt;- nigFit(dataVector, method = "BFGS")
coef=coef(fit)
nigHessian(x=dataVector, param=coef, hessianMethod = "tsHessian",
           whichParam = 2)
              
### Or calculate the exact Hessian using summary.nigFit method:
### summary(fit, hessian = TRUE)

## Calculate the approximate Hessian:
summary(fit, hessian = TRUE, hessianMethod = "tsHessian")
</code></pre>

<hr>
<h2 id='nigParam'>Parameter Sets for the Normal Inverse Gaussian Distribution</h2><span id='topic+nigParam'></span><span id='topic+nigSmallShape'></span><span id='topic+nigLargeShape'></span><span id='topic+nigSmallParam'></span><span id='topic+nigLargeParam'></span>

<h3>Description</h3>

<p>These objects store different parameter sets of the normal inverse
Gaussian distribution as matrices for testing or demonstration
purposes.
</p>
<p>The parameter sets <code>nigSmallShape</code> and
<code>nigLargeShape</code> have a constant location parameter of
<code class="reqn">\mu</code> = 0, and constant scale parameter <code class="reqn">\delta</code> =
1. In <code>nigSmallParam</code> and <code>nigLargeParam</code> the values of
the location and scale parameters vary. In these parameter sets the
location parameter <code class="reqn">\mu</code> = 0 takes values from {0, 1} and
{-1, 0, 1, 2}  respectively. For the scale parameter
<code class="reqn">\delta</code>, values are drawn from {1, 5} and {1, 2, 5,
10} respectively.
</p>
<p>For the shape parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> the
approach is more complex. The values for these shape parameters were
chosen by choosing values of <code class="reqn">\xi</code> and <code class="reqn">\chi</code> which
range over the shape triangle, then the function <code>nigChangePars</code>
was applied to convert them to the <code class="reqn">\alpha, \beta</code>
parameterization. The resulting <code class="reqn">\alpha, \beta</code>
values were then rounded to three decimal places. See the examples for
the values of <code class="reqn">\xi</code> and <code class="reqn">\chi</code> for the large
parameter sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nigSmallShape
  nigLargeShape
  nigSmallParam
  nigLargeParam
</code></pre>


<h3>Format</h3>

<p><code>nigSmallShape</code>: a 7 by 4 matrix;
<code>nigLargeShape</code>: a 15 by 4 matrix;
<code>nigSmallParam</code>: a 28 by 4 matrix;
<code>nigLargeParam</code>: a 240 by 4 matrix.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nigParam)
plotShapeTriangle()
xis &lt;- rep(c(0.1,0.3,0.5,0.7,0.9), 1:5)
chis &lt;- c(0,-0.25,0.25,-0.45,0,0.45,-0.65,-0.3,0.3,0.65,
          -0.85,-0.4,0,0.4,0.85)
points(chis, xis, pch = 20, col = "red")


## Testing the accuracy of nigMean
for (i in 1:nrow(nigSmallParam)) {
  param &lt;- nigSmallParam[i, ]
  x &lt;- rnig(1000, param = param)
  sampleMean &lt;- mean(x)
  funMean &lt;- nigMean(param = param)
  difference &lt;- abs(sampleMean - funMean)
  print(difference)
}

</code></pre>

<hr>
<h2 id='nigPlots'>Normal inverse Gaussian Quantile-Quantile and Percent-Percent Plots</h2><span id='topic+qqnig'></span><span id='topic+ppnig'></span>

<h3>Description</h3>

<p><code>qqnig</code> produces a normal inverse Gaussian Q-Q plot of the values in
<code>y</code>.
</p>
<p><code>ppnig</code> produces a normal inverse Gaussian P-P (percent-percent) or
probability plot of the values in <code>y</code>.
</p>
<p>Graphical parameters may be given as arguments to <code>qqnig</code>,
and <code>ppnig</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnig(y, mu = 0, delta = 1, alpha = 1, beta = 0,
         param = c(mu, delta, alpha, beta),
         main = "Normal inverse Gaussian Q-Q Plot",
         xlab = "Theoretical Quantiles",
         ylab = "Sample Quantiles",
         plot.it = TRUE, line = TRUE, ...)

ppnig(y, mu = 0, delta = 1, alpha = 1, beta = 0,
         param = c(mu, delta, alpha, beta),
         main = "Normal inverse Gaussian P-P Plot",
         xlab = "Uniform Quantiles",
         ylab = "Probability-integral-transformed Data",
         plot.it = TRUE, line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nigPlots_+3A_y">y</code></td>
<td>
<p>The data sample.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_param">param</code></td>
<td>
<p>Parameters of the normal inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_xlab">xlab</code>, <code id="nigPlots_+3A_ylab">ylab</code>, <code id="nigPlots_+3A_main">main</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical. Should the result be plotted?</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_line">line</code></td>
<td>
<p>Add line through origin with unit slope.</p>
</td></tr>
<tr><td><code id="nigPlots_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qqnig</code> and <code>ppnig</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that are to be plotted.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates of the points that are to be plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilk, M. B. and Gnanadesikan, R. (1968)
Probability plotting methods for the analysis of data.
<em>Biometrika</em>.
<b>55</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ppoints">ppoints</a></code>, <code><a href="#topic+dnig">dnig</a></code>, <code><a href="#topic+nigFit">nigFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
param &lt;- c(2, 2, 2, 1.5)
y &lt;- rnig(200, param = param)
qqnig(y, param = param, line = FALSE)
abline(0, 1, col = 2)
ppnig(y, param = param)
</code></pre>

<hr>
<h2 id='plotShapeTriangle'>
Plot the Shape Triangle
</h2><span id='topic+plotShapeTriangle'></span>

<h3>Description</h3>

<p>Plots the shape triangle for a hyperbolic distribution or generalized
hyperbolic distribution. For the hyperbolic distribution the parameter
<code class="reqn">\chi</code> is related to the skewness, and the parameter
<code class="reqn">\xi</code> is related to the kurtosis. See Barndorff-Nielsen, O. and
Blæsild, P. (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotShapeTriangle(xgap = 0.025, ygap = 0.0625/2,
                  main = "Shape Triangle", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotShapeTriangle_+3A_xgap">xgap</code></td>
<td>
<p>Gap between the left- and right-hand edges of the shape
triangle and the border surrounding the graph.
</p>
</td></tr>
<tr><td><code id="plotShapeTriangle_+3A_ygap">ygap</code></td>
<td>
<p>Gap between the top and bottom of the shape
triangle and the border surrounding the graph.
</p>
</td></tr>
<tr><td><code id="plotShapeTriangle_+3A_main">main</code></td>
<td>
<p>Title for the plot.
</p>
</td></tr>
<tr><td><code id="plotShapeTriangle_+3A_...">...</code></td>
<td>
<p>Values of other graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1981).
Hyperbolic distributions and ramifications: contributions to theory
and application.
In <em>Statistical Distributions in Scientific Work</em>,
eds., Taillie, C., Patil, G. P., and Baldessari, B. A., Vol. 4,
pp. 19&ndash;44. Dordrecht: Reidel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotShapeTriangle()
</code></pre>

<hr>
<h2 id='resistors'>Resistance of One-half-ohm Resistors </h2><span id='topic+resistors'></span>

<h3>Description</h3>

<p>This data set gives the resistance in ohms of 500 nominally one-half-ohm
resistors, presented in Hahn and Shapiro (1967). Summary data giving the
frequency of observations in 28 intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(resistors)</code></pre>


<h3>Format</h3>

<p>The <code>resistors</code> data frame has 28 rows and 2 columns.
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> midpoints  </td><td style="text-align: left;"> midpoints of intervals (ohm) </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> counts     </td><td style="text-align: left;"> number of observations in interval </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Hahn, Gerald J. and Shapiro, Samuel S. (1967)
<em>Statistical Models in Engineering</em>.
New York: Wiley,
page 207.
</p>


<h3>References</h3>

<p>Chen, Hanfeng, and Kamburowska, Grazyna (2001)
Fitting data to the Johnson system.
<em>J. Statist. Comput. Simul.</em> <b>70</b>, 21&ndash;32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(resistors)
str(resistors)
### Construct data from frequency summary, taking all observations
### at midpoints of intervals
resistances &lt;- rep(resistors$midpoints, resistors$counts)
hist(resistances)
DistributionUtils::logHist(resistances)
## Fit the hyperbolic distribution
hyperbFit(resistances)

## Actually fit.hyperb can deal with frequency data
hyperbFit(resistors$midpoints, freq = resistors$counts)
</code></pre>

<hr>
<h2 id='SandP500'>S&amp;P 500</h2><span id='topic+SandP500'></span>

<h3>Description</h3>

<p>This data set gives the value of Standard and Poor's most notable stock
market price index (the S&amp;P 500) at year end, from 1800 to 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SandP500)</code></pre>


<h3>Format</h3>

<p>A vector of 202 observations.
</p>


<h3>Source</h3>

<p>At the time of downloading, <code>http://www.globalfindata.com</code>
which no longer exists. Now at <code>https://globalfinancialdata.com</code>.
</p>


<h3>References</h3>

<p>Brown, Barry W., Spears, Floyd M. and Levy, Lawrence B. (2002)
The log <em>F</em>: a distribution for all seasons.
<em>Computational Statistics</em>,
<b>17</b>, 47&ndash;58.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SandP500)
### Consider proportional changes in the index
change &lt;- SandP500[-length(SandP500)] / SandP500[-1]
hist(change)
### Fit hyperbolic distribution to changes
hyperbFit(change)
</code></pre>

<hr>
<h2 id='SkewLaplace'>Skew-Laplace Distribution</h2><span id='topic+dskewlap'></span><span id='topic+pskewlap'></span><span id='topic+qskewlap'></span><span id='topic+rskewlap'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and
random number generation for the skew-Laplace distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dskewlap(x, mu = 0, alpha = 1, beta = 1,
         param = c(mu, alpha, beta), logPars = FALSE)
pskewlap(q, mu = 0, alpha = 1, beta = 1,
         param = c(mu, alpha, beta))
qskewlap(p, mu = 0, alpha = 1, beta = 1,
         param = c(mu, alpha, beta))
rskewlap(n, mu = 0, alpha = 1, beta = 1,
         param = c(mu, alpha, beta))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewLaplace_+3A_x">x</code>, <code id="SkewLaplace_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_n">n</code></td>
<td>
<p>Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_mu">mu</code></td>
<td>
<p>The location parameter, set to 0 by default.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_alpha">alpha</code>, <code id="SkewLaplace_+3A_beta">beta</code></td>
<td>
<p>The shape parameters, both set to 1 by default.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_param">param</code></td>
<td>
<p>Vector of parameters of the skew-Laplace distribution:
<code class="reqn">\mu</code>, <code class="reqn">\alpha</code> and <code class="reqn">\beta</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="SkewLaplace_+3A_logpars">logPars</code></td>
<td>
<p>Logical. If <code>TRUE</code> the second and third components
of <code>param</code> are taken to be <code class="reqn">log(\alpha)</code> and
<code class="reqn">log(\beta)</code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The central skew-Laplace has mode zero, and is a mixture of a (negative)
exponential distribution with mean <code class="reqn">\beta</code>, and the negative of an
exponential distribution with mean <code class="reqn">\alpha</code>. The weights of
the positive and negative components are proportional to their means.
</p>
<p>The general skew-Laplace distribution is a shifted central skew-Laplace
distribution, where the mode is given by <code class="reqn">\mu</code>.
</p>
<p>The density is given by:
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{1}{\alpha+\beta} e^{(x - \mu)/\alpha}</code>
</p>

<p>for <code class="reqn">x\leq\mu</code>, and
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{1}{\alpha+\beta} e^{-(x - \mu)/\beta}</code>
</p>

<p>for <code class="reqn">x\geq\mu</code>
</p>


<h3>Value</h3>

<p><code>dskewlap</code> gives the density, <code>pskewlap</code> gives the distribution
function, <code>qskewlap</code> gives the quantile function and <code>rskewlap</code>
generates random variates. The distribution function is obtained by
elementary integration of the density function. Random variates are
generated from exponential observations using the characterization of
the skew-Laplace as a mixture of exponential observations.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Ai-Wei Lee, Richard Trendall</p>


<h3>References</h3>

<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperbFitStart">hyperbFitStart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(1, 1, 2)
par(mfrow = c(1, 2))
curve(dskewlap(x, param = param), from = -5, to = 8, n = 1000)
title("Density of the\n Skew-Laplace Distribution")
curve(pskewlap(x, param = param), from = -5, to = 8, n = 1000)
title("Distribution Function of the\n Skew-Laplace Distribution")
dataVector &lt;- rskewlap(500, param = param)
curve(dskewlap(x, param = param), range(dataVector)[1], range(dataVector)[2],
      n = 500)
hist(dataVector, freq = FALSE, add = TRUE)
title("Density and Histogram\n of the Skew-Laplace Distribution")
DistributionUtils::logHist(dataVector, main =
        "Log-Density and Log-Histogram\n of the Skew-Laplace Distribution")
curve(log(dskewlap(x, param = param)), add = TRUE,
      range(dataVector)[1], range(dataVector)[2], n = 500)
</code></pre>

<hr>
<h2 id='SkewLaplacePlots'>Skew-Laplace Quantile-Quantile and Percent-Percent Plots</h2><span id='topic+qqskewlap'></span><span id='topic+ppskewlap'></span>

<h3>Description</h3>

<p><code>qqskewlap</code> produces a skew-Laplace QQ plot of the
values in <code>y</code>.
</p>
<p><code>ppskewlap</code> produces a skew-Laplace PP (percent-percent) or
probability plot of the values in <code>y</code>.
</p>
<p>If <code>line = TRUE</code>, a line with zero intercept and unit slope is
added to the plot.
</p>
<p>Graphical parameters may be given as arguments to <code>qqskewlap</code>, and
<code>ppskewlap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqskewlap(y, mu = 0, alpha = 1, beta = 1,
          param = c(mu, alpha, beta),
          main = "Skew-Laplace Q-Q Plot",
          xlab = "Theoretical Quantiles",
          ylab = "Sample Quantiles",
          plot.it = TRUE, line = TRUE, ...)

ppskewlap(y, mu = 0, alpha = 1, beta = 1,
          param = c(mu, alpha, beta),
          main = "Skew-Laplace P-P Plot",
          xlab = "Uniform Quantiles",
          ylab = "Probability-integral-transformed Data",
          plot.it = TRUE, line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewLaplacePlots_+3A_y">y</code></td>
<td>
<p>The data sample.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_mu">mu</code></td>
<td>
<p>The location parameter, set to 0 by default.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_alpha">alpha</code>, <code id="SkewLaplacePlots_+3A_beta">beta</code></td>
<td>
<p>The shape parameters, both set to 1 by default.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_param">param</code></td>
<td>
<p>Parameters of the skew-Laplace distribution.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_xlab">xlab</code>, <code id="SkewLaplacePlots_+3A_ylab">ylab</code>, <code id="SkewLaplacePlots_+3A_main">main</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical.  TRUE denotes the results should be plotted.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_line">line</code></td>
<td>
<p>Logical. If TRUE, a line with zero intercept and unit slope
is added to the plot.</p>
</td></tr>
<tr><td><code id="SkewLaplacePlots_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qqskewlap</code> and <code>ppskewlap</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that are be plotted.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates of the points that are be plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilk, M. B. and Gnanadesikan, R. (1968)
Probability plotting methods for the analysis of data.
<em>Biometrika</em>.
<b>55</b>, 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ppoints">ppoints</a></code>, <code><a href="#topic+dskewlap">dskewlap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1, 2))
y &lt;- rskewlap(1000, param = c(2, 0.5, 1))
qqskewlap(y, param = c(2, 0.5, 1), line = FALSE)
abline(0, 1, col = 2)
ppskewlap(y, param = c(2, 0.5, 1))
</code></pre>

<hr>
<h2 id='Specific+20Generalized+20Hyperbolic+20Moments+20and+20Mode'>Moments and Mode of the Generalized Hyperbolic Distribution</h2><span id='topic+ghypMean'></span><span id='topic+ghypVar'></span><span id='topic+ghypSkew'></span><span id='topic+ghypKurt'></span><span id='topic+ghypMode'></span>

<h3>Description</h3>

<p>Functions to calculate the mean, variance, skewness, kurtosis and mode
of a specific generalized hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghypMean(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
         param = c(mu, delta, alpha, beta, lambda))
ghypVar(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
        param = c(mu, delta, alpha, beta, lambda))
ghypSkew(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
         param = c(mu, delta, alpha, beta, lambda))
ghypKurt(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
         param = c(mu, delta, alpha, beta, lambda))
ghypMode(mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
         param = c(mu, delta, alpha, beta, lambda))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.
</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.
</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.
</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.
</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_lambda">lambda</code></td>
<td>
<p><code class="reqn">\lambda</code> is the shape parameter and dictates the
shape that the distribution shall take. Default value is 1.
</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Hyperbolic+2B20Moments+2B20and+2B20Mode_+3A_param">param</code></td>
<td>
<p>Parameter vector of the generalized hyperbolic
distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ghypMean</code> gives the mean of the generalized hyperbolic distribution,
<code>ghypVar</code> the variance, <code>ghypSkew</code> the skewness,
<code>ghypKurt</code> the kurtosis, and <code>ghypMode</code> the mode. The
formulae used for the mean is given in Prause (1999). The variance,
skewness and kurtosis are obtained using the recursive formula
implemented in <code><a href="#topic+ghypMom">ghypMom</a></code> which can calculate moments of
all orders about any point.
</p>
<p>The mode is found by a numerical optimisation using
<code><a href="stats.html#topic+optim">optim</a></code>. For the special case of the hyperbolic
distribution a formula for the mode is available, see
<code><a href="#topic+hyperbMode">hyperbMode</a></code>.
</p>
<p>The parameterization of the generalized hyperbolic distribution used
for these functions is the <code class="reqn">(\alpha, \beta)</code> one. See
<code><a href="#topic+ghypChangePars">ghypChangePars</a></code> to transfer between parameterizations.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Thomas Tran</p>


<h3>References</h3>

<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dghyp">dghyp</a></code>, <code><a href="#topic+ghypChangePars">ghypChangePars</a></code>,
<code><a href="base.html#topic+besselK">besselK</a></code>, <code><a href="#topic+RLambda">RLambda</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1, 2)
ghypMean(param = param)
ghypVar(param = param)
ghypSkew(param = param)
ghypKurt(param = param)
ghypMode(param = param)
maxDens &lt;- dghyp(ghypMode(param = param), param = param)
ghypRange &lt;- ghypCalcRange(param = param, tol = 10^(-3) * maxDens)
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2])
abline(v = ghypMode(param = param), col = "blue")
abline(v = ghypMean(param = param), col = "red")
</code></pre>

<hr>
<h2 id='Specific+20Generalized+20Inverse+20Gaussian+20Moments+20and+20Mode'>Moments and Mode of the Generalized Inverse Gaussian Distribution</h2><span id='topic+gigMean'></span><span id='topic+gigVar'></span><span id='topic+gigSkew'></span><span id='topic+gigKurt'></span><span id='topic+gigMode'></span>

<h3>Description</h3>

<p>Functions to calculate the mean, variance, skewness, kurtosis and mode
of a specific generalized inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gigMean(chi = 1, psi = 1, lambda = 1,
        param = c(chi, psi, lambda))
gigVar(chi = 1, psi = 1, lambda = 1,
       param = c(chi, psi, lambda))
gigSkew(chi = 1, psi = 1, lambda = 1,
        param = c(chi, psi, lambda))
gigKurt(chi = 1, psi = 1, lambda = 1,
        param = c(chi, psi, lambda))
gigMode(chi = 1, psi = 1, lambda = 1,
        param = c(chi, psi, lambda))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Specific+2B20Generalized+2B20Inverse+2B20Gaussian+2B20Moments+2B20and+2B20Mode_+3A_chi">chi</code></td>
<td>
<p>A shape parameter that by default holds a value of 1.</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Inverse+2B20Gaussian+2B20Moments+2B20and+2B20Mode_+3A_psi">psi</code></td>
<td>
<p>Another shape parameter that is set to 1 by default.</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Inverse+2B20Gaussian+2B20Moments+2B20and+2B20Mode_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter of the GIG distribution. Common to all forms of 
parameterization. By default this is set to 1.</p>
</td></tr>
<tr><td><code id="Specific+2B20Generalized+2B20Inverse+2B20Gaussian+2B20Moments+2B20and+2B20Mode_+3A_param">param</code></td>
<td>
<p>Parameter vector of the generalized inverse Gaussian
distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gigMean</code> gives the mean of the generalized inverse Gaussian
distribution, <code>gigVar</code> the variance, <code>gigSkew</code> the skewness,
<code>gigKurt</code> the kurtosis, and <code>gigMode</code> the mode. The formulae
used are as given in Jorgensen (1982),
pp. 13&ndash;17. Note that the kurtosis is the standardised fourth cumulant
or what is sometimes called the kurtosis excess. (See
<a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> for a discussion.)
</p>
<p>The parameterization used  for the generalized inverse Gaussian
distribution is the <code class="reqn">(\chi, \psi)</code> one (see
<code><a href="#topic+dgig">dgig</a></code>). To use another parameterization, use
<code><a href="#topic+gigChangePars">gigChangePars</a></code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Jorgensen, B. (1982).
<em>Statistical Properties of the Generalized Inverse Gaussian
Distribution</em>.
Lecture Notes in Statistics, Vol. 9, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgig">dgig</a></code>, <code><a href="#topic+gigChangePars">gigChangePars</a></code>,
<code><a href="base.html#topic+besselK">besselK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(5, 2.5, -0.5)
gigMean(param = param)
gigVar(param = param)
gigSkew(param = param)
gigKurt(param = param)
gigMode(param = param)
</code></pre>

<hr>
<h2 id='Specific+20Hyperbolic+20Distribution+20Moments+20and+20Mode'>Moments and Mode of the Hyperbolic Distribution</h2><span id='topic+hyperbMean'></span><span id='topic+hyperbVar'></span><span id='topic+hyperbSkew'></span><span id='topic+hyperbKurt'></span><span id='topic+hyperbMode'></span>

<h3>Description</h3>

<p>Functions to calculate the mean, variance, skewness, kurtosis and mode
of a specific hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbMean(mu = 0, delta = 1, alpha = 1, beta = 0,
           param = c(mu, delta, alpha, beta))
hyperbVar(mu = 0, delta = 1, alpha = 1, beta = 0,
          param = c(mu, delta, alpha, beta))
hyperbSkew(mu = 0, delta = 1, alpha = 1, beta = 0,
           param = c(mu, delta, alpha, beta))
hyperbKurt(mu = 0, delta = 1, alpha = 1, beta = 0,
           param = c(mu, delta, alpha, beta))
hyperbMode(mu = 0, delta = 1, alpha = 1, beta = 0,
           param = c(mu, delta, alpha, beta))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Specific+2B20Hyperbolic+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="Specific+2B20Hyperbolic+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>
<tr><td><code id="Specific+2B20Hyperbolic+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default value of 1.</p>
</td></tr>
<tr><td><code id="Specific+2B20Hyperbolic+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default this is 0.</p>
</td></tr>
<tr><td><code id="Specific+2B20Hyperbolic+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_param">param</code></td>
<td>
<p>Parameter vector of the hyperbolic distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formulae used for the mean, variance and mode are as given in
Barndorff-Nielsen and Blæsild (1983), p. 702.  The
formulae used for the skewness and kurtosis are those of
Barndorff-Nielsen and Blæsild (1981), Appendix 2. 
</p>
<p>Note that the variance, skewness and kurtosis can be obtained from the
functions for the generalized hyperbolic distribution as special
cases. Likewise other moments can be obtained from the function
<code><a href="#topic+ghypMom">ghypMom</a></code> which implements a recursive method to moments
of any desired order. Note that functions for the generalized
hyperbolic distribution use a different parameterization, so care is
required.
</p>


<h3>Value</h3>

<p><code>hyperbMean</code> gives the mean of the hyperbolic distribution,
<code>hyperbVar</code> the variance, <code>hyperbSkew</code> the skewness,
<code>hyperbKurt</code> the kurtosis and <code>hyperbMode</code> the mode.
</p>
<p>Note that the kurtosis is the standardised fourth cumulant or what is
sometimes called the kurtosis excess. (See
<a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> for a discussion.)
</p>
<p>The parameterization of the hyperbolic distribution used for this and
other components of the <code>GeneralizedHyperbolic</code> package is the
<code class="reqn">(\alpha, \beta)</code> one. See
<code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code> to transfer between parameterizations.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Richard Trendall,
Thomas Tran</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. and Blæsild, P (1981).
Hyperbolic distributions and ramifications: contributions to theory
and application.
In <em>Statistical Distributions in Scientific Work</em>,
eds., Taillie, C., Patil, G. P., and Baldessari, B. A., Vol. 4,
pp. 19&ndash;44. Dordrecht: Reidel.
</p>
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhyperb">dhyperb</a></code>, <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>,
<code><a href="base.html#topic+besselK">besselK</a></code>, <code><a href="#topic+ghypMom">ghypMom</a></code>, <code><a href="#topic+ghypMean">ghypMean</a></code>,
<code><a href="#topic+ghypVar">ghypVar</a></code>, <code><a href="#topic+ghypSkew">ghypSkew</a></code>, <code><a href="#topic+ghypKurt">ghypKurt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
hyperbMean(param = param)
hyperbVar(param = param)
hyperbSkew(param = param)
hyperbKurt(param = param)
hyperbMode(param = param)
</code></pre>

<hr>
<h2 id='Specific+20Normal+20Inverse+20Gaussian+20Distribution+20Moments+20and+20Mode'>Moments and Mode of the Normal Inverse Gaussian  Distribution</h2><span id='topic+nigMean'></span><span id='topic+nigVar'></span><span id='topic+nigSkew'></span><span id='topic+nigKurt'></span><span id='topic+nigMode'></span>

<h3>Description</h3>

<p>Functions to calculate the mean, variance, skewness, kurtosis and mode
of a specific normal inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigMean(mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
nigVar(mu = 0, delta = 1, alpha = 1, beta = 0,
       param = c(mu, delta, alpha, beta))
nigSkew(mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
nigKurt(mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
nigMode(mu = 0, delta = 1, alpha = 1, beta = 0,
        param = c(mu, delta, alpha, beta))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Specific+2B20Normal+2B20Inverse+2B20Gaussian+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> is the location parameter. By default this is
set to 0.</p>
</td></tr>
<tr><td><code id="Specific+2B20Normal+2B20Inverse+2B20Gaussian+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_delta">delta</code></td>
<td>
<p><code class="reqn">\delta</code> is the scale parameter of the distribution.
A default value of 1 has been set.</p>
</td></tr>  
<tr><td><code id="Specific+2B20Normal+2B20Inverse+2B20Gaussian+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">\alpha</code> is the tail parameter, with a default
value of 1.</p>
</td></tr> 
<tr><td><code id="Specific+2B20Normal+2B20Inverse+2B20Gaussian+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> is the skewness parameter, by default
this is 0.</p>
</td></tr>
<tr><td><code id="Specific+2B20Normal+2B20Inverse+2B20Gaussian+2B20Distribution+2B20Moments+2B20and+2B20Mode_+3A_param">param</code></td>
<td>
<p>Parameter vector of the normal inverse Gaussian
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean, variance, skewness, kurtosis and mode for the normal inverse
Gaussian distribution can be obtained from the functions for the
generalized hyperbolic distribution as special cases (i.e.,
<code class="reqn">\lambda</code> = -1/2).  Likewise other moments can be obtained
from the function <code><a href="#topic+ghypMom">ghypMom</a></code> which implements a recursive
method to moments of any desired order.
</p>
<p>The proper formulae for the mean, variance and skewness of the normal
inverse Gaussian distribution can be found in Paolella, Marc S. (2007), 
Chapter 9, p325.
</p>


<h3>Value</h3>

<p><code>nigMean</code> gives the mean of the normal inverse Gaussian distribution,
<code>nigVar</code> the variance, <code>nigSkew</code> the skewness,
<code>nigKurt</code> the kurtosis and <code>nigMode</code> the mode.
</p>
<p>Note that the kurtosis is the standardised fourth cumulant or what is
sometimes called the kurtosis excess. (See
<a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> for a discussion.)
</p>
<p>The parameterization of the normal inverse Gaussian distribution used
for this and other components of the <code>GeneralizedHyperbolic</code>
package is the <code class="reqn">(\alpha, \beta)</code> one. See
<code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code> to transfer between parameterizations.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Christine Yang Dong</p>


<h3>References</h3>

<p>Paolella, Marc S. (2007)
Intermediate Probability: A Computational Approach,
Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnig">dnig</a></code>, <code><a href="#topic+hyperbChangePars">hyperbChangePars</a></code>,
<code><a href="base.html#topic+besselK">besselK</a></code>, <code><a href="#topic+ghypMom">ghypMom</a></code>, <code><a href="#topic+ghypMean">ghypMean</a></code>,
<code><a href="#topic+ghypVar">ghypVar</a></code>, <code><a href="#topic+ghypSkew">ghypSkew</a></code>, <code><a href="#topic+ghypKurt">ghypKurt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- c(2, 2, 2, 1)
nigMean(param = param)
nigVar(param = param)
nigSkew(param = param)
nigKurt(param = param)
nigMode(param = param)
</code></pre>

<hr>
<h2 id='summary.gigFit'>Summarizing Normal Inverse Gaussian Distribution Fit</h2><span id='topic+summary.gigFit'></span><span id='topic+print.summary.gigFit'></span>

<h3>Description</h3>

<p><code>summary</code> Method for class <code>"gigFit"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gigFit'
summary(object, hessian = FALSE,
        hessianMethod = "tsHessian", ...)

## S3 method for class 'summary.gigFit'
print(x,
                               digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gigFit_+3A_object">object</code></td>
<td>
<p>An object of class <code>"gigFit"</code>, resulting from a call to
<code><a href="#topic+gigFit">gigFit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gigFit_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code> the Hessian is printed.</p>
</td></tr>
<tr><td><code id="summary.gigFit_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>The two-sided Hessian approximation given by
<code>tsHessian</code> from the package <code>DistributionUtils</code> is the
only method implemented so far.</p>
</td></tr>
<tr><td><code id="summary.gigFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.gigFit"</code>, resulting from
a call to <code>summary.gigFit</code>.</p>
</td></tr>
<tr><td><code id="summary.gigFit_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.gigFit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>hessian = FALSE</code> no calculations are performed, the class of
<code>object</code> is simply changed from <code>gigFit</code> to
<code>summary.gigFit</code> so that it can be passed to
<code>print.summary.gigFit</code> for printing in a convenient form.
</p>
<p>If <code>hessian = TRUE</code> the Hessian is calculated via a call to
<code><a href="#topic+gigHessian">gigHessian</a></code> and the standard errors of the parameter
estimates are calculated using the Hessian and these are added to the
original list <code>object</code>. The class of the object
returned is again changed to <code>summary.gigFit</code>.
</p>


<h3>Value</h3>

<p><code>summary.gigFit</code> returns a list comprised of the original
object <code>object</code> and additional elements <code>hessian</code> and
<code>sds</code> if <code>hessian = TRUE</code>, otherwise it returns the original
object. The class of the object returned is changed to
<code>summary.gigFit</code>.
</p>
<p>See <code><a href="#topic+gigFit">gigFit</a></code> for the composition of an object of class
<code>gigFit</code>.
</p>
<p>If the Hessian and standard errors have not been added to the object
<code>x</code>, <code>print.summary.gigFit</code> prints a summary in the same
format as <code><a href="#topic+print.gigFit">print.gigFit</a></code>. When the Hessian and standard
errors are available, the Hessian is printed and the standard errors
for the parameter estimates are printed in parentheses beneath the
parameter estimates, in the manner of <code>fitdistr</code> in the package
<code>MASS</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gigFit">gigFit</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code>gigHessian</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Continuing the  gigFit(.) example:
param &lt;- c(1,1,1)
dataVector &lt;- rgig(500, param = param)
fit &lt;- gigFit(dataVector)
print(fit)
summary(fit, hessian = TRUE, hessianMethod = "tsHessian")
</code></pre>

<hr>
<h2 id='summary.hyperbFit'>Summarizing Hyperbolic Distribution Fit</h2><span id='topic+summary.hyperbFit'></span><span id='topic+print.summary.hyperbFit'></span>

<h3>Description</h3>

<p><code>summary</code> Method for class <code>"hyperbFit"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperbFit'
summary(object, hessian = FALSE,
        hessianMethod = "exact", ...)

## S3 method for class 'summary.hyperbFit'
print(x,
                                  digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hyperbFit_+3A_object">object</code></td>
<td>
<p>An object of class <code>"hyperbFit"</code>, resulting from a call to
<code><a href="#topic+hyperbFit">hyperbFit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hyperbFit_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code> the Hessian is printed.</p>
</td></tr>
<tr><td><code id="summary.hyperbFit_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>Two methods are available to calculate the
Hessian exactly (<code>"exact"</code>) or approximately (<code>"tsHessian")</code>.</p>
</td></tr>
<tr><td><code id="summary.hyperbFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.hyperbFit"</code>, resulting from
a call to <code>summary.hyperbFit</code>.</p>
</td></tr>
<tr><td><code id="summary.hyperbFit_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.hyperbFit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>hessian = FALSE</code> no calculations are performed, the class of
<code>object</code> is simply changed from <code>hyperbFit</code> to
<code>summary.hyperbFit</code> so that it can be passed to
<code>print.summary.hyperbFit</code> for printing in a convenient form.
</p>
<p>If <code>hessian = TRUE</code> the Hessian is calculated via a call to
<code><a href="#topic+hyperbHessian">hyperbHessian</a></code> and the standard errors of the parameter
estimates are calculated using the Hessian and these are added to the
original list <code>object</code>. The class of the object
returned is again changed to <code>summary.hyperbFit</code>.
</p>


<h3>Value</h3>

<p><code>summary.hyperbFit</code> returns a list comprised of the original
object <code>object</code> and additional elements <code>hessian</code> and
<code>sds</code> if <code>hessian = TRUE</code>, otherwise it returns the original
object. The class of the object returned is changed to
<code>summary.hyperbFit</code>.
</p>
<p>See <code><a href="#topic+hyperbFit">hyperbFit</a></code> for the composition of an object of class
<code>hyperbFit</code>.
</p>
<p>If the Hessian and standard errors have not been added to the object
<code>x</code>, <code>print.summary.hyperbFit</code> prints a summary in the same
format as <code><a href="#topic+print.hyperbFit">print.hyperbFit</a></code>. When the Hessian and standard
errors are available, the Hessian is printed and the standard errors
for the parameter estimates are printed in parentheses beneath the
parameter estimates, in the manner of <code>fitdistr</code> in the package
<code>MASS</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperbFit">hyperbFit</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+hyperbHessian">hyperbHessian</a></code>, <code><a href="DistributionUtils.html#topic+tsHessian">tsHessian</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Continuing the  hyperbFit(.) example:
param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rhyperb(500, param = param)
fit &lt;- hyperbFit(dataVector, method = "BFGS")
print(fit)
summary(fit, hessian = TRUE)
</code></pre>

<hr>
<h2 id='summary.hyperblm'>Summary Output of Hyperbolic Regression</h2><span id='topic+summary.hyperblm'></span><span id='topic+print.summary.hyperblm'></span>

<h3>Description</h3>

<p>It obtains summary output from class 'hyperblm' object. The summary
output incldes the standard error, t-statistics, p values of the
coefficients estimates. Also the estimated parameters of hyperbolic
error distribution, the maximum likelihood, the stage one optimization
method, the two-stage alternating iterations and the convergence code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperblm'
summary(object, hessian = FALSE,
                           nboots = 1000, ...)

## S3 method for class 'summary.hyperblm'
print(x,
                                 digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hyperblm_+3A_object">object</code></td>
<td>
<p>An object of class <code>"hyperblm"</code>.</p>
</td></tr>
<tr><td><code id="summary.hyperblm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.hyperblm"</code> resulting from a
call to <code>summary.hyperblm</code>.</p>
</td></tr>
<tr><td><code id="summary.hyperblm_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If is <code>TRUE</code>, the standard error is
calculated by the hessian matrix and the also hessian matrix is
returned. Otherwise, the standard error is approximated by
bootstrapping. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="summary.hyperblm_+3A_nboots">nboots</code></td>
<td>
<p>Numeric. Number of bootstrap simulations to obtain the
bootstrap estimate of parameters standard errors.</p>
</td></tr>
<tr><td><code id="summary.hyperblm_+3A_digits">digits</code></td>
<td>
<p>Numeric. Desired number of digits when the object is
printed.</p>
</td></tr>
<tr><td><code id="summary.hyperblm_+3A_...">...</code></td>
<td>
<p>Passes additional arguments to functions <code>bSE</code>,
<code>hyperblmhessian</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.hyperblm</code> provides two approaches to obtain
the standard error of parameters due to the fact that approximated
hessian matrix is not stable for such complex optimization. The first
approach is by approximated hessian matrix. The setting in the
argument list is <code>hessian = TRUE</code>. The Hessian matrix is
approximated by function <code><a href="DistributionUtils.html#topic+tsHessian">tsHessian</a></code>. However it may not
be reliable for some error distribution parameters, for instance, the
function obtains negative variance from the Hessian matrix. The second
approach is by parametric bootstrapping. The setting in the argument
list is <code>hessian = FALSE</code> which is also the default setting. The
default number of bootstrap stimulations is 1000, but users can
increase this when accuracy has priority over efficiency. Although the
bootstrapping is fairly slow, it provides reliable standard errors.
</p>


<h3>Value</h3>

<p><code>summary.hyperblm</code> returns an object of class
<code>summary.hyperblm</code> which is a list containing:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>A names vector of regression coefficients.</p>
</td></tr>
<tr><td><code>distributionParams</code></td>
<td>
<p>A named vector of fitted hyperbolic error
distribution parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted mean values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The remaining after subtract fitted values from
response.</p>
</td></tr>
<tr><td><code>MLE</code></td>
<td>
<p>The maximum likelihood value of the model.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The optimization method for stage one.</p>
</td></tr>
<tr><td><code>paramStart</code></td>
<td>
<p>The start values of parameters that the user specified
(only where relevant).</p>
</td></tr>
<tr><td><code>residsParamStart</code></td>
<td>
<p>The start values of parameters returned by
<code>hyperbFitStand</code> (only where relevant).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The <code>terms</code> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>The contrasts used (only where relevant).</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>The levels of the factors used in the fitting (only where
relevant).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>The offset used (only where relevant).</p>
</td></tr>
<tr><td><code>xNames</code></td>
<td>
<p>The names of each explanatory variables. If explanatory
variables don't have names then they shall be named <code>x</code>.</p>
</td></tr>
<tr><td><code>yVec</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code>xMatrix</code></td>
<td>
<p>The explanatory variables matrix.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of two-stage alternating iterations to
convergency.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>The convergence code for two-stage optimization: 0
if the system converged; 1 if first stage did not converge, 2 if the
second stage did not converge, 3 if the both stages did not converge.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>The cell boundaries found by a call the
<code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian Matrix. Only where <code>Hessian = TRUE</code>.</p>
</td></tr>
<tr><td><code>tval</code></td>
<td>
<p><em>t</em>-statistics of regression coefficient estimates.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>P-values of regression coefficients estimates.</p>
</td></tr>
<tr><td><code>sds</code></td>
<td>
<p>Standard errors of regression coefficient estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Xinxing Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977). Exponentially Decreasing Distribution
for the Logarithm of Particle Size.
In <em>Proceedings of the Royal Society of London. Series A,
Mathematical and Physical Sciences</em>, Vol. 353, pp. 401&ndash;419.
</p>
<p>Prause, K. (1999). <em>The generalized hyperbolic models:
Estimation, financial derivatives and risk measurement</em>.
PhD Thesis, Mathematics Faculty, University of Freiburg.
</p>
<p>Trendall, Richard (2005). <em>hypReg: A Function for Fitting a
Linear Regression Model in R with Hyperbolic Error</em>.
Masters Thesis, Statistics Faculty, University of Auckland.
</p>
<p>Paolella, Marc S. (2007). <em>Intermediate Probability: A
Compitational Approach</em>.
pp. 415 -Chichester: Wiley.
</p>
<p>Scott, David J. and Wurtz, Diethelm and Chalabi, Yohan,
(2011). <em>Fitting the Hyperbolic Distribution with R: A Case Study
of Optimization Techniques</em>.
In preparation.
</p>
<p>Stryhn, H. and Christensen, J. (2003). <em>Confidence intervals by
the profile likelihood method, with applications in veterinary
epidemiology</em>. ISVEE X.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.summary.hyperblm">print.summary.hyperblm</a></code> prints the summary output in a
table.
<code><a href="#topic+hyperblm">hyperblm</a></code> fits linear model with hyperbolic
error distribution.
<code><a href="#topic+print.hyperblm">print.hyperblm</a></code> prints the regression result in a table.
<code><a href="#topic+coef.hyperblm">coef.hyperblm</a></code> obtains the regression coefficients and
error distribution parameters of the fitted model.
<code><a href="#topic+plot.hyperblm">plot.hyperblm</a></code> obtains a residual vs fitted value plot, a
histgram of residuals with error distribution density curve on top, a
histgram of log residuals with error distribution error density curve
on top and a QQ plot.
<code><a href="DistributionUtils.html#topic+tsHessian">tsHessian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## stackloss data example

# airflow &lt;- stackloss[, 1]
# temperature &lt;- stackloss[, 2]
# acid &lt;- stackloss[, 3]
# stack &lt;- stackloss[, 4]

# hyperblm.fit &lt;- hyperblm(stack ~ airflow + temperature + acid,
#                          tolerance = 1e-11)

# coef.hyperblm(hyperblm.fit)
# plot.hyperblm(hyperblm.fit, breaks = 20)
# summary.hyperblm(hyperblm.fit, hessian = FALSE)

</code></pre>

<hr>
<h2 id='summary.nigFit'>Summarizing Normal Inverse Gaussian Distribution Fit</h2><span id='topic+summary.nigFit'></span><span id='topic+print.summary.nigFit'></span>

<h3>Description</h3>

<p><code>summary</code> Method for class <code>"nigFit"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nigFit'
summary(object, hessian = FALSE,
        hessianMethod = "tsHessian", ...)

## S3 method for class 'summary.nigFit'
print(x,
                               digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nigFit_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nigFit"</code>, resulting from a call to
<code><a href="#topic+nigFit">nigFit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.nigFit_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code> the Hessian is printed.</p>
</td></tr>
<tr><td><code id="summary.nigFit_+3A_hessianmethod">hessianMethod</code></td>
<td>
<p>The two-sided Hessian approximation given by
<code>tsHessian</code> from the package <code>DistributionUtils</code> is the
only method implemented so far.</p>
</td></tr>
<tr><td><code id="summary.nigFit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.nigFit"</code>, resulting from
a call to <code>summary.nigFit</code>.</p>
</td></tr>
<tr><td><code id="summary.nigFit_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.nigFit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>hessian = FALSE</code> no calculations are performed, the class of
<code>object</code> is simply changed from <code>nigFit</code> to
<code>summary.nigFit</code> so that it can be passed to
<code>print.summary.nigFit</code> for printing in a convenient form.
</p>
<p>If <code>hessian = TRUE</code> the Hessian is calculated via a call to
<code><a href="#topic+nigHessian">nigHessian</a></code> and the standard errors of the parameter
estimates are calculated using the Hessian and these are added to the
original list <code>object</code>. The class of the object
returned is again changed to <code>summary.nigFit</code>.
</p>


<h3>Value</h3>

<p><code>summary.nigFit</code> returns a list comprised of the original
object <code>object</code> and additional elements <code>hessian</code> and
<code>sds</code> if <code>hessian = TRUE</code>, otherwise it returns the original
object. The class of the object returned is changed to
<code>summary.nigFit</code>.
</p>
<p>See <code><a href="#topic+nigFit">nigFit</a></code> for the composition of an object of class
<code>nigFit</code>.
</p>
<p>If the Hessian and standard errors have not been added to the object
<code>x</code>, <code>print.summary.nigFit</code> prints a summary in the same
format as <code><a href="#topic+print.nigFit">print.nigFit</a></code>. When the Hessian and standard
errors are available, the Hessian is printed and the standard errors
for the parameter estimates are printed in parentheses beneath the
parameter estimates, in the manner of <code>fitdistr</code> in the package
<code>MASS</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nigFit">nigFit</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code>nigHessian</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Continuing the  nigFit(.) example:
param &lt;- c(2, 2, 2, 1)
dataVector &lt;- rnig(500, param = param)
fit &lt;- nigFit(dataVector, method = "BFGS")
print(fit)
summary(fit, hessian = TRUE, hessianMethod = "tsHessian")
</code></pre>

<hr>
<h2 id='traffic'>Intervals Between Vehicles on a Road</h2><span id='topic+traffic'></span>

<h3>Description</h3>

<p>Intervals between the times that 129 successive vehicles pass a point
on a road, measured in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(traffic)</code></pre>


<h3>Format</h3>

<p>The <code>traffic</code> data is a vector of 128 observations.
</p>


<h3>Source</h3>

<p>Bartlett, M.S. (1963)
Statistical estimation of density functions
<em>Sankhya: The Indian Journal of Statistics</em>,
<b>Series A, Vol. 25, No. 3</b>, 245&ndash;254.
</p>
<p>Jörgensen, B. (1982)
Statistical Properties of the Generalized Inverse Gaussian Distribution.
<em>Lecture Notes in Statistics, Vol. 9, Springer-Verlag, New York</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(traffic)
str(traffic)

### Fit the generalized inverse Gaussian distribution
gigFit(traffic)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
