<!DOCTYPE html><html><head><title>Help for package adaptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adaptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptr-package'><p>adaptr: Adaptive Trial Simulator</p></a></li>
<li><a href='#assert_pkgs'><p>Check availability of required packages</p></a></li>
<li><a href='#calculate_idp'><p>Calculate the ideal design percentage</p></a></li>
<li><a href='#calibrate_trial'><p>Calibrate trial specification</p></a></li>
<li><a href='#cat0'><p>cat() with sep = &quot;&quot;</p></a></li>
<li><a href='#check_performance'><p>Check performance metrics for trial simulations</p></a></li>
<li><a href='#check_remaining_arms'><p>Check remaining arm combinations</p></a></li>
<li><a href='#cov_mat'><p>Estimates covariance matrices used by Gaussian process optimisation</p></a></li>
<li><a href='#dispatch_trial_runs'><p>Simulate single trial after setting seed</p></a></li>
<li><a href='#equivalent_funs'><p>Assert equivalent functions</p></a></li>
<li><a href='#extract_history'><p>Extract history</p></a></li>
<li><a href='#extract_results'><p>Extract simulation results</p></a></li>
<li><a href='#extract_results_batch'><p>Extract results from a batch of trials from an object with multiple trials</p></a></li>
<li><a href='#extract_statuses'><p>Extract statuses</p></a></li>
<li><a href='#find_beta_params'><p>Find beta distribution parameters from thresholds</p></a></li>
<li><a href='#fmt_dig'><p>Format digits before printing</p></a></li>
<li><a href='#fmt_pct'><p>Create formatted label with absolute and relative frequencies (percentages)</p></a></li>
<li><a href='#get_draws_binom'><p>Generate draws from posterior beta-binomial distributions</p></a></li>
<li><a href='#get_draws_generic'><p>Generic documentation for get_draws_* functions</p></a></li>
<li><a href='#get_draws_norm'><p>Generate draws from posterior normal distributions</p></a></li>
<li><a href='#get_ys_binom'><p>Generate binary outcomes from binomial distributions</p></a></li>
<li><a href='#get_ys_norm'><p>Generate normally distributed continuous outcomes</p></a></li>
<li><a href='#gp_opt'><p>Gaussian process-based optimisation</p></a></li>
<li><a href='#make_x_scale'><p>Make x-axis scale for history/status plots</p></a></li>
<li><a href='#make_y_scale'><p>Make y-axis scale for history/status plots</p></a></li>
<li><a href='#plot_convergence'><p>Plot convergence of performance metrics</p></a></li>
<li><a href='#plot_history'><p>Plot trial metric history</p></a></li>
<li><a href='#plot_metrics_ecdf'><p>Plot empirical cumulative distribution functions of performance metrics</p></a></li>
<li><a href='#plot_status'><p>Plot statuses</p></a></li>
<li><a href='#pow_abs_dist'><p>Calculates matrix of absolute distances raised to a power</p></a></li>
<li><a href='#print'><p>Print methods for adaptive trial objects</p></a></li>
<li><a href='#prob_all_equi'><p>Calculate the probability that all arms are practically equivalent</p></a></li>
<li><a href='#prob_best'><p>Calculate the probabilities of each arm being the best</p></a></li>
<li><a href='#prob_better'><p>Calculate probabilities of comparisons of arms against with common control</p></a></li>
<li><a href='#prog_breaks'><p>Generate breakpoints and other values for printing progress</p></a></li>
<li><a href='#reallocate_probs'><p>Update allocation probabilities</p></a></li>
<li><a href='#replace_nonfinite'><p>Replace non-finite values with other value (finite-OR-operator)</p></a></li>
<li><a href='#replace_null'><p>Replace NULL with other value (NULL-OR-operator)</p></a></li>
<li><a href='#rescale'><p>Rescale numeric vector to sum to 1</p></a></li>
<li><a href='#run_trial'><p>Simulate a single trial</p></a></li>
<li><a href='#run_trials'><p>Simulate multiple trials</p></a></li>
<li><a href='#setup_cluster'><p>Setup default cluster for use in parallelised adaptr functions</p></a></li>
<li><a href='#setup_trial'><p>Setup a generic trial specification</p></a></li>
<li><a href='#setup_trial_binom'><p>Setup a trial specification using a binary, binomially distributed outcome</p></a></li>
<li><a href='#setup_trial_norm'><p>Setup a trial specification using a continuous, normally distributed outcome</p></a></li>
<li><a href='#stop0_warning0'><p>stop() and warning() with call. = FALSE</p></a></li>
<li><a href='#summarise_dist'><p>Summarise distribution</p></a></li>
<li><a href='#summarise_num'><p>Summarise numeric vector</p></a></li>
<li><a href='#summary'><p>Summary of simulated trial results</p></a></li>
<li><a href='#update_saved_trials'><p>Update previously saved simulation results</p></a></li>
<li><a href='#validate_trial'><p>Validate trial specification</p></a></li>
<li><a href='#vapply_helpers'><p>vapply helpers</p></a></li>
<li><a href='#verify_int'><p>Verify input is single integer (potentially within range)</p></a></li>
<li><a href='#which_nearest'><p>Find the index of value nearest to a target value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Adaptive Trial Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Package that simulates adaptive (multi-arm, multi-stage) clinical
    trials using adaptive stopping, adaptive arm dropping, and/or adaptive
    randomisation. Developed as part of the INCEPT (Intensive Care Platform
    Trial) project (<a href="https://incept.dk/">https://incept.dk/</a>), which is primarily supported by a
    grant from Sygeforsikringen "danmark" (<a href="https://www.sygeforsikring.dk/">https://www.sygeforsikring.dk/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, parallel, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://inceptdk.github.io/adaptr/">https://inceptdk.github.io/adaptr/</a>,
<a href="https://github.com/INCEPTdk/adaptr/">https://github.com/INCEPTdk/adaptr/</a>, <a href="https://incept.dk/">https://incept.dk/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/INCEPTdk/adaptr/issues/">https://github.com/INCEPTdk/adaptr/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, covr, rmarkdown, knitr, testthat, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 11:52:50 UTC; agra0037</td>
</tr>
<tr>
<td>Author:</td>
<td>Anders Granholm <a href="https://orcid.org/0000-0001-5799-7655"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Benjamin Skov Kaas-Hansen
    <a href="https://orcid.org/0000-0003-1023-0371"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Aksel Karl Georg Jensen
    <a href="https://orcid.org/0000-0002-1459-0465"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Theis Lange <a href="https://orcid.org/0000-0001-6807-8347"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anders Granholm &lt;andersgran@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 12:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptr-package'>adaptr: Adaptive Trial Simulator</h2><span id='topic+adaptr-package'></span><span id='topic+adaptr'></span>

<h3>Description</h3>


<p><img src="../help/figures/adaptr.png" width="120" alt="logo" />
<em>Adaptive Trial Simulator</em>

</p>
<p>The <code>adaptr</code> package simulates adaptive (multi-arm, multi-stage) randomised
clinical trials using adaptive stopping, adaptive arm dropping and/or
response-adaptive randomisation. The package is developed as part of the
<a href="https://incept.dk/">INCEPT (Intensive Care Platform Trial) project</a>,
funded primarily by a grant from
<a href="https://www.sygeforsikring.dk/">Sygeforsikringen &quot;danmark&quot;</a>.
</p>


<h3>Details</h3>

<p>The <code>adaptr</code> package contains the following primary functions (in order of
typical use):
</p>

<ol>
<li><p> The <code><a href="#topic+setup_cluster">setup_cluster()</a></code> initiates a parallel computation cluster that can
be used to run simulations and post-processing in parallel, increasing speed.
Details on parallelisation and other options for running <code>adaptr</code>
functions in parallel are described in the <code><a href="#topic+setup_cluster">setup_cluster()</a></code> documentation.
</p>
</li>
<li><p> The <code><a href="#topic+setup_trial">setup_trial()</a></code> function is the general function that sets up a trial
specification. The simpler, special-case functions <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> may be used for easier specification of trial designs
using binary, binomially distributed or continuous, normally distributed
outcomes, respectively, with some limitations in flexibility.
</p>
</li>
<li><p> The <code><a href="#topic+calibrate_trial">calibrate_trial()</a></code> function calibrates a trial specification to
obtain a certain value for a performance metric (typically used to calibrate
the Bayesian type 1 error rate in a scenario with no between-arm
differences), using the functions below.
</p>
</li>
<li><p> The <code><a href="#topic+run_trial">run_trial()</a></code> and <code><a href="#topic+run_trials">run_trials()</a></code> functions are used to conduct single
or multiple simulations, respectively, according to a trial specification
setup as described in #2.
</p>
</li>
<li><p> The <code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+check_performance">check_performance()</a></code> and <code><a href="#topic+summary">summary()</a></code> functions
are used to extract results from multiple trial simulations, calculate
performance metrics, and summarise results. The <code><a href="#topic+plot_convergence">plot_convergence()</a></code> function
assesses stability of performance metrics according to the number of
simulations conducted. The <code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code> function plots empirical
cumulative distribution functions for numerical performance metrics. The
<code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code> function summarises all combinations of remaining
arms across multiple trials simulations.
</p>
</li>
<li><p> The <code><a href="#topic+plot_status">plot_status()</a></code> and <code><a href="#topic+plot_history">plot_history()</a></code> functions are used to plot the
overall trial/arm statuses for multiple simulated trials or the history of
trial metrics over time for single/multiple simulated trials, respectively.
</p>
</li></ol>

<p>For further information see the documentation of each function or the
<strong>Overview</strong> vignette (<code>vignette("Overview", package = "adaptr")</code>) for an
example of how the functions work in combination.
For further examples and guidance on setting up trial specifications, see the
<code><a href="#topic+setup_trial">setup_trial()</a></code> documentation, the <strong>Basic examples</strong> vignette
(<code>vignette("Basic-examples", package = "adaptr")</code>) and the
<strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>).
</p>
<p>If using the package, please consider citing it using
<code>citation(package = "adaptr")</code>.
</p>


<h3>References</h3>

<p>Granholm A, Jensen AKG, Lange T, Kaas-Hansen BS (2022). adaptr: an R package
for simulating and comparing adaptive clinical trials. Journal of Open Source
Software, 7(72), 4284. <a href="https://doi.org/10.21105/joss.04284">doi:10.21105/joss.04284</a>
</p>
<p>Granholm A, Kaas-Hansen BS, Lange T, Schjørring OL, Andersen LW, Perner A,
Jensen AKG, Møller MH (2022). An overview of methodological considerations
regarding adaptive stopping, arm dropping and randomisation in clinical
trials. J Clin Epidemiol. <a href="https://doi.org/10.1016/j.jclinepi.2022.11.002">doi:10.1016/j.jclinepi.2022.11.002</a>
</p>
<p><a href="https://inceptdk.github.io/adaptr/">Website/manual</a>
</p>
<p><a href="https://github.com/INCEPTdk/adaptr/">GitHub repository</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup_cluster">setup_cluster()</a></code>, <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>,
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>, <code><a href="#topic+calibrate_trial">calibrate_trial()</a></code>, <code><a href="#topic+run_trial">run_trial()</a></code>, <code><a href="#topic+run_trials">run_trials()</a></code>,
<code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>,
<code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>, <code><a href="#topic+plot_convergence">plot_convergence()</a></code>, <code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code>,
<code><a href="#topic+print">print()</a></code>, <code><a href="#topic+plot_status">plot_status()</a></code>, <code><a href="#topic+plot_history">plot_history()</a></code>.
</p>

<hr>
<h2 id='assert_pkgs'>Check availability of required packages</h2><span id='topic+assert_pkgs'></span>

<h3>Description</h3>

<p>Used internally, helper function to check if SUGGESTED packages are
available. Will halt execution if any of the queried packages are not
available and provide installation instructions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_pkgs(pkgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_pkgs_+3A_pkgs">pkgs</code></td>
<td>
<p>character vector with name(s) of package(s) to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all packages available, otherwise execution is halted with
an error.
</p>

<hr>
<h2 id='calculate_idp'>Calculate the ideal design percentage</h2><span id='topic+calculate_idp'></span>

<h3>Description</h3>

<p>Used internally by <code><a href="#topic+check_performance">check_performance()</a></code>, calculates the ideal design
percentage as described in that function's documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_idp(sels, arms, true_ys, highest_is_best)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_idp_+3A_sels">sels</code></td>
<td>
<p>a character vector specifying the selected arms (according to the
selection strategies described in <code><a href="#topic+extract_results">extract_results()</a></code>).</p>
</td></tr>
<tr><td><code id="calculate_idp_+3A_arms">arms</code></td>
<td>
<p>character vector with unique names for the trial arms.</p>
</td></tr>
<tr><td><code id="calculate_idp_+3A_true_ys">true_ys</code></td>
<td>
<p>numeric vector specifying true outcomes (e.g., event
probabilities, mean values, etc.) for all trial <code>arms</code>.</p>
</td></tr>
<tr><td><code id="calculate_idp_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value between <code>0</code> and <code>100</code> corresponding to the
ideal design percentage.
</p>

<hr>
<h2 id='calibrate_trial'>Calibrate trial specification</h2><span id='topic+calibrate_trial'></span>

<h3>Description</h3>

<p>This function calibrates a trial specification using a Gaussian process-based
Bayesian optimisation algorithm.
The function calibrates an input trial specification object (using repeated
calls to <code><a href="#topic+run_trials">run_trials()</a></code> while adjusting the trial specification) to a
<code>target</code> value within a <code>search_range</code> in a single input dimension (<code>x</code>) in
order to find an optimal value (<code>y</code>).<br />
The default (and expectedly most common use case) is to calibrate a trial
specification to adjust the <code>superiority</code> and <code>inferiority</code> thresholds to
obtain a certain probability of superiority; if used with a trial
specification with identical underlying outcomes (no between-arm
differences), this probability is an estimate of the Bayesian analogue of the
total type-1 error rate for the outcome driving the adaptations, and if
between-arm differences are present, this corresponds to an estimate of the
Bayesian analogue of the power.<br />
The default is to perform the calibration while varying single, constant,
symmetric thresholds for <code>superiority</code> / <code>inferiority</code> throughout a trial
design, as described in <strong>Details</strong>, and the default values have been chosen
to function well in this case.<br />
Advanced users may use the function to calibrate trial specifications
according to other metrics - see <strong>Details</strong> for how to specify a custom
function used to modify (or recreate) a trial specification object during
the calibration process.<br />
The underlying Gaussian process model and its control hyperparameters are
described under <strong>Details</strong>, and the model is partially based on code from
Gramacy 2020 (with permission; see <strong>References</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_trial(
  trial_spec,
  n_rep = 1000,
  cores = NULL,
  base_seed = NULL,
  fun = NULL,
  target = 0.05,
  search_range = c(0.9, 1),
  tol = target/10,
  dir = 0,
  init_n = 2,
  iter_max = 25,
  resolution = 5000,
  kappa = 0.5,
  pow = 1.95,
  lengthscale = 1,
  scale_x = TRUE,
  noisy = is.null(base_seed),
  narrow = !noisy &amp; !is.null(base_seed),
  prev_x = NULL,
  prev_y = NULL,
  path = NULL,
  overwrite = FALSE,
  version = NULL,
  compress = TRUE,
  sparse = TRUE,
  progress = NULL,
  export = NULL,
  export_envir = parent.frame(),
  verbose = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_trial_+3A_trial_spec">trial_spec</code></td>
<td>
<p><code>trial_spec</code> object, generated and validated by the
<code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> function.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_n_rep">n_rep</code></td>
<td>
<p>single integer, the number of simulations to run at each
evaluation. Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not permitted; values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> are permitted
but recommended against.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value/cluster set
by <code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether simulations are run in
parallel on a default cluster or sequentially in the main process; if a
cluster/value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>, <code>cores</code> will
then be set to the value stored in the global <code>"mc.cores"</code> option (if
previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and <code>1</code> if that
option has not been specified.<br />
If the resulting number of <code>cores = 1</code>, computations will be run
sequentially in the primary process, and if <code>cores &gt; 1</code>, a new parallel
cluster will be setup using the <code>parallel</code> library and removed once the
function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_base_seed">base_seed</code></td>
<td>
<p>single integer or <code>NULL</code> (default); the random seed used as
the basis for all simulation runs (see <code><a href="#topic+run_trials">run_trials()</a></code>) and random number
generation within the rest of the calibration process; if used, the global
random seed will be restored after the function has been run.<br />
<strong>Note:</strong> providing a <code>base_seed</code> is highly recommended, as this will
generally lead to faster and more stable calibration.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_fun">fun</code></td>
<td>
<p><code>NULL</code> (the default), in which case the trial specification will
be calibrated using the default process described above and further in
<strong>Details</strong>; otherwise a user-supplied function used during the calibration
process, which should have a structure as described in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_target">target</code></td>
<td>
<p>single finite numeric value (defaults to <code>0.05</code>); the target
value for <code>y</code> to calibrate the <code>trial_spec</code> object to.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_search_range">search_range</code></td>
<td>
<p>finite numeric vector of length <code>2</code>; the lower and upper
boundaries in which to search for the best <code>x</code>. Defaults to <code>c(0.9, 1.0)</code>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_tol">tol</code></td>
<td>
<p>single finite numeric value (defaults to <code>target / 10</code>); the
accepted tolerance (in the direction(s) specified by <code>dir</code>) accepted; when
a <code>y</code>-value within the accepted tolerance of the target is obtained, the
calibration stops.<br />
<strong>Note:</strong> <code>tol</code> should be specified to be sensible considering <code>n_rep</code>;
e.g., if the probability of superiority is targeted with <code>n_rep == 1000</code>, a
<code>tol</code> of <code>0.01</code> will correspond to <code>10</code> simulated trials.<br />
A too low <code>tol</code> relative to <code>n_rep</code> may lead to very slow calibration or
calibration that cannot succeed regardless of the number of iterations.<br />
<strong>Important:</strong> even when a large number of simulations are conducted,
using a very low <code>tol</code> may lead to calibration not succeeding as it may
also be affected by other factors, e.g., the total number of simulated
patients, the possible maximum differences in simulated outcomes, and the
number of posterior draws (<code>n_draws</code> in the <code><a href="#topic+setup_trial">setup_trial()</a></code> family of
functions), which affects the minimum differences in posterior
probabilities when simulating trials and thus can affect calibration,
including when using the default calibration function. Increasing the
number of posterior draws or the number of repetitions should be attempted
if the desired tolerance cannot be achieved with lower numbers.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_dir">dir</code></td>
<td>
<p>single numeric value; specifies the direction(s) of the tolerance
range. If <code>0</code> (the default) the tolerance range will be <code>target - tol</code> to
<code>target + tol</code>. If <code style="white-space: pre;">&#8288;&lt; 0&#8288;</code>, the range will be <code>target - tol</code> to <code>target</code>, and
if <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>, the range will be <code>target</code> to <code>target + tol</code>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_init_n">init_n</code></td>
<td>
<p>single integer <code style="white-space: pre;">&#8288;&gt;= 2&#8288;</code>. The number of initial evaluations
evenly spread over the <code>search_range</code>, with one evaluation at each boundary
(thus, the default value of <code>2</code> is the minimum permitted value; if
calibrating according to a different target than the default, a higher
value may be sensible).</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_iter_max">iter_max</code></td>
<td>
<p>single integer <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (default <code>25</code>). The maximum number of
new evaluations after the initial grid (with size specified by <code>init_n</code>)
has been set up. If calibration is unsuccessful after the maximum number
of iterations, the <code>prev_x</code> and <code>prev_y</code> arguments (described below) may be
used to to start a new calibration process re-using previous evaluations.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_resolution">resolution</code></td>
<td>
<p>single integer (defaults to <code>5000</code>), size of the grid at
which the predictions used to select the next value to evaluate at are
made.<br />
<strong>Note:</strong> memory use will substantially increase with higher values. See
also the <code>narrow</code> argument below.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_kappa">kappa</code></td>
<td>
<p>single numeric value <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (default <code>0.5</code>); corresponding to the
width of the uncertainty bounds used to find the next target to evaluate.
See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_pow">pow</code></td>
<td>
<p>single numerical value in the <code style="white-space: pre;">&#8288;[1, 2]&#8288;</code> range (default <code>1.95</code>),
controlling the smoothness of the Gaussian process. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_lengthscale">lengthscale</code></td>
<td>
<p>single numerical value (defaults to <code>1</code>) or numerical
vector of length <code>2</code>; values must be finite and non-negative. If a single
value is provided, this will be used as the <code>lengthscale</code> hyperparameter;
if a numerical vector of length <code>2</code> is provided, the second value must be
higher than the first and the optimal <code>lengthscale</code> in this range will be
found using an optimisation algorithm. If any value is <code>0</code>, a small amount
of noise will be added as lengthscales must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>. Controls smoothness
in combination with <code>pow</code>. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_scale_x">scale_x</code></td>
<td>
<p>single logical value; if <code>TRUE</code> (the default) the <code>x</code>-values
will be scaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> range according to the minimum/maximum
values provided. If <code>FALSE</code>, the model will use the original scale. If
distances on the original scale are small, scaling may be preferred. The
returned values will always be on the original scale. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_noisy">noisy</code></td>
<td>
<p>single logical value; if <code>FALSE</code>, a noiseless process is
assumed, and interpolation between values is performed (i.e., with no
uncertainty at the <code>x</code>-values assumed). If <code>TRUE</code>, the <code>y</code>-values are
assumed to come from a noisy process, and regression is performed (i.e.,
some uncertainty at the evaluated <code>x</code>-values will be assumed and included
in the predictions). Specifying <code>FALSE</code> requires a <code>base_seed</code> supplied,
and is generally recommended, as this will usually lead to faster and more
stable calibration. If a low <code>n_rep</code> is used (or if trials are calibrated
to other metrics other than the default), specifying <code>TRUE</code> may be
necessary even when using a valid <code>base_seed</code>. Defaults to <code>TRUE</code> if a
<code>base_seed</code> is supplied and <code>FALSE</code> if not.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_narrow">narrow</code></td>
<td>
<p>single logical value. If <code>FALSE</code>, predictions are evenly spread
over the full <code>x</code>-range. If <code>TRUE</code>, the prediction grid will be spread
evenly over an interval consisting of the two <code>x</code>-values with
corresponding <code>y</code>-values closest to the target in opposite directions. Can
only be <code>TRUE</code> when a <code>base_seed</code> is provided and <code>noisy</code> is <code>FALSE</code> (the
default value is <code>TRUE</code> in that case, otherwise it is <code>FALSE</code>), and only if
the function can safely be assumed to be only monotonically increasing or
decreasing (which is generally reasonable if the default is used for
<code>fun</code>), in which case this will lead to a faster search and a smoother
prediction grid in the relevant region without increasing memory use.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_prev_x">prev_x</code>, <code id="calibrate_trial_+3A_prev_y">prev_y</code></td>
<td>
<p>numeric vectors of equal lengths, corresponding to
previous evaluations. If provided, these will be used in the calibration
process (added before the initial grid is setup, with values in the grid
matching values in <code>prev_x</code> leading to those evaluations being skipped).</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_path">path</code></td>
<td>
<p>single character string or <code>NULL</code> (the default); if a valid file
path is provided, the calibration results will either be saved to this path
(if the file does not exist or if <code>overwrite</code> is <code>TRUE</code>, see below) or the
previous results will be loaded and returned (if the file exists,
<code>overwrite</code> is <code>FALSE</code>, and if the input <code>trial_spec</code> and central control
settings are identical to the previous run, otherwise an error is
produced). Results are saved/loaded using the <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> / <code><a href="base.html#topic+readRDS">readRDS()</a></code>
functions.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_overwrite">overwrite</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>, in which case previous
results are loaded if a valid file path is provided in <code>path</code> and the
object in <code>path</code> contains the same input <code>trial_spec</code> and the previous
calibration used the same central control settings (otherwise, the function
errors). If <code>TRUE</code> and a valid file path is provided in <code>path</code>, the
complete calibration function will be run with results saved using
<code><a href="base.html#topic+saveRDS">saveRDS()</a></code>, regardless of whether or not a previous result was saved
in <code>path</code>.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_version">version</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving calibration results,
defaults to <code>NULL</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), which means that the current
default version is used. Ignored if calibration results are not saved.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_compress">compress</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving calibration results,
defaults to <code>TRUE</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), see <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> for other options.
Ignored if calibration results are not saved.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_sparse">sparse</code>, <code id="calibrate_trial_+3A_progress">progress</code>, <code id="calibrate_trial_+3A_export">export</code>, <code id="calibrate_trial_+3A_export_envir">export_envir</code></td>
<td>
<p>passed to <code><a href="#topic+run_trials">run_trials()</a></code>, see
description there.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_verbose">verbose</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the function
will print details on calibration progress.</p>
</td></tr>
<tr><td><code id="calibrate_trial_+3A_plot">plot</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the function
will print plots of the Gaussian process model predictions and return
them as part of the final object; requires the <code>ggplot2</code> package installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Default calibration</strong>
<br /><br />
If <code>fun</code> is <code>NULL</code> (as default), the default calibration strategy will be
employed. Here, the target <code>y</code> is the probability of superiority (as
described in <code><a href="#topic+check_performance">check_performance()</a></code> and <code><a href="#topic+summary">summary()</a></code>), and the function will
calibrate constant stopping thresholds for superiority and inferiority (as
described in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>, and
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>), which corresponds to the Bayesian analogues of the
type 1 error rate if there are no differences between arms in the trial
specification, which we expect to be the most common use case, or the power,
if there are differences between arms in the trial specification.<br />
</p>
<p>The stopping calibration process will, in the default case, use the input <code>x</code>
as the stopping threshold for superiority and <code>1 - x</code> as the stopping
threshold for inferiority, respectively, i.e., stopping thresholds will be
constant and symmetric.<br />
</p>
<p>The underlying default function calibrated is typically essentially
noiseless if a high enough number of simulations are used with an
appropriate random <code>base_seed</code>, and generally monotonically decreasing. The
default values for the control hyperparameters have been set to normally
work well in this case (including <code>init_n</code>, <code>kappa</code>, <code>pow</code>, <code>lengthscale</code>,
<code>narrow</code>, <code>scale_x</code>, etc.). Thus, few initial grid evaluations are used in
this case, and if a <code>base_seed</code> is provided, a noiseless process is assumed
and narrowing of the search range with each iteration is performed, and the
uncertainty bounds used in the acquisition function (corresponding to
quantiles from the posterior predictive distribution) are relatively narrow.
</p>
<p><strong>Specifying calibration functions</strong>
<br /><br />
A user-specified calibration function should have the following structure:
</p>
<div class="sourceCode"><pre># The function must take the arguments x and trial_spec
# trial_spec is the original trial_spec object which should be modified
# (alternatively, it may be re-specified, but the argument should still
# be included, even if ignored)
function(x, trial_spec) {
  # Calibrate trial_spec, here as in the default function
  trial_spec$superiority &lt;- x
  trial_spec$inferiority &lt;- 1 - x

  # If relevant, known y values corresponding to specific x values may be
  # returned without running simulations (here done as in the default
  # function). In that case, a code block line the one below can be included,
  # with changed x/y values - of note, the other return values should not be
  # changed
  if (x == 1) {
    return(list(sims = NULL, trial_spec = trial_spec, y = 0))
  }

  # Run simulations - this block should be included unchanged
  sims &lt;- run_trials(trial_spec, n_rep = n_rep, cores = cores,
                     base_seed = base_seed, sparse = sparse,
                     progress = progress, export = export,
                     export_envir = export_envir)

 # Return results - only the y value here should be changed
 # summary() or check_performance() will often be used here
 list(sims = sims, trial_spec = trial_spec,
      y = summary(sims)$prob_superior)
}
</pre></div>
<p><strong>Note:</strong> changes to the trial specification are <strong>not validated</strong>; users who
define their own calibration function need to ensure that changes to
calibrated trial specifications does not lead to invalid values; otherwise,
the procedure is prone to error when simulations are run. Especially, users
should be aware that changing <code>true_ys</code> in a trial specification generated
using the simplified <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> functions
requires changes in multiple places in the object, including in the functions
used to generate random outcomes, and in these cases (and otherwise if in
doubt) re-generating the <code>trial_spec</code> instead of modifying should be
preferred as this is safer and leads to proper validation.
</p>
<p><strong>Note:</strong> if the <code>y</code> values corresponding to certain <code>x</code> values are known,
then the user may directly return these values without running simulations
(e.g., in the default case an <code>x</code> of <code>1</code> will require <code style="white-space: pre;">&#8288;&gt;100%&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;0%&#8288;</code>
probabilities for stopping rules, which is impossible, and hence the <code>y</code>
value in this case is by definition <code>1</code>).
</p>
<p><strong>Gaussian process optimisation function and control hyperparameters</strong>
<br /><br />
The calibration function uses a relatively simple Gaussian optimisation
function with settings that should work well for the default calibration
function, but can be changed as required, which should be considered if
calibrating according to other targets (effects of using other settings may
be evaluated in greater detail by setting <code>verbose</code> and <code>plot</code> to <code>TRUE</code>).<br />
The function may perform both interpolation (i.e., assuming a noiseless,
deterministic process with no uncertainty at the values already evaluated) or
regression (i.e., assuming a noisy, stochastic process), controlled by the
<code>noisy</code> argument.<br />
</p>
<p>The covariance matrix (or kernel) is defined as:<br />
</p>
<p><code style="white-space: pre;">&#8288;exp(-||x - x'||^pow / lengthscale)&#8288;</code><br />
</p>
<p>with <code style="white-space: pre;">&#8288;||x -x'||&#8288;</code> corresponding to a matrix containing the absolute Euclidean
distances of values of <code>x</code> (and values on the prediction grid), scaled to
the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> range if <code>scale_x</code> is <code>TRUE</code> and on their original scale if
<code>FALSE</code>. Scaling i generally recommended (as this leads to more comparable
and predictable effects of <code>pow</code> and <code>lengthscale</code>, regardless of the true
scale), and also recommended if the range of values is smaller than this
range. The absolute distances are raised to the power <code>pow</code>, which must be a
value in the <code style="white-space: pre;">&#8288;[1, 2]&#8288;</code> range. Together with <code>lengthscale</code>, <code>pow</code> controls the
smoothness of the Gaussian process model, with <code>1</code> corresponding to less
smoothing (i.e., piecewise straight lines between all evaluations if
<code>lengthscale</code> is <code>1</code>) and values <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code> corresponding to more smoothing. After
raising the absolute distances to the chosen power <code>pow</code>, the resulting
matrix is divided by <code>lengthscale</code>. The default is <code>1</code> (no change), and
values <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code> leads to faster decay in correlations and thus less smoothing
(more wiggly fits), and values <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code> leads to more smoothing (less wiggly
fits). If a single specific value is supplied for <code>lengthscale</code> this is used;
if a range of values is provided, a secondary optimisation process determines
the value to use within that range.<br />
</p>
<p>Some minimal noise (&quot;jitter&quot;) is always added to the diagonals of the
matrices where relevant to ensure numerical stability; if <code>noisy</code> is <code>TRUE</code>,
a &quot;nugget&quot; value will be determined using a secondary optimisation process
<br />
</p>
<p>Predictions will be made over an equally spaced grid of <code>x</code> values of size
<code>resolution</code>; if <code>narrow</code> is <code>TRUE</code>, this grid will only be spread out
between the <code>x</code> values with corresponding <code>y</code> values closest to and below and
closes to and above <code>target</code>, respectively, leading to a finer grid in the
range of relevance (as described above, this should only be used for processes
that are assumed to be noiseless and should only be used if the process can
safely be assumed to be monotonically increasing or decreasing within the
<code>search_range</code>). To suggest the next <code>x</code> value for evaluations, the function
uses an acquisition function based on bi-directional uncertainty bounds
(posterior predictive distributions) with widths controlled by the <code>kappa</code>
hyperparameter. Higher <code>kappa</code>/wider uncertainty bounds leads to increased
<em>exploration</em> (i.e., the algorithm is more prone to select values with high
uncertainty, relatively far from existing evaluations), while lower
<code>kappa</code>/narrower uncertainty bounds leads to increased <em>exploitation</em> (i.e.,
the algorithm is more prone to select values with less uncertainty, closer to
the best predicted mean values). The value in the <code>x</code> grid leading with one of
the boundaries having the smallest absolute distance to the <code>target</code> is
chosen (within the narrowed range, if <code>narrow</code> is <code>TRUE</code>). See
Greenhill et al, 2020 under <strong>References</strong> for a general description of
acquisition functions.<br />
</p>
<p><strong>IMPORTANT:</strong>
<strong>we recommend that control hyperparameters are explicitly specified</strong>, even
for the default calibration function. Although the default values should be
sensible for the default calibration function, these may change in the
future. Further, we generally recommend users to perform small-scale
comparisons (i.e., with fewer simulations than in the final calibration) of
the calibration process with different hyperparameters for specific use cases
beyond the default (possibly guided by setting the <code>verbose</code> and <code>plot</code>
options to <code>TRUE</code>) before running a substantial number of calibrations or
simulations, as the exact choices may have important influence on the speed
and likelihood of success of the calibration process.<br />
It is the responsibility of the user to specify sensible values for the
settings and hyperparameters.
</p>


<h3>Value</h3>

<p>A list of special class <code>"trial_calibration"</code>, which contains the
following elements that can be extracted using <code>$</code> or <code>[[</code>:
</p>

<ul>
<li> <p><code>success</code>: single logical, <code>TRUE</code> if the calibration succeeded with
the best result being within the tolerance range, <code>FALSE</code> if the
calibration process ended after all allowed iterations without
obtaining a result within the tolerance range.
</p>
</li>
<li> <p><code>best_x</code>: single numerical value, the <code>x</code>-value (on the original,
input scale) at which the best <code>y</code>-value was found, regardless of
<code>success</code>.
</p>
</li>
<li> <p><code>best_y</code>: single numerical value, the best <code>y</code>-value obtained,
regardless of <code>success</code>.
</p>
</li>
<li> <p><code>best_trial_spec</code>: the best calibrated version of the original
<code>trial_spec</code> object supplied, regardless of <code>success</code> (i.e., the
returned trial specification object is only adequately calibrated if
<code>success</code> is <code>TRUE</code>).
</p>
</li>
<li> <p><code>best_sims</code>: the trial simulation results (from <code><a href="#topic+run_trials">run_trials()</a></code>)
leading to the best <code>y</code>-value, regardless of <code>success</code>. If no new
simulations have been conducted (e.g., if the best <code>y</code>-value is from
one of the <code>prev_y</code>-values), this will be <code>NULL</code>.
</p>
</li>
<li> <p><code>evaluations</code>: a two-column <code>data.frame</code> containing the variables
<code>x</code> and <code>y</code>, corresponding to all <code>x</code>-values and <code>y</code>-values (including
values supplied through <code>prev_x</code>/<code>prev_y</code>).
</p>
</li>
<li> <p><code>input_trial_spec</code>: the unaltered, uncalibrated, original
<code>trial_spec</code>-object provided to the function.
</p>
</li>
<li> <p><code>elapsed_time</code>: the total run time of the calibration process.
</p>
</li>
<li> <p><code>control</code>: list of the most central settings provided to the
function.
</p>
</li>
<li> <p><code>fun</code>: the function used for calibration; if <code>NULL</code> was supplied
when starting the calibration, the default function (described in
<strong>Details</strong>) is returned after being used in the function.
</p>
</li>
<li> <p><code>adaptr_version</code>: the version of the <code>adaptr</code> package used to run
the calibration process.
</p>
</li>
<li> <p><code>plots</code>: list containing <code>ggplot2</code> plot objects of each Gaussian
process suggestion step, only included if <code>plot</code> is <code>TRUE</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Gramacy RB (2020). Chapter 5: Gaussian Process Regression. In: Surrogates:
Gaussian Process Modeling, Design and Optimization for the Applied Sciences.
Chapman Hall/CRC, Boca Raton, Florida, USA.
<a href="https://bookdown.org/rbg/surrogates/chap5.html">Available online</a>.
</p>
<p>Greenhill S, Rana S, Gupta S, Vellanki P, Venkatesh S (2020). Bayesian
Optimization for Adaptive Experimental Design: A Review. IEEE Access, 8,
13937-13948. <a href="https://doi.org/10.1109/ACCESS.2020.2966228">doi:10.1109/ACCESS.2020.2966228</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Setup a trial specification to calibrate
# This trial specification has similar event rates in all arms
# and as the default calibration settings are used, this corresponds to
# assessing the Bayesian type 1 error rate for this design and scenario
binom_trial &lt;- setup_trial_binom(arms = c("A", "B"),
                                 true_ys = c(0.25, 0.25),
                                 data_looks = 1:5 * 200)

# Run calibration using default settings for most parameters
res &lt;- calibrate_trial(binom_trial, n_rep = 1000, base_seed = 23)

# Print calibration summary result
res

## End(Not run)

</code></pre>

<hr>
<h2 id='cat0'>cat() with sep = &quot;&quot;</h2><span id='topic+cat0'></span>

<h3>Description</h3>

<p>Used internally. Passes everything on to <code><a href="base.html#topic+cat">cat()</a></code> but enforces <code>sep = ""</code>.
Relates to <code><a href="base.html#topic+cat">cat()</a></code> as <code><a href="base.html#topic+paste0">paste0()</a></code> relates to <code><a href="base.html#topic+paste">paste()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat0_+3A_...">...</code></td>
<td>
<p>strings to be concatenated and printed.</p>
</td></tr>
</table>

<hr>
<h2 id='check_performance'>Check performance metrics for trial simulations</h2><span id='topic+check_performance'></span>

<h3>Description</h3>

<p>Calculates performance metrics for a trial specification based on
simulation results from the <code><a href="#topic+run_trials">run_trials()</a></code> function, with bootstrapped
uncertainty measures if requested. Uses <code><a href="#topic+extract_results">extract_results()</a></code>, which may be
used directly to extract key trial results without summarising. This function
is also used by <code><a href="#topic+summary">summary()</a></code> to calculate the performance metrics presented by
that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_performance(
  object,
  select_strategy = "control if available",
  select_last_arm = FALSE,
  select_preferences = NULL,
  te_comp = NULL,
  raw_ests = FALSE,
  final_ests = NULL,
  restrict = NULL,
  uncertainty = FALSE,
  n_boot = 5000,
  ci_width = 0.95,
  boot_seed = NULL,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_performance_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_performance_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="check_performance_+3A_raw_ests">raw_ests</code></td>
<td>
<p>single logical. If <code>FALSE</code> (default), the
posterior estimates (<code>post_ests</code> or <code>post_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used to calculate <code>sq_err</code> (the squared error of
the estimated compared to the specified effect in the selected arm) and
<code>sq_err_te</code> (the squared error of the treatment effect comparing the
selected arm to the comparator arm, as described for <code>te_comp</code> and below).
If <code>TRUE</code>, the raw estimates (<code>raw_ests</code> or <code>raw_ests_all</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used instead of the posterior
estimates.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_final_ests">final_ests</code></td>
<td>
<p>single logical. If <code>TRUE</code> (recommended) the final estimates
calculated using outcome data from all patients randomised when trials are
stopped are used (<code>post_ests_all</code> or <code>raw_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>); if <code>FALSE</code>, the estimates calculated for each arm when
an arm is stopped (or at the last adaptive analysis if not before) using
data from patients having reach followed up at this time point and not all
patients randomised are used (<code>post_ests</code> or <code>raw_ests</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>). If <code>NULL</code> (the default), this argument
will be set to <code>FALSE</code> if outcome data are available immediate after
randomisation for all patients (for backwards compatibility, as final
posterior estimates may vary slightly in this situation, even if using the
same data); otherwise it will be said to <code>TRUE</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> for
more details on how these estimates are calculated.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_restrict">restrict</code></td>
<td>
<p>single character string or <code>NULL</code>. If <code>NULL</code> (default),
results are summarised for all simulations; if <code>"superior"</code>, results are
summarised for simulations ending with superiority only; if <code>"selected"</code>,
results are summarised for simulations ending with a selected arm only
(according to the specified arm selection strategy for simulations not
ending with superiority). Some summary measures (e.g., <code>prob_conclusive</code>)
have substantially different interpretations if restricted, but are
calculated nonetheless.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_uncertainty">uncertainty</code></td>
<td>
<p>single logical; if <code>FALSE</code> (default) uncertainty measures
are not calculated, if <code>TRUE</code>, non-parametric bootstrapping is used to
calculate uncertainty measures.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_n_boot">n_boot</code></td>
<td>
<p>single integer (default <code>5000</code>); the number of bootstrap
samples to use if <code>uncertainty = TRUE</code>. Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not allowed and
values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> will lead to a warning, as results are likely to be
unstable in those cases.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_ci_width">ci_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the
percentile-based bootstrapped confidence intervals. Defaults to <code>0.95</code>,
corresponding to 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_boot_seed">boot_seed</code></td>
<td>
<p>single integer, <code>NULL</code> (default), or <code>"base"</code>. If a value is
provided, this value will be used to initiate random seeds when
bootstrapping with the global random seed restored after the function has
run. If <code>"base"</code> is specified, the <code>base_seed</code> specified in <code><a href="#topic+run_trials">run_trials()</a></code>
is used. Regardless of whether simulations are run sequentially or in
parallel, bootstrapped results will be identical if a <code>boot_seed</code> is
specified.</p>
</td></tr>
<tr><td><code id="check_performance_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ideal design percentage (IDP) returned is based on
<em>Viele et al, 2020</em> <a href="https://doi.org/10.1177/1740774519877836">doi:10.1177/1740774519877836</a>  (and also described in
<em>Granholm et al, 2022</em> <a href="https://doi.org/10.1016/j.jclinepi.2022.11.002">doi:10.1016/j.jclinepi.2022.11.002</a>, which also
describes the other performance measures) and has been adapted to work for
trials with both desirable/undesirable outcomes and non-binary outcomes.
Briefly, the expected outcome is calculated as the sum of the true outcomes
in each arm multiplied by the corresponding selection probabilities (ignoring
simulations with no selected arm). The IDP is then calculated as:
</p>

<ul>
<li><p> For desirable outcomes (<code>highest_is_best</code> is <code>TRUE</code>):<br />
<code style="white-space: pre;">&#8288;100 * (expected outcome - lowest true outcome) / (highest true outcome - lowest true outcome)&#8288;</code>
</p>
</li>
<li><p> For undesirable outcomes (<code>highest_is_best</code> is <code>FALSE</code>):<br />
<code style="white-space: pre;">&#8288;100 - IDP calculated for desirable outcomes&#8288;</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A tidy <code>data.frame</code> with added class <code>trial_performance</code> (to control
the number of digits printed, see <code><a href="#topic+print">print()</a></code>), with the columns
<code>"metric"</code> (described below), <code>"est"</code> (estimate of each metric), and the
following four columns if <code>uncertainty = TRUE</code>: <code>"err_sd"</code>(bootstrapped
SDs), <code>"err_mad"</code> (bootstrapped MAD-SDs, as described in <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="stats.html#topic+mad">stats::mad()</a></code>), <code>"lo_ci"</code>, and <code>"hi_ci"</code>, the latter two corresponding
to the lower/upper limits of the percentile-based bootstrapped confidence
intervals. Bootstrap estimates are <strong>not</strong> calculated for the mininum
(<code style="white-space: pre;">&#8288;_p0&#8288;</code>) and maximum values (<code style="white-space: pre;">&#8288;_p100&#8288;</code>) of <code>size</code>, <code>sum_ys</code>, and <code>ratio_ys</code>,
as non-parametric bootstrapping for mininum/maximum values is not
sensible - bootstrap estimates for these values will be <code>NA</code>.<br />
The following performance metrics are calculated:
</p>

<ul>
<li> <p><code>n_summarised</code>: the number of simulations summarised.
</p>
</li>
<li> <p><code>size_mean</code>, <code>size_sd</code>, <code>size_median</code>, <code>size_p25</code>, <code>size_p75</code>,
<code>size_p0</code>, <code>size_p100</code>: the mean, standard deviation, median as well as
25-, 75-, 0- (min), and 100- (max) percentiles of the sample sizes
(number of patients randomised in each simulated trial) of the summarised
trial simulations.
</p>
</li>
<li> <p><code>sum_ys_mean</code>, <code>sum_ys_sd</code>, <code>sum_ys_median</code>, <code>sum_ys_p25</code>,
<code>sum_ys_p75</code>, <code>sum_ys_p0</code>, <code>sum_ys_p100</code>: the mean, standard deviation,
median as well as 25-, 75-, 0- (min), and 100- (max) percentiles of the
total <code>sum_ys</code> across all arms in the summarised trial simulations (e.g.,
the total number of events in trials with a binary outcome, or the sums
of continuous values for all patients across all arms in trials with a
continuous outcome). Always uses all outcomes from all randomised
patients regardless of whether or not all patients had outcome data
available at the time of trial stopping (corresponding to <code>sum_ys_all</code> in
results from <code><a href="#topic+run_trial">run_trial()</a></code>).
</p>
</li>
<li> <p><code>ratio_ys_mean</code>, <code>ratio_ys_sd</code>, <code>ratio_ys_median</code>, <code>ratio_ys_p25</code>,
<code>ratio_ys_p75</code>, <code>ratio_ys_p0</code>, <code>ratio_ys_p100</code>: the mean, standard
deviation, median as well as 25-, 75-, 0- (min), and 100- (max)
percentiles of the final <code>ratio_ys</code> (<code>sum_ys</code> as described above divided
by the total number of patients randomised) across all arms in the
summarised trial simulations.
</p>
</li>
<li> <p><code>prob_conclusive</code>: the proportion (<code>0</code> to <code>1</code>) of conclusive trial
simulations, i.e., simulations not stopped at the maximum sample size
without a superiority, equivalence or futility decision.
</p>
</li>
<li> <p><code>prob_superior</code>, <code>prob_equivalence</code>, <code>prob_futility</code>, <code>prob_max</code>: the
proportion (<code>0</code> to <code>1</code>) of trial simulations stopped for superiority,
equivalence, futility or inconclusive at the maximum allowed sample size,
respectively.<br />
<strong>Note:</strong> Some metrics may not make sense if summarised simulation
results are <code>restricted</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;prob_select_*&#8288;</code>: the selection probabilities for each arm and for no
selection, according to the specified selection strategy. Contains one
element per <code>arm</code>, named <code style="white-space: pre;">&#8288;prob_select_arm_&lt;arm name&gt;&#8288;</code> and
<code>prob_select_none</code> for the probability of selecting no arm.
</p>
</li>
<li> <p><code>rmse</code>, <code>rmse_te</code>: the root mean squared error of the estimates for
the selected arm and for the treatment effect, as described in
<code><a href="#topic+extract_results">extract_results()</a></code>.
</p>
</li>
<li> <p><code>idp</code>: the ideal design percentage (IDP; 0-100%), see <strong>Details</strong>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+plot_convergence">plot_convergence()</a></code>,
<code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code>, <code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 control = "A",
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 100)

# Run 10 simulations with a specified random base seed
res &lt;- run_trials(binom_trial, n_rep = 10, base_seed = 12345)

# Check performance measures, without assuming that any arm is selected in
# the inconclusive simulations, with bootstrapped uncertainty measures
# (unstable in this example due to the very low number of simulations
# summarised):
check_performance(res, select_strategy = "none", uncertainty = TRUE,
n_boot = 1000, boot_seed = "base")

</code></pre>

<hr>
<h2 id='check_remaining_arms'>Check remaining arm combinations</h2><span id='topic+check_remaining_arms'></span>

<h3>Description</h3>

<p>This function summarises the numbers and proportions of all combinations of
remaining arms (i.e., excluding arms dropped for inferiority or futility at
any analysis, and arms dropped for equivalence at earlier analyses in trials
with a common <code>control</code>) across multiple simulated trial results. The
function supplements the <code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+check_performance">check_performance()</a></code>, and
<code><a href="#topic+summary">summary()</a></code> functions, and is especially useful for designs with <code style="white-space: pre;">&#8288;&gt; 2&#8288;</code> arms,
where it provides details that the other functionality mentioned do not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_remaining_arms(object, ci_width = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_remaining_arms_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="check_remaining_arms_+3A_ci_width">ci_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the approximate
confidence intervals for the proportions of combinations (calculated
analytically). Defaults to <code>0.95</code>, corresponding to 95% confidence
intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> containing the combinations of remaining arms, sorted
in descending order of, with the following columns:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;arm_*&#8288;</code>, one column per arm, each named as <code style="white-space: pre;">&#8288;arm_&lt;arm name&gt;&#8288;</code>. These
columns will contain an empty character string <code>""</code> for dropped arms
(including arms dropped at the final analysis), and otherwise be
<code>"superior"</code>, <code>"control"</code>, <code>"equivalence"</code> (only if equivalent at the
final analysis), or <code>"active"</code>, as described in <code><a href="#topic+run_trial">run_trial()</a></code>.
</p>
</li>
<li> <p><code>n</code> integer vector, number of trial simulations ending with the
combination of remaining arms as specified by the preceding columns.
</p>
</li>
<li> <p><code>prop</code> numeric vector, the proportion of trial simulations ending
with the combination of remaining arms as specified by the preceding
columns.
</p>
</li>
<li> <p><code>se</code>,<code>lo_ci</code>,<code>hi_ci</code>: the standard error of <code>prop</code> and the confidence
intervals of the width specified by <code>ci_width</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>,
<code><a href="#topic+plot_convergence">plot_convergence()</a></code>, <code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 control = "A",
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 200,
                                 equivalence_prob = 0.7,
                                 equivalence_diff = 0.03,
                                 equivalence_only_first = FALSE)

# Run 35 simulations with a specified random base seed
res &lt;- run_trials(binom_trial, n_rep = 25, base_seed = 12345)

# Check remaining arms (printed with fewer digits)
print(check_remaining_arms(res), digits = 3)

</code></pre>

<hr>
<h2 id='cov_mat'>Estimates covariance matrices used by Gaussian process optimisation</h2><span id='topic+cov_mat'></span>

<h3>Description</h3>

<p>Used internally, estimates covariance matrices used by the Gaussian process
optimisation function. Calculates pairwise absolute distances raised to a
power (which defaults to <code>2</code>) using the <code><a href="#topic+pow_abs_dist">pow_abs_dist()</a></code> function, divides
the result by a<code> lengthscale</code> hyperparameter (which defaults to <code>1</code>, i.e., no
changes due to division), and subsequently returns the inverse exponentiation
of the resulting matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_mat(x1, x2 = x1, g = NULL, pow = 2, lengthscale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_mat_+3A_x1">x1</code></td>
<td>
<p>numeric vector, with length corresponding to the number of rows in
the returned matrix.</p>
</td></tr>
<tr><td><code id="cov_mat_+3A_x2">x2</code></td>
<td>
<p>numeric vector, with length corresponding to the number of columns
in the returned matrix. If not specified, <code>x1</code> will be used for <code>x2</code>.</p>
</td></tr>
<tr><td><code id="cov_mat_+3A_g">g</code></td>
<td>
<p>single numerical value; jitter/nugget value added to the diagonal
if not <code>NULL</code> (the default); should be supplied if <code>x1</code> is the same as
<code>x2</code>, to avoid potentially negative values in the matrix diagonal due to
numerical instability.</p>
</td></tr>
<tr><td><code id="cov_mat_+3A_pow">pow</code></td>
<td>
<p>single numeric value, the power that all distances are raised to.
Defaults to <code>2</code>, corresponding to pairwise, squared, Euclidean distances.</p>
</td></tr>
<tr><td><code id="cov_mat_+3A_lengthscale">lengthscale</code></td>
<td>
<p>single numerical value; lengthscale hyperparameter that
the matrix returned from <code><a href="#topic+pow_abs_dist">pow_abs_dist()</a></code> is divided by before the inverse
exponentiation is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariance matrix with <code>length(x1)</code> rows and <code>length(x2)</code> columns
used by the Gaussian process optimiser.
</p>

<hr>
<h2 id='dispatch_trial_runs'>Simulate single trial after setting seed</h2><span id='topic+dispatch_trial_runs'></span>

<h3>Description</h3>

<p>Helper function to dispatch the running of several trials to <code><a href="base.html#topic+lapply">lapply()</a></code> or
<code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>, setting seeds correctly if a <code>base_seed</code> was used
when calling <code><a href="#topic+run_trials">run_trials()</a></code>. Used internally in calls by the <code><a href="#topic+run_trials">run_trials()</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatch_trial_runs(is, trial_spec, seeds, sparse, cores, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispatch_trial_runs_+3A_is">is</code></td>
<td>
<p>vector of integers, the simulation numbers/indices.</p>
</td></tr>
<tr><td><code id="dispatch_trial_runs_+3A_trial_spec">trial_spec</code></td>
<td>
<p>trial specification as provided by <code><a href="#topic+setup_trial">setup_trial()</a></code>,
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="dispatch_trial_runs_+3A_sparse">sparse</code></td>
<td>
<p>single logical, as described in <code><a href="#topic+run_trial">run_trial()</a></code>; defaults to
<code>TRUE</code> when running multiple simulations, in which case only the data
necessary to summarise all simulations are saved for each simulation.
If <code>FALSE</code>, more detailed data for each simulation is saved, allowing more
detailed printing of individual trial results and plotting using
<code><a href="#topic+plot_history">plot_history()</a></code> (<code><a href="#topic+plot_status">plot_status()</a></code> does not require non-sparse results).</p>
</td></tr>
<tr><td><code id="dispatch_trial_runs_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value/cluster set
by <code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether simulations are run in
parallel on a default cluster or sequentially in the main process; if a
cluster/value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>, <code>cores</code> will
then be set to the value stored in the global <code>"mc.cores"</code> option (if
previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and <code>1</code> if that
option has not been specified.<br />
If the resulting number of <code>cores = 1</code>, computations will be run
sequentially in the primary process, and if <code>cores &gt; 1</code>, a new parallel
cluster will be setup using the <code>parallel</code> library and removed once the
function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
<tr><td><code id="dispatch_trial_runs_+3A_cl">cl</code></td>
<td>
<p><code>NULL</code> (default) for running sequentially, otherwise a <code>parallel</code>
cluster for parallel computation if <code>cores &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single trial simulation object, as described in <code><a href="#topic+run_trial">run_trial()</a></code>.
</p>

<hr>
<h2 id='equivalent_funs'>Assert equivalent functions</h2><span id='topic+equivalent_funs'></span>

<h3>Description</h3>

<p>Used internally. Compares the definitions of two functions (ignoring
environments, bytecodes, etc., by only comparing function arguments and
bodies, using <code><a href="base.html#topic+deparse">deparse()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_funs(fun1, fun2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_funs_+3A_fun1">fun1</code>, <code id="equivalent_funs_+3A_fun2">fun2</code></td>
<td>
<p>functions to compare.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single logical.
</p>

<hr>
<h2 id='extract_history'>Extract history</h2><span id='topic+extract_history'></span>

<h3>Description</h3>

<p>Used internally. Extracts relevant parameters at each conducted adaptive
analysis from a single trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_history(object, metric = "prob")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_history_+3A_object">object</code></td>
<td>
<p>single <code>trial_result</code> from <code><a href="#topic+run_trial">run_trial()</a></code>, only works if run
with argument <code>sparse = FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_history_+3A_metric">metric</code></td>
<td>
<p>either <code>"prob"</code> (default), in which case allocation
probabilities at each adaptive analysis are returned; <code>"n"</code>/<code>"n all"</code>, in
which case the total number of patients with available follow-up data
(<code>"n"</code>) or allocated (<code>"n all"</code>) to each <code>arm</code> during each adaptive
analysis are returned; <code>"pct"</code>/<code>"pct all"</code> in which case the proportions of
of patients allocated and having available follow-up data (<code>"pct"</code>) or
allocated in total (<code>"pct all"</code>) to each arm out of the total number of
patients are returned; <code>"sum ys"</code>/<code>"sum ys all"</code>, in which case the total
summed available outcome data (<code>"sum ys"</code>) or total summed outcome data
including outcomes of patients randomised that have not necessarily reached
follow-up yet (<code>"sum ys all"</code>) in each arm after each adaptive analysis are
returned; or <code>"ratio ys"</code>/<code>"ratio ys all"</code>, in which case the total summed
outcomes as specified for <code>"sum ys"</code>/<code>"sum ys all"</code> divided by the number
of patients after each analysis adaptive are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy <code>data.frame</code> (one row per arm per look) containing the following
columns:
</p>

<ul>
<li> <p><code>look</code>: consecutive numbers (integers) of each interim look.
</p>
</li>
<li> <p><code>look_ns</code>: total number of patients (integers) with outcome data
available at current adaptive analysis look to all arms in the trial.
</p>
</li>
<li> <p><code>look_ns_all</code>: total number of patients (integers) randomised at
current adaptive analysis look to all arms in the trial.
</p>
</li>
<li> <p><code>arm</code>: the current <code>arm</code> in the trial.
</p>
</li>
<li> <p><code>value</code>: as described under <code>metric</code>.
</p>
</li></ul>


<hr>
<h2 id='extract_results'>Extract simulation results</h2><span id='topic+extract_results'></span>

<h3>Description</h3>

<p>This function extracts relevant information from multiple simulations of the
same trial specification in a tidy <code>data.frame</code> (1 simulation per row).
See also the <code><a href="#topic+check_performance">check_performance()</a></code> and <code><a href="#topic+summary">summary()</a></code> functions, that uses the
output from this function to further summarise simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_results(
  object,
  select_strategy = "control if available",
  select_last_arm = FALSE,
  select_preferences = NULL,
  te_comp = NULL,
  raw_ests = FALSE,
  final_ests = NULL,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_results_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="extract_results_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_results_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="extract_results_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="extract_results_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="extract_results_+3A_raw_ests">raw_ests</code></td>
<td>
<p>single logical. If <code>FALSE</code> (default), the
posterior estimates (<code>post_ests</code> or <code>post_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used to calculate <code>sq_err</code> (the squared error of
the estimated compared to the specified effect in the selected arm) and
<code>sq_err_te</code> (the squared error of the treatment effect comparing the
selected arm to the comparator arm, as described for <code>te_comp</code> and below).
If <code>TRUE</code>, the raw estimates (<code>raw_ests</code> or <code>raw_ests_all</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used instead of the posterior
estimates.</p>
</td></tr>
<tr><td><code id="extract_results_+3A_final_ests">final_ests</code></td>
<td>
<p>single logical. If <code>TRUE</code> (recommended) the final estimates
calculated using outcome data from all patients randomised when trials are
stopped are used (<code>post_ests_all</code> or <code>raw_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>); if <code>FALSE</code>, the estimates calculated for each arm when
an arm is stopped (or at the last adaptive analysis if not before) using
data from patients having reach followed up at this time point and not all
patients randomised are used (<code>post_ests</code> or <code>raw_ests</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>). If <code>NULL</code> (the default), this argument
will be set to <code>FALSE</code> if outcome data are available immediate after
randomisation for all patients (for backwards compatibility, as final
posterior estimates may vary slightly in this situation, even if using the
same data); otherwise it will be said to <code>TRUE</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> for
more details on how these estimates are calculated.</p>
</td></tr>
<tr><td><code id="extract_results_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the following columns:
</p>

<ul>
<li> <p><code>sim</code>: the simulation number (from <code>1</code> to the total number of
simulations).
</p>
</li>
<li> <p><code>final_n</code>: the final sample size in each simulation.
</p>
</li>
<li> <p><code>sum_ys</code>: the sum of the total counts in all arms, e.g., the total
number of events in trials with a binary outcome
(<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>) or the sum of the arm totals in trials with a
continuous outcome (<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>). Always uses all outcome data
from all randomised patients regardless of whether or not all patients
had outcome data available at the time of trial stopping (corresponding
to <code>sum_ys_all</code> in results from <code><a href="#topic+run_trial">run_trial()</a></code>).
</p>
</li>
<li> <p><code>ratio_ys</code>: calculated as <code>sum_ys/final_n</code> (as described above).
</p>
</li>
<li> <p><code>final_status</code>: the final trial status for each simulation, either
<code>"superiority"</code>, <code>"equivalence"</code>, <code>"futility"</code>, or <code>"max"</code>, as
described in <code><a href="#topic+run_trial">run_trial()</a></code>.
</p>
</li>
<li> <p><code>superior_arm</code>: the final superior arm in simulations stopped for
superiority. Will be <code>NA</code> in simulations not stopped for superiority.
</p>
</li>
<li> <p><code>selected_arm</code>: the final selected arm (as described above). Will
correspond to the <code>superior_arm</code> in simulations stopped for superiority
and be <code>NA</code> if no arm is selected. See <code>select_strategy</code> above.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sq_err:&#8288;</code> the squared error of the estimate in the selected arm,
calculated as <code style="white-space: pre;">&#8288;(estimated effect - true effect)^2&#8288;</code> for the selected
arms.
</p>
</li>
<li> <p><code>sq_err_te</code>: the squared error of the treatment effect comparing
the selected arm to the comparator arm (as specified in <code>te_comp</code>).
Calculated as:<br />
<code style="white-space: pre;">&#8288;((estimated effect in the selected arm - estimated effect in the comparator arm) -&#8288;</code>
<code style="white-space: pre;">&#8288;(true effect in the selected arm - true effect in the comparator arm))^2&#8288;</code> <br />
Will be <code>NA</code> for simulations without a selected arm, with no
comparator specified (see <code>te_comp</code> above), and when the selected arm
is the comparator arm.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+plot_convergence">plot_convergence()</a></code>,
<code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code>, <code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 control = "A",
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 100)

# Run 10 simulations with a specified random base seed
res &lt;- run_trials(binom_trial, n_rep = 10, base_seed = 12345)

# Extract results and Select the control arm if available
# in simulations not ending with superiority
extract_results(res, select_strategy = "control")

</code></pre>

<hr>
<h2 id='extract_results_batch'>Extract results from a batch of trials from an object with multiple trials</h2><span id='topic+extract_results_batch'></span>

<h3>Description</h3>

<p>Used internally by <code><a href="#topic+extract_results">extract_results()</a></code>. Extracts results from a batch of
simulations from a simulation object with multiple simulation results
returned by <code><a href="#topic+run_trials">run_trials()</a></code>, used to facilitate parallelisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_results_batch(
  trial_results,
  control = control,
  select_strategy = select_strategy,
  select_last_arm = select_last_arm,
  select_preferences = select_preferences,
  te_comp = te_comp,
  which_ests = which_ests,
  te_comp_index = te_comp_index,
  te_comp_true_y = te_comp_true_y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_results_batch_+3A_trial_results">trial_results</code></td>
<td>
<p>list of trial results to summarise, the current batch.</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_control">control</code></td>
<td>
<p>single character string, the common <code>control</code> arm from the
trial specification (<code>NULL</code> if none).</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_which_ests">which_ests</code></td>
<td>
<p>single character string, a combination of the <code>raw_ests</code>
and <code>final_ests</code> arguments from <code><a href="#topic+extract_results">extract_results()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_te_comp_index">te_comp_index</code></td>
<td>
<p>single integer, index of the treatment effect comparator
arm (<code>NULL</code> if none).</p>
</td></tr>
<tr><td><code id="extract_results_batch_+3A_te_comp_true_y">te_comp_true_y</code></td>
<td>
<p>single numeric value, true <code>y</code> value in the treatment
effect comparator arm (<code>NULL</code> if none).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing all columns returned by <code><a href="#topic+extract_results">extract_results()</a></code>
and described in that function (<code>sim</code> will start from <code>1</code>, but this is
changed where relevant by <code><a href="#topic+extract_results">extract_results()</a></code>).
</p>

<hr>
<h2 id='extract_statuses'>Extract statuses</h2><span id='topic+extract_statuses'></span>

<h3>Description</h3>

<p>Used internally. Extracts overall trial statuses or statuses from a single
<code>arm</code> from multiple trial simulations. Works with <em>sparse</em> results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_statuses(object, x_value, arm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_statuses_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object from <code><a href="#topic+run_trials">run_trials()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_statuses_+3A_x_value">x_value</code></td>
<td>
<p>single character string, determining whether the number of
adaptive analysis looks (<code>"look"</code>, default), the total cumulated number of
patients randomised (<code>"total n"</code>) or the total cumulated number of patients
with outcome data available at each adaptive analysis (<code>"followed n"</code>) are
plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="extract_statuses_+3A_arm">arm</code></td>
<td>
<p>character vector containing one or more unique, valid <code>arm</code> names,
<code>NA</code>, or <code>NULL</code> (default). If <code>NULL</code>, the overall trial statuses are plotted,
otherwise the specified arms or all arms (if <code>NA</code> is specified) are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy <code>data.frame</code> (one row possible status per look) containing the
following columns:
</p>

<ul>
<li> <p><code>x</code>: the look numbers or total number of patients at each look,
as specified in <code>x_value</code>.
</p>
</li>
<li> <p><code>status</code>: each possible status (<code>"Recruiting"</code>, <code>"Inferiority"</code>
(only relevant for individual arms), <code>"Futility"</code>, <code>"Equivalence"</code>, and
<code>"Superiority"</code>, as relevant).
</p>
</li>
<li> <p><code>p</code>: the proportion (<code>0-1</code>) of patients with each <code>status</code> at each
value of <code>x</code>.
</p>
</li>
<li> <p><code>value</code>: as described under <code>metric</code>.
</p>
</li></ul>


<hr>
<h2 id='find_beta_params'>Find beta distribution parameters from thresholds</h2><span id='topic+find_beta_params'></span>

<h3>Description</h3>

<p>Helper function to find a beta distribution with parameters corresponding
to the fewest possible patients with events/non-events and a specified event
proportion. Used in the <strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", "adaptr")</code>) to derive <code>beta</code> prior
distributions for use in <em>beta-binomial conjugate models</em>, based on a belief
that the true event probability lies within a specified percentile-based
interval (defaults to <code style="white-space: pre;">&#8288;95%&#8288;</code>). May similarly be used by users to derive other
<code>beta</code> priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_beta_params(
  theta = NULL,
  boundary_target = NULL,
  boundary = "lower",
  interval_width = 0.95,
  n_dec = 0,
  max_n = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_beta_params_+3A_theta">theta</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, expected true event probability.</p>
</td></tr>
<tr><td><code id="find_beta_params_+3A_boundary_target">boundary_target</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, target lower or upper
boundary of the interval.</p>
</td></tr>
<tr><td><code id="find_beta_params_+3A_boundary">boundary</code></td>
<td>
<p>single character string, either <code>"lower"</code> (default) or
<code>"upper"</code>, used to select which boundary to use when finding appropriate
parameters for the <code>beta</code> distribution.</p>
</td></tr>
<tr><td><code id="find_beta_params_+3A_interval_width">interval_width</code></td>
<td>
<p>width of the credible interval whose lower/upper
boundary should be used (see <code>boundary_target</code>); must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>;
defaults to <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="find_beta_params_+3A_n_dec">n_dec</code></td>
<td>
<p>single non-negative integer; the returned parameters are rounded
to this number of decimals. Defaults to <code>0</code>, in which case the parameters
will correspond to whole number of patients.</p>
</td></tr>
<tr><td><code id="find_beta_params_+3A_max_n">max_n</code></td>
<td>
<p>single integer <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (default <code>10000</code>), the maximum total sum of
the parameters, corresponding to the maximum total number of patients that
will be considered by the function when finding the optimal parameter
values. Corresponds to the maximum number of patients contributing
information to a beta prior; more than the default number of patients are
unlikely to be used in a beta prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row <code>data.frame</code> with five columns: the two shape parameters
of the beta distribution (<code>alpha</code>, <code>beta</code>), rounded according to <code>n_dec</code>,
and the actual lower and upper boundaries of the interval and the median
(with appropriate names, e.g. <code>p2.5</code>, <code>p50</code>, and <code>p97.5</code> for a
<code style="white-space: pre;">&#8288;95%&#8288;</code> interval), when using those rounded values.
</p>

<hr>
<h2 id='fmt_dig'>Format digits before printing</h2><span id='topic+fmt_dig'></span>

<h3>Description</h3>

<p>Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_dig(x, dig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmt_dig_+3A_x">x</code></td>
<td>
<p>numeric, the numeric value(s) to format.</p>
</td></tr>
<tr><td><code id="fmt_dig_+3A_dig">dig</code></td>
<td>
<p>single integer, the number of digits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted character string.
</p>

<hr>
<h2 id='fmt_pct'>Create formatted label with absolute and relative frequencies (percentages)</h2><span id='topic+fmt_pct'></span>

<h3>Description</h3>

<p>Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_pct(e, n, dec = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmt_pct_+3A_e">e</code></td>
<td>
<p>integer, the numerator (e.g., the number of events).</p>
</td></tr>
<tr><td><code id="fmt_pct_+3A_n">n</code></td>
<td>
<p>integer, the denominator (e.g., the total number of patients).</p>
</td></tr>
<tr><td><code id="fmt_pct_+3A_dec">dec</code></td>
<td>
<p>integer, the number of decimals for the percentage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted character string.
</p>

<hr>
<h2 id='get_draws_binom'>Generate draws from posterior beta-binomial distributions</h2><span id='topic+get_draws_binom'></span>

<h3>Description</h3>

<p>Used internally. This function generates draws from posterior distributions
using separate beta-binomial models (binomial outcome, conjugate beta prior)
for each arm, with flat (<code>beta(1, 1)</code>) priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_draws_binom(arms, allocs, ys, control, n_draws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_draws_binom_+3A_arms">arms</code></td>
<td>
<p>character vector, <strong>currently active</strong> <code>arms</code> as specified in
<code><a href="#topic+setup_trial">setup_trial()</a></code> / <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> / <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_draws_binom_+3A_allocs">allocs</code></td>
<td>
<p>character vector, allocations of all patients (including
allocations to <strong>currently inactive</strong> <code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_binom_+3A_ys">ys</code></td>
<td>
<p>numeric vector, outcomes of all patients in the same order
as <code>alloc</code> (including outcomes of patients in <strong>currently inactive</strong>
<code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_binom_+3A_control">control</code></td>
<td>
<p>unused argument in the built-in functions for
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <a href="#topic+setup_trial_norm">setup_trial_norm</a>, but required as this
argument is supplied by the <code><a href="#topic+run_trial">run_trial()</a></code> function, and may be used in
user-defined functions used to generate posterior draws.</p>
</td></tr>
<tr><td><code id="get_draws_binom_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, number of posterior draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> (with numeric values) with <code>length(arms)</code> columns and
<code>n_draws</code> rows, with <code>arms</code> as column names.
</p>

<hr>
<h2 id='get_draws_generic'>Generic documentation for get_draws_* functions</h2><span id='topic+get_draws_generic'></span>

<h3>Description</h3>

<p>Used internally. See the <code><a href="#topic+setup_trial">setup_trial()</a></code> function documentation for
additional details on how to specify functions to generate posterior draws.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_draws_generic_+3A_arms">arms</code></td>
<td>
<p>character vector, <strong>currently active</strong> <code>arms</code> as specified in
<code><a href="#topic+setup_trial">setup_trial()</a></code> / <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> / <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_draws_generic_+3A_allocs">allocs</code></td>
<td>
<p>character vector, allocations of all patients (including
allocations to <strong>currently inactive</strong> <code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_generic_+3A_ys">ys</code></td>
<td>
<p>numeric vector, outcomes of all patients in the same order
as <code>alloc</code> (including outcomes of patients in <strong>currently inactive</strong>
<code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_generic_+3A_control">control</code></td>
<td>
<p>unused argument in the built-in functions for
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <a href="#topic+setup_trial_norm">setup_trial_norm</a>, but required as this
argument is supplied by the <code><a href="#topic+run_trial">run_trial()</a></code> function, and may be used in
user-defined functions used to generate posterior draws.</p>
</td></tr>
<tr><td><code id="get_draws_generic_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, number of posterior draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> (with numeric values) with <code>length(arms)</code> columns and
<code>n_draws</code> rows, with <code>arms</code> as column names.
</p>

<hr>
<h2 id='get_draws_norm'>Generate draws from posterior normal distributions</h2><span id='topic+get_draws_norm'></span>

<h3>Description</h3>

<p>Used internally. This function generates draws from posterior, normal
distributions for continuous outcomes. Technically, these posteriors use no
priors (for simulation speed), corresponding to the use of improper flat
priors. These posteriors correspond (and give similar results) to using
normal-normal models (normally distributed outcome, conjugate normal prior)
for each arm, assuming that a non-informative, flat prior is used. Thus, the
posteriors directly correspond to normal distributions with each groups' mean
as the mean and each groups' standard error as the standard deviation.
As it is necessary to always return valid draws, in cases where <code style="white-space: pre;">&#8288;&lt; 2&#8288;</code>
patients have been randomised to an <code>arm</code>, posterior draws will come from an
extremely wide normal distribution with mean corresponding to the mean of all
included patients with outcome data and a standard deviation corresponding to
the difference between the highest and lowest recorded outcomes for all
patients with available outcome data multiplied by <code>1000</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_draws_norm(arms, allocs, ys, control, n_draws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_draws_norm_+3A_arms">arms</code></td>
<td>
<p>character vector, <strong>currently active</strong> <code>arms</code> as specified in
<code><a href="#topic+setup_trial">setup_trial()</a></code> / <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> / <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_draws_norm_+3A_allocs">allocs</code></td>
<td>
<p>character vector, allocations of all patients (including
allocations to <strong>currently inactive</strong> <code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_norm_+3A_ys">ys</code></td>
<td>
<p>numeric vector, outcomes of all patients in the same order
as <code>alloc</code> (including outcomes of patients in <strong>currently inactive</strong>
<code>arms</code>).</p>
</td></tr>
<tr><td><code id="get_draws_norm_+3A_control">control</code></td>
<td>
<p>unused argument in the built-in functions for
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <a href="#topic+setup_trial_norm">setup_trial_norm</a>, but required as this
argument is supplied by the <code><a href="#topic+run_trial">run_trial()</a></code> function, and may be used in
user-defined functions used to generate posterior draws.</p>
</td></tr>
<tr><td><code id="get_draws_norm_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, number of posterior draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> (with numeric values) with <code>length(arms)</code> columns and
<code>n_draws</code> rows, with <code>arms</code> as column names.
</p>

<hr>
<h2 id='get_ys_binom'>Generate binary outcomes from binomial distributions</h2><span id='topic+get_ys_binom'></span>

<h3>Description</h3>

<p>Used internally. Function factory used to generate a function that generates
binary outcomes from binomial distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ys_binom(arms, event_probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ys_binom_+3A_arms">arms</code></td>
<td>
<p>character vector of <code>arms</code> as specified in <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>.</p>
</td></tr>
<tr><td><code id="get_ys_binom_+3A_event_probs">event_probs</code></td>
<td>
<p>numeric vector of true event probabilities in all <code>arms</code>
as specified in <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which takes the argument <code>allocs</code> (a character vector
with the allocations) and returns a numeric vector of similar length with
the corresponding, randomly generated outcomes (0 or 1, from binomial
distribution).
</p>

<hr>
<h2 id='get_ys_norm'>Generate normally distributed continuous outcomes</h2><span id='topic+get_ys_norm'></span>

<h3>Description</h3>

<p>Used internally. Function factory used to generate a function that generates
outcomes from normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ys_norm(arms, means, sds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ys_norm_+3A_arms">arms</code></td>
<td>
<p>character vector, <code>arms</code> as specified in <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_ys_norm_+3A_means">means</code></td>
<td>
<p>numeric vector, true <code>means</code> in all <code>arms</code> as specified in
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="get_ys_norm_+3A_sds">sds</code></td>
<td>
<p>numeric vector, true standard deviations (<code>sds</code>) in all <code>arms</code> as
specified in <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which takes the argument <code>allocs</code> (a character vector
with the allocations) and returns a numeric vector of the same length with
the corresponding, randomly generated outcomes (from normal distributions).
</p>

<hr>
<h2 id='gp_opt'>Gaussian process-based optimisation</h2><span id='topic+gp_opt'></span>

<h3>Description</h3>

<p>Used internally. Simple Gaussian process-based Bayesian optimisation
function, used to find the next value to evaluate (as <code>x</code>) in the
<code><a href="#topic+calibrate_trial">calibrate_trial()</a></code> function. Uses only a single input dimension, which may
be rescaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> range by the function, and a covariance structure
based on absolute distances between values, raised to a power (<code>pow</code>) and
subsequently divided by <code>lengthscale</code> before the inverse exponentiation of
the resulting matrix is used. The <code>pow</code> and <code>lengthscale</code> hyperparameters
consequently control the smoothness by controlling the rate of decay between
correlations with distance.<br />
The optimisation algorithm uses bi-directional uncertainty bounds in an
acquisition function that suggests the next target to evaluate, with wider
uncertainty bounds (higher <code>kappa</code>) leading to increased 'exploration' (i.e.,
the function is more prone to suggest new target values where the uncertainty
is high and often further from the best evaluation so far) and narrower
uncertainty bounds leading to increased 'exploitation' (i.e., the function is
more prone to suggest new target values relatively close to the mean
predictions from the model).<br />
The <code>dir</code> argument controls whether the suggested value (based on both
uncertainty bounds) should be the value closest to <code>target</code> in either
direction (<code>dir = 0</code>), at or above <code>target</code> (<code>dir &gt; 0</code>), or at or below
target (<code>dir &lt; 0</code>), if any, are preferred.<br />
When the function being evaluated is noise-free and monotonically increasing
or decreasing, the optimisation function can narrow the range of predictions
based on the input evaluations (<code>narrow = TRUE</code>), leading to a finer grid of
potential new targets to suggest compared to when predictions are spaced over
the full range.<br />
If the new value at which to evaluate the function suggested has already been
evaluated, random noise will be added to ensure evaluation at a new value
(if <code>narrow</code> is <code>FALSE</code>, noise will be based on a random draw from a normal
distribution with the current suggested value as mean and the standard
deviation of the <code>x</code> values as SD, truncated to the range of <code>x</code>-values; if
<code>narrow</code> is <code>TRUE</code>, a new value drawn from a uniform distribution within the
current narrowed range will be suggested. For both strategies, the process
will be repeated until the suggested value is 'new').
<br /> The Gaussian process model used is partially based on code from Gramacy
2020 (with permission), see <strong>References</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_opt(
  x,
  y,
  target,
  dir = 0,
  resolution = 5000,
  kappa = 1.96,
  pow = 1.95,
  lengthscale = 1,
  scale_x = TRUE,
  noisy = FALSE,
  narrow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_opt_+3A_x">x</code></td>
<td>
<p>numeric vector, the previous values where the function being
calibrated was evaluated.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_y">y</code></td>
<td>
<p>numeric vector, the corresponding results of the previous
evaluations at the <code>x</code> values (must be of the same length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_target">target</code></td>
<td>
<p>single numeric value, the desired target value for the
calibration process.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_dir">dir</code></td>
<td>
<p>single numeric value (default <code>0</code>), used when selecting the next
value to evaluate at. See <code><a href="#topic+which_nearest">which_nearest()</a></code> for further description.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_resolution">resolution</code></td>
<td>
<p>single integer (default <code>5000</code>), size of the grid at which
the predictions used to select the next value to evaluate at are made.<br />
<strong>Note:</strong> memory use and time will substantially increase with higher
values.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_kappa">kappa</code></td>
<td>
<p>single numeric value <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (default <code>1.96</code>), used for the width
of uncertainty bounds (based on the Gaussian process posterior predictive
distribution), which are used to select the next value to evaluate at.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_pow">pow</code></td>
<td>
<p>single numerical value, passed to <code><a href="#topic+cov_mat">cov_mat()</a></code> and controls the
smoothness of the Gaussian process. Should be between <code>1</code> (no smoothness,
piecewise straight lines between each subsequent <code>x</code>/<code>y</code>-coordinate if
<code>lengthscale</code> described below is <code>1</code>) and <code>2</code>; defaults to <code>1.95</code>, which
leads to slightly faster decay of correlations when <code>x</code> values are
internally scaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>-range compared to <code>2</code>.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_lengthscale">lengthscale</code></td>
<td>
<p>single numerical value (default <code>1</code>) or numerical vector
of length <code>2</code>; all values must be finite and non-negative. If a single
value is provided, this will be used as the <code>lengthscale</code> hyperparameter
and passed directly to <code><a href="#topic+cov_mat">cov_mat()</a></code>. If a numerical vector of length <code>2</code> is
provided, the second value must be higher than the first and the optimal
<code>lengthscale</code> in this range will be found using an optimisation algorithm.
If any value is <code>0</code>, a minimum amount of noise will be added as
lengthscales must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>. Controls smoothness/decay in combination
with <code>pow</code>.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_scale_x">scale_x</code></td>
<td>
<p>single logical value; if <code>TRUE</code> (the default) the <code>x</code>-values
will be scaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> range according to the minimum/maximum
values provided. If <code>FALSE</code>, the model will use the original scale. If
distances on the original scale are small, scaling may be preferred. The
returned values will always be on the original scale.</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_noisy">noisy</code></td>
<td>
<p>single logical value. If <code>FALSE</code> (the default), a noiseless
process is assumed, and interpolation between values is performed (i.e.,
with no uncertainty at the evaluated <code>x</code>-values); if <code>TRUE</code>, the <code>y</code>-values
are assumed to come from a noisy process, and regression is performed
(i.e., some uncertainty at the evaluated <code>x</code>-values will be included in the
predictions, with the amount estimated using an optimisation algorithm).</p>
</td></tr>
<tr><td><code id="gp_opt_+3A_narrow">narrow</code></td>
<td>
<p>single logical value. If <code>FALSE</code> (the default), predictions are
evenly spread over the full <code>x</code>-range. If <code>TRUE</code>, the prediction grid will
be spread evenly over an interval consisting of the two <code>x</code>-values with
corresponding <code>y</code>-values closest to the target in opposite directions. This
setting should only be used if <code>noisy</code> is <code>FALSE</code> and only if the function
can safely be assumed to be only monotonically increasing or decreasing, in
which case this will lead to a faster search and a smoother prediction grid
in the relevant region without increasing memory use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing two elements, <code>next_x</code>, a single numerical value, the
suggested next <code>x</code> value at which to evaluate the function, and
<code>predictions</code>, a <code>data.frame</code> with <code>resolution</code> rows and the four columns:
<code>x</code>, the <code>x</code> grid values where predictions are made; <code>y_hat</code>, the predicted
means, and <code>lub</code> and <code>uub</code>, the lower and upper uncertainty bounds of the
predictions according to <code>kappa</code>.
</p>


<h3>References</h3>

<p>Gramacy RB (2020). Chapter 5: Gaussian Process Regression. In: Surrogates:
Gaussian Process Modeling, Design and Optimization for the Applied Sciences.
Chapman Hall/CRC, Boca Raton, Florida, USA.
<a href="https://bookdown.org/rbg/surrogates/chap5.html">Available online</a>.
</p>
<p>Greenhill S, Rana S, Gupta S, Vellanki P, Venkatesh S (2020). Bayesian
Optimization for Adaptive Experimental Design: A Review. IEEE Access, 8,
13937-13948. <a href="https://doi.org/10.1109/ACCESS.2020.2966228">doi:10.1109/ACCESS.2020.2966228</a>
</p>

<hr>
<h2 id='make_x_scale'>Make x-axis scale for history/status plots</h2><span id='topic+make_x_scale'></span>

<h3>Description</h3>

<p>Used internally. Prepares the x-axis scale for history/status plots.
Requires the <code>ggplot2</code> package installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_x_scale(x_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_x_scale_+3A_x_value">x_value</code></td>
<td>
<p>single character string, determining whether the number of
adaptive analysis looks (<code>"look"</code>, default), the total cumulated number of
patients randomised (<code>"total n"</code>) or the total cumulated number of patients
with outcome data available at each adaptive analysis (<code>"followed n"</code>) are
plotted on the x-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An appropriate scale for the <code>ggplot2</code> plot x-axis according to
the value specified in <code>x_value</code>.
</p>

<hr>
<h2 id='make_y_scale'>Make y-axis scale for history/status plots</h2><span id='topic+make_y_scale'></span>

<h3>Description</h3>

<p>Used internally. Prepares the y-axis scale for history/status plots.
Requires the <code>ggplot2</code> package installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_y_scale(y_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_y_scale_+3A_y_value">y_value</code></td>
<td>
<p>single character string, determining which values are plotted
on the y-axis. The following options are available: allocation
probabilities (<code>"prob"</code>, default), the total number of patients with
outcome data available (<code>"n"</code>) or randomised (<code>"n all"</code>) to each arm,
the percentage of patients with outcome data available (<code>"pct"</code>) or
randomised (<code>"pct all"</code>) to each arm out of the current total, the sum of
all available (<code>"sum ys"</code>) outcome data or all outcome data for randomised
patients including outcome data not available at the time of the current
adaptive analysis (<code>"sum ys all"</code>), the ratio of outcomes as defined for
<code>"sum ys"</code>/<code>"sum ys all"</code> divided by the corresponding number of patients
in each arm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An appropriate scale for the <code>ggplot2</code> plot y-axis according to
the value specified in <code>y_value</code>.
</p>

<hr>
<h2 id='plot_convergence'>Plot convergence of performance metrics</h2><span id='topic+plot_convergence'></span>

<h3>Description</h3>

<p>Plots performance metrics according to the number of simulations conducted
for multiple simulated trials. The simulated trial results may be split into
a number of batches to illustrate stability of performance metrics across
different simulations. Calculations are done according to specified selection
and restriction strategies as described in <code><a href="#topic+extract_results">extract_results()</a></code> and
<code><a href="#topic+check_performance">check_performance()</a></code>. Requires the <code>ggplot2</code> package installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_convergence(
  object,
  metrics = "size mean",
  resolution = 100,
  select_strategy = "control if available",
  select_last_arm = FALSE,
  select_preferences = NULL,
  te_comp = NULL,
  raw_ests = FALSE,
  final_ests = NULL,
  restrict = NULL,
  n_split = 1,
  nrow = NULL,
  ncol = NULL,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_convergence_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_metrics">metrics</code></td>
<td>
<p>the performance metrics to plot, as described in
<code><a href="#topic+check_performance">check_performance()</a></code>. Multiple metrics may be plotted at the same time.
Valid metrics include: <code>size_mean</code>, <code>size_sd</code>, <code>size_median</code>, <code>size_p25</code>,
<code>size_p75</code>, <code>size_p0</code>, <code>size_p100</code>, <code>sum_ys_mean</code>, <code>sum_ys_sd</code>,
<code>sum_ys_median</code>, <code>sum_ys_p25</code>, <code>sum_ys_p75</code>, <code>sum_ys_p0</code>, <code>sum_ys_p100</code>,
<code>ratio_ys_mean</code>, <code>ratio_ys_sd</code>, <code>ratio_ys_median</code>, <code>ratio_ys_p25</code>,
<code>ratio_ys_p75</code>, <code>ratio_ys_p0</code>, <code>ratio_ys_p100</code>, <code>prob_conclusive</code>,
<code>prob_superior</code>, <code>prob_equivalence</code>, <code>prob_futility</code>, <code>prob_max</code>,
<code style="white-space: pre;">&#8288;prob_select_*&#8288;</code> (with <code>*</code> being either &quot;<code style="white-space: pre;">&#8288;arm_&lt;name&gt;&#8288;</code> for all <code>arm</code> names or
<code>none</code>), <code>rmse</code>, <code>rmse_te</code>, and <code>idp</code>. All may be specified as above,
case sensitive, but with either spaces or underlines. Defaults to
<code>"size mean"</code>.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_resolution">resolution</code></td>
<td>
<p>single positive integer, the number of points calculated
and plotted, defaults to <code>100</code> and must be <code style="white-space: pre;">&#8288;&gt;= 10&#8288;</code>. Higher numbers lead to
smoother plots, but increases computation time. If the value specified is
higher than the number of simulations (or simulations per split), the
maximum possible value will be used instead.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_convergence_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_raw_ests">raw_ests</code></td>
<td>
<p>single logical. If <code>FALSE</code> (default), the
posterior estimates (<code>post_ests</code> or <code>post_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used to calculate <code>sq_err</code> (the squared error of
the estimated compared to the specified effect in the selected arm) and
<code>sq_err_te</code> (the squared error of the treatment effect comparing the
selected arm to the comparator arm, as described for <code>te_comp</code> and below).
If <code>TRUE</code>, the raw estimates (<code>raw_ests</code> or <code>raw_ests_all</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used instead of the posterior
estimates.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_final_ests">final_ests</code></td>
<td>
<p>single logical. If <code>TRUE</code> (recommended) the final estimates
calculated using outcome data from all patients randomised when trials are
stopped are used (<code>post_ests_all</code> or <code>raw_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>); if <code>FALSE</code>, the estimates calculated for each arm when
an arm is stopped (or at the last adaptive analysis if not before) using
data from patients having reach followed up at this time point and not all
patients randomised are used (<code>post_ests</code> or <code>raw_ests</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>). If <code>NULL</code> (the default), this argument
will be set to <code>FALSE</code> if outcome data are available immediate after
randomisation for all patients (for backwards compatibility, as final
posterior estimates may vary slightly in this situation, even if using the
same data); otherwise it will be said to <code>TRUE</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> for
more details on how these estimates are calculated.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_restrict">restrict</code></td>
<td>
<p>single character string or <code>NULL</code>. If <code>NULL</code> (default),
results are summarised for all simulations; if <code>"superior"</code>, results are
summarised for simulations ending with superiority only; if <code>"selected"</code>,
results are summarised for simulations ending with a selected arm only
(according to the specified arm selection strategy for simulations not
ending with superiority). Some summary measures (e.g., <code>prob_conclusive</code>)
have substantially different interpretations if restricted, but are
calculated nonetheless.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_n_split">n_split</code></td>
<td>
<p>single positive integer, the number of consecutive batches the
simulation results will be split into, which will be plotted separately.
Default is <code>1</code> (no splitting); maximum value is the number of simulations
summarised (after restrictions) divided by 10.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_nrow">nrow</code>, <code id="plot_convergence_+3A_ncol">ncol</code></td>
<td>
<p>the number of rows and columns when plotting multiple
metrics in the same plot (using faceting in <code>ggplot2</code>). Defaults to <code>NULL</code>,
in which case this will be determined automatically.</p>
</td></tr>
<tr><td><code id="plot_convergence_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+extract_results">extract_results()</a></code>,
<code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Only run examples if ggplot2 is installed ####
if (requireNamespace("ggplot2", quietly = TRUE)){

  # Setup a trial specification
  binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                   control = "A",
                                   true_ys = c(0.20, 0.18, 0.22, 0.24),
                                   data_looks = 1:20 * 100)

  # Run multiple simulation with a fixed random base seed
  res_mult &lt;- run_trials(binom_trial, n_rep = 25, base_seed = 678)

  # NOTE: the number of simulations in this example is smaller than
  # recommended - the plots reflect that, and show that performance metrics
  # are not stable and have likely not converged yet

  # Convergence plot of mean sample sizes
  plot_convergence(res_mult, metrics = "size mean")

}

if (requireNamespace("ggplot2", quietly = TRUE)){

  # Convergence plot of mean sample sizes and ideal design percentages,
  # with simulations split in 2 batches
  plot_convergence(res_mult, metrics = c("size mean", "idp"), n_split = 2)

}

</code></pre>

<hr>
<h2 id='plot_history'>Plot trial metric history</h2><span id='topic+plot_history'></span><span id='topic+plot_history.trial_result'></span><span id='topic+plot_history.trial_results'></span>

<h3>Description</h3>

<p>Plots the history of relevant metrics over the progress of a single or
multiple trial simulations. Simulated trials <strong>only</strong> contribute until the
time they are stopped, i.e., if some trials are stopped earlier than others,
they will not contribute to the summary statistics at later adaptive looks.
Data from individual arms in a trial contribute until the complete trial is
stopped.<br />
These history plots require non-sparse results (<code>sparse</code> set to
<code>FALSE</code>; see <code><a href="#topic+run_trial">run_trial()</a></code> and <code><a href="#topic+run_trials">run_trials()</a></code>) and the <code>ggplot2</code> package
installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_history(object, x_value = "look", y_value = "prob", line = NULL, ...)

## S3 method for class 'trial_result'
plot_history(object, x_value = "look", y_value = "prob", line = NULL, ...)

## S3 method for class 'trial_results'
plot_history(
  object,
  x_value = "look",
  y_value = "prob",
  line = NULL,
  ribbon = list(width = 0.5, alpha = 0.2),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_history_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_history_+3A_x_value">x_value</code></td>
<td>
<p>single character string, determining whether the number of
adaptive analysis looks (<code>"look"</code>, default), the total cumulated number of
patients randomised (<code>"total n"</code>) or the total cumulated number of patients
with outcome data available at each adaptive analysis (<code>"followed n"</code>) are
plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="plot_history_+3A_y_value">y_value</code></td>
<td>
<p>single character string, determining which values are plotted
on the y-axis. The following options are available: allocation
probabilities (<code>"prob"</code>, default), the total number of patients with
outcome data available (<code>"n"</code>) or randomised (<code>"n all"</code>) to each arm,
the percentage of patients with outcome data available (<code>"pct"</code>) or
randomised (<code>"pct all"</code>) to each arm out of the current total, the sum of
all available (<code>"sum ys"</code>) outcome data or all outcome data for randomised
patients including outcome data not available at the time of the current
adaptive analysis (<code>"sum ys all"</code>), the ratio of outcomes as defined for
<code>"sum ys"</code>/<code>"sum ys all"</code> divided by the corresponding number of patients
in each arm.</p>
</td></tr>
<tr><td><code id="plot_history_+3A_line">line</code></td>
<td>
<p>list styling the lines as per <code>ggplot2</code> conventions (e.g.,
<code>linetype</code>, <code>linewidth</code>).</p>
</td></tr>
<tr><td><code id="plot_history_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
<tr><td><code id="plot_history_+3A_ribbon">ribbon</code></td>
<td>
<p>list, as <code>line</code> but only appropriate for <code>trial_results</code>
objects (i.e., when multiple simulations are run). Also allows to specify
the <code>width</code> of the interval: must be between 0 and 1, with <code>0.5</code> (default)
showing the inter-quartile ranges.</p>
</td></tr>
<tr><td><code id="plot_history_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_status">plot_status()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Only run examples if ggplot2 is installed ####
if (requireNamespace("ggplot2", quietly = TRUE)){

  # Setup a trial specification
  binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                   control = "A",
                                   true_ys = c(0.20, 0.18, 0.22, 0.24),
                                   data_looks = 1:20 * 100)



  # Run a single simulation with a fixed random seed
  res &lt;- run_trial(binom_trial, seed = 12345)

  # Plot total allocations to each arm according to overall total allocations
  plot_history(res, x_value = "total n", y_value = "n")

}

if (requireNamespace("ggplot2", quietly = TRUE)){

  # Run multiple simulation with a fixed random base seed
  # Notice that sparse = FALSE is required
  res_mult &lt;- run_trials(binom_trial, n_rep = 15, base_seed = 12345, sparse = FALSE)

  # Plot allocation probabilities at each look
  plot_history(res_mult, x_value = "look", y_value = "prob")

  # Other y_value options are available but not shown in these examples

}

</code></pre>

<hr>
<h2 id='plot_metrics_ecdf'>Plot empirical cumulative distribution functions of performance metrics</h2><span id='topic+plot_metrics_ecdf'></span>

<h3>Description</h3>

<p>Plots empirical cumulative distribution functions (ECDFs) of numerical
performance metrics across multiple simulations from a <code>"trial_results"</code>
object returned by <code><a href="#topic+run_trials">run_trials()</a></code>. Requires the <code>ggplot2</code> package installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_metrics_ecdf(
  object,
  metrics = c("size", "sum_ys", "ratio_ys"),
  restrict = NULL,
  nrow = NULL,
  ncol = NULL,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_metrics_ecdf_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_metrics_ecdf_+3A_metrics">metrics</code></td>
<td>
<p>the performance metrics to plot, as described in
<code><a href="#topic+extract_results">extract_results()</a></code>. Multiple metrics may be plotted at the same time.
Valid metrics include: <code>size</code>, <code>sum_ys</code>, and <code>ratio_ys_mean</code>. All may be
specified using either spaces or underlines (case sensitive). Defaults to
plotting all three.</p>
</td></tr>
<tr><td><code id="plot_metrics_ecdf_+3A_restrict">restrict</code></td>
<td>
<p>single character string or <code>NULL</code>. If <code>NULL</code> (default),
results are summarised for all simulations; if <code>"superior"</code>, results are
summarised for simulations ending with superiority only; if <code>"selected"</code>,
results are summarised for simulations ending with a selected arm only
(according to the specified arm selection strategy for simulations not
ending with superiority). Some summary measures (e.g., <code>prob_conclusive</code>)
have substantially different interpretations if restricted, but are
calculated nonetheless.</p>
</td></tr>
<tr><td><code id="plot_metrics_ecdf_+3A_nrow">nrow</code>, <code id="plot_metrics_ecdf_+3A_ncol">ncol</code></td>
<td>
<p>the number of rows and columns when plotting multiple
metrics in the same plot (using faceting in <code>ggplot2</code>). Defaults to <code>NULL</code>,
in which case this will be determined automatically.</p>
</td></tr>
<tr><td><code id="plot_metrics_ecdf_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+extract_results">extract_results()</a></code>,
<code><a href="#topic+plot_convergence">plot_convergence()</a></code>, <code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Only run examples if ggplot2 is installed ####
if (requireNamespace("ggplot2", quietly = TRUE)){

  # Setup a trial specification
  binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                   control = "A",
                                   true_ys = c(0.20, 0.18, 0.22, 0.24),
                                   data_looks = 1:20 * 100)

  # Run multiple simulation with a fixed random base seed
  res_mult &lt;- run_trials(binom_trial, n_rep = 25, base_seed = 678)

  # NOTE: the number of simulations in this example is smaller than
  # recommended - the plots reflect that, and would likely be smoother if
  # a larger number of trials had been simulated

  # Plot ECDFs of continuous performance metrics
  plot_metrics_ecdf(res_mult)

}

</code></pre>

<hr>
<h2 id='plot_status'>Plot statuses</h2><span id='topic+plot_status'></span><span id='topic+plot_status.trial_results'></span>

<h3>Description</h3>

<p>Plots the statuses over time of multiple simulated trials (overall or for one
or more specific arms). Requires the <code>ggplot2</code> package installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_status(
  object,
  x_value = "look",
  arm = NULL,
  area = list(alpha = 0.5),
  nrow = NULL,
  ncol = NULL
)

## S3 method for class 'trial_results'
plot_status(
  object,
  x_value = "look",
  arm = NULL,
  area = list(alpha = 0.5),
  nrow = NULL,
  ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_status_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_status_+3A_x_value">x_value</code></td>
<td>
<p>single character string, determining whether the number of
adaptive analysis looks (<code>"look"</code>, default), the total cumulated number of
patients randomised (<code>"total n"</code>) or the total cumulated number of patients
with outcome data available at each adaptive analysis (<code>"followed n"</code>) are
plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="plot_status_+3A_arm">arm</code></td>
<td>
<p>character vector containing one or more unique, valid <code>arm</code> names,
<code>NA</code>, or <code>NULL</code> (default). If <code>NULL</code>, the overall trial statuses are plotted,
otherwise the specified arms or all arms (if <code>NA</code> is specified) are plotted.</p>
</td></tr>
<tr><td><code id="plot_status_+3A_area">area</code></td>
<td>
<p>list of styling settings for the area as per <code>ggplot2</code>
conventions (e.g., <code>alpha</code>, <code>linewidth</code>). The default (<code>list(alpha = 0.5)</code>)
sets the transparency to 50% so overlain shaded areas are visible.</p>
</td></tr>
<tr><td><code id="plot_status_+3A_nrow">nrow</code>, <code id="plot_status_+3A_ncol">ncol</code></td>
<td>
<p>the number of rows and columns when plotting statuses for
multiple arms in the same plot (using faceting in <code>ggplot2</code>). Defaults to
<code>NULL</code>, in which case this will be determined automatically where relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_history">plot_history()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Only run examples if ggplot2 is installed ####
if (requireNamespace("ggplot2", quietly = TRUE)){

  # Setup a trial specification
  binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                   control = "A",
                                   true_ys = c(0.20, 0.18, 0.22, 0.24),
                                   data_looks = 1:20 * 100)

  # Run multiple simulation with a fixed random base seed
  res_mult &lt;- run_trials(binom_trial, n_rep = 25, base_seed = 12345)

  # Plot trial statuses at each look according to total allocations
  plot_status(res_mult, x_value = "total n")

}

if (requireNamespace("ggplot2", quietly = TRUE)){

  # Plot trial statuses for all arms
  plot_status(res_mult, arm = NA)

}

</code></pre>

<hr>
<h2 id='pow_abs_dist'>Calculates matrix of absolute distances raised to a power</h2><span id='topic+pow_abs_dist'></span>

<h3>Description</h3>

<p>Used internally, calculates the absolute distances for values in a matrix
with possibly unequal dimensions, and raises these to a power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_abs_dist(x1, x2 = x1, pow = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_abs_dist_+3A_x1">x1</code></td>
<td>
<p>numeric vector, with length corresponding to the number of rows in
the returned matrix.</p>
</td></tr>
<tr><td><code id="pow_abs_dist_+3A_x2">x2</code></td>
<td>
<p>numeric vector, with length corresponding to the number of columns
in the returned matrix. If not specified, <code>x1</code> will be used for <code>x2</code>.</p>
</td></tr>
<tr><td><code id="pow_abs_dist_+3A_pow">pow</code></td>
<td>
<p>single numeric value, the power that all distances are raised to.
Defaults to <code>2</code>, corresponding to pairwise, squared, Euclidean distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with <code>length(x1)</code> rows and <code>length(x2)</code> columns including the
calculated absolute pairwise distances raised to <code>pow</code>.
</p>

<hr>
<h2 id='print'>Print methods for adaptive trial objects</h2><span id='topic+print'></span><span id='topic+print.trial_spec'></span><span id='topic+print.trial_result'></span><span id='topic+print.trial_performance'></span><span id='topic+print.trial_results'></span><span id='topic+print.trial_results_summary'></span><span id='topic+print.trial_calibration'></span>

<h3>Description</h3>

<p>Prints contents of the first input <code>x</code> in a human-friendly way, see
<strong>Details</strong> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trial_spec'
print(x, prob_digits = 3, ...)

## S3 method for class 'trial_result'
print(x, prob_digits = 3, ...)

## S3 method for class 'trial_performance'
print(x, digits = 3, ...)

## S3 method for class 'trial_results'
print(
  x,
  select_strategy = "control if available",
  select_last_arm = FALSE,
  select_preferences = NULL,
  te_comp = NULL,
  raw_ests = FALSE,
  final_ests = NULL,
  restrict = NULL,
  digits = 1,
  cores = NULL,
  ...
)

## S3 method for class 'trial_results_summary'
print(x, digits = 1, ...)

## S3 method for class 'trial_calibration'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>object to print, see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="print_+3A_prob_digits">prob_digits</code></td>
<td>
<p>single integer (default is <code>3</code>), the number of digits used
when printing probabilities, allocation probabilities and softening powers
(with <code>2</code> extra digits added for stopping rule probability thresholds in
trial specifications and for outcome rates in summarised results from
multiple simulations).</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>single integer, the number of digits used when printing
the numeric results. Default is <code>3</code> for outputs from <code><a href="#topic+check_performance">check_performance()</a></code>
and <code>1</code> for outputs from <code><a href="#topic+run_trials">run_trials()</a></code> and the accompanying <code><a href="#topic+summary">summary()</a></code>
method.</p>
</td></tr>
<tr><td><code id="print_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="print_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="print_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="print_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="print_+3A_raw_ests">raw_ests</code></td>
<td>
<p>single logical. If <code>FALSE</code> (default), the
posterior estimates (<code>post_ests</code> or <code>post_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used to calculate <code>sq_err</code> (the squared error of
the estimated compared to the specified effect in the selected arm) and
<code>sq_err_te</code> (the squared error of the treatment effect comparing the
selected arm to the comparator arm, as described for <code>te_comp</code> and below).
If <code>TRUE</code>, the raw estimates (<code>raw_ests</code> or <code>raw_ests_all</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used instead of the posterior
estimates.</p>
</td></tr>
<tr><td><code id="print_+3A_final_ests">final_ests</code></td>
<td>
<p>single logical. If <code>TRUE</code> (recommended) the final estimates
calculated using outcome data from all patients randomised when trials are
stopped are used (<code>post_ests_all</code> or <code>raw_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>); if <code>FALSE</code>, the estimates calculated for each arm when
an arm is stopped (or at the last adaptive analysis if not before) using
data from patients having reach followed up at this time point and not all
patients randomised are used (<code>post_ests</code> or <code>raw_ests</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>). If <code>NULL</code> (the default), this argument
will be set to <code>FALSE</code> if outcome data are available immediate after
randomisation for all patients (for backwards compatibility, as final
posterior estimates may vary slightly in this situation, even if using the
same data); otherwise it will be said to <code>TRUE</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> for
more details on how these estimates are calculated.</p>
</td></tr>
<tr><td><code id="print_+3A_restrict">restrict</code></td>
<td>
<p>single character string or <code>NULL</code>. If <code>NULL</code> (default),
results are summarised for all simulations; if <code>"superior"</code>, results are
summarised for simulations ending with superiority only; if <code>"selected"</code>,
results are summarised for simulations ending with a selected arm only
(according to the specified arm selection strategy for simulations not
ending with superiority). Some summary measures (e.g., <code>prob_conclusive</code>)
have substantially different interpretations if restricted, but are
calculated nonetheless.</p>
</td></tr>
<tr><td><code id="print_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behaviour depends on the class of <code>x</code>:
</p>

<ul>
<li> <p><code>trial_spec</code>: prints a trial specification setup by
<code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>trial_result</code>: prints the results of a single trial simulated by
<code><a href="#topic+run_trial">run_trial()</a></code>. More details are saved in the <code>trial_result</code> object and thus
printed if the <code>sparse</code> argument in <code><a href="#topic+run_trial">run_trial()</a></code> or <code><a href="#topic+run_trials">run_trials()</a></code> is set to
<code>FALSE</code>; if <code>TRUE</code>, fewer details are printed, but the omitted details are
available by printing the <code>trial_spec</code> object created by <code><a href="#topic+setup_trial">setup_trial()</a></code>,
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>trial_results</code>: prints the results of multiple simulations
generated using <code><a href="#topic+run_trials">run_trials()</a></code>. Further documentation on how multiple trials
are summarised before printing can be found in the <code><a href="#topic+summary">summary()</a></code> function
documentation.
</p>
</li></ul>


<ul>
<li> <p><code>trial_results_summary</code>: print method for summary of multiple simulations
of the same trial specification, generated by using the <code><a href="#topic+summary">summary()</a></code> function
on an object generated by <code><a href="#topic+run_trials">run_trials()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Invisibly returns <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>print(trial_spec)</code>: Trial specification
</p>
</li>
<li> <p><code>print(trial_result)</code>: Single trial result
</p>
</li>
<li> <p><code>print(trial_performance)</code>: Trial performance metrics
</p>
</li>
<li> <p><code>print(trial_results)</code>: Multiple trial results
</p>
</li>
<li> <p><code>print(trial_results_summary)</code>: Summary of multiple trial results
</p>
</li>
<li> <p><code>print(trial_calibration)</code>: Trial calibration
</p>
</li></ul>

<hr>
<h2 id='prob_all_equi'>Calculate the probability that all arms are practically equivalent</h2><span id='topic+prob_all_equi'></span>

<h3>Description</h3>

<p>Used internally. This function takes a <code>matrix</code> as calculated by the
<code><a href="#topic+get_draws_binom">get_draws_binom()</a></code>, <code><a href="#topic+get_draws_norm">get_draws_norm()</a></code> or a corresponding custom function
(specified using the <code>fun_draws</code> argument in <code><a href="#topic+setup_trial">setup_trial()</a></code>; see
<code><a href="#topic+get_draws_generic">get_draws_generic()</a></code>), and an equivalence difference, and calculates the
probability of all arms being equivalent (absolute differences between
highest and lowest value in the same set of posterior draws being less than
the difference considered practically equivalent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_all_equi(m, equivalence_diff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_all_equi_+3A_m">m</code></td>
<td>
<p>a matrix with one column per trial arm (named as the <code>arms</code>) and one
row for each draw from the posterior distributions.</p>
</td></tr>
<tr><td><code id="prob_all_equi_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to the probability of all arms
being practically equivalent.
</p>

<hr>
<h2 id='prob_best'>Calculate the probabilities of each arm being the best</h2><span id='topic+prob_best'></span>

<h3>Description</h3>

<p>Used internally. This function takes a <code>matrix</code> as calculated by the
<code><a href="#topic+get_draws_binom">get_draws_binom()</a></code>, <code><a href="#topic+get_draws_norm">get_draws_norm()</a></code> or a corresponding custom function
(as specified using the <code>fun_draws</code> argument in <code><a href="#topic+setup_trial">setup_trial()</a></code>; see
<code><a href="#topic+get_draws_generic">get_draws_generic()</a></code>) and calculates the probabilities of each arm being the
best (defined as either the highest or the lowest value, as specified by the
<code>highest_is_best</code> argument in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_best(m, highest_is_best = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_best_+3A_m">m</code></td>
<td>
<p>a matrix with one column per trial arm (named as the <code>arms</code>) and one
row for each draw from the posterior distributions.</p>
</td></tr>
<tr><td><code id="prob_best_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of probabilities (names corresponding to
<code>arms</code>).
</p>

<hr>
<h2 id='prob_better'>Calculate probabilities of comparisons of arms against with common control</h2><span id='topic+prob_better'></span>

<h3>Description</h3>

<p>Used internally. This function takes a <code>matrix</code> as calculated by the
<code><a href="#topic+get_draws_binom">get_draws_binom()</a></code>, <code><a href="#topic+get_draws_norm">get_draws_norm()</a></code> or a corresponding custom function
(as specified using the <code>fun_draws</code> argument in <code><a href="#topic+setup_trial">setup_trial()</a></code>; see
<code><a href="#topic+get_draws_generic">get_draws_generic()</a></code>) and a single character specifying the <code>control</code> arm,
and calculates the probabilities of each arm being better than a common
<code>control</code> (defined as either higher or lower than the <code>control</code>, as specified
by the <code>highest_is_best</code> argument in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>
or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>). This function also calculates equivalence and
futility probabilities compared to the common <code>control</code> arm, as specified in
<code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>, unless
<code>equivalence_diff</code> or <code>futility_diff</code>, respectively, are set to <code>NULL</code>
(the default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_better(
  m,
  control = NULL,
  highest_is_best = FALSE,
  equivalence_diff = NULL,
  futility_diff = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_better_+3A_m">m</code></td>
<td>
<p>a matrix with one column per trial arm (named as the <code>arms</code>) and one
row for each draw from the posterior distributions.</p>
</td></tr>
<tr><td><code id="prob_better_+3A_control">control</code></td>
<td>
<p>a single character string specifying the common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="prob_better_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
<tr><td><code id="prob_better_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
<tr><td><code id="prob_better_+3A_futility_diff">futility_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no futility assessment). If a numeric value is specified,
estimated differences below this threshold in the <em>beneficial</em> direction
(as specified in <code>highest_is_best</code>) will be considered futile when
assessing futility in designs with a common <code>control</code> arm. If only 1 arm
remains after dropping arms for futility, the trial will be stopped without
declaring the last arm superior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named (row names corresponding to the trial <code>arms</code>) <code>matrix</code>
containing 1-3 columns: <code>probs_better</code>, <code>probs_equivalence</code> (if
<code>equivalence_diff</code> is specified), and <code>probs_futile</code> (if <code>futility_diff</code> is
specified). All columns will contain <code>NA</code> for the control arm.
</p>

<hr>
<h2 id='prog_breaks'>Generate breakpoints and other values for printing progress</h2><span id='topic+prog_breaks'></span>

<h3>Description</h3>

<p>Used internally. Generates breakpoints, messages, and 'batches' of trial
numbers to simulate when using <code><a href="#topic+run_trials">run_trials()</a></code> with the <code>progress</code> argument in
use. Breaks will be multiples of the number of <code>cores</code>, and repeated use of
the same values for breaks is avoided (if, e.g., the number of breaks times
the number of cores is not possible if few new trials are to be run). Inputs
are validated by <code><a href="#topic+run_trials">run_trials()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prog_breaks(progress, prev_n_rep, n_rep_new, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prog_breaks_+3A_progress">progress</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code> or <code>NULL</code>. If <code>NULL</code>
(default), no progress is printed to the console. Otherwise, progress
messages are printed to the control at intervals proportional to the value
specified by progress.<br />
<strong>Note:</strong> as printing is not possible from within clusters on multiple
cores, the function conducts batches of simulations on multiple cores (if
specified), with intermittent printing of statuses. Thus, all cores have to
finish running their current assigned batches before the other cores may
proceed with the next batch. If there are substantial differences in the
simulation speeds across cores, using <code>progress</code> may thus increase total
run time (especially with small values).</p>
</td></tr>
<tr><td><code id="prog_breaks_+3A_prev_n_rep">prev_n_rep</code></td>
<td>
<p>single integer, the previous number of simulations run (to
add to the indices generated and used).</p>
</td></tr>
<tr><td><code id="prog_breaks_+3A_n_rep_new">n_rep_new</code></td>
<td>
<p>single integers, number of new simulations to run (i.e.,
<code>n_rep</code> as supplied to <code><a href="#topic+run_trials">run_trials()</a></code> minus the number of previously run
simulations if <code>grow</code> is used in <code><a href="#topic+run_trials">run_trials()</a></code>).</p>
</td></tr>
<tr><td><code id="prog_breaks_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value/cluster set
by <code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether simulations are run in
parallel on a default cluster or sequentially in the main process; if a
cluster/value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>, <code>cores</code> will
then be set to the value stored in the global <code>"mc.cores"</code> option (if
previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and <code>1</code> if that
option has not been specified.<br />
If the resulting number of <code>cores = 1</code>, computations will be run
sequentially in the primary process, and if <code>cores &gt; 1</code>, a new parallel
cluster will be setup using the <code>parallel</code> library and removed once the
function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing <code>breaks</code> (the number of patients at each break),
<code>start_mess</code> and <code>prog_mess</code> (the basis of the first and subsequent
progress messages), and <code>batches</code> (a list with each entry corresponding to
the simulation numbers in each batch).
</p>

<hr>
<h2 id='reallocate_probs'>Update allocation probabilities</h2><span id='topic+reallocate_probs'></span>

<h3>Description</h3>

<p>Used internally. This function calculates new allocation probabilities for
each arm, based on the information specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>,
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> and the calculated
probabilities of each arm being the best by <code><a href="#topic+prob_best">prob_best()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reallocate_probs(
  probs_best,
  fixed_probs,
  min_probs,
  max_probs,
  soften_power = 1,
  match_arm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reallocate_probs_+3A_probs_best">probs_best</code></td>
<td>
<p>a resulting named vector from the <code><a href="#topic+prob_best">prob_best()</a></code> function.</p>
</td></tr>
<tr><td><code id="reallocate_probs_+3A_fixed_probs">fixed_probs</code></td>
<td>
<p>numeric vector, fixed allocation probabilities for each
arm. Must be either a numeric vector with <code>NA</code> for arms without fixed
probabilities and values between <code>0</code> and <code>1</code> for the other arms or <code>NULL</code>
(default), if adaptive randomisation is used for all arms or if one of the
special settings (<code>"sqrt-based"</code>, <code>"sqrt-based start"</code>,
<code>"sqrt-based fixed"</code>, or <code>"match"</code>) is specified for <code>control_prob_fixed</code>
(described below).</p>
</td></tr>
<tr><td><code id="reallocate_probs_+3A_min_probs">min_probs</code></td>
<td>
<p>numeric vector, lower threshold for adaptive allocation
probabilities; lower probabilities will be rounded up to these values. Must
be <code>NA</code> (default for all arms) if no lower threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="reallocate_probs_+3A_max_probs">max_probs</code></td>
<td>
<p>numeric vector, upper threshold for adaptive allocation
probabilities; higher probabilities will be rounded down to these values.
Must be <code>NA</code> (default for all arms) if no threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="reallocate_probs_+3A_soften_power">soften_power</code></td>
<td>
<p>either a single numeric value or a numeric vector of
exactly the same length as the maximum number of looks/adaptive analyses.
Values must be between <code>0</code> and <code>1</code> (default); if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, then re-allocated
non-fixed allocation probabilities are all raised to this power (followed
by rescaling to sum to <code>1</code>) to make adaptive allocation probabilities
less extreme, in turn used to redistribute remaining probability while
respecting limits when defined by <code>min_probs</code> and/or <code>max_probs</code>. If <code>1</code>,
then no <em>softening</em> is applied.</p>
</td></tr>
<tr><td><code id="reallocate_probs_+3A_match_arm">match_arm</code></td>
<td>
<p>index of the <code>control</code> arm. If not <code>NULL</code> (default), the
control arm allocation probability will be similar to that of the best
non-control arm. Must be <code>NULL</code> in designs without a common control arm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named (according to the <code>arms</code>) numeric vector with updated
allocation probabilities.
</p>

<hr>
<h2 id='replace_nonfinite'>Replace non-finite values with other value (finite-OR-operator)</h2><span id='topic+replace_nonfinite'></span><span id='topic++25f+7C+25'></span>

<h3>Description</h3>

<p>Used internally, helper function that replaces non-finite (i.e., <code>NA</code>, <code>NaN</code>,
<code>Inf</code>, and <code>-Inf</code>) values according to <code><a href="Matrix.html#topic+is.finite">is.finite()</a></code>, primarily used to
replace <code>NaN</code>/<code>Inf</code>/<code>-Inf</code> with <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %f|% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_nonfinite_+3A_a">a</code></td>
<td>
<p>atomic vector of any type.</p>
</td></tr>
<tr><td><code id="replace_nonfinite_+3A_b">b</code></td>
<td>
<p>single value to replace non-finite values with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If values in <code>a</code> are non-finite, they are replaced with <code>b</code>,
otherwise they are left unchanged.
</p>

<hr>
<h2 id='replace_null'>Replace NULL with other value (NULL-OR-operator)</h2><span id='topic+replace_null'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>

<p>Used internally, primarily when working with list arguments, because, e.g.,
<code>list_name$element_name</code> yields <code>NULL</code> when unspecified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %||% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_null_+3A_a">a</code>, <code id="replace_null_+3A_b">b</code></td>
<td>
<p>atomic values of any type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>a</code> is <code>NULL</code>, <code>b</code> is returned. Otherwise <code>a</code> is returned.
</p>

<hr>
<h2 id='rescale'>Rescale numeric vector to sum to 1</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, <code>x</code> rescaled to sum to a total of 1.
</p>

<hr>
<h2 id='run_trial'>Simulate a single trial</h2><span id='topic+run_trial'></span>

<h3>Description</h3>

<p>This function conducts a single trial simulation using a trial specification
as specified by <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.<br />
During simulation, the function randomises &quot;patients&quot;, randomly generates
outcomes, calculates the probabilities that each <code>arm</code> is the best (and
better than the control, if any). This is followed by checking inferiority,
superiority, equivalence and/or futility as desired; dropping arms, and
re-adjusting allocation probabilities according to the criteria specified in
the trial specification. If there is no common <code>control</code> arm, the trial
simulation will be stopped at the final specified adaptive analysis, when 1
arm is superior to the others, or when all arms are considered equivalent (if
equivalence is assessed). If a common <code>control</code> arm is specified, all other
arms will be compared to that, and if 1 of these pairwise comparisons crosses
the applicable superiority threshold at an adaptive analysis, that arm will
become the new control and the old control will be considered inferior and
dropped. If multiple non-control arms cross the applicable superiority
threshold in the same adaptive analysis, the one with the highest probability
of being the overall best will become the new control. Equivalence/futility
will also be checked if specified, and equivalent or futile arms will be
dropped in designs with a common <code>control</code> arm and the entire trial will be
stopped if all remaining arms are equivalent in designs without a common
<code>control</code> arm. The trial simulation will be stopped when only 1 arm is left,
when the final arms are all equivalent, or after the final specified adaptive
analysis.<br />
After stopping (regardless of reason), a final analysis including outcome
data from all patients randomised to all arms will be conducted (with the
final <code>control</code> arm, if any, used as the <code>control</code> in this analysis).
Results from this analysis will be saved, but not used with regards to the
adaptive stopping rules. This is particularly relevant if less patients have
available outcome data at the last adaptive analyses than the total number of
patients randomised (as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>,
or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>), as the final analysis will then include all
patients randomised, which may be more than in the last adaptive analysis
conducted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_trial(trial_spec, seed = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_trial_+3A_trial_spec">trial_spec</code></td>
<td>
<p><code>trial_spec</code> object, generated and validated by the
<code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> function.</p>
</td></tr>
<tr><td><code id="run_trial_+3A_seed">seed</code></td>
<td>
<p>single integer or <code>NULL</code> (default). If a value is provided, this
value will be used as the random seed when running and the global random
seed will be restored after the function has run, so it is not affected.</p>
</td></tr>
<tr><td><code id="run_trial_+3A_sparse">sparse</code></td>
<td>
<p>single logical; if <code>FALSE</code> (default) everything listed below is
included in the returned object. If <code>TRUE</code>, only a limited amount of data
are included in the returned object. This can be practical when running
many simulations and saving the results using the <code><a href="#topic+run_trials">run_trials()</a></code> function
(which relies on this function), as the output file will thus be
substantially smaller. However, printing of individual trial results will
be substantially less detailed for sparse results and non-sparse results
are required by <code><a href="#topic+plot_history">plot_history()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trial_result</code> object containing everything listed below if
<code>sparse</code> (as described above) is <code>FALSE</code>. Otherwise only <code>final_status</code>,
<code>final_n</code>, <code>followed_n</code>, <code>trial_res</code>, <code>seed</code>, and <code>sparse</code> are included.
</p>

<ul>
<li> <p><code>final_status</code>: either <code>"superiority"</code>, <code>"equivalence"</code>,
<code>"futility"</code>, or <code>"max"</code> (stopped at the last possible adaptive
analysis), as calculated during the adaptive analyses.
</p>
</li>
<li> <p><code>final_n</code>: the total number of patients randomised.
</p>
</li>
<li> <p><code>followed_n</code>: the total number of patients with available outcome
data at the last adaptive analysis conducted.
</p>
</li>
<li> <p><code>max_n</code>: the pre-specified maximum number of patients with outcome
data available at the last possible adaptive analysis.
</p>
</li>
<li> <p><code>max_randomised</code>: the pre-specified maximum number of patients
randomised at the last possible adaptive analysis.
</p>
</li>
<li> <p><code>looks</code>: numeric vector, the total number of patients with outcome
data available at each conducted adaptive analysis.
</p>
</li>
<li> <p><code>planned_looks</code>: numeric vector, the cumulated number of patients
planned to have outcome data available at each adaptive analysis, even
those not conducted if the simulation is stopped before the final
possible analysis.
</p>
</li>
<li> <p><code>randomised_at_looks</code>: numeric vector, the cumulated number of
patients  randomised at each conducted adaptive analysis (only
including the relevant numbers for the analyses actually conducted).
</p>
</li>
<li> <p><code>start_control</code>: character, initial common <code>control</code> arm (if
specified).
</p>
</li>
<li> <p><code>final_control</code>: character, final common <code>control</code> arm
(if relevant).
</p>
</li>
<li> <p><code>control_prob_fixed</code>: fixed common <code>control</code> arm probabilities (if
specified; see <code><a href="#topic+setup_trial">setup_trial()</a></code>).
</p>
</li>
<li> <p><code>inferiority</code>, <code>superiority</code>, <code>equivalence_prob</code>,
<code>equivalence_diff</code>, <code>equivalence_only_first</code>, <code>futility_prob</code>,
<code>futility_diff</code>, <code>futility_only_first</code>, <code>highest_is_best</code>, and
<code>soften_power</code>: as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>.
</p>
</li>
<li> <p><code>best_arm</code>: the best <code>arm</code>(s), as described in <code><a href="#topic+setup_trial">setup_trial()</a></code>.
</p>
</li>
<li> <p><code>trial_res</code>: a <code>data.frame</code> containing most of the information
specified for each arm in <code><a href="#topic+setup_trial">setup_trial()</a></code> including <code>true_ys</code> (true
outcomes as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>) and for each arm the sum of
the outcomes (<code>sum_ys</code>/<code>sum_ys_all</code>; i.e., the total number of events
for binary outcomes or the totals of continuous outcomes) and sum of
patients (<code>ns</code>/<code>ns_all</code>), summary statistics for the raw outcome data
(<code>raw_ests</code>/<code>raw_ests_all</code>, calculated as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>,
defaults to mean values, i.e., event rates for binary outcomes or means
for continuous outcomes) and posterior estimates
(<code>post_ests</code>/<code>post_ests_all</code>, <code>post_errs</code>/<code>post_errs_all</code>,
<code>lo_cri</code>/<code>lo_cri_all</code>, and <code>hi_cri</code>/<code>hi_cri_all</code>, calculated as
specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>), <code>final_status</code> of each arm
(<code>"inferior"</code>, <code>"superior"</code>, <code>"equivalence"</code>, <code>"futile"</code>, <code>"active"</code>,
or <code>"control"</code> (currently active control arm, including if the current
control when stopped for equivalence)), <code>status_look</code> (specifying the
cumulated number of patients with outcome data available when an
adaptive analysis changed the <code>final_status</code> to <code>"superior"</code>,
<code>"inferior"</code>, <code>"equivalence"</code>, or <code>"futile"</code>), <code>status_probs</code>, the
probability (in the last adaptive analysis for each arm) that each
arm was the best/better than the common control arm (if any)/equivalent
to the common control arm (if any and stopped for equivalence; <code>NA</code> if
the control arm was stopped due to the last remaining other arm(s)
being stopped for equivalence)/futile if stopped for futility at the
last analysis it was included in, <code>final_alloc</code>, the final allocation
probability for each arm the last time patients were randomised to it,
including for arms stopped at the maximum sample size, and
<code>probs_best_last</code>, the probabilities of each remaining arm being the
overall best in the last conducted adaptive analysis (<code>NA</code> for
previously dropped arms).<br />
<strong>Note:</strong> for the variables in the <code>data.frame</code> where a version
including the <code style="white-space: pre;">&#8288;_all&#8288;</code>-suffix is included, the versions WITHOUT this
suffix are calculated using patients with available outcome data at the
time of analysis, while the versions WITH the <code style="white-space: pre;">&#8288;_all&#8288;</code>-suffixes are
calculated using outcome data for all patients randomised at the time
of analysis, even if they have not reached the time of follow-up yet
(see <code><a href="#topic+setup_trial">setup_trial()</a></code>).
</p>
</li>
<li> <p><code>all_looks</code>: a list of lists containing one list per conducted
trial look (adaptive analysis). These lists contain the variables
<code>arms</code>, <code>old_status</code> (status before the analysis of the current round
was conducted), <code>new_status</code> (as specified above, status after current
analysis has been conducted), <code>sum_ys</code>/<code>sum_ys_all</code> (as described
above), <code>ns</code>/<code>ns_all</code> (as described above), <code>old_alloc</code> (the allocation
probability used during this look), <code>probs_best</code> (the probabilities of
each arm being the best in the current adaptive analysis), <code>new_alloc</code>
(the allocation probabilities after updating these in the current
adaptive analysis; NA for all arms when the trial is stopped and no
further adaptive analyses will be conducted), <code>probs_better_first</code> (if
a common control is provided, specifying the probabilities that each
arm was better than the control in the first analysis conducted during
that look), <code>probs_better</code> (as <code>probs_better_first</code>, but updated if
another arm becomes the new control), <code>probs_equivalence_first</code> and
<code>probs_equivalence</code> (as for <code>probs_better</code>/<code>probs_better_first</code>, but
for equivalence if equivalence is assessed). The last variables are
<code>NA</code> if the arm was not active in the applicable adaptive analysis or
if they would not be included during the next adaptive analysis.
</p>
</li>
<li> <p><code>allocs</code>: a character vector containing the allocations of all
patients in the order of randomization.
</p>
</li>
<li> <p><code>ys</code>: a numeric vector containing the outcomes of all patients in
the order of randomization (<code>0</code> or <code>1</code> for binary outcomes).
</p>
</li>
<li> <p><code>seed</code>: the random seed used, if specified.
</p>
</li>
<li> <p><code>description</code>, <code>add_info</code>, <code>cri_width</code>, <code>n_draws</code>, <code>robust</code>: as
specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
</p>
</li>
<li> <p><code>sparse</code>: single logical, corresponding to the <code>sparse</code> input.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 100)

# Run trial with a specified random seed
res &lt;- run_trial(binom_trial, seed = 12345)

# Print results with 3 decimals
print(res, digits = 3)

</code></pre>

<hr>
<h2 id='run_trials'>Simulate multiple trials</h2><span id='topic+run_trials'></span>

<h3>Description</h3>

<p>This function conducts multiple simulations using a trial specification as
specified by <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
This function essentially manages random seeds and runs multiple simulation
using <code><a href="#topic+run_trial">run_trial()</a></code> - additional details on individual simulations are
provided in that function's description. This function allows simulating
trials in parallel using multiple cores, automatically saving and re-loading
saved objects, and &quot;growing&quot; already saved simulation files (i.e., appending
additional simulations to the same file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_trials(
  trial_spec,
  n_rep,
  path = NULL,
  overwrite = FALSE,
  grow = FALSE,
  cores = NULL,
  base_seed = NULL,
  sparse = TRUE,
  progress = NULL,
  version = NULL,
  compress = TRUE,
  export = NULL,
  export_envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_trials_+3A_trial_spec">trial_spec</code></td>
<td>
<p><code>trial_spec</code> object, generated and validated by the
<code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> function.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_n_rep">n_rep</code></td>
<td>
<p>single integer; the number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_path">path</code></td>
<td>
<p>single character string; if specified (defaults to <code>NULL</code>), files
will be written to and  loaded from this path using the <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> /
<code><a href="base.html#topic+readRDS">readRDS()</a></code> functions.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_overwrite">overwrite</code></td>
<td>
<p>single logical; defaults to <code>FALSE</code>, in which case previous
simulations saved in the same <code>path</code> will be re-loaded (if the same trial
specification was used). If <code>TRUE</code>, the previous file is overwritten (even
if the the same trial specification was not used). If <code>grow</code> is <code>TRUE</code>,
this argument must be set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_grow">grow</code></td>
<td>
<p>single logical; defaults to <code>FALSE</code>. If <code>TRUE</code> and a valid <code>path</code>
to a valid previous file containing less simulations than <code>n_rep</code>, the
additional number of simulations will be run (appropriately re-using the
same <code>base_seed</code>, if specified) and appended to the same file.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value/cluster set
by <code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether simulations are run in
parallel on a default cluster or sequentially in the main process; if a
cluster/value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>, <code>cores</code> will
then be set to the value stored in the global <code>"mc.cores"</code> option (if
previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and <code>1</code> if that
option has not been specified.<br />
If the resulting number of <code>cores = 1</code>, computations will be run
sequentially in the primary process, and if <code>cores &gt; 1</code>, a new parallel
cluster will be setup using the <code>parallel</code> library and removed once the
function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_base_seed">base_seed</code></td>
<td>
<p>single integer or <code>NULL</code> (default); a random seed used as
the basis for simulations. Regardless of whether simulations are run
sequentially or in parallel, random number streams will be identical and
appropriate (see <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details).</p>
</td></tr>
<tr><td><code id="run_trials_+3A_sparse">sparse</code></td>
<td>
<p>single logical, as described in <code><a href="#topic+run_trial">run_trial()</a></code>; defaults to
<code>TRUE</code> when running multiple simulations, in which case only the data
necessary to summarise all simulations are saved for each simulation.
If <code>FALSE</code>, more detailed data for each simulation is saved, allowing more
detailed printing of individual trial results and plotting using
<code><a href="#topic+plot_history">plot_history()</a></code> (<code><a href="#topic+plot_status">plot_status()</a></code> does not require non-sparse results).</p>
</td></tr>
<tr><td><code id="run_trials_+3A_progress">progress</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code> or <code>NULL</code>. If <code>NULL</code>
(default), no progress is printed to the console. Otherwise, progress
messages are printed to the control at intervals proportional to the value
specified by progress.<br />
<strong>Note:</strong> as printing is not possible from within clusters on multiple
cores, the function conducts batches of simulations on multiple cores (if
specified), with intermittent printing of statuses. Thus, all cores have to
finish running their current assigned batches before the other cores may
proceed with the next batch. If there are substantial differences in the
simulation speeds across cores, using <code>progress</code> may thus increase total
run time (especially with small values).</p>
</td></tr>
<tr><td><code id="run_trials_+3A_version">version</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving simulations, defaults to
<code>NULL</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), which means that the current default version is
used. Ignored if simulations are not saved.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_compress">compress</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving simulations, defaults to
<code>TRUE</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), see <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> for other options. Ignored if
simulations are not saved.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_export">export</code></td>
<td>
<p>character vector of names of objects to export to each
parallel core when running in parallel; passed as the <code>varlist</code> argument to
<code><a href="parallel.html#topic+clusterApply">parallel::clusterExport()</a></code>. Defaults to <code>NULL</code> (no objects exported),
ignored if <code>cores == 1</code>. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="run_trials_+3A_export_envir">export_envir</code></td>
<td>
<p><code>environment</code> where to look for the objects defined
in <code>export</code> when running in parallel and <code>export</code> is not <code>NULL</code>. Defaults
to the environment from where the function is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Exporting objects when using multiple cores</strong>
</p>
<p>If <code><a href="#topic+setup_trial">setup_trial()</a></code> is used to define a trial specification with custom
functions (in the <code>fun_y_gen</code>, <code>fun_draws</code>, and <code>fun_raw_est</code> arguments of
<code><a href="#topic+setup_trial">setup_trial()</a></code>) and <code><a href="#topic+run_trials">run_trials()</a></code> is run with <code>cores &gt; 1</code>, it is necessary
to export additional functions or objects used by these functions and defined
by the user outside the function definitions provided. Similarly, functions
from external packages loaded using <code><a href="base.html#topic+library">library()</a></code> or <code><a href="base.html#topic+require">require()</a></code> must be
exported or called prefixed with the namespace, i.e., <code style="white-space: pre;">&#8288;package::function&#8288;</code>.
The <code>export</code> and <code>export_envir</code> arguments are used to export objects calling
the <code><a href="parallel.html#topic+clusterApply">parallel::clusterExport()</a></code>-function. See also <code><a href="#topic+setup_cluster">setup_cluster()</a></code>, which
may be used to setup a cluster and export required objects only once per
session.
</p>


<h3>Value</h3>

<p>A list of a special class <code>"trial_results"</code>, which contains the
<code>trial_results</code> (results from all simulations; note that <code>seed</code> will be
<code>NULL</code> in the individual simulations), <code>trial_spec</code> (the trial
specification), <code>n_rep</code>, <code>base_seed</code>, <code>elapsed_time</code> (the total simulation
run time), <code>sparse</code> (as described above) and <code>adaptr_version</code> (the version
of the <code>adaptr</code> package used to run the simulations). These results may be
extracted, summarised, and plotted using the <code><a href="#topic+extract_results">extract_results()</a></code>,
<code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+print.trial_results">print.trial_results()</a></code>,
<code><a href="#topic+plot_convergence">plot_convergence()</a></code>, <code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>, <code><a href="#topic+plot_status">plot_status()</a></code>, and
<code><a href="#topic+plot_history">plot_history()</a></code> functions. See the definitions of these functions for
additional details and details on additional arguments used to select arms
in simulations not ending in superiority and other summary choices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 100)

# Run 10 simulations with a specified random base seed
res &lt;- run_trials(binom_trial, n_rep = 10, base_seed = 12345)

# See ?extract_results, ?check_performance, ?summary and ?print for details
# on extracting resutls, summarising and printing

</code></pre>

<hr>
<h2 id='setup_cluster'>Setup default cluster for use in parallelised adaptr functions</h2><span id='topic+setup_cluster'></span>

<h3>Description</h3>

<p>This function setups (or removes) a default cluster for use in all
parallelised functions in <code>adaptr</code> using the <code>parallel</code> package. The function
also exports objects that should be available on the cluster and sets the
random number generator appropriately. See <strong>Details</strong> for further info on
how <code>adaptr</code> handles sequential/parallel computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_cluster(cores, export = NULL, export_envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_cluster_+3A_cores">cores</code></td>
<td>
<p>can be either unspecified, <code>NULL</code>, or a single integer <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>. If
<code>NULL</code> or <code>1</code>, an existing default cluster is removed (if any), and the
default will subsequently be to run functions sequentially in the main
process if <code>cores = 1</code>, and according to <code>getOption("mc.cores")</code> if <code>NULL</code>
(unless otherwise specified in individual functions calls). The
<code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code> function may be used to see the number of
available cores, although this comes with some caveats (as described in the
function documentation), including that the number of cores may not always
be returned and may not match the number of cores that are available for
use. In general, using less cores than available may be preferable if other
processes are run on the machine at the same time.</p>
</td></tr>
<tr><td><code id="setup_cluster_+3A_export">export</code></td>
<td>
<p>character vector of names of objects to export to each
parallel core when running in parallel; passed as the <code>varlist</code> argument to
<code><a href="parallel.html#topic+clusterApply">parallel::clusterExport()</a></code>. Defaults to <code>NULL</code> (no objects exported),
ignored if <code>cores == 1</code>. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="setup_cluster_+3A_export_envir">export_envir</code></td>
<td>
<p><code>environment</code> where to look for the objects defined
in <code>export</code> when running in parallel and <code>export</code> is not <code>NULL</code>. Defaults
to the environment from where the function is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Using sequential or parallel computing in adaptr</strong>
</p>
<p>All parallelised <code>adaptr</code> functions have a <code>cores</code> argument that defaults to
<code>NULL</code>. If a non-<code>NULL</code> integer <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> is provided to the <code>cores</code> argument in
any of those (except <code><a href="#topic+setup_cluster">setup_cluster()</a></code>), the package will run calculations
sequentially in the main process if <code>cores = 1</code>, and otherwise initiate a new
cluster of size <code>cores</code> that will be removed once the function completes,
regardless of whether or not a default cluster or the global <code>"mc.cores"</code>
option have been specified.
</p>
<p>If <code>cores</code> is <code>NULL</code> in any <code>adaptr</code> function (except <code><a href="#topic+setup_cluster">setup_cluster()</a></code>), the
package will use a default cluster if one exists or run computations
sequentially if <code><a href="#topic+setup_cluster">setup_cluster()</a></code> has last been called with <code>cores = 1</code>.
If <code><a href="#topic+setup_cluster">setup_cluster()</a></code> has not been called or last called with <code>cores = NULL</code>,
then the package will check if the global <code>"mc.cores"</code> option has been
specified (using <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;)&#8288;</code>). If this option has
been set with a value <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>, then a new, temporary cluster of that size is
setup, used, and removed once the function completes. If this option has not
been set or has been set to <code>1</code>, then computations will be run sequentially
in the main process.
</p>
<p>Generally, we recommend using the <code><a href="#topic+setup_cluster">setup_cluster()</a></code> function as this avoids
the overhead of re-initiating new clusters with every call to one of the
parallelised <code>adaptr</code> functions. This is especially important when exporting
many or large objects to a <code>parallel</code> cluster, as this can then be done only
once (with the option to export further objects to the same cluster when
calling <code><a href="#topic+run_trials">run_trials()</a></code>).
</p>
<p><strong>Type of clusters used and random number generation</strong>
</p>
<p>The <code>adaptr</code> package solely uses parallel socket clusters (using
<code><a href="parallel.html#topic+makeCluster">parallel::makePSOCKcluster()</a></code>) and thus does not use forking (as this is not
available on all operating systems and may cause crashes in some situations).
As such, user-defined objects that should be used by the <code>adaptr</code> functions
when run in parallel need to be exported using either <code><a href="#topic+setup_cluster">setup_cluster()</a></code> or
<code><a href="#topic+run_trials">run_trials()</a></code>, if not included in the generated <code>trial_spec</code> object.
</p>
<p>The <code>adaptr</code> package uses the <code>"L'Ecuyer-CMRG"</code> kind (see <code><a href="base.html#topic+RNGkind">RNGkind()</a></code>) for
safe random number generation for all parallelised functions. This is also
the case when running <code>adaptr</code> functions sequentially with a seed provided,
to ensure that the same results are obtained regardless of whether sequential
or parallel computation is used. All functions restore both the random number
generator kind and the global random seed after use if called with a seed.
</p>


<h3>Value</h3>

<p>Invisibly returns the default <code>parallel</code> cluster or <code>NULL</code>, as
appropriate. This may be used with other functions from the <code>parallel</code>
package by advanced users, for example to load certain libraries on the
cluster prior to calling <code><a href="#topic+run_trials">run_trials()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setup a cluster using 2 cores
setup_cluster(cores = 2)

# Get existing default cluster (printed here as invisibly returned)
print(setup_cluster())

# Remove existing default cluster
setup_cluster(cores = NULL)

# Specify preference for running computations sequentially
setup_cluster(cores = 1)

# Remove default cluster preference
setup_cluster(cores = NULL)

# Set global option to default to using 2 new clusters each time
# (only used if no default cluster preference is specified)
options(mc.cores = 2)

</code></pre>

<hr>
<h2 id='setup_trial'>Setup a generic trial specification</h2><span id='topic+setup_trial'></span>

<h3>Description</h3>

<p>Specifies the design of an adaptive trial with any type of outcome and
validates all inputs. Use <code><a href="#topic+calibrate_trial">calibrate_trial()</a></code> to calibrate the trial
specification to obtain a specific value for a certain performance metric
(e.g., the Bayesian type 1 error rate). Use <code><a href="#topic+run_trial">run_trial()</a></code> or <code><a href="#topic+run_trials">run_trials()</a></code>
to conduct single/multiple simulations of the specified trial, respectively.
<br /> See <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> for simplified setup
of trial designs for common outcome types. For additional trial specification
examples, see the the <strong>Basic examples</strong> vignette
(<code>vignette("Basic-examples", package = "adaptr")</code>) and the
<strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_trial(
  arms,
  true_ys,
  fun_y_gen = NULL,
  fun_draws = NULL,
  start_probs = NULL,
  fixed_probs = NULL,
  min_probs = rep(NA, length(arms)),
  max_probs = rep(NA, length(arms)),
  data_looks = NULL,
  max_n = NULL,
  look_after_every = NULL,
  randomised_at_looks = NULL,
  control = NULL,
  control_prob_fixed = NULL,
  inferiority = 0.01,
  superiority = 0.99,
  equivalence_prob = NULL,
  equivalence_diff = NULL,
  equivalence_only_first = NULL,
  futility_prob = NULL,
  futility_diff = NULL,
  futility_only_first = NULL,
  highest_is_best = FALSE,
  soften_power = 1,
  fun_raw_est = mean,
  cri_width = 0.95,
  n_draws = 5000,
  robust = TRUE,
  description = NULL,
  add_info = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_trial_+3A_arms">arms</code></td>
<td>
<p>character vector with unique names for the trial arms.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_true_ys">true_ys</code></td>
<td>
<p>numeric vector specifying true outcomes (e.g., event
probabilities, mean values, etc.) for all trial <code>arms</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_fun_y_gen">fun_y_gen</code></td>
<td>
<p>function, generates outcomes. See <code><a href="#topic+setup_trial">setup_trial()</a></code>
<strong>Details</strong> for information on how to specify this function.<br />
<strong>Note:</strong> this function is called once during setup to validate its output
(with the global random seed restored afterwards).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_fun_draws">fun_draws</code></td>
<td>
<p>function, generates posterior draws. See <code><a href="#topic+setup_trial">setup_trial()</a></code>
<strong>Details</strong> for information on how to specify this function.<br />
<strong>Note:</strong> this function is called up to three times during setup to
validate its output (with the global random seed restored afterwards).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_start_probs">start_probs</code></td>
<td>
<p>numeric vector, allocation probabilities for each arm at
the beginning of the trial. The default (<code>NULL</code>) automatically generates
equal randomisation probabilities for each arm.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_fixed_probs">fixed_probs</code></td>
<td>
<p>numeric vector, fixed allocation probabilities for each
arm. Must be either a numeric vector with <code>NA</code> for arms without fixed
probabilities and values between <code>0</code> and <code>1</code> for the other arms or <code>NULL</code>
(default), if adaptive randomisation is used for all arms or if one of the
special settings (<code>"sqrt-based"</code>, <code>"sqrt-based start"</code>,
<code>"sqrt-based fixed"</code>, or <code>"match"</code>) is specified for <code>control_prob_fixed</code>
(described below).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_min_probs">min_probs</code></td>
<td>
<p>numeric vector, lower threshold for adaptive allocation
probabilities; lower probabilities will be rounded up to these values. Must
be <code>NA</code> (default for all arms) if no lower threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_max_probs">max_probs</code></td>
<td>
<p>numeric vector, upper threshold for adaptive allocation
probabilities; higher probabilities will be rounded down to these values.
Must be <code>NA</code> (default for all arms) if no threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_data_looks">data_looks</code></td>
<td>
<p>vector of increasing integers, specifies when to conduct
adaptive analyses (= the total number of patients with available outcome
data at each adaptive analysis). The last number in the vector represents
the final adaptive analysis, i.e., the final analysis where superiority,
inferiority, practical equivalence, or futility can be claimed.
Instead of specifying <code>data_looks</code>, the <code>max_n</code> and <code>look_after_every</code>
arguments can be used in combination (in which case <code>data_looks</code> must be
<code>NULL</code>, the default value).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_max_n">max_n</code></td>
<td>
<p>single integer, number of patients with available outcome data
at the last possible adaptive analysis (defaults to <code>NULL</code>).
Must only be specified if <code>data_looks</code> is <code>NULL</code>. Requires specification of
the <code>look_after_every</code> argument.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_look_after_every">look_after_every</code></td>
<td>
<p>single integer, specified together with <code>max_n</code>.
Adaptive analyses will be conducted after every <code>look_after_every</code>
patients have available outcome data, and at the total sample size as
specified by <code>max_n</code> (<code>max_n</code> does not need to be a multiple of
<code>look_after_every</code>). If specified, <code>data_looks</code> must be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_randomised_at_looks">randomised_at_looks</code></td>
<td>
<p>vector of increasing integers or <code>NULL</code>,
specifying the number of patients randomised at the time of each adaptive
analysis, with new patients randomised using the current allocation
probabilities at said analysis.
If <code>NULL</code> (the default), the number of patients randomised at each analysis
will match the number of patients with available outcome data at said
analysis, as specified by <code>data_looks</code> or <code>max_n</code> and <code>look_after_every</code>,
i.e., outcome data will be available immediately after randomisation for
all patients.<br />
If not <code>NULL</code>, the vector must be of the same length as the number of
adaptive analyses specified by <code>data_looks</code> or <code>max_n</code> and
<code>look_after_every</code>, and all values must be larger than or equal to the
number of patients with available outcome data at each analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_control">control</code></td>
<td>
<p>single character string, name of one of the <code>arms</code> or <code>NULL</code>
(default). If specified, this arm will serve as a common control arm, to
which all other arms will be compared and the
inferiority/superiority/equivalence thresholds (see below) will be for
those comparisons. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for information on
behaviour with respect to these comparisons.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_control_prob_fixed">control_prob_fixed</code></td>
<td>
<p>if a common <code>control</code> arm is specified, this can
be set <code>NULL</code> (the default), in which case the control arm allocation
probability will not be fixed if control arms change (the allocation
probability for the first control arm may still be fixed using
<code>fixed_probs</code>). If not <code>NULL</code>, a vector of probabilities of either length
<code>1</code> or <code style="white-space: pre;">&#8288;number of arms - 1&#8288;</code> can be provided, or one of the special
arguments <code>"sqrt-based"</code>, <code>"sqrt-based start"</code>, <code>"sqrt-based fixed"</code> or
<code>"match"</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for details on how this affects
trial behaviour.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_inferiority">inferiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for inferiority (default is <code>0.01</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be lower than the preceding value. If a common <code>control</code>is not
used, all values must be <code style="white-space: pre;">&#8288;&lt; 1 / number of arms&#8288;</code>. An arm will be considered
inferior and dropped if the probability that it is best (when comparing all
arms) or better than the control arm (when a common <code>control</code> is used)
drops below the inferiority threshold at an adaptive analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_superiority">superiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for superiority (default is <code>0.99</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be higher than the preceding value. If the probability that an
arm is best (when comparing all arms) or better than the control arm (when
a common <code>control</code> is used) exceeds the superiority threshold at an
adaptive analysis, said arm will be declared the winner and the trial will
be stopped (if no common <code>control</code> is used or if the last comparator is
dropped in a design with a common control) <em>or</em> become the new control and
the trial will continue (if a common control is specified).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_equivalence_prob">equivalence_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no equivalence assessment), specifying the
probability threshold(s) for equivalence. If not <code>NULL</code>, all values must be
<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no value may be
higher than the preceding value. If not <code>NULL</code>, arms will be dropped for
equivalence if the probability of either <em>(a)</em> equivalence compared to a
common <code>control</code> or <em>(b)</em> equivalence between all arms remaining (designs
without a common <code>control</code>) exceeds the equivalence threshold at an
adaptive analysis. Requires specification of <code>equivalence_diff</code> and
<code>equivalence_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_equivalence_only_first">equivalence_only_first</code></td>
<td>
<p>single logical in trial specifications where
<code>equivalence_prob</code> and <code>equivalence_diff</code> are specified and a common
<code>control</code> arm is included, otherwise <code>NULL</code> (default). If a common
<code>control</code> arm is used, this specifies whether equivalence will only be
assessed for the first control (if <code>TRUE</code>) or also for subsequent <code>control</code>
arms (if <code>FALSE</code>) if one arm is superior to the first control and becomes
the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_futility_prob">futility_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no futility assessment), specifying the
probability threshold(s) for futility. All values must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>,
and if multiple values are supplied, no value may be higher than the
preceding value. If not <code>NULL</code>, arms will be dropped for futility if
the probability for futility compared to the common <code>control</code> exceeds the
futility threshold at an adaptive analysis. Requires a common <code>control</code>
arm (otherwise this argument must be <code>NULL</code>), specification of
<code>futility_diff</code>, and <code>futility_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_futility_diff">futility_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no futility assessment). If a numeric value is specified,
estimated differences below this threshold in the <em>beneficial</em> direction
(as specified in <code>highest_is_best</code>) will be considered futile when
assessing futility in designs with a common <code>control</code> arm. If only 1 arm
remains after dropping arms for futility, the trial will be stopped without
declaring the last arm superior.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_futility_only_first">futility_only_first</code></td>
<td>
<p>single logical in trial specifications designs
where <code>futility_prob</code> and <code>futility_diff</code> are specified, otherwise <code>NULL</code>
(default and required in designs without a common <code>control</code> arm).
Specifies whether futility will only be assessed against the first
<code>control</code> (if <code>TRUE</code>) or also for subsequent control arms (if <code>FALSE</code>) if
one arm is superior to the first control and becomes the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_soften_power">soften_power</code></td>
<td>
<p>either a single numeric value or a numeric vector of
exactly the same length as the maximum number of looks/adaptive analyses.
Values must be between <code>0</code> and <code>1</code> (default); if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, then re-allocated
non-fixed allocation probabilities are all raised to this power (followed
by rescaling to sum to <code>1</code>) to make adaptive allocation probabilities
less extreme, in turn used to redistribute remaining probability while
respecting limits when defined by <code>min_probs</code> and/or <code>max_probs</code>. If <code>1</code>,
then no <em>softening</em> is applied.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_fun_raw_est">fun_raw_est</code></td>
<td>
<p>function that takes a numeric vector and returns a
single numeric value, used to calculate a raw summary estimate of the
outcomes in each <code>arm</code>. Defaults to <code><a href="base.html#topic+mean">mean()</a></code>, which is always used in the
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> functions.<br />
<strong>Note:</strong> the function is called one time per arm during setup to validate
the output structure.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_cri_width">cri_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the
percentile-based credible intervals used when summarising individual trial
results. Defaults to <code>0.95</code>, corresponding to 95% credible intervals.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, the number of draws from the posterior
distributions for each arm used when running the trial. Defaults to
<code>5000</code>; can be reduced for a speed gain (at the potential loss of stability
of results if too low) or increased for increased precision (increasing
simulation time). Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not allowed and values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> are
not recommended and warned against.</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_robust">robust</code></td>
<td>
<p>single logical, if <code>TRUE</code> (default) the medians and median
absolute deviations (scaled to be comparable to the standard deviation for
normal distributions; MAD_SDs, see <code><a href="stats.html#topic+mad">stats::mad()</a></code>) are used to summarise
the posterior distributions; if <code>FALSE</code>, the means and standard deviations
(SDs) are used instead (slightly faster, but may be less appropriate for
posteriors skewed on the natural scale).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_description">description</code></td>
<td>
<p>optional single character string describing the trial
design, will only be used in print functions if not <code>NULL</code> (the default).</p>
</td></tr>
<tr><td><code id="setup_trial_+3A_add_info">add_info</code></td>
<td>
<p>optional single string containing additional information
regarding the trial design or specifications, will only be used in print
functions if not <code>NULL</code> (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>How to specify the <code>fun_y_gen</code> function</strong>
</p>
<p>The function must take the following arguments:
</p>

<ul>
<li> <p><code>allocs</code>: character vector, the trial <code>arms</code> that new patients allocated
since the last adaptive analysis are randomised to.
</p>
</li></ul>

<p>The function must return a single numeric vector, corresponding to the
outcomes for all patients allocated since the last adaptive analysis, in the
same order as <code>allocs</code>.<br />
See the <strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>) for an example with
further details.
</p>
<p><strong>How to specify the <code>fun_draws</code> function</strong>
</p>
<p>The function must take the following arguments:
</p>

<ul>
<li> <p><code>arms</code>: character vector, the unique trial <code>arms</code>, in the same order as
above, but only the <strong>currently active</strong> arms are included when the function
is called.
</p>
</li>
<li> <p><code>allocs</code>: a vector of allocations for all patients, corresponding to the
trial <code>arms</code>, including patients allocated to both
<strong>currently active AND inactive</strong> <code>arms</code> when called.
</p>
</li>
<li> <p><code>ys</code>: a vector of outcomes for all patients in the same order as <code>allocs</code>,
including outcomes for patients allocated to both
<strong>currently active AND inactive</strong> <code>arms</code> when called.
</p>
</li>
<li> <p><code>control</code>: single character, the current <code>control</code> arm, will be <code>NULL</code> for
designs without a common control arm, but required regardless as the argument
is supplied by <code><a href="#topic+run_trial">run_trial()</a></code>/<code><a href="#topic+run_trials">run_trials()</a></code>.
</p>
</li>
<li> <p><code>n_draws</code>: single integer, the number of posterior draws for each arm.
</p>
</li></ul>

<p>The function must return a <code>matrix</code> (containing numeric values) with <code>arms</code>
named columns and <code>n_draws</code> rows. The <code>matrix</code> must have columns
<strong>only for currently active arms</strong> (when called). Each row should contain a
single posterior draw for each arm on the original outcome
scale: if they are estimated as, e.g., the <em>log(odds)</em>, these estimates must
be transformed to probabilities and similarly for other measures.<br />
Important: the <code>matrix</code> cannot contain <code>NA</code>s, even if no patients have been
randomised to an arm yet. See the provided example for one way to alleviate
this.<br />
See the <strong>Advanced examples</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>) for an example with
further details.
</p>
<p><em>Notes</em>
</p>

<ul>
<li><p> Different estimation methods and prior distributions may be used;
complex functions will lead to slower simulations compared to simpler
methods for obtaining posterior draws, including those specified using the
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> functions.
</p>
</li>
<li><p> Technically, using log relative effect measures — e.g. log(odds ratios) or
log(risk ratios) - or differences compared to a reference arm (e.g., mean
differences or absolute risk differences) instead of absolute values in each
arm will work to some extent (<strong>be cautious!</strong>):
</p>
</li>
<li><p> Stopping for superiority/inferiority/max sample sizes will work.
</p>
</li>
<li><p> Stopping for equivalence/futility may be used with relative effect
measures on the log scale, but thresholds have to be adjusted accordingly.
</p>
</li>
<li><p> Several summary statistics from <code><a href="#topic+run_trial">run_trial()</a></code> (<code>sum_ys</code> and posterior
estimates) may be nonsensical if relative effect measures are used
(depending on calculation method; see the <code>raw_ests</code> argument in the
relevant functions).
</p>
</li>
<li><p> In the same vein, <code><a href="#topic+extract_results">extract_results()</a></code> (<code>sum_ys</code>, <code>sq_err</code>, and
<code>sq_err_te</code>), and <code><a href="#topic+summary">summary()</a></code> (<code>sum_ys_mean/sd/median/q25/q75/q0/q100</code>,
<code>rmse</code>, and <code>rmse_te</code>) may be equally nonsensical when calculated on
the relative scale (see the <code>raw_ests</code> argument in the relevant functions.
</p>
</li></ul>

<p><strong>Using additional custom or functions from loaded packages in the
custom functions</strong>
</p>
<p>If the <code>fun_y_gen</code>, <code>fun_draws</code>, or <code>fun_raw_est</code> functions calls other
user-specified functions (or uses objects defined by the user outside these
functions or the <code><a href="#topic+setup_trial">setup_trial()</a></code>-call) or functions from external packages
and simulations are conducted on multiple cores, these objects or functions
must be exported or prefixed with their namespaces, respectively, as
described in <code><a href="#topic+setup_cluster">setup_cluster()</a></code> and <code><a href="#topic+run_trials">run_trials()</a></code>.
</p>
<p><strong>More information on arguments</strong>
</p>

<ul>
<li> <p><code>control</code>: if one or more treatment arms are superior to the control arm
(i.e., passes the superiority threshold as defined above), this arm will
become the new control (if multiple arms are superior, the one with the
highest probability of being the overall best will become the new control),
the previous control will be dropped for inferiority, and all remaining arms
will be immediately compared to the new control in the same adaptive analysis
and dropped if inferior (or possibly equivalent/futile, see below) compared
to this new control arm. Only applies in trials with a common <code>control</code>.
</p>
</li>
<li> <p><code>control_prob_fixed</code>: If the length is 1, then this allocation probability
will be used for the <code>control</code> group (including if a new arm becomes the
control and the original control is dropped). If multiple values are specified
the first value will be used when all arms are active, the second when one
arm has been dropped, and so forth. If 1 or more values are specified,
previously set <code>fixed_probs</code>, <code>min_probs</code> or <code>max_probs</code> for new control arms
will be ignored. If all allocation probabilities do not sum to 1 (e.g, due to
multiple limits) they will be rescaled to do so.<br />
Can also be set to one of the special arguments <code>"sqrt-based"</code>,
<code>"sqrt-based start"</code>, <code>"sqrt-based fixed"</code> or <code>"match"</code> (written exactly as
one of those, case sensitive). This requires <code>start_probs</code> to be <code>NULL</code> and
relevant <code>fixed_probs</code> to be <code>NULL</code> (or <code>NA</code> for the control arm).<br />
If one of the <code>"sqrt-based"/"sqrt-based start"/"sqrt-based fixed"</code> options
are used, the function will set <em>square-root-transformation-based</em> starting
allocation probabilities. These are defined as:<br />
<code style="white-space: pre;">&#8288;square root of number of non-control arms to 1-ratio for other arms&#8288;</code><br />
scaled to sum to 1, which will generally increase power for comparisons
against the common <code>control</code>, as discussed in, e.g., <em>Park et al, 2020</em>
<a href="https://doi.org/10.1016/j.jclinepi.2020.04.025">doi:10.1016/j.jclinepi.2020.04.025</a>.<br />
If <code>"sqrt-based"</code>, square-root-transformation-based allocation probabilities
will also be used for new controls when arms are dropped. If
<code>"sqrt-based start"</code>, the control arm will be fixed to this allocation
probability at all times (also after arm dropping, with rescaling as
necessary, as specified above). If <code>"sqrt-based fixed"</code> is chosen,
square-root-transformation-based allocation probabilities will be used and
all allocation probabilities will be fixed throughout the trial (with
rescaling when arms are dropped).<br />
If <code>"match"</code> is specified, the control group allocation probability will
always be <em>matched</em> to be similar to the highest non-control arm allocation
probability.
</p>
</li></ul>

<p><strong>Superiority and inferiority</strong>
</p>
<p>In trial designs without a common control arm, superiority and inferiority
are assessed by comparing all <em><strong>currently active</strong></em> groups. This means that
if a &quot;final&quot; analysis of a trial without a common control and <code style="white-space: pre;">&#8288;&gt; 2 arms&#8288;</code> is
conducted including all arms (as will often be done in practice) <em>after</em> an
adaptive trial has stopped, the final probabilities of the best arm being
superior may differ slightly.<br />
For example, in a trial with three arms and no common <code>control</code> arm, one arm
may be dropped early for inferiority defined as <code style="white-space: pre;">&#8288;&lt; 1%&#8288;</code> probability of being
the overall best <code>arm</code>. The trial may then continue with the two remaining
arms, and stopped when one is declared superior to the other defined as
<code style="white-space: pre;">&#8288;&gt; 99%&#8288;</code> probability of being the overall best <code>arm</code>. If a final analysis is
then conducted including all arms, the final probability of the best arm
being overall superior will generally be slightly lower as the probability
of the first dropped arm being the best will often be <code style="white-space: pre;">&#8288;&gt; 0%&#8288;</code>, even if very
low and below the inferiority threshold.<br />
This is less relevant trial designs <em>with</em> a common <code>control</code>, as pairwise
assessments of superiority/inferiority compared to the common <code>control</code> will
not be influenced similarly by previously dropped arms (and previously
dropped arms may be included in the analyses, even if posterior distributions
are not returned for those).
Similarly, in actual clinical trials and when <code>randomised_at_looks</code> is
specified with numbers higher than the number of patients with available
outcome data at each analysis, final probabilities may change somewhat when
the all patients are have completed follow-up and are included in a final
analysis.
</p>
<p><strong>Equivalence</strong>
</p>
<p>Equivalence is assessed <em><strong>after</strong></em> both inferiority and superiority have
been assessed (and in case of superiority, it will be assessed against the
new <code>control</code> arm in designs with a common <code>control</code>, if specified - see
above).
</p>
<p><strong>Futility</strong>
</p>
<p>Futility is assessed <em><strong>after</strong></em> inferiority, superiority, <em><strong>and</strong></em>
equivalence have been assessed (and in case of superiority, it will be
assessed against the new control arm in designs with a common control, if
specified - see above). Arms will thus be dropped for equivalence before
futility.
</p>
<p><strong>Varying probability thresholds</strong>
</p>
<p>Different probability thresholds (for superiority, inferiority, equivalence,
and futility) may be specified for different adaptive analyses. This may be
used, e.g., to apply more strict probability thresholds at earlier analyses
(or make one or more stopping rules not apply at earlier analyses), similar
to the use of monitoring boundaries with different thresholds used for
interim analyses in conventional, frequentist group sequential trial designs.
See the <strong>Basic examples</strong> vignette
(<code>vignette("Basic-examples", package = "adaptr")</code>) for an example.
</p>


<h3>Value</h3>

<p>A <code>trial_spec</code> object used to run simulations by <code><a href="#topic+run_trial">run_trial()</a></code> or
<code><a href="#topic+run_trials">run_trials()</a></code>. The output is essentially a list containing the input
values (some combined in a <code>data.frame</code> called <code>trial_arms</code>), but its class
signals that these inputs have been validated and inappropriate
combinations and settings have been ruled out. Also contains <code>best_arm</code>,
holding the arm(s) with the best value(s) in <code>true_ys</code>. Use <code>str()</code> to
peruse the actual content of the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a custom trial specification with right-skewed, log-normally
# distributed continuous outcomes (higher values are worse)

# Define the function that will generate the outcomes in each arm
# Notice: contents should match arms/true_ys in the setup_trial() call below
get_ys_lognorm &lt;- function(allocs) {
  y &lt;- numeric(length(allocs))
  # arms (names and order) and values (except for exponentiation) should match
  # those used in setup_trial (below)
  means &lt;- c("Control" = 2.2, "Experimental A" = 2.1, "Experimental B" = 2.3)
  for (arm in names(means)) {
    ii &lt;- which(allocs == arm)
    y[ii] &lt;- rlnorm(length(ii), means[arm], 1.5)
  }
  y
}

# Define the function that will generate posterior draws
# In this example, the function uses no priors (corresponding to improper
# flat priors) and calculates results on the log-scale, before exponentiating
# back to the natural scale, which is required for assessments of
# equivalence, futility and general interpretation
get_draws_lognorm &lt;- function(arms, allocs, ys, control, n_draws) {
  draws &lt;- list()
  logys &lt;- log(ys)
  for (arm in arms){
    ii &lt;- which(allocs == arm)
    n &lt;- length(ii)
    if (n &gt; 1) {
      # Necessary to avoid errors if too few patients randomised to this arm
      draws[[arm]] &lt;- exp(rnorm(n_draws, mean = mean(logys[ii]), sd = sd(logys[ii])/sqrt(n - 1)))
    } else {
      # Too few patients randomised to this arm - extreme uncertainty
      draws[[arm]] &lt;- exp(rnorm(n_draws, mean = mean(logys), sd = 1000 * (max(logys) - min(logys))))
    }
  }
  do.call(cbind, draws)
}

# The actual trial specification is then defined
lognorm_trial &lt;- setup_trial(
  # arms should match those above
  arms = c("Control", "Experimental A", "Experimental B"),
  # true_ys should match those above
  true_ys = exp(c(2.2, 2.1, 2.3)),
  fun_y_gen = get_ys_lognorm, # as specified above
  fun_draws = get_draws_lognorm, # as specified above
  max_n = 5000,
  look_after_every = 200,
  control = "Control",
  # Square-root-based, fixed control group allocation ratio
  # and response-adaptive randomisation for other arms
  control_prob_fixed = "sqrt-based",
  # Equivalence assessment
  equivalence_prob = 0.9,
  equivalence_diff = 0.5,
  equivalence_only_first = TRUE,
  highest_is_best = FALSE,
  # Summarise raw results by taking the mean on the
  # log scale and back-transforming
  fun_raw_est = function(x) exp(mean(log(x))) ,
  # Summarise posteriors using medians with MAD-SDs,
  # as distributions will not be normal on the actual scale
  robust = TRUE,
  # Description/additional info used when printing
  description = "continuous, log-normally distributed outcome",
  add_info = "SD on the log scale for all arms: 1.5"
)

# Print trial specification with 3 digits for all probabilities
print(lognorm_trial, prob_digits = 3)

</code></pre>

<hr>
<h2 id='setup_trial_binom'>Setup a trial specification using a binary, binomially distributed outcome</h2><span id='topic+setup_trial_binom'></span>

<h3>Description</h3>

<p>Specifies the design of an adaptive trial with a binary, binomially
distributed outcome and validates all inputs. Uses <em>beta-binomial</em>
conjugate models with <code>beta(1, 1)</code> prior distributions, corresponding to a
uniform prior (or the addition of 2 patients, 1 with an event and 1 without,
in each <code>arm</code>) to the trial. Use <code><a href="#topic+calibrate_trial">calibrate_trial()</a></code> to calibrate the trial
specification to obtain a specific value for a certain performance metric
(e.g., the Bayesian type 1 error rate). Use <code><a href="#topic+run_trial">run_trial()</a></code> or <code><a href="#topic+run_trials">run_trials()</a></code>
to conduct single/multiple simulations of the specified trial, respectively.
<br />
<strong>Note:</strong> <code>add_info</code> as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code> is set to <code>NULL</code> for
trial specifications setup by this function.<br />
<strong>Further details:</strong> please see <code><a href="#topic+setup_trial">setup_trial()</a></code>. See <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> for
simplified setup of trials with a normally distributed continuous outcome.<br />
For additional trial specification examples, see the the <strong>Basic examples</strong>
vignette (<code>vignette("Basic-examples", package = "adaptr")</code>) and the
<strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_trial_binom(
  arms,
  true_ys,
  start_probs = NULL,
  fixed_probs = NULL,
  min_probs = rep(NA, length(arms)),
  max_probs = rep(NA, length(arms)),
  data_looks = NULL,
  max_n = NULL,
  look_after_every = NULL,
  randomised_at_looks = NULL,
  control = NULL,
  control_prob_fixed = NULL,
  inferiority = 0.01,
  superiority = 0.99,
  equivalence_prob = NULL,
  equivalence_diff = NULL,
  equivalence_only_first = NULL,
  futility_prob = NULL,
  futility_diff = NULL,
  futility_only_first = NULL,
  highest_is_best = FALSE,
  soften_power = 1,
  cri_width = 0.95,
  n_draws = 5000,
  robust = TRUE,
  description = "generic binomially distributed outcome trial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_trial_binom_+3A_arms">arms</code></td>
<td>
<p>character vector with unique names for the trial arms.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_true_ys">true_ys</code></td>
<td>
<p>numeric vector, true probabilities (between <code>0</code> and <code>1</code>) of
outcomes in all trial <code>arms</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_start_probs">start_probs</code></td>
<td>
<p>numeric vector, allocation probabilities for each arm at
the beginning of the trial. The default (<code>NULL</code>) automatically generates
equal randomisation probabilities for each arm.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_fixed_probs">fixed_probs</code></td>
<td>
<p>numeric vector, fixed allocation probabilities for each
arm. Must be either a numeric vector with <code>NA</code> for arms without fixed
probabilities and values between <code>0</code> and <code>1</code> for the other arms or <code>NULL</code>
(default), if adaptive randomisation is used for all arms or if one of the
special settings (<code>"sqrt-based"</code>, <code>"sqrt-based start"</code>,
<code>"sqrt-based fixed"</code>, or <code>"match"</code>) is specified for <code>control_prob_fixed</code>
(described below).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_min_probs">min_probs</code></td>
<td>
<p>numeric vector, lower threshold for adaptive allocation
probabilities; lower probabilities will be rounded up to these values. Must
be <code>NA</code> (default for all arms) if no lower threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_max_probs">max_probs</code></td>
<td>
<p>numeric vector, upper threshold for adaptive allocation
probabilities; higher probabilities will be rounded down to these values.
Must be <code>NA</code> (default for all arms) if no threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_data_looks">data_looks</code></td>
<td>
<p>vector of increasing integers, specifies when to conduct
adaptive analyses (= the total number of patients with available outcome
data at each adaptive analysis). The last number in the vector represents
the final adaptive analysis, i.e., the final analysis where superiority,
inferiority, practical equivalence, or futility can be claimed.
Instead of specifying <code>data_looks</code>, the <code>max_n</code> and <code>look_after_every</code>
arguments can be used in combination (in which case <code>data_looks</code> must be
<code>NULL</code>, the default value).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_max_n">max_n</code></td>
<td>
<p>single integer, number of patients with available outcome data
at the last possible adaptive analysis (defaults to <code>NULL</code>).
Must only be specified if <code>data_looks</code> is <code>NULL</code>. Requires specification of
the <code>look_after_every</code> argument.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_look_after_every">look_after_every</code></td>
<td>
<p>single integer, specified together with <code>max_n</code>.
Adaptive analyses will be conducted after every <code>look_after_every</code>
patients have available outcome data, and at the total sample size as
specified by <code>max_n</code> (<code>max_n</code> does not need to be a multiple of
<code>look_after_every</code>). If specified, <code>data_looks</code> must be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_randomised_at_looks">randomised_at_looks</code></td>
<td>
<p>vector of increasing integers or <code>NULL</code>,
specifying the number of patients randomised at the time of each adaptive
analysis, with new patients randomised using the current allocation
probabilities at said analysis.
If <code>NULL</code> (the default), the number of patients randomised at each analysis
will match the number of patients with available outcome data at said
analysis, as specified by <code>data_looks</code> or <code>max_n</code> and <code>look_after_every</code>,
i.e., outcome data will be available immediately after randomisation for
all patients.<br />
If not <code>NULL</code>, the vector must be of the same length as the number of
adaptive analyses specified by <code>data_looks</code> or <code>max_n</code> and
<code>look_after_every</code>, and all values must be larger than or equal to the
number of patients with available outcome data at each analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_control">control</code></td>
<td>
<p>single character string, name of one of the <code>arms</code> or <code>NULL</code>
(default). If specified, this arm will serve as a common control arm, to
which all other arms will be compared and the
inferiority/superiority/equivalence thresholds (see below) will be for
those comparisons. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for information on
behaviour with respect to these comparisons.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_control_prob_fixed">control_prob_fixed</code></td>
<td>
<p>if a common <code>control</code> arm is specified, this can
be set <code>NULL</code> (the default), in which case the control arm allocation
probability will not be fixed if control arms change (the allocation
probability for the first control arm may still be fixed using
<code>fixed_probs</code>). If not <code>NULL</code>, a vector of probabilities of either length
<code>1</code> or <code style="white-space: pre;">&#8288;number of arms - 1&#8288;</code> can be provided, or one of the special
arguments <code>"sqrt-based"</code>, <code>"sqrt-based start"</code>, <code>"sqrt-based fixed"</code> or
<code>"match"</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for details on how this affects
trial behaviour.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_inferiority">inferiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for inferiority (default is <code>0.01</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be lower than the preceding value. If a common <code>control</code>is not
used, all values must be <code style="white-space: pre;">&#8288;&lt; 1 / number of arms&#8288;</code>. An arm will be considered
inferior and dropped if the probability that it is best (when comparing all
arms) or better than the control arm (when a common <code>control</code> is used)
drops below the inferiority threshold at an adaptive analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_superiority">superiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for superiority (default is <code>0.99</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be higher than the preceding value. If the probability that an
arm is best (when comparing all arms) or better than the control arm (when
a common <code>control</code> is used) exceeds the superiority threshold at an
adaptive analysis, said arm will be declared the winner and the trial will
be stopped (if no common <code>control</code> is used or if the last comparator is
dropped in a design with a common control) <em>or</em> become the new control and
the trial will continue (if a common control is specified).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_equivalence_prob">equivalence_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no equivalence assessment), specifying the
probability threshold(s) for equivalence. If not <code>NULL</code>, all values must be
<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no value may be
higher than the preceding value. If not <code>NULL</code>, arms will be dropped for
equivalence if the probability of either <em>(a)</em> equivalence compared to a
common <code>control</code> or <em>(b)</em> equivalence between all arms remaining (designs
without a common <code>control</code>) exceeds the equivalence threshold at an
adaptive analysis. Requires specification of <code>equivalence_diff</code> and
<code>equivalence_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_equivalence_only_first">equivalence_only_first</code></td>
<td>
<p>single logical in trial specifications where
<code>equivalence_prob</code> and <code>equivalence_diff</code> are specified and a common
<code>control</code> arm is included, otherwise <code>NULL</code> (default). If a common
<code>control</code> arm is used, this specifies whether equivalence will only be
assessed for the first control (if <code>TRUE</code>) or also for subsequent <code>control</code>
arms (if <code>FALSE</code>) if one arm is superior to the first control and becomes
the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_futility_prob">futility_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no futility assessment), specifying the
probability threshold(s) for futility. All values must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>,
and if multiple values are supplied, no value may be higher than the
preceding value. If not <code>NULL</code>, arms will be dropped for futility if
the probability for futility compared to the common <code>control</code> exceeds the
futility threshold at an adaptive analysis. Requires a common <code>control</code>
arm (otherwise this argument must be <code>NULL</code>), specification of
<code>futility_diff</code>, and <code>futility_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_futility_diff">futility_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no futility assessment). If a numeric value is specified,
estimated differences below this threshold in the <em>beneficial</em> direction
(as specified in <code>highest_is_best</code>) will be considered futile when
assessing futility in designs with a common <code>control</code> arm. If only 1 arm
remains after dropping arms for futility, the trial will be stopped without
declaring the last arm superior.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_futility_only_first">futility_only_first</code></td>
<td>
<p>single logical in trial specifications designs
where <code>futility_prob</code> and <code>futility_diff</code> are specified, otherwise <code>NULL</code>
(default and required in designs without a common <code>control</code> arm).
Specifies whether futility will only be assessed against the first
<code>control</code> (if <code>TRUE</code>) or also for subsequent control arms (if <code>FALSE</code>) if
one arm is superior to the first control and becomes the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_soften_power">soften_power</code></td>
<td>
<p>either a single numeric value or a numeric vector of
exactly the same length as the maximum number of looks/adaptive analyses.
Values must be between <code>0</code> and <code>1</code> (default); if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, then re-allocated
non-fixed allocation probabilities are all raised to this power (followed
by rescaling to sum to <code>1</code>) to make adaptive allocation probabilities
less extreme, in turn used to redistribute remaining probability while
respecting limits when defined by <code>min_probs</code> and/or <code>max_probs</code>. If <code>1</code>,
then no <em>softening</em> is applied.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_cri_width">cri_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the
percentile-based credible intervals used when summarising individual trial
results. Defaults to <code>0.95</code>, corresponding to 95% credible intervals.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, the number of draws from the posterior
distributions for each arm used when running the trial. Defaults to
<code>5000</code>; can be reduced for a speed gain (at the potential loss of stability
of results if too low) or increased for increased precision (increasing
simulation time). Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not allowed and values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> are
not recommended and warned against.</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_robust">robust</code></td>
<td>
<p>single logical, if <code>TRUE</code> (default) the medians and median
absolute deviations (scaled to be comparable to the standard deviation for
normal distributions; MAD_SDs, see <code><a href="stats.html#topic+mad">stats::mad()</a></code>) are used to summarise
the posterior distributions; if <code>FALSE</code>, the means and standard deviations
(SDs) are used instead (slightly faster, but may be less appropriate for
posteriors skewed on the natural scale).</p>
</td></tr>
<tr><td><code id="setup_trial_binom_+3A_description">description</code></td>
<td>
<p>character string, default is
<code>"generic binomially distributed outcome trial"</code>. See arguments of
<code><a href="#topic+setup_trial">setup_trial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trial_spec</code> object used to run simulations by <code><a href="#topic+run_trial">run_trial()</a></code> or
<code><a href="#topic+run_trials">run_trials()</a></code>. The output is essentially a list containing the input
values (some combined in a <code>data.frame</code> called <code>trial_arms</code>), but its class
signals that these inputs have been validated and inappropriate
combinations and settings have been ruled out. Also contains <code>best_arm</code>,
holding the arm(s) with the best value(s) in <code>true_ys</code>. Use <code>str()</code> to
peruse the actual content of the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification using a binary, binomially
# distributed, undesirable outcome
binom_trial &lt;- setup_trial_binom(
  arms = c("Arm A", "Arm B", "Arm C"),
  true_ys = c(0.25, 0.20, 0.30),
  # Minimum allocation of 15% in all arms
  min_probs = rep(0.15, 3),
  data_looks = seq(from = 300, to = 2000, by = 100),
  # Stop for equivalence if &gt; 90% probability of
  # absolute differences &lt; 5 percentage points
  equivalence_prob = 0.9,
  equivalence_diff = 0.05,
  soften_power = 0.5 # Limit extreme allocation ratios
)

# Print using 3 digits for probabilities
print(binom_trial, prob_digits = 3)

</code></pre>

<hr>
<h2 id='setup_trial_norm'>Setup a trial specification using a continuous, normally distributed outcome</h2><span id='topic+setup_trial_norm'></span>

<h3>Description</h3>

<p>Specifies the design of an adaptive trial with a continuous, normally
distributed outcome and validates all inputs. Uses normally distributed
posterior distributions for the mean values in each
trial arm; technically, no priors are used (as using <em>normal-normal</em>
conjugate prior models with extremely wide or uniform priors gives similar
results for these simple, unadjusted estimates). This corresponds to the use
of improper, flat priors, although not explicitly specified as such. Use
<code><a href="#topic+calibrate_trial">calibrate_trial()</a></code> to calibrate the trial specification to obtain a specific
value for a certain performance metric (e.g., the Bayesian type 1 error
rate). Use <code><a href="#topic+run_trial">run_trial()</a></code> or <code><a href="#topic+run_trials">run_trials()</a></code> to conduct single/multiple
simulations of the specified trial, respectively.<br />
<strong>Note:</strong> <code>add_info</code> as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code> is set to the arms and
standard deviations used for trials specified using this function.<br />
<strong>Further details:</strong> please see <code><a href="#topic+setup_trial">setup_trial()</a></code>. See <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code>
for simplified setup of trials with binomially distributed binary outcomes.
<br />
For additional trial specification examples, see the the
<strong>Basic examples</strong> vignette
(<code>vignette("Basic-examples", package = "adaptr")</code>) and the
<strong>Advanced example</strong> vignette
(<code>vignette("Advanced-example", package = "adaptr")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_trial_norm(
  arms,
  true_ys,
  sds,
  start_probs = NULL,
  fixed_probs = NULL,
  min_probs = rep(NA, length(arms)),
  max_probs = rep(NA, length(arms)),
  data_looks = NULL,
  max_n = NULL,
  look_after_every = NULL,
  randomised_at_looks = NULL,
  control = NULL,
  control_prob_fixed = NULL,
  inferiority = 0.01,
  superiority = 0.99,
  equivalence_prob = NULL,
  equivalence_diff = NULL,
  equivalence_only_first = NULL,
  futility_prob = NULL,
  futility_diff = NULL,
  futility_only_first = NULL,
  highest_is_best = FALSE,
  soften_power = 1,
  cri_width = 0.95,
  n_draws = 5000,
  robust = FALSE,
  description = "generic normally distributed outcome trial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_trial_norm_+3A_arms">arms</code></td>
<td>
<p>character vector with unique names for the trial arms.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_true_ys">true_ys</code></td>
<td>
<p>numeric vector, simulated means of the outcome in all trial
<code>arms</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_sds">sds</code></td>
<td>
<p>numeric vector, true standard deviations (must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) of the
outcome in all trial <code>arms</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_start_probs">start_probs</code></td>
<td>
<p>numeric vector, allocation probabilities for each arm at
the beginning of the trial. The default (<code>NULL</code>) automatically generates
equal randomisation probabilities for each arm.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_fixed_probs">fixed_probs</code></td>
<td>
<p>numeric vector, fixed allocation probabilities for each
arm. Must be either a numeric vector with <code>NA</code> for arms without fixed
probabilities and values between <code>0</code> and <code>1</code> for the other arms or <code>NULL</code>
(default), if adaptive randomisation is used for all arms or if one of the
special settings (<code>"sqrt-based"</code>, <code>"sqrt-based start"</code>,
<code>"sqrt-based fixed"</code>, or <code>"match"</code>) is specified for <code>control_prob_fixed</code>
(described below).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_min_probs">min_probs</code></td>
<td>
<p>numeric vector, lower threshold for adaptive allocation
probabilities; lower probabilities will be rounded up to these values. Must
be <code>NA</code> (default for all arms) if no lower threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_max_probs">max_probs</code></td>
<td>
<p>numeric vector, upper threshold for adaptive allocation
probabilities; higher probabilities will be rounded down to these values.
Must be <code>NA</code> (default for all arms) if no threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_data_looks">data_looks</code></td>
<td>
<p>vector of increasing integers, specifies when to conduct
adaptive analyses (= the total number of patients with available outcome
data at each adaptive analysis). The last number in the vector represents
the final adaptive analysis, i.e., the final analysis where superiority,
inferiority, practical equivalence, or futility can be claimed.
Instead of specifying <code>data_looks</code>, the <code>max_n</code> and <code>look_after_every</code>
arguments can be used in combination (in which case <code>data_looks</code> must be
<code>NULL</code>, the default value).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_max_n">max_n</code></td>
<td>
<p>single integer, number of patients with available outcome data
at the last possible adaptive analysis (defaults to <code>NULL</code>).
Must only be specified if <code>data_looks</code> is <code>NULL</code>. Requires specification of
the <code>look_after_every</code> argument.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_look_after_every">look_after_every</code></td>
<td>
<p>single integer, specified together with <code>max_n</code>.
Adaptive analyses will be conducted after every <code>look_after_every</code>
patients have available outcome data, and at the total sample size as
specified by <code>max_n</code> (<code>max_n</code> does not need to be a multiple of
<code>look_after_every</code>). If specified, <code>data_looks</code> must be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_randomised_at_looks">randomised_at_looks</code></td>
<td>
<p>vector of increasing integers or <code>NULL</code>,
specifying the number of patients randomised at the time of each adaptive
analysis, with new patients randomised using the current allocation
probabilities at said analysis.
If <code>NULL</code> (the default), the number of patients randomised at each analysis
will match the number of patients with available outcome data at said
analysis, as specified by <code>data_looks</code> or <code>max_n</code> and <code>look_after_every</code>,
i.e., outcome data will be available immediately after randomisation for
all patients.<br />
If not <code>NULL</code>, the vector must be of the same length as the number of
adaptive analyses specified by <code>data_looks</code> or <code>max_n</code> and
<code>look_after_every</code>, and all values must be larger than or equal to the
number of patients with available outcome data at each analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_control">control</code></td>
<td>
<p>single character string, name of one of the <code>arms</code> or <code>NULL</code>
(default). If specified, this arm will serve as a common control arm, to
which all other arms will be compared and the
inferiority/superiority/equivalence thresholds (see below) will be for
those comparisons. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for information on
behaviour with respect to these comparisons.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_control_prob_fixed">control_prob_fixed</code></td>
<td>
<p>if a common <code>control</code> arm is specified, this can
be set <code>NULL</code> (the default), in which case the control arm allocation
probability will not be fixed if control arms change (the allocation
probability for the first control arm may still be fixed using
<code>fixed_probs</code>). If not <code>NULL</code>, a vector of probabilities of either length
<code>1</code> or <code style="white-space: pre;">&#8288;number of arms - 1&#8288;</code> can be provided, or one of the special
arguments <code>"sqrt-based"</code>, <code>"sqrt-based start"</code>, <code>"sqrt-based fixed"</code> or
<code>"match"</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for details on how this affects
trial behaviour.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_inferiority">inferiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for inferiority (default is <code>0.01</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be lower than the preceding value. If a common <code>control</code>is not
used, all values must be <code style="white-space: pre;">&#8288;&lt; 1 / number of arms&#8288;</code>. An arm will be considered
inferior and dropped if the probability that it is best (when comparing all
arms) or better than the control arm (when a common <code>control</code> is used)
drops below the inferiority threshold at an adaptive analysis.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_superiority">superiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for superiority (default is <code>0.99</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be higher than the preceding value. If the probability that an
arm is best (when comparing all arms) or better than the control arm (when
a common <code>control</code> is used) exceeds the superiority threshold at an
adaptive analysis, said arm will be declared the winner and the trial will
be stopped (if no common <code>control</code> is used or if the last comparator is
dropped in a design with a common control) <em>or</em> become the new control and
the trial will continue (if a common control is specified).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_equivalence_prob">equivalence_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no equivalence assessment), specifying the
probability threshold(s) for equivalence. If not <code>NULL</code>, all values must be
<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no value may be
higher than the preceding value. If not <code>NULL</code>, arms will be dropped for
equivalence if the probability of either <em>(a)</em> equivalence compared to a
common <code>control</code> or <em>(b)</em> equivalence between all arms remaining (designs
without a common <code>control</code>) exceeds the equivalence threshold at an
adaptive analysis. Requires specification of <code>equivalence_diff</code> and
<code>equivalence_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_equivalence_only_first">equivalence_only_first</code></td>
<td>
<p>single logical in trial specifications where
<code>equivalence_prob</code> and <code>equivalence_diff</code> are specified and a common
<code>control</code> arm is included, otherwise <code>NULL</code> (default). If a common
<code>control</code> arm is used, this specifies whether equivalence will only be
assessed for the first control (if <code>TRUE</code>) or also for subsequent <code>control</code>
arms (if <code>FALSE</code>) if one arm is superior to the first control and becomes
the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_futility_prob">futility_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no futility assessment), specifying the
probability threshold(s) for futility. All values must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>,
and if multiple values are supplied, no value may be higher than the
preceding value. If not <code>NULL</code>, arms will be dropped for futility if
the probability for futility compared to the common <code>control</code> exceeds the
futility threshold at an adaptive analysis. Requires a common <code>control</code>
arm (otherwise this argument must be <code>NULL</code>), specification of
<code>futility_diff</code>, and <code>futility_only_first</code>.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_futility_diff">futility_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no futility assessment). If a numeric value is specified,
estimated differences below this threshold in the <em>beneficial</em> direction
(as specified in <code>highest_is_best</code>) will be considered futile when
assessing futility in designs with a common <code>control</code> arm. If only 1 arm
remains after dropping arms for futility, the trial will be stopped without
declaring the last arm superior.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_futility_only_first">futility_only_first</code></td>
<td>
<p>single logical in trial specifications designs
where <code>futility_prob</code> and <code>futility_diff</code> are specified, otherwise <code>NULL</code>
(default and required in designs without a common <code>control</code> arm).
Specifies whether futility will only be assessed against the first
<code>control</code> (if <code>TRUE</code>) or also for subsequent control arms (if <code>FALSE</code>) if
one arm is superior to the first control and becomes the new control.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_soften_power">soften_power</code></td>
<td>
<p>either a single numeric value or a numeric vector of
exactly the same length as the maximum number of looks/adaptive analyses.
Values must be between <code>0</code> and <code>1</code> (default); if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, then re-allocated
non-fixed allocation probabilities are all raised to this power (followed
by rescaling to sum to <code>1</code>) to make adaptive allocation probabilities
less extreme, in turn used to redistribute remaining probability while
respecting limits when defined by <code>min_probs</code> and/or <code>max_probs</code>. If <code>1</code>,
then no <em>softening</em> is applied.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_cri_width">cri_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the
percentile-based credible intervals used when summarising individual trial
results. Defaults to <code>0.95</code>, corresponding to 95% credible intervals.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, the number of draws from the posterior
distributions for each arm used when running the trial. Defaults to
<code>5000</code>; can be reduced for a speed gain (at the potential loss of stability
of results if too low) or increased for increased precision (increasing
simulation time). Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not allowed and values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> are
not recommended and warned against.</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_robust">robust</code></td>
<td>
<p>single logical, if <code>TRUE</code> (default) the medians and median
absolute deviations (scaled to be comparable to the standard deviation for
normal distributions; MAD_SDs, see <code><a href="stats.html#topic+mad">stats::mad()</a></code>) are used to summarise
the posterior distributions; if <code>FALSE</code>, the means and standard deviations
(SDs) are used instead (slightly faster, but may be less appropriate for
posteriors skewed on the natural scale).</p>
</td></tr>
<tr><td><code id="setup_trial_norm_+3A_description">description</code></td>
<td>
<p>character string, default is
<code>"generic normally distributed outcome trial"</code>. See arguments of
<code><a href="#topic+setup_trial">setup_trial()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the posteriors used in this type of trial (with a generic,
continuous, normally distributed outcome) are by definition normally
distributed, <code>FALSE</code> is used as the default value for the <code>robust</code> argument.
</p>


<h3>Value</h3>

<p>A <code>trial_spec</code> object used to run simulations by <code><a href="#topic+run_trial">run_trial()</a></code> or
<code><a href="#topic+run_trials">run_trials()</a></code>. The output is essentially a list containing the input
values (some combined in a <code>data.frame</code> called <code>trial_arms</code>), but its class
signals that these inputs have been validated and inappropriate
combinations and settings have been ruled out. Also contains <code>best_arm</code>,
holding the arm(s) with the best value(s) in <code>true_ys</code>. Use <code>str()</code> to
peruse the actual content of the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification using a continuous, normally distributed, desirable outcome
norm_trial &lt;- setup_trial_norm(
  arms = c("Control", "New A", "New B", "New C"),
  true_ys = c(15, 20, 14, 13),
  sds = c(2, 2.5, 1.9, 1.8), # SDs in each arm
  max_n = 500,
  look_after_every = 50,
  control = "Control", # Common control arm
  # Square-root-based, fixed control group allocation ratios
  control_prob_fixed = "sqrt-based fixed",
  # Desirable outcome
  highest_is_best = TRUE,
  soften_power = 0.5 # Limit extreme allocation ratios
)

# Print using 3 digits for probabilities
print(norm_trial, prob_digits = 3)

</code></pre>

<hr>
<h2 id='stop0_warning0'>stop() and warning() with call. = FALSE</h2><span id='topic+stop0_warning0'></span><span id='topic+stop0'></span><span id='topic+warning0'></span>

<h3>Description</h3>

<p>Used internally. Calls <code><a href="#topic+stop0">stop0()</a></code> or <code><a href="base.html#topic+warning">warning()</a></code> but enforces <code>call. = FALSE</code>,
to suppress the call from the error/warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop0(...)

warning0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop0_warning0_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character
(and which are pasted together with no separator) or a single
condition object.</p>
</td></tr>
</table>

<hr>
<h2 id='summarise_dist'>Summarise distribution</h2><span id='topic+summarise_dist'></span>

<h3>Description</h3>

<p>Used internally, to summarise posterior distributions, but the logic does
apply to any distribution (thus, the name).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_dist(x, robust = TRUE, interval_width = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_dist_+3A_x">x</code></td>
<td>
<p>a numeric vector of posterior draws.</p>
</td></tr>
<tr><td><code id="summarise_dist_+3A_robust">robust</code></td>
<td>
<p>single logical. if <code>TRUE</code> (default) the median and median
absolute deviation (MAD-SD; scaled to be comparable to the standard
deviation for normal distributions) are used to summarise the distribution;
if <code>FALSE</code>, the mean and standard deviation (SD) are used instead (slightly
faster, but may be less appropriate for skewed distribution).</p>
</td></tr>
<tr><td><code id="summarise_dist_+3A_interval_width">interval_width</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;1&#8288;</code>); the width of the
interval; default is 0.95, corresponding to 95% percentile-base credible
intervals for posterior distributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MAD-SDs are scaled to correspond to SDs if distributions are normal,
similarly to the <code><a href="stats.html#topic+mad">stats::mad()</a></code> function; see details regarding calculation
in that function's description.
</p>


<h3>Value</h3>

<p>A numeric vector with four named elements: <code>est</code> (the median/mean),
<code>err</code> (the MAD-SD/SD), <code>lo</code> and <code>hi</code> (the lower and upper boundaries of the
interval).
</p>

<hr>
<h2 id='summarise_num'>Summarise numeric vector</h2><span id='topic+summarise_num'></span>

<h3>Description</h3>

<p>Used internally, to summarise numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_num_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with seven named elements: <code>mean</code>, <code>sd</code>, <code>median</code>,
<code>p25</code>, <code>p75</code>, <code>p0</code>, and <code>p100</code> corresponding to the mean, standard
deviation, median, and 25-/75-/0-/100-percentiles.
</p>

<hr>
<h2 id='summary'>Summary of simulated trial results</h2><span id='topic+summary'></span><span id='topic+summary.trial_results'></span>

<h3>Description</h3>

<p>Summarises simulation results from the <code><a href="#topic+run_trials">run_trials()</a></code> function. Uses
<code><a href="#topic+extract_results">extract_results()</a></code> and <code><a href="#topic+check_performance">check_performance()</a></code>, which may be used directly to
extract key trial results without summarising or to calculate performance
metrics (with uncertainty measures if desired) and return them in a tidy
<code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trial_results'
summary(
  object,
  select_strategy = "control if available",
  select_last_arm = FALSE,
  select_preferences = NULL,
  te_comp = NULL,
  raw_ests = FALSE,
  final_ests = NULL,
  restrict = NULL,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p><code>trial_results</code> object, output from the <code><a href="#topic+run_trials">run_trials()</a></code>
function.</p>
</td></tr>
<tr><td><code id="summary_+3A_select_strategy">select_strategy</code></td>
<td>
<p>single character string. If a trial was not stopped
due to superiority (or had only 1 arm remaining, if <code>select_last_arm</code> is
set to <code>TRUE</code> in trial designs with a common <code>control</code> arm; see below),
this parameter specifies which arm will be considered selected when
calculating trial design performance metrics, as described below;
this corresponds to the consequence of an inconclusive trial, i.e., which
arm would then be used in practice.<br />
The following options are available and must be written exactly as below
(case sensitive, cannot be abbreviated):
</p>

<ul>
<li> <p><code>"control if available"</code> (default): selects the <strong>first</strong>
<code>control</code> arm for trials with a common <code>control</code> arm <em><strong>if</strong></em> this
arm is active at end-of-trial, otherwise no arm will be selected. For
trial designs without a common <code>control</code>, no arm will be selected.
</p>
</li>
<li> <p><code>"none"</code>: selects no arm in trials not ending with superiority.
</p>
</li>
<li> <p><code>"control"</code>: similar to <code>"control if available"</code>, but will throw
an error if used for trial designs without a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"final control"</code>: selects the <strong>final</strong> <code>control</code> arm regardless
of whether the trial was stopped for practical equivalence, futility,
or at the maximum sample size; this strategy can only be specified
for trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"control or best"</code>: selects the <strong>first</strong> <code>control</code> arm if still
active at end-of-trial, otherwise selects the best remaining arm
(defined as the remaining arm with the highest probability of being
the best in the last adaptive analysis conducted). Only works for
trial designs with a common <code>control</code> arm.
</p>
</li>
<li> <p><code>"best"</code>: selects the best remaining arm (as described under
<code>"control or best"</code>).
</p>
</li>
<li> <p><code>"list or best"</code>: selects the first remaining arm from a specified
list (specified using <code>select_preferences</code>, technically a character
vector). If none of these arms are are active at end-of-trial, the best
remaining arm will be selected (as described above).
</p>
</li>
<li> <p><code>"list"</code>: as specified above, but if no arms on the provided list
remain active at end-of-trial, no arm is selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary_+3A_select_last_arm">select_last_arm</code></td>
<td>
<p>single logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, the
only remaining active arm (the last <code>control</code>) will be selected in trials
with a common <code>control</code> arm ending with <code>equivalence</code> or <code>futility</code>, before
considering the options specified in <code>select_strategy</code>. Must be <code>FALSE</code> for
trial designs without a common <code>control</code> arm.</p>
</td></tr>
<tr><td><code id="summary_+3A_select_preferences">select_preferences</code></td>
<td>
<p>character vector specifying a number of arms used
for selection if one of the <code>"list or best"</code> or <code>"list"</code> options are
specified for <code>select_strategy</code>. Can only contain valid <code>arms</code>
available in the trial.</p>
</td></tr>
<tr><td><code id="summary_+3A_te_comp">te_comp</code></td>
<td>
<p>character string, treatment-effect comparator. Can be either
<code>NULL</code> (the default) in which case the <strong>first</strong> <code>control</code> arm is used for
trial designs with a common control arm, or a string naming a single trial
<code>arm</code>. Will be used when calculating <code>sq_err_te</code> (the squared error of the
treatment effect comparing the selected arm to the comparator arm, as
described below).</p>
</td></tr>
<tr><td><code id="summary_+3A_raw_ests">raw_ests</code></td>
<td>
<p>single logical. If <code>FALSE</code> (default), the
posterior estimates (<code>post_ests</code> or <code>post_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used to calculate <code>sq_err</code> (the squared error of
the estimated compared to the specified effect in the selected arm) and
<code>sq_err_te</code> (the squared error of the treatment effect comparing the
selected arm to the comparator arm, as described for <code>te_comp</code> and below).
If <code>TRUE</code>, the raw estimates (<code>raw_ests</code> or <code>raw_ests_all</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>) will be used instead of the posterior
estimates.</p>
</td></tr>
<tr><td><code id="summary_+3A_final_ests">final_ests</code></td>
<td>
<p>single logical. If <code>TRUE</code> (recommended) the final estimates
calculated using outcome data from all patients randomised when trials are
stopped are used (<code>post_ests_all</code> or <code>raw_ests_all</code>, see <code><a href="#topic+setup_trial">setup_trial()</a></code>
and <code><a href="#topic+run_trial">run_trial()</a></code>); if <code>FALSE</code>, the estimates calculated for each arm when
an arm is stopped (or at the last adaptive analysis if not before) using
data from patients having reach followed up at this time point and not all
patients randomised are used (<code>post_ests</code> or <code>raw_ests</code>, see
<code><a href="#topic+setup_trial">setup_trial()</a></code> and <code><a href="#topic+run_trial">run_trial()</a></code>). If <code>NULL</code> (the default), this argument
will be set to <code>FALSE</code> if outcome data are available immediate after
randomisation for all patients (for backwards compatibility, as final
posterior estimates may vary slightly in this situation, even if using the
same data); otherwise it will be said to <code>TRUE</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> for
more details on how these estimates are calculated.</p>
</td></tr>
<tr><td><code id="summary_+3A_restrict">restrict</code></td>
<td>
<p>single character string or <code>NULL</code>. If <code>NULL</code> (default),
results are summarised for all simulations; if <code>"superior"</code>, results are
summarised for simulations ending with superiority only; if <code>"selected"</code>,
results are summarised for simulations ending with a selected arm only
(according to the specified arm selection strategy for simulations not
ending with superiority). Some summary measures (e.g., <code>prob_conclusive</code>)
have substantially different interpretations if restricted, but are
calculated nonetheless.</p>
</td></tr>
<tr><td><code id="summary_+3A_cores">cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value set by
<code><a href="#topic+setup_cluster">setup_cluster()</a></code> will be used to control whether extractions of simulation
results are done in parallel on a default cluster or sequentially in the
main process; if a value has not been specified by <code><a href="#topic+setup_cluster">setup_cluster()</a></code>,
<code>cores</code> will then be set to the value stored in the global <code>"mc.cores"</code>
option (if previously set by <code style="white-space: pre;">&#8288;options(mc.cores = &lt;number of cores&gt;&#8288;</code>), and
<code>1</code> if that option has not been specified.<br />
If <code>cores = 1</code>, computations
will be run sequentially in the primary process, and if <code>cores &gt; 1</code>, a new
parallel cluster will be setup using the <code>parallel</code> library and removed
once the function completes. See <code><a href="#topic+setup_cluster">setup_cluster()</a></code> for details.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"trial_results_summary"</code> object containing the following values:
</p>

<ul>
<li> <p><code>n_rep</code>: the number of simulations.
</p>
</li>
<li> <p><code>n_summarised</code>: as described in <code><a href="#topic+check_performance">check_performance()</a></code>.
</p>
</li>
<li> <p><code>highest_is_best</code>: as specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>.
</p>
</li>
<li> <p><code>elapsed_time</code>: the total simulation time.
</p>
</li>
<li> <p><code>size_mean</code>, <code>size_sd</code>, <code>size_median</code>, <code>size_p25</code>, <code>size_p75</code>,
<code>size_p0</code>, <code>size_p100</code>, <code>sum_ys_mean</code>, <code>sum_ys_sd</code>, <code>sum_ys_median</code>,
<code>sum_ys_p25</code>, <code>sum_ys_p75</code>, <code>sum_ys_p0</code>, <code>sum_ys_p100</code>, <code>ratio_ys_mean</code>,
<code>ratio_ys_sd</code>, <code>ratio_ys_median</code>, <code>ratio_ys_p25</code>, <code>ratio_ys_p75</code>,
<code>ratio_ys_p0</code>, <code>ratio_ys_p100</code>, <code>prob_conclusive</code>, <code>prob_superior</code>,
<code>prob_equivalence</code>, <code>prob_futility</code>, <code>prob_max</code>, <code style="white-space: pre;">&#8288;prob_select_*&#8288;</code> (with
<code>*</code> being either &quot;<code style="white-space: pre;">&#8288;arm_&lt;name&gt;&#8288;</code> for all <code>arm</code> names or <code>none</code>), <code>rmse</code>,
<code>rmse_te</code>, and <code>idp</code>: performance metrics as described in
<code><a href="#topic+check_performance">check_performance()</a></code>. Note that all <code>sum_ys_</code> and <code>ratio_ys_</code> measures
use outcome data from all randomised patients, regardless of whether they
had outcome data available at the last analysis or not, as described in
<code><a href="#topic+extract_results">extract_results()</a></code>.
</p>
</li>
<li> <p><code>select_strategy</code>, <code>select_last_arm</code>, <code>select_preferences</code>,
<code>te_comp</code>, <code>raw_ests</code>, <code>final_ests</code>, <code>restrict</code>: as specified above.
</p>
</li>
<li> <p><code>control</code>: the control arm specified by <code><a href="#topic+setup_trial">setup_trial()</a></code>,
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>; <code>NULL</code> if no control.
</p>
</li>
<li> <p><code>equivalence_assessed</code>, <code>futility_assessed</code>: single logicals,
specifies whether the trial design specification includes assessments of
equivalence and/or futility.
</p>
</li>
<li> <p><code>base_seed</code>: as specified in <code><a href="#topic+run_trials">run_trials()</a></code>.
</p>
</li>
<li> <p><code>cri_width</code>, <code>n_draws</code>, <code>robust</code>, <code>description</code>, <code>add_info</code>: as
specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> or
<code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+extract_results">extract_results()</a></code>, <code><a href="#topic+check_performance">check_performance()</a></code>, <code><a href="#topic+plot_convergence">plot_convergence()</a></code>,
<code><a href="#topic+plot_metrics_ecdf">plot_metrics_ecdf()</a></code>, <code><a href="#topic+check_remaining_arms">check_remaining_arms()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup a trial specification
binom_trial &lt;- setup_trial_binom(arms = c("A", "B", "C", "D"),
                                 control = "A",
                                 true_ys = c(0.20, 0.18, 0.22, 0.24),
                                 data_looks = 1:20 * 100)

# Run 10 simulations with a specified random base seed
res &lt;- run_trials(binom_trial, n_rep = 10, base_seed = 12345)

# Summarise simulations - select the control arm if available in trials not
# ending with a superiority decision
res_sum &lt;- summary(res, select_strategy = "control")

# Print summary
print(res_sum, digits = 1)

</code></pre>

<hr>
<h2 id='update_saved_trials'>Update previously saved simulation results</h2><span id='topic+update_saved_trials'></span>

<h3>Description</h3>

<p>This function updates a previously saved <code>"trial_results"</code> object created and
saved by <code><a href="#topic+run_trials">run_trials()</a></code> using a previous version of <code>adaptr</code>, allowing the
results from these previous simulations to be post-processed (including
performance metric calculation, printing and plotting) without errors by this
version of the package. The function should be run only once per saved
simulation object and will issue a warning if the object is already up to
date. And overview of the changes made according to the <code>adaptr</code> package
version used to generate the original object is provided in <strong>Details</strong>.<br />
<strong>NOTE:</strong> some values cannot be updated and will be set to <code>NA</code> (the
posterior estimates from the 'final' analysis conducted after the last
adaptive analysis and including outcome data for all patients), and thus
using both <code>raw_ests = TRUE</code> and <code>final_ests = TRUE</code> in the
<code><a href="#topic+extract_results">extract_results()</a></code> and <code><a href="#topic+summary">summary()</a></code> functions will lead to missing values for
some of the values calculated for updated simulation objects.<br />
<strong>NOTE:</strong> other objects created by the <code>adaptr</code> package, i.e., trial
specifications generated by
<code><a href="#topic+setup_trial">setup_trial()</a></code> / <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> / <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> and single
simulation results from <code><a href="#topic+run_trials">run_trials()</a></code> when not included in as part of the
returned output from <code><a href="#topic+run_trials">run_trials()</a></code> should be re-created by re-running the
relevant code using the updated version of <code>adaptr</code>; if manually re-loaded
from previous sessions, they may cause errors and problems with the updated
version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_saved_trials(path, version = NULL, compress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_saved_trials_+3A_path">path</code></td>
<td>
<p>single character; the path to the saved <code>"trial_results"</code>-object
containing the simulations saved by <code><a href="#topic+run_trials">run_trials()</a></code>.</p>
</td></tr>
<tr><td><code id="update_saved_trials_+3A_version">version</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving the updated object, defaults
to <code>NULL</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), which means that the current default version
is used.</p>
</td></tr>
<tr><td><code id="update_saved_trials_+3A_compress">compress</code></td>
<td>
<p>passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> when saving the updated object,
defaults to <code>TRUE</code> (as in <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>), see <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> for other options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following changes are made according to the version of <code>adaptr</code> used to
generate the original <code>"trial_results"</code> object:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;v1.2.0+&#8288;</code>: only updates the version number.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;v1.1.1 or earlier&#8288;</code>: updates version number and everything related
to follow-up and data collection lag (in these versions, the
<code>randomised_at_looks</code> argument in the <code><a href="#topic+setup_trial">setup_trial()</a></code> functions did not
exist, but for practical purposes was identical to the number of
patients with available data at each look).
</p>
</li></ul>



<h3>Value</h3>

<p>Invisibly returns the updated <code>"trial_results"</code>-object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_trials">run_trials()</a></code>.
</p>

<hr>
<h2 id='validate_trial'>Validate trial specification</h2><span id='topic+validate_trial'></span>

<h3>Description</h3>

<p>Used internally. Validates the inputs common to all trial specifications, as
specified in <code><a href="#topic+setup_trial">setup_trial()</a></code>, <code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_trial(
  arms,
  true_ys,
  start_probs = NULL,
  fixed_probs = NULL,
  min_probs = rep(NA, length(arms)),
  max_probs = rep(NA, length(arms)),
  data_looks = NULL,
  max_n = NULL,
  look_after_every = NULL,
  randomised_at_looks = NULL,
  control = NULL,
  control_prob_fixed = NULL,
  inferiority = 0.01,
  superiority = 0.99,
  equivalence_prob = NULL,
  equivalence_diff = NULL,
  equivalence_only_first = NULL,
  futility_prob = NULL,
  futility_diff = NULL,
  futility_only_first = NULL,
  highest_is_best = FALSE,
  soften_power = 1,
  cri_width = 0.95,
  n_draws = 5000,
  robust = FALSE,
  description = NULL,
  add_info = NULL,
  fun_y_gen,
  fun_draws,
  fun_raw_est
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_trial_+3A_arms">arms</code></td>
<td>
<p>character vector with unique names for the trial arms.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_true_ys">true_ys</code></td>
<td>
<p>numeric vector specifying true outcomes (e.g., event
probabilities, mean values, etc.) for all trial <code>arms</code>.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_start_probs">start_probs</code></td>
<td>
<p>numeric vector, allocation probabilities for each arm at
the beginning of the trial. The default (<code>NULL</code>) automatically generates
equal randomisation probabilities for each arm.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_fixed_probs">fixed_probs</code></td>
<td>
<p>numeric vector, fixed allocation probabilities for each
arm. Must be either a numeric vector with <code>NA</code> for arms without fixed
probabilities and values between <code>0</code> and <code>1</code> for the other arms or <code>NULL</code>
(default), if adaptive randomisation is used for all arms or if one of the
special settings (<code>"sqrt-based"</code>, <code>"sqrt-based start"</code>,
<code>"sqrt-based fixed"</code>, or <code>"match"</code>) is specified for <code>control_prob_fixed</code>
(described below).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_min_probs">min_probs</code></td>
<td>
<p>numeric vector, lower threshold for adaptive allocation
probabilities; lower probabilities will be rounded up to these values. Must
be <code>NA</code> (default for all arms) if no lower threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_max_probs">max_probs</code></td>
<td>
<p>numeric vector, upper threshold for adaptive allocation
probabilities; higher probabilities will be rounded down to these values.
Must be <code>NA</code> (default for all arms) if no threshold is wanted and for arms
using fixed allocation probabilities.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_data_looks">data_looks</code></td>
<td>
<p>vector of increasing integers, specifies when to conduct
adaptive analyses (= the total number of patients with available outcome
data at each adaptive analysis). The last number in the vector represents
the final adaptive analysis, i.e., the final analysis where superiority,
inferiority, practical equivalence, or futility can be claimed.
Instead of specifying <code>data_looks</code>, the <code>max_n</code> and <code>look_after_every</code>
arguments can be used in combination (in which case <code>data_looks</code> must be
<code>NULL</code>, the default value).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_max_n">max_n</code></td>
<td>
<p>single integer, number of patients with available outcome data
at the last possible adaptive analysis (defaults to <code>NULL</code>).
Must only be specified if <code>data_looks</code> is <code>NULL</code>. Requires specification of
the <code>look_after_every</code> argument.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_look_after_every">look_after_every</code></td>
<td>
<p>single integer, specified together with <code>max_n</code>.
Adaptive analyses will be conducted after every <code>look_after_every</code>
patients have available outcome data, and at the total sample size as
specified by <code>max_n</code> (<code>max_n</code> does not need to be a multiple of
<code>look_after_every</code>). If specified, <code>data_looks</code> must be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_randomised_at_looks">randomised_at_looks</code></td>
<td>
<p>vector of increasing integers or <code>NULL</code>,
specifying the number of patients randomised at the time of each adaptive
analysis, with new patients randomised using the current allocation
probabilities at said analysis.
If <code>NULL</code> (the default), the number of patients randomised at each analysis
will match the number of patients with available outcome data at said
analysis, as specified by <code>data_looks</code> or <code>max_n</code> and <code>look_after_every</code>,
i.e., outcome data will be available immediately after randomisation for
all patients.<br />
If not <code>NULL</code>, the vector must be of the same length as the number of
adaptive analyses specified by <code>data_looks</code> or <code>max_n</code> and
<code>look_after_every</code>, and all values must be larger than or equal to the
number of patients with available outcome data at each analysis.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_control">control</code></td>
<td>
<p>single character string, name of one of the <code>arms</code> or <code>NULL</code>
(default). If specified, this arm will serve as a common control arm, to
which all other arms will be compared and the
inferiority/superiority/equivalence thresholds (see below) will be for
those comparisons. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for information on
behaviour with respect to these comparisons.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_control_prob_fixed">control_prob_fixed</code></td>
<td>
<p>if a common <code>control</code> arm is specified, this can
be set <code>NULL</code> (the default), in which case the control arm allocation
probability will not be fixed if control arms change (the allocation
probability for the first control arm may still be fixed using
<code>fixed_probs</code>). If not <code>NULL</code>, a vector of probabilities of either length
<code>1</code> or <code style="white-space: pre;">&#8288;number of arms - 1&#8288;</code> can be provided, or one of the special
arguments <code>"sqrt-based"</code>, <code>"sqrt-based start"</code>, <code>"sqrt-based fixed"</code> or
<code>"match"</code>. See <code><a href="#topic+setup_trial">setup_trial()</a></code> <strong>Details</strong> for details on how this affects
trial behaviour.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_inferiority">inferiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for inferiority (default is <code>0.01</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be lower than the preceding value. If a common <code>control</code>is not
used, all values must be <code style="white-space: pre;">&#8288;&lt; 1 / number of arms&#8288;</code>. An arm will be considered
inferior and dropped if the probability that it is best (when comparing all
arms) or better than the control arm (when a common <code>control</code> is used)
drops below the inferiority threshold at an adaptive analysis.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_superiority">superiority</code></td>
<td>
<p>single numeric value or vector of numeric values of the
same length as the maximum number of possible adaptive analyses, specifying
the probability threshold(s) for superiority (default is <code>0.99</code>). All
values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no
values may be higher than the preceding value. If the probability that an
arm is best (when comparing all arms) or better than the control arm (when
a common <code>control</code> is used) exceeds the superiority threshold at an
adaptive analysis, said arm will be declared the winner and the trial will
be stopped (if no common <code>control</code> is used or if the last comparator is
dropped in a design with a common control) <em>or</em> become the new control and
the trial will continue (if a common control is specified).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_equivalence_prob">equivalence_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no equivalence assessment), specifying the
probability threshold(s) for equivalence. If not <code>NULL</code>, all values must be
<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>, and if multiple values are supplied, no value may be
higher than the preceding value. If not <code>NULL</code>, arms will be dropped for
equivalence if the probability of either <em>(a)</em> equivalence compared to a
common <code>control</code> or <em>(b)</em> equivalence between all arms remaining (designs
without a common <code>control</code>) exceeds the equivalence threshold at an
adaptive analysis. Requires specification of <code>equivalence_diff</code> and
<code>equivalence_only_first</code>.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_equivalence_diff">equivalence_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no equivalence assessment). If a numeric value is
specified, estimated absolute differences smaller than this threshold will
be considered equivalent. For designs with a common <code>control</code> arm, the
differences between each non-control arm and the <code>control</code> arm is used, and
for trials without a common <code>control</code> arm, the difference between the
highest and lowest estimated outcome rates are used and the trial is only
stopped for equivalence if all remaining arms are equivalent.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_equivalence_only_first">equivalence_only_first</code></td>
<td>
<p>single logical in trial specifications where
<code>equivalence_prob</code> and <code>equivalence_diff</code> are specified and a common
<code>control</code> arm is included, otherwise <code>NULL</code> (default). If a common
<code>control</code> arm is used, this specifies whether equivalence will only be
assessed for the first control (if <code>TRUE</code>) or also for subsequent <code>control</code>
arms (if <code>FALSE</code>) if one arm is superior to the first control and becomes
the new control.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_futility_prob">futility_prob</code></td>
<td>
<p>single numeric value, vector of numeric values of the
same length as the maximum number of possible adaptive analyses or <code>NULL</code>
(default, corresponding to no futility assessment), specifying the
probability threshold(s) for futility. All values must be <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 1&#8288;</code>,
and if multiple values are supplied, no value may be higher than the
preceding value. If not <code>NULL</code>, arms will be dropped for futility if
the probability for futility compared to the common <code>control</code> exceeds the
futility threshold at an adaptive analysis. Requires a common <code>control</code>
arm (otherwise this argument must be <code>NULL</code>), specification of
<code>futility_diff</code>, and <code>futility_only_first</code>.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_futility_diff">futility_diff</code></td>
<td>
<p>single numeric value (<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>) or <code>NULL</code> (default,
corresponding to no futility assessment). If a numeric value is specified,
estimated differences below this threshold in the <em>beneficial</em> direction
(as specified in <code>highest_is_best</code>) will be considered futile when
assessing futility in designs with a common <code>control</code> arm. If only 1 arm
remains after dropping arms for futility, the trial will be stopped without
declaring the last arm superior.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_futility_only_first">futility_only_first</code></td>
<td>
<p>single logical in trial specifications designs
where <code>futility_prob</code> and <code>futility_diff</code> are specified, otherwise <code>NULL</code>
(default and required in designs without a common <code>control</code> arm).
Specifies whether futility will only be assessed against the first
<code>control</code> (if <code>TRUE</code>) or also for subsequent control arms (if <code>FALSE</code>) if
one arm is superior to the first control and becomes the new control.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_highest_is_best">highest_is_best</code></td>
<td>
<p>single logical, specifies whether larger estimates of
the outcome are favourable or not; defaults to <code>FALSE</code>, corresponding to,
e.g., an undesirable binary outcomes (e.g., mortality) or a continuous
outcome where lower numbers are preferred (e.g., hospital length of stay).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_soften_power">soften_power</code></td>
<td>
<p>either a single numeric value or a numeric vector of
exactly the same length as the maximum number of looks/adaptive analyses.
Values must be between <code>0</code> and <code>1</code> (default); if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, then re-allocated
non-fixed allocation probabilities are all raised to this power (followed
by rescaling to sum to <code>1</code>) to make adaptive allocation probabilities
less extreme, in turn used to redistribute remaining probability while
respecting limits when defined by <code>min_probs</code> and/or <code>max_probs</code>. If <code>1</code>,
then no <em>softening</em> is applied.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_cri_width">cri_width</code></td>
<td>
<p>single numeric <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, the width of the
percentile-based credible intervals used when summarising individual trial
results. Defaults to <code>0.95</code>, corresponding to 95% credible intervals.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_n_draws">n_draws</code></td>
<td>
<p>single integer, the number of draws from the posterior
distributions for each arm used when running the trial. Defaults to
<code>5000</code>; can be reduced for a speed gain (at the potential loss of stability
of results if too low) or increased for increased precision (increasing
simulation time). Values <code style="white-space: pre;">&#8288;&lt; 100&#8288;</code> are not allowed and values <code style="white-space: pre;">&#8288;&lt; 1000&#8288;</code> are
not recommended and warned against.</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_robust">robust</code></td>
<td>
<p>single logical, if <code>TRUE</code> (default) the medians and median
absolute deviations (scaled to be comparable to the standard deviation for
normal distributions; MAD_SDs, see <code><a href="stats.html#topic+mad">stats::mad()</a></code>) are used to summarise
the posterior distributions; if <code>FALSE</code>, the means and standard deviations
(SDs) are used instead (slightly faster, but may be less appropriate for
posteriors skewed on the natural scale).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_description">description</code></td>
<td>
<p>optional single character string describing the trial
design, will only be used in print functions if not <code>NULL</code> (the default).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_add_info">add_info</code></td>
<td>
<p>optional single string containing additional information
regarding the trial design or specifications, will only be used in print
functions if not <code>NULL</code> (the default).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_fun_y_gen">fun_y_gen</code></td>
<td>
<p>function, generates outcomes. See <code><a href="#topic+setup_trial">setup_trial()</a></code>
<strong>Details</strong> for information on how to specify this function.<br />
<strong>Note:</strong> this function is called once during setup to validate its output
(with the global random seed restored afterwards).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_fun_draws">fun_draws</code></td>
<td>
<p>function, generates posterior draws. See <code><a href="#topic+setup_trial">setup_trial()</a></code>
<strong>Details</strong> for information on how to specify this function.<br />
<strong>Note:</strong> this function is called up to three times during setup to
validate its output (with the global random seed restored afterwards).</p>
</td></tr>
<tr><td><code id="validate_trial_+3A_fun_raw_est">fun_raw_est</code></td>
<td>
<p>function that takes a numeric vector and returns a
single numeric value, used to calculate a raw summary estimate of the
outcomes in each <code>arm</code>. Defaults to <code><a href="base.html#topic+mean">mean()</a></code>, which is always used in the
<code><a href="#topic+setup_trial_binom">setup_trial_binom()</a></code> and <code><a href="#topic+setup_trial_norm">setup_trial_norm()</a></code> functions.<br />
<strong>Note:</strong> the function is called one time per arm during setup to validate
the output structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>trial_spec</code> containing the validated trial
specification.
</p>

<hr>
<h2 id='vapply_helpers'>vapply helpers</h2><span id='topic+vapply_helpers'></span><span id='topic+vapply_num'></span><span id='topic+vapply_int'></span><span id='topic+vapply_str'></span><span id='topic+vapply_lgl'></span>

<h3>Description</h3>

<p>Used internally. Helpers for simplifying code invoking vapply().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapply_num(X, FUN, ...)

vapply_int(X, FUN, ...)

vapply_str(X, FUN, ...)

vapply_lgl(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vapply_helpers_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an <code><a href="base.html#topic+expression">expression</a></code>
object.  Other objects (including classed objects) will be coerced
by <code>base::<a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="vapply_helpers_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each element of <code>X</code>:
see &lsquo;Details&rsquo;.  In the case of functions like
<code>+</code>, <code>%*%</code>, the function name must be backquoted or quoted.</p>
</td></tr>
<tr><td><code id="vapply_helpers_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_int'>Verify input is single integer (potentially within range)</h2><span id='topic+verify_int'></span>

<h3>Description</h3>

<p>Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_int(x, min_value = -Inf, max_value = Inf, open = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_int_+3A_x">x</code></td>
<td>
<p>value to check.</p>
</td></tr>
<tr><td><code id="verify_int_+3A_min_value">min_value</code>, <code id="verify_int_+3A_max_value">max_value</code></td>
<td>
<p>single integers (each), lower and upper bounds
between which <code>x</code> should lie.</p>
</td></tr>
<tr><td><code id="verify_int_+3A_open">open</code></td>
<td>
<p>single character, determines whether <code>min_value</code> and <code>max_value</code>
are excluded or not. Valid values: <code>"no"</code> (= closed interval; <code>min_value</code>
and <code>max_value</code> included; default value), <code>"right"</code>, <code>"left"</code>, <code>"yes"</code>
(= open interval, <code>min_value</code> and <code>max_value</code> excluded).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single logical.
</p>

<hr>
<h2 id='which_nearest'>Find the index of value nearest to a target value</h2><span id='topic+which_nearest'></span>

<h3>Description</h3>

<p>Used internally, to find the index of the value in a vector nearest to a
target value, possibly in a specific preferred direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_nearest(values, target, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_nearest_+3A_values">values</code></td>
<td>
<p>numeric vector, the values considered.</p>
</td></tr>
<tr><td><code id="which_nearest_+3A_target">target</code></td>
<td>
<p>single numeric value, the target to find the value closest to.</p>
</td></tr>
<tr><td><code id="which_nearest_+3A_dir">dir</code></td>
<td>
<p>single numeric value. If <code>0</code> (the default), finds the index of the
value closest to the target, regardless of the direction. If <code style="white-space: pre;">&#8288;&lt; 0&#8288;</code> or
<code style="white-space: pre;">&#8288;&gt; 0&#8288;</code>, finds the index of the value closest to the target, but only
considers values at or below/above target, respectfully, if any (otherwise
returns the closest value regardless of direction).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single integer, the index of the value closest to <code>target</code> according
to <code>dir</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
