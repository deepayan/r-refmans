<!DOCTYPE html><html><head><title>Help for package MKomics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MKomics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#corDist'><p> Correlation Distance Matrix Computation</p></a></li>
<li><a href='#corPlot'><p> Plot of similarity matrix based on correlation</p></a></li>
<li><a href='#heatmapCol'><p> Generate colors for heatmaps</p></a></li>
<li><a href='#madMatrix'><p> Compute MAD between colums of a matrix or data.frame</p></a></li>
<li><a href='#madPlot'><p> Plot of similarity matrix based on MAD</p></a></li>
<li><a href='#MKomics-package'>
<p>Omics Data Analysis.</p></a></li>
<li><a href='#mod.oneway.test'><p>Moderated 1-Way ANOVA</p></a></li>
<li><a href='#mod.t.test'><p>Moderated t-Test</p></a></li>
<li><a href='#oneWayAnova'><p> A function for Analysis of Variance</p></a></li>
<li><a href='#pairwise.fc'><p> Compute pairwise fold changes</p></a></li>
<li><a href='#pairwise.logfc'><p> Compute pairwise log-fold changes</p></a></li>
<li><a href='#pairwise.mod.t.test'><p>Pairwise Moderated t-Tests</p></a></li>
<li><a href='#repMeans'><p> Compute mean of replicated spots</p></a></li>
<li><a href='#simPlot'><p> Plot of a similarity matrix.</p></a></li>
<li><a href='#stringDist'><p>Function to compute distances between strings</p></a></li>
<li><a href='#stringSim'><p>Function to compute similarity scores between strings</p></a></li>
<li><a href='#traceBack'>
<p>Function to trace back</p></a></li>
<li><a href='#twoWayAnova'><p> A function for Analysis of Variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Omics Data Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices, RColorBrewer, robustbase,
limma, grid, circlize, ComplexHeatmap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Similarity plots based on correlation and median absolute deviation (MAD); adjusting colors for heatmaps; aggregate technical replicates; calculate pairwise fold-changes and log fold-changes; compute one- and two-way ANOVA; simplified interface to package 'limma' (Ritchie et al. (2015), &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkv007">doi:10.1093/nar/gkv007</a>&gt; ) for moderated t-test and one-way ANOVA; Hamming and Levenshtein (edit) distance of strings as well as optimal alignment scores for global (Needleman-Wunsch) and local (Smith-Waterman) alignments with constant gap penalties (Merkl and Waack (2009), ISBN:978-3-527-32594-8).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.stamats.de/">https://www.stamats.de/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-08 13:24:50 UTC; kohlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-08 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='corDist'> Correlation Distance Matrix Computation </h2><span id='topic+corDist'></span>

<h3>Description</h3>

<p>The function computes and returns the correlation and absolute correlation distance
matrix computed by using the specified distance measure to compute the distances
between the rows of a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corDist(x, method = "pearson", diag = FALSE, upper = FALSE, abs = FALSE,
        use = "pairwise.complete.obs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corDist_+3A_x">x</code></td>
<td>
<p> a numeric matrix or data frame </p>
</td></tr>
<tr><td><code id="corDist_+3A_method">method</code></td>
<td>
<p> the correlation distance measure to be used. This must be one of
<code>"pearson"</code>, <code>"spearman"</code>, <code>"kandall"</code>, <code>"cosine"</code>,
<code>"mcd"</code> or <code>"ogk"</code>, respectively.
Any unambiguous substring can be given. </p>
</td></tr>
<tr><td><code id="corDist_+3A_diag">diag</code></td>
<td>
<p> logical value indicating whether the diagonal of the distance
matrix should be printed by 'print.dist'. </p>
</td></tr>
<tr><td><code id="corDist_+3A_upper">upper</code></td>
<td>
<p> logical value indicating whether the upper triangle of the
distance matrix should be printed by 'print.dist'. </p>
</td></tr>
<tr><td><code id="corDist_+3A_abs">abs</code></td>
<td>
<p> logical, compute absolute correlation distances </p>
</td></tr>
<tr><td><code id="corDist_+3A_use">use</code></td>
<td>
<p> character, correponds to argument <code>use</code> of function
<code><a href="stats.html#topic+cor">cor</a></code> </p>
</td></tr>
<tr><td><code id="corDist_+3A_...">...</code></td>
<td>
<p> further arguments to functions <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
or <code><a href="robustbase.html#topic+covOGK">covOGK</a></code>, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the Pearson, Spearman, Kendall or Cosine sample correlation
and absolute correlation; confer Section 12.2.2 of Gentleman et al (2005). For more
details about the arguments we refer to functions <code><a href="stats.html#topic+dist">dist</a></code> and
<code><a href="stats.html#topic+cor">cor</a></code>.
Moreover, the function computes the minimum covariance determinant or the
orthogonalized Gnanadesikan-Kettenring estimator. For more details we refer to
functions <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> and <code><a href="robustbase.html#topic+covOGK">covOGK</a></code>,
respectively.
</p>


<h3>Value</h3>

<p><code>corDist</code> returns an object of class <code>"dist"</code>; cf. <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Gentleman R. Ding B., Dudoit S. and Ibrahim J. (2005). Distance Measures in DNA
Microarray Data Analysis. In: Gentleman R., Carey V.J., Huber W., Irizarry R.A. and
Dudoit S. (editors) Bioinformatics and Computational Biology Solutions Using R and
Bioconductor. Springer.
</p>
<p>P. J. Rousseeuw and A. M. Leroy (1987). Robust Regression and Outlier Detection. Wiley.
</p>
<p>P. J. Rousseeuw and K. van Driessen (1999) A fast algorithm for the minimum
covariance determinant estimator. Technometrics 41, 212-223.
</p>
<p>Pison, G., Van Aelst, S., and Willems, G. (2002), Small Sample Corrections for
LTS and MCD, Metrika, 55, 111-123.
</p>
<p>Maronna, R.A. and Zamar, R.H. (2002). Robust estimates of location and dispersion
of high-dimensional datasets; Technometrics 44(4), 307-317.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972). Robust estimates, residuals, and
outlier detection with multiresponse data. Biometrics 28, 81-124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
M &lt;- matrix(rnorm(1000), ncol = 20)
D &lt;- corDist(M)
</code></pre>

<hr>
<h2 id='corPlot'> Plot of similarity matrix based on correlation </h2><span id='topic+corPlot'></span><span id='topic+corPlot2'></span>

<h3>Description</h3>

<p>Plot of similarity matrix. This function is a slight modification of function
<code>plot.cor</code> of the archived package <code>"sma"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corPlot(x, new = FALSE, col, minCor, 
        labels = FALSE, lab.both.axes = FALSE, labcols = "black", 
        title = "", cex.title = 1.2, 
        protocol = FALSE, cex.axis = 0.8, 
        cex.axis.bar = 1, signifBar = 2, ...)
        
corPlot2(x, new = FALSE, col, minCor = 0.5, labels = FALSE, 
         row.width = 6, column.height = 6, lab.both.axes = TRUE, 
         fontsize.axis = 12, title = "", fontsize.title = 16, 
         signifBar = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corPlot_+3A_x">x</code></td>
<td>
<p> data or correlation matrix, respectively </p>
</td></tr>
<tr><td><code id="corPlot_+3A_new">new</code></td>
<td>
<p> If <code>new=FALSE</code>, <code>x</code> must already be a correlation matrix. 
If <code>new=TRUE</code>, the correlation matrix for the columns of 
<code>x</code> is computed and displayed in the image. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_col">col</code></td>
<td>
<p> colors palette for image. If missing, the <code>RdYlGn</code> palette
of <code>RColorBrewer</code> is used.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_mincor">minCor</code></td>
<td>
<p>numeric value in [-1,1], used to adjust <code>col</code></p>
</td></tr>
<tr><td><code id="corPlot_+3A_labels">labels</code></td>
<td>
<p> vector of character strings to be placed at the tickpoints,
labels for the columns of <code>x</code>. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_lab.both.axes">lab.both.axes</code></td>
<td>
<p> logical, display labels on both axes </p>
</td></tr>
<tr><td><code id="corPlot_+3A_labcols">labcols</code></td>
<td>
<p> colors to be used for the labels of the columns of <code>x</code>.
<code>labcols</code> can have either length 1, in which case all 
the labels are displayed using the same color, or the same 
length as <code>labels</code>, in which case a color is specified 
for the label of each column of <code>x</code>. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_title">title</code></td>
<td>
<p> character string, overall title for the plot. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_cex.title">cex.title</code></td>
<td>
<p> numerical value giving the amount by which plotting text
and symbols should be magnified relative to the default;
cf. <code><a href="graphics.html#topic+par">par</a></code>, <code>cex.main</code>. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_fontsize.title">fontsize.title</code></td>
<td>
<p> numerical value giving the fontsize of the title. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_protocol">protocol</code></td>
<td>
<p> logical, display color bar without numbers. </p>
</td></tr>
<tr><td><code id="corPlot_+3A_cex.axis">cex.axis</code></td>
<td>
<p> The magnification to be used for axis annotation relative to the 
current setting of 'cex'; cf. <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_fontsize.axis">fontsize.axis</code></td>
<td>
<p> numerical value giving the fontsize of the axis labels.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_cex.axis.bar">cex.axis.bar</code></td>
<td>
<p> The magnification to be used for axis annotation of the color 
bar relative to the current setting of 'cex'; cf. 
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_signifbar">signifBar</code></td>
<td>
<p> integer indicating the precision to be used for the bar.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_row.width">row.width</code></td>
<td>
<p> numerical value giving width of the row in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_column.height">column.height</code></td>
<td>
<p> numerical value giving the height of the column in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="corPlot_+3A_...">...</code></td>
<td>
<p> graphical parameters may also be supplied as arguments to the
function (see <code><a href="graphics.html#topic+par">par</a></code>). For comparison purposes, 
it is good to set <code>zlim=c(-1,1)</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions generates the so called similarity matrix (based on correlation) 
for a microarray experiment. 
</p>
<p>If <code>min(x)</code>, respectively <code>min(cor(x))</code> is smaller than <code>minCor</code>, 
the colors in <code>col</code> are adjusted such that the minimum correlation value 
which is color coded is equal to <code>minCor</code>.
</p>


<h3>Value</h3>

<p><code>invisible()</code>
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Sandrine Dudoit, Yee Hwa (Jean) Yang, Benjamin Milo Bolstad and with 
contributions from Natalie Thorne, Ingrid Loennstedt and Jessica Mar.
sma: Statistical Microarray Analysis.<br />
http://www.stat.berkeley.edu/users/terry/zarray/Software/smacode.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
M &lt;- matrix(rnorm(1000), ncol = 20)
colnames(M) &lt;- paste("Sample", 1:20)
M.cor &lt;- cor(M)

corPlot(M.cor, minCor = min(M.cor))
corPlot(M.cor, minCor = min(M.cor), lab.both.axes = TRUE)
corPlot(M.cor, minCor = min(M.cor), protocol = TRUE)
corPlot(M.cor, minCor = min(M.cor), signifBar = 1)

corPlot2(M.cor, minCor = min(M.cor))
corPlot2(M.cor, minCor = min(M.cor), lab.both.axes = FALSE)
corPlot2(M.cor, minCor = min(M.cor), signifBar = 1)
</code></pre>

<hr>
<h2 id='heatmapCol'> Generate colors for heatmaps </h2><span id='topic+heatmapCol'></span>

<h3>Description</h3>

<p>This function modifies a given color vector as used for heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapCol(data, col, lim, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmapCol_+3A_data">data</code></td>
<td>
<p> matrix or data.frame; data which shall be displayed in a heatmap; ranging from negative to positive numbers. </p>
</td></tr>
<tr><td><code id="heatmapCol_+3A_col">col</code></td>
<td>
<p> vector of colors used for heatmap. </p>
</td></tr>
<tr><td><code id="heatmapCol_+3A_lim">lim</code></td>
<td>
<p> constant colors are used for data below <code>-lim</code> resp. above <code>lim</code>. </p>
</td></tr>
<tr><td><code id="heatmapCol_+3A_na.rm">na.rm</code></td>
<td>
<p> logical; remove <code>NA</code> values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors below and above a specified value are kept constant. In addition, the colors
are symmetrizised.
</p>


<h3>Value</h3>

<p>vector of colors
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data.plot &lt;- matrix(rnorm(100*50, sd = 1), ncol = 50)
colnames(data.plot) &lt;- paste("patient", 1:50)
rownames(data.plot) &lt;- paste("gene", 1:100)
data.plot[1:70, 1:30] &lt;- data.plot[1:70, 1:30] + 3
data.plot[71:100, 31:50] &lt;- data.plot[71:100, 31:50] - 1.4
data.plot[1:70, 31:50] &lt;- rnorm(1400, sd = 1.2)
data.plot[71:100, 1:30] &lt;- rnorm(900, sd = 1.2)
nrcol &lt;- 128

require(RColorBrewer)
myCol &lt;- rev(colorRampPalette(brewer.pal(10, "RdBu"))(nrcol))
heatmap(data.plot, col =  myCol, main = "standard colors")
myCol2 &lt;- heatmapCol(data = data.plot, col = myCol, 
                     lim = min(abs(range(data.plot)))-1)
heatmap(data.plot, col = myCol2, main = "heatmapCol colors")
</code></pre>

<hr>
<h2 id='madMatrix'> Compute MAD between colums of a matrix or data.frame </h2><span id='topic+madMatrix'></span>

<h3>Description</h3>

<p>Compute MAD between colums of a matrix or data.frame. Can be used to create
a similarity matrix for a microarray experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madMatrix_+3A_x">x</code></td>
<td>
<p> matrix or data.frame </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions computes the so called similarity matrix (based on MAD)
for a microarray experiment; cf. Buness et. al. (2004).
</p>


<h3>Value</h3>

<p>matrix of MAD values between colums of <code>x</code>
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Andreas Buness, Wolfgang Huber, Klaus Steiner, Holger Sueltmann, and
Annemarie Poustka. arrayMagic: two-colour cDNA microarray quality
control and preprocessing. Bioinformatics Advance Access published on
September 28, 2004. doi:10.1093/bioinformatics/bti052
</p>


<h3>See Also</h3>

<p><code>plotMAD</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
madMatrix(matrix(rnorm(1000), ncol = 10))
</code></pre>

<hr>
<h2 id='madPlot'> Plot of similarity matrix based on MAD </h2><span id='topic+madPlot'></span><span id='topic+madPlot2'></span>

<h3>Description</h3>

<p>Plot of similarity matrix based on MAD between microarrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madPlot(x, new = FALSE, col, maxMAD = 3, labels = FALSE, 
        labcols = "black", title = "", protocol = FALSE, ...)

madPlot2(x, new = FALSE, col, maxMAD = 3, labels = FALSE, 
         row.width = 6, column.height = 6, 
         lab.both.axes = TRUE, fontsize.axis = 12,
         title = "", fontsize.title = 16, signifBar = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madPlot_+3A_x">x</code></td>
<td>
<p> data or correlation matrix, respectively </p>
</td></tr>
<tr><td><code id="madPlot_+3A_new">new</code></td>
<td>
<p> If <code>new=FALSE</code>, <code>x</code> must already be a matrix with MAD
values. If <code>new=TRUE</code>, the MAD matrix for the columns of 
<code>x</code> is computed and displayed in the image. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_col">col</code></td>
<td>
<p> colors palette for image. If missing, the <code>RdYlGn</code> palette
of <code>RColorBrewer</code> is used. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_maxmad">maxMAD</code></td>
<td>
<p> maximum MAD value displayed  </p>
</td></tr>
<tr><td><code id="madPlot_+3A_labels">labels</code></td>
<td>
<p> vector of character strings to be placed at the tickpoints,
labels for the columns of <code>x</code>. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_labcols">labcols</code></td>
<td>
<p> colors to be used for the labels of the columns of <code>x</code>.
<code>labcols</code> can have either length 1, in which case all 
the labels are displayed using the same color, or the same 
length as <code>labels</code>, in which case a color is specified 
for the label of each column of <code>x</code>. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_title">title</code></td>
<td>
<p> character string, overall title for the plot. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_fontsize.title">fontsize.title</code></td>
<td>
<p> numerical value giving the fontsize of the title. </p>
</td></tr>
<tr><td><code id="madPlot_+3A_protocol">protocol</code></td>
<td>
<p> logical, display color bar without numbers </p>
</td></tr>
<tr><td><code id="madPlot_+3A_lab.both.axes">lab.both.axes</code></td>
<td>
<p> logical, display labels on both axes </p>
</td></tr>
<tr><td><code id="madPlot_+3A_fontsize.axis">fontsize.axis</code></td>
<td>
<p> numerical value giving the fontsize of the axis labels.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_signifbar">signifBar</code></td>
<td>
<p> integer indicating the precision to be used for the bar.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_row.width">row.width</code></td>
<td>
<p> numerical value giving width of the row in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_column.height">column.height</code></td>
<td>
<p> numerical value giving the height of the column in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_...">...</code></td>
<td>
<p> graphical parameters may also be supplied as arguments to the
function (see <code><a href="graphics.html#topic+par">par</a></code>). For comparison purposes, 
it is good to set <code>zlim=c(-1,1)</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions generates the so called similarity matrix (based on MAD) for 
a microarray experiment; cf. Buness et. al. (2004). The function is similar
to <code><a href="#topic+corPlot">corPlot</a></code>.
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Sandrine Dudoit, Yee Hwa (Jean) Yang, Benjamin Milo Bolstad and with 
contributions from Natalie Thorne, Ingrid Loennstedt and Jessica Mar.
sma: Statistical Microarray Analysis.<br />
http://www.stat.berkeley.edu/users/terry/zarray/Software/smacode.html
</p>
<p>Andreas Buness, Wolfgang Huber, Klaus Steiner, Holger Sueltmann, and
Annemarie Poustka. arrayMagic: two-colour cDNA microarray quality
control and preprocessing. Bioinformatics Advance Access published on
September 28, 2004. doi:10.1093/bioinformatics/bti052
</p>


<h3>See Also</h3>

<p><code>corPlot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
set.seed(13)
x &lt;- matrix(rnorm(1000), ncol = 10)
x[1:20,5] &lt;- x[1:20,5] + 10
madPlot(x, new = TRUE, maxMAD = 2.5)
madPlot2(x, new = TRUE, maxMAD = 2.5)
## in contrast
corPlot2(x, new = TRUE, minCor = -0.5)
</code></pre>

<hr>
<h2 id='MKomics-package'>
Omics Data Analysis.
</h2><span id='topic+MKomics-package'></span><span id='topic+MKomics'></span>

<h3>Description</h3>

<p>Similarity plots based on correlation and median absolute deviation (MAD); 
adjusting colors for heatmaps; aggregate technical replicates; calculate 
pairwise fold-changes and log fold-changes; computate one- and two-way ANOVA; 
simplified interface to package 'limma' (Ritchie et al. (2015), &lt;doi:10.1093/nar/gkv007&gt;) 
for moderated t-test and one-way ANOVA; Hamming and Levenshtein (edit) 
distance of strings as well as optimal alignment scores for global (Needleman-Wunsch) 
and local (Smith-Waterman) alignments with constant gap penalties 
(Merkl and Waack (2009), ISBN:978-3-527-32594-8).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MKomics</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-08-08</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, utils, graphics, grDevices, RColorBrewer, robustbase, limma</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.stamats.de/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>library(MKomics)
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="https://www.stamats.de">https://www.stamats.de</a>
</p>
<p>Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>

<hr>
<h2 id='mod.oneway.test'>Moderated 1-Way ANOVA</h2><span id='topic+mod.oneway.test'></span>

<h3>Description</h3>

<p>Performs moderated 1-Way ANOVAs based on Bioconductor package limma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod.oneway.test(x, group, repeated = FALSE, subject, adjust.method = "BH", 
                sort.by = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.oneway.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric matrix of data values.</p>
</td></tr>
<tr><td><code id="mod.oneway.test_+3A_group">group</code></td>
<td>
<p>an optional factor representing the groups.</p>
</td></tr>
<tr><td><code id="mod.oneway.test_+3A_repeated">repeated</code></td>
<td>
<p>logical indicating whether there are repeated-measures.</p>
</td></tr>
<tr><td><code id="mod.oneway.test_+3A_subject">subject</code></td>
<td>
<p>factor with subject IDs; required if <code>repeated = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mod.oneway.test_+3A_adjust.method">adjust.method</code></td>
<td>
<p>see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
<tr><td><code id="mod.oneway.test_+3A_sort.by">sort.by</code></td>
<td>
<p>see <code><a href="limma.html#topic+toptable">toptable</a></code></p>
</td></tr></table>
<p>, where <code>"logFC"</code>
corresponds to difference in means.
</p>


<h3>Details</h3>

<p>The function uses Bioconductor package limma to compute moderated 1-way ANOVAs.
For more details we refer to <code><a href="limma.html#topic+ebayes">ebayes</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame with the results.
</p>


<h3>References</h3>

<p>Ritchie, M.E., Phipson, B., Wu, D., Hu, Y., Law, C.W., Shi, W., and Smyth, G.K.
(2015). limma powers differential expression analyses for RNA-sequencing and
microarray studies. <em>Nucleic Acids Research</em> 43(7), e47.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+oneway.test">oneway.test</a></code>, <code>mod.t.test</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
X &lt;- rbind(matrix(rnorm(5*20), nrow = 5, ncol = 20),
           matrix(rnorm(5*20, mean = 1), nrow = 5, ncol = 20))
gr &lt;- factor(c(rep("A1", 5), rep("B2", 5), rep("C3", 5), rep("D4", 5)))
mod.oneway.test(X, gr)

## Welch 1-Way ANOVA (not moderated)
ow.test &lt;- function(x, g){
  res &lt;- oneway.test(x ~ g)
  c(res$statistic, res$p.value)
}
ow.res &lt;- t(apply(X, 1, ow.test, g = gr))
colnames(ow.res) &lt;- c("F", "p.value")
ow.res

## repeated measures
X &lt;- rbind(matrix(rnorm(6*18), nrow = 6, ncol = 18),
           matrix(rnorm(6*18, mean = 1), nrow = 6, ncol = 18))
gr &lt;- factor(c(rep("T1", 6), rep("T2", 6), rep("T3", 6)))
subjectID &lt;- factor(c(rep(1:6, 3)))
mod.oneway.test(X, gr, repeated = TRUE, subject = subjectID)
</code></pre>

<hr>
<h2 id='mod.t.test'>Moderated t-Test</h2><span id='topic+mod.t.test'></span>

<h3>Description</h3>

<p>Performs moderated t-tests based on Bioconductor package limma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod.t.test(x, group = NULL, paired = FALSE, subject, adjust.method = "BH",
           sort.by = "none", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric matrix of data values.</p>
</td></tr>
<tr><td><code id="mod.t.test_+3A_group">group</code></td>
<td>
<p>an optional factor representing the groups.</p>
</td></tr>
<tr><td><code id="mod.t.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="mod.t.test_+3A_subject">subject</code></td>
<td>
<p>factor with subject IDs; required if <code>paired = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mod.t.test_+3A_adjust.method">adjust.method</code></td>
<td>
<p>see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
<tr><td><code id="mod.t.test_+3A_sort.by">sort.by</code></td>
<td>
<p>see <code><a href="limma.html#topic+toptable">toptable</a></code></p>
</td></tr></table>
<p>, where <code>"logFC"</code>
corresponds to difference in means.
</p>
<table>
<tr><td><code id="mod.t.test_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values (including NaN) be omitted from 
the calculations of group means?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses Bioconductor package limma to compute moderated t-tests.
For more details we refer to <code><a href="limma.html#topic+ebayes">ebayes</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame with the results.
</p>


<h3>References</h3>

<p>Ritchie, M.E., Phipson, B., Wu, D., Hu, Y., Law, C.W., Shi, W., and Smyth, G.K.
(2015). limma powers differential expression analyses for RNA-sequencing and
microarray studies. <em>Nucleic Acids Research</em> 43(7), e47.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## One-sample test
X &lt;- matrix(rnorm(10*20, mean = 1), nrow = 10, ncol = 20)

mod.t.test(X)
## corresponds to
library(limma)
design &lt;- matrix(1, nrow = ncol(X), ncol = 1)
colnames(design) &lt;- "A"
fit1 &lt;- lmFit(X, design)
fit2 &lt;- eBayes(fit1)
topTable(fit2, coef = 1, number = Inf, confint = TRUE, sort.by = "none")[,-4]

## Two-sample test
set.seed(123)
X &lt;- rbind(matrix(rnorm(5*20), nrow = 5, ncol = 20),
           matrix(rnorm(5*20, mean = 1), nrow = 5, ncol = 20))
g2 &lt;- factor(c(rep("group 1", 10), rep("group 2", 10)))

mod.t.test(X, group = g2)
## corresponds to
design &lt;- model.matrix(~ 0 + g2)
colnames(design) &lt;- c("group1", "group2")
fit1 &lt;- lmFit(X, design)
cont.matrix &lt;- makeContrasts(group1vsgroup2="group1-group2", levels=design)
fit2 &lt;- contrasts.fit(fit1, cont.matrix)
fit3 &lt;- eBayes(fit2)
topTable(fit3, coef = 1, number = Inf, confint = TRUE, sort.by = "none")[,-4]

## Paired two-sample test
subjID &lt;- factor(rep(1:10, 2))
mod.t.test(X, group = g2, paired = TRUE, subject = subjID)
</code></pre>

<hr>
<h2 id='oneWayAnova'> A function for Analysis of Variance </h2><span id='topic+oneWayAnova'></span>

<h3>Description</h3>

<p>This function is a slight modification of function <code>Anova</code> of
package <span class="pkg">genefilter</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneWayAnova(cov, na.rm = TRUE, var.equal = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneWayAnova_+3A_cov">cov</code></td>
<td>
<p> The covariate. It must have length equal to the number of
columns of the array that the result of <code>oneWayAnova</code> will be 
applied to. </p>
</td></tr>
<tr><td><code id="oneWayAnova_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical value indicating whether <code>NA</code> values should be
stripped before the computation proceeds. </p>
</td></tr>
<tr><td><code id="oneWayAnova_+3A_var.equal">var.equal</code></td>
<td>
<p> a logical variable indicating whether to treat the variances
in the samples as equal.  If <code>TRUE</code>, then a simple F test for
the equality of means in a one-way analysis of variance is
performed.  If <code>FALSE</code>, an approximate method of Welch (1951)
is used, which generalizes the commonly known 2-sample Welch
test to the case of arbitrarily many samples. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returned by <code>oneWayAnova</code> uses <code><a href="stats.html#topic+oneway.test">oneway.test</a></code> 
to perform a one-way ANOVA, where <code>x</code> is the set of gene expressions. 
The F statistic for an overall effect is computed and the corresponding
p-value is returned.
</p>
<p>The function <code>Anova</code> of package <span class="pkg">genefilter</span> instead compares the computed 
p-value to a prespecified p-value and returns <code>TRUE</code>, if the computed p-value
is smaller than the prespecified one.
</p>


<h3>Value</h3>

<p><code>oneWayAnova</code> returns a function with bindings for <code>cov</code> that will
perform a one-way ANOVA.
</p>
<p>The covariate can be continuous, in which case the test is for a linear effect 
for the covariate.
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>R. Gentleman, V. Carey, W. Huber and F. Hahne (2006). 
genefilter: methods for filtering genes from microarray experiments. 
R package version 1.13.7.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+oneway.test">oneway.test</a></code>, <code><a href="#topic+twoWayAnova">twoWayAnova</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
af &lt;- oneWayAnova(c(rep(1,5),rep(2,5)))
af(rnorm(10))
</code></pre>

<hr>
<h2 id='pairwise.fc'> Compute pairwise fold changes </h2><span id='topic+pairwise.fc'></span>

<h3>Description</h3>

<p>This function computes pairwise fold changes. It also works for 
logarithmic data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.fc(x, g, ave = mean, log = TRUE, base = 2, mod.fc = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.fc_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_ave">ave</code></td>
<td>
<p> function to compute the group averages. </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_log">log</code></td>
<td>
<p> logical. Is the data logarithmic? </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_base">base</code></td>
<td>
<p> If <code>log = TRUE</code>, the base which was used to compute
the logarithms. </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_mod.fc">mod.fc</code></td>
<td>
<p> logical. Return modified fold changes? (see details) </p>
</td></tr>
<tr><td><code id="pairwise.fc_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>ave</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise fold changes between groups, where
the group values are aggregated using the function which is 
given by the argument <code>ave</code>.
</p>
<p>The fold changes are returned in a slightly modified form if mod.fc = TRUE. 
Fold changes <code>FC</code> which are smaller than <code>1</code> are reported as
to <code>-1/FC</code>.
</p>
<p>The implementation is in certain aspects analogously to <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>


<h3>Value</h3>

<p>Vector with pairwise fold changes.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100) ## assumed as log2-data
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.fc(x, g)

## some small checks
res &lt;- by(x, list(g), mean)
2^(res[[1]] - res[[2]]) # a vs. b
-1/2^(res[[1]] - res[[3]]) # a vs. c
2^(res[[1]] - res[[4]]) # a vs. d
-1/2^(res[[2]] - res[[3]]) # b vs. c
-1/2^(res[[2]] - res[[4]]) # b vs. d
2^(res[[3]] - res[[4]]) # c vs. d
</code></pre>

<hr>
<h2 id='pairwise.logfc'> Compute pairwise log-fold changes </h2><span id='topic+pairwise.logfc'></span>

<h3>Description</h3>

<p>The function computes pairwise log-fold changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.logfc(x, g, ave = mean, log = TRUE, base = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.logfc_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="pairwise.logfc_+3A_g">g</code></td>
<td>
<p> grouping vector or factor </p>
</td></tr>
<tr><td><code id="pairwise.logfc_+3A_ave">ave</code></td>
<td>
<p> function to compute the group averages. </p>
</td></tr>
<tr><td><code id="pairwise.logfc_+3A_log">log</code></td>
<td>
<p> logical. Is the data logarithmic? </p>
</td></tr>
<tr><td><code id="pairwise.logfc_+3A_base">base</code></td>
<td>
<p> If <code>log = TRUE</code>, the base which was used to compute
the logarithms. </p>
</td></tr>
<tr><td><code id="pairwise.logfc_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>ave</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes pairwise log-fold changes between groups, where
the group values are aggregated using the function which is 
given by the argument <code>ave</code>.
</p>
<p>The implementation is in certain aspects analogously to <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>


<h3>Value</h3>

<p>Vector with pairwise log-fold changes.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
x &lt;- rnorm(100) ## assumed as log2-data
g &lt;- factor(sample(1:4, 100, replace = TRUE))
levels(g) &lt;- c("a", "b", "c", "d")
pairwise.logfc(x, g)

## some small checks
res &lt;- by(x, list(g), mean)
res[[1]] - res[[2]] # a vs. b
res[[1]] - res[[3]] # a vs. c
res[[1]] - res[[4]] # a vs. d
res[[2]] - res[[3]] # b vs. c
res[[2]] - res[[4]] # b vs. d
res[[3]] - res[[4]] # c vs. d
</code></pre>

<hr>
<h2 id='pairwise.mod.t.test'>Pairwise Moderated t-Tests</h2><span id='topic+pairwise.mod.t.test'></span>

<h3>Description</h3>

<p>Performs pairwise moderated t-tests (unpaired) based on Bioconductor package 
limma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.mod.t.test(x, group, adjust.method = "BH", sort.by = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.mod.t.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric matrix of data values.</p>
</td></tr>
<tr><td><code id="pairwise.mod.t.test_+3A_group">group</code></td>
<td>
<p>an optional factor representing the groups.</p>
</td></tr>
<tr><td><code id="pairwise.mod.t.test_+3A_adjust.method">adjust.method</code></td>
<td>
<p>see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
<tr><td><code id="pairwise.mod.t.test_+3A_sort.by">sort.by</code></td>
<td>
<p>see <code><a href="limma.html#topic+toptable">toptable</a></code></p>
</td></tr></table>
<p>, where <code>"logFC"</code>
corresponds to difference in means.
</p>


<h3>Details</h3>

<p>The function uses Bioconductor package limma to compute pairwise moderated
t-tests. For more details we refer to <code><a href="limma.html#topic+ebayes">ebayes</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame with the results.
</p>


<h3>References</h3>

<p>Ritchie, M.E., Phipson, B., Wu, D., Hu, Y., Law, C.W., Shi, W., and Smyth, G.K.
(2015). limma powers differential expression analyses for RNA-sequencing and
microarray studies. <em>Nucleic Acids Research</em> 43(7), e47.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+oneway.test">oneway.test</a></code>, <code>mod.t.test</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
X &lt;- rbind(matrix(rnorm(5*20), nrow = 5, ncol = 20),
           matrix(rnorm(5*20, mean = 1), nrow = 5, ncol = 20))
gr &lt;- factor(c(rep("A1", 5), rep("B2", 5), rep("C3", 5), rep("D4", 5)))
mod.oneway.test(X, gr)
pairwise.mod.t.test(X, gr)
</code></pre>

<hr>
<h2 id='repMeans'> Compute mean of replicated spots </h2><span id='topic+repMeans'></span>

<h3>Description</h3>

<p>Compute mean of replicated spots where additionally spot flags may incorporated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repMeans(x, flags, use.flags = NULL, ndups, spacing, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repMeans_+3A_x">x</code></td>
<td>
<p> matrix or data.frame of expression values </p>
</td></tr>
<tr><td><code id="repMeans_+3A_flags">flags</code></td>
<td>
<p> matrix or data.frame of spot flags; must have same dimension as <code>x</code> </p>
</td></tr>
<tr><td><code id="repMeans_+3A_use.flags">use.flags</code></td>
<td>
<p> should flags be included and in which way; cf. section details </p>
</td></tr>
<tr><td><code id="repMeans_+3A_ndups">ndups</code></td>
<td>
<p> integer, number of replicates on chip. The number of rows of 
<code>x</code> must be divisible by <code>ndups</code> </p>
</td></tr>
<tr><td><code id="repMeans_+3A_spacing">spacing</code></td>
<td>
<p> the spacing between the rows of 'x' corresponding to 
replicated spots, <code>spacing = 1</code> for consecutive spots; 
cf. function <code><a href="limma.html#topic+unwrapdups">unwrapdups</a></code> in package 
<code>"limma"</code> </p>
</td></tr>
<tr><td><code id="repMeans_+3A_method">method</code></td>
<td>
<p> function to aggregate the replicated spots. If missing, the mean is used. </p>
</td></tr>
<tr><td><code id="repMeans_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>method</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The incorporation of spot flags is controlled via argument <code>use.flags</code>.
</p>
<p><code>NULL</code>: flags are not used; minimum flag value of replicated 
spots is returned
</p>
<p><code>"max"</code>: only spots with flag value equal to the maximum flag value of 
replicated spots are used
</p>
<p><code>"median"</code>: only spots with flag values larger or equal to median of 
replicated spots are used
</p>
<p><code>"mean"</code>: only spots with flag values larger or equal to mean of replicated 
spots are used  
</p>


<h3>Value</h3>

<p>LIST with components
</p>
<table>
<tr><td><code>exprs</code></td>
<td>
<p>mean of expression values</p>
</td></tr>
<tr><td><code>flags</code></td>
<td>
<p>flags for mean expression values</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="limma.html#topic+unwrapdups">unwrapdups</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
M &lt;- matrix(rnorm(1000), ncol = 10)
FL &lt;- matrix(rpois(1000, lambda = 10), ncol = 10) # only for this example
res &lt;- repMeans(x = M, flags = FL, use.flags = "max", ndups = 5, spacing = 20)
</code></pre>

<hr>
<h2 id='simPlot'> Plot of a similarity matrix. </h2><span id='topic+simPlot'></span><span id='topic+simPlot2'></span>

<h3>Description</h3>

<p>Plot of similarity matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPlot(x, col, minVal, labels = FALSE, lab.both.axes = FALSE, 
        labcols = "black", title = "", cex.title = 1.2, 
        protocol = FALSE, cex.axis = 0.8, 
        cex.axis.bar = 1, signifBar = 2, ...)
        
simPlot2(x, col, minVal, labels = FALSE, 
         row.width = 6, column.height = 6, lab.both.axes = TRUE, 
         fontsize.axis = 12, title = "", fontsize.title = 16, 
         signifBar = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPlot_+3A_x">x</code></td>
<td>
<p> quadratic data matrix. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_col">col</code></td>
<td>
<p> colors palette for image. If missing, the <code>RdYlGn</code> palette
of <code>RColorBrewer</code> is used. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_minval">minVal</code></td>
<td>
<p> numeric, minimum value which is display by a color; used to adjust <code>col</code></p>
</td></tr>
<tr><td><code id="simPlot_+3A_labels">labels</code></td>
<td>
<p> vector of character strings to be placed at the tickpoints,
labels for the columns of <code>x</code>. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_lab.both.axes">lab.both.axes</code></td>
<td>
<p> logical, display labels on both axes </p>
</td></tr>
<tr><td><code id="simPlot_+3A_labcols">labcols</code></td>
<td>
<p> colors to be used for the labels of the columns of <code>x</code>.
<code>labcols</code> can have either length 1, in which case all 
the labels are displayed using the same color, or the same 
length as <code>labels</code>, in which case a color is specified 
for the label of each column of <code>x</code>. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_title">title</code></td>
<td>
<p> character string, overall title for the plot. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_cex.title">cex.title</code></td>
<td>
<p> A numerical value giving the amount by which plotting text
and symbols should be magnified relative to the default;
cf. <code><a href="graphics.html#topic+par">par</a></code>, <code>cex.main</code>. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_fontsize.title">fontsize.title</code></td>
<td>
<p> numerical value giving the fontsize of the title. </p>
</td></tr>
<tr><td><code id="simPlot_+3A_protocol">protocol</code></td>
<td>
<p> logical, display color bar without numbers </p>
</td></tr>
<tr><td><code id="simPlot_+3A_cex.axis">cex.axis</code></td>
<td>
<p> The magnification to be used for axis annotation relative to the 
current setting of 'cex'; cf. <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_fontsize.axis">fontsize.axis</code></td>
<td>
<p> numerical value giving the fontsize of the axis labels.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_cex.axis.bar">cex.axis.bar</code></td>
<td>
<p> The magnification to be used for axis annotation of the color 
bar relative to the current setting of 'cex'; cf. 
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_signifbar">signifBar</code></td>
<td>
<p> integer indicating the precision to be used for the bar.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_row.width">row.width</code></td>
<td>
<p> numerical value giving width of the row in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_column.height">column.height</code></td>
<td>
<p> numerical value giving the height of the column in centimeters; i.e., 
can be used to change space available for the labels.</p>
</td></tr>
<tr><td><code id="simPlot_+3A_...">...</code></td>
<td>
<p> graphical parameters may also be supplied as arguments to the
function (see <code><a href="graphics.html#topic+par">par</a></code>). For comparison purposes, 
it is good to set <code>zlim=c(-1,1)</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions generates a so called similarity matrix. 
</p>
<p>If <code>min(x)</code> is smaller than <code>minVal</code>, the colors in <code>col</code> are 
adjusted such that the minimum value which is color coded is equal to <code>minVal</code>.
</p>


<h3>Value</h3>

<p><code>invisible()</code>
</p>


<h3>Note</h3>

<p>The function is a slight modification of function <code><a href="#topic+corPlot">corPlot</a></code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Sandrine Dudoit, Yee Hwa (Jean) Yang, Benjamin Milo Bolstad and with 
contributions from Natalie Thorne, Ingrid Loennstedt and Jessica Mar.
sma: Statistical Microarray Analysis.<br />
http://www.stat.berkeley.edu/users/terry/zarray/Software/smacode.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## only a dummy example
M &lt;- matrix(rnorm(1000), ncol = 20)
colnames(M) &lt;- paste("Sample", 1:20)
M.cor &lt;- cor(M)

simPlot(M.cor, minVal = min(M.cor))
simPlot(M.cor, minVal = min(M.cor), lab.both.axes = TRUE)
simPlot(M.cor, minVal = min(M.cor), protocol = TRUE)
simPlot(M.cor, minVal = min(M.cor), signifBar = 1)

simPlot2(M.cor, minVal = min(M.cor))
simPlot2(M.cor, minVal = min(M.cor), lab.both.axes = FALSE)
simPlot2(M.cor, minVal = min(M.cor), signifBar = 1)
</code></pre>

<hr>
<h2 id='stringDist'>Function to compute distances between strings</h2><span id='topic+stringDist'></span>

<h3>Description</h3>

<p>The function can be used to compute distances between strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringDist(x, y, method = "levenshtein", mismatch = 1, gap = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringDist_+3A_x">x</code></td>
<td>
<p>character vector, first string</p>
</td></tr>
<tr><td><code id="stringDist_+3A_y">y</code></td>
<td>
<p>character vector, second string</p>
</td></tr>
<tr><td><code id="stringDist_+3A_method">method</code></td>
<td>
<p>character, name of the distance method. This must be 
<code>"levenshtein"</code> or <code>"hamming"</code>. Default is the classical
Levenshtein distance.</p>
</td></tr>
<tr><td><code id="stringDist_+3A_mismatch">mismatch</code></td>
<td>
<p>numeric, distance value for a mismatch between symbols</p>
</td></tr>
<tr><td><code id="stringDist_+3A_gap">gap</code></td>
<td>
<p>numeric, distance value for inserting a gap</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the Hamming and the Levenshtein (edit) distance of two given strings
(sequences). 
</p>
<p>In case of the Hamming distance the two strings must have the same length.
</p>
<p>In case of the Levenshtein (edit) distance a scoring and a trace-back matrix are computed
and are saved as attributes <code>"ScoringMatrix"</code> and <code>"TraceBackMatrix"</code>. 
The characters in the trace-back matrix reflect insertion of a gap in string <code>y</code> 
(<code>d</code>: deletion), match (<code>m</code>), mismatch (<code>mm</code>), 
and insertion of a gap in string <code>x</code> (<code>i</code>).
</p>


<h3>Value</h3>

<p><code>stringDist</code> returns an object of S3 class <code>"stringDist"</code> inherited 
from class <code>"dist"</code>; cf. <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Note</h3>

<p>The function is mainly for teaching purposes.
</p>
<p>For distances between strings and string alignments see also Bioconductor package
<span class="pkg">Biostrings</span>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> </p>


<h3>References</h3>

<p>R. Merkl and S. Waack (2009). Bioinformatik Interaktiv. Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+stringSim">stringSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "GACGGATTATG"
y &lt;- "GATCGGAATAG"
## Levenshtein distance
d &lt;- stringDist(x, y)
d
attr(d, "ScoringMatrix")
attr(d, "TraceBackMatrix")

## Hamming distance
stringDist(x, y)
</code></pre>

<hr>
<h2 id='stringSim'>Function to compute similarity scores between strings</h2><span id='topic+stringSim'></span>

<h3>Description</h3>

<p>The function can be used to compute similarity scores between strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringSim(x, y, global = TRUE, match = 1, mismatch = -1, gap = -1, minSim = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringSim_+3A_x">x</code></td>
<td>
<p>character vector, first string</p>
</td></tr>
<tr><td><code id="stringSim_+3A_y">y</code></td>
<td>
<p>character vector, second string</p>
</td></tr>
<tr><td><code id="stringSim_+3A_global">global</code></td>
<td>
<p>logical; global or local alignment</p>
</td></tr>
<tr><td><code id="stringSim_+3A_match">match</code></td>
<td>
<p>numeric, score for a match between symbols</p>
</td></tr>
<tr><td><code id="stringSim_+3A_mismatch">mismatch</code></td>
<td>
<p>numeric, score for a mismatch between symbols</p>
</td></tr>
<tr><td><code id="stringSim_+3A_gap">gap</code></td>
<td>
<p>numeric, penalty for inserting a gap</p>
</td></tr>
<tr><td><code id="stringSim_+3A_minsim">minSim</code></td>
<td>
<p>numeric, used as required minimum score in case of local alignments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes optimal alignment scores for global (Needleman-Wunsch) 
and local (Smith-Waterman) alignments with constant gap penalties. 
</p>
<p>Scoring and trace-back matrix are computed and saved in form of attributes 
<code>"ScoringMatrix"</code> and <code>"TraceBackMatrix"</code>. 
The characters in the trace-back matrix reflect insertion of a gap in 
string <code>y</code> (<code>d</code>: deletion), match (<code>m</code>), mismatch (<code>mm</code>), 
and insertion of a gap in string <code>x</code> (<code>i</code>). In addition <code>stop</code>
indicates that the minimum similarity score has been reached.
</p>


<h3>Value</h3>

<p><code>stringSim</code> returns an object of S3 class <code>"stringSim"</code> inherited 
from class <code>"dist"</code>; cf. <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Note</h3>

<p>The function is mainly for teaching purposes.
</p>
<p>For distances between strings and string alignments see also Bioconductor package
<span class="pkg">Biostrings</span>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> </p>


<h3>References</h3>

<p>R. Merkl and S. Waack (2009). Bioinformatik Interaktiv. Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+stringDist">stringDist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "GACGGATTATG"
y &lt;- "GATCGGAATAG"

## optimal global alignment score
d &lt;- stringSim(x, y)
d
attr(d, "ScoringMatrix")
attr(d, "TraceBackMatrix")

## optimal local alignment score
d &lt;- stringSim(x, y, global = FALSE)
d
attr(d, "ScoringMatrix")
attr(d, "TraceBackMatrix")
</code></pre>

<hr>
<h2 id='traceBack'>
Function to trace back
</h2><span id='topic+traceBack'></span>

<h3>Description</h3>

<p>Function computes an optimal global or local alignment based on a trace back
matrix as provided by function <code><a href="#topic+stringDist">stringDist</a></code> or <code><a href="#topic+stringSim">stringSim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceBack(D, global = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceBack_+3A_d">D</code></td>
<td>
<p>object of class <code>"stringDist"</code></p>
</td></tr>
<tr><td><code id="traceBack_+3A_global">global</code></td>
<td>
<p>logical,  global or local alignment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes one possible optimal global or local alignment based on the trace back
matrix saved in an object of class <code>"stringDist"</code> or <code>"stringSim"</code>.
</p>


<h3>Value</h3>

<p>matrix: pairwise global/local alignment</p>


<h3>Note</h3>

<p>The function is mainly for teaching purposes.
</p>
<p>For distances between strings and string alignments see Bioconductor package
<span class="pkg">Biostrings</span>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>R. Merkl and S. Waack (2009). Bioinformatik Interaktiv. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stringDist">stringDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "GACGGATTATG"
y &lt;- "GATCGGAATAG"

## Levenshtein distance
d &lt;- stringDist(x, y)
## optimal global alignment
traceBack(d)

## Optimal global alignment score
d &lt;- stringSim(x, y)
## optimal global alignment
traceBack(d)

## Optimal local alignment score
d &lt;- stringSim(x, y, global = FALSE)
## optimal local alignment
traceBack(d, global = FALSE)
</code></pre>

<hr>
<h2 id='twoWayAnova'> A function for Analysis of Variance </h2><span id='topic+twoWayAnova'></span>

<h3>Description</h3>

<p>This function is a slight modification of function <code>Anova</code> of
package <span class="pkg">genefilter</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoWayAnova(cov1, cov2, interaction, na.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoWayAnova_+3A_cov1">cov1</code></td>
<td>
<p> The first covariate. It must have length equal to the number of
columns of the array that the result of <code>twoWayAnova</code> will be 
applied to. </p>
</td></tr>
<tr><td><code id="twoWayAnova_+3A_cov2">cov2</code></td>
<td>
<p> The second covariate. It must have length equal to the number of
columns of the array that the result of <code>twoWayAnova</code> will be 
applied to. </p>
</td></tr>
<tr><td><code id="twoWayAnova_+3A_interaction">interaction</code></td>
<td>
<p> logical, should interaction be considered </p>
</td></tr>
<tr><td><code id="twoWayAnova_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical value indicating whether 'NA' values should be
stripped before the computation proceeds. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returned by <code>twoWayAnova</code> uses <code><a href="stats.html#topic+lm">lm</a></code> to fit 
a linear model of the form <code>lm(x ~ cov1*cov2)</code>, where <code>x</code> is the set 
of gene expressions. The F statistics for the main effects and the interaction are  
computed and the corresponding p-values are returned.
</p>


<h3>Value</h3>

<p><code>twoWayAnova</code> returns a function with bindings for <code>cov1</code> and 
<code>cov2</code>that will perform a two-way ANOVA.
</p>


<h3>Note</h3>

<p>A first version of this function appeared in package SLmisc.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>R. Gentleman, V. Carey, W. Huber and F. Hahne (2006). 
genefilter: methods for filtering genes from microarray experiments. 
R package version 1.13.7.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+oneWayAnova">oneWayAnova</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
af1 &lt;- twoWayAnova(c(rep(1,6),rep(2,6)), rep(c(rep(1,3), rep(2,3)), 2))
af2 &lt;- twoWayAnova(c(rep(1,6),rep(2,6)), rep(c(rep(1,3), rep(2,3)), 2), 
                   interaction = FALSE)
x &lt;- matrix(rnorm(12*10), nrow = 10)
apply(x, 1, af1)
apply(x, 1, af2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
