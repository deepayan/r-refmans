<!DOCTYPE html><html lang="en"><head><title>Help for package mvbutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvbutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvbutils-package'><p>How to use the mvbutils package</p></a></li>
<li><a href='#add.flatdoc.to'><p>Skeletal flat-format documentation</p></a></li>
<li><a href='#cd'><p>Organizing R workspaces</p></a></li>
<li><a href='#cdfind'><p>Hierarchy-crawling functions for cd-organized workspaces</p></a></li>
<li><a href='#cdprompt'><p>Support routine for cd-organized workspace hierarchy.</p></a></li>
<li><a href='#changed.funs'><p>Show functions and callees in environment 'egood' that have changed or disappeared in environment 'ebad'.</p></a></li>
<li><a href='#check.patch.versions'><p>Check consistency of maintained package versions</p></a></li>
<li><a href='#ditto.list'><p>Shorthand filler-inner for lists</p></a></li>
<li><a href='#do.in.envir'><p>Modify a function's scope</p></a></li>
<li><a href='#do.on'><p>Easier sapply/lapply avoiding explicit function</p></a></li>
<li><a href='#doc2Rd'><p>Converts plain-text documentation to Rd format</p></a></li>
<li><a href='#dochelp'><p>Documentation (informal help)</p></a></li>
<li><a href='#dont.lock.me'><p>Prevent sealing of a namespace, to facilitate package maintenance.</p></a></li>
<li><a href='#dont.lockBindings'><p>Helper for live-editing of packages</p></a></li>
<li><a href='#extract.named'><p>Create variables from corresponding named list elements</p></a></li>
<li><a href='#fast.read.fwf'><p>Read in fixed-width files quickly</p></a></li>
<li><a href='#find.documented'><p>Support for flat-format documentation</p></a></li>
<li><a href='#fix.order'><p>Shows functions sorted by date of edit</p></a></li>
<li><a href='#fixr'><p>Editing functions, text objects, and scriptlets</p></a></li>
<li><a href='#flatdoc'><p>Flat-format documentation</p></a></li>
<li><a href='#foodweb'><p>Shows which functions call what</p></a></li>
<li><a href='#full.path'><p>Expand relative file path</p></a></li>
<li><a href='#generic.dll.loader'><p>Convenient automated loading of DLLs</p></a></li>
<li><a href='#get.backup'><p>Text backups of function source code</p></a></li>
<li><a href='#hack'><p>Modify standard R functions, including tweaking their default arguments</p></a></li>
<li><a href='#help'><p>The R help system</p></a></li>
<li><a href='#help2flatdoc'><p>Convert help files to flatdoc format.</p></a></li>
<li><a href='#install.pkg'><p>Package building, distributing, and checking</p></a></li>
<li><a href='#library.dynam.reg'><p>Auto-registration and loading of dynamic library</p></a></li>
<li><a href='#load.refdb'><p>Cacheing objects for lazy-load access</p></a></li>
<li><a href='#local.on.exit'><p>Macro-like functions</p></a></li>
<li><a href='#local.return'><p>Macro-like functions</p></a></li>
<li><a href='#localfuncs'><p>&quot;Declare&quot; child functions, allowing much tidier code</p></a></li>
<li><a href='#lsize'><p>Report objects and their memory sizes</p></a></li>
<li><a href='#maintain.packages'><p>Set up task package for live editing</p></a></li>
<li><a href='#make_dull'><p>Hide dull columns in data frames</p></a></li>
<li><a href='#make.NAMESPACE'><p>Auto-create a NAMESPACE file</p></a></li>
<li><a href='#make.usage.section'><p>Construct sections of documentation</p></a></li>
<li><a href='#max_pkg_ver'><p>Max package version</p></a></li>
<li><a href='#mcut'><p>Put reals and integers into specified bins, returning factors.</p></a></li>
<li><a href='#mlazy'><p>Cacheing objects for lazy-load access</p></a></li>
<li><a href='#mlocal'><p>Macro-like functions</p></a></li>
<li><a href='#move'><p>Organizing R workspaces</p></a></li>
<li><a href='#multirep'><p>Replacement and insertion functions with more/less than 1 replacement per spot</p></a></li>
<li><a href='#mvb.sys.parent'><p>Functions to Access the Function Call Stack</p></a></li>
<li><a href='#mvbutils.operators'><p>Utility operators</p></a></li>
<li><a href='#mvbutils.packaging.tools'><p>How to create &amp; maintain packages with mvbutils</p></a></li>
<li><a href='#mvbutils.utils'><p>Miscellaneous utilities</p></a></li>
<li><a href='#my.index'><p>Arbitrary-level retrieval from and modification of recursive objects</p></a></li>
<li><a href='#NEG'><p>Generate a negated version of your function. Useful for 'nlminb' etc.</p></a></li>
<li><a href='#noice'><p>Prints a call object nicely</p></a></li>
<li><a href='#pre.install'><p>Update a source and/or installed package from a task package</p></a></li>
<li><a href='#print'><p>Print values</p></a></li>
<li><a href='#rbdf'><p>Data frames: better behaviour with zero-length cases</p></a></li>
<li><a href='#readLines.mvb'><p>Read text lines from a connection</p></a></li>
<li><a href='#rm.pkg'><p>Remove object(s) from maintained package</p></a></li>
<li><a href='#Save'><p>Save R objects</p></a></li>
<li><a href='#search.for.regexpr'><p>Find functions/objects/flatdoc-documentation containing a regexp.</p></a></li>
<li><a href='#search.task.trees'><p>Locate loaded tasks on search path.</p></a></li>
<li><a href='#set.finalizer'><p>Obsolete but automatic finalization for persistent objects created in C.</p></a></li>
<li><a href='#set.presave.hook.mvb'><p>Do something-or-other</p></a></li>
<li><a href='#setup.mcache'><p>Cacheing objects for lazy-load access</p></a></li>
<li><a href='#sleuth'><p>Generalized version of find</p></a></li>
<li><a href='#source.mvb'><p>Read R code and data from a file or connection</p></a></li>
<li><a href='#strip.missing'><p>Exclude &quot;missing&quot; objects</p></a></li>
<li><a href='#task.home'><p>Organizing R workspaces</p></a></li>
<li><a href='#unpackage'><p>Convert existing source package into task package</p></a></li>
<li><a href='#warn.and.subset'><p>Extract subset and warn about omitted cases</p></a></li>
<li><a href='#write.sourceable.function'><p>Sourceable code for functions (and more) with flat-format documentation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.8.232</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark V. Bravington &lt;mark.bravington@csiro.au&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark V. Bravington &lt;mark.bravington@csiro.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, tools, stats, graphics</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-12-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Workspace Organization, Code and Documentation Editing, Package
Prep and Editing, Etc</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Hierarchical workspace tree, code editing and backup, easy package prep, editing of packages while loaded, per-object lazy-loading, easy documentation, macro functions, and miscellaneous utilities. Needed by debug package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-12 11:36:05 UTC; bra381</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-12 15:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvbutils-package'>How to use the mvbutils package</h2><span id='topic+mvbutils'></span><span id='topic+mvbutils-package'></span>

<h3>Description</h3>

<p>Package <span class="pkg">mvbutils</span> is a collection of utilities offering the following main features:
</p>

<ul>
<li><p> Hierarchical organization of projects (AKA tasks) and sub-tasks, allowing switching within a single R session, searching and moving objects through the hierarchy, objects in ancestor tasks always visible from child (sub)tasks, etc. See <code><a href="#topic+cd">cd</a></code>.
</p>
</li>
<li><p> Improved function, text, and script editing facilities, interfacing with whichever text editor you prefer. The R command line is not frozen while editing, and you can have multiple edit windows open. Scriptlets can be edited as expressions, for subsequent calls to <code>eval</code>. Function documentation can be stored as plain text after the function definition, and will be found by <code><a href="#topic+help">help</a></code> even if the function isn't part of a package. There is also a complete automatic text-format backup system for functions &amp; text. See <code><a href="#topic+fixr">fixr</a></code>.
</p>
</li>
<li><p> Automated package construction, including production of Rd-format from plain text documentation. Packages can be edited &amp; updated while loaded, without needing to quit/rebuild/reinstall. See <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>.
</p>
</li>
<li><p> &quot;Lazy loading&quot; for individual objects, allowing fast and transparent access to collections of biggish objects where only a few objects are used at a time. See <code><a href="#topic+mlazy">mlazy</a></code>.
</p>
</li>
<li><p> Miscellaneous goodies: local/nested functions (<code><a href="#topic+mlocal">mlocal</a></code>), display of what-calls-what (<code><a href="#topic+foodweb">foodweb</a></code>), multiple replacement (<code><a href="#topic+multirep">multirep</a></code>), nicely-formatted latex tables (<code>xtable.mvb</code>), numerous lower-level lower-level utility functions and operators (<code><a href="#topic+mvbutils.utils">mvbutils.utils</a></code>, <code><a href="#topic+mvbutils.operators">mvbutils.operators</a></code>, <code><a href="#topic+extract.named">extract.named</a></code>, <code><a href="#topic+mcut">mcut</a></code>, <code><a href="#topic+search.for.regexpr">search.for.regexpr</a></code>, <code><a href="#topic+strip.missing">strip.missing</a></code>, <code><a href="#topic+FOR">FOR</a></code> )
</p>
</li></ul>

<p>To get the full features of the <span class="pkg">mvbutils</span> package&ndash; in particular, the project organization&ndash; you need to start R in the same directory every time (your &quot;ROOT task&quot;), and then switch to whichever project from inside R; see <code><a href="#topic+cd">cd</a></code>. Various <code>options</code> always need to be set to make <code><a href="#topic+fixr">fixr</a></code> and the <span class="pkg">debug</span> package work the way you want, so one advantage of the start-in-the-same directory-approach is that you can keep all your project-independent <code>options()</code>, library loads, etc., in a single <code>.First</code> function or &quot;.Rprofile&quot; file, to be called automatically when you start R. However, many features (including support for the <span class="pkg">debug</span> package) will work even if you don't follow this suggestion.
</p>
<p>The remaining sections of this document cover details that most users don't know about; there's no need to read them when you are just starting out with <code>mvbutils</code>.
</p>


<h3>Housekeeping info</h3>

<p>On loading, the <span class="pkg">mvbutils</span> package creates a new environment in the search path, called <code>mvb.session.info</code>, which stores some housekeeping information. <code>mvb.session.info</code> is never written to disk, and disappears when the R session finishes. [For Splus users: <code>mvb.session.info</code> is similar to frame 0.] You should never change anything in <code>mvb.session.info</code> by hand, but it is sometimes useful to look at some of the variables there:
</p>

<ul>
<li> <p><code>.First.top.search</code> is the directory R started in (your ROOT task).
</p>
</li>
<li> <p><code>.Path</code> shows the currently-attached part of the task hierarchy.
</p>
</li>
<li> <p><code>base.xxx</code> is the original copy of an overwritten system function, e.g. <code>library</code>
</p>
</li>
<li> <p><code>fix.list</code> keeps track of objects being edited via <code><a href="#topic+fixr">fixr</a></code>
</p>
</li>
<li> <p><code>session.start.time</code> is the value of <code>Sys.time()</code> when <code>mvbutils</code> was loaded
</p>
</li>
<li> <p><code>source.list</code> is used by <code><a href="#topic+source.mvb">source.mvb</a></code> to allow nesting of sources
</p>
</li>
<li> <p><code>r.window.handle</code> is used by the <span class="pkg">handy</span> package (Windows only)
</p>
</li>
<li> <p><code>partial.namespaces</code> is used to alleviate difficulties with unloadable data files&ndash; see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>
</p>
</li>
<li><p> things whose name starts with &quot;..&quot; are environments used in live-editing packages
</p>
</li>
<li> <p><code>maintained.packages</code> is a list of the latter
</p>
</li></ul>



<h3>Redefined functions</h3>

<p>On loading, package <span class="pkg">mvbutils</span> redefines a few system functions: <code>lockEnvironment</code>, <code>importIntoEnv</code> <code>loadNamespace</code>, <code><a href="#topic+print.function">print.function</a></code>, <code><a href="#topic+help">help</a></code>, <code><a href="#topic+rbind.data.frame">rbind.data.frame</a></code> and, by default, <code>library</code>, <code>savehistory</code>, <code>loadhistory</code>, and <code>save.image</code>. (The original version of routine <code>xxx</code> can always be obtained via <code>base.xxx</code> if you really need it.) The modifications, which are undone when you unload <code>mvbutils</code>, should have [almost] no side-effects. Briefly:
</p>

<ul>
<li> <p><code>library</code> is modified so that its default <code><a href="#topic+pos">pos</a></code> argument is just under the ROOT workspace (the one that was on top when <code>mvbutils</code> was loaded), which is needed by <code><a href="#topic+cd">cd</a></code>. This means that packages no longer get attached by default always in position 2.
</p>
</li>
<li> <p><code>lockEnvironment</code> and <code>importIntoEnv</code> are modified to allow live-editing of your own maintained packages&ndash; no change to default behaviour.
</p>
</li>
<li> <p><code>loadNamespace</code> has the default value of its &quot;partial&quot; argument altered, to let you bypass <code>.onLoad</code> for selected faulty packages&ndash; see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code> and look for <code>partial.namespaces</code>. This allows the loading of certain &quot;.RData&quot; files which otherwise crash from hidden attempts to load a namespace. It lets you get round some truly horrendous problems arising from faults with 3rd-party packages, as well as problems when you stuff up your own packages.
</p>
</li>
<li> <p><code><a href="#topic+rbind.data.frame">rbind.data.frame</a></code> does not ignore zero-row arguments (so it takes account of their factor levels, for example).
</p>
</li>
<li> <p><code><a href="#topic+rbind.data.frame">rbind.data.frame</a></code>: dimensioned elements (i.e. matrices &amp; arrays within data.frames) no longer have any extra attributes removed. Hence, for example, you can (if you are also using my <code>nicetime</code> package) <code><a href="#topic+rbind">rbind</a></code> two data frames that both have POSIXct-matrix elements without turning them into raw seconds and losing timezones.
</p>
</li>
<li> <p><code><a href="#topic+help">help</a></code> and <code>?</code> are modified so that, if <code>utils:::help</code> can't find help for a function (but not a method, dataset, or package), it will look instead for a <code>doc</code> attribute of the function to display in a pager/browser using <code><a href="#topic+dochelp">dochelp</a></code>. Character objects with a &quot;.doc&quot; extension will also be found and displayed. This lets you write and distribute &quot;informal help&quot;.
</p>
</li>
<li> <p><code>loadhistory</code> and <code>savehistory</code> are modified so that they use the <em>current</em> &quot;R_HISTFILE&quot; environment variable if it set. This can be set dynamically during an R session using <code>Sys.setenv</code>. Standard R behaviour is to respect &quot;R_HISTFILE&quot; iff it is set <em>before</em> the R session starts, but not to track it during a session. If &quot;R_HISTFILE&quot; is not set, then <code><a href="#topic+cd">cd</a></code> will on first use set &quot;R_HISTFILE&quot; to &quot;&lt;&lt;ROOT task&gt;&gt;/.RHistory&quot;, so that same the history file will be used throughout each and every session.
</p>
</li>
<li> <p><code>save.image</code> is modified to call <code><a href="#topic+Save">Save</a></code> instead; this will behave exactly the same for workspaces not using <code>mvbutils</code> task-hierarchy feature or the <span class="pkg">debug</span> package, but otherwise will prevent problems with <code>mtrace</code>d functions and <code><a href="#topic+mlazy">mlazy</a></code>ed objects.
</p>
</li>
<li> <p><code><a href="#topic+print.function">print.function</a></code> is modified to let you go on seamlessly using functions written prior to R 2.14 in conjunction with the <code>srcref</code> system imposed by R 2.14; see <code><a href="#topic+fixr">fixr</a></code>.
</p>
</li></ul>

<p>Some of these redefinitions are optional and can be turned off if you really want: <code>loadhistory</code>, <code>savehistory</code>, <code>save.image</code>, <code>library</code>, <code>lockEnvironment</code>, <code>importIntoEnv</code>, and <code>loadNamespace</code>. To turn them off, set <code>options(mvbutils.replacements=FALSE)</code> <em>before</em> loading <code>mvbutils</code>. However, I really don't recommend doing so; it will prevent <code><a href="#topic+cd">cd</a></code> etc, <code><a href="#topic+fixr">fixr</a></code>, and the package-maintenance tools from working properly, and if you use <code>debug</code> you will probably cause yourself trouble when you forgetfully <code>save.image</code> an <code>mtrace</code>d function. You can also set the &quot;mvbutils.replacements&quot; option to a character vector comprising some or all of the above names, so that only those happen; if so, you're on your own. The other replacements are unavoidable (but should not be apparent for packages that don't import <code>mvbutils</code>).
</p>
<p>After <code>mvbutils</code> has loaded, you can undo the modification of a function <code>xxx</code> by calling <code>assign.to.base( "xxx", base.xxx)</code>. Exceptions are <code><a href="#topic+help">help</a></code>, <code>?</code>, <code><a href="#topic+print.function">print.function</a></code>, <code><a href="#topic+rbind.data.frame">rbind.data.frame</a></code> which are intrinsic to <code>mvbutils. Unloading </code>mvbutils' will undo all the modifications.
</p>


<h4>Nicer posixt behaviour</h4>

<p><code>POSIXct</code> etc have some nasty behaviour, and <code>mvbutils</code> used to include some functions that ameliorated things. I've moved them into a separate package <span class="pkg">nicetime</span>, available on request.
</p>



<h3>Ess and mvbutils</h3>

<p>For ESS users: I'm not an Emacs user and so haven't tried ESS with the <span class="pkg">mvbutils</span> package myself, but a read-through of the ESS documentation (as of ~2005) suggests that a couple of ESS variables may need changing to get the two working optimally. Please check the ESS documentation for further details on these points. I will update this helpfile when/if I receive more feedback on what works (though there hasn't been ESS feedback in ~8 years...).
</p>

<ul>
<li> <p><code><a href="#topic+cd">cd</a></code> changes the search list, so you may need to alter &quot;ess-change-sp-regex&quot; in ESS.
</p>
</li>
<li> <p><code><a href="#topic+cd">cd</a></code> also changes the prompt, so you may need to alter &quot;inferior-ess-prompt&quot;. Prompts have the form WORD1/WORD2/.../WORDn&gt; where WORDx is a letter followed by zero or more letters, underscores, periods, or digits.
</p>
</li>
<li> <p><code><a href="#topic+move">move</a></code> can add/remove objects in workspaces other than the top one, so if ESS relies on stored internal summaries of &quot;what's where&quot;, these may need updating.
</p>
</li></ul>



<h3>Display bugs</h3>

<p>If you have a buggy Linux display where <code>readline()</code> always returns the cursor to the start of the line, overwriting any prompt, then try <code>options( cd.extra.CR=TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>, <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+mlazy">mlazy</a></code>, <code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+dochelp">dochelp</a></code>, <code><a href="#topic+maintain.packages">maintain.packages</a></code>, <code><a href="#topic+source.mvb">source.mvb</a></code>, <code><a href="#topic+mlocal">mlocal</a></code>, <code><a href="#topic+do.in.envir">do.in.envir</a></code>, <code><a href="#topic+foodweb">foodweb</a></code>, <code><a href="#topic+mvbutils.operators">mvbutils.operators</a></code>, <code><a href="#topic+mvbutils.utils">mvbutils.utils</a></code>, <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>, package <span class="pkg">debug</span>
</p>

<hr>
<h2 id='add.flatdoc.to'>Skeletal flat-format documentation</h2><span id='topic+add.flatdoc.to'></span>

<h3>Description</h3>

<p>You very likely don't need to read this&mdash; <code>add.flatdoc.to</code> is usually called automatically for you, by <code>fixr( ..., new.doc=TRUE)</code>. It adds skeleton flat-format documentation to a function, suitable for conversion to Rd-format using <code><a href="#topic+doc2Rd">doc2Rd</a></code>. The result should pass RCMD CHECK (but won't be much use until you actually edit the documentation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># See *Examples* for practical usage
add.flatdoc.to(x, char.x = NULL, pkg=NULL, env=NULL, convert.to.source=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.flatdoc.to_+3A_x">x</code></td>
<td>
<p>unquoted function name, sought in <code>parent.frame()</code> unless <code>pkg</code> is set</p>
</td></tr>
<tr><td><code id="add.flatdoc.to_+3A_char.x">char.x</code></td>
<td>
<p>[string] function name</p>
</td></tr>
<tr><td><code id="add.flatdoc.to_+3A_pkg">pkg</code></td>
<td>
<p>[string] name of maintained package where <code>x</code> lives (optional)</p>
</td></tr>
<tr><td><code id="add.flatdoc.to_+3A_env">env</code></td>
<td>
<p>[environment] where to get <code>x</code> from; defaults to caller unless <code>pkg</code> is set.</p>
</td></tr>
<tr><td><code id="add.flatdoc.to_+3A_convert.to.source">convert.to.source</code></td>
<td>
<p>[logical] if TRUE and <code>x</code> has a &quot;srcref&quot; attribute, the latter is converted to a <code>source</code> attribute. This ensures that <code>fixr</code> will write the function correctly to the temporary file used by your text editor. Default is FALSE for historical reasons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You don't <b>have</b> to write Rd-compatible documentation from the outset. You can write documentation that's as free-form as you wish, and there's no need to use <code>add.flatdoc.to</code> to do it&ndash; you can write the doco directly in your text editor provided that you can <code>source</code> the resultant melange OK (see <code><a href="#topic+fixr">fixr</a></code>). I find <code>add.flatdoc.to</code> useful, though, because I can never remember the headings or mild layout conventions of <code><a href="#topic+doc2Rd">doc2Rd</a></code> and Rd-format itself.
</p>


<h3>Value</h3>

<p>A function with attribute <code>doc</code> containing the flat-format documentation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+doc2Rd">doc2Rd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myfun &lt;- function( ...) ...
myfun &lt;- add.flatdoc.to( myfun)
# 'fixr( myfun)' will now allow editing of code &amp; doco together
# Or, in a maintained package:
# ..mypack$myfun &lt;&lt;- add.flatdoc.to( myfun, pkg='mypack')
</code></pre>

<hr>
<h2 id='cd'>Organizing R workspaces</h2><span id='topic+cd'></span>

<h3>Description</h3>

<p><code>cd</code> allows you to set up and move through a hierarchically-organized set of R workspaces, each corresponding to a directory. While working at any level of the hierarchy, all higher levels are attached on the search path, so you can see objects in the &quot;parents&quot;. You can easily switch between workspaces in the same session, you can move objects around in the hierarchy, and you can do several hierarchy-wide things such as searching, even on parts of the hierarchy that aren't currently attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Occasionally: cd()
# Usually: cd(to)
# Rarely:
 cd(to, execute.First = TRUE, execute.Last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cd_+3A_to">to</code></td>
<td>
<p>the path of a task to move to or create, as an unquoted string. If omitted, you'll be given a menu. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="cd_+3A_execute.first">execute.First</code></td>
<td>
<p>should the <code>.First.task</code> code be executed on attachment? Yes, unless there's a bug in it.</p>
</td></tr>
<tr><td><code id="cd_+3A_execute.last">execute.Last</code></td>
<td>
<p>should the <code>.Last.task</code> code be executed on detachment? Yes, unless there's a bug in it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R workspaces can become very cluttered, so that it becomes difficult to keep track of what's what (I have seen workspaces with over 1000 objects in them). If you work on several different projects, it can be awkward to work out where to put &quot;shared&quot; functions&ndash; or to remember where things are, if you come back to a project after some months away. And if you just want to test out a bit of code without leaving permanent clutter, but while still being able to &quot;see&quot; your important objects, how do you do it? <code>cd</code> helps with all such problems, by letting you organize all your projects into a single tree structure, regardless of where they are stored on disk. Each workspace is referred to (for historical reasons) as a &quot;task&quot;.
</p>
<p>Note that there is a basic choice when working with R: do you keep everything you write in a text file which you <code>source</code> every time you start; or do you store all the objects in a workspace as a binary image in a &quot;.RData&quot; file, and rely on <code>save</code> and <code>load</code>? [Hybrids are possible, too.] Some people prefer the text-based approach, but others including me prefer the binary image approach; my reasons are that binary images let me organize my work across tasks more systematically, and that repeated text-sourcing is much too slow when lengthy analyses or data extractions are involved. The <code>cd</code> system is really geared to the binary image model and, before <code>cd</code> moves to a new task, either up or down the hierarchy, the current workspace is automatically saved to a binary image. Nevertheless, I don't think <code>cd</code> is incompatible with other ways of working, as long as the &quot;.RData&quot; file (actually the <code>tasks</code> object) is not destroyed from session to session. At any rate, some people who work by <code>source</code>ing large code files still seem to find <code>cd</code> useful; it's even possible to use the <code>.First.task</code> feature to auto-load a task's source files into a text editor when you <code>cd</code> to that task. With the &quot;.RData&quot;-only approach, it is highly advisable to have some way of keeping separate text backups, at least of function code. The <code><a href="#topic+fixr">fixr</a></code> editing system is geared up to this, and I presume other systems such as ESS are too.
</p>
<p>To use the <code>cd</code> system, you will need to start R in the <b>same</b> workspace every time. This will become your ROOT or home task, from which all other tasks stem. There need not be much in this workspace except for an object called <code>tasks</code> (see below), though you can use it for shared functions that you don't want to organize into a package. From the ROOT task, your first action in a new R session will normally be to use <code>cd</code> to switch to a real task. The <code>cd</code> command is used both to switch between existing tasks, and to create new ones.
</p>
<p>To set yourself up for working with <code>cd</code>, it's probably a good idea to make the ROOT task a completely new blank workspace, so the first step is to (outside R) create an empty folder with some name like &quot;Rstart&quot;. [In MS-Windows, you should think about <b>where</b> to put this, to save yourself inordinate typing later on. If you are planning to create a completely new set of folders for your R projects, you might want to put this ROOT folder near the top of the disk directory structure, rather than in the insane default that Windows proffers, which usually looks something like &quot;c:\document...\local...\long...\ridiculous...&quot;. However, if you are planning instead to link existing folders into the task hierarchy, then it's better to create the ROOT folder just above, or parallel to, the location of these folders.] Start R in this folder, type <code>library( mvbutils)</code>, and then start linking your existing projects into the task hierarchy. [Of course, this assumes that you do have existing projects. If you don't, then just start creating new tasks.] To link in a project, just type <code>cd()</code> and a menu will appear. The first time, there will be only one option: &quot;CREATE NEW TASK&quot;. Select it (or type 0 to quit if you are feeling nervous), and you will be prompted for a &quot;task name&quot;, by which R will always subsequently refer to the task. Keep the name short; it doesn't have to be related to the location of the disk directory where the .RData lives. Avoid spaces and weird characters&ndash; use periods as separators. Task names are case-sensitive. Next, you'll be asked which disk directory this task refers to. By default, <code>cd</code> expects that you are creating a new task, and therefore suggests putting the directory immediately below the current task directory. However, if you are linking in an existing project, you'll need to supply the directory name. You can save huge amounts of typing by using &quot;.&quot; to refer to the current directory, and on *nix systems you can use &quot;~&quot; too. Next, you'll be returned to the R command prompt&ndash; but the prompt will have changed, so that the &quot;&gt;&quot; is preceded by the task name. If you type <code>search()</code>, you'll see your ROOT task in position 2, below .GlobalEnv as usual. Despite the name, though, the new .GlobalEnv contains the project you've just linked, and if you type <code>ls()</code>, you should see some familiar objects. Now type <code>cd(0)</code> to move back to the ROOT task (note the changed prompt), type <code>search()</code> and <code>ls()</code> again to orient yourself, and proceed as before to link the rest of your pre-existing tasks into the hierarchy. When you now type <code>cd()</code>, the menu will have more choices. If you select an existing task rather than creating a new one, you will switch straightaway to that workspace; watch the prompt.
</p>
<p>Once you have a hierarchy set up, you can switch the current workspace within the hierarchy by calling e.g. <code>cd(existing.task)</code> (note the lack of quotes), or by calling <code>cd()</code> and picking off the menu. You can move through several levels of the hierarchy at once, using a path specifier such as <code>cd(mytask/data/funcs)</code> or <code>cd(../child.of.sibling)</code>. Path specifiers are just like Unix or Windows disk paths with &quot;/&quot; as the separator, so that &quot;.&quot; means &quot;current task&quot; and &quot;..&quot; means &quot;parent&quot;. However, the character 0 must be used to denote the ROOT task, so that you have to type <code>cd(0/different.task)</code> rather than <code>cd(/different.task</code>). You can display the entire hierarchy by calling <code>cdtree(0)</code>, or graphically via <code>plot( cdtree( 0))</code>.
</p>
<p>When you first set up your task hierarchy, you'll also want to create or modify the <code>.First</code> function in your ROOT task. At a minimum, this should call <code>library( mvbutils)</code>, but you may also want to set some options controlling the behaviour of <code>cd</code> (see the <b>Options</b> section). If you use other features of <code>mvbutils</code> such as the function-editing interface in <code><a href="#topic+fixr">fixr</a></code>, there will be further options to be set in <code>.First</code>. [MAC users: for some strange reason <code>.First</code> just doesn't get called if you are using the &quot;usual&quot; RGUI for MACs. So what you need to do is create a &quot;.Rprofile&quot; file in your ROOT folder using a text editor; this file should both contain the definition of the <code>.First</code> function, and should also call <code>.First()</code> directly. You can also put the <code>.First</code> commands directly into the &quot;.Rprofile&quot; file, but watch out for the side-effect of creating objects in <code>.GlobalEnv</code>.]
</p>
<p>You can create a fully hierarchical structure, with subtasks within subtasks within tasks, etc. Even if your projects don't naturally look like this, you may find the facility useful. When I create a new task, I tend to start with just one level of hierarchy, containing data, function code, and results. When this gets unspeakably messy, I often create one (or more) subtasks, usually putting the basic data at the top level, and functions and results at the lower level. Apart from tidiness, this provides some degree of protection against overwriting the original data. And when even this gets too messy&ndash; in one task, I have more than 150 functions, and it is very easy to generate 100s of analysis results&ndash; I create another level, keeping &quot;established&quot; functions at the second tier and using the third tier for temporary workspace and results. There are no hard-and-fast rules here, of course, and different people use R in very different ways.
</p>
<p>A task can have <code>.First.task</code> and/or <code>.Last.task</code> functions, which get called immediately after <code>cd</code>ing into the task from its parent, or immediately before <code>cd</code>ing back to its parent, respectively (see <b>Arguments</b>). These can be useful for dynamic loading, loading scripts into a text editor, attaching &amp; detaching datasets, etc., and facilitate the use of tasks as informal packages.
</p>
<p>For turning tasks into formal R packages, consult <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>.
</p>


<h3>How it works</h3>

<p>The mechanism underlying the tree structure is very simple: each task that has any subtasks will contain a character vector called <code>tasks</code>, whose names are the R names of the tasks, and whose elements are the corresponding disk directories. Your ROOT task need contain no more than a <code>.First</code> function and a <code>tasks</code> object.
</p>
<p>You can manually modify the <code>tasks</code> vector, and sometimes this is essential. If you decide to move a disk directory, for example, you can manually change the corresponding element of <code>tasks</code> to reflect the change. (Though if you are moving a whole task hierarchy, e.g. when migrating to a new machine, consult <code><a href="#topic+cd.change.all.paths">cd.change.all.paths</a></code>. Having said that, the ability to use relative pathnames in tasks, which is present since about mvbutils version 2.0, makes <code><a href="#topic+cd.change.all.paths">cd.change.all.paths</a></code> partly redundant.) You can also rename a task very easily, via something like
</p>
<pre>
  names( tasks)[ names( tasks)=="my.old.name"] &lt;- "my.new.name"
</pre>
<p>You can use similar methods to &quot;reparent&quot; a subtask without changing the directory structure.
</p>
<p>There is (deliberately, to avoid accidents) no completely automatic way of removing tasks. To &quot;hide&quot; a task from the <code>cd</code> system, you first need to be <code>cd</code>ed to its parent; then remove the corresponding element of the <code>tasks</code> object, most easily via e.g.
</p>
<pre>
  tasks &lt;- tasks %without.name% "mysubtask"
</pre>
<p>If you want to remove the directories corresponding to &quot;mysubtask&quot;, you have to do so manually, either in the operating system or (for the brave) in R code.
</p>
<p>Remember to <code>Save()</code> at some point after manually modifying <code>tasks</code>.
</p>


<h3>Options</h3>

<p>Various <code>options()</code> can be set, as follows. Remember to put these into your <code>.First</code> function, too.
</p>
<p><code>write.mvb.tasks=TRUE</code> causes a sourceable text representation of the <code>tasks</code> object to be maintained in each directory, in the file <code>tasks.r</code>. This helps in case you accidentally wipe out the .RData file and lose track of where the child tasks live. To create these text representations for the first time throughout the hierarchy, call <code>cd.write.mvb.tasks(0)</code>. You need to put the the <code>options</code> call in your <code>.First</code>.
</p>
<p><code>abbreviate.cdprompt=n</code> controls the length of the prompt string. Only the first <code>n</code> characters of all ancestral task names will be shown. For example, <code>n=1</code> would replace the prompt <code>long.task.name/data/funcs&gt;</code> with <code>l/d/funcs&gt;</code>.
</p>
<p><code>mvbutils.update.history.on.cd=FALSE</code> will prevent automatic saving &amp; reloading of the history file when <code>cd</code> is called.
</p>
<p><code>cd</code> checks the <code>R_HISTFILE</code> environment variable and, if unset, sets it to <code>file.path( getwd()), ".Rhistory")</code>. This (combined with the <code>mvbutils</code> replacement of the standard versions of <code>savehistory</code> and <code>loadhistory</code>&ndash; see <code>package?mvbutils</code>) ensures that the same history file is used throughout each and every R session. My experience is that a single master history file is safer. However, if you want to override this behaviour&ndash; e.g. if you want to use a separate history file for each task&ndash; call something like <code>Sys.setenv( R_HISTFILE=".Rhistory")</code> <b>before</b> the <b>first</b> use of <code>cd</code>.
</p>


<h3>Note</h3>

<p><code>cd</code> calls <code>setwd</code> so that file searches will default to the task directory (see also <code><a href="#topic+task.home">task.home</a></code>).
</p>
<p><code>cd</code> always calls <code><a href="#topic+Save">Save</a></code> before attaching a child task on top or moving back up the hierarchy. If you have many and/or big objects, the default behaviour can be slow. You can speed this up&ndash; sometimes dramatically&ndash; by &quot;mcacheing&quot; some of your objects so that they are stored in separate files&ndash; see <code><a href="#topic+mlazy">mlazy</a></code>.
</p>
<p>If there are no changes to the &quot;.RData&quot; file, <code>cd</code> will not modify the file&ndash; in particular, its date-of-access will be unchanged. This helps avoid unnecessary file copying on subsequent synchronization. However, there are several seemingly innocuous operations which change the workspace: calling a random number function (changes <code>.Random.seed</code>), causing an error (creates <code>.Traceback</code>), and causing a warning (creates <code>last.warning</code>). To avoid forcing a change to the entire &quot;.RData&quot; file whenever one of these changes, you can set <code>option( mvbutils.quick.cd=TRUE)</code>; this turns on <code>mcache</code>ing for those objects (see <code><a href="#topic+mlazy">mlazy</a></code>), so that they are stored in separate mini-files.
</p>
<p><code>cd</code> is only meant to be called interactively, and has only been tested in that context.
</p>
<p><code>cd</code> will issue a warning and refuse to move back up the hierarchy if it detects a non-task attached in position 2. You will need to manually detach any such objects before <code>cd</code>ing back up, or write a <code>.Last.task</code> function to automatically do the detaching. To make sure that <code>library</code> (and any automatic loading of packages, e.g. if triggered by <code>load</code>ing a file referring to a namespace) always inserts packages below ROOT, the <code>.onLoad</code> code in <code>mvbutils</code> makes a minor hack to <code>library</code>, changing the default <code><a href="#topic+pos">pos</a></code> argument accordingly.
</p>
<p>Two objects in the <code>mvb.session.info</code> search environment (see <code>search()</code>) help keep track of what parts of the hierarchy are currently attached; <code>.First.top.search</code> and <code>.Path</code>. The former is set when <code>mvbutils</code> loads, and the latter is updated by <code>cd</code>. Attached tasks can be identified by having a <code>path</code> attribute consisting of a <em>named</em> character vector. Normal packages also have a <code>path</code> attribute, but without <code>names</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+move">move</a></code>, <code><a href="#topic+task.home">task.home</a></code>, <code><a href="#topic+cdtree">cdtree</a></code>, <code><a href="#topic+cdfind">cdfind</a></code>, <code><a href="#topic+cditerate">cditerate</a></code>, <code><a href="#topic+cd.change.all.paths">cd.change.all.paths</a></code>, <code><a href="#topic+cd.write.mvb.tasks">cd.write.mvb.tasks</a></code>, <code><a href="#topic+cdprompt">cdprompt</a></code>, <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+mlazy">mlazy</a></code>
</p>

<hr>
<h2 id='cdfind'>Hierarchy-crawling functions for cd-organized workspaces</h2><span id='topic+cdfind'></span><span id='topic+cdregexpr'></span><span id='topic+cdtree'></span><span id='topic+cd.change.all.paths'></span><span id='topic+cd.write.mvb.tasks'></span><span id='topic+cditerate'></span><span id='topic+plot.cdtree'></span>

<h3>Description</h3>

<p>These functions work through part or all of a workspace (task) hierarchy set up via <code><a href="#topic+cd">cd</a></code>. <code>cdfind</code> searches for objects through the (attached and unattached) task hierarchy. <code>cdtree</code> displays the hierarchy structure. <code>cd.change.all.paths</code> is useful for moving or migrating all or part of the hierarchy to new disk directories. <code>cd.write.mvb.tasks</code> sets up sourceable text representations of the hierarchy, as a safeguard. <code>cditerate</code> is the engine that crawls through the hierarchy, underpinning the others; you can write your own functions to be called by <code>cditerate</code>.
</p>
<p>If a task folder or its &quot;.RData&quot; file doesn't exist, a warning is given and (obviously) it's not iterated over. If that file does exist but there's a problem while loading it (e.g. a reference to the namespace of a package that can't be loaded&ndash; search for <code>partial.namespaces</code> in <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>) then the iteration is still attempted, because something might be loaded. Neither case should cause an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdfind( pattern, from = ., from.text, show.task.name=FALSE)
cdregexpr( regexp, from = ., from.text, ..., show.task.name=FALSE)
cdtree( from = ., from.text = substitute(from), charlim = 90)
cd.change.all.paths( from.text = "0", old.path, new.path)
cd.write.mvb.tasks( from = ., from.text = substitute(from))
cditerate( from.text, what.to.do, so.far = vector("NULL", 0), ..., show.task.name=FALSE)
## S3 method for class 'cdtree'
plot( x, ...) # S3 method for cdtree; normally plot( cdtree(&lt;&lt;args&gt;&gt;))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdfind_+3A_pattern">pattern</code></td>
<td>
<p>regexpr to be checked against object names.</p>
</td></tr>
<tr><td><code id="cdfind_+3A_regexp">regexp</code></td>
<td>
<p>regexpr to be checked against function source code.</p>
</td></tr>
<tr><td><code id="cdfind_+3A_from">from</code></td>
<td>
<p>unquoted path specifier (see <code><a href="#topic+cd">cd</a></code>); make this 0 to operate on the entire hierarchy.</p>
</td></tr>
<tr><td><code id="cdfind_+3A_from.text">from.text</code></td>
<td>
<p>use this in place of <code>from</code> if you want to use a character string instead</p>
</td></tr>
<tr><td><code id="cdfind_+3A_show.task.name">show.task.name</code></td>
<td>
<p>(boolean) as-it-happens display of which task is being looked at</p>
</td></tr>
<tr><td><code id="cdfind_+3A_charlim">charlim</code></td>
<td>
<p>maximum characters per line allowed in graphical display of <code>cdtree</code>; reduce if unreadable, or change par( <code>cex</code>)</p>
</td></tr>
<tr><td><code id="cdfind_+3A_old.path">old.path</code></td>
<td>
<p>regexpr showing portion of directory names to be replaced</p>
</td></tr>
<tr><td><code id="cdfind_+3A_new.path">new.path</code></td>
<td>
<p>replacement portion of directory names</p>
</td></tr>
<tr><td><code id="cdfind_+3A_what.to.do">what.to.do</code></td>
<td>
<p>function to be called on each task (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="cdfind_+3A_so.far">so.far</code></td>
<td>
<p>starting value for accumulated list of function results</p>
</td></tr>
<tr><td><code id="cdfind_+3A_...">...</code></td>
<td>
<p>further fixed arguments to be passed to <code>what.to.do</code> (for <code>cditerate</code>), or <code>grep</code> (for <code>cdregexpr</code>), or <code><a href="#topic+foodweb">foodweb</a></code> (for <code>plot.cdtree</code>)</p>
</td></tr>
<tr><td><code id="cdfind_+3A_x">x</code></td>
<td>
<p>result of a call to <code>cdtree</code>, for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions start by default from the task that is currently top of the search list, and only look further down the hiearchy (i.e. to unattached descendents). To make them work through the whole hierarchy, supply <code>0</code> as the <code>from</code> argument. <code>cdtree</code> has a <code>plot</code> method, useful for complicated task hierarchies.
</p>
<p>If you want to automatically crawl through the task hierarchy to do something else, you can write a wrapper function which calls <code>cditerate</code>, and an inner function to be passed as the <code>what.to.do</code> argument to <code>cditerate</code>. The wrapper function will typically be very short; see the code of <code>cdfind</code> for an example.
</p>
<p>The inner function (typically called <code>cdsomething.guts</code>) must have arguments <code>found</code>, <code>task.dir</code>, <code>task.name</code>, and <code>env</code>, and may have any other arguments, which will be set according as the <code>...</code> argument of <code>cditerate</code>. <code>found</code> accumulates the results of previous calls to <code>what.to.do</code>. Your inner function can augment <code>found</code>, and should return the (possibly augmented) <code>found</code>. As for the other parameters: <code>task.dir</code> is obvious; <code>task.name</code> is a character(1) giving the full path specifier, e.g. <code>"ROOT/mytask"</code>; and <code>env</code> holds the environment into which the task has been (temporarily) loaded. <code>env</code> allows you to examine the task; for instance, you can check objects in the task by calling <code>ls(env=env)</code> inside your <code>what.to.do</code> function. See the code of <code>cdfind.guts</code> for an example.
</p>


<h3>Value</h3>

<p><code>cdfind</code> returns a list with one element for each object that is found somewhere; each such element is a character vector showing the tasks where the object was found.
<code>cdregexpr</code> returns a list with one element for each task where a function whose source matches the regexpr is found; the names of each list element names the functions within that task (an ugly way to return results, for sure).
<code>cdtree</code> returns an object of class <code>cdtree</code>, which is normally printed with indentations to show the hierarchy. You can also <code>plot(cdtree(...))</code> to see a graphical display.
<code>cd.change.all.paths</code> and <code>cd.write.mvb.tasks</code> do not return anything useful.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdfind( ".First", 0) # probably returns list( .First="ROOT")
</code></pre>

<hr>
<h2 id='cdprompt'>Support routine for cd-organized workspace hierarchy.</h2><span id='topic+cdprompt'></span>

<h3>Description</h3>

<p>Sets the command-line prompt to the correct value (see <code><a href="#topic+cd">cd</a></code>, and the notes on the option <code>abbreviate.cdprompt</code>); useful if the prompt somehow becomes corrupted. <code>cdprompt</code> never seems necessary in R but has been useful in the S+ manifestations of <code>mvbutils</code>, where system bugs are commoner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdprompt()
</code></pre>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdprompt()
</code></pre>

<hr>
<h2 id='changed.funs'>Show functions and callees in environment 'egood' that have changed or disappeared in environment 'ebad'.</h2><span id='topic+changed.funs'></span>

<h3>Description</h3>

<p>Useful eg when you have been modifying a package, and have buggered stuff up, and want to partly go back to an earlier version... entirely hypothetical of course, things like that never ever happens to <em>me</em>. Mere mortals might want to create a new environment <code>goodenv</code>, use <code>evalq(source(&lt;&lt;old.mypack.R.source.file&gt;&gt; local=T), goodenv)</code>, then <code>find.changes( goodenv, asNamespace("mypack"))</code>. If your package is lazy-loaded, you're stuffed; I avoid lazy-loading, except perhaps for final distribution, because it just makes it much harder to track problems. Not that <em>I</em> ever have problems, of course.
</p>
<p>Can be applied either to a specified set of functions, or by default to all the functions in <code>egood</code>. If the former, then all callees of the specified functions are also checked for changes, as are all their callees, and so on recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changed.funs(egood, ebad, topfun, fw = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="changed.funs_+3A_egood">egood</code>, <code id="changed.funs_+3A_ebad">ebad</code></td>
<td>
<p>environments #1 &amp; #2. Not symmetric; functions only in <code>ebad</code> won't be checked.</p>
</td></tr>
<tr><td><code id="changed.funs_+3A_topfun">topfun</code></td>
<td>
<p>name of functions in <code>egood</code> to check; all callees will be checked too, recursively. Default is all functions in <code>egood</code>.</p>
</td></tr>
<tr><td><code id="changed.funs_+3A_fw">fw</code></td>
<td>
<p>if non-NULL, the result of a previous call to <code>foodweb(egood)</code>, but this will be called automatically if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the names of changed/lost functions.
</p>

<hr>
<h2 id='check.patch.versions'>Check consistency of maintained package versions</h2><span id='topic+check.patch.versions'></span>

<h3>Description</h3>

<p>Utility to compare version numbers of the different &quot;instances&quot; of one of your maintained packages. Only the most up-to-date folders relevant to the running R version are checked; see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>.
</p>
<p>The &quot;instances&quot; checked are:
</p>

<ul>
<li><p> the task package itself (in eg <code>..mypack$mypack.VERSION</code>)
</p>
</li>
<li><p> the source package created by <code><a href="#topic+pre.install">pre.install</a></code>
</p>
</li>
<li><p> the installed package, maintained by <code><a href="#topic+patch.install">patch.install</a></code>
</p>
</li>
<li><p> the tarball package, created by <code><a href="#topic+build.pkg">build.pkg</a></code>
</p>
</li>
<li><p> the binary package, created by <code><a href="#topic+build.pkg.binary">build.pkg.binary</a></code>
</p>
</li></ul>

<p>The <code>care</code> argument controls what's shown. Mismatches when <code>care="installed"</code> should be addressed by <code><a href="#topic+patch.install">patch.install</a></code>, because something has gotten out-of-synch (probably when maintaining the same version of a package for different R versions). Mismatches with the built (&quot;tarball&quot; and &quot;binary&quot;) packages are not necessarily a problem, just an indication of work-in-progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.patch.versions(care = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.patch.versions_+3A_care">care</code></td>
<td>
<p>if non-NULL, a character vector with elements in the set &quot;installed&quot;, &quot;source&quot;, &quot;tarball&quot;, and &quot;binary&quot;. Only packages where there's a version mismatch between these fields and the task package version will be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix with maintained packages as rows, and the different instances as columns. &quot;NA&quot; indicates that a version couldn't be found.
</p>

<hr>
<h2 id='ditto.list'>Shorthand filler-inner for lists</h2><span id='topic+ditto.list'></span>

<h3>Description</h3>

<p>Suppose you want to set up a list where several consecutive elements take the same value, but you don't want to repeatedly type that value: then use <code>dittolist</code> to set empty (missing) elements to the previous non-empty element. Wrap in <code>unlist()</code> to create a vector instead of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ditto.list(...)
# EG:
# ditto.list( a=1, b=, c='hello') # a: 1; b: 1, c: 'hello'
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ditto.list_+3A_...">...</code></td>
<td>
<p>anything, named or unnamed; missing elements OK</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unlist( ditto.list( a=1, b=, c='hello')) # a: 1; b: 1, c: 'hello'
</code></pre>

<hr>
<h2 id='do.in.envir'>Modify a function's scope</h2><span id='topic+do.in.envir'></span>

<h3>Description</h3>

<p><code>do.in.envir</code> lets you write a function whose scope (enclosing environment) is defined at runtime, rather than by the environment in which it was defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Use only as wrapper of function body, like this:
# my.fun &lt;- function(...) do.in.envir( fbody, envir=)
# ... should be the arg list of "my.fun"
# fbody should be the code of "my.fun"
do.in.envir( fbody, envir=parent.frame(2)) # Don't use it like this!
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do.in.envir_+3A_fbody">fbody</code></td>
<td>
<p>the code of the function, usually a braced expression</p>
</td></tr>
<tr><td><code id="do.in.envir_+3A_envir">envir</code></td>
<td>
<p>the environment to become the function's enclosure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a <code>do.in.envir</code> function will have, as its enclosing environment, the environment in which it was <b>called</b>, rather than <b>defined</b>. It can therefore read variables in its caller's frame directly (i.e. without using <code>get</code>), and can assign to them via <code>&lt;&lt;-</code>. It's also possible to use <code>do.in.envir</code> to set a completely different enclosing environment; this is exemplified by some of the functions in <code>debug</code>, such as <code>go</code>.
</p>
<p>Note the difference between <code>do.in.envir</code> and <code><a href="#topic+mlocal">mlocal</a></code>; <code><a href="#topic+mlocal">mlocal</a></code> functions evaluate in the frame of their caller (by default), whereas <code>do.in.envir</code> functions evaluate in their own frame, but have a non-standard enclosing environment defined by the <code>envir</code> argument.
</p>
<p>Calls to e.g. <code>sys.nframe</code> won't work as expected inside <code>do.in.envir</code> functions. You need to offset the frame argument by 5, so that <code>sys.parent()</code> should be replaced by <code>sys.parent( 5)</code> and <code>sys.call</code> by <code>sys.call(-5)</code>.
</p>
<p><code>do.in.envir</code> functions are awkward inside namespaced packages, because the code in <code>fbody</code> will have &quot;forgotten&quot; its original environment when it is eventually executed. This means that objects in the namespace will not be found.
</p>
<p>The <span class="pkg">debug</span> package does not yet trace inside <code>do.in.envir</code> functions&ndash; this will change.
</p>


<h3>Value</h3>

<p>Whatever <code>fbody</code> returns.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlocal">mlocal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fff &lt;- function( abcdef) ffdie( 3)
ffdie &lt;- function( x) do.in.envir( { x+abcdef} )
fff( 9) # 12; ffdie wouldn't know about abcdef without the do.in.envir call
# Show sys.call issues
# Note that the "envir" argument in this case makes the
# "do.in.envir" call completely superfluous!
ffe &lt;- function(...) do.in.envir( envir=sys.frame( sys.nframe()), sys.call( -5))
ffe( 27, b=4) # ffe( 27, b=4)
</code></pre>

<hr>
<h2 id='do.on'>Easier sapply/lapply avoiding explicit function</h2><span id='topic+do.on'></span><span id='topic+FOR'></span>

<h3>Description</h3>

<p>Simpler to demonstrate:
</p>
<pre>
  do.on( find.funs(), environment( get( .)))
  # same as:
  lapply( find.funs(), function( x) environment( get( x)))
</pre>
<p><code>do.on</code> evaluates <code>expr</code> for all elements of <code>x</code>. The expression should involve the symbol <code>.</code>, and will be cast into a function which has an argument <code>.</code> and knows about any dotdotdot arguments passed to <code>do.on</code> (and objects in the function that calls <code>do.on</code>). If <code>x</code> is atomic (e.g. character or numeric, but not list) and lacks names, it will be given names via <code><a href="#topic+named">named</a></code>. With <code>do.on</code>, you are calling <code>sapply</code>, so the result is simplified if possible, unless <code>simplify=FALSE</code> (or <code>simplify="array"</code>, for which see <code><a href="base.html#topic+sapply">sapply</a></code>). With <code>FOR</code>, you are calling <code>lapply</code>, so no simplication is tried; this is often more useful for programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.on(x, expr, ..., simplify = TRUE)
FOR(x, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do.on_+3A_x">x</code></td>
<td>
<p>thing to be iterated over. Names are copied to the result, and are pre-allocated if required as per <b>Description</b></p>
</td></tr>
<tr><td><code id="do.on_+3A_expr">expr</code></td>
<td>
<p>expression, presumably involving the symbol <code>.</code> which will successively become the individual elements of <code>x</code></p>
</td></tr>
<tr><td><code id="do.on_+3A_...">...</code></td>
<td>
<p>other &quot;arguments&quot; for <code>expr</code></p>
</td></tr>
<tr><td><code id="do.on_+3A_simplify">simplify</code></td>
<td>
<p>as per <code>sapply</code>, and defaulting to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>do.on</code></td>
<td>
<p>as per <code>sapply</code>, a vector or array of the same &quot;length&quot; as <code>x</code>.</p>
</td></tr>
<tr><td><code>FOR</code></td>
<td>
<p>a list of the same length as <code>x</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>do.on( 1:7, sum(1:.))
#  1  2  3  4  5  6  7
# 1  3  6 10 15 21 28
# note the numeric "names" in the first row
FOR( 1:3, sum(1:.))
</code></pre>

<hr>
<h2 id='doc2Rd'>Converts plain-text documentation to Rd format</h2><span id='topic+doc2Rd'></span><span id='topic+docotest'></span>

<h3>Description</h3>

<p><code>doc2Rd</code> converts plain-text documentation into an Rd-format character vector, optionally writing it to a file. You probably won't need to call <code>doc2Rd</code> yourself, because <code><a href="#topic+pre.install">pre.install</a></code> and <code><a href="#topic+patch.install">patch.install</a></code> do it for you when you are building a package; the entire documentation of package <span class="pkg">mvbutils</span> was produced this way. The main point of this helpfile is to describe plain-text documentation details. However, rather than wading through all the material below, just have a look at a couple of R's help screens in the pager, e.g. via <code>help( glm, help_type="text")</code>, copy the result into a text editor, and try making one yourself. Don't bother with indentation, except in item lists as per <b>More details</b> below (the pager's version is not 100% suitable). See <code><a href="#topic+fixr">fixr</a></code> and its <code>new.doc</code> argument for how to set up an empty template: also <code><a href="#topic+help2flatdoc">help2flatdoc</a></code> for how to convert existing Rd-format doco.
</p>
<p><code>docotest</code> allows you to quickly check what your plain-text doco would look life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doc2Rd( text, file=NULL, append=, warnings.on=TRUE, Rd.version=,
    def.valids=NULL, check.legality=TRUE)
docotest( fun.or.text, ...)
</code></pre>


<h3>Arguments</h3>

<p>For <code>doc2Rd</code>:
</p>
<table role = "presentation">
<tr><td><code id="doc2Rd_+3A_text">text</code></td>
<td>
<p>(character or function) character vector of documentation, or a function with a <code>doc</code> attribute that is a c.v. of d..</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_file">file</code></td>
<td>
<p>(string or connection) if non-NULL, write the output to this file</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_append">append</code></td>
<td>
<p>(logical) only applies if <code>!is.null(file)</code>; should output be appended rather than overwriting?</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_warnings.on">warnings.on</code></td>
<td>
<p>(logical) ?display warnings about apparently informal documentation?</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_rd.version">Rd.version</code></td>
<td>
<p>(character) what Rdoc version to create &quot;man&quot; files in? Currently &quot;1&quot; means pre-R2.10, &quot;2&quot; means R2.10 and up. Default is set according to what version of R is running.</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_def.valids">def.valids</code></td>
<td>
<p>(character) objects or helpfiles for which links should be generated automatically. When <code>doc2Rd</code> is being called from <code>pre.install</code>, this will be set to all documented objects in your package. Cross-links to functions in other packages are not currently generated automatically (in fact not at all, yet).</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_check.legality">check.legality</code></td>
<td>
<p>if TRUE and <code>Rd.version</code> is 2 or more, then the output Rd will be run thru <code>parse_Rd</code> and a <code>try-error</code> will be returned if that fails; normal return otherwise. Not applicable if <code>Rd.version</code> is 1.</p>
</td></tr>
</table>
<p>For <code>docotest</code>:
</p>
<table role = "presentation">
<tr><td><code id="doc2Rd_+3A_fun.or.text">fun.or.text</code></td>
<td>
<p>(character or function) character vector of documentation, or a function with a <code>doc</code> attribute that is a c.v. of d.. NB if maintaining a package, you need to run this on the &quot;raw&quot; code (e.g. <code>..mypack$myfun</code>), not on the installed function (e.g. not <code>myfun</code> or <code>mypack::myfun</code>).</p>
</td></tr>
<tr><td><code id="doc2Rd_+3A_...">...</code></td>
<td>
<p>other args passed to <code>Rd2HTML</code> when it tries to convert <code>doc2Rd</code> output to HTML. I've no idea what these might be, since they wouldn't be used in reality by <code>pre.install</code> when it assembles your source package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing the text as it would appear in an Rd file, with <code>class</code> of &quot;cat&quot; so it prints nicely on the screen.
</p>


<h3>More details</h3>

<p>Flat-format (plain-text) documentation in <code>doc</code> attributes, or in stand-alone character objects whose name ends with &quot;.doc&quot;, can be displayed by the replacement <code><a href="#topic+help">help</a></code> in <code>mvbutils</code> (see <code><a href="#topic+dochelp">dochelp</a></code>) without any further ado. This is very useful while developing code before the package-creation stage, and you can write such documentation any way you want. For display in an HTML browser (as opposed to R's internal pager), and/or when you want to generate a package, <code>doc2Rd</code> will convert pretty much anything into a legal Rd file. However, if you can follow a very few rules, using <code>doc2Rd</code> will actually give nice-looking authentic R help. For this to work, your documentation basically needs to look like a plain-text help file, as displayed by <code>help(..., help_type="text")</code>.
</p>
<p>Rather than wading through this help file to work out how to write plain-text help, just have a look at a couple of R's help screens in the pager, and try making one yourself. You can also use <code><a href="#topic+help2flatdoc">help2flatdoc</a></code> to convert an existing plain-text help file. Also check the file &quot;sample.fun.rrr&quot; in the &quot;demostuff&quot; subdirectory of this package (see <b>Examples</b>). If something doesn't work, delve more deeply...
</p>

<ul>
<li><p> There are no &quot;escape characters&quot;&ndash; the system is &quot;text WYSIWYG&quot;. For example, if you type a \ character in your doc, <code><a href="#topic+help">help</a></code> will display a \ in that spot. Single quotes and percent signs can have special implications, though&ndash; see below.
</p>
</li>
<li><p> Section titles should either be fully capitalized, or end with a : character. The capitalized version shows up more clearly in informal help. Replace any spaces with periods, e.g. SEE.ALSO not SEE ALSO. The only non-alpha characters allowed are hyphens.
</p>
</li>
<li><p> Subsections are like sections, except they start with a sequence of full stops, one per nesting level. See also <b>Subsections</b>.
</p>
</li>
<li><p> &quot;Item lists&quot;, such as in the <b>Arguments</b> section and sometimes the <b>Value</b> section (and sometimes other sections), should be indented and should have a colon to separate the item name from the item body.
</p>
</li>
<li><p> General lists of items, like this bullet-point list, should be indented and should start with a &quot;-&quot; character, followed by a space.
</p>
</li>
<li><p> Your spacing is generally ignored (exceptions: <b>Usage</b>, <b>Examples</b>, multi-line code blocks; see previous point). Tabs are converted to spaces. Text is wrapped, so you should write paragraphs as single lines without hard line breaks. Use blank lines generously, to make your life easier; also, they will help readability of informal helpfiles.
</p>
</li>
<li><p> To mark <em>in-line</em> code fragments (including variable names, package names, etc&ndash; basically things that R could parse), put them in single quotes. Hence you can't use single quotes within in-line code fragments.
</p>
</li></ul>

<p>An example of what you couldn't include:
</p>
<p><code>'myfun( "'No no no!'")'</code>
</p>

<ul>
<li><p> Single quotes are OK within multi-code blocks, <b>Usage</b>, and <b>Examples</b>. For multi-line code blocks in other sections, don't bother with the single-quotes mechanism. Instead, insert a &quot;%%#&quot; line before the first line of the block, and make sure there is a blank line after the block.
</p>
</li>
<li><p> You can insert &quot;hidden lines&quot;, starting with a % character, which get passed to the Rd conversion routines. If the line starts with %%, then the Rd conversion routines will ignore it too. The &quot;%%#&quot; line to introduce multi-line code blocks is a special case of this.
</p>
</li>
<li><p> Some other special constructs, such as links, can be obtained by using particular phrases in your documentation, as per <b>Special fields</b>.
</p>
</li></ul>



<h4>Subsections</h4>

<p>I've bolded some of these meta-refs to sections
</p>
<p>Subsections are a nice new feature in R 2.11. You can use them to get better control over the order in which parts of documentation appear. R will order sections thus: <b>Usage</b>, <b>Arguments</b>, <b>Details</b>, <b>Value</b>, other sections you write in alphabetical section order, <b>Notes</b>, <b>See also</b>. That order is not always useful. You can add subsections to <b>Details</b> so that people will see them in the order you want. If you want <b>Value</b> to appear before <b>Details</b>, then just rename <b>Details</b> to &quot;MORE.DETAILS&quot;, and put subsections inside that.
</p>
<p>In plain-text, subsection headings are just like section headings, except they start with a period (don't use the initial periods when cross-referencing to it elsewhere in the doco). You can have nested subsections by adding extra periods at the start, like this:
</p>


<h5>Another depth of nesting</h5>

<p>In the plain text version of this doco, the SUBSECTIONS line starts with one period, and the ANOTHER.DEPTH.OF.NESTING line starts with two. If you try to increase subsection depth by more than one level, i.e. with 2+ full stops more than the previous (sub)section, then <code>doc2Rd</code> will correct your &quot;mistake&quot;.
</p>




<h4>Special fields</h4>

<p>Almost anything between a pair of single quotes will be put into a \code{} or \code{\link{}} or \pkg{} or \env{} construct, and the quotes will be removed. A link will be used if the thing between the quotes is a one-word name of something documented in your package (assuming <code>doc2Rd</code> is being called from <code><a href="#topic+pre.install">pre.install</a></code>). A link will also be used in all cases of the form &quot;See XXX&quot; or &quot;see XXX&quot; or &quot;XXX (qv)&quot;, where XXX is in single quotes, and any &quot; (qv)&quot; will be removed. With &quot;[pP]ackage XXX&quot; and &quot;XXX package&quot;, a \pkg{} construct will be used. References to <code>.GlobalEnv</code> and <code>.BaseNamespaceEnv</code> go into \env{} constructs. Otherwise, a \code{} construct will be used, unless the following exceptions apply. The first exception is if the quotes are inside <b>Usage</b>, <b>Examples</b>, or a multi-line code block. The second is if the first quote is preceded by anything other than &quot; &quot;, &quot;(&quot; or &quot;-&quot;. The final semi-exception is that a few special cases are put into other constructs, as next.
</p>
<p>URLs and email addresses should be enclosed in &lt;...&gt;; they are auto-detected and put into \url{} and \email{} constructs respectively.
</p>
<p>Lines that start with a % will have the % removed before conversion, so their contents will be passed to RCMD Rdconv later (unless you start the line with %%). They aren't displayed by <code><a href="#topic+dochelp">dochelp</a></code>, though, so can be used to hide an unhelpful USAGE, say, or to hide an &quot;#ifdef windows&quot;.
</p>
<p>A solitary capital-R is converted to \R. Triple dots <em>used to be</em> converted to \dots (regardless of whether they're in code or normal text) but I've stopped doing so because this conversion was taking 97% of the total runtime!
</p>
<p>Any reasonable &quot;*b*old&quot; or &quot;_emphatic stuff_&quot; constructions (no quotes, just the asterisks) will go into \bold{} and \emph{} constructs respectively, to give <b>b</b>old or <em>emphatic stuff</em>. (Those first two didn't, because they are &quot;unreasonable&quot;&ndash; in particular, they're quoted.) No other fancy constructs are supported (yet).
</p>



<h4>Format for non-function help</h4>

<p>For documenting datasets, the mandatory sections seem to be <b>Description</b>, <b>Usage</b>, and <b>Format</b>; the latter works just like <b>Arguments</b>, in that you specify field names in a list. Other common sections include <b>Examples</b>, <b>Source</b>, <b>References</b>, and <b>Details</b>.
</p>



<h4>Extreme details</h4>

<p>The first line should be the docfile name (without the Rd) followed by a few spaces and the package descriptor, like so:
</p>
<p>utility-funs package:mypack
</p>
<p>When <code>doc2Rd</code> runs, the docfile name will appear in both the \name{} field and the first \alias{} field. <code><a href="#topic+pre.install">pre.install</a></code> will actually create the file &quot;utility-funs.Rd&quot;. The next non-blank lines form the other alias entries. Each of those lines should consist of one word, preceded by one or more spaces for safety (not necessary if they have normal names).
</p>
<p>&quot;Informal documentation&quot; is interpreted as any documentation that doesn't include a &quot;DESCRIPTION&quot; (or &quot;Description:&quot;) line. If this is the case, <code>doc2Rd</code> first looks for a blank line, treats everything before it as \alias{} entries, and then generates the <b>Description</b> section into which all the rest of your documentation goes. No other sections in your documentation are recognized, but all the special field substitutions above are applied. (If you really don't want them to be, use the multi-line code block mechanism.) Token <b>Usage</b>, <b>Arguments</b>, and <b>Keywords</b> sections are appended automatically, to keep RCMD happy.
</p>
<p>Section titles built into Rd are: <b>Description</b>, <b>Usage</b>, <b>Synopsis</b> (defunct for R&gt;=3.1), <b>Arguments</b>, <b>Value</b>, <b>Details</b>, <b>Examples</b>, <b>Author</b> or <b>Author(s)</b>, <b>See also</b>, <b>References</b>, <b>Note</b>, <b>Keywords</b> and, for data documentation only, <b>Format</b> and <b>Source</b>. Other section titles (in capitals, or terminated with a colon) can be used, and will be sentence-cased and wrapped in a \section{} construct. Subsections work like sections, but begin with a sequence of full stops, one per nesting level. Most cross-refs to (sub)sections will be picked up automatically and put into <b>bold</b>, so that e.g. &quot;see MY.SECTION&quot; will appear as &quot;see <b>My section</b>&quot;; when referring to subsections, omit the initial dots. To force a cross-reference that just doesn't want to appear, use e.g. &quot;MY.SECTION (qv)&quot;, or just wrap it in &quot;*...*&quot;.
</p>
<p>The \docType field is set automatically for data documentation (iff a <b>Format</b> section is found) and for package documentation (iff the name on the first line includes &quot;-package&quot;).
</p>
<p>Spacing within lines does matter in <b>Usage</b> (qv), <b>Examples</b>, and multi-line code blocks, where what you type really is what you get (except that a fixed indent at the start of all lines in such a block is removed, usually to be reinstated later by the help facilities). The main issue is in the package &quot;manual&quot; that RCMD generates for you, where the line lengths are very short and overflows are common. (Overflows are also common with in-line code fragments, but little can be done about that.) The &quot;RCMD Rd2dvi &ndash;pdf&quot; utility is helpful for seeing how individual helpfiles come out.
</p>
<p>In <b>See also</b>, the syntax is slightly different; names of things to link to should <em>not</em> be in single quotes, and should be separated by commas or semicolons; they will be put into \code{\link{}} constructs. You can split SEE.ALSO across several lines; this won't matter for pager help, but can help produce tidier output in the file &quot;***-manual.tex&quot; produced by RCMD CHECK.
</p>
<p>In <b>Examples</b>, to designate &quot;don't run&quot; segments, put a &quot;## Don't run&quot; line before and a &quot;## End don't run&quot; line after.
</p>
<p>I never bother with <b>Keywords</b>, but if you do, then separate the keywords with commas, semicolons, or line breaks; don't use quotes. A token <b>Keywords</b> section will be auto-generated if you don't include one, to keep RCMD happy.
</p>



<h4>Infrequently asked questions</h4>

<p><b>Q:</b> Why didn't you use Markdown/MyPetBargainSyntax?
</p>
<p><b>A:</b> Mainly because I didn't know about them, to be honest. But WRTO MarkDown it seemed to me that the hard-line-breaks feature would be a pain. If anyone thinks there's really good alternative standard, please let me know.
</p>
<p><b>Q:</b> I have written a fancy <em>displayed</em> equation using \deqn{} and desperately want to include it. Can I?
</p>
<p><b>A:</b> Yes (though are you sure that a fancy equation really belongs in your function doco? how about in an attached PDF, or vignette?). Just prefix all the lines of your \deqn with %. If you want something to show up in informal help too, then make sure you also include lines with the text version of the equation, as per the next-but-one question.
</p>
<p><b>Q:</b> I have written a fancy <em>in-line</em> equation using \eqn{} and desperately want to include it. Can I?
</p>
<p><b>A:</b> No. Sorry.
</p>
<p><b>Q:</b> For some reason I want to see one thing in informal help (i.e. when the package isn't actually loaded but just sitting in a task on the search path), but a different thing in formal help. Can I do that?
</p>
<p><b>A:</b> If you must. Use the %-line mechanism for the formal help version, and then insert a line &quot;%#ifdef flub&quot; before the informal version, and a line &quot;%#endif&quot; after it. Your text version will show up in informal help, and your fancy version will show up in all help produced via Rd. (Anyone using the &quot;flub&quot; operating system will see both versions...)
</p>
<p><b>Q:</b> How can I insert a file/kbd/samp/option/acronym etc tag?
</p>
<p><b>A:</b> You can't. They all look like single quotes in pager-style help, anyway.
</p>
<p><b>Q:</b> What about S3?
</p>
<p><b>A:</b> S3 methods often don't need to be documented. However, they can be documented just like any other function, except for one small detail: in the <b>Usage</b> section, the call should use the generic name instead of your method name, and should be followed by a comment &quot;# S3 method for &lt;class&gt;&quot;; you can append more text to the comment if you wish. E.G.: if you are documenting a method <code><a href="#topic+print.cat">print.cat</a></code>, the <b>Usage</b> section should contain a call to <code>print(x,...) # S3 method for cat</code> rather than <code>print.cat(x,...)</code>. The version seen by the user will duplicate this &quot;S3 method...&quot; information, but never mind eh.
</p>
<p>If you are also (re)defining an S3 generic and documenting it in the same file as various methods, then put a comment <code># generic</code> on the relevant usage line. See <code>?print.function</code> for associated requirements.
</p>
<p>Confusion will deservedly arise with a function that looks like an S3 method, but isn't. It will be not be labelled as S3 by <code><a href="#topic+pre.install">pre.install</a></code> because you will of course have used the full name in the <b>Usage</b> section, because it isn't a method. However, it can still be found by <code>NextMethod</code> etc., so you shouldn't do that. (Though <code>mvbutils::max.pkg.ver</code> currently does exactly that...)
</p>
<p>S3 classes themselves need to be documented either via a relevant method using an alias line, or via a separate <code>myclass.doc</code> text object.
</p>
<p><b>Q:</b> What about S4?
</p>
<p><b>A:</b> I am not a fan of S4 and have found no need for it in many 1000s of lines of R code... hence I haven't included any explicit support for it so far. Nevertheless, things might well work anyway, unless special Rd constructs are needed. If <code>doc2Rd</code> <em>doesn't</em> work for your S4 stuff (bear in mind that the %-line mechanism may help), then for now you'll still have to write S4 Rd files yourself; see <code><a href="#topic+pre.install">pre.install</a></code> for where to put them. However, if anyone would like the flatdoc facility for S4 and is willing to help out, I'm happy to try to add support.
</p>



<h3>See Also</h3>

<p>The file &quot;sample.fun.rrr&quot; in subdirectory &quot;demostuff&quot;, and the demo &quot;flatdoc.demo.r&quot;.
</p>
<p>To do a whole group at once: <code><a href="#topic+pre.install">pre.install</a></code>.
</p>
<p>To check the results: <code>docotest(myfun)</code> to check the HTML (or <code>patch.installed(mypack)</code> and then <code>?myfun</code>). TODO something to easily check PDF (though R's PDF doco is pointless IMO); for now you need to manually generate the file, then from a command-line prompt do something like &quot;RCMD Rd2dvi &ndash;pdf XXX.Rd&quot; and &quot;RCMD Rdconv -t=html XXX.Rd&quot; and/or &quot;-t=txt&quot;
</p>
<p>To convert existing Rd documentation: <code><a href="#topic+help2flatdoc">help2flatdoc</a></code>.
</p>
<p>If you want to tinker with the underlying mechanisms: <code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+write.sourceable.function">write.sourceable.function</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Needs a function with the right kind of "doc" attr
## Look at file "demostuff/sample.fun.rrr"
sample.fun &lt;- source.mvb( system.file( file.path(
    'demostuff', 'sample.fun.rrr'), package='mvbutils'))
print( names( attributes( sample.fun)))
cat( '***Original plain-text doco:***\n')
print( as.cat( attr( sample.fun, 'doc'))) # unescaped, ie what you'd actually edit
cat( '\n***Rd output:***\n')
sample.fun.Rd &lt;- doc2Rd( sample.fun)
print( sample.fun.Rd) # already "cat" class
## Not run: 
docotest( sample.fun) # should display in browser

## End(Not run)
</code></pre>

<hr>
<h2 id='dochelp'>Documentation (informal help)</h2><span id='topic+dochelp'></span>

<h3>Description</h3>

<p><code>dochelp(topic)</code> will be invoked by the replacement <code><a href="#topic+help">help</a></code> if conventional <code><a href="#topic+help">help</a></code> fails to find documentation for topic <code>topic</code>. If <code>topic</code> is an object with a <code>doc</code> attribute (or failing that if <code>&lt;&lt;topic&gt;&gt;</code> or <code>&lt;&lt;topic&gt;&gt;.doc</code> is a character vector), then the attribute (or the character object) will be formatted and displayed by the pager or browser. <code>dochelp</code> is not usually called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Not usually called directly
# If it is, then normal usage is: dochelp( topic)
dochelp( topic, doc, help_type=c( "text", "html"))
# Set options( mvb_help_type="text") if the browser gives you grief
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dochelp_+3A_topic">topic</code></td>
<td>
<p>(character) name of the object to look for help on, or name of &quot;...doc&quot; character object&ndash; e.g. either <code>thing</code> or <code>thing.doc</code> if the character object is <code>thing.doc</code>.</p>
</td></tr>
<tr><td><code id="dochelp_+3A_doc">doc</code></td>
<td>
<p>(character or list)&ndash; normally not set, but deduced by default from <code>topic</code>; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="dochelp_+3A_help_type">help_type</code></td>
<td>
<p>as per <code>help</code>. Defaults to <code>getOption( "mvb_help_type")</code> in normal usage, which in turn defaults to <code>getOption( "help_type")</code> as for standard <code>help</code>. Only <code>"text"</code> and <code>"html"</code> are supported by <code>dochelp</code>; anything else maps to <code>"text"</code>, which invokes R's internal pager.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dochelp</code> will only be called if the original <code><a href="#topic+help">help</a></code> call was a simple <code>help( topic=X, ...)</code> form, with X not a call and with no <code>try.all.packages</code> or <code>type</code> or <code>lib.loc</code> arguments (the other <code><a href="#topic+help">help</a></code> options are OK).
</p>
<p>The <code>doc</code> argument defaults to the <code>doc</code> attribute of <code>get("topic")</code>. The only reason to supply a non-default argument would be to use <code>dochelp</code> as a pager; this might have some value, since <code>dochelp</code> does reformat character vectors to fit nicely in the system pager window, one paragraph per element, using <code><a href="base.html#topic+strwrap">strwrap</a></code>. Elements starting with a &quot;%&quot; symbol are not displayed.
</p>
<p>To work with <code>dochelp</code>, a <code>doc</code> attribute should be either:
</p>

<ul>
<li><p> a character vector, of length &gt;=1. New elements get line breaks in the pager. Or:
</p>
</li>
<li><p> a length-one list, containing the name of another object with a <code>doc</code> attribute. <code>dochelp</code> will then use the <code>doc</code> attribute of that object instead. This referencing can be iterated.
</p>
</li></ul>

<p>If the documentation is very informal, start it with a blank line to prevent <code>find.documented( ..., doctype="Rd")</code> from finding it.
</p>
<p>With <code>help_type="text"</code>, the doco will be re-formatted to fit the pager; each paragraph should be a single element in the character vector. Elements starting with a % will be dropped (but may still be useful for <code><a href="#topic+doc2Rd">doc2Rd</a></code>).
</p>
<p>With <code>help_type="html"</code>, the doco will be passed thru <code><a href="#topic+doc2Rd">doc2Rd</a></code> and then turned into HTML. <code><a href="#topic+doc2Rd">doc2Rd</a></code> is pretty forgiving and has a fair crack at converting even very informal documentation, but does have its limits. If there is an error in the <code><a href="#topic+doc2Rd">doc2Rd</a></code> conversion then <code>help_type</code> will be reset to <code>"text"</code>.
</p>
<p><code><a href="#topic+flatdoc">flatdoc</a></code> offers an easy way to incorporate plain-text (flat-format) documentation&ndash; formal or informal&ndash; in the same text file as a function definition, allowing easy maintenance. The closer you get to the displayed appearance of formal R-style help, the nicer the results will look in a browser (assuming <code>help_type="html"</code>), but the main thing is to just write <em>some</em> documentation&ndash; the perfect is the enemy of the good in this case!
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+doc2Rd">doc2Rd</a></code>, <code><a href="#topic+find.documented">find.documented</a></code>, <code>strwrap</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
myfun &lt;- structure( function() 1,
  doc="Here is some informal documentation for myfun\n")
dochelp( "myfun")
help( "myfun") # calls dochelp
</code></pre>

<hr>
<h2 id='dont.lock.me'>Prevent sealing of a namespace, to facilitate package maintenance.</h2><span id='topic+dont.lock.me'></span>

<h3>Description</h3>

<p>Call <code>dont.lock.me()</code> during a <code>.onLoad</code> to stop the namespace from being sealed. This will allow you to add/remove objects to/from the namespace later in the R session (in a sealed namespace, you can only change objects, and you can't unseal a namespace retrospectively). There could be all sorts of unpleasant side-effects. Best to leave it to <code><a href="#topic+maintain.packages">maintain.packages</a></code> to look after this for you...
</p>


<h3>Usage</h3>

<pre><code class='language-R'># default of env works if called directly in .onLoad
dont.lock.me( env=environment( sys.function( -1)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dont.lock.me_+3A_env">env</code></td>
<td>
<p>the environment to not lock.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dont.lock.me</code> hacks the standard <code>lockEnvironment</code> function so that locking won't happen if the environment has a non-NULL <code>dont.lock.me</code> attribute. Then it sets this attribute for the namespace environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This unseals the namespace of MYPACK only if the option "maintaining.MYPACK" is non-NULL:
.onLoad &lt;- function( libname, pkgname) {
  if( !is.null( getOption( 'maintaining.' %&amp;% pkgname)))
    mvbutils:::dont.lock.me()
}

## End(Not run)
</code></pre>

<hr>
<h2 id='dont.lockBindings'>Helper for live-editing of packages</h2><span id='topic+dont.lockBindings'></span>

<h3>Description</h3>

<p>Normally, objects in a NAMESPACEd package are locked and can't be changed. Sometimes this isn't what you want; you can prevent it by calling <code>dont.lockBindings</code> in the <code>.onLoad</code> for the package. For user-visible objects (i.e. things that end up in the &quot;package:blah&quot; environment on the search path), you can achieve the same effect by calling <code>dont.lockBindings</code> in the package's <code>.onAttach</code> function, with <code>namespace=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> dont.lockBindings( what, pkgname, namespace.=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dont.lockBindings_+3A_what">what</code></td>
<td>
<p>(character) the names of the objects to not lock.</p>
</td></tr>
<tr><td><code id="dont.lockBindings_+3A_pkgname">pkgname</code></td>
<td>
<p>(string) the name of the package. As you will only use this inside <code>.onLoad</code>, you can just set this to <code>pkgname</code> which is an argument of <code>.onLoad</code>.</p>
</td></tr>
<tr><td><code id="dont.lockBindings_+3A_namespace.">namespace.</code></td>
<td>
<p>TRUE to antilock in the namespace during <code>.onLoad</code>; FALSE to antilock in the visible manifestation of the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locking occurs after <code>.onLoad</code> / <code>.onAttach</code> are called so, to circumvent it, <code>dont.lockBindings</code> creates a hook function to be called after the locking step.
</p>


<h3>See Also</h3>

<p><code>lockBinding</code>, <code>setHook</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library( debug)
debug:::.onLoad # d.lB is called to make 'tracees' editable inside 'debug's namespace.
debug:::.onAttach # d.lB is called to make 'tracees' editable in the search path
# NB also that an active binding is used to ensure that the 'tracees' object in the search...
#... path is a "shadow of" or "pointer to" the one in 'debug's namespace; the two cannot get...
#... out-of-synch

## End(Not run)
</code></pre>

<hr>
<h2 id='extract.named'>Create variables from corresponding named list elements</h2><span id='topic+extract.named'></span>

<h3>Description</h3>

<p>This is a convenience function for creating named variables from lists. It's particularly useful for &quot;unpacking&quot; the results of calls to <code>.C</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.named( l, to=parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.named_+3A_l">l</code></td>
<td>
<p>a list, with some named elements (no named elements is OK but pointless)</p>
</td></tr>
<tr><td><code id="extract.named_+3A_to">to</code></td>
<td>
<p>environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing directly, but will create variables
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- function(...) { extract.named( list(...)); print( ls()); bbb }
# note bbb is not "declared"
ff( bbb=6, ccc=9) # prints [1] "bbb" "ccc", returns 6
</code></pre>

<hr>
<h2 id='fast.read.fwf'>Read in fixed-width files quickly</h2><span id='topic+fast.read.fwf'></span>

<h3>Description</h3>

<p>Experimental replacement for <code>read.fwf</code> that runs much faster. Included in <code>mvbutils</code> only to reduce dependencies amongst my other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.read.fwf(file, width,
    col.names = if (!is.null(colClasses))
        names( colClasses) else "V" %&amp;%  1:ncol(fields),
    colClasses = character(0), na.strings = character(0L),  tz = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast.read.fwf_+3A_file">file</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_width">width</code></td>
<td>
<p>vector of column widths. Negative numbers mean &quot;skip this many columns&quot;. Use an NA as the final element if there are likely to be extra characters at the end of each row after the last one that you're interested in.</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_col.names">col.names</code></td>
<td>
<p>names for the columns that are NOT skipped</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_colclasses">colClasses</code></td>
<td>
<p>can be used to control type conversion; see <code><a href="utils.html#topic+read.table">read.table</a></code>. It is an optional vector whose names must be part of <code>col.names</code>. There is one extension of the <code>read.table</code> rules:a <code>colClass</code> string starting <code>POSIXct.</code> will trigger automatic conversion to <code>POSIXct</code>, using the rest of the string as the format specifier. See also <code>tz</code>.</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_na.strings">na.strings</code></td>
<td>
<p>are there any strings (other than NA) which should convert to NAs?</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_tz">tz</code></td>
<td>
<p>used in auto-conversion to <code>POSIXct</code> when <code>colClass</code> is set</p>
</td></tr>
<tr><td><code id="fast.read.fwf_+3A_...">...</code></td>
<td>
<p>ignored; it's here so that this function can be called just like <code>read.fwf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, as per <code>read.fwf</code> and <code>read.table</code>.
misc
</p>

<hr>
<h2 id='find.documented'>Support for flat-format documentation</h2><span id='topic+find.documented'></span><span id='topic+find.docholder'></span>

<h3>Description</h3>

<p><code>find.documented</code> locates functions that have flat-format documentation; the functions and their documentation can be separate, and are looked for in all the environments in <code><a href="#topic+pos">pos</a></code>, so that functions documented in one environment but existing in another will be found. <code>find.docholder</code> says where the documentation for one or more functions is actually stored. Both <code>find.documented</code> and <code>find.docholder</code> check two types of object for documentation: (i) functions with &quot;doc&quot; attributes, and (ii) character-mode objects whose name ends in &quot;.doc&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.documented( pos=1, doctype=c( "Rd", "casual", "own", "any"),
  only.real.objects=TRUE)
find.docholder( what, pos=find( what[1]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.documented_+3A_pos">pos</code></td>
<td>
<p>search path position(s), numeric or character. In <code>find.documented</code>, any length. In <code>find.docholder</code>, only <code>pos[1]</code> will be used; it defaults to where the first element of <code>what</code> is found.</p>
</td></tr>
<tr><td><code id="find.documented_+3A_doctype">doctype</code></td>
<td>
<p>Defaults to &quot;Rd&quot;. If supplied, it is partially matched against the choices in <b>Usage</b>. &quot;Rd&quot; functions are named in the alias list at the start of (i) any <code>doc</code> attribute of a function, and (ii) any text object whose name ends with &quot;.doc&quot;, that exist in <code>pos</code> (see <code><a href="#topic+doc2Rd">doc2Rd</a></code>). &quot;casual&quot; functions have their own <code>doc</code> attribute and will be found by the replacement of <code>help</code>; note that the <code>doc</code> attribute can be just a reference to another documented function, of mode &quot;list&quot; as described in <code><a href="#topic+dochelp">dochelp</a></code>. &quot;own&quot; functions (a subset of &quot;casual&quot;) have their own character-mode <code>doc</code> attribute, and are suitable for <code>doc2Rd</code>. &quot;any&quot; combines <code>casual</code> and <code>Rd</code>.</p>
</td></tr>
<tr><td><code id="find.documented_+3A_only.real.objects">only.real.objects</code></td>
<td>
<p>If TRUE, only return names of things that exist somewhere in the <code>pos</code> environments. FALSE means that other things such as the name of helpfiles might be returned, too.</p>
</td></tr>
<tr><td><code id="find.documented_+3A_what">what</code></td>
<td>
<p>names of objects whose documentation you're trying to find.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>find.documented</code></td>
<td>
<p>Character vector of function names.</p>
</td></tr>
<tr><td><code>find.docholder</code></td>
<td>
<p>list whose names are <code>what</code>; element <code>i</code> is a character vector showing which objects hold documentation for <code>what[i]</code>. Normally you'd expect either 0 or 1 entries in the character vector; more than 1 would imply duplication.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>doctype="Rd"</code> looks for the alias names, i.e. the first word of all lines occurring before the first blank line. This may include non-existent objects, but these are checked for and removed.
</p>
<p>Start informal documentation (i.e. not intended for <code><a href="#topic+doc2Rd">doc2Rd</a></code>) with a blank line to avoid confusion.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+doc2Rd">doc2Rd</a></code>, <code><a href="#topic+dochelp">dochelp</a></code>
</p>

<hr>
<h2 id='fix.order'>Shows functions sorted by date of edit</h2><span id='topic+fix.order'></span>

<h3>Description</h3>

<p><code>fix.order</code> sorts the functions according to the filedates of their backups (in the .Backup.mvb directory). This is very useful for reminding yourself what you were working on recently. It only works if functions have been edited using the <code><a href="#topic+fixr">fixr</a></code> system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.order( env=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix.order_+3A_env">env</code></td>
<td>
<p>a single number, character string, or environment. Numbers and characters are interpreted as search path positions. The environment must be an attached mvb-style task.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only functions that have a BU*** backup file will appear. Functions that have a BU*** file but have been deleted will not appear.
</p>


<h3>Value</h3>

<p>Character vector of functions sorted by date/time of last modification.
</p>


<h3>To do</h3>

<p>Probably should modify this so it takes an arbitrary task path instead of a search position only. Task doesn't really need to be attached.
</p>
<p>Add a <code>pattern</code> argument a la find.funs.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixr">fixr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Need to create backups and do some function editing first
fix.order() # functions in .GlobalEnv
fix.order( "ROOT") # functions in your startup task

## End(Not run)
</code></pre>

<hr>
<h2 id='fixr'>Editing functions, text objects, and scriptlets</h2><span id='topic+fixr'></span><span id='topic+fixtext'></span><span id='topic+readr'></span><span id='topic+FF'></span><span id='topic+autoedit'></span>

<h3>Description</h3>

<p><code>fixr</code> opens a function (or text object, or &quot;script&quot; stored as an R <code>expression</code>&mdash; see <b>Scriptlets</b>) in your preferred text editor. Control returns immediately to the R command line, so you can keep working in R and can be editing several objects simultaneously (cf <code>edit</code>). A session-duration list of objects being edited is maintained, so that each object can be easily sourced back into its rightful workspace. These objects will be updated automatically on file-change if you've run <code>autoedit( TRUE)</code> (e.g. in your <code>.First</code>), or manually by calling <code>FF()</code>. There is an optional automatic text backup facility.
</p>
<p>The safest is to call <code>fixtext</code> to edit text objects, and <code>fixr</code> for functions and everything else. However, <code>fixr</code> can handle both, and for objects that already exist it will preserve the type. For new objects, though, you have to specify the type by calling either <code>fixr</code> or <code>fixtext</code>. If you forget&mdash; ie if you really wanted to create a new text object, but instead accidentally typed <code>fixr( mytext)</code>&mdash; you will (probably) get a parse error, and <code>mytext</code> will then be &quot;stuck&quot; as a broken function. Your best bet is to copy the actual contents in the text-editor to the clipboard, type <code>fixtext( mytext)</code> in R, paste the old contents into the text-editor, and save the file; R will then reset the type and all should be well.
</p>
<p><code>readr</code> also opens a file in your text editor, but in read-only mode, and doesn't update the backups or the list of objects being edited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  # Usually: fixr( x) or fixr( x, new.doc=T)
  fixr( x, new=FALSE, install=FALSE, what, fixing, pkg=NULL,
      character.only=FALSE, new.doc=FALSE, force.srcref=FALSE)
  # fixtext really has exact same args as fixr, but technically its args are:
  fixtext( x, ...)
  # Usually: readr( x) but exact same args as fixr, though the defaults are different
  readr( x, ...)
  FF() # manual check and update, usually only needed...
      # ... temporarily if autoedit() stops working
  autoedit( do=TRUE) # stick this line in your .First
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixr_+3A_x">x</code></td>
<td>
<p>a quoted or unquoted name of a function, text object, or expression. You can also write <code>mypack$myfun</code>, or <code>mypack::myfun</code>, or <code>mypack:::myfun</code>, or <code>..mypack$myfun</code>, to simultaneously set the <code>pkg</code> argument (only if <code>mypack</code> has been set up with <code>maintain.packages</code>). Note that <code>fixr</code> uses non-standard evaluation of its <code>x</code> argument, unless you specify <code>character.only=TRUE</code>. If your object has a funny name, either quote it and set <code>character.only=TRUE</code>, or pass it directly as...</p>
</td></tr>
<tr><td><code id="fixr_+3A_character.only">character.only</code></td>
<td>
<p>(logical or character) if TRUE, <code>x</code> is treated as a string naming the object to be edited, rather than the unquoted object name. If <code>character.only</code> is a string, it is treated as the name of <code>x</code>, so that eg <code>fixr(char="funny%name")</code> works.</p>
</td></tr>
<tr><td><code id="fixr_+3A_new.doc">new.doc</code></td>
<td>
<p>(logical) if TRUE, add skeleton plain-text R-style documentatation, as per <code>add.flatdoc.to</code>. Also use this to create an empty scriptlet for a general (non-function, non-text) object.</p>
</td></tr>
<tr><td><code id="fixr_+3A_force.srcref">force.srcref</code></td>
<td>
<p>(logical) Occasionally there have been problems transferring old code into &quot;new&quot; R, especially when a function has text attributes such as (but not limited to) <code>doc</code>; the symptom is, they appear in the editor just as &quot;# FLAT-FORMAT DOCUMENTATION&quot;. This sometimes requires manual poking-around, but usually can be sorted out by calling <code>fixr(...,force.srcref=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="fixr_+3A_new">new</code></td>
<td>
<p>(logical, seldom used) if TRUE, edit a blank function template, rather than any existing object of that name elsewhere in the search path. New edit will go into <code>.GlobalEnv</code> unless argument <code>pkg</code> is set.</p>
</td></tr>
<tr><td><code id="fixr_+3A_install">install</code></td>
<td>
<p>(logical, rarely used) logical indicating whether to go through the process of asking you about your editor</p>
</td></tr>
<tr><td><code id="fixr_+3A_what">what</code></td>
<td>
<p>Don't use this&ndash; it's &quot;internal&quot;! [Used by <code>fixtext</code>, which calls <code>fixr</code> with <code>what=""</code> to force text-mode object. <code>what</code> should be an object with the desired class.]</p>
</td></tr>
<tr><td><code id="fixr_+3A_fixing">fixing</code></td>
<td>
<p>(logical, rarely used) FALSE for read-only (i.e. just opening editor to examine the object)</p>
</td></tr>
<tr><td><code id="fixr_+3A_pkg">pkg</code></td>
<td>
<p>(string or environment) if non-NULL, then specifies in which package a specific maintained package (see <code><a href="#topic+maintain.packages">maintain.packages</a></code>) <code>x</code> should be looked for.</p>
</td></tr>
<tr><td><code id="fixr_+3A_do">do</code></td>
<td>
<p>(logical) TRUE =&gt; automatically update objects from altered files; FALSE =&gt; don't.</p>
</td></tr>
<tr><td><code id="fixr_+3A_...">...</code></td>
<td>
<p>other arguments, except <code>what</code> in <code>fixtext</code>, and <code>fixing</code> in <code>readr</code>, are passed to <code>fixr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>fixr</code> is run for the first time (or if you set <code>install=TRUE</code>), it will ask you for some basic information about your text editor. In particular, you'll need to know what to type at a command prompt to invoke your text editor on a specific file; in Windows, you can usually find this by copying the Properties/Shortcut/Target field of a shortcut, followed by a space and the filename. After supplying these details, <code>fixr</code> will launch the editor and print a message showing some <code>options</code> (<code>"backup.fix"</code>, <code>"edit.scratchdir"</code> and <code>"program.editor"</code>), that will need to be set in your <code>.First</code>. function. You should now be able to do that via <code>fixr(.First)</code>.
</p>
<p>Changes to the temporary files used for editing can be checked for automatically whenever a valid R command is typed (e.g. by typing 0&lt;ENTER&gt;; &lt;ENTER&gt; alone doesn't work). To set this up, call <code>autoedit()</code> once per session, e.g. in your <code>.First</code>. The manual version (ie what <code>autoedit</code> causes to run automatically) is <code>FF()</code>. If any file changes are detected by <code>FF</code>, the code is sourced back in and the appropriate function(s) are modified. <code>FF</code> tries to write functions back into the workspace they came from, which might not be <code>.GlobalEnv</code>. If not, you'll be asked whether you want to <code><a href="#topic+Save">Save</a></code> that workspace (provided it's a task&ndash; see <code><a href="#topic+cd">cd</a></code>). <code>FF</code> should still put the function in the right place, even if you've called <code><a href="#topic+cd">cd</a></code> after calling <code>fixr</code> (unless you've detached the original task) or if you <code><a href="#topic+move">move</a></code>d it. If the function was being <code>mtrace</code>d (see <code>package?debug</code>), <code>FF</code> will re-apply <code>mtrace</code> after loading the edited version. If there is a problem with parsing, the <code>source</code> attribute of the function is updated to the new code, but the function body is invisibly replaced with a <code>stop</code> call, stating that parsing failed.
</p>
<p>If something goes wrong during an automatic call to <code>FF</code>, the automatic-call feature will stop working; this is rare, but can be caused eg by hitting &lt;ESC&gt; while being prompted whether to save a task. To restart the feature in the current R session, do <code>autoedit(F)</code> and then <code>autoedit(T)</code>. It will come back anyway in a new R session.
</p>
<p><code>readr</code> requires a similar installation process. To get the read-only feature, you'll need to add some kind of option/switch on the command line that invokes your text editor in read-only mode; not all text editors support this. Similarly to <code>fixr</code>, you'll need to set <code>options( program.reader=&lt;&lt;something&gt;&gt;)</code> in your <code>.First</code>; the installation process will tell you what to use.
</p>
<p><code>fixr</code>, and of course <code>fixtext</code>, will also edit character vectors. If the object to be edited exists beforehand and has a class attribute, <code>fixr</code> will not change its class; otherwise, the class will be set to &quot;cat&quot;. This means that <code><a href="#topic+print">print</a></code> invokes the <code><a href="#topic+print.cat">print.cat</a></code> method, which displays text more readably than the default. Any other attributes on character vectors are stripped.
</p>
<p>For functions, the file passed to the editor will have a &quot;.r&quot; extension. For character vectors or other things, the default extension is &quot;.txt&quot;, which may not suit you since some editors decide syntax-highlighting based on the file extension. (EG if the object is a character-vector &quot;R script&quot;, you might want R-style syntax highlighting.) You can somewhat control that behaviour by setting <code>options()$fixr.suffices</code>, eg
</p>
<pre>
  options( fixr.suffices=c( r='.r', data='.dat'))
</pre>
<p>which will mean that non-function objects whose name ends <code>.r</code> get written to files ending &quot;.r.r&quot;, and objects whose name ends <code>.data</code> get written to files ending &quot;.data.dat&quot;; any other non-functions will go to files ending &quot;.txt&quot;. This does require you to use some discipline in naming objects, which is no bad thing; FWIW my &quot;scripts&quot; always do have names ending in <code>.r</code>, so that I can see what's what.
</p>
<p><code>fixr</code> creates a blank function template if the object doesn't exist already, or if <code>new=TRUE</code>. If you want to create a new character vector as opposed to a new function, call <code>fixtext</code>, or equivalently set <code>what=""</code> when you call <code>fixr</code>.
</p>
<p>If the function has attributes, the version in the text editor will be wrapped in a <code>structure(...)</code> construct (and you can do this yourself). If a <code>doc</code> attribute exists, it's printed as free-form text at the end of the file, and the call to <code>structure</code> will end with a line similar to:
</p>
<pre>
  ,doc=flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;"))
</pre>
<p>When the file is sourced back in, that line will cause the rest of the file&ndash; which should be free-format text, with no escape characters etc.&ndash; to be read in as a <code>doc</code> attribute, which can be displayed by <code><a href="#topic+help">help</a></code>. If you want to add plain-text documentation, you can also add these lines yourself&ndash; see <code><a href="#topic+flatdoc">flatdoc</a></code>. Calling <code>fixr( myfun, new.doc=TRUE)</code> sets up a documentation template that you can fill in, ready for later conversion to Rd format in a package (see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>).
</p>
<p>The list of functions being edited by <code>fixr</code> is stored in the variable <code>fix.list</code> in the <code>mvb.session.info</code> environment. When you quit and restart R, the function files you have been using will stay open in the editor, but <code>fix.list</code> will be empty; hence, updating the file &quot;myfun.r&quot; will not update the corresponding R function. If this happens, just type <code>fixr(myfun)</code> in R and when your editor asks you if you want to replace the on-screen version, say no. Save the file again (some editors require a token modification, such as space-then-delete, first) and R will notice the update. Very very occasionally, you may want to tell R to stop trying to update one of the things it's editing, via eg <code>fixtext &lt;&lt;- fixtext[-3,]</code> if the offending thing is the third row in <code>fixlist</code>; note the double arrow.
</p>
<p>An automatic text backup facility is available from <code>fixr</code>: see <code>?get.backup</code>. The backup system also allows you to sort edited objects by edit date; see <code>?fix.order</code>.
</p>


<h4>Changes with r 2 14</h4>

<p>Time was, functions had their source code (including comments, author's preferred layout, etc) stored in a &quot;source&quot; attribute, a simple character vector that was automatically printed when you looked at the function. Thanks to the fiddly, convoluted, opaque &quot;srcref&quot; system that has replaced &quot;source&quot; as of R 2.14&mdash; to no real benefit that I can discern&mdash; <code>fixr</code> in versions of <code>mvbutils</code> prior to 2.5.209 didn't work correctly with R 2.14 up. Versions of <code>mvbutils</code> after 2.5.509 should work seamlessly.
</p>
<p>The technical point is that, from R 2.14 onwards, basic R will <em>not</em> show the <code>source</code> attribute when you type a function name without running the function; unless there is a <code>srcref</code> attribute, all you will see is the deparsed raw code. Not nice; so the replacement to <code><a href="#topic+print.function">print.function</a></code> in <code>mvbutils</code> will show the <code>source</code> attribute if it and no <code>srcref</code> attribute is present. As soon as you change a function with <code>fixr</code> post-R-2.14, it automatically loses any <code>source</code> attribute and acquires a &quot;proper&quot; <code>srcref</code> attribute, which will from then on.
</p>



<h4>Local function groups</h4>

<p>There are several ways to work with &quot;nested&quot; (or &quot;child&quot; or &quot;lisp-style macro&quot;) functions in R, thanks to R's scoping and environment rules; I've used at least four, most often <code><a href="#topic+mlocal">mlocal</a></code> in package <span class="pkg">mvbutils</span>. One is to keep a bunch of functions together in a <code><a href="base.html#topic+local">local</a></code> environment so that they (i) know about each other's existence and can access a shared variable pool, (ii) can be edited en bloc, but (iii) don't need to clutter up the &quot;parent&quot; code with the definitions of the children. <code>fixr</code> will happily create &amp; edit such a function-group, as long as you make sure the last statement in <code>local</code> evaluates to a function. For example:
</p>
<pre>
  # after typing 'fixr( secondfun)' in R, put this into your text editor:
  local({
    tot &lt;- 0
    firstfun &lt;- function( i) tot &lt;&lt;- tot+i
    function( j) {
        for( ii in 1:j)
          firstfun( ii)
        tot
      }
  })
</pre>
<p>Note that it's <em>not</em> necessary to assign the last definition to a variable inside the <code>local</code> call, unless you want to be able to reach that function recursively from one of the others, as in the first example for <code>local</code>. Note also that <code>firstfun</code> will not be visible &quot;globally&quot;, only from within <code>secondfun</code> when it executes.
</p>
<p><code>secondfun</code> above can be debugged as usual with <code>mtrace</code> in the <span class="pkg">debug</span> package. If you want to turn on mtracing for <code>firstfun</code> without first mtracing <code>secondfun</code> and manually calling <code>mtrace(firstfun)</code> when <code>secondfun</code> appears, do <code>mtrace(firstfun, from=environment( secondfun))</code>.
</p>
<p><b>Note</b>: I <em>think</em> all this works OK in normal use (Oct 2012), but be careful! I doubt it works when building a package, and I'm not sure that R-core intend that it should; you might have to put the local-building code into the <code>.onLoad</code>.
</p>



<h4>Scriptlets</h4>

<p><b>Note</b>: I've really gone off &quot;scriptlets&quot; (writing this in mid 2016). These days I prefer to keep &quot;scripts&quot; as R character-vector objects (because I dislike having lots of separate files), edited by <code>fixtext</code> and manually executed as required by <code>debug::mrun</code>&mdash; which also has a debugging option that automatically applies <code>mtrace</code>. I'm not going to remove support for scriptlets in <code>fixr</code>, but I'm not going to try hard to sort out any bugs either. Instructions below are unchanged, and unchecked, from some years ago.
</p>
<p>You can also maintain &quot;scriptlets&quot; with <code>fixr</code>, by embedding the instructions (and comments etc) in an <code>expression(...)</code> statement. Obviously, the result will be an <code>expression</code>; to actually execute a scriptlet after editing it, use <code>eval()</code>. The scriptlet itself is stored in the &quot;source&quot; attribute as a character vector of class <code>cat</code>, and the expression itself is given class <code>thing.with.source</code> so that the source is displayed in preference to the raw expression. Backup files are maintained just as for functions. Only the <em>first</em> syntactically complete statement is returned by <code>fixr</code> (though subsequent material, including extra comments, is always retained in the <code>source</code> attribute); make sure you wrap everything you want done inside that call to <code>expression(...)</code>.
</p>
<p>Two cases I find useful are:
</p>

<ul>
<li><p> instructions to create data.frames or matrices by reading from a text file, and maybe doing some initial processing;
</p>
</li>
<li><p> expressions for complicated calls with particular datasets to model-fitting functions such as <code>glm</code>.
</p>
</li></ul>

<pre>
  # Object creator:
  expression( { # Brace needed for multiple steps
    raw.data &lt;- read.table( "bigfile.txt", header=TRUE, row=NULL)
    # Condense date/time char fields into something more useful:
    raw.data &lt;- within( raw.data, {
      Time &lt;- strptime( paste( DATE, TIME, sep=' '), format="%Y-%m-%d %H:%M:%S")
      rm( DATE, TIME)
    })
    cat( "'raw.data' created OK")
  })
</pre>
<p>and
</p>
<pre>
  # Complicated call:
  expression(
    glm( LHS ~ captain + beard %in% soup, data=alldata %where% (mushroom=='magic'), family=binomial( link=caterpillar))
  )
</pre>
<p>Bear in mind that <code>eval(myscriptlet)</code> takes place in <code>.GlobalEnv</code> unless you tell it not to, so the first example above actually creates <code>raw.data</code> even though it returns NULL. To trace evaluation of <code>myscriptlet</code> with the <span class="pkg">debug</span> package, call <code>debug.eval( myscriptlet)</code>.
</p>
<p>For a new scriptlet <code>mything</code>, the call to <code>fixr</code> should still just be <code>fixr(mything)</code>. However, if you have trouble with this, try <code>fixr( mything, what=list())</code> instead, even if <code>mything</code> won't be a <code>list()</code>. For an existing non-function, you'll need the <code>new=T</code> argument, e.g. <code>fixr( oldthing, new=T)</code>, and you'll then have to manually copy/paste the contents.
</p>
<p>Note that you <b>can't</b> use <code>quote()</code> instead of <code>expression()</code>, because any attempt to display the object will cause it to run instead; this is a quirk of S3 methods!
</p>


<h5>For the brave</h5>

<p>In principle, you can also edit non-expressions the same way. For example, you can create a <code>list</code> directly (not requiring subsequent <code>eval()</code>) via a scriptlet like this:
</p>
<pre>
  list(
    a = 1, # a number
    b = 'aardvark' # a character
  )
</pre>
<p>Nowadays I tend to avoid this, because the code will be executed immediately R detects a changed file, and you have no other (easy) control over when it's evaluated. Also, note that the result will have class <code>thing.with.source</code> (prepended to any other S3 classes it might have), which has its own print method that shows the source; hence you won't see the contents directly when you just type its name, which may or may not be desirable.
</p>




<h3>Troubleshooting</h3>

<p>Rarely, <code>fixr</code> (actually <code>FF</code>) can get confused, and starts returning errors when trying to update objects from their source files. (Switching between &quot;types&quot; of object with the same name&mdash; function, expression, character vector&mdash; can do this.) In such cases, it can be useful to purge the object from the <code>fix.list</code>, a session-duration data.frame object in workspace <code>mvb.session.info</code> on the search path. Say you are having trouble with object &quot;badthing&quot;: then
</p>
<pre>
  fix.list &lt;&lt;- fix.list[ names( fix.list) != 'bad.thing',]
</pre>
<p>will do the trick (note the double arrow). This means <code>FF</code> will no longer look for updates to the source file for <code>badthing</code>, and you are free to again <code>fixr( badthing)</code>.
</p>
<p>To purge the entire <code>fix.list</code>, do this:
</p>

<p>fix.list &lt;&lt;- fix.list[ 0,]
</p>


<h3>Note</h3>

<p><code>fixr</code> is designed to be used with <code><a href="#topic+cd">cd</a></code>; I'm not sure it will work independently.
</p>
<p>Originally, <code>fixr</code> was only for functions, and not even for functions in packages, so that it was mostly an alternative to e.g. ESS; if you liked ESS, you wouldn't have bothered with <code>fixr</code>. However, <code>fixr</code> now has more sophisticated purposes, in particular being AFAIK the only reliable way of interfacing the package-maintenance features in the <span class="pkg">mvbutils</span> package. It would be interesting to find out if it can be integrated with e.g. ESS (which I know only enough about to dislike). Input welcome (but unexpected; none has ever come from ESSers).
</p>


<h3>See Also</h3>

<p><code>.First</code>, <code>edit</code>, <code><a href="#topic+cd">cd</a></code>, <code><a href="#topic+get.backup">get.backup</a></code>, <code><a href="#topic+fix.order">fix.order</a></code>, <code><a href="#topic+move">move</a></code>
</p>

<hr>
<h2 id='flatdoc'>Flat-format documentation</h2><span id='topic+flatdoc'></span>

<h3>Description</h3>

<p>The <code>flatdoc</code> convention lets you edit plain-text documentation in the same file as your function's source code. <code>flatdoc</code> is hardly ever called explicitly, but you will see it in text files produced by <code><a href="#topic+fixr">fixr</a></code>; you can also add it to such files yourself. <code>mvbutils</code> extends <code><a href="#topic+help">help</a></code> so that <code>?myfunc</code> will display this type of documentation for <code>myfunc</code>, even if <code>myfunc</code> isn't in a package. There are no restrictions on the format of informal-help documentation, so <code>flatdoc</code> is useful for adding quick simple help just for you or for colleagues. If your function is to be part of a maintained package (see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>), then the documentation should follow a slightly more formal structure; use <code>fixr( myfun, new.doc=T)</code> to set up the appropriate template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ALWAYS use it like this:
# structure( function( ...) {body},
# doc=flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;"))
# plaintext doco goes here...
# NEVER use it like this:
flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatdoc_+3A_eof">EOF</code></td>
<td>
<p>character string showing when plain text ends, as in <code>readlines.mvb</code></p>
</td></tr>
<tr><td><code id="flatdoc_+3A_body">body</code></td>
<td>
<p>replace with your function code</p>
</td></tr>
<tr><td><code id="flatdoc_+3A_...">...</code></td>
<td>
<p>replace with your function arg list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of class <code>docattr</code>, as read from the <code>current.source()</code> (qv) connection. The print method for <code>docattr</code> objects just displays the string &quot;# FLAT-FORMAT DOCUMENTATION&quot;, to avoid screen clutter.
</p>


<h3>Internal details</h3>

<p>This section can be safely ignored by almost all users.
</p>
<p>On some text editors, you can modify syntax highlighting so that the &quot;start of comment block&quot; marker is set to the string &quot;doc=flatdoc(&quot;.
</p>
<p>It's possible to use <code>flatdoc</code> to read in more than one free-format text attribute. The <code>EOF</code> argument can be used to distinguish one block of free text from the next. These attributes can be accessed from your function via <code>attr( sys.function(), "&lt;&lt;attr.name&gt;&gt;")</code>, and this trick is occasionally useful to avoid having to include multi-line text blocks in your function code; it's syntactically clearer, and avoids having to escape quotes, etc. <code>mvbutils:::docskel</code> shows one example.
</p>
<p><code><a href="#topic+fixr">fixr</a></code> uses <code><a href="#topic+write.sourceable.function">write.sourceable.function</a></code> to create text files that use the <code>flatdoc</code> convention. Its counterpart <code><a href="#topic+FF">FF</a></code> reads these files back in after they're edited. The reading-in is not done with <code>source</code> but rather with <code><a href="#topic+source.mvb">source.mvb</a></code>, which understands <code>flatdoc</code>. The call to <code>doc=flatdoc</code> causes the rest of the file to be read in as plain text, and assigned to the <code>doc</code> attribute of the function. Documentation can optionally be terminated before the end of the file with the following line:
</p>
<pre>
  &lt;&lt;end of doc&gt;&gt;
</pre>
<p>or whatever string is given as the argument to <code>flatdoc</code>; this line will cause <code><a href="#topic+source.mvb">source.mvb</a></code> to revert to normal statement processing mode for the rest of the file. Note that vanilla <code>source</code> will not respect <code>flatdoc</code>; you do need to use <code><a href="#topic+source.mvb">source.mvb</a></code>.
</p>
<p><code>flatdoc</code> should never be called from the command line; it should only appear in text files designed for <code><a href="#topic+source.mvb">source.mvb</a></code>.
</p>
<p><em>The rest of this section is probably obsolete, though things should still work.</em>
</p>
<p>If you are writing informal documentation for a group of functions together, you only need to <code>flatdoc</code> one of them, say <code>myfun1</code>. Informal help will work if you modify the others to e.g.
</p>
<pre>
  myfun2 &lt;- structure( function(...) { whatever}, doc=list("myfun1"))
</pre>
<p>If you are writing with <code><a href="#topic+doc2Rd">doc2Rd</a></code> in mind and a number of such functions are to be grouped together, e.g. a group of &quot;internal&quot; functions in preparation for formal package release, you may find <code><a href="#topic+make.usage.section">make.usage.section</a></code> and <code><a href="#topic+make.arguments.section">make.arguments.section</a></code> helpful.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+source.mvb">source.mvb</a></code>, <code><a href="#topic+doc2Rd">doc2Rd</a></code>, <code><a href="#topic+dochelp">dochelp</a></code>, <code><a href="#topic+write.sourceable.function">write.sourceable.function</a></code>, <code><a href="#topic+make.usage.section">make.usage.section</a></code>,
</p>
<p><code><a href="#topic+make.arguments.section">make.arguments.section</a></code>, <code><a href="#topic+fixr">fixr</a></code>, the demo in &quot;flatdoc.demo.R&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Put next lines up to "&lt;&lt;end of doc&gt;&gt;" into a text file &lt;&lt;your filename&gt;&gt;
## and remove the initial hashes
#structure( function( x) {
#  x*x
#}
#,doc=flatdoc("&lt;&lt;end of doc&gt;&gt;"))
#
#Here is some informal documentation for the "SQUARE" function
#&lt;&lt;end of doc&gt;&gt;
## Now try SQUARE &lt;- source.mvb( &lt;&lt;your filename&gt;&gt;); ?SQUARE
## Example with multiple attributes
## Put the next lines up to "&lt;&lt;end of part 2&gt;&gt;"
## into a text file, and remove the single hashes
#myfun &lt;- structure( function( attname) {
#  attr( sys.function(), attname)
#}
#,  att1=flatdoc( EOF="&lt;&lt;end of part 1&gt;&gt;")
#,  att2=flatdoc( EOF="&lt;&lt;end of part 2&gt;&gt;"))
#This goes into "att1"
#&lt;&lt;end of part 1&gt;&gt;
#and this goes into "att2"
#&lt;&lt;end of part 2&gt;&gt;
## Now "source.mvb" that file, to create "myfun"; then:
myfun( 'att1') # "This goes into \\"att1\\""
myfun( 'att2') # "and this goes into \\"att2\\""

## End(Not run)
</code></pre>

<hr>
<h2 id='foodweb'>Shows which functions call what</h2><span id='topic+foodweb'></span><span id='topic+callers.of'></span><span id='topic+callees.of'></span><span id='topic+plot.foodweb'></span>

<h3>Description</h3>

<p><code>foodweb</code> is applied to a group of functions (e.g. all those in a workspace); it produces a graphical display showing the hierarchy of which functions call which other ones. This is handy, for instance, when you have a great morass of functions in a workspace, and want to figure out which ones are meant to be called directly. <code>callers.of(funs)</code> and <code>callees.of(funs)</code> show which functions directly call, or are called directly by, <code>funs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foodweb( funs, where=1, charlim=80, prune=character(0), rprune,
    ancestors=TRUE, descendents=TRUE, plotting =TRUE, plotmath=FALSE,
    generics=c( "c","print","plot", "["), lwd=0.5, xblank=0.18,
    border="transparent", boxcolor="white", textcolor="black",
    color.lines=TRUE, highlight="red", ...)
## S3 method for class 'foodweb'
plot(x, textcolor, boxcolor, xblank, border, textargs = list(),
    use.centres = TRUE, color.lines = TRUE, poly.args = list(),
    expand.xbox = 1.05, expand.ybox = expand.xbox * 1.2, plotmath = FALSE,
    cex=par( "cex"), ...) # S3 method for foodweb
callers.of( funs, fw, recursive=FALSE)
callees.of( funs, fw, recursive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foodweb_+3A_funs">funs</code></td>
<td>
<p>character vector OR (in <code>foodweb</code> only) the result of a previous <code>foodweb</code> call</p>
</td></tr>
<tr><td><code id="foodweb_+3A_where">where</code></td>
<td>
<p>position(s) on search path, or an environment, or a list of environments</p>
</td></tr>
<tr><td><code id="foodweb_+3A_charlim">charlim</code></td>
<td>
<p>controls maximum number of characters per horizontal line of plot</p>
</td></tr>
<tr><td><code id="foodweb_+3A_prune">prune</code></td>
<td>
<p>character vector. If omitted, all <code>funs</code> will be shown; otherwise, only ancestors and descendants of functions in <code>prune</code> will be shown. Augments <code>funs</code> if required.</p>
</td></tr>
<tr><td><code id="foodweb_+3A_rprune">rprune</code></td>
<td>
<p>regexpr version of <code>prune</code>; <code>prune &lt;- funs %matching% rprune</code>. Does NOT augment <code>funs</code>. Overrides <code>prune</code> if set.</p>
</td></tr>
<tr><td><code id="foodweb_+3A_ancestors">ancestors</code></td>
<td>
<p>show ancestors of <code>prune</code> functions?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_descendents">descendents</code></td>
<td>
<p>show descendents of <code>prune</code> functions?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_plotting">plotting</code></td>
<td>
<p>graphical display?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_plotmath">plotmath</code></td>
<td>
<p>leave alone</p>
</td></tr>
<tr><td><code id="foodweb_+3A_generics">generics</code></td>
<td>
<p>calls TO functions in <code>generics</code> won't be shown</p>
</td></tr>
<tr><td><code id="foodweb_+3A_lwd">lwd</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="foodweb_+3A_xblank">xblank</code></td>
<td>
<p>leave alone</p>
</td></tr>
<tr><td><code id="foodweb_+3A_border">border</code></td>
<td>
<p>border around name of each object (<code>TRUE/FALSE</code>)</p>
</td></tr>
<tr><td><code id="foodweb_+3A_boxcolor">boxcolor</code></td>
<td>
<p>background colour of each object's text box</p>
</td></tr>
<tr><td><code id="foodweb_+3A_textcolor">textcolor</code></td>
<td>
<p>of each object</p>
</td></tr>
<tr><td><code id="foodweb_+3A_color.lines">color.lines</code></td>
<td>
<p>will linking lines be coloured according to the level they originate at?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_highlight">highlight</code></td>
<td>
<p>seemingly not used</p>
</td></tr>
<tr><td><code id="foodweb_+3A_cex">cex</code></td>
<td>
<p>text size (see &quot;cex&quot; in <code>?par</code>)</p>
</td></tr>
<tr><td><code id="foodweb_+3A_...">...</code></td>
<td>
<p>passed to <code>plot.foodweb</code> and thence to <code>par</code></p>
</td></tr>
<tr><td><code id="foodweb_+3A_textargs">textargs</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="foodweb_+3A_use.centres">use.centres</code></td>
<td>
<p>where to start/end linking lines. <code>TRUE</code> is more accurate but less tidy with big webs.</p>
</td></tr>
<tr><td><code id="foodweb_+3A_expand.xbox">expand.xbox</code></td>
<td>
<p>how much horizontally bigger to make boxes relative to text?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_expand.ybox">expand.ybox</code></td>
<td>
<p>how much vertically bigger to ditto?</p>
</td></tr>
<tr><td><code id="foodweb_+3A_poly.args">poly.args</code></td>
<td>
<p>other args to <code>rect</code> when boxes are drawn</p>
</td></tr>
<tr><td><code id="foodweb_+3A_fw">fw</code></td>
<td>
<p>an object of class <code>foodweb</code>, or the <code>funmat</code> element thereof (see <b>Value</b>)</p>
</td></tr>
<tr><td><code id="foodweb_+3A_x">x</code></td>
<td>
<p>a foodweb (as an argument to <code>plot.foodweb</code>)</p>
</td></tr>
<tr><td><code id="foodweb_+3A_recursive">recursive</code></td>
<td>
<p>(<code>callees.of</code> and <code>callers.of</code> only) whether to include callee/rs of callee/rs of... (Thanks to William Proffitt for this suggestion.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main value is in the graphical display. At the top (&quot;level 0&quot;), functions which don't call any others, and aren't called by any others, are shown without any linking lines. Functions which do call others, but aren't called themselves, appear on the next layer (&quot;level 1&quot;), with lines linking them to functions at other levels. Functions called only by level 1 functions appear next, at level 2, and so on. Functions which call each other will always appear on the same level, linked by a bent double arrow above them. The colour of a linking line shows what level of the hierarchy it came from.
</p>
<p><code>foodweb</code> makes some effort to arrange the functions on the display to keep the number of crossing lines low, but this is a hard problem! Judicious use of <code>prune</code> will help keep the display manageable. Perhaps counterintuitively, any functions NOT linked to those in <code>prune</code> (which all will be, by default) will be pruned from the display.
</p>
<p><code>foodweb</code> tries to catch names of functions that are stored as text, and it will pick up e.g. <code>glm</code> in <code>do.call( "glm", glm.args)</code>. There are limits to this, of course (?methods?).
</p>
<p>The argument list may be somewhat daunting, but the only ones normally used are <code>funs</code>, <code>where</code>, and <code>prune</code>. Also, to get a readable display, you may need to reduce <code>cex</code> and/or <code>charlim</code>. A number of the less-obvious arguments are set by other functions which rely on <code>plot.foodweb</code> to do their display work. Several may disappear in future versions.
</p>
<p>If the display from <code>foodweb</code> is unclear, try <code>foodweb( .Last.value, cex=&lt;&lt;something below 1&gt;&gt;, charlim=&lt;&lt;something probably less than 100&gt;&gt;)</code>. This works because <code>foodweb</code> will also accept a <code>foodweb</code>-class object as its argument. You can also assign the result of <code>foodweb</code> to a variable, which is useful if you expect to do a lot of tinkering with the display, or to inspect the who-calls-whom matrix by hand.
</p>
<p><code>callers.of</code> and <code>callees.of</code> process the output of <code>foodweb</code>, looking for immediate dependencies only. The second argument will call <code>foodweb</code> by default, so it may be more efficient to call <code>foodweb</code> first and assign the result to a variable. NB you can set <code>recursive=TRUE</code> for the obvious result.
</p>


<h4>Bug in rgui windows graphics</h4>

<p>When plotting the foodweb, there's a display bug in Rgui for windows which somehow causes the fontsize to shrink in each successive calls! Somehow <code>par("ps")</code> keeps on shrinking. Indeed, on my own machines, calling <code>par(ps=par("ps"))$ps</code> will show a decreasing value each time... Working around this was very tricky; variants of saving/restoring <code>par</code> <em>inside</em> <code>plot.foodweb</code> do not work. As of package <span class="pkg">mvbutils</span> version 2.8.142, there's an attempted fix directly in <code>foodweb</code>, but conceivably the fixe will somehow cause problems for other people using default graphics windows in Rgui. Let me know if that's you... (in which case I'll add an <code>option()</code> to not apply the fix).
</p>



<h3>Value</h3>

<p><code>foodweb</code> returns an object of (S3) class <code>foodweb</code>. This has three components:
</p>
<table role = "presentation">
<tr><td><code>funmat</code></td>
<td>
<p>a matrix of 0s and 1s showing what (row) calls what (column). The <code>dimnames</code> are the function names.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>shows the x-axis location of the centre of each function's name in the display, in <code>par("usr")</code> units</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>shows the y-axis location of the centre of each function's name in the display, in <code>par("usr")</code> units. For small numbers of functions, this will be an integer; for larger numbers, there will some adjustment around the nearest integer</p>
</td></tr>
</table>
<p>Apart from graphical annotation, the main useful thing is <code>funmat</code>, which can be used to work out the &quot;pecking order&quot; and e.g. which functions directly call a given function. <code>callers.of</code> and <code>callees.of</code> return a character vector of function names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foodweb( ) # functions in .GlobalEnv
# I have had to trim this set of examples because CRAN thinks it's too slow...
# ... though it's only 5sec on my humble laptop. So...
## Not run: 
foodweb( where="package:mvbutils", cex=0.4, charlim=60) # yikes!
foodweb( c( find.funs("package:mvbutils"), "paste"))
# functions in .GlobalEnv, and "paste"
foodweb( find.funs("package:mvbutils"), prune="paste")
# only those parts of the tree connected to "paste";
# NB that funs &lt;- unique( c( funs, prune)) inside "foodweb"
foodweb( where="package:mvbutils", rprune="aste")
# doesn't include "paste" as it's not in "mvbutils", and rprune doesn't augment funs
foodweb( where=asNamespace( "mvbutils")) # secret stuff
fw &lt;- foodweb( where="package:mvbutils")

## End(Not run)
fw &lt;- foodweb( where=asNamespace( "mvbutils")) # also plots
fw$funmat # a big matrix
callers.of( "mlocal", fw)
callees.of( "find.funs", fw)
# ie only descs of functions whose name contains 'name'
foodweb( where=asNamespace( 'mvbutils'), rprune="name", ancestors=FALSE, descendents=TRUE)
</code></pre>

<hr>
<h2 id='full.path'>Expand relative file path</h2><span id='topic+full.path'></span>

<h3>Description</h3>

<p><code>path</code> is expanded relative to <code>start</code>, with any <code>.</code> being eliminated and any <code>..</code> being treated as &quot;go back one step&quot;. If <code>path</code> doesn't start with a <code>.</code> or <code>..</code>, <code>start</code> is ignored. Might be Windows-specific but probably fairly safe in general. NB that all separators in <code>path</code> and <code>start</code> must be &quot;/&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full.path(path, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full.path_+3A_path">path</code></td>
<td>
<p>character(1)</p>
</td></tr>
<tr><td><code id="full.path_+3A_start">start</code></td>
<td>
<p>character(1), defaulting to <code>.</code></p>
</td></tr>
</table>

<hr>
<h2 id='generic.dll.loader'>Convenient automated loading of DLLs</h2><span id='topic+generic.dll.loader'></span><span id='topic+create.wrappers.for.dll'></span><span id='topic+ldyn.tester'></span><span id='topic+ldyn.unload'></span>

<h3>Description</h3>

<p><code>generic.dll.loader</code> is to be called from the <code>.onLoad</code> of a package. It calls <code>library.dynam</code> on all the DLLs it can find in the &quot;libs&quot; folder (so you don't need to specify their names), or in the appropriate sub-architecture folder below &quot;libs&quot;. It also creates &quot;R aliasses&quot; in your namespace for all the <em>registered</em> low-level routines in each DLL (i.e. those returned by <code>getDLLRegisteredRoutines</code>, qv), so that the routines can be called efficiently later on from your code&mdash; see <b>Details</b>.
</p>
<p>If you just want to use <code>mvbutils</code> to help build/maintain your package, and don't need your package to import/depend on other functions in <code>mvbutils</code>, then it's fine to just copy the code from <code>generic.dll.loader</code> etc and put it directly into your own <code>.onLoad</code>.
</p>
<p><code>ldyn.tester</code>, <code>create.wrappers.for.dll</code>, and <code>ldyn.unload</code> are to help you develop a DLL that has fully-registered routines, without immediately having to create an R package for it. <code>ldyn.tester</code> loads a DLL and returns its registration info. The DLL must be in a folder <code>.../libs/&lt;subarch&gt;</code> where <code>&lt;subarch&gt;</code> is <code>.Platform$r_arch</code> iff that is non-empty; this is because <code>ldyn.tester</code> merely tricks <code>library.dynam</code> into finding a spurious &quot;package&quot;, and that's the folder structure that <code>library.dynam</code> needs to see. <code>create.wrappers.for.dll</code> does the alias-creation mentioned above for <code>generic.dll.loader</code>. <code>ldyn.unload</code> unloads the DLL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Only call this inside your .onLoad!
generic.dll.loader(libname, pkgname, ignore_error=FALSE)
# Only call these if you are informally developing a DLL outside a package
ldyn.tester(chname)
create.wrappers.for.dll( this.dll.info, ns=new.env( parent=parent.frame(2)))
ldyn.unload( l1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generic.dll.loader_+3A_libname">libname</code>, <code id="generic.dll.loader_+3A_pkgname">pkgname</code></td>
<td>
<p>as per <code>.onLoad</code></p>
</td></tr>
<tr><td><code id="generic.dll.loader_+3A_ignore_error">ignore_error</code></td>
<td>
<p>?continue to load other DLLs if one fails?</p>
</td></tr>
<tr><td><code id="generic.dll.loader_+3A_chname">chname</code></td>
<td>
<p>(for <code>ldyn.tester</code>) Path to the DLL (extension not required)</p>
</td></tr>
<tr><td><code id="generic.dll.loader_+3A_this.dll.info">this.dll.info</code></td>
<td>
<p>(for <code>create.wrappers.for.dll</code>) A <code>DLLInfo</code> object, as returned by <code>.dynLibs()[[N]]</code> or <code>library.dynam(...)</code></p>
</td></tr>
<tr><td><code id="generic.dll.loader_+3A_ns">ns</code></td>
<td>
<p>(for <code>create.wrappers.for.dll</code>) If you're calling <code>create.wrappers.for.dll</code> manually, then this defaults to the calling environment, probably <code>.GlobalEnv</code>. For &quot;internal use&quot;, <code>ns</code> is meant to be a namespace, but you shouldn't be using it like that!</p>
</td></tr>
<tr><td><code id="generic.dll.loader_+3A_l1">l1</code></td>
<td>
<p>(for <code>ldyn.unload</code>) Result of previous call to <code>ldyn.tester</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>R-callable aliasses for your low-level routines will be called e.g. <code>C_myrout1</code>, <code>Call_myrout2</code>, <code>F_myrout3</code>, or <code>Ext_myrout4</code>, depending on type. Those for routines in &quot;myfirstdll&quot; will be stored in the environment <code>LL_myfirstdll</code> (&quot;Low Level&quot;) in your package's namespace, which itself inherits from the namespace. In your own R code elsewhere in your package, you can then have something like
</p>
<pre>
  .C( LL_myfirstdll$C_myrout1, &lt;&lt;arguments&gt;&gt;) # NB no need for PACKAGE argument
</pre>
<p>Getting fancy, you can alternatively set the environment of your calling function to <code>LL_myfirstdll</code> (which inherits from the namespace, so all your other functions are still visible). In that case, you can just write
</p>
<pre>
  .C( C_myrout1, &lt;&lt;arguments&gt;&gt;)
</pre>


<h3>Value</h3>

<p><code>generic.dll.loader</code> returns NULL (but see <b>Details</b>).
<code>ldyn.tester</code> returns a class &quot;DLLInfo&quot; object if successful. <code>ldyn.unload</code> should return NULL if successful, and crash otherwise.
<code>create.wrappers.for.dll</code> returns the environment containing the aliasses.
Be careful with accidentally saving and loading the results of <code>ldyn.tester</code> and <code>create.wrappers.for.dll</code>; they won't be valid in a new R session. You might be better off creating them in the <code>mvb.session.info</code> environment on the search path; they will still be found, but won't persist in a different R session. See <b>Examples</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.finalizer">set.finalizer</a></code> for a safe way to ensure cleanup after low-level routines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mypack:::.onLoad &lt;- function( libname, pkgname) generic.dll.loader( libname, pkgname)
#... or just copy the code into your .onLoad
# For casual testing of a DLL that's not yet in a package
dl &lt;- ldyn.tester( 'path/to/my/dll/libs/i386/mydll.dll')
getDLLRegisteredRoutines( l1)
LL_mydll &lt;- create.wrappers.for.dll( dl)
.C( LL_mydll$C_rout1, as.integer( 0)) # ... whatever!
ldyn.unload( dl)
# Safer because not permanent:
assign( 'dl', ldyn.tester( 'path/to/my/dll/libs/i386/mydll.dll'), pos='mvb.session.info')
assign( 'LL_mydll', create.wrappers.for.dll( dl), pos='mvb.session.info')
.C( LL.mydll$C_rout1, as.integer( 0)) # ... whatever!

## End(Not run)
</code></pre>

<hr>
<h2 id='get.backup'>Text backups of function source code</h2><span id='topic+get.backup'></span><span id='topic+create.backups'></span><span id='topic+read.bkind'></span>

<h3>Description</h3>

<p><code>get.backup</code> retrieves backups of a function or character object. <code>create.backups</code> creates backup files for all hitherto-unbacked-up functions in a search environment. For <code>get.backup</code> to work, all backups must have been created using the <code><a href="#topic+fixr">fixr</a></code> system (or <code>create.backups</code>). <code>read.bkind</code> shows the names of objects with backups, and gives their associated filenames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.backup( name, where=1, rev=TRUE, zap.name=TRUE, unlength=TRUE)
create.backups( pos=1)
read.bkind( where=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.backup_+3A_name">name</code></td>
<td>
<p>function name (character)</p>
</td></tr>
<tr><td><code id="get.backup_+3A_where">where</code>, <code id="get.backup_+3A_pos">pos</code></td>
<td>
<p>position in search path (character or numeric), or e.g. <code>..mypack</code> for maintained package <span class="pkg">mypack</span>.</p>
</td></tr>
<tr><td><code id="get.backup_+3A_rev">rev</code></td>
<td>
<p>if TRUE, most recent backup comes first in the return value</p>
</td></tr>
<tr><td><code id="get.backup_+3A_zap.name">zap.name</code></td>
<td>
<p>if TRUE, the tag <code>"funname" &lt;- </code> at the start of each backup is removed</p>
</td></tr>
<tr><td><code id="get.backup_+3A_unlength">unlength</code></td>
<td>
<p>if TRUE, the first line of each backup is removed iff it consists only of a number equal to 1+length( object). This matches the (current) format of character object backups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+fixr">fixr</a></code> and <code><a href="#topic+FF">FF</a></code> are able to maintain text-file backups of source code, in a directory &quot;.Backup.mvb&quot; below the task directory. The directory will contain a file called &quot;index&quot;, plus files BU1, BU2, etc. &quot;index&quot; shows the correspondence between function names and BUx files. Each BUx file contains multiple copies of the source code, with the oldest first. Even if a function is removed (or <code><a href="#topic+move">move</a></code>d) from the workspace, its BUx file and &quot;index&quot; entry are not deleted.
</p>
<p>The number of backups kept is controlled by <code>options(backup.fix)</code>, a numeric vector of length 2. The first element is how many backups to keep from the current R session. The second is how many previous R sessions to keep the final version of the source code from. Older versions get discarded. I use <code>c(5,2)</code>. If you want to use the backup facility, you'll need to set this option in your <code>.First</code>. If the option is not set, no backups happen. If set, then every call to <code><a href="#topic+Save">Save</a></code> or <code><a href="#topic+Save.pos">Save.pos</a></code> will create backups for all previously-unbackupped functions, by automatically calling <code>create.backups</code>. <code>create.backups</code> can also be called manually, to create the backup directory, index, and backup files for all functions in the currently-top task.
</p>
<p><code>get.backup</code> returns all available backup versions as <b>character vectors</b>, by default with the most recent first. To turn one of these character vectors into a function, a <code>source</code> step is needed; see <b>Examples</b>.
</p>
<p><code>read.bkind</code> shows which file to look for particular backups in. These files are text-format, so you can look at one in a text editor and manually extract the parts you want. You can also use <code>read.bkind</code> to set up a restoration-of-everything, as shown in <b>Examples</b>. I deliberately haven't included a function for mass restoration in <code>mvbutils</code>, because it's too dangerous and individual needs vary.
</p>
<p>Currently there is no automatic way to determine the type of a backed-up object. All backups are stored as text, so text objects look very similar to functions. However, the first line of a text object is just a number equal to the length of the text object; the first line of a function object starts with &quot;function(&quot; or &quot;structure( function(&quot;. The examples show one way to distinguish automatically.
</p>
<p>The function <code><a href="#topic+fix.order">fix.order</a></code> uses the access dates of backup files to list your functions sorted by date order.
</p>
<p><code><a href="#topic+move">move</a></code> will also move backup files and update INDEX files appropriately.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>get.backup</code></td>
<td>
<p>Either NULL with a warning, if no backups are found, or a list containing the backups, each as a character vector.</p>
</td></tr>
<tr><td><code>create.backups</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>read.bkind</code></td>
<td>
<p>a list with components <code>files</code> and <code>object.names</code>; these are character vector with elements in 1-1 correspondence. Some of the objects named may not currently exist in <code>where</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+cd">cd</a></code>, <code><a href="#topic+move">move</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Need some backups first
# Restore a function:
g1 &lt;- get.backup( "myfun", "package:myfun")[[1]] # returns most recent backup only
# To turn this into an actual function (with source attribute as per your formatting):
myfun &lt;- source.mvb( textConnection( g1)) # would be nice to have an self-closing t.c.
cat( get.backup( "myfun", "package:myfun", zap=FALSE)[[1]][1])
# shows "myfun" &lt;- function...
# Restore a character vector:
mycharvec &lt;- as.cat( get.backup( 'mycharvec', ..mypackage)[[1]]) # ready to roll
# Restore most recent backup of everything... brave!
# Will include functions &amp; charvecs that have subsequently been deleted
bks &lt;- read.bkind() # in current task
for( i in bks$object.names) {
  cat( "Restoring ", i, "...")
  gb &lt;- get.backup( i, unlength=FALSE)[[1]] # unlength F so we can check type
  # Is it a charvec?
  if( grepl( '^ *[0-9]+ *$', gb[1])) # could check length too
    gb &lt;- as.cat( gb[-1]) # remove line showing length and...
    # ...set class to "cat" for nice printing, as per 'as.cat'
  else {
    # Nope, so it's a function and needs to be sourced
    tc &lt;- textConnection( gb)
    gbfun &lt;- try( source.mvb( gb)) # will set source attribute, documentation etc.
    close( tc)
    if( gbfun %is.a% "try-error") {
      gbfun &lt;- stop( function( ...) stop( ii %&amp;% " failed to parse"), list( ii=i))
      attr( gbfun, 'source') &lt;- gb # still assign source attribute
    }
    gb &lt;- gbfun
  }
  assign( i, gb)
  cat( '\n')
}

## End(Not run)
</code></pre>

<hr>
<h2 id='hack'>Modify standard R functions, including tweaking their default arguments</h2><span id='topic+hack'></span><span id='topic+assign.to.base'></span>

<h3>Description</h3>

<p>You probably shouldn't use these... <code>hack</code> lets you easily change the argument defaults of a function. <code>assign.to.base</code> replaces a function in <code>base</code> or <code>utils</code> (or any other package and its namespace and S3 methods table) with a modified version, possibly produced by <code>hack</code>. Package <span class="pkg">mvbutils</span> uses these two to change the default position for library attachment, etc; see the code of <code>mvbutils:::.onLoad</code>.
</p>
<p>Note that, if you call <code>assign.to.base</code> during the <code>.onLoad</code> of your package, then it must be called <em>directly</em> from the <code>.onLoad</code>, not via an intermediate function; otherwise, it won't correctly reset its argument in the import-environment of your namespace. To get round this, wrap it in an <code><a href="#topic+mlocal">mlocal</a></code>; see <code>mvbutils:::.onLoad</code> for an example.
</p>
<p><code>assign.to.base</code> is only meant for changing things in packages, e.g. not for things that merely sit in non-package environments high on the search path (where <code>&lt;&lt;-</code> should work). I don't know how it will behave if you try. It won't work for S4 methods, either.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hack( fun, ...)
 assign.to.base( x, what=,  where=-1, in.imports=, override.env = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_+3A_fun">fun</code></td>
<td>
<p>a function (not a character string)</p>
</td></tr>
<tr><td><code id="hack_+3A_...">...</code></td>
<td>
<p>pairlist of arguments and new default values, e.g. arg1=1+2. Things on RHS of equal signs will <b>not</b> be evaluated.</p>
</td></tr>
<tr><td><code id="hack_+3A_x">x</code></td>
<td>
<p>function name (a character string)</p>
</td></tr>
<tr><td><code id="hack_+3A_what">what</code></td>
<td>
<p>function to replace <code>x</code>, defaulting to <code>"replacement." %&amp;% x</code></p>
</td></tr>
<tr><td><code id="hack_+3A_where">where</code></td>
<td>
<p>where to find the replacement function, defaulting to usual search path</p>
</td></tr>
<tr><td><code id="hack_+3A_in.imports">in.imports</code></td>
<td>
<p>usually TRUE, if this is being called from an <code>.onLoad</code> method in a namespace. Make sure any copies of the function to be changed that are in the &quot;imports&quot; namespace also get changed. See <b>Description</b>.</p>
</td></tr>
<tr><td><code id="hack_+3A_override.env">override.env</code></td>
<td>
<p>should the replacement use its own environment, or (by default) the one that was originally there?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hack( dir, all.files=getOption( "ls.all.files", TRUE)) # from my '.First'
assign.to.base( "dir", hack( dir, all.files=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='help'>The R help system</h2><span id='topic+help'></span><span id='topic++3F'></span>

<h3>Description</h3>

<p><code>?x</code> is the usual way to get help on <code>x</code>; it's primarily a shortcut for <code>help(x)</code>. There are rarer but more flexible variations, such as <code>x?y</code> or <code>help(x,...)</code>. See base-R help on help. The versions of <code>help</code> and <code>?</code> exported by <code>mvbutils</code> behave exactly the same as base-R, unless base-R <code>help</code> <em>fails</em> after being called with a single argument, e.g. <code>help(topic)</code>. In that case, if <code>topic</code> is an object with an attribute called &quot;doc&quot; (or failing that if <code>topic</code> or <code>topic.doc</code> is a character vector), then the attribute (or the character object) will be formatted and displayed by the pager (by default) or browser. This lets you write informal documentation for non-package objects that can still be found by <code>help</code>, and by colleagues you distribute your code to. See <code><a href="#topic+dochelp">dochelp</a></code> for more information. The rest of this documentation is copied directly from base-R for <code>help</code>, except as noted under <b>Arguments</b> for <code>help_type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>help(topic, package = NULL, lib.loc = NULL,
     verbose = getOption("verbose"),
     try.all.packages = getOption("help.try.all.packages"),
     help_type = getOption("help_type"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="help_+3A_topic">topic</code></td>
<td>
<p>usually, a name or character string specifying the topic for which help is sought. A character string (enclosed in explicit single or double quotes) is always taken as naming a topic. If the value of <code>topic</code> is a length-one character vector the topic is taken to be the value of the only element. Otherwise <code>topic</code> must be a name or a reserved word (if syntactically valid) or character string. See <b>Details</b> for what happens if this is omitted.</p>
</td></tr>
<tr><td><code id="help_+3A_package">package</code></td>
<td>
<p>a name or character vector giving the packages to look into for documentation, or <code>NULL</code>. By default, all packages in the search path are used. To avoid a name being deparsed use e.g. <code>(pkg_ref)</code> (see the examples).</p>
</td></tr>
<tr><td><code id="help_+3A_lib.loc">lib.loc</code></td>
<td>
<p>a character vector of directory names of R libraries, or <code>NULL</code>. The default value of <code>NULL</code> corresponds to all libraries currently known. If the default is used, the loaded packages are searched before the libraries. This is not used for HTML help (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="help_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the file name is reported.</p>
</td></tr>
<tr><td><code id="help_+3A_try.all.packages">try.all.packages</code></td>
<td>
<p>logical; see <b>Note</b>.</p>
</td></tr>
<tr><td><code id="help_+3A_help_type">help_type</code></td>
<td>
<p>character string:the type of help required. Possible values are &quot;text&quot;, &quot;html&quot; and &quot;pdf&quot;. Case is ignored, and partial matching is allowed. [Note that, for informal doco, <code>getOption( mvb_help_type, "text")</code> is used; i.e., the default there is always the pager, which lets you be as informal as you please.]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following types of help are available:
</p>

<ul>
<li><p> Plain text help
</p>
</li>
<li><p> HTML help pages with hyperlinks to other topics, shown in a browser by <code>browseURL</code>. If for some reason HTML help is unavailable (see <code><a href="tools.html#topic+startDynamicHelp">startDynamicHelp</a></code>), plain text help will be used instead.
</p>
</li>
<li><p> For <code>help</code> only, typeset as PDF - see the section on <b>Offline help</b>.
</p>
</li></ul>

<p>The default for the type of help is selected when R is installed - the <code>factory-fresh</code> default is HTML help.
</p>
<p>The rendering of text help will use directional quotes in suitable locales (UTF-8 and single-byte Windows locales): sometimes the fonts used do not support these quotes so this can be turned off by setting <code>options(useFancyQuotes = FALSE)</code>.
</p>
<p><code>topic</code> is not optional. If it is omitted, R will give:
</p>

<ul>
<li><p> If a package is specified, (text or, in interactive use only, HTML) information on the package, including hints/links to suitable help topics.
</p>
</li>
<li><p> If <code>lib.loc</code> only is specified, a (text) list of available packages.
</p>
</li>
<li><p> Help on <code>help</code> itself if none of the first three arguments is specified.
</p>
</li></ul>

<p>Some topics need to be quoted (by backticks) or given as a character string. These include those which cannot syntactically appear on their own such as unary and binary operators, <code>function</code> and control-flow reserved words (including <code>if</code>, <code>else</code> <code>for</code>, <code>in</code>, <code>repeat</code>, <code>while</code>, <code>break</code> and <code>next</code>). The other <code>reserved</code> words can be used as if they were names, for example <code>TRUE</code>, <code>NA</code> and <code>Inf</code>.
</p>
<p>If multiple help files matching <code>topic</code> are found, in interactive use a menu is presented for the user to choose one: in batch use the first on the search path is used. (For HTML help the menu will be an HTML page, otherwise a graphical menu if possible if <code>getOption("menu.graphics")</code> is true, the default.)
</p>
<p>Note that HTML help does not make use of <code>lib.loc</code>: it will always look first in the attached packages and then along <code>libPaths()</code>.
</p>


<h3>Offline help</h3>

<p>Typeset documentation is produced by running the LaTeX version of the help page through <code>pdflatex</code>: this will produce a PDF file.
</p>
<p>The appearance of the output can be customized through a file <code>Rhelp.cfg</code> somewhere in your LaTeX search path: this will be input as a LaTeX style file after <code>Rd.sty</code>. Some environment variables are consulted, notably <code>R_PAPERSIZE</code> (<em>via</em> <code>getOption("papersize")</code>) and <code>R_RD4PDF</code> (see <code>Making manuals</code> in the <code>R Installation and Administration Manual</code>).
</p>
<p>If there is a function <code>offline_help_helper</code> in the workspace or further down the search path it is used to do the typesetting, otherwise the function of that name in the <code>utils</code> namespace (to which the first paragraph applies). It should accept at least two arguments, the name of the LaTeX file to be typeset and the type (which as from R 2.15.0 is ignored). As from R 2.14.0 it should accept a third argument, <code>texinputs</code>, which will give the graphics path when the help document contains figures, and will otherwise not be supplied.
</p>


<h3>Note</h3>

<p>Unless <code>lib.loc</code> is specified explicitly, the loaded packages are searched before those in the specified libraries. This ensures that if a library is loaded from a library not in the known library trees, then the help from the loaded library is used. If <code>lib.loc</code> is specified explicitly, the loaded packages are <em>not</em> searched.
</p>
<p>If this search fails and argument <code>try.all.packages</code> is <code>TRUE</code> and neither <code>packages</code> nor <code>lib.loc</code> is specified, then all the packages in the known library trees are searched for help on <code>topic</code> and a list of (any) packages where help may be found is displayed (with hyperlinks for <code>help_type = "html"</code>). <b>NB:</b> searching all packages can be slow, especially the first time (caching of files by the OS can expedite subsequent searches dramatically).
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>?</code> for shortcuts to help topics.
</p>
<p><code><a href="#topic+dochelp">dochelp</a></code> for how to write informal help with <code>mvbutils</code>.
</p>
<p><code>help.search()</code> or <code>??</code> for finding help pages on a vague topic; <code>help.start()</code> which opens the HTML version of the R help pages; <code>library()</code> for listing available packages and the help objects they contain; <code>data()</code> for listing available data sets; <code>methods()</code>.
</p>
<p>Use <code>prompt()</code> to get a prototype for writing <code>help</code> pages of your own package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>help()
help(help)              # the same
help(lapply)
help("for")             # or ?"for", but quotes/backticks are needed
help(package="splines") # get help even when package is not loaded
topi &lt;- "women"
help(topi)
try(help("bs", try.all.packages=FALSE)) # reports not found (an error)
help("bs", try.all.packages=TRUE)       # reports can be found
                                        # in package 'splines'
## For programmatic use:
topic &lt;- "family"; pkg_ref &lt;- "stats"
help((topic), (pkg_ref))
</code></pre>

<hr>
<h2 id='help2flatdoc'>Convert help files to flatdoc format.</h2><span id='topic+help2flatdoc'></span>

<h3>Description</h3>

<p>Converts a vanilla R help file (as shown in the internal pager) to plain-text format. The output conventions are those in <code><a href="#topic+doc2Rd">doc2Rd</a></code>, so the output can be turned into Rd-format by running it through <code><a href="#topic+doc2Rd">doc2Rd</a></code>. This function is useful if you have existing Rd-format documentation and want to try out the <code><a href="#topic+flatdoc">flatdoc</a></code> system of integrated code and documentation. Revised Nov 2017: now pretty good, but not perfect; see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> help2flatdoc( fun.name, pkg=NULL, text=NULL, aliases=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="help2flatdoc_+3A_fun.name">fun.name</code></td>
<td>
<p>function name (a character string)</p>
</td></tr>
<tr><td><code id="help2flatdoc_+3A_pkg">pkg</code></td>
<td>
<p>name of package</p>
</td></tr>
<tr><td><code id="help2flatdoc_+3A_text">text</code></td>
<td>
<p>plain-text help</p>
</td></tr>
<tr><td><code id="help2flatdoc_+3A_aliases">aliases</code></td>
<td>
<p>normally leave this empty&mdash; see <b>Details</b>.</p>
</td></tr>
</table>
<p>The real argument is <code>text</code>; if missing, this is deduced from the help for <code>fun.name</code> (need not be a function) in the installed package <span class="pkg">pkg</span>.
</p>


<h3>Details</h3>

<p>The package containing <code>fun.name</code> must be loaded first. If you write documentation using <code><a href="#topic+flatdoc">flatdoc</a></code>, prepare the package with <code><a href="#topic+pre.install">pre.install</a></code>, build it with RCMD BUILD or INSTALL, and run <code>help2flatdoc</code> on the result, you should largely recover your original flat-format documentation. Some exceptions:
</p>

<ul>
<li><p> Nesting in lists is ignored.
</p>
</li>
<li><p> Numbered lists won't convert back correctly (Nov 2017), but the problem there is in <code><a href="#topic+doc2Rd">doc2Rd</a></code>.
</p>
</li>
<li><p> Link-triggering phrases (i.e. that will be picked up by <code><a href="#topic+doc2Rd">doc2Rd</a></code>, such as &quot;see &lt;blah&gt;&quot;) aren't explicitly created&ndash; probably, links could be automated better via an argument to <code><a href="#topic+doc2Rd">doc2Rd</a></code>.
</p>
</li></ul>

<p>Aliases (i.e. if this doco can be found by <code><a href="#topic+help">help</a></code> under several different names) are deduced from function calls in the <b>Usage</b> section, in addition to anything supplied specifically in the <code>alias</code> argument. The latter is really just meant for internal use by <code><a href="#topic+unpackage">unpackage</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+doc2Rd">doc2Rd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cd.doc &lt;- help2flatdoc( "cd", "mvbutils")
print( cd.doc)
cd.Rd &lt;- doc2Rd( cd.doc)
</code></pre>

<hr>
<h2 id='install.pkg'>Package building, distributing, and checking</h2><span id='topic+install.pkg'></span><span id='topic+build.pkg'></span><span id='topic+build.pkg.binary'></span><span id='topic+check.pkg'></span><span id='topic+cull.old.builds'></span><span id='topic+set.rcmd.vars'></span>

<h3>Description</h3>

<p>These are convenient wrappers for R's package creation and installation tools. They are designed to be used on packages created from tasks via <code>mvbutils</code> package, specifically <code><a href="#topic+pre.install">pre.install</a></code> (though they can be used for &quot;home-made&quot; packages). The <code>mvbutils</code> approach deliberately makes re-installation a rare event, and one call to <code>install.pkg</code> might suffice for the entire life of a simple package. After that very first installation, you'd probably only need to call <code>install.pkg</code> if (when...) new versions of R entail re-installation of packages, and <code>build.pkg/build.pkg.binary/check.pkg</code> when you want to give your package to others, either directly or via CRAN etc.
</p>


<h4>Folders</h4>

<p>Source packages and built packages go into various folders, depending on various things. Normally you shouldn't have to mess around with the folder structure, but you will still need to <em>know</em> where built packages are put so that you can send them to other people. Specifically, these <code>...pkg...</code> functions work in the highest-versioned &quot;Rx.y&quot; folder that is not newer than the <em>running</em> R version. If no such folder exists, then 'build.pkg/build.pkg.binary&quot; will create one from the running R version; you can also create such a folder manually, as a kind of &quot;checkpoint&quot;, when you want to make your package dependent on a specific R version. See &quot;Folders and R versions&quot; in <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code> for full details.
</p>
<p>There are also two minor housekeeping functions: <code>cull.old.builds</code> to tidy up detritus, and <code>set.rcmd.vars</code> which does absolutely nothing (yet). <code>cull.old.builds</code> looks through <em>all</em> &quot;Rx.y&quot; folders (where built packages live) and deletes the least-recent &quot;.tar.gz&quot; and &quot;.zip&quot; files in each (regardless of which built package versions are in the other &quot;Rx.y&quot; folders).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>  # Usually: build.pkg( mypack) etc
  install.pkg( pkg, character.only=FALSE, lib=.libPaths()[1], flags=character(0),
      multiarch=NA, preclean=TRUE)
  build.pkg( pkg, character.only=FALSE, flags=character(0), cull.old.builds=TRUE)
  build.pkg.binary( pkg, character.only=FALSE, flags=character(0),
      cull.old.builds=TRUE, multiarch=NA, preclean=TRUE)
  check.pkg( pkg, character.only=FALSE, build.flags=character(0),
      check.flags=character( 0), CRAN=FALSE)
  cull.old.builds( pkg, character.only=FALSE)
  set.rcmd.vars( ...) # NYI; ...
  # ... if you need to set env vars eg PATH for R CMD to work,  then...
  # ... you have to do so yourself; see *Details*
</code></pre>


<h3>Arguments</h3>

<p>See the examples
</p>
<table role = "presentation">
<tr><td><code id="install.pkg_+3A_pkg">pkg</code></td>
<td>
<p>usually an unquoted package name, but interpretation can be changed by non-default <code>character.only</code>. You can also get away with eg <code>..mypack</code>, ie a direct reference to the maintained package. A folder name can also be used, for a non-mvbutils-maintained package. Just as if it was &quot;maintained&quot;, the folder should contain a subfolder with the (same) package name and the real package contents (eg &quot;c:/r/mypack/mypack/DESCRIPTION&quot; should exist), and any built things will go into eg &quot;c:/r/mypack/R3.2&quot;</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_character.only">character.only</code></td>
<td>
<p>default FALSE. If TRUE, treat <code>pkg</code> as a normal object, which should therefore be a string containing the package's name. If <code>character.only</code> is itself a string, it will override <code>pkg</code> and be treated as the name of the package.</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_lib">lib</code></td>
<td>
<p>(<code>install.pkg</code> only) where to install to; default is the same place R would install to, i.e. <code>.libPaths()[1]</code>.</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_flags">flags</code></td>
<td>
<p>character vector, by default empty. Any entries should be function-specific flags, such as &quot;&ndash;md5&quot; for <code>build.pkg</code>. It will be passed through <code>paste( flags, collapse=" ")</code>, so you can supply flags individually (eg <code>flags=c( "--md5", "--compact.vignettes")</code>) or jointly (eg <code>flags="--md5 --compact.vignettes"</code>).</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_build.flags">build.flags</code>, <code id="install.pkg_+3A_check.flags">check.flags</code></td>
<td>
<p>(<code>check.pkg</code> only) as per <code>flags</code> but for the two separate parts of <code>check.pkg</code> (see <b>Details</b>). <code>check.flags</code> is overridden if <code>CRAN==TRUE</code>'.</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_preclean">preclean</code></td>
<td>
<p>adds flag &quot;&ndash;preclean&quot; if TRUE (the default); this is probably a good idea since one build-failure can otherwise cause R to keep failing to build.</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_multiarch">multiarch</code></td>
<td>
<p>Adds flag &quot;-no-multiarch&quot; if FALSE. Defaults to TRUE unless &quot;Biarch:FALSE&quot; is found in the DESCRIPTION. Default used to be FALSE when I was unable to get 64bit versions to build. Now I mostly can (after working round BINPREF64 bug in R3.3.something by futzing around in etc/arch/Makeconf based on random internet blogs).</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_cull.old.builds">cull.old.builds</code></td>
<td>
<p>self-explanatory</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_cran">CRAN</code></td>
<td>
<p>(<code>check.pkg</code> only) if TRUE, set the <code>--as-cran</code> flag to &quot;RCMD check&quot; and unset all other check flags (except library locations, which are set automatically by all these functions). Note that this will cause R to check various internet databases, and so can be slow.</p>
</td></tr>
<tr><td><code id="install.pkg_+3A_...">...</code></td>
<td>
<p>name-value pairs of system environment variables (not used for now)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before doing any of this, you need to have used <code><a href="#topic+pre.install">pre.install</a></code> to create a source package. (Or <code><a href="#topic+patch.install">patch.install</a></code>, if you've done all this before and just want to re-install/build/check for some reason.)
</p>
<p>The only environment variable currently made known to R CMD is R_LIBS&ndash; let me know if others would be useful.
</p>
<p><code>install.pkg</code> calls &quot;R CMD INSTALL&quot; to install from a source package.
</p>
<p><code>build.pkg</code> calls &quot;R CMD build&quot; to wrap up the source package into a &quot;tarball&quot;, as required by CRAN and also for distribution to non-Windows-and-Mac platforms.
</p>
<p><code>build.pkg.binary</code> (Windows &amp; Mac only) calls &quot;R CMD INSTALL &ndash;build&quot; to generate a binary package. A temporary installation directory is used, so your existing installation is <em>not</em> overwritten or deleted if there's a problem; R CMD INSTALL &ndash;build has a nasty habit of doing just that unless you're careful, which <code>build.pkg.binary</code> is.
</p>
<p><code>check.pkg</code> calls &quot;R CMD check&quot; after first calling <code>build.pkg</code> (more efficiently, I should perhaps try to work out whether there's an up-to-date tarball already). It doesn't delete the tarball afterwards. It <em>may</em> also be possible for you to do some checks directly from R via functions in the <span class="pkg">utils</span> package, which is potentially a lot quicker. However, NB the possibility of interference with your current R session. For example, at one stage <code>codoc</code> (which is the only check that I personally find very useful) tried to unload &amp; load the package, which was very bad; but I think that may no longer be the case.
</p>
<p>You <em>may</em> have to set some environment variables (eg PATH, and perhaps R_LIBS) for the underlying R CMD calls to work. Currently you have to do this manually&mdash; your <code>.First</code> or <code>.Rprofile</code> would be a good place. If you really object to changing these for the whole R session, let me know; I've left a placeholder for a function <code>set.rcmd.vars</code> that could store a list of environment variables to be set temporarily for the duration of the R CMD calls only, but I haven't implemented it (and won't unless there's demand).
</p>
<p>Perhaps it would be desirable to let some flags be set automatically, eg via something in the <code>pre.install.hook</code> for a package. I'll add this if requested.
</p>


<h3>Value</h3>

<p>Ideally, the &quot;status code&quot; of the corresponding RCMD operation: 0 for success or some other integer if not. It will have several attributes attached, most usefully &quot;output&quot; which duplicates what's printed while the functions are running. (Turn off &quot;buffered output&quot; in RGui to see it as it's happening.) This requires the existence of the &quot;tee&quot; shell redirection facility, which is built-in to Linux and presumably Macs, but not to Windows. You can get one version from Coreutils in GnuWin32; make sure this is on your PATH, but probably <em>after</em> the Rtools folders required by the R build process, to avoid conflicts between the other Coreutils versions and those in Rtools (I don't know what I'm talking about here, obviously; I'm just describing what I've done, which seems to work). If &quot;tee&quot; eventually moves to Rtools, then this won't be necessary.
If no &quot;tee&quot; is available, then:
</p>
<table role = "presentation">
<tr><td><code>- progress of RCMD will be shown "live" in a separate shell window</code></td>
<td>
</td></tr>
<tr><td><code>- the status code is returned as NA</code>, <code>but still has the attributes including "output". You could</code>, <code>I suppose</code>, <code>"parse" the output somehow to check for failure.</code></td>
<td>
</td></tr>
</table>
<p>The point of all this &quot;tee&quot; business is that there's no reliable way in R itself to both show progress on-screen within R (which is useful, because these procedures can be slow) and to return the screen output as a character vector (which is useful so you can subsequently, pore through the error messages, or bask in a miasma of smugness).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First time package installation
# Must be cd()ed to task above 'mvbutils'
maintain.packages( mvbutils)
pre.install( mvbutils)
install.pkg( mvbutils)
# Subsequent maintenance is all done by:
patch.install( mvbutils)
# For distro to
build.pkg( mvbutils)
# or on Windows (?and Macs?)
build.pkg.binary( mvbutils)
# If you enjoy R CMD CHECK:
check.pkg( mvbutils)
# Also legal:
build.pkg( ..mvbutils)
# To do it under programmatic control
for( ipack in all.my.package.names) {
  build.pkg( char=ipack)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='library.dynam.reg'>Auto-registration and loading of dynamic library</h2><span id='topic+library.dynam.reg'></span>

<h3>Description</h3>

<p>A bit like <code>useDynLib</code> but for direct use in your own package's <code>.onLoad</code>, this loads a DLL and creates objects that allow the DLL routines to be called directly. If your package &quot;Splendid&quot; calls <code>library.dynam.reg</code> in its <code>.onLoad()</code> to load a DLL &quot;speedoo&quot; which contains routines &quot;whoosh&quot; and &quot;zoom&quot;, then an environment &quot;C_speedoo&quot; will be created in the <code>asNamespace("Splendid")</code>, and the environment will contain objects <code>whoosh</code> and <code>zoom</code>. R-code routines in &quot;Splendid&quot; can then call e.g.
</p>
<pre>
  .C( C_speedo$whoosh, ....)
</pre>
<p>You can only call <code>library.dynam.reg</code> inside <code>.onLoad</code>, because after that the namespace will be sealed so you can't poke more objects into it.
</p>


<h4>Note</h4>

<p>Currently, <em>all</em> routines go into <code>C_speedoo</code>, regardless of how they are meant to be called (<code>.C</code>, <code>.Call</code>, <code>.Fortran</code>, or <code>.External</code>). It's up to you to call them the right way. I might change this to create separate <code>Call_speedoo</code> etc.
</p>



<h4>Note2</h4>

<p>As of R3.1.1 at least, it's possible that &quot;recent&quot; changes to the <code>useDynLib</code> directive in a package namespace might obviate the need for this function. In particular, <code>useDynLib</code> can now create an environment/list that refers directly to DLL, containing references to individual routines (which will be slightly slowed because they need to be looked up each time). Also, <code>useDynLib</code> can automatically register its routines. What's not obvious is whether it can yet do both these things together&mdash; which is what <code>library.dynam.reg</code> is aimed at.
</p>



<h3>Usage</h3>

<pre><code class='language-R'># Only inside a '.onLoad', where you will already know "package" and "lib.loc"
library.dynam.reg(chname, package, lib.loc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="library.dynam.reg_+3A_chname">chname</code></td>
<td>
<p>DLL name, a string&mdash; <em>without</em> any path</p>
</td></tr>
<tr><td><code id="library.dynam.reg_+3A_package">package</code>, <code id="library.dynam.reg_+3A_lib.loc">lib.loc</code></td>
<td>
<p>strings as for <code>library.dynam</code></p>
</td></tr>
<tr><td><code id="library.dynam.reg_+3A_...">...</code></td>
<td>
<p>other args to <code>library.dynam</code></p>
</td></tr>
</table>

<hr>
<h2 id='load.refdb'>Cacheing objects for lazy-load access</h2><span id='topic+load.refdb'></span>

<h3>Description</h3>

<p><code>load.refdb</code> is like <code>load</code>, but automatically calls <code><a href="#topic+setup.mcache">setup.mcache</a></code> to create access arrangements for cached objects. You probably don't need to call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.refdb( file, envir, fpath=attr( envir, "path"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.refdb_+3A_file">file</code></td>
<td>
<p>a filename relative to <code>fpath</code></p>
</td></tr>
<tr><td><code id="load.refdb_+3A_envir">envir</code></td>
<td>
<p>an environment or (more usually) a position on the search path (numeric or character)</p>
</td></tr>
<tr><td><code id="load.refdb_+3A_fpath">fpath</code></td>
<td>
<p>a directory. Usually the default will do.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlazy">mlazy</a></code>, <code><a href="#topic+setup.mcache">setup.mcache</a></code>
</p>

<hr>
<h2 id='local.on.exit'>Macro-like functions</h2><span id='topic+local.on.exit'></span>

<h3>Description</h3>

<p><code>local.on.exit</code> is the analogue of <code>on.exit</code> for &quot;nested&quot; or &quot;macro&quot; functions written with <code><a href="#topic+mlocal">mlocal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Inside an 'mlocal' function of the form
# function( &lt;&lt;args&gt;&gt;, nlocal=sys.parent(), &lt;&lt;temp.params&gt;&gt;) mlocal({ &lt;&lt;code&gt;&gt; })
local.on.exit( expr, add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local.on.exit_+3A_expr">expr</code></td>
<td>
<p>the expression to evaluate when the function ends</p>
</td></tr>
<tr><td><code id="local.on.exit_+3A_add">add</code></td>
<td>
<p>if TRUE, the expression will be appended to the existing <code>local.on.exit</code> expression. If FALSE, the latter is overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>on.exit</code> doesn't work properly inside an <code><a href="#topic+mlocal">mlocal</a></code> function, because the scoping is wrong (though sometimes you get away with it). Use <code>local.on.exit</code> instead, in exactly the same way. I can't find any way to set the exit code in the <b>calling</b> function from within an <code><a href="#topic+mlocal">mlocal</a></code> function.
</p>
<p>Exit code will be executed before any temporary variables are removed (see <code><a href="#topic+mlocal">mlocal</a></code>).
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlocal">mlocal</a></code>, <code><a href="#topic+local.return">local.return</a></code>, <code>local.on.exit</code>, <code><a href="#topic+do.in.envir">do.in.envir</a></code>, and R-news 1/3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ffin &lt;- function( nlocal=sys.parent(), x1234, yyy) mlocal({
  x1234 &lt;- yyy &lt;- 1 # x1234 &amp; yyy are temporary variables
  # on.exit( cat( yyy)) # would crash after not finding yyy
  local.on.exit( cat( yyy))
  })
ffout &lt;- function() {
  x1234 &lt;- 99
  ffin()
  x1234 # still 99 because x1234 was temporary
}
ffout()
</code></pre>

<hr>
<h2 id='local.return'>Macro-like functions</h2><span id='topic+local.return'></span>

<h3>Description</h3>

<p>In an <code><a href="#topic+mlocal">mlocal</a></code> function, <code>local.return</code> should be used whenever <code>return</code> is called, wrapped inside the <code>return</code> call around the return arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local.return(...) # Don't use it like this!
# Correct usage: return( local.return( ...))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local.return_+3A_...">...</code></td>
<td>
<p>named and unnamed list, handled the same way as <code>return</code> before R 1.8, or as <code><a href="#topic+returnList">returnList</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlocal">mlocal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ffin &lt;- function( nlocal=sys.parent()) mlocal( return( local.return( a)))
ffout &lt;- function( a) ffin()
ffout( 3) # 3
# whereas:
ffin &lt;- function( nlocal=sys.parent()) mlocal( return( a))
ffout( 3) # NULL; "return" alone doesn't work
</code></pre>

<hr>
<h2 id='localfuncs'>&quot;Declare&quot; child functions, allowing much tidier code</h2><span id='topic+localfuncs'></span>

<h3>Description</h3>

<p>Only call this within a function, say <code>f</code>. The named functions are copied into the environment of <code>f</code>, with their environments set to the environment of <code>f</code>. This means that when you call one of the named functions later in <code>f</code>, it will be able to see all the variables in <code>f</code>, just as if you had defined the function inside <code>f</code>. Using <code>localfuncs</code> avoids you having to clutter <code>f</code> with definitions of child functions. It differs from <code><a href="#topic+mlocal">mlocal</a></code> in that the local functions won't be changing objects directly in <code>f</code> unless they use <code>&lt;&lt;-</code> &ndash; they will instead have normal R lexical scoping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localfuncs(funcs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localfuncs_+3A_funcs">funcs</code></td>
<td>
<p>character vector of function names</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mlocal">mlocal</a></code> for a different approach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inner &lt;- function( x) {
  y &lt;&lt;- y+x
  0
}
outer &lt;- function( z) {
  # Multiply z by 2!
  y &lt;- z
  localfuncs( 'inner')
  inner( z)
  return( y)
}
outer( 4) # 8
</code></pre>

<hr>
<h2 id='lsize'>Report objects and their memory sizes</h2><span id='topic+lsize'></span>

<h3>Description</h3>

<p><code>lsize</code> is like <code>ls</code>, except it returns a numeric vector whose names are the object names, and whose elements are the object sizes. The vector is sorted in order of increasing size. <code>lsize</code> avoids loading objects cached using <code><a href="#topic+mlazy">mlazy</a></code>; instead of their true size, it uses the size of the file that stores each cached object, which is shown as a <em>negative</em> number. The file size is typically smaller than the size of the loaded object, because <code><a href="#topic+mlazy">mlazy</a></code> saves a compressed version. NB that <code>lsize</code> will scan <em>all</em> objects in the environment, including ones with funny names, whereas <code>ls</code> does so only if its <code>all.names</code> argument is set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsize( envir=.GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsize_+3A_envir">envir</code></td>
<td>
<p>where to look for the objects. Will be coerced to environment, so that e.g. <code>lsize( 2)</code> and <code>lsize( "package:mvbutils")</code> work. <code>envir</code> can be a <code>sys.frame</code>&ndash; useful during debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named numeric vector.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>ls</code>, <code><a href="#topic+mlazy">mlazy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Current workspace
lsize()
# Contrived example to show objects in a function's environment
{function(..., a, b, c) lsize( sys.frame( sys.nframe())) }()
# a, b, c are all missing; this example might break in future R versions
# ...   a   b   c
#  28  28  28  28
</code></pre>

<hr>
<h2 id='maintain.packages'>Set up task package for live editing</h2><span id='topic+maintain.packages'></span><span id='topic+unmaintain.package'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code> before reading or experimenting!
</p>
<p>Set up task package(s) for editing and/or live-editing. Usually called in <code>.First</code> or <code>.First.task</code>. You need to be <code><a href="#topic+cd">cd</a></code>ed into the parent task of your task-package. <code>maintain.packages</code> must be called <em>before</em> loading the package via <code>library</code> or <code>require</code>. The converse, <code>unmaintain.package</code>, is rarely needed; it's really only meant for when <code><a href="#topic+unpackage">unpackage</a></code> doesn't work properly, and you want a &quot;clean slate&quot; task package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># E.g. in your .First, after library( mvbutils), or in...
# ... a '.First.task' above yr task-package
maintain.packages(..., character.only = FALSE, autopatch=FALSE)
unmaintain.package( pkg, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maintain.packages_+3A_...">...</code></td>
<td>
<p>names of packages, unquoted unless <code>character.only</code> is TRUE. Package names must correspond to subtasks of the current task.</p>
</td></tr>
<tr><td><code id="maintain.packages_+3A_character.only">character.only</code></td>
<td>
<p>see above</p>
</td></tr>
<tr><td><code id="maintain.packages_+3A_pkg">pkg</code></td>
<td>
<p>name of package, unquoted unless <code>character.only</code> is TRUE.</p>
</td></tr>
<tr><td><code id="maintain.packages_+3A_autopatch">autopatch</code></td>
<td>
<p>whether to <code>patch.install</code> out-of-date installed packages (default FALSE, but TRUE is common).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maintain.packages( mypack)</code> loads a copy of your task-package &quot;mypack&quot; (as stored in its &quot;.RData&quot; file) into a environment <code>..mypack</code> (an &quot;in-memory-task-package&quot;), which itself lives in the &quot;mvb.session.info&quot; environment on the search path. You don't normally need to know this, because normally you'd modify/create/delete objects in the package via <code><a href="#topic+fixr">fixr</a></code> or <code>fixr(..., pkg="mypack")</code> or <code>rm.pkg( ..., pkg="mypack")</code>. But to move objects between the package and other tasks, you do need to refer to the in-memory task package, e.g. via <code>move( ..., from=..Splendid, to=subtask/of/current)</code>. In most cases, you will be prompted afterwards for whether to save the task package on disk, but you can always do yourself via <code>Save.pos( ..Splendid)</code>. Note that only these updates and saves only update the <em>task package</em> and the <em>loaded package</em>. To update the <em>source package</em> using the task package, call <code><a href="#topic+pre.install">pre.install</a></code>; to update the <em>installed package</em> on disk as well as the source package, call <code><a href="#topic+patch.install">patch.install</a></code>.
</p>


<h4>Creating new things</h4>

<p>It's always safe to create new objects of any type in <code>.GlobalEnv</code>, then use <code>move(newthing,.,..mypack)</code>. For a new <em>function</em>, you can shortcut this two-step process and create it directly in the in-memory maintained package, via <code>fixr(..mypack$newfun)</code>; <code><a href="#topic+fixr">fixr</a></code> will take care of synchronization with the loaded package. This also ought to work for text objects created via <code><a href="#topic+fixtext">fixtext</a></code>. Otherwise, use the two-step route, unless you have a good reason to do the following...
</p>



<h4>Directly modifying the maintained package</h4>

<p>Rarely, you may have a really good reason to directly modify the contents of <code>..mypack</code>, e.g. via
</p>
<pre>
  ..mypack$newfun &lt;&lt;- function( x) whatever
</pre>
<p>You can do it, but there are two problems to be aware of. The first is that changes won't be directly propagated to the loaded package, possibly not even after <code><a href="#topic+patch.install">patch.install</a></code> (though they will be honoured when you <code>library()</code> the package again). That is definitely the case for general data objects, and I'm not sure about functions; however, successful propagation after <code><a href="#topic+patch.install">patch.install</a></code> may happen for a special objects such as <code>mypack.DESCRIPTION</code> and documentation objects. Hence my general advice is to use <code><a href="#topic+fixr">fixr</a></code> or <code><a href="#topic+move">move</a></code>.
</p>
<p>The second, minor, problem is that you will probably forget to use <code>&lt;&lt;-</code> and will use <code>&lt;-</code> instead, so that a local copy of <code>..mypack</code> will be created in the current task. This is no big deal, and you can just <code>rm</code> the local copy; the local copy and the master copy in &quot;mvb.session.info&quot; both point to the same thing, and modifying one implies modifying the other, so that deleting the local copy won't lose your changes. <code><a href="#topic+Save">Save</a></code> detects accidental local copies of task packages, and omits them from the disk image, so there shouldn't be any problems next time you start R even if you completely forget about local/master copies.
</p>



<h4>Autopatch</h4>

<p>If <code>autopatch==TRUE</code>, then <code>maintain.packages</code> will check whether the corresponding <em>installed</em> packages are older than the &quot;.RData&quot; files of the task packages. If they are, it will do a full <code><a href="#topic+patch.install">patch.install</a></code>; if not, it will still call <code><a href="#topic+patch.install">patch.install</a></code> but only to reverse-update any bundled DLLs (see <code><a href="#topic+pre.install">pre.install</a></code>), not to re-install the R-source. I find <code>autopatch</code> useful with packages containing C code, where a crash in the C code can cause R to die before the most recent R-code changes have been &quot;committed&quot; with <code><a href="#topic+patch.install">patch.install</a></code>. When you next start R, a call to <code>maintain.packages</code> with <code>autopatch=TRUE</code> will &quot;commit&quot; the changes <em>before</em> the package is loaded, because you have to call <code>maintain.packages</code> before <code>library</code>; this seems to be more reliable than running <code><a href="#topic+patch.install">patch.install</a></code> manually after <code>library</code> after a restart.
</p>



<h3>Maintained packages as tasks</h3>

<p>If you use <code>mvbutils</code> to pre-build your package, then your package must exist as a task in the <code><a href="#topic+cd">cd</a></code> hierarchy. Older versions of <code>mvbutils</code> allowed you to <code><a href="#topic+cd">cd</a></code> to a maintained package, but this is now forbidden because of the scope for confusion. Thanks to <code>maintain.packages</code>, there is no compelling need to have the package/task at the top of the search path; <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+move">move</a></code>, etc work just fine without. If you really do want to <code><a href="#topic+cd">cd</a></code> to a maintained package, you must call <code>unmaintain.package</code> first.
</p>
<p>One piece of cleanup that I recommend, is to move any subtasks of &quot;mypack&quot; one level up in the task hierarchy, and to remove the <code>tasks</code> object from &quot;Splendid&quot; itself, e.g. via something like:
</p>
<pre>
  cd( task.above.splendid)
  tasks &lt;- c( tasks, combined.file.paths( tasks[ "Splendid"], ..Splendid$tasks))
  # ... combined.file.paths is an imaginary function. Watch out if you've used relative paths!
  rm.pkg( tasks, pkg="Splendid")
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>, <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+pre.install">pre.install</a></code>, <code><a href="#topic+patch.installed">patch.installed</a></code>, <code><a href="#topic+unpackage">unpackage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In your .First:
library( mvbutils)
maintain.packages( myfirstpack, mysecondpack, mythirdpack)
# or...
live.edit.list &lt;- c( 'myfirstpack', 'mysecondpack', 'mythirdpack')
maintain.packages( live.edit.list, character.only=TRUE)
library( myfirstpack) # etc

## End(Not run)
</code></pre>

<hr>
<h2 id='make_dull'>Hide dull columns in data frames</h2><span id='topic+make_dull'></span><span id='topic+make.dull'></span>

<h3>Description</h3>

<p><code>make_dull</code> AKA <code>make.dull</code> adds a &quot;dull&quot; S3 class to designated columns in a <code>data.frame</code>. When the <code>data.frame</code> is printed, entries in those columns will show up just as &quot;...&quot;. Useful for hiding long boring stuff like nucleotide sequences, MD5 sums, and filenames. Columns will still print clearly if manually extracted.
</p>
<p>The <code>dull</code> class has methods for <code>format</code> (used when printing a <code>data.frame</code>) and <code>[</code>, so that dullness is perpetuated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dull(df, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dull_+3A_df">df</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="make_dull_+3A_cols">cols</code></td>
<td>
<p>columns to designate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ask yourself: do you <em>really</em> want details of a function called <code>make_dull</code>? Life may be sweet but it is also short.
</p>


<h4>More details</h4>

<p><code>make_dull</code> is both autologous and idempotent.
</p>



<h3>Value</h3>

<p>A modified data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Becos more logical syntax:
rsample &lt;- function (n = length(pop), pop, replace = FALSE, prob = NULL){
  pop[sample(seq_along(pop) - 1, size = n, replace = replace, prob = prob) + 1]
}
df &lt;- data.frame( x=1:3,
    y=apply( matrix( rsample( 150, as.raw( 33:127), rep=TRUE), 50, 3), 2, rawToChar),
    stringsAsFactors=FALSE) # s.A.F. value shouldn't matter
df # zzzzzzzzzzzzzzz
df &lt;- make_dull( df, 'y')
df # wow, exciting!
df$y # zzzzzzzzzzzzzz
</code></pre>

<hr>
<h2 id='make.NAMESPACE'>Auto-create a NAMESPACE file</h2><span id='topic+make.NAMESPACE'></span><span id='topic+write.NAMESPACE'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+pre.install">pre.install</a></code> for would-be packages that have a <code>.onLoad</code> function, and are therefore assumed to want a namespace. Produces defaults for the import, export, and S3Methods. You can modify this information prior to the NAMESPACE file being created, using the pre-install hook mechanism. The default for <code>import</code> is taken from the DESCRIPTION file, but the defaults for export and S3 methods are deduced from your functions, and are described below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Don't call this directly-- pre.install will do it automatically for you
make.NAMESPACE( env=1, path=attr( env, "path"),
  description=read.dcf( file.path( path, "DESCRIPTION"))[1,], more.exports=character( 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.NAMESPACE_+3A_env">env</code></td>
<td>
<p>character or numeric position on search path</p>
</td></tr>
<tr><td><code id="make.NAMESPACE_+3A_path">path</code></td>
<td>
<p>directory where proto-package lives</p>
</td></tr>
<tr><td><code id="make.NAMESPACE_+3A_description">description</code></td>
<td>
<p>(character) elements for the DESCRIPTION file, e.g. <code>c( ..., Author="R.A. Fisher", ...)</code>. By default, read from existing file.</p>
</td></tr>
<tr><td><code id="make.NAMESPACE_+3A_more.exports">more.exports</code></td>
<td>
<p>(character) things to export that normally wouldn't be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is (currently) no attempt to handle S4 methods.
</p>
<p>The imported packages are those listed in the &quot;Depends:&quot; and &quot;Imports:&quot; field of the DESCRIPTION file. At present, all functions in those packages will be imported (i.e. no &quot;importFrom&quot; provision).
</p>
<p>The exported functions are all those in <code>find.documented(doctype="any")</code> unless they appear to be S3 methods, plus any functions that have a non-NULL <code>export.me</code> attribute. The latter is a cheap way of arranging for a function to be exported, but without formal documentation (is that wise??). <code><a href="#topic+pre.install">pre.install</a></code> will incorporate any undocumented <code>export.me</code> functions in the &quot;mypack-internal.Rd&quot; file, so that RCMD CHECK will be happy.
</p>
<p>The S3 methods are all the functions whose names start &quot;&lt;&lt;generic&gt;&gt;.&quot; and whose first argument has the same name as in the appropriate <code>&lt;&lt;generic&gt;&gt;</code>. The generics that are checked are (i) the names of the character vector <code>.knownS3Generics</code> in package <span class="pkg">base</span>; (ii) all functions that look like generics in any importees or dependees of your would-be package (i.e. functions in the namespace whose name is a prefix of a function in the S3 methods table of the namespace, and whose body contains a call to <code>UseMethod</code>); (iii) any plausible-looking generic in your would-be package (effectively the same criterion). Documented functions which look like methods but whose flat-doc documentation names them explicitly in the <b>Usage</b> section (e.g. referring to <code>print.myclass(...)</code> rather than just <code>print(...)</code>, the latter being how you're supposed to document methods) are assumed not be methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pre.install">pre.install</a></code>, <code><a href="#topic+flatdoc">flatdoc</a></code>
</p>

<hr>
<h2 id='make.usage.section'>Construct sections of documentation</h2><span id='topic+make.usage.section'></span><span id='topic+make.arguments.section'></span>

<h3>Description</h3>

<p>Don't bother reading about these unless you are sure you need to! These are really intended for expediting documentation of large numbers of &quot;internal&quot; functions in a proto-package, and are called by <code>make.internal.doc</code>. <code>make.usage.section</code> and <code>make.arguments.section</code> form prototype USAGE and ARGUMENTS section for the specified functions. These are ready for pasting into flat-format documentation (and subsequent editing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.usage.section( funs=, file=stdout(), env=.GlobalEnv)
make.arguments.section( funs=, file=stdout(), env=.GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.usage.section_+3A_funs">funs</code></td>
<td>
<p>character vector of function names, defaulting to <code>find.funs() %except% find.documented( doctype="Rd")</code></p>
</td></tr>
<tr><td><code id="make.usage.section_+3A_file">file</code></td>
<td>
<p>where to put the output (<code>"clipboard"</code> is useful). NULL means don't print.</p>
</td></tr>
<tr><td><code id="make.usage.section_+3A_env">env</code></td>
<td>
<p>where to look for the functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>funs</code> argument will find all functions not mentioned in flat-format ready-for-doc2Rd documentation. This is useful for documenting a group of &quot;internal&quot; functions.
</p>
<p><code>make.usage.section</code> simply puts the name of each function before its deparsed and concatenated argument list, one function per line.
</p>
<p><code>make.arguments.section</code> puts one argument per line, then a colon, then the name of the function in parentheses. The idea is that something about the argument should be added manually in a text editor.
</p>


<h3>Value</h3>

<p>Character vector containing the doc section (in plain text, not Rd format).
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+pre.install">pre.install</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.usage.section( c( "make.usage.section", "find.funs"), env=asNamespace( 'mvbutils'))
make.arguments.section( c( "make.usage.section", "find.funs"), env=asNamespace( 'mvbutils'))
</code></pre>

<hr>
<h2 id='max_pkg_ver'>Max package version</h2><span id='topic+max_pkg_ver'></span>

<h3>Description</h3>

<p>Finds the highest version number of an installed package in (possibly) <em>several</em> libraries. Mainly for internal use in <code>mvbutils</code>, but might come in handy if your version numbers have gotten out-of-synch eg with different R versions. On my setup, all my &quot;non-base&quot; libraries are folders inside &quot;d:/rpackages&quot;, with folder names such as &quot;R2.13&quot;; my <code>.First</code> sets <code>.libPaths()</code> to all of these that are below the running version of R (but that are still legal for that R version; so for R &gt; 3.0, folders named &quot;R2.xxxx&quot; would be excluded). Hence I can call <code>max_pkg_ver( mypack, "d:/rpackages")</code> to find the highest installed version in all these subfolders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_pkg_ver(pkg, libroot, pattern = "^[rR][ -]?[0-9]+")
    # NB named with underscores to avoid interpretation as S3 method
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_pkg_ver_+3A_pkg">pkg</code></td>
<td>
<p>character, the name of the package</p>
</td></tr>
<tr><td><code id="max_pkg_ver_+3A_libroot">libroot</code></td>
<td>
<p>folder(s) to be searched recursively for package <span class="pkg">pkg</span></p>
</td></tr>
<tr><td><code id="max_pkg_ver_+3A_pattern">pattern</code></td>
<td>
<p>what regexp to use when looking for potential libraries to recurse into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric_version</code> object for the highest-numbered installation, with value <code>numeric_version("0")</code> if no such package is found. If <code>libroot</code> is a single library containing the package, the result will equal <code>packageVersion( pkg, limbroot)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>max_pkg_ver( "mvbutils", .libPaths())
</code></pre>

<hr>
<h2 id='mcut'>Put reals and integers into specified bins, returning factors.</h2><span id='topic+mcut'></span><span id='topic+mintcut'></span>

<h3>Description</h3>

<p>Put reals and integers into specified bins, returning ordered factors. Like <code><a href="base.html#topic+cut">cut</a></code> but for human use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcut( x, breaks, pre.lab='', mid.lab='', post.lab='', digits=getOption( 'digits'))
mintcut( x, breaks=NULL, prefix='', all.levels=, by.breaks=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcut_+3A_x">x</code></td>
<td>
<p>(numeric vector) What to bin&ndash; will be coerced to integer for <code>mintcut</code></p>
</td></tr>
<tr><td><code id="mcut_+3A_breaks">breaks</code></td>
<td>
<p>(numeric vector) LH end of each bin&ndash; should be increasing. Values of <code>x</code> exactly on the LH end of a bin will go into that bin, not the previous one. For <code>mintcut</code>, defaults to equal-size bins across the range of <code>x</code>, where bin size is set from <code>by.breaks</code> which itself defaults to 1. For <code>mcut</code>, should start with -Inf if necessary, but should not finish with Inf unless you want a bin for Infs only.</p>
</td></tr>
<tr><td><code id="mcut_+3A_prefix">prefix</code>, <code id="mcut_+3A_pre.lab">pre.lab</code></td>
<td>
<p>(string) What to prepend to the factor labels&ndash; e.g. &quot;Amps&quot; if your original data is about Amps.</p>
</td></tr>
<tr><td><code id="mcut_+3A_mid.lab">mid.lab</code></td>
<td>
<p>&quot;units&quot; to append to numeric vals <em>inside</em> factor labels. Tends to make the labels harder to read; try using <code>post.lab</code> instead.</p>
</td></tr>
<tr><td><code id="mcut_+3A_post.lab">post.lab</code></td>
<td>
<p>(string) What to append to the factor labels.</p>
</td></tr>
<tr><td><code id="mcut_+3A_digits">digits</code></td>
<td>
<p>(integer) How many digits to put into the factor labels.</p>
</td></tr>
<tr><td><code id="mcut_+3A_all.levels">all.levels</code></td>
<td>
<p>if FALSE, omit factor levels that don't occur in <code>x</code>. To override &quot;automatically&quot;, just set the &quot;all.levels&quot; attribute of <code>breaks</code> to anything non-NULL; useful e.g. if you are repeatedly calling <code>mintcut</code> with the same <code>breaks</code> and you always want <code>all.levels=TRUE</code>.</p>
</td></tr>
<tr><td><code id="mcut_+3A_by.breaks">by.breaks</code></td>
<td>
<p>for <code>mintcut</code> when default <code>breaks</code> is used, to set the bin size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of <code>x</code> below <code>breaks[1]</code> will end up as NAs. For <code>mintcut</code>, factor labels (well, the bit after the <code>prefix</code>) will be of the form &quot;2-7&quot; or &quot;3&quot; (if the bin range is 1) or &quot;8+&quot; (for last in range). For <code>mcut</code>, labels will look like this (apart from the <code>pre.lab</code> and <code>post.lab</code> bits): &quot;[&lt;0.25]&quot; or &quot;[0.25,0.50]&quot; or &quot;[&gt;=0.75]&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed( 1)
mcut( runif( 5), c( 0.25, 0.5, 0.75))
# [1] [0.25,0.50] [0.25,0.50] [0.50,0.75] [&gt;=0.75]     [&lt;0.25]
# Levels: [&lt;0.25] [0.25,0.50] [0.50,0.75] [&gt;=0.75]
 mcut( runif( 5), c( 0.25, 0.5, 0.75), pre.lab='A', post.lab='B', digits=1)
# [1] A[&gt;=0.8]B    A[&gt;=0.8]B    A[0.5,0.8]B A[0.5,0.8]B A[&lt;0.2]B
# Levels: A[&lt;0.2]B A[0.2,0.5]B A[0.5,0.8]B A[&gt;=0.8]B
mintcut( 1:8, c( 2, 4, 7))
# [1] &lt;NA&gt; 2-3  2-3  4-6  4-6  4-6  7+   7+
# Levels: 2-3 4-6 7+
mintcut( c( 1, 2, 4)) # auto bins, size defaulting to 1
# [1] 1  2  4+
# Levels: 1 &lt; 2 &lt; 3 &lt; 4+
mintcut( c( 1, 2, 6), by=2) # auto bins of size 2
# [1] 1-2 1-2 5+
# Levels: 1-2 &lt; 3-4 &lt; 5+
</code></pre>

<hr>
<h2 id='mlazy'>Cacheing objects for lazy-load access</h2><span id='topic+mlazy'></span><span id='topic+mtidy'></span><span id='topic+demlazy'></span><span id='topic+mcachees'></span><span id='topic+attach.mlazy'></span>

<h3>Description</h3>

<p><code>mlazy</code> and friends are designed for handling collections of biggish objects, where only a few of the objects are accessed during any period, and especially where the individual objects might change and the collection might grow or shrink. As with &quot;lazy loading&quot; of packages, and the <code>gdata/ASOR</code> packages, the idea is to avoid the time &amp; memory overhead associated with loading in numerous huge R binary objects when not all will be needed. Unlike lazy loading and <code>gdata</code>, <code>mlazy</code> caches each mlazyed object in a separate file, so it also avoids the overhead that would be associated with changing/adding/deleting objects if all objects lived in the same big file. When a workspace is <code><a href="#topic+Save">Save</a></code>d, the code updates only those individual object files that need updating.
</p>
<p><code>mlazy</code> does not require any special structure for object collections; in particular, the data doesn't have to go into a package. <code>mlazy</code> is particularly useful for users of <code><a href="#topic+cd">cd</a></code> because each <code><a href="#topic+cd">cd</a></code> to/from a task causes a read/write of the binary image file (usually &quot;.RData&quot;), which can be very large if <code>mlazy</code> is not used. Read DETAILS next. Feedback is welcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlazy( ..., what, envir=.GlobalEnv, save.now=TRUE)
  # cache some objects
mtidy( ..., what, envir=.GlobalEnv)
  # (cache and) purge the cache to disk, freeing memory
demlazy( ..., what, envir=.GlobalEnv)
  # makes 'what' into normal uncached objects
mcachees( envir=.GlobalEnv)
  # shows which objects in  envir are cached
attach.mlazy( dir, pos=2, name=)
  # load mcached workspace into new search environment,
  # or create empty s.e. for cacheing
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlazy_+3A_...">...</code></td>
<td>
<p>unquoted object names, overridden by <code>what</code> if supplied</p>
</td></tr>
<tr><td><code id="mlazy_+3A_what">what</code></td>
<td>
<p>character vector of object names, all from the same environment. For <code>mtidy</code> and <code>demlazy</code>, defaults to all currently-cached objects in <code>envir</code></p>
</td></tr>
<tr><td><code id="mlazy_+3A_envir">envir</code></td>
<td>
<p>environment or position on the search path, defaulting to the environment where <code>what</code> or <code>objs</code> live.</p>
</td></tr>
<tr><td><code id="mlazy_+3A_save.now">save.now</code></td>
<td>
<p>see DETAILS</p>
</td></tr>
<tr><td><code id="mlazy_+3A_dir">dir</code></td>
<td>
<p>name of directory, relative to <code><a href="#topic+task.home">task.home</a></code>.</p>
</td></tr>
<tr><td><code id="mlazy_+3A_pos">pos</code></td>
<td>
<p>numeric position of environment on search path, 2 or more</p>
</td></tr>
<tr><td><code id="mlazy_+3A_name">name</code></td>
<td>
<p>name to give environment, defaulting to something like &quot;data:current.task:dir&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are used only for their side-effects, except for <code>cachees</code> which returns a character vector of object names.
</p>


<h3>More details</h3>

<p>All this is geared to working with saved images (i.e. &quot;.RData&quot; or &quot;all.rda&quot; files) rather than creating all objects anew each session via <code>source</code>. If you use the latter approach, <code>mlazy</code> will probably be of little value.
</p>
<p>The easiest way to set up cacheing is just to create your objects as normal, then call
</p>
<p><code>mlazy( &lt;&lt;objname1&gt;&gt;, &lt;&lt;objname2&gt;&gt;, &lt;&lt;etc&gt;&gt;)</code>
</p>
<p><code>Save()</code>
</p>
<p>This will not seem to do much immediately&ndash; your object can be read and changed as normal, and is still taking up memory. The memory and time savings will come in your next R session in this workspace.
</p>
<p>You should never see any differences (except in time &amp; memory usage) between working with cached (AKA mlazyed) and normal uncached objects.[One minor exception is that cacheing a function may stuff up the automatic backup system, or at any rate the &quot;backstop&quot; version of it which runs when you <code><a href="#topic+cd">cd</a></code>. This is deliberate, for speeding up <code><a href="#topic+cd">cd</a></code>. But why would you cache a <em>function</em> anyway?]
</p>
<p><code>mlazy</code> itself doesn't save the workspace image (the &quot;.RData&quot; or &quot;all.rda&quot; file), which is where the references live; that's why you need to call <code><a href="#topic+Save">Save</a></code> periodically. <code>save.image</code> and <code>save</code> will <b>not</b> work properly, and nor will <code>load</code>&ndash; see NOTE below. <code><a href="#topic+Save">Save</a></code> doesn't store cached objects directly in the &quot;.RData&quot; file, but instead stores the uncached objects as normal in <code>.RData</code> together with a special object called something like <code>.mcache00</code> (guaranteed not to conflict with one of your own objects). When the <code>.RData</code> file is subsequently reloaded by <code><a href="#topic+cd">cd</a></code>, the presence of the <code>.mcache00</code> object triggers the creation of &quot;stub&quot; objects that will load the real cached objects from disk when and only when each one is required; the <code>.mcache00</code> object is then deleted. Cached objects are loaded &amp; stored in a subdirectory &quot;mlazy&quot; from individual files called &quot;obj*.rda&quot;, where &quot;*&quot; is a number.
</p>
<p><code>mlazy</code> and <code><a href="#topic+Save">Save</a></code> do not immediately free any memory, to avoid any unnecessary re-loading from disk if you access the objects again during the current session. To force a &quot;memory purge&quot; <em>during</em> an R session, you need to call <code>mtidy</code>. <code>mtidy</code> purges its arguments from the cache, replacing them by <code>promise</code>s just as when loading the workspace; when a reference is next accessed, its cached version will be re-loaded from disk. <code>mtidy</code> can be useful if you are looping over objects, and want to keep memory growth limited&ndash; you can <code>mtidy</code> each object as the last statement in the loop. By default, <code>mtidy</code> purges the cache of all objects that have previously been cached. <code>mtidy</code> also caches any formerly uncached arguments, so one call to <code>mtidy</code> can be used instead of <code>mlazy( ...); mtidy( ...)</code>.
</p>
<p><code><a href="#topic+move">move</a></code> understands cached objects, and will shuffle the files accordingly.
</p>
<p><code>demlazy</code> will <b>delete</b> the corresponding &quot;obj*.rda&quot; file(s), so that only an in-memory copy will then exist; don't forget to <code><a href="#topic+Save">Save</a></code> soon after.
</p>


<h4>Warning</h4>

<p>The system function <code>load</code> does not understand cacheing. If you merely <code>load</code> an image file saved using <code><a href="#topic+Save">Save</a></code>, cached objects will not be there, but there will be an extra object called something like <code>.mcache00</code>. Hence, if you have cached objects in your ROOT task, they will not be visible when you start R until you load the <code>mvbutils</code> library&ndash; another fine reason to do that in your <code>.First</code>. The <code>.First.lib</code> function in <code>mvbutils</code> calls <code>setup.mcache( .GlobalEnv)</code> to automatically prepare any references in the ROOT task.
</p>



<h4>Cacheing in other search environments</h4>

<p>It is possible to cache in search environments other the current top one (AKA the current workspace, AKA <code>.GlobalEnv</code>). This could be useful if, for example, you have a large number of simulated datasets that you might need to access, but you don't want them cluttering up <code>.GlobalEnv</code>. If you weren't worried about cacheing, you'd probably do this by calling <code>attach( "&lt;&lt;filename&gt;&gt;")</code>. The cacheing equivalent is <code>attach.mlazy( "cachedir")</code>. The argument is the name of a directory where the cached objects will be (or already are) stored; the directory will be created if necessary. If there is a &quot;.RData&quot; file in the directory, <code>attach.mlazy</code> will load it and set up any references properly; the &quot;.RData&quot; file will presumably contain mostly references to cached data objects, but can contain normal uncached objects too.
</p>
<p>Once you have set up a cacheable search environment via <code>attach.mlazy</code> (typically in search position 2), you can cache objects into it using <code>mlazy</code> with the <code>envir</code> argument set (typically to 2). If the objects are originally somewhere else, they will be transferred to <code>envir</code> before cacheing. Whenever you want to save the cached objects, call <code>Save.pos(2)</code>.
</p>
<p>You will probably also want to modify or create the <code>.First.task</code> (see <code><a href="#topic+cd">cd</a></code>) of the current task so that it calls <code>attach.mlazy("&lt;&lt;cache directory name&gt;&gt;")</code>. Also, you should create a <code>.Last.task</code> (see <code><a href="#topic+cd">cd</a></code>) containing <code>detach(2)</code>, otherwise <code>cd(..)</code> and <code>cd(0/...)</code> won't work.
</p>



<h4>Options</h4>

<p>By default, <code>mlazy</code> now saves &amp; loads into a auto-created subdirectory called &quot;mlazy&quot;. In the earliest releases, though, it saved &quot;obj*.rda&quot; files into the same directory as &quot;.RData&quot;. It will now <b>move</b> any &quot;obj*.rda&quot; files that it finds alongside &quot;.RData&quot; into the &quot;mlazy&quot; subdirectory. You can (possibly) override this by setting <code>options( mlazy.subdir=FALSE)</code>, but the default is likely more reliable.
</p>
<p>By default, there is no way to figure out what object is contained in a &quot;obj*.rda&quot; without forcibly loading that file or inspecting the <code>.mcache00</code> object in the &quot;parent&quot; <code>.RData</code> file&ndash; not that you should ever need to know. However, if you set <code>options( mlazy.index=TRUE)</code> (<b>recommended</b>), then a file &quot;obj.ind&quot; will be maintained in the &quot;mlazy&quot; directory, showing (object name - value) pairs in plain text (tab-separated). For directories with very large numbers of objects, there may be some speed penalty. If you want to create an index file for an existing &quot;mlazy&quot; directory that lacks one, <code><a href="#topic+cd">cd</a></code> to the task and call <code>mvbutils:::mupdate.mcache.index.if.opt(mlazy.index=TRUE)</code>.
</p>
<p>See <code><a href="#topic+Save">Save</a></code> for how to set compression options, and <code>save</code> for what you can set them to; <code>options(mvbutils.compression_level=1)</code> may save some time, at the expense of disk space.
</p>



<h4>Troubleshooting</h4>

<p>In the unlikely event of needing to manually load a cached image file, use <code><a href="#topic+load.refdb">load.refdb</a></code>&ndash; <code><a href="#topic+cd">cd</a></code> and <code>attach.mlazy</code> do this automatically.
</p>
<p>In the unlikely event of lost/corrupted data, you can manually reload individual &quot;obj*.rda&quot; files using <code>load</code>&ndash; each &quot;obj*.rda&quot; file contains one object stored with its correct name. Before doing that, call <code>demlazy( what=mcachees())</code> to avoid subsequent trouble. Once you have reloaded the objects, you can call <code>mlazy</code> again.
</p>
<p>See <b>Options</b> for the easy way to check what object is stored in a particular &quot;obj*.rda&quot; file. If that feature is turned off on your system, the failsafe way is to load the file into a new environment, e.g. <code>e &lt;- new.env(); load( "obj99.rda", e); ls( e)</code>.
</p>
<p>To see how memory changes when you call <code>mlazy</code> and <code>mtidy</code>, call <code>gc()</code>.
</p>
<p>To check object sizes <em>without</em> actually loading the cached objects, use <code><a href="#topic+lsize">lsize</a></code>. Many functions that iterate over all objects in the environment, such as <code>eapply</code>, will cause <code>mlazy</code> objects to be loaded.
</p>
<p>Housekeeping of &quot;obj**.rda&quot; files happens during <code><a href="#topic+Save">Save</a></code>; any obsolete files (i.e. corresponding to objects that have been <code>remove</code>d) are deleted.
</p>



<h4>Inner workings</h4>

<p>What happens: each workspace acquires a <code>mcache</code> attribute, which is a named numeric vector. The absolute values of the entries correspond to files&ndash; 53 corresponds to a file &quot;obj53.rda&quot;, etc., and the names to objects. When an object <code>myobj</code> is <code>mlazy</code>ed, the <code>mcache</code> is augmented by a new element named &quot;myobj&quot; with a new file number, and that file is saved to disk. Also, &quot;myobj&quot; is replaced with an active binding (see <code><a href="base.html#topic+makeActiveBinding">makeActiveBinding</a></code>). The active binding is a function which retrieves or sets the object's data within the function's environment. If the function is called in change-value mode, then it also makes negative the file number in <code>mcache</code>. Hence it's possible to tell whether an object has been changed since last being saved.
</p>
<p>When an object is first <code>mlazy</code>ed, the object data is placed directly into the active binding function's environment so that the function can find/modify the data. When an object is <code>mtidy</code>ed, or when a cached image is loaded from disk, the thing placed into the A.B.fun's environment is not the data itself, but instead a <code>promise</code> saying, in effect, &quot;fetch me from disk when you need me&quot;. The promise gets forced when the object is accessed for reading or writing. This is how &quot;lazy loading&quot; of packages works, and also the <span class="pkg">gdata</span> package. However, for <code>mlazy</code> there is the additional requirement of being able to determine whether an object has been modified; for efficiency, only modified objects should be written to disk when there is a <code><a href="#topic+Save">Save</a></code>.
</p>
<p>There is presumably some speed penalty from using a cache, but experience to date suggests that the penalty is small. Cached objects are saved in compressed format, which seems to take a little longer than an uncompressed save, but loading seems pretty quick compared to uncompressed files.
</p>



<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsize">lsize</a></code>, <code>gc</code>, package <span class="pkg">gdata</span>, package <span class="pkg">ASOR</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
biggo &lt;- matrix( runif( 1e6), 1000, 1000)
gc() # lots of memory
mlazy( biggo)
gc() # still lots of memory
mtidy( biggo)
gc() # better
biggo[1,1]
gc() # worse; it's been reloaded

## End(Not run)
</code></pre>

<hr>
<h2 id='mlocal'>Macro-like functions</h2><span id='topic+mlocal'></span>

<h3>Description</h3>

<p><code>mlocal</code> lets you write a function whose statements are executed in its caller's frame, rather than in its own frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Use only as wrapper of function body, like this:
# my.fun &lt;- function(..., nlocal=sys.parent()) mlocal( expr)
# ... should be replaced by the arguments of "my.fun"
# expr should be replaced by the code of "my.fun"
# nlocal should always be included as shown
mlocal( expr) # Don't use it like this!
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlocal_+3A_expr">expr</code></td>
<td>
<p>the function code, normally a braced expression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes it's useful to write a &quot;child&quot; function that can create and modify variables in its parent directly, without using <code>assign</code> or <code>&lt;&lt;-</code> (note that <code>&lt;&lt;-</code> will only work on variables that exist already). This can make for clearer, more modular programming; for example, tedious initializations of many variables can be hidden inside an <code>initialize()</code> statement. The definition of an <code>mlocal</code> function does not have to occur within its caller; the <code>mlocal</code> function can exist as a completely separate R object.
</p>
<p><code>mlocal</code> functions can have arguments just like normal functions. These arguments will temporarily hide any objects of the same name in the <code>nlocal</code> frame (i.e. the calling frame). When the <code>mlocal</code> function exits, its arguments will be deleted from the calling frame and the hidden objects (if any) will be restored. Sometimes it's desirable to avoid cluttering the calling frame with variables that only matter to the <code>mlocal</code> function. A useful convention is to &quot;declare&quot; such temporary variables in your function definition, as defaultless arguments after the <code>nlocal</code> argument.
</p>
<p>The <code>nlocal</code> argument of an <code>mlocal</code> function&ndash; which must ALWAYS be included in the definition, with the default specified as <code>sys.parent()</code>&ndash; can normally be omitted when invoking your <code>mlocal</code> function. However, you will need to set it explicitly when your function is to be called by another, e.g. <code>lapply</code>; see the third example. A more daring usage is to call e.g. <code>fun.mlocal(nlocal=another.frame.number)</code> so that the statements in <code>fun.mlocal</code> get executed in a completely different frame. A convoluted example can be found in the (internal) function <code>find.debug.HQ</code> in the <span class="pkg">debug</span> package, which creates a frame and then defines a large number of variables in it by calling <code>setup.debug.admin(nlocal=new.frame.number)</code>. As of 2016, you can also set <code>nlocal</code> to be an environment.
</p>
<p><code>mlocal</code> functions can be nested, though this gets confusing. By default, all evaluation will happen in the same frame, that of the original caller.
</p>
<p>Note that (at least at present) all arguments are evaluated as soon as your <code>mlocal</code> function is invoked, rather than by the usual lazy evaluation mechanism. Missing arguments are still OK, though.
</p>
<p>If you call <code>return</code> in an <code>mlocal</code> function, you must call <code><a href="#topic+local.return">local.return</a></code> too.
</p>
<p><code>on.exit</code> doesn't work properly. If you want to have exit code in the <code>mlocal</code> function itself, use <code><a href="#topic+local.on.exit">local.on.exit</a></code>. I can't find any way to set the exit code in the calling function from within an <code>mlocal</code> function. (Not checked for some years)
</p>
<p>Frame-dependent functions (sys.parent()) etc. will not do what you expect inside an <code>mlocal</code> function. For R versions between at least 1.8 and 2.15, calling the <code>mvb...</code> versions will return information about the <b>caller</b> of the current <code>mlocal()</code> function caller (or the original caller, if there is a chain of <code>mlocal</code>s). For example, <code>mvb.sys.function()</code> returns the definition of the caller, and <code>mvb.sys.parent()</code> the frame of the caller's parent. Note that <code>sys.frame( mvb.sys.nframe())</code> gives the current environment (i.e. where all the variables live), because this is shared between the caller and the <code>mlocal</code> function. Other behaviour seems to depend on the version of R, and in R 2.15 I don't know how to access the definition of the <code>mlocal</code> function itself. This means, for example, that you can't reliably access attributes of the <code>mlocal</code> function itself, though you can access those of its caller via e.g. <code>attr( mvb.sys.function(), "thing")</code>.
</p>


<h3>Value</h3>

<p>As per your function; also see <code><a href="#topic+local.return">local.return</a></code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+local.return">local.return</a></code>, <code><a href="#topic+local.on.exit">local.on.exit</a></code>, <code><a href="#topic+do.in.envir">do.in.envir</a></code>, <code><a href="#topic+localfuncs">localfuncs</a></code>, and R-news 1/3 2001 for a related approach to &quot;macros&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tidiness and variable creation
init &lt;- function( nlocal=sys.parent()) mlocal( sqr.a &lt;- a*a)
ffout &lt;- function( a) { init(); sqr.a }
ffout( 5) # 25
# Parameters and temporary variables
ffin &lt;- function( n, nlocal=sys.parent(), a, i) mlocal({
    # this "n" and "a" will temporarily replace caller's "n" and "a"
    print( n)
    a &lt;- 1
    for( i in 1:n)
      a &lt;- a*x
    a
  })
x.to.the.n.plus.1 &lt;- function( x, n) {
    print( ffin( n+1))
    print( n)
    print( ls())
  }
x.to.the.n.plus.1( 3, 2) # prints as follows:
# [1] 3 (in "ffin")
# [1] 27 (result of "ffin")
# [1] 2 (original n)
# [1] "n" "x" (vars in "x.to.the..."-- NB no a or i)
# Use of "nlocal"
ffin &lt;- function( i, nlocal=sys.parent()) mlocal( a &lt;- a+i )
ffout &lt;- function( ivec) { a &lt;- 0; sapply( ivec, ffin, nlocal=sys.nframe()) }
ffout( 1:3) # 1 3 6
</code></pre>

<hr>
<h2 id='move'>Organizing R workspaces</h2><span id='topic+move'></span>

<h3>Description</h3>

<p><code>move</code> shifts one or more objects around the task hierarchy (see <code><a href="#topic+cd">cd</a></code>), whether or not the source and destination are currently attached on the search path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Usually: unquoted object name, unquoted from and to, e.g.
# move( thing, ., 0/somewhere)
# Use 'what' arg to move several objects at once, e.g.
# move( what=c( "thing1", "thing2"), &lt;&lt;etc&gt;&gt;)
# move( x, from, to)
# move( what=, from, to)
# Next line shows the formal args, but the real usage would NEVER be like this...0
move( x='.', from='.', to='.', what, overwrite.by.default=FALSE, copy=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="move_+3A_x">x</code></td>
<td>
<p>unquoted name</p>
</td></tr>
<tr><td><code id="move_+3A_from">from</code></td>
<td>
<p>unquoted path specifier (or maintained package specifier)</p>
</td></tr>
<tr><td><code id="move_+3A_to">to</code></td>
<td>
<p>unquoted path specifier (or M.P. specifier)</p>
</td></tr>
<tr><td><code id="move_+3A_what">what</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="move_+3A_overwrite.by.default">overwrite.by.default</code></td>
<td>
<p>logical(1)</p>
</td></tr>
<tr><td><code id="move_+3A_copy">copy</code></td>
<td>
<p>logical(1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal invocation is something like <code>move( myobj, ., 0/another.task)</code>&ndash; note the lack of quotes around <code>myobj</code>. To move objects with names that have to be quoted, or to move several objects at the same time, specify the <code>what</code> argument: e.g. <code>move( what=c( "myobj", "%myop%"), ., 0/another.task)</code>. Note that <code>move</code> is playing fast and loose with standard argument matching here; it correctly interprets the <code>.</code> as <code>from</code>, rather than <code>x</code>. This well-meaning subversion can lead to unexpected trouble if you deviate from the paradigms in <b>Examples</b>. If in doubt, you can always name <code>from</code> and <code>to</code>.
</p>
<p><code>move</code> can also handle moves in and out of packages being live-edited (see <code><a href="#topic+maintain.packages">maintain.packages</a></code>). If you want to specify a move to/from your package &quot;whizzbang&quot;, the syntax of <code>to</code> and <code>from</code> should be <code>..whizzbang</code> (i.e. the actual environment where the pre-installed package lives). An alternative for those short of typing practice is <code>maintained.packages$whizzbang</code>. No quotes in either case.
</p>
<p>If <code>move</code> finds an object with the same name in the destination, you will be asked whether to overwrite it. If you say no, the object will not be moved. If you want to force overwriting of a large number of objects, set <code>overwrite.by.default=TRUE</code>.
</p>
<p>By default, <code>move</code> will delete the original object after it has safely arrived in its destination. It's normally only necessary (and more helpful) to have just one instance of an object; after all, if it needs to be accessed by several different tasks, you can just <code>move</code> it to an ancestral task. However, if you really do want a duplicate, you can avoid deletion of the original by setting <code>copy=TRUE</code>.
</p>
<p>You will be prompted for whether to <code>save</code> the source and destination tasks, if they are attached somewhere, but not in position 1. Normally this is a good idea, but you can always say no, and call <code><a href="#topic+Save.pos">Save.pos</a></code> later. If the source and/or destination are not attached, they will of course be saved automatically. The top workspace (i.e. current task) <code>.GlobalEnv</code> is never saved automatically; you have to call <code><a href="#topic+Save">Save</a></code> yourself.
</p>
<p><code>move</code> is not meant to be called within other functions.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
move( myobj, ., 0) # back to the ROOT task
move( what="%myop%", 0/first.task, 0/second.task)
# neither source nor destination attached. Funny name requires "what"
move( what=c( "first.obj", "second.obj"), ., ../sibling.task)
# multiple objects require "what"
move( myobj, ..myfirstpack, ..mysecondpack) # live-edited packages

## End(Not run)
</code></pre>

<hr>
<h2 id='multirep'>Replacement and insertion functions with more/less than 1 replacement per spot</h2><span id='topic+multirep'></span><span id='topic+multinsert'></span><span id='topic+massrep'></span>

<h3>Description</h3>

<p><code>multirep</code> is like <code>replace</code>, but the replacements are a list of the same length as the number of elements to replace. Each element of the list can have 0, 1, or more elements&ndash; the original vector will be expanded/contracted accordingly. (If all elements of the list have length 1, the result will be the same length as the original.) <code>multinsert</code> is similar, but doesn't overwrite the elements in <code>orig</code> (so the result of <code>multinsert</code> is longer). <code>massrep</code> is like <code>multirep</code>, but takes lists as arguments so that a group-of-line-numbers in the first list is replaced by a group-of-lines in the second list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multirep( orig, at, repl, sorted.at=TRUE)
multinsert( orig, at, ins, sorted.at=TRUE)
massrep( orig, atlist, replist, sorted.at=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multirep_+3A_orig">orig</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="multirep_+3A_at">at</code></td>
<td>
<p>numeric vector, saying which elements of the original will be replaced or appended-to. Can't exceed <code>length(orig)</code>. 0 is legal in <code>multinsert</code> but not <code>multirep</code>. Assumed sorted unless <code>sorted.at</code> is set to FALSE.</p>
</td></tr>
<tr><td><code id="multirep_+3A_atlist">atlist</code></td>
<td>
<p>list where each element is a group of line numbers to be replaced by the corresponding element of <code>replist</code> (and that element can have a different length). Normally each group of line numbers would be consecutive, but this is not mandatory.</p>
</td></tr>
<tr><td><code id="multirep_+3A_repl">repl</code>, <code id="multirep_+3A_ins">ins</code>, <code id="multirep_+3A_replist">replist</code></td>
<td>
<p>a list of replacements. <code>repl[[i]]</code> will replace line <code>at[i]</code> in <code>orig</code>, possibly removing it (if <code>repl[[i]]</code> has length 0) or inserting extra elements (if <code>repl[[i]]</code> has length &gt; 1). In <code>multinsert</code>, <code>repl</code> can be a non-list, whereupon it will be cast to <code>list(repl)</code> [if <code>at</code> is length 1] or <code>as.list(repl)</code> [if <code>at</code> is length&gt;1]. If <code>length(repl</code>) &lt; <code>length(at)</code>, <code>repl</code> will be replicated to the appropriate size. If <code>repl</code> is atomic, it will be typecast into a list&ndash; in this case, all replacements/insertions will be of length 1.</p>
</td></tr>
<tr><td><code id="multirep_+3A_sorted.at">sorted.at</code></td>
<td>
<p>if TRUE, then <code>at</code> had better be sorted beforehand; if FALSE, <code>at</code> will be sorted for you inside <code>multirep</code>, and <code>repl</code> is reordered accordingly.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>multirep( cq( the, cat, sat, on, the, mat), c( 2, 6),
    list( cq( big, bug), cq( elephant, howdah, cushion)))
# [1] "the" "big" "bug" "sat" "on" "the" "elephant" "howdah" "cushion"
multirep( cq( the, cat, sat, on, the, mat), c( 2, 6),
    list( cq( big, bug), character(0)))
# [1] "the" "big" "bug" "sat" "on" "the"
# NB the 0 in next example:
multinsert( cq( cat, sat, on, mat), c( 0, 4),
    list( cq( fat), cq( cleaning, equipment)))
# [1] "fat" "cat" "sat" "on" "mat" "cleaning" "equipment"
</code></pre>

<hr>
<h2 id='mvb.sys.parent'>Functions to Access the Function Call Stack</h2><span id='topic+mvb.sys.parent'></span><span id='topic+mvb.sys.nframe'></span><span id='topic+mvb.parent.frame'></span><span id='topic+mvb.eval.parent'></span><span id='topic+mvb.match.call'></span><span id='topic+mvb.nargs'></span><span id='topic+mvb.sys.call'></span><span id='topic+mvb.sys.function'></span>

<h3>Description</h3>

<p>These functions are &quot;do what I mean, not what I say&quot; equivalents of the corresponding system functions. The system functions can behave strangely when called in strange ways (primarily inside <code>eval</code> calls). The <code>mvb</code> equivalents behave in a more predictable fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvb.sys.parent(n=1)
mvb.sys.nframe()
mvb.parent.frame(n=1)
mvb.eval.parent( expr, n=1)
mvb.match.call(definition = sys.function(mvb.sys.parent()),
    call = sys.call(mvb.sys.parent()),  expand.dots = TRUE, envir= mvb.parent.frame( 2))
mvb.nargs()
mvb.sys.call(which = 0)
mvb.sys.function(n)
</code></pre>


<h3>Arguments</h3>

<p>All as per the corresponding system functions, from whole helpfiles the following is taken:
</p>
<table role = "presentation">
<tr><td><code id="mvb.sys.parent_+3A_which">which</code></td>
<td>
<p>the frame number if non-negative, the number of generations to go back if negative. (See the Details section.)</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_n">n</code></td>
<td>
<p>the number of frame generations to go back.</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_definition">definition</code></td>
<td>
<p>a function, by default the function from which <code>match.call</code> is called.</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_call">call</code></td>
<td>
<p>an unevaluated call to the function specified by <code>definition</code>, as generated by <code>call</code>.</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_expand.dots">expand.dots</code></td>
<td>
<p>logical. Should arguments matching <code>...</code> in the call be included or left as a <code>...</code> argument?</p>
</td></tr>
<tr><td><code id="mvb.sys.parent_+3A_envir">envir</code></td>
<td>
<p>an environment from which the ... in call are retrieved, if any (as per <code>base::match.call</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes <code>eval</code> is used to execute statements in another frame. If such statements include calls to the system versions of these routines, the results will probably not be what you want. In technical terms: the same environment will actually appear several times on the call stack (returned by <code>sys.frame()</code>) but with a different calling history each time. The <code>mvb.</code> equivalents look through <code>sys.frames()</code> for the first frame whose environment is identical to the environment they were called from, and base all conclusions on that first frame. To see how in detail, look at the most fundamental function: <code>mvb.sys.parent</code>.
</p>
<p><code>mvbutils</code> pre 2.7 used to include <code>mvb.sys.on.exit</code> as well (to return whatever the <code>on.exit</code> code would be), but I think this was by mistake; the code was actually specific to my <code>debug</code> package (which already has its own substitute), and so I've moved it out of <code>mvbutils</code>.
</p>


<h3>Value</h3>

<p>See the helpfiles for the system functions.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>sys.parent</code>, <code>sys.nframe</code>, <code>parent.frame</code>, <code>eval.parent</code>, <code>match.call</code>, <code>nargs</code>, <code>sys.call</code>, <code>sys.function</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff.no.eval &lt;- function() sys.nframe()
ff.no.eval() # 1
ff.system &lt;- function() eval( quote( sys.nframe()), envir=sys.frame( sys.nframe()))
ff.system() # expect 1 as per ff.no.eval, get 3
ff.mvb &lt;- function() eval( quote( mvb.sys.nframe()), envir=sys.frame( sys.nframe()))
ff.mvb() # 1
ff.no.eval &lt;- function(...) sys.call()
ff.no.eval( 27, b=4) # ff.no.eval( 27, b=4)
ff.system &lt;- function(...) eval( quote( sys.call()), envir=sys.frame( sys.nframe()))
ff.system( 27, b=4) # eval( expr, envir, enclos) !!!
ff.mvb &lt;- function(...) eval( quote( mvb.sys.call()), envir=sys.frame( sys.nframe()))
ff.mvb( 27, b=4) # ff.mvb( 27, b=4)
</code></pre>

<hr>
<h2 id='mvbutils.operators'>Utility operators</h2><span id='topic+mvbutils.operators'></span><span id='topic++25+26+25'></span><span id='topic++25+21in+25'></span><span id='topic++25+2A+2A+25'></span><span id='topic++25except+25'></span><span id='topic++25grepling+25'></span><span id='topic++25is.not.a+25'></span><span id='topic++25is.a+25'></span><span id='topic++25is.not.an+25'></span><span id='topic++25is.an+25'></span><span id='topic++25matching+25'></span><span id='topic++25not.in+25'></span><span id='topic++25not.in.range+25'></span><span id='topic++25perling+25'></span><span id='topic++25that.match+25'></span><span id='topic++25that.dont.match+25'></span><span id='topic++25that.are.in+25'></span><span id='topic++25without.name+25'></span><span id='topic++25in.range+25'></span><span id='topic++25such.that+25'></span><span id='topic++25SUCH.THAT+25'></span><span id='topic++25upto+25'></span><span id='topic++25downto+25'></span><span id='topic++25where+25'></span><span id='topic++25where.warn+25'></span><span id='topic++25+3C-+25'></span>

<h3>Description</h3>

<p>Succinct or convenience operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %&amp;% b
x %**% y
a %!in% b
vector %except% condition
x %grepling% patt
x %is.not.a% what
x %is.a% what
x %is.not.an% what
x %is.an% what
x %matching% patt
a %not.in% b
a %not.in.range% b
x %perling% patt
x %that.match% patt
x %that.dont.match% patt
a %that.are.in% b
x %without.name% what
a %in.range% b
a %such.that% b
a %SUCH.THAT% b
from %upto% to
from %downto% to
x %where% cond
x %where.warn% cond
a %&lt;-% value # really e.g. {x;y} %&lt;-% list( 'yes', sqrt(pi)) to create x &amp; y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvbutils.operators_+3A_a">a</code>, <code id="mvbutils.operators_+3A_b">b</code>, <code id="mvbutils.operators_+3A_vector">vector</code>, <code id="mvbutils.operators_+3A_condition">condition</code>, <code id="mvbutils.operators_+3A_x">x</code>, <code id="mvbutils.operators_+3A_y">y</code>, <code id="mvbutils.operators_+3A_what">what</code>, <code id="mvbutils.operators_+3A_patt">patt</code>, <code id="mvbutils.operators_+3A_from">from</code>, <code id="mvbutils.operators_+3A_to">to</code>, <code id="mvbutils.operators_+3A_cond">cond</code>, <code id="mvbutils.operators_+3A_value">value</code></td>
<td>
<p>see <b>Arguments by function</b>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>%&amp;%</code></td>
<td>
<p>character vector. If either is zero-length, so is the result (unlike <code>paste</code>).</p>
</td></tr>
<tr><td><code>%**%</code></td>
<td>
<p>numeric, possibly a matrix</p>
</td></tr>
<tr><td><code>%upto%</code>, <code>%downto%</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>%is.a%</code>, <code>%in%</code>, <code>etc</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code>%&lt;-%</code></td>
<td>
<p>technically NULL return, but it overwrites / creates objects; see below...</p>
</td></tr>
<tr><td><code>All others</code></td>
<td>
<p>same type as first argument.</p>
</td></tr>
</table>


<h3>Arguments by function</h3>

<p><code>%&amp;%</code> a, b: character vectors to be <code>paste</code>d with no separator. If either is zero-length, so is the result (unlike <code>paste</code>).
</p>
<p><code>%**%</code> x, y: matrices or vectors to be multiplied using <code>%*%</code> but with less fuss about dimensions
</p>
<p><code>%!in%</code>, <code>%that.are.in%</code> a, b: vectors (character, numeric, complex, or logical).
</p>
<p><code>%except%</code> vector, condition: character or numeric vectors
</p>
<p><code>%in.range%</code>, <code>%not.in.range%</code> a, b: numeric vectors.
</p>
<p><code>%is.a%</code>, etc. x: object whose class is to be checked
</p>
<p><code>%is.a%</code>, etc. what: class name
</p>
<p><code>%matching%</code>, <code>%that.match%</code>, <code>%that.dont.match%</code>, <code>%grepling%</code>, <code>%perling%</code> x: character vector
</p>
<p><code>%matching%</code>, <code>%that.match%</code>, <code>%that.dont.match%</code>, <code>%grepling%</code>, <code>%perling%</code> patt: character vector of regexps, with perl syntax for <code>%perling%</code>
</p>
<p><code>%such.that%</code>, <code>%SUCH.THAT%</code> a: vector
</p>
<p><code>%such.that%</code>, <code>%SUCH.THAT%</code> b: expression containing a <code>.</code>, to subscript <code>a</code> with
</p>
<p><code>%upto%</code>, <code>%downto%</code> from, to: numeric(1)
</p>
<p><code>%where%</code>, <code>%where.warn%</code> x: data.frame
</p>
<p><code>%where%</code>, <code>%where.warn%</code> cond: unquoted expression to be <code>eval</code>ed in context of <code>x</code>, then in the calling frame of <code>%where%</code> (or <code>.GlobalEnv</code>). Should evaluate to logical (or maybe numeric or character); NA is treated as FALSE. Wrap <code>cond</code> in parentheses to avoid trouble with operator precedence.
</p>
<p><code>%without.name%</code> x: object with <code>names</code> attribute
</p>
<p><code>%without.name%</code> what: character vector of names to drop
</p>
<p><code>%&lt;-%</code> a, value: <code>value</code> should be a list, and <code>a</code> should be e.g. <code>{x;y;z}</code> with as many elements as <code>value</code> has. The elements of <code>value</code> are assigned, in order, to the objects named in <code>a</code>, which are created / overwritten in the calling environment.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p>bquote
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"a" %&amp;% "b" # "ab"
matrix( 1:4, 2, 2) %**% matrix( 1:2, 2, 1) # c( 7, 10); '%*%' gives matrix result
matrix( 1:2, 2, 1) %**% matrix( 1:4, 2, 2) # c( 5, 11); '%*%' gives error
1:2 %**% matrix( 1:4, 2, 2) # '%*%' gives matrix result
1:5 %!in% 3:4 # c( TRUE, TRUE, FALSE, FALSE, TRUE)
1:5 %not.in% 3:4 # c( TRUE, TRUE, FALSE, FALSE, TRUE)
1:5 %that.are.in% 3:4 # c( 3, 4)
trf &lt;- try( 1+"nonsense")
if( trf %is.not.a% "try-error") cat( "OK\n") else cat( "not OK\n")
1:5 %except% c(2,4,6) # c(1,3,5)
c( alpha=1, beta=2) %without.name% "alpha" # c( beta=2)
1:5 %in.range% c( 2, 4) # c(F,T,T,T,F)
1:5 %not.in.range% c( 2, 4) # c(T,F,F,F,T)
c( "cat", "hat", "dog", "brick") %matching% c( "at", "ic") # cat hat brick
c( "cat", "hat", "dog", "brick") %that.match% c( "at", "ic") # cat hat brick; ...
# ... synonym for '%matching%'
c( "cat", "hat", "dog", "brick") %that.dont.match% c( "at", "ic") # dog; ...
# ... like '%except%' but for regexps
1 %upto% 2 # 1:2
1 %upto% 0 # numeric( 0); use %upto% rather than : in for-loops to avoid unintended errors
1 %downto% 0 # 1:0
1 %downto% 2 # numeric( 0)
ff &lt;- function( which.row) {
    x &lt;- data.frame( a=1:3, b=4:6)
    x %where% (a==which.row)
  }
ff( 2) # data.frame( a=2, b=5)
x &lt;- data.frame( start=1:3, end=c( 4, 5, 0))
x %where.warn% (start &lt; end) # gives warning about row 3
(1:5) %such.that% (.&gt;2) # 3,4,5
listio &lt;- list( a=1,  b=2)
chars &lt;- cq( a, b)
chars %SUCH.THAT% (listio[[.]]==2) # 'b'; %such.that% won't work because [[]] can't handle xtuples
{x;y} %&lt;-% list( 'yes', sqrt(pi))
# x: [1] "yes"
# y: [1] 1.772
</code></pre>

<hr>
<h2 id='mvbutils.packaging.tools'>How to create &amp; maintain packages with mvbutils</h2><span id='topic+mvbutils.packaging.tools'></span>

<h3>Description</h3>

<p>This document covers:
</p>

<ul>
<li><p> using <code>mvbutils</code> to create a new package from scratch;
</p>
</li>
<li><p> using <code>mvbutils</code> to maintain a package you've created (e.g. edit it while using it);
</p>
</li>
<li><p> converting an existing package into <code>mvbutils</code>-compatible format;
</p>
</li>
<li><p> how to customize the package-creation process.
</p>
</li></ul>

<p>For clarity, the simplest usage is presented first in each case. For how to do things differently, first look further down this document, then in the documentation for <code><a href="#topic+pre.install">pre.install</a></code> and perhaps <code><a href="#topic+doc2Rd">doc2Rd</a></code>.
</p>
<p>You need to understand <code><a href="#topic+cd">cd</a></code> and <code><a href="#topic+fixr">fixr</a></code> before trying any of this.
</p>


<h3>Setting up a package from scratch</h3>

<p>First, the simplest case: suppose you have some pure R code and maybe data that you'd like to make into a package called &quot;Splendid&quot;. The bare-minimum steps you need are:-
</p>

<ul>
<li><p> Make sure all the code &amp; data lives in a single task called &quot;Splendid&quot;.
</p>
</li>
<li> <p><code><a href="#topic+cd">cd</a></code> to the task above &quot;Splendid&quot;
</p>
</li>
<li> <p><code>maintain.packages( Splendid)</code>
</p>
</li>
<li> <p><code>pre.install( Splendid)</code>. This will create a &quot;source package&quot; in a subdirectory of Splendid's task directory. The subdirectory will be called &quot;Splendid&quot;.
</p>
</li>
<li><p> Make sure you have all the R build tools installed and on your path&ndash; see &quot;R-exts&quot; for details (and NB that if you need to install Latex, then google MikTex &amp; choose a <em>minimal</em> install).
</p>
</li>
<li> <p><code>install.pkg( Splendid)</code> to do what you'd expect. On Windows, you can alternatively first do <code>build.pkg.binary( Splendid)</code>, then use R's menus to &quot;Packages/Install from local zip files&quot;.
</p>
</li>
<li> <p><code>library(Splendid)</code>; your package will be loaded for use, and is also ready for live-editing.
</p>
</li></ul>

<p>Your package will probably just about work now, but the result won't yet be perfect. The additional steps you'll likely need are these:
</p>

<ul>
<li><p> Sort out the <b>Description file or object</b>[(]see below[)]
</p>
</li>
<li><p> Provide <b>Documentation and metadata</b>[(]see below[)]
</p>
</li>
<li><p> Sort out any C/Fortran source code, pre-compiled code, demos, and other additional files (see <code><a href="#topic+pre.install">pre.install</a></code>)
</p>
</li>
<li><p> Move any subtasks of Splendid to one level up the task hierarchy (see <code><a href="#topic+maintain.packages">maintain.packages</a></code>)
</p>
</li></ul>

<p>Once you have set up &quot;Splendid&quot; so that <code><a href="#topic+maintain.packages">maintain.packages</a></code> works, you won't need to <code><a href="#topic+cd">cd</a></code> directly into &quot;Splendid&quot; again&mdash; which is good, because you're not allowed to.
</p>


<h4>Glossary</h4>

<p><em>Task package</em> is a folder with at least an &quot;.RData&quot; file, linked into the <code><a href="#topic+cd">cd</a></code> hierarchy. It contains master copies of the objects in your package, plus perhaps a few other objects required to build the package (e.g. stand-alone items of documentation).
</p>
<p><em>In-memory task package</em> is an environment in the current R session that contains an image of the task package. Objects in it are never used directly, only as templates for editing. It is loaded by <code><a href="#topic+maintain.packages">maintain.packages</a></code>, and <code><a href="#topic+Save.pos">Save.pos</a></code> uses it to update the task package (usually automatic).
</p>
<p><em>Source package</em> is a folder containing, yes, an R-style source package. It is created initially by <code><a href="#topic+pre.install">pre.install</a></code>, and subsequently by <code><a href="#topic+patch.install">patch.install</a></code> or <code><a href="#topic+pre.install">pre.install</a></code>.
</p>
<p><em>Installed package</em> is a folder containing, yes, an R-style installed package. It is always created from the source package, initially by <code><a href="#topic+install.pkg">install.pkg</a></code> and subsequently by <code><a href="#topic+patch.install">patch.install</a></code> or <code><a href="#topic+install.pkg">install.pkg</a></code>.
</p>
<p><em>Loaded package</em> is the in-memory version of an installed package, loaded by <code>library</code>.
</p>
<p><em>Tarball package</em> is a zipped-up version of a source package, for distro on non-Windows-Mac platforms or submission to CRAN and subsequent installation via &quot;R CMD INSTALL&quot;. Usually it will not contain DLLs of any low-level code, just the source low-level code. It is created by <code><a href="#topic+build.pkg">build.pkg</a></code>.
</p>
<p><em>Binary package</em> is a special zipped-up version for distro to Windows or Macs that includes actual DLLs, for installation via e.g. the &quot;Packages/Install from local ZIP&quot; menu. It is created by <code><a href="#topic+build.pkg.binary">build.pkg.binary</a></code>.
</p>
<p><em>Built package</em> is a tarball package or binary package.
</p>



<h3>Converting an existing package</h3>

<p>Suppose you have already have a <em>source</em> package &quot;hardway&quot;, and would like to try maintaining it via <code>mvbutils</code>. You'll need to create a task package, then create a new version of the source package, then re-install it. The first step is to call <code>unpackage( hardway)</code> to creat the task package &quot;hardway&quot; in a subdirectory of the current task. Plain-text documentation will be attached to functions, or stored as &quot;.doc&quot; text objects. All functions and documentation must thereafter be edited using <code><a href="#topic+fixr">fixr</a></code>. The full sequence is something like:
</p>
<pre>
  # Create task package in subdirectory of current:
  unpackage( "path/to/existing/source/package/hardway")
  #
  # Load image into memory:
  maintain.packages( hardway)
  #
  # Make new version of source package:
  pre.install( hardway, ...) # use dir= to control where new source pkg goes
  #
  install.pkg( hardway) # or build.pkg.binary( hardway) followed by "install from local zip file" menu
  #
  library( hardway) # off yer go
</pre>
<p>If you get problems after <code><a href="#topic+maintain.packages">maintain.packages</a></code>, you might need <code>unmaintain.package( hardway)</code> to clear out the in-memory copy of the new task package.
</p>


<h3>Documentation and metadata</h3>

<p>Documentation for functions can be stored as plain text just after a function's source code, as described in <code><a href="#topic+flatdoc">flatdoc</a></code>. Just about anything will do&ndash; you don't absolutely have to follow the conventional structure of R help if you are really in a hurry. However, the easiest way to add kosheR but skeletal documentation to your function <code>brilliant</code>, is <code>fixr( brilliant, new.doc=TRUE)</code>; again, see <code><a href="#topic+flatdoc">flatdoc</a></code> and <code><a href="#topic+doc2Rd">doc2Rd</a></code> if you want to understand what's going on. The format is almost exactly as displayed in plain-text help, i.e. from <code>help(..., help_type="text")</code>. My recommendation is to just start writing something that looks reasonable, and see if it works. To quickly test the ultimate appearance, you can use e.g. <code>docotest(..Splendid$brilliant)</code>. More generally, run <code>patch.install(Splendid)</code> which, as explained in <b>Maintaining a package</b> below, updates everything for your package including the help system, so you can then just do <code>?brilliant</code>. If you run into problems with writing documentation for your functions, then refer to <code><a href="#topic+doc2Rd">doc2Rd</a></code> for further details of format, such as how to document several functions in the same file.
</p>
<p>You can also provide three other types of documentation, for: (i) general use of your package (please do! it helps the user a lot; packages where the doco PDF consists only of an alphabetical list of functions/objects are a pain); (ii) more specific aspects of usage that are not tied to individual functions, such as this file; and (iii) datasets. These types of documentation should be stored in the package as text objects whose name ends in &quot;.doc&quot;; examples of the three types could be &quot;Splendid.package.doc&quot;, &quot;glitzograms.with.Splendid.doc&quot;, and &quot;earlobes.doc&quot; if you have a dataset <code>earlobes</code>. See <code><a href="#topic+doc2Rd">doc2Rd</a></code> for format details.
</p>
<p>You must document every function and dataset that the user will see, but you don't need to document any others. The foregoing applies iff your package has a <b>Namespace</b>, which it must for R 2.14 up.
</p>


<h4>Description file or object</h4>

<p>When you first create a package from a task via <code><a href="#topic+pre.install">pre.install</a></code>, there probably won't be any DESCRIPTION information, so <code>mvbutils</code> will create a default &quot;DESCRIPTION&quot; file in your task folder, which it then copies to the source package. However, the default won't really be what you really want, as you'll realize if you type <code>library( help=Splendid)</code>. You can either manually edit the default &quot;DESCRIPTION&quot; file, or you can use <code>fixtext(Splendid.DESCRIPTION, pkg="Splendid")</code> to create a text object in your task package, which you then populate with the contents of the default &quot;DESCRIPTION&quot; file, and then edit. If a <code>Splendid.DESCRIPTION</code> object exists, <code>mvbutils</code> will use it in preference to a file; I find this tidier, because more of the package metadata lives in a single place, viz. inside the task package.
</p>
<p>Apart from the obvious changes needed to the default &quot;DESCRIPTION&quot; file or text object, the most important fields to add are &quot;Imports:&quot; (or &quot;Depends:&quot; for packages that are pre-R2.14 and that also don't have a namespace), to say what other packages are needed by &quot;Splendid&quot;. The DESCRIPTION file/text should rarely need to be updated, since the &quot;autoversion&quot; feature (see <code><a href="#topic+pre.install">pre.install</a></code> doco) can be used to take care of version numbering. The most common reason to change the DESCRIPTION is probably to add/remove packages in &quot;Imports&quot;; at present, this pretty much requires you to unload &amp; reload the package, but I may try to expedite this in future versions.
</p>



<h4>Vignettes</h4>

<p>In time, I plan to get <code>mvbutils</code> working nicely with <code>knitr</code>. At present (Jan 2013), the easiest way to create vignettes with <code>mvbutils</code> is to produce your own &quot;homebrewed&quot; PDFs however you prefer, and put them into the &quot;inst/doc&quot; folder. <code>pre.install/patch.install</code> will sort them out and link them into the help system. To provide more information than the filename, use <code><a href="#topic+fixtext">fixtext</a></code> to create a text object in your task package called e.g. <code>mypack.VIGNETTES</code>, with lines as follows:
</p>
<pre>
  my.first.vignette: Behold leviathan, mate
  my.second.vignette: What a good idea, to write a vignette
</pre>
<p>As a <em>very</em> experimental feature, you can also include R code for a homebrewed vignette, via a file with the same name but extension &quot;.R&quot; also in &quot;inst/doc&quot;. Users can access it as normal for vignette code, via <code>edit( vignette( "my.first.vignette", package="mypack"))</code> or via doing something to <code>system.file( file.path( "doc", "my.first.vignette.R"), package="mypack")</code>.
</p>
<p>You can put full-on Sweave-style vignettes into a &quot;vignettes&quot; folder, and they should be set up correctly in the source package. Currently, though, they are <b>not</b> re-installed by <code><a href="#topic+patch.install">patch.install</a></code>; you need to use <code><a href="#topic+build.pkg">build.pkg</a></code> and <code><a href="#topic+install.pkg">install.pkg</a></code> (partly defeating the point of these package-building utilities).
</p>


<h5>Very technical details about homebrewed vignettes</h5>

<p>&quot;Rnw stubs&quot; are created for all homebrewed vignettes so that the help system finds them. A rudimentary index will be created for vignettes not mentioned in <code>&lt;&lt;mypack&gt;&gt;.VIGNETTES</code>. If you create your own &quot;inst/doc/index.html&quot; file, this takes precedence over mvbutil's versions, so that <code>&lt;&lt;mypack&gt;&gt;.VIGNETTES</code> is not used.
</p>




<h4>Namespace</h4>

<p>Usually this is automatic. <code><a href="#topic+pre.install">pre.install</a></code> etc automatically creates a &quot;NAMESPACE&quot; file for your package, ensuring inter alia that all documented objects are user-visible. To load DLLs, add a <code>.onLoad</code> function that contains the body code of <code><a href="#topic+generic.dll.loader">generic.dll.loader</a></code> in package <span class="pkg">mvbutils</span> (thus avoiding dependence on <code>mvbutils</code>). For more complicated fiddling, see <b>Customizing package creation</b>.
</p>


<h5>Packages without namespaces pre r 2 14</h5>

<p>Namespaces only became compulsory with R 2.14. If you're setting up your package in an earlier version of R, <code>mvbutils</code> will <em>not</em> create a namespace unless it finds a <code>.onLoad</code> function. To trigger namespacing, just create a <code>.onLoad</code> with this definition: <code>function( libname, pkgname) {}</code>.
</p>




<h3>Maintaining a package</h3>

<p>Once you have successfully gotten your &quot;Splendid&quot; package installed and loaded the first time, you should rarely need to call <code><a href="#topic+install.pkg">install.pkg</a></code> or <code><a href="#topic+build.pkg">build.pkg</a></code> etc again, except when you are about to distribute to others. In your own work, after calling <code><a href="#topic+maintain.packages">maintain.packages</a></code> and <code>library</code> in an R session, you can modify, add and delete functions, datasets, and documentation in your package via the standard functions <code><a href="#topic+fixr">fixr</a></code>, <code><a href="#topic+move">move</a></code>, and <code><a href="#topic+rm.pkg">rm.pkg</a></code> (or directly), and these changes will mostly be immediately manifested in the loaded package within your R session&ndash; this is &quot;live editing&quot;. The changes are made first to the in-memory task package, which will be called e.g. <code>..Splendid</code>, and then propagated to the loaded package. Don't try to manipulate the loaded package's namespace directly. See <code><a href="#topic+maintain.packages">maintain.packages</a></code> for details.
</p>
<p>To update the installed package (on disk), call <code>patch.install( Splendid)</code>; this also calls <code><a href="#topic+pre.install">pre.install</a></code> to update the source package, updates the help system in the current session, and does a few other synchronizations. You need to call <code><a href="#topic+patch.install">patch.install</a></code> before quitting R to ensure that the changes are manifest in the loaded package the next time you start R; otherwise they will only exist in the in-memory task package, and won't be callable.
</p>


<h4>Troubleshooting</h4>

<p>In rare cases, you may find that <code>maintain.packages( Splendid)</code> fails. If that happens, there won't be a <code>..Splendid</code> environment, which means you can't fix whatever caused the load failure. The load failure is (invariably in my experience) caused by a hidden attempt to load a namespaced package, which is failing for yet another reason, usually something in its <code>.onLoad</code>; that package might or might not be &quot;Splendid&quot; itself. If you can work out what other package is trying to load itself&ndash; say <code>badpack</code>&ndash; you can temporarily get round the problem by making use of the character vector <code>partial.namespaces</code>, which lives in the &quot;mvb.session.info&quot; search environment, as follows:
</p>
<pre>
  partial.namespaces &lt;&lt;- c( partial.namespaces, "badpack")
</pre>
<p>That will prevent execution of <code>badpack:::.onLoad</code>. Consequently <code>badpack</code> won't be properly loaded, but at least the task package will be loaded into <code>..Splendid</code>, so that you can make a start on the problem. If you can't work out which package is causing the trouble, try
</p>
<pre>
  partial.namespaces &lt;&lt;- "EVERY PACKAGE"
</pre>
<p>After that, no namespaced package will load properly, so remember to clear <code>partial.namespaces &lt;&lt;- NULL</code> before resuming normal service.
</p>
<p>Occasionally (usually during <code><a href="#topic+patch.install">patch.install</a></code>), you might see R errors like &quot;cannot allocate vector of size 4.8Gb&quot;. I think this happens when some internal cache gets out-of-synch. It doesn't seem to cause much damage to the installed package, but once it's happened in an R session, it tends to happen again. I usually quit &amp; restart R.
</p>
<p>You might also find <code><a href="#topic+find.lurking.envs">find.lurking.envs</a></code> useful, via <code>eapply( ..Splendid, find.lurking.envs)</code>; this will show any functions (or other things) in <code>..Splendid</code> that have accidentally acquired a non-standard environment such as a namespace, which can trigger a &quot;hidden&quot; package load attempt. The environment for all functions in <code>..Splendid</code> <em>should</em> probably be <code>.GlobalEnv</code>; the environments in the <em>loaded</em> package will be different, of course.
</p>
<p>It's rare to need to manually inspect either the source package or the installed package. But if you do, then <code><a href="#topic+spkg">spkg</a></code> helps for the former, e.g. <code>dir( spkg( mypack))</code>; and <code>system.file</code> helps for the latter, e.g. <code>system.file( package="mypack")</code>, or <code>system.file( file.path( "help", "AnIndex"), package="mypack")</code>.
</p>



<h3>Distributing and checking</h3>

<p><code><a href="#topic+build.pkg">build.pkg</a></code> calls R CMD BUILD to create a &quot;tarball&quot; of the package (a &quot;.tar.gz&quot; file), which is the appropriate format for distribution to Unix folk and submission to CRAN. <code><a href="#topic+build.pkg.binary">build.pkg.binary</a></code> creates a binary package (a &quot;.zip&quot; file), suitable for Windows or Macs. <code><a href="#topic+check.pkg">check.pkg</a></code> runs R CMD CHECK (but see next paragraph for a quicker alternative), which is required by CRAN and sometimes useful at other times. These <code>.pkg</code> functions are pretty simple wrappers to the R CMD tools with similar names. However, for those with imperfect memories and limited time, there are enough arcane and mutable nuances with the &quot;raw&quot; R CMD commands (including the risk of inadvertently deleting existing installations) to make the wrappers in <code>mvbutils</code> useful.
</p>
<p>Various functions in the <span class="pkg">tools</span> package can be used to quickly check specific aspects of an <em>installed</em> package, without needing a full-on, and slow, R CMD CHECK. In particular, I sometimes use
</p>
<pre>
  codoc( spkg( mypack)) # also spkg( "mypack"), spkg( ..mypack)
  undoc( spkg( ..mypack))
</pre>
<p>Nothing is printed unless a problem is found, so a blank result is good news! It's also possible to run other tools such as <code>checkTnF</code> and <code>checkFF</code> similarly.
</p>
<p>By default, <code>mvbutils</code> adds code to the source package to circumvent the CRAN checks for &quot;no visible function/binding&quot;, which I consider to be a waste of time; for example, unless circumvented they generate 338 false positives for package <span class="pkg">mvbutils</span>. If for some reason you actually want these checks, see &quot;Overriding defaults&quot; in <code><a href="#topic+pre.install">pre.install</a></code>.
</p>


<h3>Folders and different r versions</h3>

<p>Life can get complicated when there are several versions of R around, particularly when they require different package formats at source or build or install time (eg R 2.10, 2.12, R 3.0). <code><a href="#topic+install.pkg">install.pkg</a></code> etc do their best to simplify this for you. You won't normally need to know the details unless you are trying to maintain several versions of your package for different versions of R for distribution to other people who use those different R versions. But if you do need to know the details, then the default folder structure is as follows. If the task package lives in folder &quot;mypack&quot;, then the source package is created by <code><a href="#topic+pre.install">pre.install</a></code> in &quot;mypack/mypack&quot;, and the built package(s) will go into folders such as &quot;mypack/R2.15&quot; depending on what R version is running.
</p>
<p>Note that your <em>task package</em> can only ever have one version; if different behaviour is required for different R versions, then you need to code this up your functions, or via some trickery in <code>.onLoad</code>.
</p>


<h4>Built packages</h4>

<p>Building comes first: the tarballed/zipped packages from <code><a href="#topic+build.pkg">build.pkg</a></code> and <code><a href="#topic+build.pkg.binary">build.pkg.binary</a></code> are placed in a folder parallel to the source package, with a name of the form &quot;Rx.y&quot;. <code>mvbutils</code> tries to be sensible about what &quot;x.y&quot; should be. It will never be newer than the <em>running</em> R version. It will never be older than the most recent major R version that required mandatory package rebuilds (eg R 3.0 and R 2.12). If one or more folders already exist that satisfy those properties, the highest-numbered one will be used. If not, a new folder will be created with the current R major version (eg R 2.15.3 will trigger a folder &quot;R2.15&quot;). You can create your own &quot;Rx.y&quot; folder, for instance if the current version of your package requires an R feature only found in R version &quot;x.y&quot;. Also, <code>mvbutils</code> knows which R versions change the format of built packages, and will create a new folder for such a version if required.
</p>
<p>The default behaviour is therefore that <code>build.pkg.&lt;binary&gt;</code> will keep building into the same folder. For example, if at some point a &quot;mypack/R2.12&quot; folder was created, then that's where all builds will be sent regardless of the running R version, until you either manually create an &quot;mypack/Rx.y&quot; folder that's closer to the running R version, or the latter hits 3.0 which automatically triggers the creation of a new &quot;mypack/R3.0&quot; folder. Thanks to the &quot;autoversion&quot; feature of <code><a href="#topic+pre.install">pre.install</a></code>, the version number of the build will change whenever <code>&lt;pre/patch&gt;.install</code> is used. (Note that old built packages are not removed until/unless you explicitly call <code><a href="#topic+cull.old.builds">cull.old.builds</a></code>, although it's &quot;good housekeeping&quot; to do the latter occasionally.) By manually creating new &quot;Rx.y&quot; folder when necessary, you can ensure that there <em>won't</em> be any updates to built packages for R older than &quot;x.y&quot;, which gives a kind of &quot;checkpoint&quot; feature; your built packages for older versions of R (ie for distribution to users of those older R versions) won't be accidentally zapped by <code><a href="#topic+cull.old.builds">cull.old.builds</a></code> housekeeping, and you can be sure that old code running under old versions of R will still work.
</p>
<p>What this does <em>not</em> let you do easily, is use your current R version to create updated versions of your package for R-versions that pre-date the most up-to-date &quot;Rx.y&quot; folder. For example, if you are running R3.0, there is guaranteed to be an &quot;R3.0&quot; folder, so calling <code>build.pkg&lt;.binary&gt;</code> won't build new packages in an &quot;R2.15&quot; folder. Again, usually this doesn't matter, because new &quot;Rx.y&quot; folders are only rarely created automatically, so builds will tend to stay in the same folder and the newest version will be accessible to all. But sometimes it is a hassle... Nevertheless, I have managed to maintain parallel versions of my packages across the R2.15-R3.0 change, by (sequentially) running two R versions and calling <code>build.pkg&lt;.binary&gt;</code> from each. (Note that <code>build.pkg&lt;.binary&gt;</code> can only build in the format of running R version&ndash; you can't &quot;cross-build&quot; for different built formats from the same R session.)
</p>



<h4>Source packages</h4>

<p>R occasionally demands a change in <em>source</em> package format, as opposed to <em>built</em> package format (as with R 3.0). (IIRC one example is R 2.10, with the change in helpfile format.) Then you face the problem of how to keep several source packages. This can be controlled by <code>options("mvbutils.sourcepkgdir.postfix")</code>, which is appended to the name of the folder where your source package will be created and used for building or installing. The default is the empty string <code>""</code>, so that the default source package folder for &quot;mypack&quot; is &quot;mypack/mypack&quot;. To allow for multiple source package versions, you could put something like this in your <code>.First</code> or &quot;.Rprofile&quot;:
</p>
<pre>
  if( getRversion() &gt;= numeric_version( '4.0')) {
    # New source package format
    options( mvbutils.sourcepkgdir.postfix='[R4]')
  }
</pre>
<p>Everything <em>should</em> then work automatically; all source-package operations will refer to &quot;mypack/mypack[R4]&quot; if you are running version 4 or above, or to &quot;mypack/mypack&quot; if you are running an earlier R version, and you should never really need to know the source package foldername yourself (<code><a href="#topic+build.pkg">build.pkg</a></code> etc do it all for you). This depends on you setting the option yourself, and <em>has not been tested</em> yet. Eventually I may hardwire the feature automatically into <code>mvbutils</code> (or is it better for each source package to go into an appropriate built-package folder? but that sounds a bit like version hell).
</p>



<h3>Customizing package creation</h3>

<p>You can customize many aspects of the <span class="pkg">mvbutils</span> package-creation process, by adding a function <code>pre.install.hook.Splendid</code> to your package. See <code><a href="#topic+pre.install">pre.install</a></code> for further details.
</p>

<hr>
<h2 id='mvbutils.utils'>Miscellaneous utilities</h2><span id='topic+mvbutils.utils'></span><span id='topic+as.cat'></span><span id='topic+clip'></span><span id='topic+cq'></span><span id='topic+deparse.names.parsably'></span><span id='topic+empty.data.frame'></span><span id='topic+env.name.string'></span><span id='topic+expanded.call'></span><span id='topic+everyth'></span><span id='topic+find.funs'></span><span id='topic+find.lurking.envs'></span><span id='topic+index'></span><span id='topic+integ'></span><span id='topic+is.dir'></span><span id='topic+isF'></span><span id='topic+isT'></span><span id='topic+legal.filename'></span><span id='topic+lsall'></span><span id='topic+masked'></span><span id='topic+masking'></span><span id='topic+mkdir'></span><span id='topic+most.recent'></span><span id='topic+my.all.equal'></span><span id='topic+named'></span><span id='topic+nscat'></span><span id='topic+nscatn'></span><span id='topic+option.or.default'></span><span id='topic+pos'></span><span id='topic+put.in.session'></span><span id='topic+returnList'></span><span id='topic+safe.rbind'></span><span id='topic+scatn'></span><span id='topic+to.regexpr'></span><span id='topic+yes.no'></span>

<h3>Description</h3>

<p>Miscellaneous utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.cat( x)
clip( x, n=1)
cq( ...)
deparse.names.parsably( x)
empty.data.frame( ...)
env.name.string( env)
expanded.call( nlocal=sys.parent())
everyth( x, by=1, from=1)
find.funs(pos=1, ..., exclude.mcache = TRUE, mode="function")
find.lurking.envs(obj, delve=FALSE, trace=FALSE)
index( lvector)
integ(expr, lo, hi, what = "x", ..., args.to.integrate = list())
is.dir( dir)
isF( x)
isT( x)
legal.filename( name)
lsall( ...)
masked( pos)
masking( pos=1)
mkdir( dirlist)
most.recent( lvec)
my.all.equal( x, y, ...)
named( x)
nscat( fmt, ..., sep='\n', file='')
nscatn( fmt, ..., sep='\n', file='')
option.or.default( opt.name, default=NULL)
pos( substrs, mainstrs, any.case = FALSE, names.for.output)
put.in.session( ...)
returnList( ...)
safe.rbind( df1, df2) # Deprecated in 2013
scatn( fmt, ..., sep='\n', file='')
to.regexpr( x)
yes.no( prompt, default)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvbutils.utils_+3A_x">x</code>, <code id="mvbutils.utils_+3A_y">y</code>, <code id="mvbutils.utils_+3A_n">n</code>, <code id="mvbutils.utils_+3A_...">...</code>, <code id="mvbutils.utils_+3A_by">by</code>, <code id="mvbutils.utils_+3A_env">env</code>, <code id="mvbutils.utils_+3A_from">from</code>, <code id="mvbutils.utils_+3A_exclude.mcache">exclude.mcache</code>, <code id="mvbutils.utils_+3A_nlocal">nlocal</code>, <code id="mvbutils.utils_+3A_lvector">lvector</code>, <code id="mvbutils.utils_+3A_dir">dir</code>, <code id="mvbutils.utils_+3A_name">name</code>, <code id="mvbutils.utils_+3A_pos">pos</code>, <code id="mvbutils.utils_+3A_frame">frame</code>, <code id="mvbutils.utils_+3A_mode">mode</code>, <code id="mvbutils.utils_+3A_dirlist">dirlist</code>, <code id="mvbutils.utils_+3A_lvec">lvec</code>, <code id="mvbutils.utils_+3A_opt.name">opt.name</code>, <code id="mvbutils.utils_+3A_default">default</code>, <code id="mvbutils.utils_+3A_substrs">substrs</code>, <code id="mvbutils.utils_+3A_mainstrs">mainstrs</code>, <code id="mvbutils.utils_+3A_any.case">any.case</code>, <code id="mvbutils.utils_+3A_names.for.output">names.for.output</code>, <code id="mvbutils.utils_+3A_df1">df1</code>, <code id="mvbutils.utils_+3A_df2">df2</code>, <code id="mvbutils.utils_+3A_prompt">prompt</code>, <code id="mvbutils.utils_+3A_obj">obj</code>, <code id="mvbutils.utils_+3A_delve">delve</code>, <code id="mvbutils.utils_+3A_trace">trace</code>, <code id="mvbutils.utils_+3A_fmt">fmt</code>, <code id="mvbutils.utils_+3A_sep">sep</code>, <code id="mvbutils.utils_+3A_file">file</code>, <code id="mvbutils.utils_+3A_expr">expr</code>, <code id="mvbutils.utils_+3A_lo">lo</code>, <code id="mvbutils.utils_+3A_hi">hi</code>, <code id="mvbutils.utils_+3A_what">what</code>, <code id="mvbutils.utils_+3A_args.to.integrate">args.to.integrate</code></td>
<td>
<p>see &quot;Arguments by function&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.cat</code> makes a character vector print as if it was <code>cat</code>ted rather than <code><a href="#topic+print">print</a></code>ed (one element per line, no extra quotes or backslashes, no [1] etc prefixes).
</p>
<p><code>clip</code> removes the last <code>n</code> elements of <code>x</code>.
</p>
<p><code>cq</code> is handy for typing <code>cq( alpha, beta, gamma)</code> instead of <code>cq( "alpha", "beta", "gamma")</code>. Certain strings DO still require quotes around them, e.g. <code>cq( "NULL", "1-2")</code>).
</p>
<p><code>deparse.names.parsably</code> is like <code>deparse</code> except that <code>name</code> objects get wrapped in a call to <code>as.name</code>, so that they won't be evaluated accidentally.
</p>
<p><code>empty.data.frame</code> creates a template data frame with 0 rows but with all columns of the appropriate type. Useful for <code><a href="#topic+rbind">rbind</a></code>ing to later.
</p>
<p><code>env.name.string</code> returns a string naming an environment; its <code>name</code> attribute if there is one, or the name of its <code>path</code> attribute if applicable, concatenated with the first line of what would be shown if you <code><a href="#topic+print">print</a></code>ed the argument. Unlike <code>environmentName</code>, this will always return a non-empty string.
</p>
<p><code>expanded.call</code> returns the full argument list available to its caller, including defaults where arguments were not set explicitly. The arguments may not be those originally passed, if they were modified before the invocation of <code>expanded.call</code>. Default arguments which depend on calculations after the invocation of <code>expanded.call</code> will lead to an error.
</p>
<p><code>everyth</code> extracts every <code>by</code>-th element of <code>x</code>, starting at position <code>from</code>.
</p>
<p><code>find.funs</code> finds &quot;function&quot; objects (or objects of other modes, via the &quot;mode&quot; arg) in one or more environments, optionally matching a pattern.
</p>
<p><code>find.lurking.envs( myobj)</code> will search through <code>myobj</code> and all its attributes, returning the size of each sub-object. The size of environments is returned as Inf. The search is completely recursive, except for environments and by default the inner workings of functions; attributes of the entire function are always recursed. Changing the <code>delve</code> parameter to TRUE ensures full recursion of function arguments and function bodies, which will show e.g. the <code>srcref</code> structure; try it to see why the default is FALSE. <code>find.lurking.envs</code> can be very useful for working out e.g. why the result of a model-fitting function is taking up 1000000MB of disk space; sometimes this is due to unnecessary environments in well-concealed places.
</p>
<p><code>index</code> returns the position(s) of TRUE elements. Unlike <code>which</code>: attributes are lost; NA elements map to NAs; <code>index(&lt;&lt;length 0 object&gt;&gt;)</code> is <code>numeric(0)</code>; <code>index( &lt;&lt;non-logical&gt;&gt;)</code> is NA.
</p>
<p><code>integ</code> is a handy wrapper for <code>integrate</code>, that takes an expression rather than a function&mdash; so <code>integ( sin(x), 0, 1)</code> &quot;just works&quot;.
</p>
<p><code>is.dir</code> tests for directoriness.
</p>
<p><code>isF</code> and <code>isT</code> test a logical <em>scalar</em> in the obvious way, with NA (and non-logicals) failing the test, to avoid teeeedious repetition of <code>is( !is.na( my.complicated.expression) &amp; my.complicated.expression) ...</code>. They are deliberately not vectorized (contrary to some versions of <code>mvbutils</code> documentation); arguments with non-1 length trigger a warning.
</p>
<p><code>legal.filename</code> coerces its character argument into a similar-looking string that is a legal filename on any (?) system.
</p>
<p><code>lsall</code> is like <code>ls</code> but coerces <code>all.names=TRUE</code>.
</p>
<p><code>masked</code> checks which objects in <code>search()[pos]</code> are masked by identically-named objects higher in the search path. <code>masking</code> checks for objects mask identically-named objects lower in the search path. Namespaces may make the results irrelevant.
</p>
<p><code>mkdir</code> makes directories; unlike <code>dir.create</code>, it can do several levels at once.
</p>
<p><code>most.recent</code> returns the highest-so-far position of TRUE within a logical vector, or 0 if TRUE has not occurred yet; <code>most.recent( c(F,T,F,T))</code> returns c(0,2,2,4).
</p>
<p><code>my.all.equal</code> is like <code>all.equal</code>, except that it returns FALSE in cases where <code>all.equal</code> returns a non-logical-mode result.
</p>
<p><code>named(x)</code> is just <code>names(x) &lt;- as.character( x); x</code>; useful for <code>lapply</code> etc.
</p>
<p><code>nscat</code>, <code>nscatn</code>: see <code><a href="#topic+scatn">scatn</a></code>
</p>
<p><code>option.or.default</code> obsolete&mdash; use equivalent <code>getOption()</code> instead.
</p>
<p><code>pos</code> is probably to be eschewed in new code, in favour of <code>gregexpr</code> with <code>fixed=TRUE</code>, which is likely faster. (And I should rewrite it to use <code>gregexpr</code>.) It's one of a few legacy functions in <code>mvbutils</code> that pre-date improvements in base R. <code>pos</code> will either search for several literal patterns in a single target, or vice versa&ndash; but not both. It returns a matrix showing the positions of the matching substrings, with as many columns as the maximum number of matches. 0 signifies &quot;no match&quot;; there is always at least one column even if there are no matches at all.
</p>
<p><code>returnList</code> returns a list corresponding to old-style (pre-R 1.8) <code>return</code> syntax. Briefly: a single argument is returned as itself. Multiple arguments are returned in a list. The names of that list are the argument names if provided; or, for any unnamed argument that is just a symbolic name, that symbolic name; or no name at all, for other unnamed arguments. You can duplicate pre-1.8 behaviour of <code>return(...)</code> via <code>return(returnList(...))</code>.
</p>
<p><code>safe.rbind</code> ( <em>Deprecated in 2013</em> ) mimics <code><a href="#topic+rbind">rbind</a></code>, but works round an R bug (I reckon) where a column appears to be a numeric in one <code>data.frame</code> but a factor in the other. But I now think you should just sort your column classes/types properly in advance, rather than mixing types and relying on somewhat arbitrary conversion rules.
</p>
<p><code>scatn</code> is just <code>cat( sprintf( fmt, ...), "", file=file, sep=sep)</code>. <code>scatn</code> prints a newline afterwards, but not before; <code>nscat</code> does the opposite; <code>nscatn</code> does both. If you're just displaying a &quot;title&quot; before calling <code><a href="#topic+print">print</a></code>, use <code>nscat</code>.
</p>
<p><code>to.regexpr</code> converts literal strings to their equivalent regexps, e.g. by doubling backslashes. Useful if you want &quot;fixed=TRUE&quot; to apply only to a portion of your regexp.
</p>
<p><code>yes.no</code> <code>cat</code>s its &quot;prompt&quot; argument and waits for user input. if the user input <code>pmatch</code>es &quot;yes&quot; or &quot;YES&quot;, then <code>yes.no</code> returns <code>TRUE</code>; if the input <code>pmatch</code>es <code>no</code> or <code>NO</code> then <code>yes.no</code> returns <code>FALSE</code>; if the input is &rdquo; and <code>default</code> is set, then <code>yes.no</code> returns <code>default</code>; otherwise it repeats the question. You probably want to put a space at the end of <code>prompt</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>as.cat</code></td>
<td>
<p>character vector of class <code>cat</code></p>
</td></tr>
<tr><td><code>clip</code></td>
<td>
<p>vector of the same mode as <code>x</code></p>
</td></tr>
<tr><td><code>cq</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code>empty.data.frame</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code>env.name.string</code></td>
<td>
<p>a string</p>
</td></tr>
<tr><td><code>expanded.call</code></td>
<td>
<p>a <code>call</code> object</p>
</td></tr>
<tr><td><code>everyth</code></td>
<td>
<p>same type as <code>x</code></p>
</td></tr>
<tr><td><code>find.funs</code></td>
<td>
<p>a character vector of function names</p>
</td></tr>
<tr><td><code>find.lurking.envs</code></td>
<td>
<p>a <code>data.frame</code> with columns &quot;what&quot; and &quot;size&quot;</p>
</td></tr>
<tr><td><code>integ</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code>is.dir</code></td>
<td>
<p>logical vector</p>
</td></tr>
<tr><td><code>is.nonzero</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code>isF</code>, <code>isT</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code>legal.filename</code></td>
<td>
<p>character( 1)</p>
</td></tr>
<tr><td><code>masked</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code>masking</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code>mkdir</code></td>
<td>
<p>logical vector of success/failure</p>
</td></tr>
<tr><td><code>nscat</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>nscatn</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>most.recent</code></td>
<td>
<p>integer vector the same length as <code>lvec</code>, with values in the range (0,length(lvec)).</p>
</td></tr>
<tr><td><code>named</code></td>
<td>
<p>vector of the same mode as <code>x</code></p>
</td></tr>
<tr><td><code>option.or.default</code></td>
<td>
<p>option's value</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>
<p>numeric matrix, one column per match found plus one; at least one column guaranteed</p>
</td></tr>
<tr><td><code>returnList</code></td>
<td>
<p>list or single object</p>
</td></tr>
<tr><td><code>safe.rbind</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code>scatn</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>to.regexpr</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code>yes.no</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
</table>


<h3>Arguments by function</h3>


<dl>
<dt>as.cat</dt><dd><p>x: character vector that you want to be displayed via <code>cat( x, sep="\n")</code></p>
</dd>
<dt>clip</dt><dd><p>x: a vector or list</p>
</dd>
<dt>clip</dt><dd><p>n: integer saying how many elements to clip from the end of <code>x</code></p>
</dd>
<dt>cq</dt><dd><p>...: quoted or unquoted character strings, to be <code>substitute</code>d and then concatenated</p>
</dd>
<dt>deparse.names.parsably</dt><dd><p>x: any object for <code>deparse</code>- <code>name</code> objects treated specially</p>
</dd>
<dt>empty.data.frame</dt><dd><p>...: named length-1 vectors of appropriate mode, e.g. &quot;first.col=&rdquo;&quot;</p>
</dd>
<dt>env.name.string</dt><dd><p>env: environment</p>
</dd>
<dt>expanded.call</dt><dd><p>nlocal: frame to retrieve arguments from. Normally, use the default; see <code><a href="#topic+mlocal">mlocal</a></code>.</p>
</dd>
<dt>everyth</dt><dd><p>x: subsettable thing. by: step between values to extract. from: first position.</p>
</dd>
<dt>find.funs</dt><dd><p>...: extra arguments for <code>objects</code>. Usually just &quot;pattern&quot; for regexp searches.</p>
</dd>
<dt>find.funs</dt><dd><p>exclude.mcache: if TRUE (default), don't look at <code><a href="#topic+mlazy">mlazy</a></code> objects</p>
</dd>
<dt>find.funs</dt><dd><p>mode: &quot;function&quot; to look for functions, &quot;environment&quot; to look for environments, etc</p>
</dd>
<dt>find.lurking.envs</dt><dd><p>delve: whether to recurse into function arguments and function bodies</p>
</dd>
<dt>find.lurking.envs</dt><dd><p>trace: just a debugging aid&ndash; leave as FALSE</p>
</dd>
<dt>index</dt><dd><p>lvector: vector of TRUE/FALSE/NA</p>
</dd>
<dt>integ</dt><dd><p>expr: an expression; what: a string, the argument of <code>expr</code> to be integrated over; lo, hi: limits; ...: other variables to be set in the expression; args.to.integrate: a list of other things to pass to <code>integrate</code></p>
</dd>
<dt>is.dir</dt><dd><p>dir: character vector of files to check existence and directoriness of.</p>
</dd>
<dt>isF, isT</dt><dd><p>x: anything, but meant to be a logical scalar</p>
</dd>
<dt>legal.filename</dt><dd><p>name: character string to be modified</p>
</dd>
<dt>find.funs</dt><dd><p>pos: list of environments, or vector of char or numeric positions in search path.</p>
</dd>
<dt>lsall</dt><dd><p>...: as for <code>ls</code>, except that <code>all.names</code> will be coerced to TRUE</p>
</dd>
<dt>masking, masked</dt><dd><p>pos: position in search path</p>
</dd>
<dt>mkdir</dt><dd><p>dirlist: character vector of directories to create</p>
</dd>
<dt>most.recent</dt><dd><p>logical vector</p>
</dd>
<dt>my.all.equal</dt><dd><p>x, y: anything; ...: passed to <code>all.equal</code></p>
</dd>
<dt>named</dt><dd><p>x: character vector which will become its own <code>names</code> attribute</p>
</dd>
<dt>nscat, nscatn</dt><dd><p>see <code><a href="#topic+scatn">scatn</a></code></p>
</dd>
<dt>option.or.default</dt><dd><p>opt.name: character(1)</p>
</dd>
<dt>option.or.default</dt><dd><p>default: value to be returned if there is no <code>option</code> called <code>"opt.name"</code></p>
</dd>
<dt>pos</dt><dd><p>substrs: character vector of patterns (literal not regexpr)</p>
</dd>
<dt>pos</dt><dd><p>mainstrs: character vector to search for <code>substrs</code> in.</p>
</dd>
<dt>pos</dt><dd><p>any.case: logical- ignore case?</p>
</dd>
<dt>pos</dt><dd><p>names.for.output: character vector to label rows of output matrix; optional</p>
</dd>
<dt>put.in.session</dt><dd><p>...: a named set of objects, to be <code>assign</code>ed into the <code>mvb.session.info</code> search environment</p>
</dd>
<dt>returnList</dt><dd><p>...: named or un-named arguments, just as for <code>return</code> before R 1.8.</p>
</dd>
<dt>safe.rbind</dt><dd><p>df1, df2: <code>data.frame</code> or <code>list</code></p>
</dd>
<dt>scatn, nscat</dt><dd><p>fmt, ...: as per <code>sprintf</code>; file, sep: as per <code>cat</code></p>
</dd>
<dt>to.regexpr</dt><dd><p>x: character vector</p>
</dd>
<dt>yes.no</dt><dd><p>prompt: string to put before asking for input</p>
</dd>
<dt>yes.no</dt><dd><p>default: value to return if user just presses &lt;ENTER&gt;</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>Examples</h3>

<pre><code class='language-R'># as.cat
ugly.bugly &lt;- c( 'A rose by any other name', 'would annoy taxonomists')
ugly.bugly
#[1] "A rose by any other name"                 "would annoy taxonomists"
as.cat( ugly.bugly) # calls print.cat--- no clutter
#A rose by any other name
#would annoy taxonomists
clip( 1:5, 2) # 1:3
cq( alpha, beta) # c( "alpha", "beta")
empty.data.frame( a=1, b="yes")
# data.frame with 0 rows of columns "a" (numeric) and "b" (character)
empty.data.frame( a=1, b=factor( c( "yes", "no")))$b
# factor with levels c( "no", "yes")
everyth( 1:10, 3, 5) # c( 5, 8)
f &lt;- function( a=9, b) expanded.call(); f( 3, 4) # list( a=3, b=4)
find.funs( "package:base", patt="an") # "transform" etc.
find.lurking.envs( cd)
#                                     what  size
#1                     attr(obj, "source")  5368
#2                                     obj 49556
#3 environment(obj) &lt;: namespace:mvbutils&gt;   Inf
## Not run: 
eapply( .GlobalEnv, find.lurking.envs)

## End(Not run)
integ( sin(x), 0, 1) # [1] 0.4597
integ( sin(x+a), a=5, 0, 1) # [1] -0.6765; 'a' is "passed" to 'expr'
integ( sin(y+a), what='y', 0, 1, a=0) # [1] 0.4597; arg is 'y' not 'x'
is.dir( getwd()) # TRUE
isF( FALSE) # TRUE
isF( NA) # FALSE
isF( c( FALSE, FALSE)) # FALSE, with a warning
sapply( c( FALSE, NA, TRUE), isF)
# [1]  TRUE FALSE FALSE
sapply( c( FALSE, NA, TRUE), isT)
# [1] FALSE FALSE  TRUE
legal.filename( "a:b\\c/d&amp;f") # "a.b.c.d&amp;f"
most.recent( c( FALSE,TRUE,FALSE,TRUE)) # c( 0, 2, 2, 4)
sapply( named( cq( alpha, beta)), nchar)  # c( alpha=5, beta=4)
pos( cq( quick, lazy), "the quick brown fox jumped over the lazy dog")
# matrix( c( 5, 37), nrow=2)
pos( "quick", c( "first quick", "second quick quick", "third"))
# matrix( c( 7,8,0, 0,14,0), nrow=3)
pos( "quick", "slow") # matrix( 0)
f &lt;- function() { a &lt;- 9; return( returnList( a, a*a, a2=a+a)) }
f() # list( a=9, 81, a2=18)
scatn( 'Things %i', 1:3)
nscat( 'Things %i', 1:3)
nscatn( 'Things %i', 1:3)
to.regexpr( "a{{") # "a\\{\\{"
## Not run: 
mkdir( "subdirectory.of.getwd")
yes.no( "OK (Y/N)? ")
masking( 1)
masked( 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='my.index'>Arbitrary-level retrieval from and modification of recursive objects</h2><span id='topic+my.index'></span><span id='topic+my.index.assign'></span><span id='topic+my.index.exists'></span>

<h3>Description</h3>

<p>As of R 2.12, you probably don't need these at all. But, in case you do: <code>my.index</code> and <code>my.index.assign</code> are designed to replace <code>[[</code> and <code>[[&lt;-</code> <em>within</em> a function, to allow arbitrary-depth access into any recursive object. In order to avoid conflicts with system usage and/or slowdowns, it is wise to do this only inside a function definition where they are needed. A zero-length index returns the entire object, which I think is more sensible than the default behaviour (chuck a tanty). <code>my.index.exists</code> tests whether the indexed element actually exists. Note that these functions were written in 2001; since then, base-R has extended the default behaviour of <code>[[</code> etc for recursive objects, so that <code>my.index( thing, 1, 3, 5)</code> can sometimes be achieved just by to <code>thing[[c(1,3,5)]]</code> with the system version of <code>[[</code>. However, at least as of R 2.10.1, the system versions still have limited &quot;recursability&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Use them like this, inside a function definition:
# assign( "[[", my.index); var[[i]]
# assign( "[[&lt;-", my.index.assign); var[[i]] &lt;- value
my.index( var, ...) # not normally called by name
my.index.assign( var, ..., value) # not normally called by name
my.index.exists( i, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.index_+3A_var">var</code></td>
<td>
<p>a recursive object of any mode (not just <code>list</code>, but e.g. <code>call</code> too)</p>
</td></tr>
<tr><td><code id="my.index_+3A_value">value</code></td>
<td>
<p>anything</p>
</td></tr>
<tr><td><code id="my.index_+3A_...">...</code></td>
<td>
<p>one or more numeric index vectors, to be concatenated</p>
</td></tr>
<tr><td><code id="my.index_+3A_i">i</code></td>
<td>
<p>numeric index vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although R allows arbitrary-level access to lists, this does not (yet) extend to <code>call</code> objects or certain other language objects&ndash; hence these functions. They are written entirely in R, and are probably very slow as a result. Notwithstanding EXAMPLES below, it is <b>unwise</b> to replace system <code>[[</code> and <code>[[&lt;-</code> with these replacements at a global level, i.e. outside the body of a function&ndash; these replacements do not dispatch based on object class, for example.
</p>
<p>Note that <code>my.index</code> and <code>my.index.assign</code> distort strict R syntax, by concatenating their <code>...</code> arguments before lookup. Strictly speaking, R says that <code>x[[2,1]]</code> should extract one element from a matrix list; however, this doesn't really seem useful because the same result can always be achieved by <code>x[2,1][[1]]</code>. With <code>my.index</code>, <code>x[[2,1]]</code> is the same as <code>x[[c(2,1)]]</code>. The convenience of automatic concatentation seemed slightly preferable (at least when I wrote these, in 2001).
</p>
<p><code>my.index.exists</code> checks whether <code>var</code> is &quot;deep enough&quot; for <code>var[[i]]</code> to work. Unlike the others, it does not automatically concatenate indices.
</p>
<p>At present, there is no facility to use a mixture of character and numeric indexes, which you can in S+ via &quot;list subscripting of lists&quot;.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>Examples</h3>

<pre><code class='language-R'>local({
  assign( "[[", my.index)
  assign( "[[&lt;-", my.index.assign)
  ff &lt;- function() { a &lt;- b + c }
  body( ff)[[2,3,2]] # as.name( "b")
  my.index.exists( c(2,3,2), body( ff)) # TRUE
  my.index.exists( c(2,3,2,1), body( ff)) # FALSE
  body( ff)[[2,3,2]] &lt;- quote( ifelse( a&gt;1,2,3))
  ff # function () { a &lt;- ifelse(a &gt; 1, 2, 3) + c }
  my.index.exists( c(2,3,2,1), body( ff)) # now TRUE
})
</code></pre>

<hr>
<h2 id='NEG'>Generate a negated version of your function. Useful for 'nlminb' etc.</h2><span id='topic+NEG'></span>

<h3>Description</h3>

<p>You pass it a function <code>f(.)</code>; it returns a function whose result will be <code>-f(.)</code>. The arguments, return attributes, and environment are identical to those of <code>f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NEG(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NEG_+3A_f">f</code></td>
<td>
<p>Normally, a function that returns a scalar; rarely, a NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns <code>-f</code>. However, if <code>is.null(f)</code>, the result is also NULL; this is useful e.g. for gradient arg to <code>nlminb</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NEG( sqrt)( 4) # -2
# should put in more complex one here...
e &lt;- new.env()
e$const &lt;- 3
funco &lt;- function( x) -sum( ( x-const)^2L)
environment( funco) &lt;- e
nlminb( c( 0, 0), NEG( funco)) # c( 3, 3)
dfunco &lt;- NULL
nlminb( c( 0, 0), NEG( funco), gradient=NEG( dfunco)) # c( 3, 3)
</code></pre>

<hr>
<h2 id='noice'>Prints a call object nicely</h2><span id='topic+noice'></span>

<h3>Description</h3>

<p>Prints a <code>call</code>-mode object nicely, with one argument per line. This is useful, for example, in displaying readably the outcomes of <code>sys.call()</code>, which is often used to create a <code>call</code> attribute for the results of complicated functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noice( cc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noice_+3A_cc">cc</code></td>
<td>
<p>a <code>call</code> object, eg something appended to a fitting result via <code>sys.call</code>.</p>
</td></tr>
<tr><td><code id="noice_+3A_...">...</code></td>
<td>
<p>any other arguments for <code>deparse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with one argument per line, of class <code><a href="#topic+as.cat">as.cat</a></code> so that it prints cleanly. Long arguments are truncated, so the result is not guaranteed to re-parse cleanly (a general issue with R which seems unavoidable in any powerful language).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a bona fide function call from my own work
# normally it would be evaluated directly, and sys.call()
# would be used inside it to assign a 'call' attrib to the result
# but the call attrib then looks like a mess-o-rama
# The quote() wrapper is just used here to make the point
# It would be interesting if 'call' could cope with a 'source' or
# 'srcref' argument, and would "know" how to print itself, but that
# is a big ask
# BTW, the 72-char limit in Rd EXAMPLES and USAGE is a PITBA
monster &lt;- quote( est_N(
    popcompo = fp1a_17,
    df_rs_as_at_l = NULL,
    df_rs_ls = NULL, # NB comments are allowed, but get chucked
    newstyle_data = data17b,
    use_alpha_hsp = TRUE,
    AMIN = 8, AMAX = 30,
    YMIN = 2002, YMAX = 2014,
    prior_mean_z_plusgroup = 0.386,
    prior_sd_z_plusgroup = 0.0268,
    LMIN = 150, LMAX = 200,
    logit_surv_form = ~ I( pmax( age, 19)- AMAX) - 1,
    log_nsa_y1_form = ~factor(sex),
    log_nys_a1_reqm_form = ~0,
    logit_tresid_form = ~sex * I(len - 170),
    log_selbase_form = ~ 0,
    log_daily_reprodm_form = ~ 0,
    vb_form = ~sex,
    log_vb_cv_Linf_form = ~1,
    log_rct_re_var_start = log( sqr( 0.41)),
    fix_CV_R = TRUE,
    RE_rct = TRUE,
    sel_is_by_sex = TRUE,
    ssreduce_l = 1,
    fec_bout_start_fit = start_of_bout,
    fec_rest_start_fit = start_of_rest,
    fec_ovwt_fit = bfec,
    lf_sel_model=lv10kk5fix,
    nu_lata = 12))
monster # yuk
noice( monster) # yum
</code></pre>

<hr>
<h2 id='pre.install'>Update a source and/or installed package from a task package</h2><span id='topic+pre.install'></span><span id='topic+patch.installed'></span><span id='topic+patch.install'></span><span id='topic+pre.install.hook...'></span><span id='topic+spkg'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code> before reading or experimenting!
</p>
<p><code>pre.install</code> creates a &quot;source package&quot; from a &quot;task package&quot;, ready for first-time installation using <code><a href="#topic+install.pkg">install.pkg</a></code>. You must have called <code>maintain.packages( mypack)</code> at some point in your R session before <code>pre.install( mypack)</code> etc.
</p>
<p><code>patch.install</code> is normally sufficient for subsequent maintenance of an already-installed package (ie you rarely need call <code><a href="#topic+install.pkg">install.pkg</a></code> again). Again, <code><a href="#topic+maintain.packages">maintain.packages</a></code> must have been called earlier. It's also expected that the package has been loaded via <code>library()</code> before <code>patch.install</code> is called, but this may not be required. <code>patch.install</code> first calls <code>pre.install</code> and then modifies the installed package accordingly on-the-fly, so there is no need to re-load or re-build or re-install. <code>patch.install</code> also updates the help system with immediate effect, i.e. during the current R session. You don't need to call <code>patch.install</code> after every little maintenance change to your package during an R session; it's usually only necessary when (i) you want updated help, or (ii) you want to make the changes &quot;permanent&quot;. However, it's not a problem to call <code>patch.install</code> quite often. <code>patch.installed</code> is a synonym for <code>patch.install</code>.
</p>
<p>It's possible to tweak the source-package-creation process, and this is what 'pre.install.hook...&quot; is for; see <b>Details</b> and section on <b>Overriding defaults</b> below.
</p>
<p><code>spkg</code> is a rarely-needed utility that returns the folder of source package created by <code>pre.install</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> # 95% of the time you just need:
 # pre.install( pkg)
 # patch.install( pkg)
 # Your own hook: pre.install.hook.&lt;&lt;mypack&gt;&gt;( default.list, &lt;&lt;myspecialargs&gt;&gt;, ...)
 pre.install( pkg, character.only=FALSE, force.all.docs=FALSE,
     dir.above.source="+", autoversion=getOption("mvb.autoversion", TRUE),
     R.target.version=getRversion(), ...)
 patch.installed( pkg, character.only=FALSE, force.all.docs=FALSE,
     help.patch=TRUE, DLLs.only=FALSE,
     update.installed.cache=getOption("mvb.update.installed.cache", TRUE),
     pre.inst=!DLLs.only, dir.above.source="+", R.target.version=getRversion(),
     autoversion=getOption("mvb.autoversion", TRUE))
 patch.install(...) # actually, args are exactly as for 'patch.installed'
 spkg( pkg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pre.install_+3A_pkg">pkg</code></td>
<td>
<p>package name. Either quoted or unquoted is OK; unquoted will be treated as quoted unless <code>character.only=TRUE</code>. Here and in most other places in <code>mvbutils</code>, you can also specify an actual in-memory-task-package object such as <code>..mypack</code>.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_character.only">character.only</code></td>
<td>
<p>Default FALSE, which allows unquoted package names. You can set it to TRUE, or just set e.g. <code>char="my@funny@name"</code>, which will trump any use of <code>pkg</code>.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_force.all.docs">force.all.docs</code></td>
<td>
<p>normally just create help files for objects whose documentation has changed (which will always be generated, regardless of <code>force.all.docs</code>). If TRUE, then recreate help for all documented objects. Can also be a character vector of specific docfile names (usually function names, but can be the names of the Rd file, without path or the Rd extension), in which case those Rd files will be regenerated.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_help.patch">help.patch</code></td>
<td>
<p>if TRUE, patch the help of the installed package</p>
</td></tr>
<tr><td><code id="pre.install_+3A_dlls.only">DLLs.only</code></td>
<td>
<p>just synchronize the DLLs and don't bother with other steps (see <b>Compiled code</b>)</p>
</td></tr>
<tr><td><code id="pre.install_+3A_default.list">default.list</code></td>
<td>
<p>list of various things&ndash; see under &quot;Overriding...&quot; below</p>
</td></tr>
<tr><td><code id="pre.install_+3A_...">...</code></td>
<td>
<p>arguments to pass to your <code>pre.install.hook.XXX</code> function, usually if you want to be able to build different &quot;flavours&quot; of a package (e.g. a trial version vs. a production version, or versions with and without enormous datasets included). In <code>patch.install</code>, <code>...</code> is just shorthand for the arg list of <code>patch.installed</code>.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_update.installed.cache">update.installed.cache</code></td>
<td>
<p>If TRUE, then clear the installed-package cache, so that things like <code>installed.packages</code> work OK. The only reason to set to FALSE could be speed, if you have lots of packages; feedback appreciated. Default is TRUE unless you have set <code>options( mvb.update.installed.cache=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_pre.inst">pre.inst</code></td>
<td>
<p>?run <code>pre.install</code> first? Default is TRUE unless <code>DLLs.only=TRUE</code>; leave it unless you know better.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_autoversion">autoversion</code></td>
<td>
<p>if TRUE, try to automatically increment the version number in the source (and installed, if <code>patch.install</code>) packages; this means you don't have to change the DESCRIPTION object or file. However, if you have changed the DESCRIPTION object or file's version to something beyond the source/installed version, the larger number will take precedence; hence, you can force a &quot;major&quot; revision by manually increasing the 1st or 2nd component of the version in <b>Description</b>. Only versions with at least 3 levels will be updated:so 1.0.0 will go to 1.0.1, 1.0.0.0 will go to 1.0.0.1, but 1.0 will stay the same. Default is TRUE unless you have set <code>options( mvb.autoversion=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="pre.install_+3A_dir.above.source">dir.above.source</code></td>
<td>
<p>folder within which the source package will go, with a <code>+</code> at the start being shorthand for the task package folder (the default). Hence <code>pre.install( pkg=mypack, dir="+/holder")</code> will lead to creation of &quot;holder/mypack&quot; below the task folder of <code>mypack</code>. Set this manually if you have to maintain different versions of the package for different R versions, or different flavours of the package for other reasons, or if your source package must live in a &quot;subversion tree&quot; (whatever that is).</p>
</td></tr>
<tr><td><code id="pre.install_+3A_r.target.version">R.target.version</code></td>
<td>
<p>Not needed 99% of the time; use only if you want to create source package for a different version of R. Supercedes the <code>Rd.version</code> argument of <code>pre.install</code> pre-'mvbutils' 2.5.57, used to control the documentation format. Set <code>R.target.version</code> to something less than &quot;2.10&quot; for ye olde &quot;Rd version 1&quot; format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As per the Glossary section of <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>: the &quot;task package&quot; is the directory containing the &quot;.RData&quot; file with the guts of your package, which should be linked into the <code><a href="#topic+cd">cd</a></code> task hierarchy. The &quot;source package&quot; is usually the directory &quot;&lt;&lt;pkg&gt;&gt;&quot; below the task package, which will be created if needs be.
</p>
<p>The default behaviour of <code>pre.install</code> is as follows&ndash; to change it, see <b>Overriding defaults</b>. A basic source package is created in a sourcedirectory &quot;&lt;&lt;pkg&gt;&gt;&quot; of the current task. The package will have at least a DESCRIPTION file, a NAMESPACE file, a single R source file with name &quot;&lt;&lt;pkg&gt;&gt;.R&quot; in the &quot;R&quot; sourcedirectory, possibly a &quot;sysdata.rda&quot; file in the same place to contain non-functions, and a set of Rd files in the &quot;man&quot; sourcedirectory. Rd files will be auto-created from <code><a href="#topic+flatdoc">flatdoc</a></code> style documentation, although precedence will be given to any pre-existing Rd files found in an &quot;Rd&quot; sourcedirectory of your task, which get copied directly into the package. Any &quot;inst&quot;, &quot;demo&quot;, &quot;vignettes&quot;, &quot;tests&quot;, &quot;src&quot;, &quot;exec&quot;, and &quot;data&quot; sourcedirectories will be copied to the source package, recursively (i.e. including any of <em>their</em> sourcedirectories). There is no compilation of source code, since only a source package is being created; see also <b>Compiled code</b> below.
</p>
<p>Most objects in the task package will go into the source package, but there are usually a few you wouldn't want there: objects that are concerned only with how to create the package in the first place, and ephemeral system clutter such as <code>.Random.seed</code>. The default exceptions are: functions <code>pre.install.hook.&lt;&lt;pkg&gt;&gt;</code>, <code>.First.task</code>, and <code>.Last.task</code>; data <code>&lt;&lt;pkg&gt;&gt;.file.exclude.regexes</code>, <code>&lt;&lt;pkg&gt;&gt;.DESCRIPTION</code>, <code>&lt;&lt;pkg&gt;&gt;.VERSION</code>, <code>&lt;&lt;pkg&gt;&gt;.UNSTABLE</code>, <code>forced!exports</code>, <code>.required</code>, <code>.Depends</code>, <code>tasks</code>, <code>.Traceback</code>, <code>.packageName</code>, <code>last.warning</code>, <code>.Last.value</code>, <code>.Random.seed</code>, <code>.SavedPlots</code>; and any character vector whose name ends with &quot;.doc&quot;.
</p>
<p>All pre-existing files in the &quot;man&quot;, &quot;src&quot;, &quot;tests&quot;, &quot;exec&quot;, &quot;demo&quot;, &quot;inst&quot;, and &quot;R&quot; sourcedirectories of the source-package directory will be removed (unless you have some <code><a href="#topic+mlazy">mlazy</a></code> objects; see below). If a file &quot;.Rbuildignore&quot; file is present in the task package, it's copied to the package directory, but I've never gotten this feature to work (NB I should include a facility in the pre-install hook for this). To exclude files that would otherwise be copied, i.e. those in &quot;inst/demo/src/data&quot; folders, create a character vector of regexes called <code>&lt;&lt;pkg&gt;&gt;.file.exclude.regexes</code>; any file matching any of these won't be copied. If there is a &quot;changes.txt&quot; file in the task package, it will be copied to the &quot;inst&quot; sourcedirectory of the package, as will any files in the task's own &quot;inst&quot; sourcedirectory. A DESCRIPTION file will be created, preferably from a <code>&lt;&lt;pkg&gt;&gt;.DESCRIPTION</code> <em>object</em> in the task package; see <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code> for more. Any &quot;Makefile.*&quot; in the task package will be copied, as will any in the &quot;src&quot; sourcedirectory (not sure why both places are allowed). No other files or sourcedirectories in the package directory will be created or removed, but some essential files will be modified.
</p>
<p>If a NAMESPACE file is present in the task (usually no need), then it is copied directly to the package. If not, then <code>pre.install</code> will generate a NAMESPACE file by calling <code><a href="#topic+make.NAMESPACE">make.NAMESPACE</a></code>, which makes reasonable guesses about what to import, export, and S3methodize. What is &amp; isn't an S3 method is generally deduced OK (see <code><a href="#topic+make.NAMESPACE">make.NAMESPACE</a></code> for gruesome details), but you can override the defaults via the pre-install hook. FWIW, since adding the package-creation features to <code>mvbutils</code>, I have never bothered explicitly writing a NAMESPACE file for any of my packages. By default, only <em>documented</em> functions are exported (i.e. visible to the user or other packages); the rest are only available to other functions in your package.
</p>
<p>The R source file will contain functions only. Any <code>doc</code> and <code>export.me</code> attributes are dropped, but other attributes are kept; in particular, source code is kept in the <code>source</code> attribute.
</p>
<p>If any of the Rd files starts with a period, e.g. &quot;.dotty.name&quot;, it will be renamed to e.g. &quot;01.dotty.name.Rd&quot; to avoid some problems with RCMD. This should never matter, but just so you know...
</p>
<p>To speed up conversion of documentation, a list of raw &amp; converted documentation is stored in the file &quot;doc2Rd.info.rda&quot; in the task package, and conversion is only done for objects whose raw documentation has changed, unless <code>force.all.docs</code> is TRUE.
</p>
<p><code>pre.install</code> creates a file &quot;funs.rda&quot; in the package's &quot;R&quot; sourcedirectory, which is subsequently used by <code>patch.installed</code>. The function <code><a href="#topic+build.pkg">build.pkg</a></code> (or R CMD BUILD) and friends will omit this file (currently with a complaint, which I intend to fix eventually, but which does not cause trouble).
</p>


<h4>Compiled code</h4>

<p><code>patch.install</code> does not compile source code; currently, you need to do that yourself, though I might add support for that if I can work a sufficiently general mechanism. If you use R to do your compilation, then <code><a href="#topic+install.pkg">install.pkg</a></code> should work after <code>pre.install</code>, though you may need <code>detach("package:mypack", unload=T)</code> first and that will disrupt your R session. Alternatively, you may be able to use R CMD SHLIB to create the DLL directly, which you can then copy into the &quot;libs&quot; sourcedirectory of the installed package, without needing to re-install. I haven't tried this, but colleagues have reported success.
</p>
<p>If, like me, you pre-compile your own DLLs manually (not allowed on CRAN, but fine for distribution to other users on the same OS), then you can put the DLLs into a folder &quot;inst/libs&quot; of the task (see next for Windows); they will end up as usual in the &quot;libs&quot; folder of the installed package, even though R itself hasn't compiled them. On Windows, put the DLLs one level deeper in &quot;inst/libs/&lt;&lt;arch&gt;&gt;&quot; instead, where &quot;&lt;&lt;arch&gt;&gt;&quot; is found from <code>.Platform$r_arch</code>; for 32-bit Windows, it's currently &quot;i386&quot;. All references in this section to &quot;libs&quot;, whether in the task or source or installed package, should be taken as meaning &quot;libs/&lt;&lt;arch&gt;&gt;&quot;.
</p>
<p>To load your package's DLLs, call <code>library.dynam</code> in the <code>.onLoad</code> function, for example like this:
</p>
<pre>
  .onLoad &lt;- function( libname, pkgname){
    library.dynam( 'my_first_dll', package=pkgname)
    library.dynam( 'my_other_dll', package=pkgname)  # fine to have several DLLs
  }
</pre>
<p>To automatically load all DLLs, you can copy the body of <code>mvbutils:::generic.dll.loader</code> into your own <code>.onLoad</code>, or just include a call to <code>generic.dll.loader(libname,pkgname)</code> if you don't mind having dependence on <code>mvbutils</code>.
</p>
<p>After the package has been installed for the first time, I change my compiler settings so that the DLL is created directly in the installed package's &quot;libs&quot; folder; this means I can use the compiler's debugger while R is running. To accommodate this, <code>patch.install</code> behaves as follows:
</p>

<ul>
<li><p> any new DLLs in the task package are copied to the installed package;
</p>
</li>
<li><p> any DLLs in the installed package but not in the task package are deleted;
</p>
</li>
<li><p> for any DLLs in both task &amp; installed, both copies are synchronized to the <em>newer</em> version;
</p>
</li>
<li><p> the source package always matches the task package
</p>
</li></ul>

<p>You can call <code>patch.install( mypack, DLLs.only=TRUE)</code> if you only want the DLL-synching step.
</p>
<p>(Before version 2.5.57, <code>mvbutils</code> allowed more latitude in where you could put your home-brewed DLLs, but it just made life more confusing. The only place that now works is as above.)
</p>



<h4>Data objects</h4>

<p>Data objects are handled a bit differently to the recommendations in &quot;R extensions&quot; and elsewhere&ndash; but the end result for the package user is the same, or better. The changes have been made to speed up package maintenance, and to improve useability. Specifically:
</p>

<ul>
<li><p> Undocumented data objects live only in the package's namespace, i.e. visible only to your functions.
</p>
</li>
<li><p> Documented data objects appear both in the visible part of the package (i.e. in the search path), and in the namespace. [The R standard is that these should not be visible in the namespace, but this doesn't seem sensible to me.]
</p>
</li>
<li><p> The easiest way to export a data object, is to &quot;document&quot; it by putting its name into an alias line of the doc attribute of an existing function. (Alias lines are single-word lines directly after the first line of the doc attr.)
</p>
</li>
<li><p> To document a data object <code>xxx</code> in its own right, include a flat-format text object <code>xxx.doc</code> in your task package; see <code><a href="#topic+doc2Rd">doc2Rd</a></code>. <code>xxx.doc</code> itself won't appear in the packaged object, but will result in documentation for <code>xxx</code> <em>and</em> any other data objects that are given as alias lines.
</p>
</li>
<li><p> Big data objects can be set up for transparent individual lazy-loading (see below) to save time &amp; memory, but lazy-loading is otherwise off by default for individual data objects.
</p>
</li>
<li><p> There is no need for the user ever to call <code><a href="utils.html#topic+data">data</a></code> to access a dataset in the package, and in fact it won't work.
</p>
</li></ul>

<p>Note that the <code>data(...)</code> function has been pretty much obsolete since the advent of lazy-loading in R 2.0; see R-news #4/2.
</p>
<p>In terms of package structure, as opposed to operation, there is no &quot;data&quot; sourcedirectory. Data lives either in the &quot;sysdata.rdb/rdx&quot; files in the &quot;R&quot; sourcedirectory (but can still be user-visible, which is not normally the case for objects in those files), or in the &quot;mlazy&quot; sourcedirectory for those objects with individual lazy-loading.
</p>


<h5>Big data objects</h5>

<p>Lazy-loading objects cached with <code><a href="#topic+mlazy">mlazy</a></code> are handled specially, to speed up <code>pre.install</code>. Such objects get their cache-files copied to &quot;inst/mlazy&quot;, and the <code>.onLoad</code> is prepended with code that will load them on demand. By default, they are exported if and only if documented, and are not locked. The following objects are not packaged by default, even if <code><a href="#topic+mlazy">mlazy</a></code>ed: <code>.Random.seed</code>, <code>.Traceback</code>, <code>last.warning</code>, and <code>.Saved.plots</code>. These are <code><a href="#topic+mlazy">mlazy</a></code>ed automatically if <code>options( mvb.quick.cd)</code> is <code>TRUE</code>&ndash; see <code><a href="#topic+cd">cd</a></code>.
</p>




<h4>Documentation and exporting</h4>



<h5>Package documentation</h5>

<p>Just because you have a package <span class="pkg">Splendid</span>, it doesn't follow that a user will be able to figure out how to use it from the alphabetical list of functions in <code>library( help=Splendid)</code>; even if you've written vignettes, it may not be obvious which to use. The recommended way to provide a package overview is via &quot;package documentation&quot;, which the user accesses via <code>package?Splendid</code>. You can write this in a text object called e.g. &quot;Splendid.package.doc&quot;, which will be passed through <code><a href="#topic+doc2Rd">doc2Rd</a></code> with an extra &quot;docType{package}&quot; field added. The first line should start e.g. &quot;Splendid-package&quot; and the corresponding &quot;.Rd&quot; file will be put first into the index. Speaking as a frequently bewildered would-be user of others' packages&ndash; and one who readily gives up if the &quot;help&quot; is impenetrable&ndash; I urge you to make use of this feature!
</p>



<h5>Vignettes</h5>

<p>See <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>.
</p>



<h5>Bare minimum for export</h5>

<p>Only documented functions and data are exported from your package (unless you resort to the subterfuge described in the subsection after this). Documented things are those found by <code>find.documented( doc="any")</code>. The simplest way to document something is just to add its name as an &quot;alias line&quot; to the existing documentation of another function, before the first empty line. For example, if you're already using <code><a href="#topic+flatdoc">flatdoc</a></code> to document <code>my.beautiful.function</code>, you can technically &quot;document&quot; and thus export other functions like so:
</p>
<pre>
  structure( function( blahblahblah)...
  ,doc=flatdoc())
  my.beautiful.function    package:splendid
  other.exported.function.1
  other.exported.function.2
</pre>
<p>The package will build &amp; install OK even if you don't provide USAGE and ARGUMENTS sections for the other functions. Of course, R CMD CHECK wouldn't like it (and may have a point on this occasion). If you just are after &quot;legal&quot; (for R CMD CHECK) albeit unhelpful documentation for some of your functions that you can't face writing proper doco for yet, see <code><a href="#topic+make.usage.section">make.usage.section</a></code> and <code>make.argument.section</code>.
</p>



<h5>Exporting undocumented things and vice versa</h5>

<p>A bit naughty (RCMD CHECK complains), but quite doable. Note that &quot;things&quot; can be data objects, not just functions. Simply write a pre-install hook (see <b>Overriding defaults</b>) that includes something like this:
</p>
<pre>
  pre.install.hook.mypack &lt;- function( hooklist) {
    hooklist$nsinfo$exports &lt;- c( hooklist$nsinfo$exports, "my.undocumented.thing")
  return( hooklist)
  }
</pre>
<p>You can follow a similar approach if you want to document something but <em>not</em> to export it (so that it can only be accessed by <code>Splendid:::unexported.thing</code>. This probably isn't naughty.
</p>




<h4>Overriding defaults</h4>

<p>Source package folder can be controlled via <code>options("mvbutils.sourcepkgdir.postfix")</code>, as per &quot;Folders and different R versions&quot; in <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>. You'd only need to do this if you have multiple R versions installed that require different source-package formats (something that does not often change).
</p>
<p>If a function <code>pre.install.hook.&lt;&lt;pkgname&gt;&gt;</code> exists in the task &quot;&lt;&lt;pkgname&gt;&gt;&quot;, it will be called during <code>pre.install</code>. It will be passed one list-mode argument, containing default values for various installation things that can be adjusted; and it should return a list with the same names. It will also be passed any <code>...</code> arguments to <code>pre.install</code>, which can be used e.g. to set &quot;production mode&quot; vs &quot;informal mode&quot; of the end product. For example, you might call <code>preinstall(mypack,modo="production")</code> and then write a function <code>pre.install.hook.mypack( hooklist, modo)</code> that includes or excludes certain files depending on the value of <code>modo</code>. The hook can do two things: sort out any file issues not adequately handled by <code>pre.install</code>, and/or change the following elements in the list that is passed in. The return value should be the possibly-modified list. Hook list elements are:
</p>

<dl>
<dt>copies</dt><dd><p>files to copy directly</p>
</dd>
<dt>dll.paths</dt><dd><p>DLLs to copy directly</p>
</dd>
<dt>extra.filecontents</dt><dd><p>named list; each element is the contents of a text file, the corresponding name being the path of the file to create eg <code>"inst/src/utils.pas"</code>&mdash; a nonstandard name</p>
</dd>
<dt>extra.docs</dt><dd><p>names of character-mode objects that constitute flat-format documentation</p>
</dd>
<dt>description</dt><dd><p>named elements of DESCRIPTION file</p>
</dd>
<dt>task.path</dt><dd><p>path of task (ready-to-install package will be created as a sourcedirectory in this)</p>
</dd>
<dt>has.namespace</dt><dd><p>should a namespace be used?</p>
</dd>
<dt>use.existing.NAMESPACE</dt><dd><p>ignore default and just copy the existing NAMESPACE file?</p>
</dd>
<dt>nsinfo</dt><dd><p>default namespace information, to be written iff <code>has.namespace==TRUE</code> and <code>use.existing.NAMESPACE==FALSE</code></p>
</dd>
<dt>exclude.funs</dt><dd><p>any functions <b>not</b> to include</p>
</dd>
<dt>exclude.data</dt><dd><p>non-functions to exclude from <code>system.rda</code></p>
</dd>
<dt>dont.check.visibility</dt><dd><p>either TRUE (default default), FALSE, or a specified character vector, to say which objects are <em>not</em> to be checked for &quot;globality&quot; by RCMD CHECK (using the <code>globalVariables</code> mechanism). Leave alone if you don't understand this. You can change the &quot;default default&quot; via <code>options( mvb_dont_check_visibility=FALSE)</code>.</p>
</dd>
</dl>

<p>There are two reasons for using a hook rather than directly setting parameters in <code>pre.install</code>. The first is that <code>pre.install</code> will calculate sensible but non-obvious default values for most things, and it is easier to change the defaults than to set them up from scratch in the call. The second is that once you have written a hook, you can forget about it&ndash; you don't have to remember special argument values each time you call <code>pre.install</code> for that task.
</p>


<h5>Debugging a pre install hook</h5>

<p>To understand what's in the list and how to write a pre-install hook, the easiest way is probably to write a dummy one and then <code>mtrace</code> it before calling <code>pre.install(mypack)</code>. However, it's all a bit clunky at present (July 2011). Because the hook only exists in the &quot;..mypack&quot; shadow environment, <code>mtrace</code> won't find it automatically, so you'll need <code>mtrace( pre.install.hook.mypack, from=..mypack)</code>. That's fine, but if you then modify the source of your hook function, you'll get an error following the &quot;Reapplying trace...&quot; message. So you need to do <code>mtrace.off</code> <em>before</em> saving your edited hook-function source, and then <code>mtrace</code> the hook again before calling <code>pre.install(mypack)</code>. To be fixed, if I can work out how...
</p>




<h4>Different versions of r</h4>

<p>R seems to be rather fond of changing the structural requirements of source &amp; installed packages. <code>mvbutils</code> tries to shield you from those arcane and ephemeral details&ndash; usually, your task package will not need changing, and <code>pre.install</code> will automatically generate source &amp; installed packages in whatever format R currently requires. However, sometimes you do at least need to be able to build different &quot;instances&quot; of your package for different versions of R. The <code>sourcedir</code> and maybe the <code>R.target.version</code> arguments of <code>pre.install</code> may help with this.
</p>
<p>But if you need to build instances of your package for a different version of R, then you may need this argument (and <code>dir.above.source</code>). I try to keep <code>mvbutils</code> up-to-date with R's fairly frequent revisions to package structure rules, with the aim that you (or I) can easily produce a source/binary-source package for a version of R later than the one you're using right now, merely by setting <code>R.target.version</code>. However, be warned that this may not always be enough; there might at some point be changes in R that will require you to be running the appropriate R version (and an appropriate version of <code>mvbutils</code>) just to recreate/rebuild your package in an appropriate form.
</p>
<p>The nuances of <code>R.target.version</code> change with the changing tides of R versions, but the whole point of <code>pre.install</code> etc is that you shouldn't really need to know about those details; <code>mvbutils</code> tries to look after them for you. For example, though: as of 10/2011, the &quot;detailed behaviour&quot; is to enforce namespaces if <code>R.target.version</code> &gt;= 2.14, regardless of whether your package has a <code>.onLoad</code> or not.
</p>


<h5>Packages without namespaces pre r2 14</h5>

<p>You used to be allowed to build packages without namespaces&ndash; not to be encouraged for general distribution IMO, but occasionally a useful shortcut for your own stuff nevertheless (mainly because everything is &quot;exported&quot;, documented or not). For R &lt;= 2.14, <code>mvbutils</code> will decide for itself whether your package is meant to be namespaced, based on whether any of the following apply: there is a NAMESPACE file in the task package; there is a <code>.onLoad</code> function in the task; there is an &quot;Imports&quot; directive in the DESCRIPTION file.
</p>




<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>, <code><a href="#topic+cd">cd</a></code>, <code><a href="#topic+doc2Rd">doc2Rd</a></code>, <code><a href="#topic+maintain.packages">maintain.packages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Workflow for simple case:
cd( task.above.mypack)
maintain.packages( mypack)
# First-time setup, or after major R version changes:
pre.install( mypack)
install.pkg( mypack)
library( mypack)
# ... do stuff
# Subsequent maintenance:
maintain.packages( mypack) # only once per session, usually at the start
library( mypack) # maybe optional
# ...do various things involving changes to mypack, then...
patch.install( mypack) # keep disk image up-to-date
# Prepare copies for distribution
build.pkg( mypack) # for Linux or CRAN
build.pkg.binary( mypack) # for Windows or Macs
check.pkg( mypack) # if you like that sort of thing

## End(Not run)
</code></pre>

<hr>
<h2 id='print'>Print values</h2><span id='topic+print'></span><span id='topic+print.cat'></span><span id='topic+print.specialprint'></span><span id='topic+print.pagertemp'></span><span id='topic+print.function'></span><span id='topic+print.call'></span><span id='topic+print.name'></span><span id='topic+print.+3C-'></span><span id='topic+print.+28'></span><span id='topic+print.+7B'></span><span id='topic+print.if'></span><span id='topic+print.for'></span><span id='topic+print.while'></span><span id='topic+print.default'></span>

<h3>Description</h3>

<p>See base-R documentation of <code>print</code> and <code>print.default</code>. Users should see no difference with the <code>mvbutils</code> versions; they need to be documented and exported in <code>mvbutils</code> for purely technical reasons. There are also three useful special-purpose print methods in <code>mvbutils</code>; see <b>Value</b>.Some of the base-R documentation is reproduced below.
</p>
<p>The motive for redeclaration is to have a seamless transition within the <code><a href="#topic+fixr">fixr</a></code> editing system, from the nice simple &quot;source&quot;-attribute system used to store function source-code before R2.14, to the quite extraordinarily complicated &quot;srcref&quot; system used thereafter. <code>mvbutils</code> does so via an augmented version of base-R's print method for functions, without which your careful formatting and commenting would be lost. If a function has a &quot;source&quot; attribute but no &quot;srcref&quot; attribute (as would be the case for many functions created prior to R2.14), then the augmented <code>print.function</code> will use the &quot;source&quot; attribute. There is no difference from base-R in normal use.
</p>
<p>See <b>How to override an s3 method</b> if you really want to understand the technicalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...) # generic
## Default S3 method:
print(x, ...) # S3 method for default
## S3 method for class 'function'
print(x, useSource=TRUE, ...) # S3 method for function
## S3 method for class 'cat'
print(x, ...) # S3 method for cat
## S3 method for class 'specialprint'
print(x, ...) # S3 method for specialprint
## S3 method for class 'pagertemp'
print(x, ...) # S3 method for pagertemp
## S3 method for class 'call'
print(x, ...) # S3 method for call
## S3 replacement method for class ''&lt;-''
print(x, ...) # S3 method for "&lt;-" (a special sort of call)
## S3 method for class ''(''
print(x, ...) # S3 method for "(" (a special sort of call)
#print(x, ...) # S3 method for "{" (a special sort of call)
## S3 method for class ''if''
print(x, ...) # S3 method for "if" (a special sort of call)
## S3 method for class ''for''
print(x, ...) # S3 method for "for" (a special sort of call)
## S3 method for class ''while''
print(x, ...) # S3 method for "while" (a special sort of call)
## S3 method for class 'name'
print(x, ...) # S3 method for name (symbol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>thing to print.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>NextMethod</code> and/or ignored. There are many special arguments to base-R <code>print.default</code>, as described in its documentation. They are not named individually in the <code>mvbutils</code> version for technical reasons, but you can still use them.</p>
</td></tr>
<tr><td><code id="print_+3A_usesource">useSource</code></td>
<td>
<p>[print.function] logical, indicating whether to use source references or copies rather than deparsing language objects. The default is to use the original source if it is available. The <code>mvbutils</code> override will print a &quot;source&quot; attribute if one exists but no &quot;srcref&quot; attribute does, whereas base-R post-2.14 would just print a deparsed version of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Technically, an <code>invisible</code> version of the object is returned. But the point of <code>print</code> is to display the object. <code>print.function</code> displays source code, as per <b>Description</b>. <code>print.default</code> and <code>print.call</code> need to exist in <code>mvbutils</code> only for technical reasons. The other two special methods are:
<code>print.cat</code> applies to character vectors of S3 class <code>cat</code>, which are printed each on a new line, without the [1] prefix or double-quotes or backslashes. It's ideal for displaying &quot;plain text&quot;. Use <code><a href="#topic+as.cat">as.cat</a></code> to coerce a character vector so that it prints this way.
<code>print.specialprint</code> can be used to ensure an object (of class <code>specialprint</code>) displays in any particular way you want, without bothering to define a new S3 class and write a print method. Just give the object an attribute &quot;print&quot; of mode <code>expression</code>, which can refer to the main argument <code>x</code> and any other arguments. That expression will be run by <code>print.specialprint</code>&ndash; see <b>Examples</b>.
<code>print.pagertemp</code> is meant only for internal use by the informal-help viewer.
</p>


<h3>How to override an s3 method</h3>

<p>Suppose you maintain a package <span class="pkg">mypack</span> in which you want to mildly redefine an existing S3 method, like <code>mvbutils</code> does with <code>print.function</code>. (Drastic redefinitions are likely to be a bad idea, but adding or tweaking functionality can occasionally make sense.) The aim is that other packages which import <code>mypack</code> should end up using your redefined method, and so should the user if they have explicitly called <code>library( mypack)</code>. But your redefined method should <em>not</em> be visible to packages that don't import <code>mypack</code>, nor to the user if <code>mypack</code> has only been loaded implicitly (i.e. if <code>mypack</code> is imported by another package, so that <code>asNamespace(mypack)</code> is loaded but <code>package:mypack</code> doesn't appear on the search path). It's hard to find out how to do this. Here's what I have discovered:
</p>

<ul>
<li><p> For a <em>new</em> S3 method (i.e. for a class that doesn't already have one), then you just need to mark it as an <code>S3method</code> in the <code>mypack</code> NAMESPACE file (which <code>mvbutils</code> packaging tools do for you automatically). You don't need to document the new method explicitly, and consequently there's no need to export it. The new method will still be found when the generic runs on an object of the appropriate class.
</p>
</li>
<li><p> If you're modifying an existing method, you can't just declare it as <code>S3method</code> in the NAMESPACE file of <code>mypack</code>. If that's all you did, R would complain that it already has a registered method for that class&mdash; fair enough. Therefore, you also have to redeclare and export the <em>generic</em>, so that there's a &quot;clean slate&quot; for registering the method (specifically, in the S3 methods table for <code>mypack</code>, where the new generic lives). The new generic will probably be identical to the existing generic, very likely just a call to <code>UseMethod</code>. Because it's exported, it needs to be documented; you can either just refer to base-R documentation (but you still need all the formal stuff for Arguments etc, otherwise RCMD CHECK complains), or you can duplicate the base-R doco with a note. <code><a href="#topic+help2flatdoc">help2flatdoc</a></code> is useful here, assuming you're wisely using <code>mvbutils</code> to build &amp; maintain your package.
</p>
</li>
<li><p> If you redeclare the generic, you also need to make sure that your <em>method</em> is <em>exported</em> as well as S3-registered in the NAMESPACE file of <code>mypack</code>. This is somehow connected with the obscure scoping behaviour of <code>UseMethod</code> and I don't really understand it, but the result is: if you don't export your method, then it's not found by the new generic (even though it exists in <code>asNamespace(mypack)</code>, which is the environment of the new generic, and even though your method is also S3-registered in that same environment). Because you export the method, you also need to document it.
</p>
</li>
<li><p> Unfortunately, the new generic won't know about the methods already registered for the old generic. So, for most generics (exceptions listed later), you will also have to define a <code>generic.default</code> method in <code>mypack</code>&mdash; and you need to export and therefore document it too, as per the previous point. This <code>generic.default</code> just needs to invoke the original generic, so that the already-registered S3 methods are searched. However, this can lead to infinite loops if you're not careful. See <code>mvbutils:::print.default</code> for how to do it. If you were redefining a generic that was originally (or most recently) defined somewhere other than <code>baseenv()</code>, then you'd need to replace the latter with <code>asNamespace(&lt;&lt;original.defining.package&gt;&gt;)</code>.
</p>
</li>
<li><p> Because your new <code>generic.default</code> might invoke any of the pre-existing (or subsequently-registered) methods of the <em>original</em> generic, you should just make its argument list <code>x,...</code>. In other words, don't name individual arguments even if they are named in the original <code>generic.default</code> (eg for <code>print.default</code>).
</p>
</li>
<li><p> Objects of mode <code>name</code>, <code>call</code>, and <code>"("</code> or <code>"{"</code> or <code>"&lt;-"</code> (special types of <code>call</code>) cause trouble in <code>generic.default</code> (at least using the approach in the previous point, as in <code>mvbutils:::print.default</code>). Unless they have a specific method, the object will be automatically evaluated. So if your generic is ever likely to be invoked on a <code>call</code> object, you'll need a special <code>generic.call</code> method, as in <code>mvbutils:::print.call</code>; the same goes for those other objects.
</p>
</li>
<li><p> A few generics&mdash; <code><a href="#topic+rbind">rbind</a></code> and <code>cbind</code>, for example&mdash; use their own internal dispatch mechanism and don't have e.g. an <code>rbind.default</code>. Of course, there is a default behaviour, but it's not defined by an R-level function; see <code>?InternalGenerics</code>. For these generics, the previous point wouldn't work as a way of looking for existing methods. Fortunately, at least for <code><a href="#topic+rbind">rbind</a></code>, things seem to &quot;just work&quot; if your redefined generic simply runs the code of the base generic (but don't call the latter directly, or you risk infinite loops&mdash; just run its body code). Then, if <em>your</em> generic is run, the search order is (1) methods registered for <em>your</em> generic in <code>asNamespace("mypack")</code>, whether defined in <code>mypack</code> itself or subsequently registered by another package that uses <code>mypack</code>, (2) methods defined/registered for the base generic (ie in the original generic's namespace), (3) the original &quot;implicit default method&quot;. But if the <em>original</em> generic is run (e.g. from another package that doesn't import <code>mypack</code>), then step (1) is skipped. This is good; if another package <span class="pkg">pack2</span> imports <code>mypack</code> and registers an S3 method, the S3 registration will go into the <code>mypack</code> S3 lookup table, but if <code>pack2</code> <em>doesn't</em> import <code>mypack</code> then the S3 registration will go into the base S3 lookup table (or the lookup table for whichever package the generic was originally defined in, eg package <span class="pkg">stats</span>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Special methods shown below; basic behaviour of 'print', 'print.default',
# and 'print.function' is as for base-R
#cat
ugly.bugly &lt;- c( 'A rose by any other name', 'would annoy taxonomists')
ugly.bugly
#[1] "A rose by any other name"                 "would annoy taxonomists"
as.cat( ugly.bugly) # calls print.cat--- no clutter
#A rose by any other name
#would annoy taxonomists
# nullprint:
biggo &lt;- 1:1000
biggo
# [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
# [2] 19  20  21  22  23  24  25  26  27  28 etc...
oldClass( biggo) &lt;- 'nullprint'
biggo # calls print.nullprint
# nuthin'
# specialprint:
x &lt;- matrix( exp( seq( -20, 19, by=2)), 4, 5)
attr( x, 'print') &lt;- expression( {
    x[] &lt;- sprintf( '%12.2f', x);
    class( x) &lt;- 'noquote';
    attr( x, 'print') &lt;- NULL;
    print( x)
  })
class( x) &lt;- 'specialprint'
x # calls print.specialprint; consistently formatted for once
#     [,1]         [,2]         [,3]         [,4]         [,5]
#[1,]         0.00         0.00         0.02        54.60    162754.79
#[2,]         0.00         0.00         0.14       403.43   1202604.28
#[3,]         0.00         0.00         1.00      2980.96   8886110.52
#[4,]         0.00         0.00         7.39     22026.47  65659969.14

## End(Not run)
</code></pre>

<hr>
<h2 id='rbdf'>Data frames: better behaviour with zero-length cases</h2><span id='topic+rbdf'></span><span id='topic+rbind'></span><span id='topic+rbind.data.frame'></span>

<h3>Description</h3>

<p><code>rbind</code> concatenates its arguments by row; see <code><a href="base.html#topic+cbind">cbind</a></code> for basic documentation. There is an <code>rbind</code> method for data frames which <code>mvbutils</code> overrides, and <code>rbdf</code> calls the override directly. The <code>mvbutils</code> version should behave exactly as the base-R version, with two exceptions:
</p>

<ul>
<li><p> zero-row arguments are <b>not</b> ignored, e.g. so that factor levels which never appear are not dropped.
</p>
</li>
<li><p> dimensioned (array or matrix) elements do not lose any extra attributes (such as <code>class</code>).
</p>
</li></ul>

<p>I find the zero-row behaviour more logical, and useful because e.g. it lets me create an <code><a href="#topic+empty.data.frame">empty.data.frame</a></code> with the correct type/class/levels for all columns, then subsequently add rows to it. The behaviour for matrix (array) elements allows e.g. the <code>rbind</code>ing of data frames that contain matrices of <code>POSIXct</code> elements without losing the <code>POSIXct</code> class (as in my package <span class="pkg">nicetime</span>).
</p>
<p>When <code>rbind</code>ing data frames, best practice is to make sure all the arguments really are data frames. Lists and matrices also work OK (they are first coerced to data frames), but scalars are dangerous (even though base-R will process them without complaint). <code>rbind</code> is quirky around data frames; unless <em>all</em> the arguments are data frames, sometimes <code>rbind.data.frame</code> will not be called even when you'd expect it to be, and the coercion of scalars is frankly potty; see <b>Details</b> and EXAMPLES. <code>mvbutils:::rbind.data.frame</code> tries to mimic the base-R scalar coercion, but I'm not sure it's 100% compatible. Again, the safest way to ensure a predictable outcome, is to make sure all arguments really are data frames, and/or to call <code>rbdf</code> directly.
</p>
<p>Note that (&quot;thanks&quot; to <code>stringsAsFactors</code>) the order in which data frames are rbound can affect the result&mdash; see <b>Examples</b>.
</p>


<h4>Obsolete</h4>

<p>Versions of <code>mvbutils</code> prior to 2.8.207 installed replacements for <code>$&lt;-.data.frame</code> and <code>[[&lt;-.data.frame</code> that circumvented weird behaviour with the base-R versions when the <code>data.frame</code> had zero rows. That weird behaviour seems to be fixed in base-R as of version 3.4.4 (perhaps earlier). I've therefore removed those replacements (after warnings from newer versions RCMD CHECK). Hopefully, everything works... but just for the record, here's the old text, which I <em>think</em> no longer applies.
</p>
<p>[I <em>think</em> this paragraph is obsolete.] Normally, you can replace elements in, or add a column to, data frames via e.g. <code>x$y &lt;- z</code> or <code>x[["y"]] &lt;- z</code>. However, in base-R this fails for no good reason if <code>x</code> is a zero-row data frame; the sensible behaviour when <code>y</code> doesn't exist yet, would be to create a zero-length column of the appropriate class. <code>mvbutils</code> overrides the base (mis)behaviour so it works sensibly. Should work for matrix/array &quot;replacements&quot; too.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rbind(..., deparse.level = 1) # generic
## S3 method for class 'data.frame'
rbind(..., deparse.level = 1) # S3 method for data.frame
rbdf(..., deparse.level = 1) # explicitly call S3 method...
# ... for data frames (circumvent rbind dispatch)
## OBSOLETE x[[i,j]] &lt;- value # S3 method for data.frame; only ...
## OBS ... the version x[[i]] &lt;- value is relevant here, tho' arguably j==0 might be
## OBS x$name &lt;- value # S3 method for data.frame
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbdf_+3A_...">...</code></td>
<td>
<p>Data frames, or things that will coerced to data frames. NULLs are ignored.</p>
</td></tr>
<tr><td><code id="rbdf_+3A_deparse.level">deparse.level</code></td>
<td>
<p>not used by <code>rbind.data.frame</code>, it's for the default and generic only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>old arguments
</p>

<dl>
<dt>i,j</dt><dd><p>column and row subscripts</p>
</dd>
<dt>name</dt><dd><p>column name</p>
</dd>
<dt>x, value</dt><dd><p>that's up to you; I just have to include them here to stop RCMD CHECK from moaning... :/</p>
</dd>
</dl>

<p>See <code><a href="base.html#topic+cbind">cbind</a></code> documentation in base-R.
</p>
<p>R's dispatch mechanism for <code>rbind</code> is as follows [my paraphrasing of base-R documentation]. Mostly, if any argument is a data frame then <code>rbind.data.frame</code> will be used. However, if one argument is a data frame but another argument is a scalar/matrix of a class that has an <code>rbind</code> method, then &quot;default rbind&quot; will be called instead. Although the latter still returns a data frame, it stuffs up e.g. class attributes, so that <code>POSIXct</code> objects will be turned into huge numbers. Again, if you really want a data frame result, make sure all the arguments are data frames.
</p>
<p>In <code>mvbutils:::rbind.data.frame</code> (and AFAIK in the base-R version), arguments that are not data frames are coerced to data frames, by calling <code>data.frame()</code> on them. AFAICS this works predictably for list and matrix arguments; note that lists need names, and matrices need column names, that match the names of the real data frame arguments, because column alignment is done by name not position. Behaviour for scalars is IMO weird; see <b>Examples</b>. The idea seems to be to turn each scalar into a single-row data frame, coercing its names and truncating/replicating it to match the columns of the first real data frame argument; any <code>names</code> of the scalar itself are disregarded, and alignment is by position not name. Although <code>mvbutils:::rbind.data.frame</code> tries to mimic this coercion, it seems to me unnecessary (the user should just turn the scalar into something less ambiguous), confusing, and dangerous, so <code>mvbutils</code> issues a warning. Whether I have duplicated every quirk, I'm not sure.
</p>
<p>Note also that R's accursed <code>drop=TRUE</code> default means that things you might reasonably think <em>should</em> be data frames, might not be. Under some circumstances, this might result in <code>rbind.data.frame</code> being bypassed. See <b>Examples</b>.
</p>
<p>Short of rewriting <code>data.frame</code> and <code>rbind</code>, there's nothing <code>mvbutils</code> can do to fix these quirks. Whether base-R should consider any changes is another story, but back-compatibility probably suggests not.
</p>


<h3>Value</h3>

<p>[Taken from the base-R documentation, modified to fit the <code>mvbutils</code> version]
The <code>rbind</code> data frame method first drops any NULL arguments, then coerces all others to data frames (see <b>Details</b> for how it does this with scalars). Then it drops all zero-column arguments. (If that leaves none, it returns a zero-column zero-row data frame.) It then takes the classes of the columns from the first argument, and matches columns by name (rather than by position). Factors have their levels expanded as necessary (in the order of the levels of the levelsets of the factors encountered) and the result is an ordered factor if and only if all the components were ordered factors. (The last point differs from S-PLUS.) Old-style categories (integer vectors with levels) are promoted to factors. Zero-row arguments are kept, so that in particular their column classes and factor levels are taken account of.
Because the class of each column is set by the <em>first</em> data frame, rather than &quot;by consensus&quot;, numeric/character/factor conversions can be a bit surprising especially where NAs are involved. See the final bit of EXAMPLES.
</p>


<h3>See Also</h3>

<p><code>cbind</code> and <code>data.frame</code> in base-R; <code><a href="#topic+empty.data.frame">empty.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mvbutils versions are used, unless base:: or baseenv() gets mentioned
# Why base-R dropping of zero rows is odd
rbind( data.frame( x='yes', y=1)[-1,], data.frame( x='no', y=0))$x # mvbutils
#[1] no
#Levels: yes no # two levels
base::rbind( data.frame( x='yes', y=1)[-1,], data.frame( x='no', y=0))$x # base-R
#[1] no
#Levels: no # lost level
rbind( data.frame( x='yes', y=1)[-1,], data.frame( x='no', y=0, stringsAsFactors=FALSE))$x
#[1] no
#Levels: yes no
base::rbind( data.frame( x='yes', y=1)[-1,], data.frame( x='no', y=0, stringsAsFactors=FALSE))$x
#[1] "no" # x has turned into a character
# Quirks of scalar coercion
evalq( rbind( data.frame( x=1), x=2, x=3), baseenv()) # OK I guess
#   x
#1  1
#x  2
#x1 3
evalq( rbind( data.frame( x=1), x=2:3), baseenv()) # NB lost element
#  x
#1 1
#x 2
evalq( rbind( data.frame( x=1, y=2, z=3), c( x=4, y=5)), baseenv())
# NB gained element! Try predicting z[2]...
#  x y z
#1 1 2 3
#2 4 5 4
evalq( rbind( data.frame( x='cat', y='dog'), cbind( x='flea', y='goat')), baseenv()) # OK
#     x    y
#1  cat  dog
#2 flea goat
evalq( rbind( data.frame( x='cat', y='dog'), c( x='flea', y='goat')), baseenv()) # Huh?
#Warning in `[&lt;-.factor`(`*tmp*`, ri, value = "flea") :
#  invalid factor level, NAs generated
#Warning in `[&lt;-.factor`(`*tmp*`, ri, value = "goat") :
#  invalid factor level, NAs generated
#     x    y
#1  cat  dog
#2 &lt;NA&gt; &lt;NA&gt;
evalq( rbind( data.frame( x='cat', y='dog'), c( x='flea')), baseenv()) # Hmmm...
#Warning in `[&lt;-.factor`(`*tmp*`, ri, value = "flea") :
#  invalid factor level, NAs generated
#Warning in `[&lt;-.factor`(`*tmp*`, ri, value = "flea") :
#  invalid factor level, NAs generated
#     x    y
#1  cat  dog
#2 &lt;NA&gt; &lt;NA&gt;
try( evalq( rbind( data.frame( x='cat', y='dog'), cbind( x='flea')), baseenv())) # ...mmmm...
#Error in rbind(deparse.level, ...) :
#  numbers of columns of arguments do not match
# Data frames that aren't:
data.frame( x=1,y=2)[-1,] # a zero-row DF-- OK
# [1] x y
# &lt;0 rows&gt; (or 0-length row.names)
data.frame( x=1)[-1,] # not a DF!?
# numeric(0)
data.frame( x=1)[-1,,drop=FALSE] # OK, but exceeeeeedingly cumbersome
# &lt;0 rows&gt; (or 0-length row.names)
# Implications for rbind:
rbind( data.frame( x='yes')[-1,], x='no')
#  [,1]
# x "no" # rbind.data.frame not called!
rbind( data.frame( x='yes')[-1,,drop=FALSE], x='no')
#Warning in rbind(deparse.level, ...) :
#  risky to supply scalar argument(s) to 'rbind.data.frame'
#   x
#x no
# Quirks of ordering and character/factor conversion:
rbind( data.frame( x=NA), data.frame( x='yes'))$x
#[1] NA    "yes" # character
rbind( data.frame( x=NA_character_), data.frame( x='yes'))$x
#[1] &lt;NA&gt; yes
#Levels: yes # factor!
rbind( data.frame( x='yes'), data.frame( x=NA))$x[2:1]
#[1] &lt;NA&gt;  yes
#Levels: yes # factor again
x1 &lt;- data.frame( x='yes', stringsAsFactors=TRUE)
x2 &lt;- data.frame( x='no', stringsAsFactors=FALSE)
rbind( x1, x2)$x
# [1] yes no
# Levels: yes no
rbind( x2, x1)$x
# [1] "no"  "yes"
# sigh...
</code></pre>

<hr>
<h2 id='readLines.mvb'>Read text lines from a connection</h2><span id='topic+readLines.mvb'></span>

<h3>Description</h3>

<p>Reads text lines from a connection (just like <code>readLines</code>), but optionally only until a specfied string is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  readLines.mvb( con=stdin(), n=-1, ok=TRUE, EOF=as.character( NA), line.count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLines.mvb_+3A_con">con</code></td>
<td>
<p>A connection object or a character string.</p>
</td></tr>
<tr><td><code id="readLines.mvb_+3A_n">n</code></td>
<td>
<p>integer. The (maximal) number of lines to read. Negative values indicate that one should read up to the end of the connection.</p>
</td></tr>
<tr><td><code id="readLines.mvb_+3A_ok">ok</code></td>
<td>
<p>logical. Is it OK to reach the end of the connection before &lsquo;n &gt; 0&rsquo; lines are read? If not, an error will be generated.</p>
</td></tr>
<tr><td><code id="readLines.mvb_+3A_eof">EOF</code></td>
<td>
<p>character. If the current line matches the EOF, it's treated as an end-of-file, and the read stops. The connection is left OPEN so that subsequent reads work.</p>
</td></tr>
<tr><td><code id="readLines.mvb_+3A_line.count">line.count</code></td>
<td>
<p>(default FALSE) see <b>Value</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from stopping if the EOF line is encountered, and as noted with <code>line.count==TRUE</code>, behaviour should be as for <code>readLines</code>.
</p>


<h3>Value</h3>

<p>A character vector of length the number of lines read. If <code>line.count==TRUE</code>, it will also have an attribute &quot;line.count&quot; showing the number of lines read.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+source.mvb">source.mvb</a></code>, <code><a href="#topic+current.source">current.source</a></code>, <code><a href="#topic+flatdoc">flatdoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- tempfile()
cat( letters[ 1:6], sep="\n", file=tt)
the.data &lt;- readLines.mvb( tt, EOF="d")
unlink( tt)
the.data # [1] "a" "b" "c"
</code></pre>

<hr>
<h2 id='rm.pkg'>Remove object(s) from maintained package</h2><span id='topic+rm.pkg'></span><span id='topic+remove.from.package'></span>

<h3>Description</h3>

<p>Remove object(s) from maintained package. If the package is loaded, then objects are also removed from the search path version if any, the namespace if any, any importing namespaces, and any S3 method table. <code>remove.from.package</code> is a synonym. You will be prompted about whether to auto-save the maintained package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.pkg( pkg, ..., list = NULL, save.=NA)
# remove.from.package( pkg, ..., list=NULL)
remove.from.package( ...) # really has same args as 'rm.pkg'
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.pkg_+3A_pkg">pkg</code></td>
<td>
<p>(string, or environment) package name or environment, e.g. <code>..mypack</code></p>
</td></tr>
<tr><td><code id="rm.pkg_+3A_...">...</code></td>
<td>
<p>unquoted object names to remove</p>
</td></tr>
<tr><td><code id="rm.pkg_+3A_list">list</code></td>
<td>
<p>character vector alternative to ..., which is ignored if <code>list</code> is set</p>
</td></tr>
<tr><td><code id="rm.pkg_+3A_save.">save.</code></td>
<td>
<p>For internal use&mdash; leave this alone!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For now, methods are only removed from the <b>base</b> S3 methods table; if new S3 generics have been defined in loaded packages, and you are trying to remove a method for such a generic, then it won't be removed. I could implement this feature if anyone really wants it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maintain.packages">maintain.packages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm.pkg( "mypackage", foo, bar)
rm.pkg( "mypackage", list=cq( foo, bar))
rm.pkg( ..mypackage, list=cq( foo, bar))

## End(Not run)
</code></pre>

<hr>
<h2 id='Save'>Save R objects</h2><span id='topic+Save'></span><span id='topic+Save.pos'></span>

<h3>Description</h3>

<p>These function resemble <code>save</code> and <code>save.image</code>, with two main differences. First, any functions which have been <code>mtrace</code>d (see package <span class="pkg">debug</span>) will be temporarily untraced during saving (the <span class="pkg">debug</span> package need not be loaded). Second, <code>Save</code> and <code>Save.pos</code> know how to deal with lazy-loaded objects set up via <code><a href="#topic+mlazy">mlazy</a></code>. <code>Save()</code> is like <code>save.image()</code>, and also tries to call <code>savehistory</code> (see <b>Details</b>). <code>Save.pos(i)</code> saves all objects from the <code>i</code>th position on the search list in the corresponding &quot;.RData&quot; file (or &quot;all.rda&quot; file for image-loading packages, or &quot;*.rdb/*.rdx&quot; for lazyloading packages). There is less flexibility in the arguments than for the system equivalents. If you use the <code><a href="#topic+cd">cd</a></code> system in <code>mvbutils</code>, you will rarely need to call <code>Save.pos</code> directly; <code><a href="#topic+cd">cd</a></code>, <code><a href="#topic+move">move</a></code> and <code><a href="#topic+FF">FF</a></code> will do it for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Save()
Save.pos( pos, path, ascii=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Save_+3A_pos">pos</code></td>
<td>
<p>string or numeric position on search path, or environment (e.g. <code>..mypack</code> if &quot;mypack&quot; is a maintained-package).</p>
</td></tr>
<tr><td><code id="Save_+3A_path">path</code></td>
<td>
<p>directory or file to save into (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="Save_+3A_ascii">ascii</code></td>
<td>
<p>file type, as per <code><a href="base.html#topic+save">save</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a safety provision in <code>Save</code> and <code>Save.pos</code>, which is normally invisible to the user, but can be helpful if there is a failure during the save process (for example, if the system shuts down unexpectedly). The workspace image is first saved under a name such as &quot;n.RData&quot; (the name will be adapted to avoid clashes if necessary). Then, if and only if the new image file has a different checksum to the old &quot;.RData&quot; file, the old file will be deleted and the new one will be renamed &quot;.RData&quot;; otherwise, the new file will be deleted. This also means that the &quot;.RData&quot; file will not be updated at all if there have been no changes, which may save time when synchronizing file systems or backing up.
</p>
<p>Two categories of objects will not be saved by <code>Save</code> or <code>Save.pos</code>. The first category is anything named in <code>options( dont.save)</code>; by default, this is &quot;.packageName&quot;, &quot;.SavedPlots&quot;, &quot;last.warning&quot;, and &quot;.Traceback&quot;, and you might want to add &quot;.Last.value&quot;. The second category is anything which looks like a maintained package, i.e. an environment whose name starts with &quot;..&quot; and which has attributes &quot;name&quot;, &quot;path&quot;, and &quot;task.tree&quot;. A warning will be given if such objects are found. [From bitter experience, this is to prevent accidents on re-loading after careless mistakes such as <code>..mypack$newfun &lt;- something</code>; what you <em>meant</em>, of course, is <code>..mypack$newfun &lt;&lt;- something</code>. Note that the accident will not cause any bad effects during the current R session, because environments are not duplicated; anything you do to the &quot;copy&quot; will also affect the &quot;real&quot; <code>..mypack</code>. However, a mismatch will occur if the environment is accidentally saved and re-loaded; hence the check in <code>Save</code>.]
</p>
<p><code>path</code> is normally inferred from the <code>path</code> attribute of the <code><a href="#topic+pos">pos</a></code> workspace. If no such attribute can be found (e.g. if the attached workspace was a list object), you will be prompted. If <code>path</code> is a directory, the file will be called &quot;.RData&quot; if that file already exists, or &quot;R/all.rda&quot; if that exists, or &quot;R/*.rbd&quot; for lazy loads if that exists; and if none of these exist already, then the file will be called &quot;.RData&quot; after all. If you specify <code>path</code>, it must be a complete directory path or file path (i.e. it will not be interpreted relative to a <code>path</code> attribute).
</p>


<h4>Compression</h4>

<p><code>mvbutils</code> uses the default compression options of <code><a href="base.html#topic+save">save</a></code>, unless you set <code>options()</code> &quot;mvbutils.compress&quot; and/or &quot;mvbutils.compression_level&quot; to appropriate values as per <code>?save</code>. The same applies to <code><a href="#topic+mlazy">mlazy</a></code> objects. Setting <code>options(mvbutils.compression_level=1)</code> can sometimes save quite a bit of time, at the cost of using more disk space. Set these options to NULL to return to the defaults.
</p>



<h4>History files</h4>

<p><code>Save</code> calls <code>savehistory()</code>. With package <span class="pkg">mvbutils</span> from about version 2.5.6 on, <code>savehistory</code> and <code>loadhistory</code> will by default use the same file throughout each and every R session. That means everything works nicely for most users, and you really don't need to read the rest of this section unless you are unhappy with the default behaviour.
</p>
<p>If you are unhappy, there are two things you might be unhappy about. First, <code>savehistory</code> and <code>loadhistory</code> are by default modified to always use the <em>current</em> value of the R_HISTFILE environment variable at the time they are called, whereas default R behaviour is to use the value when the session started, or &quot;.Rhistory&quot; in the current directory if none was set. I can't imagine why the default would be preferable, but if you do want to revert to it, then try to follow the instructions in <code>?mvbutils</code>, and email me if you get stuck. Second, the default for R_HISTFILE itself is set by <code>mvbutils</code> to be the file &quot;.Rhistory&quot; in the <code>.First.top.search</code> directory&ndash; normally the one you start R in. You can change that default by specifying R_HISTFILE yourself before loading <code>mvbutils</code>, in one of the many ways described by the R documentation on <code>?Startup</code> and <code>?Sys.getenv</code>.
</p>



<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>save</code>, <code>save.image</code>, <code> mtrace</code> in package <span class="pkg">debug</span>, <code><a href="#topic+mlazy">mlazy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Save() #
Save.pos( "package:mvbutils") # binary image of exported functions
Save.pos( 3, path="temp.Rdata") # path appended to attr( search()[3], "path")

## End(Not run)
</code></pre>

<hr>
<h2 id='search.for.regexpr'>Find functions/objects/flatdoc-documentation containing a regexp.</h2><span id='topic+search.for.regexpr'></span>

<h3>Description</h3>

<p>Search one or more environments for objects that contain a regexp. Within each environment, check either (i) all functions, or (ii) the &quot;doc&quot; attributes of all functions, plus any character objects whose name ends in &quot;.doc&quot; or matches a specified regexp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.for.regexpr( pattern, where=1, lines=FALSE, doc=FALSE, code.only=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search.for.regexpr_+3A_pattern">pattern</code></td>
<td>
<p>the regexp</p>
</td></tr>
<tr><td><code id="search.for.regexpr_+3A_where">where</code></td>
<td>
<p>an environment, something that can be coerced to an environment (so the default corresponds to <code>.GlobalEnv</code>), or a list of environments or things that can be coerced to environments.</p>
</td></tr>
<tr><td><code id="search.for.regexpr_+3A_lines">lines</code></td>
<td>
<p>if FALSE, return names of objects mentioning the regexp. If TRUE, return the actual lines containing the regexp.</p>
</td></tr>
<tr><td><code id="search.for.regexpr_+3A_doc">doc</code></td>
<td>
<p>if FALSE, search function source code only. Otherwise, search the usual <code><a href="#topic+flatdoc">flatdoc</a></code> places, i.e. &quot;doc&quot; attributes of functions, and certain character objects. If <code>doc==TRUE</code>, the name of those objects must end in &quot;.doc&quot;; otherwise, if <code>doc</code> is a string (length-1 character vector), then the names of the character object must grep that string; hence, <code>doc="[.]doc$"</code> is equivalent to <code>doc=TRUE</code>.</p>
</td></tr>
<tr><td><code id="search.for.regexpr_+3A_code.only">code.only</code></td>
<td>
<p>if FALSE, search only the deparsed version of &quot;raw&quot; code, so ignoring e.g. comments and &quot;flatdoc&quot; documentation</p>
</td></tr>
<tr><td><code id="search.for.regexpr_+3A_...">...</code></td>
<td>
<p>passed to <code>grep</code>&ndash; e.g. &quot;fixed&quot;, &quot;ignore.case&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element per environment searched, containing either a vector of object names that mention the regexp, or a named list of objects &amp; the actual lines mentioning the regexp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flatdoc">flatdoc</a></code>, <code><a href="#topic+find.docholder">find.docholder</a></code>, <code><a href="#topic+find.documented">find.documented</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# On my own system's ROOT task (i.e. workspace--- see ?cd)
search.for.regexpr( 'author', doc=FALSE)
# $.GlobalEnv
# [1] "cleanup.refs"
# the code to function 'cleanup.refs' contains "author"
search.for.regexpr( 'author', doc=TRUE)
# $.GlobalEnv
# [1] "scrunge"
# 'scrunge' is a function with a character attribute that contains "author"
search.for.regexpr( 'author', doc='p')
#$.GlobalEnv
# [1] "scrunge" "p1"      "p2"
## 'scrunge' again, plus two character vectors whose names contain 'p'

## End(Not run)
</code></pre>

<hr>
<h2 id='search.task.trees'>Locate loaded tasks on search path.</h2><span id='topic+search.task.trees'></span>

<h3>Description</h3>

<p>Returns the search positions of loaded tasks, with names showing the attached branch of the tree&ndash; see <b>Examples</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.task.trees()
</code></pre>


<h3>Value</h3>

<p>Increasing numeric vector with names such as &quot;ROOT&quot;, &quot;ROOT/top.task&quot;, &quot;ROOT/top.task/sub.task&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
search.task.trees() # c( ROOT=1) if you haven't used cd yet
cd( mytask)
search.task.trees() # c( "ROOT/mytask"=1, ROOT=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='set.finalizer'>Obsolete but automatic finalization for persistent objects created in C.</h2><span id='topic+set.finalizer'></span>

<h3>Description</h3>

<p>[Almost certainly obsolete; <code>.Call</code> really is the way to go for newer code, complexity notwithstanding.]
</p>
<p>Suppose you want to create persistent objects in C&ndash; i.e. objects that can be accessed from R by subsequent calls to C. The usual advice is that <code>.C</code> won't work safely because of uncertain disposal, and that you should use <code>.Call</code> and &quot;externalptr&quot; types instead. However, <code>.Call</code> etc is very complicated, and is much harder to use than <code>.C</code> in e.g. numerical settings. As an alternative, <code>set.finalizer</code> provides a safe way to ensure that your <code>.C</code>-created persistent object will tidy itself up when its R pointer is no longer required, just as you can with <code>externalptr</code> objects. There is no need for <code>on.exit</code> or other precautions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Always assign the result to a variable-- usually a temporary var inside a function...
# ... which R will destroy when the function ends. EG:
# keeper &lt;- set.finalizer( handle, finalizer.name, PACKAGE=NULL)
set.finalizer( handle, finalizer.name, PACKAGE=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.finalizer_+3A_handle">handle</code></td>
<td>
<p>[integer vector]. Pointer to your object, of length 1 on 32-bit systems or 2 on 64-bit systems. Will have been returned by your object-creation function in C.</p>
</td></tr>
<tr><td><code id="set.finalizer_+3A_finalizer.name">finalizer.name</code></td>
<td>
<p>Preferably a &quot;native symbol&quot; corresponding to a registered routine in a DLL; alternatively a string that names your <code>.C</code>-callable disposal routine. The routine must take exactly one argument, a 32-bit or 64-bit integer (the handle).</p>
</td></tr>
<tr><td><code id="set.finalizer_+3A_package">PACKAGE</code></td>
<td>
<p>[string] iff <code>finalizer.name</code> is <code>character</code>, this is a PACKAGE argument that specifies the DLL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You <b>must</b> assign the result to a variable, otherwise your object will be prematurely terminated!
</p>
<p><code>set.finalizer</code> provides a wrapper for R's own <code>reg.finalizer</code>, setting up a dummy &quot;trigger&quot; environment with a registered finalizer. The trigger is defined as an environment rather than the more obvious choice of an external pointer, because the latter would require me to get fancy with <code>.Call</code>. The role of <code>reg.finalizer</code> is to prime the trigger, so that when the trigger is subsequently garbage-collected, your specified <code>.C</code> function is called to do the finalization.
</p>
<p>Note that finalization will only happen after <em>all copies</em> of <code>keeper</code> have been deleted. If you make a &quot;temporary&quot; copy in the global environment, remember to delete it! (Though presumably finalizers are de-registered if R is restarted and the keeper is reloaded, so there shouldn't be cross-session consequences.). Finalization won't necessarily happen immediately the last copy is deleted; you can call <code>gc()</code> to force it.
</p>


<h3>Value</h3>

<p>A list with elements <code>handle</code> and <code>trigger</code>, the second being the environment that will trigger the call when discarded. The first is the original handle; it has storage mode integer so, as per <b>Examples</b>, you don't need to coerce it when subsequently passing it to <code>.C</code>.
</p>


<h3>See Also</h3>

<p>.C, .Call, reg.finalizer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myfun &lt;- function( ...) {
  ...0
  # Create object, return pointer, and ensure safe disposal
  keeper &lt;- set.finalizer( .C( "create_thing", handle=integer(2), ...1)$handle,
      "dispose_of_thing")
  "cause" + "crash" # whoops, will cause crash: but finalizer will still be called
  # "dispose_of_thing" had better be the name of a DLL routine that takes a...
  # ... single integer argument, of length 1 or 2
  # Intention was to use the object. First param of DLL routine "use_thing" should
  # be pointer to thing.
  .C( "use_thing", keeper$handle, ...2)
}
myfun(...)

## End(Not run)
</code></pre>

<hr>
<h2 id='set.presave.hook.mvb'>Do something-or-other</h2><span id='topic+set.presave.hook.mvb'></span>

<h3>Description</h3>

<p>I have forgotten what this function is for, but probably the only reason it's documented is to make sure it's exported... My advice: don't use it!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.presave.hook.mvb( hook, set=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.presave.hook.mvb_+3A_hook">hook</code></td>
<td>
<p>can't remember</p>
</td></tr>
<tr><td><code id="set.presave.hook.mvb_+3A_set">set</code></td>
<td>
<p>boolean...</p>
</td></tr>
</table>

<hr>
<h2 id='setup.mcache'>Cacheing objects for lazy-load access</h2><span id='topic+setup.mcache'></span>

<h3>Description</h3>

<p>Manually setup existing reference objects&ndash; rarely used explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup.mcache( envir, fpath, refs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup.mcache_+3A_envir">envir</code></td>
<td>
<p>environment or position on the search path.</p>
</td></tr>
<tr><td><code id="setup.mcache_+3A_fpath">fpath</code></td>
<td>
<p>directory where &quot;obj*.rda&quot; files live.</p>
</td></tr>
<tr><td><code id="setup.mcache_+3A_refs">refs</code></td>
<td>
<p>which objects to handle&ndash; all names in the <code>mcache</code> attribute of <code>envir</code>, by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an active binding in <code>envir</code> for each element in <code>refs</code>. The active binding for an object <code>myobj</code> will be a function which keeps the real data in its own environment, reading and writing it as required. Writing a new value will give <code>attr( envir, "mcache")[ "myobj"]</code> a negative sign. This signals that the &quot;obj*.rda&quot; file needs updating, and the next <code><a href="#topic+Save">Save</a></code> (or <code><a href="#topic+move">move</a></code> or <code><a href="#topic+cd">cd</a></code>) command will do so. [The &quot;*&quot; is the absolute value of <code>attr( envir, "mcache")[ "myobj"]</code>.] One wrinkle is that the &quot;real data&quot; is initially a <code>promise</code> created by <code>delayedAssign</code>, which will fetch the data from disk the first time it is needed.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlazy">mlazy</a></code>, <code>makeActiveBinding</code>, <code>delayedAssign</code>
</p>

<hr>
<h2 id='sleuth'>Generalized version of find</h2><span id='topic+sleuth'></span>

<h3>Description</h3>

<p>Looks for objects that regex-match <code>pattern</code>, in all attached workspaces (as per <code>search()</code>) and any maintained packages (see <code><a href="#topic+maintain.packages">maintain.packages</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sleuth(pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sleuth_+3A_pattern">pattern</code></td>
<td>
<p>regex</p>
</td></tr>
<tr><td><code id="sleuth_+3A_...">...</code></td>
<td>
<p>other args to <code>grep</code>, e.g. <code>perl=TRUE</code> or <code>ignore.case=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of environments containing one or more matching objects, with the object names returned as a character vector within each list element.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+search.for.regexpr">search.for.regexpr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sleuth( '^rm')
# On my setup, that currently gives:
#$ROOT
#[1] "rmsrc"
#
#$`package:stats`
#[1] "rmultinom"
#
#$`package:base`
#[1] "rm"
#
#$mvbutils
#[1] "rm.pkg"
#
#$handy2
#[1] "rmultinom"
#
</code></pre>

<hr>
<h2 id='source.mvb'>Read R code and data from a file or connection</h2><span id='topic+source.mvb'></span><span id='topic+current.source'></span><span id='topic+from.here'></span>

<h3>Description</h3>

<p><code>source.mvb</code> works like <code>source(local=TRUE)</code>, except you can intersperse free-format data into your code. <code>current.source</code> returns the connection that's currently being read by <code>source.mvb</code>, so you can redirect input accordingly. To do this conveniently inside <code>read.table</code>, you can use <code>from.here</code> to read the next lines as data rather than R code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source.mvb( con, envir=parent.frame(), max.n.expr=Inf,
  echo=getOption( 'verbose'), print.eval=echo,
  prompt.echo=getOption( 'prompt'), continue.echo=getOption( 'continue'))
current.source()
from.here( EOF=as.character(NA)) # Don't use it like this!
# Use "from.here" only inside "read.table", like so:
# read.table( file=from.here( EOF=), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="source.mvb_+3A_con">con</code></td>
<td>
<p>a filename or connection</p>
</td></tr>
<tr><td><code id="source.mvb_+3A_envir">envir</code></td>
<td>
<p>an environment to evaluate the code in; by default, the environment of the caller of <code>source</code></p>
</td></tr>
<tr><td><code id="source.mvb_+3A_max.n.expr">max.n.expr</code></td>
<td>
<p>finish after evaluating <code>max.n.expr</code> complete expressions, unless file ends first.</p>
</td></tr>
<tr><td><code id="source.mvb_+3A_eof">EOF</code></td>
<td>
<p>line which terminates data block; lines afterwards will again be treated as R statements.</p>
</td></tr>
<tr><td><code id="source.mvb_+3A_...">...</code></td>
<td>
<p>other args to <code>read.table</code></p>
</td></tr>
<tr><td><code id="source.mvb_+3A_echo">echo</code>, <code id="source.mvb_+3A_print.eval">print.eval</code>, <code id="source.mvb_+3A_prompt.echo">prompt.echo</code>, <code id="source.mvb_+3A_continue.echo">continue.echo</code></td>
<td>
<p>as per <code>source</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls to <code>source.mvb</code> can be nested, because the function maintains a stack of connections currently being read by <code>source.mvb</code>. The stack is stored in the list <code>source.list</code> in the <code>mvb.session.info</code> environment, on the search path. <code>current.source</code> returns the last (most recent) entry of <code>source.list</code>.
</p>
<p>The sequence of operations differs from vanilla <code>source</code>, which parses the entire file and then executes each expression in turn; that's why it can't cope with interspersed data. Instead, <code>source.mvb</code> parses one statement, then executes it, then parses the next, then executes that, etc. Thus, if you include in your file a call to e.g.
</p>
<p><code>text.line &lt;- readLines( con=current.source(), n=1)</code>
</p>
<p>then the next line in the file will be read in to <code>text.line</code>, and execution will continue at the following line. <code><a href="#topic+readLines.mvb">readLines.mvb</a></code> can be used to read text whose length is not known in advance, until a terminating string is encountered; lines after the terminator, if any, will again be evaluated as R expressions by <code>source.mvb</code>.
</p>
<p>After <code>max.n.expr</code> statements (i.e. syntactically complete R expressions) have been executed, <code>source.mvb</code> will return.
</p>
<p>If the connection was open when <code>source.mvb</code> is called, it is left open; otherwise, it is closed.
</p>
<p>If you want to use <code>read.table</code> or <code>scan</code> etc. inside a <code>source.mvb</code> file, to read either a known number of lines or the rest of the file as data, you can use e.g. <code>read.table( current.source(), ...)</code>.
</p>
<p>If you want to <code>read.table</code> to read an <em>unknown</em> number of lines until a terminator, you could explicitly use <code><a href="#topic+readLines.mvb">readLines.mvb</a></code>, as shown in the demo &quot;source.mvb.demo.R&quot;. However, the process is cumbersome because you have to explicitly open and close a <code>textConnection</code>. Instead, you can just use <code>read.table( from.here( EOF=...), ...)</code> with a non-default <code>EOF</code>, as in <b>Usage</b> and the same demo (but see <b>Note</b>). <code>from.here</code> <em>shouldn't</em> be used inside <code>scan</code>, however, because a temporary file will be left over.
</p>
<p><code>current.source()</code> can also be used inside a source file, to work out the source file's name. Of course, this will only work if the file is being handled by <code>source.mvb</code> rather than <code>source</code>.
</p>
<p>If you type <code>source.list</code> at the R command prompt, you should always see an empty list, because all <code>source.mvb</code> calls should have finished. However, the source list can occasionally become corrupt, i.e. containing invalid connections (I have only had this happen when debugging <code>source.mvb</code> and quitting before the exit code can clean up). If so, you'll get an error message on typing <code>source.list</code> (?an R bug?). Normally this won't matter at all. If it bothers you, try <code>source.list &lt;&lt;- list()</code>.
</p>


<h3>Value</h3>

<p><code>source.mvb</code> returns the value of the last expression executed, but is mainly called for its side-effects of evaluating the code. <code>from.here</code> returns a connection, of class <code>c( "selfdeleting.file", "file", "connection")</code>; see <b>Details</b>. <code>current.source</code> returns a connection.
</p>


<h3>Limitations</h3>

<p>Because <code>source.mvb</code> relies on <code>pushBack</code>, <code>con=stdin()</code> won't work.
</p>


<h3>Note</h3>

<p><code>from.here</code> creates a temporary file, which should be automatically deleted when <code>read.table</code> finishes (with or without an error). Technically, the connection returned by <code>from.here</code> is of class <code>selfdeleting.file</code> inheriting from <code>file</code>; this class has a specific <code>close</code> method, which unlinks the <code>description</code> field of the connection. This trick works inside <code>read.table</code>, which calls <code>close</code> explicitly, but not in <code>scan</code> or <code>closeAllConnections</code>, which ignore the <code>selfdeleting.file</code> class.
</p>
<p><code>from.here()</code> without an explicit terminator is equivalent to <code>readLines( current.source())</code>, and the latter avoids temporary files.
</p>


<h3>See Also</h3>

<p><code>source</code>, <code><a href="#topic+readLines.mvb">readLines.mvb</a></code>, <code><a href="#topic+flatdoc">flatdoc</a></code>, the demo in &quot;source.mvb.demo.R&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># You wouldn"t normally do it like this:
tt &lt;- tempfile()
cat( "data &lt;- scan( current.source(), what=list( x=0, y=0))",
"27 3",
"35 5",
file=tt, sep="\n")
source.mvb( tt)
unlink( tt)
data # list( x=c( 27, 35), y=c(3, 5))
# "current.source", useful for hacking:
tt &lt;- tempfile()
cat( "cat( \"This code is being read from file\",",
"summary( current.source())$description)", file=tt)
source.mvb( tt)
cat( "\nTo prove the point:\n")
cat( scan( tt, what="", sep="\n"), sep="\n")
unlink( tt)
</code></pre>

<hr>
<h2 id='strip.missing'>Exclude &quot;missing&quot; objects</h2><span id='topic+strip.missing'></span>

<h3>Description</h3>

<p>To be called inside a function, with a character vector of object names in that function's frame. <code>strip.missing</code> will return all names except those corresponding to formal arguments which were not set in the original call and which lack defaults. The output can safely be passed to <code>get</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.missing( obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip.missing_+3A_obs">obs</code></td>
<td>
<p>character vector of object names, often from <code>ls(all=TRUE)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formal arguments that were not passed explicitly, but which <b>do</b> have defaults, will <b>not</b> be treated as missing; instead, they will be set equal to their evaluated defaults. This could cause problems if the defaults aren't meant to be evaluated.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+returnList">returnList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>funco &lt;- function( first, second, third) {
  a &lt;- 9
  return( do.call("returnList", lapply( strip.missing( ls()), as.name)))
}
funco( 1) # list( a=9, first=1)
funco( second=2) # list( a=9, second=2)
funco( ,,3) # list( a=9, third=3)
funco2 &lt;- function( first=999) {
  a &lt;- 9
  return( do.call("returnList", lapply( strip.missing( ls()), as.name)))
}
funco2() # list( a=9, first=999) even tho' "first" was not set
</code></pre>

<hr>
<h2 id='task.home'>Organizing R workspaces</h2><span id='topic+task.home'></span>

<h3>Description</h3>

<p>Returns file path to current task, or to a file in that task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Often: task.home()
task.home(fname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="task.home_+3A_fname">fname</code></td>
<td>
<p>file name, a character(1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without any arguments, <code>task.home</code> returns the path of the current task. With a filename argument, the filename is interpreted as relative to the current task, and its full (non-relative) path is returned.
</p>
<p><code>task.home</code> is almost obsolete in R, since the working directory tracks the current task. It is more important in the S+ version of <code>mvbutils</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd">cd</a></code>, <code>getwd</code>, <code>file.path</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
task.home( "myfile.c") # probably the same as file.path( getwd(), "myfile.c")
task.home() # probably the same as getwd()

## End(Not run)
</code></pre>

<hr>
<h2 id='unpackage'>Convert existing source package into task package</h2><span id='topic+unpackage'></span>

<h3>Description</h3>

<p>Converts an existing source package into a task package. A subdirectory with the package name will be created under the current working directory, and will be populated with a &quot;.RData&quot; file and various other files/directories from the source package. All Rd files will be turned into flat-format help in the &quot;.RData&quot;, either attached to functions or as stand-alone &quot;*.doc&quot; text objects, as per <code><a href="#topic+help2flatdoc">help2flatdoc</a></code>. The subdirectory will also be made into a <em>task</em>, i.e. it will be added to the &quot;tasks&quot; vector in the current workspace that <code><a href="#topic+cd">cd</a></code> uses to keep track of the task hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpackage(spath, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpackage_+3A_spath">spath</code></td>
<td>
<p>where to find the source package</p>
</td></tr>
<tr><td><code id="unpackage_+3A_force">force</code></td>
<td>
<p>if TRUE, overwrite any previous contents of task package without prompting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NAMESPACE file won't be copied; instead, it will be auto-generated by <code><a href="#topic+pre.install">pre.install</a></code>. Therefore, some features of the original NAMESPACE may be lost. You can either copy the NAMESPACE manually (in which case, you'll need to maintain it by hand), or write a &quot;pre.install.hook.MYPACK&quot; function.
</p>
<p>The DESCRIPTION file becomes a character vector called e.g. <code>&lt;mypack&gt;.DESCRIPTION</code>, of class &quot;cat&quot; (see <code><a href="#topic+as.cat">as.cat</a></code>).
</p>
<p>Functions in the &quot;.RData&quot; may be saved with extra attributes, in particular &quot;doc&quot; (deduced from a dot-Rd file) but perhaps other things too that they acquire after the package code is <code>source</code>d. Attributes that are character vector will acquire class &quot;docattr&quot;, so that they won't be fully displayed during default printing of the function; to see them, use e.g. <code>as.cat( attr( myfun, "myatt"))</code> or <code>unclass( attr( myfun, "myatt"))</code> or, if you are using the <span class="pkg">atease</span> package, just <code>as.cat( myfun@myatt)</code>. Editing the function with <code><a href="#topic+fixr">fixr</a></code> will display the character attributes in full.
</p>
<p>Any environment objects found in the package's environment (its namespace environment) will be dropped from the &quot;.RData&quot; file, with a warning; this is to avoid dramas on reloading.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pre.install">pre.install</a></code>, <code><a href="#topic+mvbutils.packaging.tools">mvbutils.packaging.tools</a></code>
</p>

<hr>
<h2 id='warn.and.subset'>Extract subset and warn about omitted cases</h2><span id='topic+warn.and.subset'></span>

<h3>Description</h3>

<p>Extract row-subset of a <code>data.frame</code> according to a condition. If any cases (rows) are omitted, they are listed with a warning. Rows where the condition gives NA are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># This is the obligatory format, and is not very useful; look at EXAMPLES instead
warn.and.subset(x, cond,
    mess.head=deparse( substitute( x), width.cutoff=20, control=NULL, nlines=1),
    mess.cond=deparse( substitute( cond), width.cutoff=40, control=NULL, nlines=1),
    row.info=rownames( x), sub=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="warn.and.subset_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="warn.and.subset_+3A_cond">cond</code></td>
<td>
<p>expression to evaluate in the context of <code>data.frame</code>. If <code>sub=TRUE</code> (the default), this will be substituted. If <code>sub=FALSE</code>, you can use a pre-assigned expression; in that case, you had better set <code>mess.cond</code> manually.</p>
</td></tr>
<tr><td><code id="warn.and.subset_+3A_mess.head">mess.head</code></td>
<td>
<p>description of data.frame (e.g. its name) for use in a warning.</p>
</td></tr>
<tr><td><code id="warn.and.subset_+3A_mess.cond">mess.cond</code></td>
<td>
<p>description of the desired condition for use in a warning.</p>
</td></tr>
<tr><td><code id="warn.and.subset_+3A_row.info">row.info</code></td>
<td>
<p>character vector that will describe rows; omitted elements appear in the warning</p>
</td></tr>
<tr><td><code id="warn.and.subset_+3A_sub">sub</code></td>
<td>
<p>should <code>cond</code> be treated as a literal expression to be evaluated, or as a pre-computed logical index?</p>
</td></tr>
</table>
<p># ...: just there to keep RCMD CHECK happy&ndash; for heaven's sake...
</p>


<h3>Value</h3>

<p>The subsetted data.frame.
</p>


<h3>See Also</h3>

<p><code>%where.warn%</code> which is a less-flexible way of doing the same thing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame( a=1:3, b=letters[1:3])
df1 &lt;- warn.and.subset( df, a %% 2 == 1, 'Boring example data.frame', 'even-valued "a"')
condo &lt;- quote( a %% 2 == 1)
df2 &lt;- warn.and.subset( df, condo, 'Same boring data.frame', deparse( condo), sub=FALSE)
</code></pre>

<hr>
<h2 id='write.sourceable.function'>Sourceable code for functions (and more) with flat-format documentation</h2><span id='topic+write.sourceable.function'></span>

<h3>Description</h3>

<p>Works like <code>write</code> for functions without flat documentation (i.e. without a &quot;doc&quot; attribute). If a &quot;doc&quot; attribute exists, the file is written in a form allowing it to be edited and then read back in with &quot;source.mvb&quot;; the &quot;doc&quot; attribute is given as free-form text following the function definition. If applied to a non-function with a &quot;source&quot; attribute, just the source attribute is printed; the idea is that this could be read back by <code>source</code> (or <code><a href="#topic+source.mvb">source.mvb</a></code>), probably in the course of <code><a href="#topic+FF">FF</a></code> after <code><a href="#topic+fixr">fixr</a></code>, to regenerate the non-function object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.sourceable.function( x, con, append=FALSE, print.name=FALSE,
    doc.special=TRUE, xn=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.sourceable.function_+3A_x">x</code></td>
<td>
<p>function or other object, or the name thereof, that is to be written. If <code>x</code> is not a function, then it must have an attribute &quot;source&quot;.</p>
</td></tr>
<tr><td><code id="write.sourceable.function_+3A_con">con</code></td>
<td>
<p>a connection or filename</p>
</td></tr>
<tr><td><code id="write.sourceable.function_+3A_append">append</code></td>
<td>
<p>if &quot;con&quot; is not already open, should it be appended to rather than overwritten?</p>
</td></tr>
<tr><td><code id="write.sourceable.function_+3A_print.name">print.name</code></td>
<td>
<p>should output start with <code>"NAME" &lt;-</code> (where NAME is deduced from <code>x</code>)?</p>
</td></tr>
<tr><td><code id="write.sourceable.function_+3A_doc.special">doc.special</code></td>
<td>
<p>TRUE if <code>doc</code> attribute is to be printed as flat doc&ndash; assumes readback via <code>source.mvb</code></p>
</td></tr>
<tr><td><code id="write.sourceable.function_+3A_xn">xn</code></td>
<td>
<p>(string) can set this to be the name of the function if <code>print.name</code> is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is unquoted and <code>print.name=TRUE</code>, the name is obtained from <code>deparse( substitute( x))</code>. If <code>x</code> is a character string, the name is <code>x</code> itself and the function printed is <code>get(x)</code>.
</p>
<p>The real criterion for an attribute to be output in <code><a href="#topic+flatdoc">flatdoc</a></code>-style, is not whether the attribute is called <code>doc</code>, but rather whether it is a character-mode object of class <code>docattr</code>. You can use this to force <code><a href="#topic+flatdoc">flatdoc</a></code>-style output of several <code>doc</code>-like attributes.
</p>
<p>The default EOF line for an attribute is &lt;&lt;end of doc&gt;&gt;, but this will be adjusted if it appears in the attribute itself.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+source.mvb">source.mvb</a></code>, <code><a href="#topic+readLines.mvb">readLines.mvb</a></code>, <code><a href="#topic+flatdoc">flatdoc</a></code>, the file &quot;demostuff/original.dochelp.rrr&quot;, the demo in &quot;flatdoc.demo.r&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write.sourceable.function( write.sourceable.function, "wsf.r")
# To dump all functions and their documentation in a workspace into a single sourceable file:
cat( "", file="allfuns.r")
sapply( find.funs(), write.sourceable.function, file="allfuns.r", append=TRUE, print.name=TRUE)
# A non-function
scrunge &lt;- c( 1:7, 11)
attr( scrunge, "source") &lt;- c( "# Another way:", "c( 1:4, c( 5:7, 11))")
scrunge # [1] 1 2 3 4 5 6 7 11
write.sourceable.function( scrunge, stdout()) # source
fixr( scrunge) # source

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
