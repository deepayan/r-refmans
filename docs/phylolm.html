<!DOCTYPE html><html lang="en"><head><title>Help for package phylolm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylolm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#phylolm-package'><p>Phylogenetic Linear Regression</p></a></li>
<li><a href='#flowerSize'><p>Flower size of 25 Euphorbiaceae species</p></a></li>
<li><a href='#flowerTree'><p>Phylogenetic tree of 25 Euphorbiaceae species</p></a></li>
<li><a href='#guidetree'><p>Binary population tree within Arabidopsis thaliana</p></a></li>
<li><a href='#mace'>
<p>Multi-task learning for ancestral state estimation.</p></a></li>
<li><a href='#OU1d.loglik'>
<p>Log likelihood of an one-dimensional Ornstein-Uhlenbeck model</p></a></li>
<li><a href='#OUshifts'><p>Detections of shifts in the OU process along a phylogeny.</p></a></li>
<li><a href='#OUshifts-methods'><p>Methods for class 'OUshifts'.</p></a></li>
<li><a href='#phyloglm'><p>Phylogenetic Generalized Linear Model</p></a></li>
<li><a href='#phyloglm-methods'><p>Methods for class 'phyloglm'.</p></a></li>
<li><a href='#phyloglmstep'><p>Stepwise model selection for Phylogenetic Generalized Linear Model</p></a></li>
<li><a href='#phylolm'><p>Phylogenetic Linear Model</p></a></li>
<li><a href='#phylolm-methods'><p>Methods for class 'phylolm'.</p></a></li>
<li><a href='#phylostep'><p>Stepwise model selection for Phylogenetic Linear Model</p></a></li>
<li><a href='#pruningwise.branching.times'><p>Calculates internal node ages in</p>
an ultrametric &quot;pruningwise&quot; tree</a></li>
<li><a href='#pruningwise.distFromRoot'><p>Calculates node distance from the root in</p>
an &quot;pruningwise&quot; tree</a></li>
<li><a href='#quartetCF'><p>Quartet concordance factors across Arabidopsis thaliana</p></a></li>
<li><a href='#rbinTrait'><p>Binary trait simulation</p></a></li>
<li><a href='#rTrait'><p>Continuous trait simulation</p></a></li>
<li><a href='#stepwise.test.tree'><p>Fits a population tree to data from quartet concordance factors</p></a></li>
<li><a href='#test.one.species.tree'><p>Tests the fit of a population tree to quartet concordance factor data</p></a></li>
<li><a href='#test.tree.preparation'><p>data structure preparation for testing a population tree</p></a></li>
<li><a href='#three.point.compute'><p>Computations with a (generalized) three-point structured tree</p></a></li>
<li><a href='#transf.branch.lengths'><p>Creates a tree with branch lengths to represent the 3-point structure of a covariance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.6.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetic Linear Regression</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), ape</td>
</tr>
<tr>
<td>Imports:</td>
<td>future.apply</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for fitting phylogenetic linear models and phylogenetic generalized linear models. The computation uses an algorithm that is linear in the number of tips in the tree. The package also provides functions for simulating continuous or binary traits along the tree. Other tools include functions to test the adequacy of a population tree.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lamho86/phylolm">https://github.com/lamho86/phylolm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lamho86/phylolm/issues">https://github.com/lamho86/phylolm/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-30 13:59:25 UTC; lamho</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, nlme</td>
</tr>
<tr>
<td>Author:</td>
<td>Lam Si Tung Ho [aut, cre],
  Cecile Ane [aut],
  Robert Lachlan [ctb],
  Kelsey Tarpinian [ctb],
  Rachel Feldman [ctb],
  Qing Yu [ctb],
  Wouter van der Bijl [ctb],
  Joan Maspons [ctb],
  Rutger Vos [ctb],
  Paul Bastide [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lam Si Tung Ho &lt;lamho86@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-30 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='phylolm-package'>Phylogenetic Linear Regression</h2><span id='topic+phylolm-package'></span>

<h3>Description</h3>

<p>The package provides functions for fitting phylogenetic linear models and phylogenetic generalized linear models. The computation uses an algorithm that is linear in the number of tips in the tree. The package also provides functions for simulating continuous and binary traits along the tree.
Other tools include functions to test the adequacy of a population tree.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> phylolm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.6.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-09-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Lam Si Tung Ho, Cecile Ane, Robert Lachlan, Kelsey Tarpinia, Rachel Feldman, Qing Yu, Wouter van der Bijl, Joan Maspons, Rutger Vos, Paul Bastide
</p>
<p>Maintainer: Lam Si Tung Ho &lt;lamho86@gmail.com&gt;
</p>

<hr>
<h2 id='flowerSize'>Flower size of 25 Euphorbiaceae species</h2><span id='topic+flowerSize'></span>

<h3>Description</h3>

<p> Names, flower diameters (mm) and log-transformed diameter (mm) of 25 plant species.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flowerSize)</code></pre>


<h3>Format</h3>

<p>A data frame with 25 rows and 3 columns.</p>


<h3>References</h3>

<p>Davis, C.C., Latvis, M., Nickrent, D.L., Wurdack, K.J. and Baum, D.A. 2007. &quot;Floral gigantism in Rafflesiaceae&quot;. Science <b>315</b>:1812.
</p>

<hr>
<h2 id='flowerTree'>Phylogenetic tree of 25 Euphorbiaceae species</h2><span id='topic+flowerTree'></span>

<h3>Description</h3>

<p>A phylogenetic tree with 25 tips and 24 internal nodes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flowerTree)</code></pre>


<h3>Format</h3>

<p>A data frame of class phylo.</p>


<h3>References</h3>

<p>Davis, C.C., Latvis, M., Nickrent, D.L., Wurdack, K.J. and Baum, D.A. 2007. &quot;Floral gigantism in Rafflesiaceae&quot;. Science <b>315</b>:1812.
</p>

<hr>
<h2 id='guidetree'>Binary population tree within Arabidopsis thaliana</h2><span id='topic+guidetree'></span>

<h3>Description</h3>

<p>Binary population tree for
29 A. thaliana accessions and A. lyrata,
obtained from chromosome 4 using MDL to delimit loci,
BUCKy to estimate quartet concordance factors (CFs) and
Quartet Max Cut to estimate the tree topology.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(guidetree)</code></pre>


<h3>Format</h3>

<p>tree object of class phylo. Branch lengths are in coalescent units.</p>


<h3>References</h3>

<p>Stenz, Noah W. M., Bret Larget, David A. Baum and Cécile Ané (2015).
Exploring tree-like and non-tree-like patterns using genome sequences:
An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh.
Systematic Biology, <b>64</b>(5):809-823.
</p>
<p>TICR pipeline: github.com/nstenz/TICR
</p>

<hr>
<h2 id='mace'>
Multi-task learning for ancestral state estimation.
</h2><span id='topic+mace'></span>

<h3>Description</h3>

<p>Estimate the ancestral states of multiple traits simultaneously using a regularized maximum likelihood objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mace(trait, phy, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mace_+3A_trait">trait</code></td>
<td>
<p>a matrix of trait values. Each row is one species and each column is a trait.</p>
</td></tr>
<tr><td><code id="mace_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="mace_+3A_lambda">lambda</code></td>
<td>
<p>regularizer parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traits are assumed to evolve according to the Brownian motion model.
</p>


<h3>Value</h3>

<p>a numeric vector of estimated ancestral states.
</p>


<h3>Note</h3>

<p>The default choice for <code>lambda</code> was proposed by Ho et al. (2019).
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho
</p>


<h3>References</h3>

<p>Ho, Lam Si Tung, Vu Dinh, and Cuong V. Nguyen. &quot;Multi-task learning improves ancestral state reconstruction.&quot; Theoretical Population Biology 126 (2019): 33-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 3
anc = c(0, 8, 16)
sig2 = c(1, 1, 2)
tree = rtree(50)

trait = rTrait(n = 1, phy = tree, model = "BM",
               parameters=list(ancestral.state = anc[1], sigma2 = sig2[1]))
for (i in 2:m) {
  trait = cbind(trait,rTrait(n = 1, phy = tree, model = "BM",
                             parameters=list(ancestral.state = anc[i], sigma2 = sig2[i])))
}
res = mace(trait, tree)
print(res)

</code></pre>

<hr>
<h2 id='OU1d.loglik'>
Log likelihood of an one-dimensional Ornstein-Uhlenbeck model
</h2><span id='topic+OU1d.loglik'></span>

<h3>Description</h3>

<p>computes log likelihood of an one-dimensional Ornstein-Uhlenbeck model with an algorithm that is linear in the number of tips in the tree. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OU1d.loglik(trait, phy, model = c("OUrandomRoot", "OUfixedRoot"), parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OU1d.loglik_+3A_trait">trait</code></td>
<td>

<p>a vector of trait values.
</p>
</td></tr>
<tr><td><code id="OU1d.loglik_+3A_phy">phy</code></td>
<td>

<p>a phylogenetic tree of type phylo with branch lengths.
</p>
</td></tr>
<tr><td><code id="OU1d.loglik_+3A_model">model</code></td>
<td>

<p>an Ornstein-Uhlenbeck model.
</p>
</td></tr>
<tr><td><code id="OU1d.loglik_+3A_parameters">parameters</code></td>
<td>

<p>List of parameters for the model
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr = rtree(100)
alpha = 1
sigma2 = 1
sigma2_error = 0.5
ancestral.state = 0
optimal.value = 1
  
trait = rTrait(n = 1, tr, model = "OU", 
              parameters = list(ancestral.state=ancestral.state, alpha=alpha,
                                sigma2=sigma2,sigma2_error=sigma2_error,
                                optimal.value=optimal.value))
OU1d.loglik(trait=trait, phy=tr, model="OUfixedRoot", 
            parameters=list(ancestral.state=ancestral.state, alpha=alpha,sigma2=sigma2,
                            sigma2_error=sigma2_error,optimal.value=optimal.value))
</code></pre>

<hr>
<h2 id='OUshifts'>Detections of shifts in the OU process along a phylogeny.</h2><span id='topic+OUshifts'></span>

<h3>Description</h3>

<p>Trait data is fitted to a phylogeny using an Ornstein-Uhlenbeck (OU) process, such that the mean (or selection optimum) of the process may change in one or more edges in the tree. The number and location of changes, or shifts, is estimated using an information criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUshifts(y, phy, method = c("mbic", "aic", "bic", "saic", "sbic"),
         nmax, check.pruningwise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUshifts_+3A_y">y</code></td>
<td>
<p>values for the trait data.</p>
</td></tr>
<tr><td><code id="OUshifts_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="OUshifts_+3A_method">method</code></td>
<td>
<p>a method for model selection (see details below).</p>
</td></tr>
<tr><td><code id="OUshifts_+3A_nmax">nmax</code></td>
<td>
<p>maximum allowed number of shifts.</p>
</td></tr>
<tr><td><code id="OUshifts_+3A_check.pruningwise">check.pruningwise</code></td>
<td>
<p>if TRUE, the algorithm checks if the ordering
of the edges in phy are in pruningwise order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not accept multivariate data (yet): <code>y</code> should be a vector named with species labels.  The data <code>y</code> and the tree <code>phy</code> need to contain the same species. The user can choose among various information criteria.  Each criterion seeks to minimize the value of <code class="reqn">-2 \log[</code>likelihood<code class="reqn">(y, M)] +</code> penalty<code class="reqn">(M)</code>, where <code class="reqn">M</code> is an OU model with <code class="reqn">m</code> shifts, placed on various edges along the phylogeny.  All models use <code class="reqn">3+m</code> parameters: <code class="reqn">\alpha</code>, <code class="reqn">\sigma^2</code>, and <code class="reqn">m+1</code> parameters to describe the expected trait values in each of the <code class="reqn"> m+1</code> regimes.  The AIC penalty is <code class="reqn">2*(3+m)</code>. The BIC penalty is  <code class="reqn">(3+m) \log(n)</code> where <code class="reqn">n</code> is the numer of species.  If one considers the position of the <code class="reqn">m</code> shifts in the phylogeny as parameters (even though they are discrete parameters), we get the sAIC penalty <code class="reqn">2*(3+2m</code>) (used in SURFACE), and the sBIC penalty <code class="reqn">(3+2*m)*\log(n)</code>.  The default penalty (model = 'mbic') is defined as <code class="reqn">3*\log(n)+(2m-1)\log(n)+\sum_{i=0}^{m}(\log(n_i))</code>. A lower value of <code>nmax</code> will make the search faster, but if the estimated number of shifts is found equal to nmax, then the output model is probably not optimal.  Re-running with a larger <code>nmax</code> would take longer, but would likely return a more complex model with a better score.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>the input trait.</p>
</td></tr>
<tr><td><code>phy</code></td>
<td>
<p>the input tree.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>the information criterion value of the optimal model.</p>
</td></tr>
<tr><td><code>nmax</code></td>
<td>
<p>maximum allowed number of shifts.</p>
</td></tr>
<tr><td><code>nshift</code></td>
<td>
<p>estimated number of shifts.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>estimated selection strength of the optimal model.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>estimated variance of the optimal model.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>estimated the expected value of the trait in lineages without shift.</p>
</td></tr>
<tr><td><code>pshift</code></td>
<td>
<p>positions of shifts, i.e. indicies of edges where the estimated shifts occurred. The same ordering of edges is used as in phy.</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>estimated shifts in the expected value of the trait.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The tip labels in the tree are matched to the data names. The default choice for the parameters are as follows:
<code>method = "mbic"</code>,
<code>check.pruningwise = TRUE</code>
</p>
<p>Due to unidentifiability, the parameters are the expected value of the trait and their shifts instead of the ancestral trait, the optimal values and shifts in optimal values.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>References</h3>

<p>Ho, L. S. T. and Ane, C. 2014.  &quot;Intrinsic inference difficulties for trait evolution with Ornstein-Uhlenbeck models&quot;. Methods in Ecology and Evolution. <b>5</b>(11):1133-1146.
</p>
<p>Ingram, T. and Mahler, D.L. 2013. &quot;SURFACE: detecting convergent
evolution from comparative data by fitting Ornstein-Uhlenbeck models
with step-wise Akaike information criterion&quot;. Methods in Ecology and
Evolution <b>4</b>:416-425.
</p>
<p>Zhang, N.R. and Siegmund, D.O. 2007. &quot;A modified Bayes information
criterion with applications to the analysis of comparative genomic
hybridization data&quot;. Biometrics <b>63</b>:22-32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flowerSize)
data(flowerTree)
result &lt;- OUshifts(flowerSize$log_transformed_size, flowerTree, 
                   method = "mbic", nmax = 1)
plot.OUshifts(result,show.tip.label=FALSE)
</code></pre>

<hr>
<h2 id='OUshifts-methods'>Methods for class 'OUshifts'.</h2><span id='topic+plot.OUshifts'></span>

<h3>Description</h3>

<p>These are method functions for class 'OUshifts'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OUshifts'
plot(x, show.data = TRUE, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

      
<table role = "presentation">
<tr><td><code id="OUshifts-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"OUshifts"</code>.</p>
</td></tr>
<tr><td><code id="OUshifts-methods_+3A_show.data">show.data</code></td>
<td>
<p>if TRUE, visualizes a bar plot of the data side-by-side with the phylogeny.</p>
</td></tr>
<tr><td><code id="OUshifts-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in the bar plot.</p>
</td></tr>
<tr><td><code id="OUshifts-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to plot.phylo to plot the tree.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho, Kelsey Tarpinian</p>


<h3>See Also</h3>

<p><code><a href="#topic+OUshifts">OUshifts</a></code>
</p>

<hr>
<h2 id='phyloglm'>Phylogenetic Generalized Linear Model</h2><span id='topic+phyloglm'></span>

<h3>Description</h3>

<p>Fits the phylogenetic logistic regression described in
Ives and Garland (2010) and the Poisson regression described in Paradis and Claude (2002). The computation uses an algorithm that is
linear in the number of tips in the tree.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloglm(formula, data, phy, method = c("logistic_MPLE","logistic_IG10", "logistic_MLE",
         "poisson_GEE"), btol = 10, log.alpha.bound = 4,
         start.beta=NULL, start.alpha=NULL,
         boot = 0, full.matrix = TRUE, save = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phyloglm_+3A_formula">formula</code></td>
<td>
<p>a model formula.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model. If not
found in <code>data</code>, the variables are taken from the current environment.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_method">method</code></td>
<td>
<p>The &quot;logistic_IG10&quot; method optimizes a GEE approximation to the penalized likelihood of the logistic regression. &quot;logistic_MPLE&quot; maximizes the penalized likelihood of the logistic regression. In both cases, the penalty is Firth's correction. The &quot;poisson_GEE&quot; method solves the generalized estimating equations (GEE) for Poisson regression.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_btol">btol</code></td>
<td>
<p>(logistic regression only) bound on the linear predictor to bound the searching space.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_log.alpha.bound">log.alpha.bound</code></td>
<td>
<p>(logistic regression only) bound for the log of the parameter alpha.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_start.beta">start.beta</code></td>
<td>
<p>starting values for beta coefficients.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_start.alpha">start.alpha</code></td>
<td>
<p>(logistic regression only) starting values for alpha (phylogenetic correlation).</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_boot">boot</code></td>
<td>
<p>number of independent bootstrap replicates, <code>0</code> means no bootstrap.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_full.matrix">full.matrix</code></td>
<td>
<p>if <code>TRUE</code>, the full matrix of bootstrap estimates (coefficients and alpha) will be returned.</p>
</td></tr>
<tr><td><code id="phyloglm_+3A_save">save</code></td>
<td>
<p>if <code>TRUE</code>, the simulated bootstrap data will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses an algorithm that is linear in the number of tips in the tree.
</p>
<p>Bootstrapping can be parallelized using the <code>future</code> package on any future 
compatible back-end. For example, run <code>library(future); plan(multiprocess))</code>, 
after which bootstrapping will automatically occur in parallel. See 
<code><a href="future.html#topic+plan">plan</a></code> for options.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the named vector of coefficients.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>(logistic regression only) the phylogenetic correlation parameter.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>(Poisson regression only) the scale parameter which estimates the overdispersion.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>standard deviation for the regression coefficients.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix for the regression coefficients.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>(logistic regression only) log likelihood.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>(logistic regression only) AIC.</p>
</td></tr>
<tr><td><code>penlogLik</code></td>
<td>
<p>(logistic regression only) penalized log likelihood, using Firth's penalty for coefficients.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations (tips in the tree).</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>number of dependent variables.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call to the function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the estimation method.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code with '0' for successful optimization. With logistic_MPLE, this is the convergence code from the <code>optim</code> routine.</p>
</td></tr>
<tr><td><code>alphaWarn</code></td>
<td>
<p>(logistic regression only) An interger code with '0' for the estimate of alpha is not near the lower and upper bounds, code with '1' for the estimate of alpha near the lower bound, code with '2' for the estimate of alpha near the upper bound.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a design matrix with one row for each tip in the phylogenetic tree.</p>
</td></tr>
<tr><td><code>bootmean</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap means of the parameters estimated.</p>
</td></tr>
<tr><td><code>bootsd</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap standard deviations of the estimated parameters.</p>
</td></tr>
<tr><td><code>bootconfint95</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap 95% confidence interval.</p>
</td></tr>
<tr><td><code>bootmeanAlog</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap mean of the logs of the estimated alphas.</p>
</td></tr>
<tr><td><code>bootsdAlog</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap standard deviation of the logs of the estimated alphas.</p>
</td></tr>
<tr><td><code>bootnumFailed</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) number of independent bootstrap replicates for which
<code>phyloglm</code> failed. These failures may be due to the bootstrap data having too few 0's or too few 1's.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>(<code>boot &gt; 0</code> and <code>full.matrix</code> = <code>TRUE</code> only) matrix of all bootstrap estimates.</p>
</td></tr>
<tr><td><code>bootdata</code></td>
<td>
<p>(<code>boot &gt; 0</code> and <code>save</code> = <code>TRUE</code> only) matrix of all bootstrap data (each column is a dataset).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The tip labels in the tree are matched to the data names (row names in
the data frame). If no data frame is provided through the argument <code>data</code>,
taxon labels in the tree are matched to taxon labels in the response
variable based on the row names of the response vector, and the taxa are
assumed to come in the same order for all variables in the model.
</p>
<p>The logistic regression method of Ives and Garland (2010) uses alpha to estimate the level of phylogenetic correlation. The GEE method for Poisson regression does not estimate the level of phylogenetic correlation but takes it from the existing branch lengths in the tree.
</p>
<p>The standard deviation and the covariance matrix for the coefficients of logistic regression are conditional on the estimated value of the phylogenetic correlation parameter <code class="reqn">\alpha</code>.
</p>
<p>The default choice <code>btol=10</code> constrains the fitted values, i.e. the probability of &quot;1&quot; predicted by the model, to lie within
<code class="reqn">1/(1+e^{ 10})=0.000045</code> and
<code class="reqn">1/(1+e^{-10})=0.999955</code>.
</p>
<p>The log of <code class="reqn">\alpha</code> is bounded in the interval
<code class="reqn">-\log(T) \pm \mathrm{log.alpha.bound}</code> 
where <code class="reqn">T</code> is the mean of the distances from the root to tips. In
other words, <code class="reqn">\alpha T</code> is constrained to lie within
<code class="reqn">\exp(\pm\mathrm{log.alpha.bound})</code>.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho, Robert Lachlan, Rachel Feldman and Cecile Ane</p>


<h3>References</h3>

<p>Ho, L. S. T. and Ane, C. 2014. &quot;A linear-time algorithm for Gaussian and
non-Gaussian trait evolution models&quot;.  Systematic Biology <b>63</b>(3):397-408.
</p>
<p>Ives, A. R. and T. Garland, Jr. 2010. &quot;Phylogenetic logistic regression
for binary dependent variables&quot;.  Systematic Biology <b>59</b>:9-26.
</p>
<p>Paradis E. and Claude J. 2002. &quot;Analysis of Comparative Data Using Generalized Estimating Equations&quot;. Journal of Theoretical Biology <b>218</b>:175-185.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+compar.gee">compar.gee</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
tre = rtree(50)
x = rTrait(n=1,phy=tre)
X = cbind(rep(1,50),x)
y = rbinTrait(n=1,phy=tre, beta=c(-1,0.5), alpha=1 ,X=X)
dat = data.frame(trait01 = y, predictor = x)
fit = phyloglm(trait01~predictor,phy=tre,data=dat,boot=100)
summary(fit)
coef(fit)
vcov(fit)
</code></pre>

<hr>
<h2 id='phyloglm-methods'>Methods for class 'phyloglm'.</h2><span id='topic+print.phyloglm'></span><span id='topic+summary.phyloglm'></span><span id='topic+print.summary.phyloglm'></span><span id='topic+residuals.phyloglm'></span><span id='topic+vcov.phyloglm'></span><span id='topic+nobs.phyloglm'></span><span id='topic+logLik.phyloglm'></span><span id='topic+print.logLik.phyloglm'></span><span id='topic+AIC.phyloglm'></span><span id='topic+AIC.logLik.phyloglm'></span><span id='topic+plot.phyloglm'></span>

<h3>Description</h3>

<p>These are method functions for class 'phyloglm'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phyloglm'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'phyloglm'
summary(object, ...)
## S3 method for class 'phyloglm'
residuals(object,type = c("response"), ...)
## S3 method for class 'phyloglm'
vcov(object, ...)
## S3 method for class 'phyloglm'
nobs(object, ...)
## S3 method for class 'phyloglm'
logLik(object, ...)
## S3 method for class 'phyloglm'
AIC(object, k=2, ...)
## S3 method for class 'phyloglm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phyloglm-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phyloglm"</code>.</p>
</td></tr>
<tr><td><code id="phyloglm-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"phyloglm"</code>.</p>
</td></tr>
<tr><td><code id="phyloglm-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in summary method.</p>
</td></tr>  
<tr><td><code id="phyloglm-methods_+3A_type">type</code></td>
<td>
<p>Currently, only the &quot;response&quot; type is implemented. It returns the raw residuals, that is, the differences between the observed responses and the predicted values. They are phylogenetically correlated.</p>
</td></tr>
<tr><td><code id="phyloglm-methods_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
<tr><td><code id="phyloglm-methods_+3A_...">...</code></td>
<td>
<p>further arguments to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyloglm">phyloglm</a></code>
</p>

<hr>
<h2 id='phyloglmstep'>Stepwise model selection for Phylogenetic Generalized Linear Model</h2><span id='topic+phyloglmstep'></span>

<h3>Description</h3>

<p>Performs stepwise model selection for phylogenetic generalized
linear models, using the criterion -2*log-likelihood + k*npar, where npar 
is the number of estimated parameters and k=2 for the usual AIC.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloglmstep(formula, starting.formula = NULL, data=list(), phy, 
       method = c("logistic_MPLE","logistic_IG10", "logistic_MLE", "poisson_GEE"),
       direction = c("both", "backward", "forward"), trace = 2,
       btol = 10, log.alpha.bound = 4, start.beta=NULL, 
       start.alpha=NULL, boot = 0, full.matrix = TRUE,
       k=2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phyloglmstep_+3A_formula">formula</code></td>
<td>
<p>formula of the full model.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_starting.formula">starting.formula</code></td>
<td>
<p>optional formula of the starting model.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model. If not
found in <code>data</code>, the variables are taken from current environment.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_method">method</code></td>
<td>
<p>The &quot;logistic_IG10&quot; method optimizes a GEE approximation to the penalized likelihood of the logistic regression. &quot;logistic_MPLE&quot; maximizes the penalized likelihood of the logistic regression. In both cases, the penalty is Firth's correction.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_direction">direction</code></td>
<td>
<p>direction for stepwise search, can be <code>both</code>, <code>forward</code>, and <code>backward</code>.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_trace">trace</code></td>
<td>
<p>if positive, information on each searching step is
printed. Larger values may give more detailed information.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_btol">btol</code></td>
<td>
<p>bound on the linear predictor to bound the searching space.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_log.alpha.bound">log.alpha.bound</code></td>
<td>
<p>bound for the log of the parameter alpha.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_start.beta">start.beta</code></td>
<td>
<p>starting values for beta coefficients.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_start.alpha">start.alpha</code></td>
<td>
<p>starting values for alpha (phylogenetic correlation).</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_boot">boot</code></td>
<td>
<p>number of independent bootstrap replicates, <code>0</code> means no bootstrap.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_full.matrix">full.matrix</code></td>
<td>
<p>if <code>TRUE</code>, the full matrix of bootstrap estimates (coefficients and alpha) will be returned.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_k">k</code></td>
<td>
<p>optional weight for the penalty.</p>
</td></tr>
<tr><td><code id="phyloglmstep_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function <code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code class="reqn">k=2</code> corresponds to the usual AIC penalty.
Use <code class="reqn">k=\log(n)</code> for the usual BIC, although it is
unclear how BIC should be defined for phylogenetic regression.
</p>
<p>See <code><a href="#topic+phyloglm">phyloglm</a></code> for details on the possible
phylogenetic methods for the error term, for default bounds on the
phylogenetic signal parameters, or for matching tip labels between the
tree and the data.
</p>


<h3>Value</h3>

<p>A phyloglm object correponding to the best model is returned.
</p>


<h3>Author(s)</h3>

<p>Rutger Vos</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyloglm">phyloglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
tre = rcoal(60)
taxa = sort(tre$tip.label)
b0=0; b1=1;
x1 = rTrait(phy=tre,model="BM",
           parameters=list(ancestral.state=0,sigma2=10))
x2 = rTrait(phy=tre,model="BM",
            parameters=list(ancestral.state=0,sigma2=10))
x3 = rTrait(phy=tre,model="BM",
            parameters=list(ancestral.state=0,sigma2=10))
X = cbind(rep(1,60), x1)
y = rbinTrait(n=1,phy=tre, beta=c(-1,0.5), alpha=1 ,X=X)
dat = data.frame(trait=y[taxa],pred1=x1[taxa],pred2=x2[taxa],pred3=x3[taxa])
fit = phyloglmstep(trait~pred1+pred2+pred3,data=dat,phy=tre,method="logistic_MPLE",direction="both")
summary(fit)
</code></pre>

<hr>
<h2 id='phylolm'>Phylogenetic Linear Model</h2><span id='topic+phylolm'></span>

<h3>Description</h3>

<p>Fits a phylogenetic linear regression model. The likelihood is calculated with an algorithm that is linear in the number of tips in the tree.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylolm(formula, data = list(), phy, model = c("BM", "OUrandomRoot",
       "OUfixedRoot", "lambda", "kappa", "delta", "EB", "trend"),
       lower.bound = NULL, upper.bound = NULL,
       starting.value = NULL, measurement_error = FALSE,
       boot=0,full.matrix = TRUE, save = FALSE, REML = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phylolm_+3A_formula">formula</code></td>
<td>
<p>a model formula.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model. If not
found in <code>data</code>, the variables are taken from current environment.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_model">model</code></td>
<td>
<p>a model for the covariance (see Details).</p>
</td></tr>
<tr><td><code id="phylolm_+3A_lower.bound">lower.bound</code></td>
<td>
<p>optional lower bound for the optimization of the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_upper.bound">upper.bound</code></td>
<td>
<p>optional upper bound for the optimization of the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_starting.value">starting.value</code></td>
<td>
<p>optional starting value for the optimization of the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_measurement_error">measurement_error</code></td>
<td>
<p>a logical value indicating whether there is measurement error <code>sigma2_error</code> (see Details).</p>
</td></tr>
<tr><td><code id="phylolm_+3A_boot">boot</code></td>
<td>
<p>number of independent bootstrap replicates, 0 means no bootstrap.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_full.matrix">full.matrix</code></td>
<td>
<p>if <code>TRUE</code>, the full matrix of bootstrap estimates (coefficients and covariance parameters) will be returned.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_save">save</code></td>
<td>
<p>if <code>TRUE</code>, the simulated bootstrap data will be returned.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_reml">REML</code></td>
<td>
<p>Use ML (default) or REML for estimating the parameters.</p>
</td></tr>
<tr><td><code id="phylolm_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function <code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses an algorithm that is linear in the number of
tips in the tree to calculate the likelihood. Possible phylogenetic
models for the error term are the Brownian motion model (<code>BM</code>), the
Ornstein-Uhlenbeck model with an ancestral state to be estimated at
the root (<code>OUfixedRoot</code>), the Ornstein-Uhlenbeck model with the
ancestral state at the root having the stationary distribution
(<code>OUrandomRoot</code>), Pagel's <code class="reqn">\lambda</code> model
(<code>lambda</code>), Pagel's <code class="reqn">\kappa</code> model (<code>kappa</code>),
Pagel's <code class="reqn">\delta</code> model (<code>delta</code>), the early burst
model (<code>EB</code>), and the Brownian motion model with a trend
(<code>trend</code>).
</p>
<p>Using measurement error means that the covariance matrix is taken
to be <code class="reqn">\sigma^2*V + \sigma^2_{error}*I</code>
where <code class="reqn">V</code> is the phylogenetic covariance matrix from the chosen model,
<code class="reqn">I</code> is the identity matrix, and <code class="reqn">\sigma^2_{error}</code> is the
variance of the measurement error (which could include environmental variability,
sampling error on the species mean, etc.).
</p>
<p>By default, the bounds on the phylogenetic parameters are
<code class="reqn">[10^{-7}/T,50/T]</code> for <code class="reqn">\alpha</code>,
<code class="reqn">[10^{-7},1]</code> for <code class="reqn">\lambda</code>,
<code class="reqn">[10^{-6},1]</code> for <code class="reqn">\kappa</code>,
<code class="reqn">[10^{-5},3]</code> for <code class="reqn">\delta</code> and
<code class="reqn">[-3/T,0]</code> for <code>rate</code>, where <code class="reqn">T</code> is the mean root-to-tip distance.
<code class="reqn">[10^{-16}, 10^{16}]</code> for the ratio <code>sigma2_error</code>/<code>sigma2</code> (if measurement errors is used).
</p>
<p>Bootstrapping can be parallelized using the <code>future</code> package on any future
compatible back-end. For example, run <code>library(future); plan(multiprocess))</code>,
after which bootstrapping will automatically occur in parallel. See
<code><a href="future.html#topic+plan">plan</a></code> for options.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the named vector of coefficients.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>the maximum likelihood estimate of the variance rate <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>sigma2_error</code></td>
<td>
<p>the maximum likelihood estimate of the variance of the measurement errors.</p>
</td></tr>
<tr><td><code>optpar</code></td>
<td>
<p>the optimized value of the phylogenetic correlation parameter (alpha, lambda, kappa, delta or rate).</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the maximum of the log likelihood.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of all parameters of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC value of the model.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix for the regression coefficients, given
the phylogenetic correlation parameter (if any).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>raw residuals</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations (tips in the tree)</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>number of dependent variables</p>
</td></tr>
<tr><td><code>mean.tip.height</code></td>
<td>
<p>mean root-to-tip distance, which can help
choose good starting values for the correlation parameter.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call to the function</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the phylogenetic model for the covariance</p>
</td></tr>
<tr><td><code>bootmean</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap means of the parameters estimated.</p>
</td></tr>
<tr><td><code>bootsd</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap standard deviations of the estimated parameters.</p>
</td></tr>
<tr><td><code>bootconfint95</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap 95% confidence interval.</p>
</td></tr>
<tr><td><code>bootmeansdLog</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) bootstrap mean and standard deviation of the logs of the estimated covariance parameters.</p>
</td></tr>
<tr><td><code>bootnumFailed</code></td>
<td>
<p>(<code>boot &gt; 0</code> only) number of independent bootstrap replicates for which
<code>phylolm</code> failed.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>(<code>boot &gt; 0</code> and <code>full.matrix</code> = <code>TRUE</code> only) matrix of all bootstrap estimates.</p>
</td></tr>
<tr><td><code>bootdata</code></td>
<td>
<p>(<code>boot &gt; 0</code> and <code>save</code> = <code>TRUE</code> only) matrix of all bootstrap data (each column is a dataset).</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>The r^2 for the model.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The adjusted r^2 for the model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The tip labels in the tree are matched to the data names (row names in
the data frame). If no data frame is provided through the argument data,
taxon labels in the tree are matched to taxon labels in the response
variable based on the row names of the response vector, and the taxa are
assumed to come in the same order for all variables in the model.
</p>
<p>For the delta model, the tree is rescaled back to its original height
after each node's distance from the root is raised to the power
delta. This is to provide a stable estimate of the variance parameter
<code class="reqn">\sigma^2</code>. For non-ultrametric trees, the tree is rescaled
to maintain the longest distance from the root to its original value.
</p>
<p>The trend model can only be used with non-ultrametric trees. For this
model, one predictor variable is added to the model whose values are the
distances from the root to every tip of the tree. The estimate of the
coefficent for this variable forms the trend value.
</p>
<p>Pagel's <code class="reqn">\lambda</code> model and measurement error cannot be used together:
the parameters <code class="reqn">\lambda</code>, <code class="reqn">\sigma^2</code> and
<code class="reqn">\sigma^2_{error}</code> are not distinguishable (identifiable) from each other.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>References</h3>

<p>Ho, L. S. T. and Ane, C. 2014.  &quot;A linear-time algorithm for Gaussian and non-Gaussian trait evolution models&quot;. Systematic Biology <b>63</b>(3):397-408.
</p>
<p>Butler, M. A. and King, A. A. 2004. &quot;Phylogenetic comparative analysis:
A modeling approach for adaptive evolution&quot;. The American Naturalist <b>164</b>:683-695.
</p>
<p>Hansen, T. F. 1997. &quot;Stabilizing selection and the comparative analysis
of adaptation&quot;. Evolution <b>51</b>:1341-1351.
</p>
<p>Harmon, L. J. et al. 2010. &quot;Early bursts of body size and shape
evolution are rare in comparative data&quot;. Evolution <b>64</b>:2385-2396.
</p>
<p>Ho, L. S. T. and Ane, C. 2013. &quot;Asymptotic theory with hierarchical
autocorrelation: Ornstein-Uhlenbeck tree models&quot;. The Annals of Statistics <b>41</b>(2):957-981.
</p>
<p>Pagel, M. 1997. &quot;Inferring evolutionary processes from
phylogenies&quot;. Zoologica Scripta <b>26</b>:331-348.
</p>
<p>Pagel, M. 1999. &quot;Inferring the historical patterns of biological
evolution&quot;. Nature <b>401</b>:877-884.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+corBrownian">corBrownian</a></code>, <code><a href="ape.html#topic+corMartins">corMartins</a></code>,
<code><a href="ape.html#topic+corPagel">corPagel</a></code>, <code><a href="geiger.html#topic+fitContinuous">fitContinuous</a></code>, <code><a href="caper.html#topic+pgls">pgls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
tre = rcoal(60)
taxa = sort(tre$tip.label)
b0=0; b1=1;
x &lt;- rTrait(n=1, phy=tre,model="BM",
            parameters=list(ancestral.state=0,sigma2=10))
y &lt;- b0 + b1*x +
     rTrait(n=1,phy=tre,model="lambda",parameters=list(
              ancestral.state=0,sigma2=1,lambda=0.5))
dat = data.frame(trait=y[taxa],pred=x[taxa])
fit = phylolm(trait~pred,data=dat,phy=tre,model="lambda")
summary(fit)

# adding measurement errors and bootstrap
z &lt;- y + rnorm(60,0,1)
dat = data.frame(trait=z[taxa],pred=x[taxa])
fit = phylolm(trait~pred,data=dat,phy=tre,model="BM",measurement_error=TRUE,boot=100)
summary(fit)

</code></pre>

<hr>
<h2 id='phylolm-methods'>Methods for class 'phylolm'.</h2><span id='topic+print.phylolm'></span><span id='topic+summary.phylolm'></span><span id='topic+print.summary.phylolm'></span><span id='topic+residuals.phylolm'></span><span id='topic+predict.phylolm'></span><span id='topic+vcov.phylolm'></span><span id='topic+logLik.phylolm'></span><span id='topic+print.logLik.phylolm'></span><span id='topic+AIC.phylolm'></span><span id='topic+AIC.logLik.phylolm'></span><span id='topic+extractAIC.phylolm'></span><span id='topic+nobs.phylolm'></span><span id='topic+plot.phylolm'></span><span id='topic+confint.phylolm'></span><span id='topic+model.frame.phylolm'></span>

<h3>Description</h3>

<p>These are method functions for class 'phylolm'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylolm'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'phylolm'
summary(object, ...)
## S3 method for class 'phylolm'
nobs(object, ...)
## S3 method for class 'phylolm'
residuals(object,type = c("response"), ...)
## S3 method for class 'phylolm'
predict(object, newdata = NULL, se.fit = FALSE, ...)
## S3 method for class 'phylolm'
vcov(object, ...)
## S3 method for class 'phylolm'
logLik(object, ...)
## S3 method for class 'phylolm'
AIC(object, k=2, ...)
## S3 method for class 'phylolm'
plot(x, ...)
## S3 method for class 'phylolm'
confint(object, parm, level=0.95, ...)
## S3 method for class 'phylolm'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

    
<table role = "presentation">
<tr><td><code id="phylolm-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylolm"</code>.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"phylolm"</code>.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"phylolm"</code>.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in summary method.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_type">type</code></td>
<td>
<p>Currently, only the &quot;response&quot; type is implemented. It returns the raw residuals, that is, the differences between the observed responses and the predicted values. They are phylogenetically correlated.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to provide the predictor values
at which predictions should be made. If omitted, the fitted values are used. Currently, predictions are made for new species whose placement in the tree is unknown. Only their covariate information is used. The prediction for the trend model is not currently implemented.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_se.fit">se.fit</code></td>
<td>
<p>A switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="phylolm-methods_+3A_...">...</code></td>
<td>
<p>further arguments to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylolm">phylolm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(321123)
tre = rcoal(50)
y = rTrait(n=1,phy=tre,model="BM")
fit = phylolm(y~1,phy=tre,model="BM")
summary(fit)
vcov(fit)
</code></pre>

<hr>
<h2 id='phylostep'>Stepwise model selection for Phylogenetic Linear Model</h2><span id='topic+phylostep'></span>

<h3>Description</h3>

<p>Performs stepwise model selection for phylogenetic linear
models, using the criterion -2*log-likelihood + k*npar, where npar is
the number of estimated parameters and k=2 for the usual AIC.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylostep(formula, starting.formula = NULL, keeping.formula = NULL, data = list(), 
       phy, model = c("BM", "OUrandomRoot","OUfixedRoot", 
       "lambda", "kappa", "delta", "EB", "trend"),
       direction = c("both", "backward", "forward"), trace = 2,
       lower.bound = NULL, upper.bound = NULL, 
       starting.value = NULL, k=2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phylostep_+3A_formula">formula</code></td>
<td>
<p>formula of the full model.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_starting.formula">starting.formula</code></td>
<td>
<p>optional formula of the starting model.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_keeping.formula">keeping.formula</code></td>
<td>
<p>optional formula of the keeping model. Covariates of the keeping model are always included in the model.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model. If not
found in <code>data</code>, the variables are taken from current environment.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_model">model</code></td>
<td>
<p>a model for the phylogenetic covariance of residuals.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_direction">direction</code></td>
<td>
<p>direction for stepwise search, can be <code>both</code>, <code>forward</code>, and <code>backward</code>.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_trace">trace</code></td>
<td>
<p>if positive, information on each searching step is
printed. Larger values may give more detailed information.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_lower.bound">lower.bound</code></td>
<td>
<p>optional lower bound for the optimization of the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_upper.bound">upper.bound</code></td>
<td>
<p>optional upper bound for the optimization of the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_starting.value">starting.value</code></td>
<td>
<p>optional starting value for the optimization of
the phylogenetic model parameter.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_k">k</code></td>
<td>
<p>optional weight for the penalty.</p>
</td></tr>
<tr><td><code id="phylostep_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function <code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code class="reqn">k=2</code> corresponds to the usual AIC penalty.
Use <code class="reqn">k=\log(n)</code> for the usual BIC, although it is
unclear how BIC should be defined for phylogenetic regression.
</p>
<p>See <code><a href="#topic+phylolm">phylolm</a></code> for details on the possible
phylogenetic models for the error term, for default bounds on the
phylogenetic signal parameters, or for matching tip labels between the
tree and the data.
</p>


<h3>Value</h3>

<p>A phylolm object correponding to the best model is returned.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho and Cecile Ane</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylolm">phylolm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
tre = rcoal(60)
taxa = sort(tre$tip.label)
b0=0; b1=1;
x1 = rTrait(phy=tre,model="BM",
           parameters=list(ancestral.state=0,sigma2=10))
x2 = rTrait(phy=tre,model="BM",
            parameters=list(ancestral.state=0,sigma2=10))
x3 = rTrait(phy=tre,model="BM",
            parameters=list(ancestral.state=0,sigma2=10))
y &lt;- b0 + b1*x1 + 
     rTrait(n=1,phy=tre,model="BM",parameters=list(
              ancestral.state=0,sigma2=1))
dat = data.frame(trait=y[taxa],pred1=x1[taxa],pred2=x2[taxa],pred3=x3[taxa])
fit = phylostep(trait~pred1+pred2+pred3,data=dat,phy=tre,model="BM",direction="both")
summary(fit)
</code></pre>

<hr>
<h2 id='pruningwise.branching.times'>Calculates internal node ages in
an ultrametric &quot;pruningwise&quot; tree</h2><span id='topic+pruningwise.branching.times'></span>

<h3>Description</h3>

<p>Calculates the branching times, or ages, of all internal nodes in
an ultrametric tree whose internal representation is in &quot;pruningwise&quot; order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruningwise.branching.times(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pruningwise.branching.times_+3A_phy">phy</code></td>
<td>
<p>an ultrametric phylogenetic tree of type phylo with branch
lengths, already in &quot;pruningwise&quot; order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of node ages, with the original internal node names if
those were available in <code>phy</code>, or otherwise named by the node numbers
in <code>phy</code>.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>See Also</h3>

<p><code><a href="#topic+pruningwise.distFromRoot">pruningwise.distFromRoot</a></code>, <code><a href="ape.html#topic+branching.times">branching.times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tre = reorder(rcoal(50),"pruningwise")
pruningwise.branching.times(tre)
</code></pre>

<hr>
<h2 id='pruningwise.distFromRoot'>Calculates node distance from the root in
an &quot;pruningwise&quot; tree</h2><span id='topic+pruningwise.distFromRoot'></span>

<h3>Description</h3>

<p>Calculates the distance from the root to all nodes, in
a tree whose internal representation is in &quot;pruningwise&quot; order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruningwise.distFromRoot(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pruningwise.distFromRoot_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch
lengths, already in &quot;pruningwise&quot; order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of distances, with the original tip labels and internal node names if
internal node names were available, or otherwise named by the node numbers
in <code>phy</code>.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>See Also</h3>

<p><code><a href="#topic+pruningwise.branching.times">pruningwise.branching.times</a></code>, <code><a href="stats.html#topic+cophenetic">cophenetic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tre = reorder(rtree(50),"pruningwise")
pruningwise.distFromRoot(tre)
</code></pre>

<hr>
<h2 id='quartetCF'>Quartet concordance factors across Arabidopsis thaliana</h2><span id='topic+quartetCF'></span>

<h3>Description</h3>

<p>Concordance factors of quartets for 29 A. thaliana accessions and A. lyrata,
obtained from chromosome 4 using MDL to delimit loci
then 
BUCKy on each 4-taxon set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quartetCF)</code></pre>


<h3>Format</h3>

<p>Data frame with 7 variables and 27,405 rows.
Each row corresponds to one 4-taxon set
(choosing 4 taxa out of 30 makes 27,405 combinations).
The first four variables, named 'taxon1' through 'taxon4',
give the names of the 4 taxa in each 4-taxon set.
Variables 5 through 7 are named CF12.34, CF13.24 and CF14.23,
and give the estimated concordance factors of the 3 quartets on
each set of 4 taxa: taxon 1 + taxon 2 versus taxon3 + taxon 4, etc.
These concordance factors are the proportion of loci that have a
given quartet tree.
They were obtained from chromosome 4 using MDL to delimit loci
then BUCKy to estimate quartet concordance factors (CFs).
</p>


<h3>References</h3>

<p>Stenz, Noah W. M., Bret Larget, David A. Baum and Cécile Ané (2015).
Exploring tree-like and non-tree-like patterns using genome sequences:
An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh.
Systematic Biology, <b>64</b>(5):809-823.
</p>
<p>TICR pipeline: github.com/nstenz/TICR
</p>

<hr>
<h2 id='rbinTrait'>Binary trait simulation</h2><span id='topic+rbinTrait'></span>

<h3>Description</h3>

<p>Simulates a binary trait along a phylogeny, according to the model in Ives and Garland (2010).</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbinTrait(n=1, phy, beta, alpha, X = NULL, model = c("LogReg"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbinTrait_+3A_n">n</code></td>
<td>
<p>number of independent replicates.</p>
</td></tr>
<tr><td><code id="rbinTrait_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with brach lengths.</p>
</td></tr>
<tr><td><code id="rbinTrait_+3A_beta">beta</code></td>
<td>
<p>a vector of coefficients for the logistic regression model.</p>
</td></tr>
<tr><td><code id="rbinTrait_+3A_alpha">alpha</code></td>
<td>
<p>the phylogenetic correlation parameter.</p>
</td></tr>
<tr><td><code id="rbinTrait_+3A_x">X</code></td>
<td>
<p>a design matrix with one row for each tip in the phylogenetic tree.</p>
</td></tr>
<tr><td><code id="rbinTrait_+3A_model">model</code></td>
<td>
<p>Currently, only phylogenetic logistic regression is implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n=1</code>, a numeric vector of 0-1 values with names from the
tip labels in the tree. For more than 1 replicate, a matrix with the
tip labels as row names, and one column per replicate.</p>


<h3>Note</h3>

<p>In the absence of a design matrix <code>X</code>, a single intercept is
used. In this case <code>beta</code> should be a vector of length one and
the model reduces to a 2-state Markov process on the tree with
stationary mean <code class="reqn">e^\beta/(1+e^\beta)</code>.
If a design matrix <code>X</code> is provided, the length of <code>beta</code> should be
equal to the number of columns in <code>X</code>.</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho and C. An? </p>


<h3>References</h3>

<p>Ives, A. R. and T. Garland, Jr. 2010. &quot;Phylogenetic logistic regression
for binary dependent variables&quot;. Systematic Biology <b>59</b>:9-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rTrait">rTrait</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tre = rtree(50)
x = rTrait(n=1,phy=tre)
X = cbind(rep(1,50),x)
y = rbinTrait(n=1, phy=tre, beta=c(-1,0.5), alpha=1, X=X)
</code></pre>

<hr>
<h2 id='rTrait'>Continuous trait simulation</h2><span id='topic+rTrait'></span>

<h3>Description</h3>

<p>Simulates a continuous trait along a tree from various phylogenetic models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrait(n=1, phy, model=c("BM","OU","lambda","kappa","delta","EB","trend"),
       parameters = NULL, plot.tree=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrait_+3A_n">n</code></td>
<td>
<p>number of independent replicates</p>
</td></tr>
<tr><td><code id="rTrait_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="rTrait_+3A_model">model</code></td>
<td>
<p>a phylogenetic model. Default is &quot;BM&quot;, for Brownian motion.
Alternatives are &quot;OU&quot;, &quot;lambda&quot;, &quot;kappa&quot;, &quot;delta&quot;, &quot;EB&quot; and &quot;trend&quot;.</p>
</td></tr>
<tr><td><code id="rTrait_+3A_parameters">parameters</code></td>
<td>
<p>List of parameters for the model (see Note).</p>
</td></tr>
<tr><td><code id="rTrait_+3A_plot.tree">plot.tree</code></td>
<td>
<p>If TRUE, the tree with transformed branch lengths
will be shown, except for the OU model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible phylogenetic models are the Brownian motion
model (BM), the Ornstein-Uhlenbeck model (OU),
Pagel's <code class="reqn">\lambda</code> model (lambda), Pagel's <code class="reqn">\kappa</code> model (kappa),
Pagel's <code class="reqn">\delta</code> model (delta), the early burst model (EB), and the
Brownian motion model with a trend (trend).
</p>


<h3>Value</h3>

<p>If <code>n=1</code>, a numeric vector with names from the tip labels in
the tree. For more than 1 replicate, a matrix with the tip labels as
row names, and one column per replicate.</p>


<h3>Note</h3>

<p>The default choice for the parameters are as follows:
<code>ancestral.state=0</code>,
<code>sigma2=1</code>, <code>optimal.value=0</code> for the OU model,
<code>alpha=0</code> for the selection strength in the OU model,
<code>lambda=1</code>, <code>kappa=1</code>, <code>delta=1</code>, <code>rate=0</code> for the
EB model, <code>trend=0</code>. These default choices correspond to the BM model.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho and C. Ane</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+rTraitCont">rTraitCont</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tre = rtree(50)
y = rTrait(n=1, phy=tre, model="OU",
           parameters=list(optimal.value=2,sigma2=1,alpha=0.1))
</code></pre>

<hr>
<h2 id='stepwise.test.tree'>Fits a population tree to data from quartet concordance factors</h2><span id='topic+stepwise.test.tree'></span>

<h3>Description</h3>

<p>From a set of quartet concordance factors obtained from genetic data
(proportion of loci that truly have a given quartet) and from a guide tree,
this functions uses a stepwise search to find the best resolution of that guide tree.
Any unresolved edge corresponds to ancestral panmixia, on which the coalescent process
is assumed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.test.tree(cf, guidetree, search="both", method="PLL", kbest=5,
                   maxiter=100, startT="panmixia", shape.correction=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepwise.test.tree_+3A_cf">cf</code></td>
<td>
<p>data frame containing one row for each 4-taxon set and containing taxon names
in columns 1-4, and concordance factors in columns 5-7.</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_guidetree">guidetree</code></td>
<td>
<p>tree of class phylo on the same taxon set as those in <code>cf</code>,
with branch lengths in coalescent units.</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_search">search</code></td>
<td>
<p>one of &quot;both&quot; (stepwise search both forwards and backwards at each step),
or &quot;heuristic&quot; (heuristic shallow search: not recommended). </p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_method">method</code></td>
<td>
<p>Only &quot;PLL&quot; is implemented. The scoring criterion to rank population trees is the
pseudo log-likelihood (ignored if search=&quot;heuristic&quot;).</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_kbest">kbest</code></td>
<td>
<p>Number of candidate population trees to consider at each step
for the forward and for the backward phase (separately). Use a lower value for faster
but less thorough search.</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. One iteration consists of considering
multiple candidate population trees, using both a forward step and a backward step.</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_startt">startT</code></td>
<td>
<p>starting population tree. One of &quot;panmixia&quot;, &quot;fulltree&quot;, or a numeric
vector of edge numbers to keep resolved. The other edges are collapsed for panmixia.</p>
</td></tr>
<tr><td><code id="stepwise.test.tree_+3A_shape.correction">shape.correction</code></td>
<td>
<p>boolean. If true, the shapes of all Dirichlet distributions
used to test the adequacy of a population tree
are corrected to be greater or equal to 1. This correction avoids Dirichlet densities
going near 0 or 1. It is applied both when the <code class="reqn">\alpha</code> parameter is estimated and
when the outlier p-values are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Nedge</code></td>
<td>
<p>Number of edges kept resolved in the guide tree. Other edges
are collapsed to model ancestral panmixia.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>Indices of edges kept resolved in the guide tree.</p>
</td></tr>
<tr><td><code>notincluded</code></td>
<td>
<p>Indices of edges collapsed in the guide tree, to model ancestral panmixia.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>estimated <code class="reqn">\alpha</code> parameter.</p>
</td></tr>
<tr><td><code>negPseudoLoglik</code></td>
<td>
<p>Negative pseudo log-likelihood of the final estimated population tree.</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>Chi-square statistic, from comparing the counts of outlier p-values
(in <code>outlier.table</code>) to the expected counts.</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>p-value from the chi-square test, obtained from the comparing the <code>X2</code>
value to a chi-square distribution with 3 df.</p>
</td></tr>
<tr><td><code>chisq.conclusion</code></td>
<td>
<p>character string. If the chi-square test is significant, this
statement says if there is an excess (or deficit) of outlier 4-taxon sets.</p>
</td></tr>
<tr><td><code>outlier.table</code></td>
<td>
<p>Table with 2 rows (observed and expected counts) and 4 columns:
number of 4-taxon sets with p-values <code class="reqn">p\leq 0.01</code>,
<code class="reqn">0.01&lt;p\leq 0.05</code>, <code class="reqn">0.05&lt;p\leq 0.10</code>
or <code class="reqn">p&gt;0.10</code>.</p>
</td></tr>
<tr><td><code>outlier.pvalues</code></td>
<td>
<p>Vector of outlier p-values, with as many entries as there
are rows in <code>cf</code>, one for each set of 4 taxa.</p>
</td></tr>
<tr><td><code>cf.exp</code></td>
<td>
<p>Matrix of concordance factors expected from the estimated population tree,
with as many rows as in <code>cf</code> (one row for each 4-taxon set) and 3 columns
(one for each of the 3 possible quartet trees).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cécile Ané</p>


<h3>References</h3>

<p>Stenz, Noah W. M., Bret Larget, David A. Baum and Cécile Ané (2015).
Exploring tree-like and non-tree-like patterns using genome sequences:
An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh.
Systematic Biology, <b>64</b>(5):809-823.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.one.species.tree">test.one.species.tree</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quartetCF)
data(guidetree)
resF &lt;- stepwise.test.tree(quartetCF,guidetree,startT="fulltree") # takes ~ 1 min
resF[1:9]

</code></pre>

<hr>
<h2 id='test.one.species.tree'>Tests the fit of a population tree to quartet concordance factor data</h2><span id='topic+test.one.species.tree'></span>

<h3>Description</h3>

<p>From a set of quartet concordance factors obtained from genetic data
(proportion of loci that truly have a given quartet), this function tests
the adequacy of the coalescent process on a given population tree, where branch
lengths indicate coalescent units.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.one.species.tree(cf, guidetree, prep, edge.keep,
                      plot=TRUE, shape.correction = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.one.species.tree_+3A_cf">cf</code></td>
<td>
<p>data frame containing one row for each 4-taxon set, with taxon names
in columns 1-4 and concordance factors in columns 5-7.</p>
</td></tr>
<tr><td><code id="test.one.species.tree_+3A_guidetree">guidetree</code></td>
<td>
<p>tree of class phylo on the same taxon set as those in <code>cf</code>,
with branch lengths in coalescent units.</p>
</td></tr>
<tr><td><code id="test.one.species.tree_+3A_prep">prep</code></td>
<td>
<p>result of <code>test.tree.preparation(cf,guidetree)</code>.
If the test is repeated multiple times on various resolutions of the guide tree
(see <code>edge.keep</code>), it saves time to do this only once.</p>
</td></tr>
<tr><td><code id="test.one.species.tree_+3A_edge.keep">edge.keep</code></td>
<td>
<p>Indices of edges to keep in the guide tree.
All other edges are collapsed to reflect ancestral panmixia.
In the tested population tree, the collapsed edges have length set to 0.</p>
</td></tr>
<tr><td><code id="test.one.species.tree_+3A_plot">plot</code></td>
<td>
<p>boolean. If TRUE, a number of plots are output.</p>
</td></tr>
<tr><td><code id="test.one.species.tree_+3A_shape.correction">shape.correction</code></td>
<td>
<p>boolean. If TRUE, the shapes of all Dirichlet distributions
are corrected to be greater or equal to 1. This correction avoids Dirichlet densities
going near 0 or 1. It applies when the <code class="reqn">\alpha</code> parameter is estimated and
when the outlier p-values are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>estimated <code class="reqn">\alpha</code> parameter.</p>
</td></tr>
<tr><td><code>negPseudoLoglik</code></td>
<td>
<p>Negative pseudo log-likelihood of the population tree.</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>Chi-square statistic, from comparing the counts of outlier p-values
(in <code>outlier.table</code>) to the expected counts.</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>p-value from the chi-square test, obtained from the comparing the <code>X2</code>
value to a chi-square distribution with 3 df.</p>
</td></tr>
<tr><td><code>chisq.conclusion</code></td>
<td>
<p>character string. If the chi-square test is significant, this
statement says if there is an excess (or deficit) of outlier 4-taxon sets.</p>
</td></tr>
<tr><td><code>outlier.table</code></td>
<td>
<p>Table with 2 rows (observed and expected counts) and 4 columns:
number of 4-taxon sets with p-values <code class="reqn">p\leq 0.01</code>,
<code class="reqn">0.01&lt;p\leq 0.05</code>, <code class="reqn">0.05&lt;p\leq 0.10</code>
or <code class="reqn">p&gt;0.10</code>.</p>
</td></tr>
<tr><td><code>outlier.pvalues</code></td>
<td>
<p>Vector of outlier p-values, with as many entries as there
are rows in <code>cf</code>, one for each set of 4 taxa.</p>
</td></tr>
<tr><td><code>cf.exp</code></td>
<td>
<p>Matrix of concordance factors expected from the estimated population tree,
with as many rows as in <code>cf</code> (one row for each 4-taxon set) and 3 columns
(one for each of the 3 possible quartet trees).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cécile Ané</p>


<h3>References</h3>

<p>Stenz, Noah W. M., Bret Larget, David A. Baum and Cécile Ané (2015).
Exploring tree-like and non-tree-like patterns using genome sequences:
An example using the inbreeding plant species <em>Arabidopsis thaliana</em> (L.) Heynh.
Systematic Biology, <b>64</b>(5):809-823.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepwise.test.tree">stepwise.test.tree</a></code>, <code><a href="#topic+test.tree.preparation">test.tree.preparation</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quartetCF)
data(guidetree)
prelim &lt;- test.tree.preparation(quartetCF,guidetree) # takes 5-10 seconds

# test of panmixia: all edges collapsed, none resolved.
panmixia &lt;- test.one.species.tree(quartetCF,guidetree,prelim,edge.keep=NULL)
panmixia[1:6]

# test of full tree: all internal edges resolved, none collapsed.
Ntaxa = length(guidetree$tip.label)
# indices of internal edges:
internal.edges = which(guidetree$edge[,2] &gt; Ntaxa)
fulltree &lt;- test.one.species.tree(quartetCF,guidetree,prelim,edge.keep=internal.edges)
fulltree[1:6]

# test of a partial tree, some edges (but not all) collapsed
edges2keep &lt;- c(1,2,4,6,7,8,11,14,20,21,23,24,31,34,35,36,38,39,44,47,53)
partialTree &lt;- test.one.species.tree(quartetCF,guidetree,prelim,edge.keep=edges2keep)
partialTree[1:5]
partialTree$outlier.table
# identify taxa most responsible for the extra outlier quartets
outlier.4taxa &lt;- which(partialTree$outlier.pvalues &lt; 0.01)
length(outlier.4taxa) # 483 4-taxon sets with outlier p-value below 0.01
q01 = as.matrix(quartetCF[outlier.4taxa,1:4])
sort(table(as.vector(q01)),decreasing=TRUE)
# So: Cnt_1 and Vind_1 both appear in 239 of these 483 outlier 4-taxon sets.
sum(apply(q01,1,function(x){"Cnt_1" %in% x | "Vind_1" %in% x}))
# 266 outlier 4-taxon sets have either Cnt_1 or Vind_1
sum(apply(q01,1,function(x){"Cnt_1" %in% x &amp; "Vind_1" %in% x}))
# 212 outlier 4-taxon sets have both Cnt_1 and Vind_1

</code></pre>

<hr>
<h2 id='test.tree.preparation'>data structure preparation for testing a population tree</h2><span id='topic+test.tree.preparation'></span>

<h3>Description</h3>

<p>Takes a guide tree and quartet concordance factor data,
and makes preliminary calculations to speed up the test of adequacy
of a population tree with <code><a href="#topic+test.one.species.tree">test.one.species.tree</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.tree.preparation(cf, guidetree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.tree.preparation_+3A_cf">cf</code></td>
<td>
<p>data frame containing one row for each 4-taxon set, with taxon names
in columns 1-4.</p>
</td></tr>
<tr><td><code id="test.tree.preparation_+3A_guidetree">guidetree</code></td>
<td>
<p>tree of class phylo on the same taxon set as those in <code>cf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>quartet2edge</code></td>
<td>
<p>matrix of booleans with as many rows as in <code>cf</code>
(one row for each 4-taxon set) and with as many columns as edges in <code>guidetree</code>.
For a given set of 4 taxa and for edge <code>i</code>, the corresponding entry is true
if the guide tree pruned to the 4 taxa includes edge <code>i</code> as part of its internal edge.</p>
</td></tr>
<tr><td><code>dominant</code></td>
<td>
<p>Vector with as many entries as rows in <code>cf</code>, one for each 4-taxon set.
Entries are 1, 2 or 3 depending on the quartet displayed in the guide tree: 1 for the quartet
12|34 (i.e. taxon1 + taxon2 versus taxon3 + taxon4), 2 for the quartet 13|24 and 3 for the
quartet 14|23.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+test.one.species.tree">test.one.species.tree</a></code>.</p>

<hr>
<h2 id='three.point.compute'>Computations with a (generalized) three-point structured tree</h2><span id='topic+three.point.compute'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">P'V^{-1}Q</code> and the <code class="reqn">\log(\det V)</code> of a (generalized) three-point structured matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>three.point.compute(phy, P, Q = NULL, diagWeight = NULL, 
            check.pruningwise = TRUE, check.names = TRUE, check.precision = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="three.point.compute_+3A_phy">phy</code></td>
<td>
<p>a rooted phylogenetic tree of type phylo with branch
lengths, to represent the 3-point structured matrix <code class="reqn">V_0</code>. Note
that the matrix of interest is <code class="reqn">V = D V_0 D</code>.</p>
</td></tr>
<tr><td><code id="three.point.compute_+3A_p">P</code>, <code id="three.point.compute_+3A_q">Q</code></td>
<td>
<p>two matrices.</p>
</td></tr>
<tr><td><code id="three.point.compute_+3A_diagweight">diagWeight</code></td>
<td>
<p>a vector containing the diagonal elements of the
diagonal matrix <code class="reqn">D</code> if <code class="reqn">V</code> has a generalized 3-point structure:
<code class="reqn">V = D V_0 D</code></p>
</td></tr>
<tr><td><code id="three.point.compute_+3A_check.pruningwise">check.pruningwise</code></td>
<td>
<p>If FALSE, the tree is assumed to be in pruningwise order.</p>
</td></tr>
<tr><td><code id="three.point.compute_+3A_check.names">check.names</code></td>
<td>
<p>if FALSE, the row names of <code>P</code>, <code>Q</code>, and
the names of <code>diagWeight</code> are assumed to be the same as the
labels of the tips in the tree.</p>
</td></tr> 
<tr><td><code id="three.point.compute_+3A_check.precision">check.precision</code></td>
<td>
<p>if FALSE, diagWeight will be allowed to be below Machine epsilon. Recommended to remain TRUE.</p>
</td></tr> 
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>vec11</code></td>
<td>
<p><code class="reqn">1'V^{-1}1</code>.</p>
</td></tr>
<tr><td><code>P1</code></td>
<td>
<p><code class="reqn">P'V^{-1}1</code>.</p>
</td></tr>
<tr><td><code>PP</code></td>
<td>
<p><code class="reqn">P'V^{-1}P</code>.</p>
</td></tr>
<tr><td><code>Q1</code></td>
<td>
<p><code class="reqn">Q'V^{-1}1</code>.</p>
</td></tr>
<tr><td><code>QQ</code></td>
<td>
<p><code class="reqn">Q'V^{-1}Q</code>.</p>
</td></tr>
<tr><td><code>PQ</code></td>
<td>
<p><code class="reqn">P'V^{-1}Q</code>.</p>
</td></tr>
<tr><td><code>logd</code></td>
<td>
<p><code class="reqn">\log(\det V)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The matrix <code class="reqn">V</code> is assumed to be <code class="reqn">V = D V_0 D</code> where <code class="reqn">D</code> is the diagonal
matrix with non-zero diagonal elements in <code>diagWeight</code>, and where
<code class="reqn">V_0</code> is the 3-point structured covariance matrix
determined by <code>phy</code> and its branch lengths. Note that <code class="reqn">D</code> do
not correspond to measurement error terms. 
</p>
<p>The number of rows in <code>P</code> and <code>Q</code> and the length of <code>diagWeight</code> need
to be the same as the number of tips in the tree. When Q = NULL, the
function only returns <code class="reqn">1'V^{-1}1</code>, <code class="reqn">P'V^{-1}1</code> and <code class="reqn">P'V^{-1}P</code>.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho, Robert Lachlan</p>


<h3>References</h3>

<p>Ho, L. S. T. and An?, C. (2014). &quot;A linear-time algorithm for Gaussian and
non-Gaussian trait evolution models&quot;. Systematic Biology <b>63</b>(3):397-408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transf.branch.lengths">transf.branch.lengths</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tre1 = rtree(500)
tre2 = transf.branch.lengths(phy=tre1, model="OUrandomRoot",
                             parameters = list(alpha = 0.5))
Q = rTrait(n=2,tre1)
y = rTrait(n=1,tre1)
P = cbind(1,y)
three.point.compute(tre2$tree,P,Q,tre2$diagWeight)
</code></pre>

<hr>
<h2 id='transf.branch.lengths'>Creates a tree with branch lengths to represent the 3-point structure of a covariance matrix</h2><span id='topic+transf.branch.lengths'></span>

<h3>Description</h3>

<p>Creates a phylogenetic tree with branch lengths and a diagonal matrix to represent a (generalized) 3-point structured covariance matrix from a trait evolution model on a known tree.</p>


<h3>Usage</h3>

<pre><code class='language-R'>transf.branch.lengths(phy, model = c("BM", "OUrandomRoot",
       "OUfixedRoot", "lambda", "kappa", "delta", "EB", "trend"),
       parameters = NULL, check.pruningwise = TRUE,
       check.ultrametric=TRUE, D=NULL, check.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transf.branch.lengths_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of type phylo with branch lengths.</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_model">model</code></td>
<td>
<p>a phylogenetic model. Default is &quot;BM&quot;, for Brownian motion. Alternatives are &quot;OU&quot;, &quot;lambda&quot;, &quot;kappa&quot;, &quot;delta&quot;, &quot;EB&quot; and &quot;trend&quot;.</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_parameters">parameters</code></td>
<td>
<p>List of parameters for the model (see Note).</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_check.pruningwise">check.pruningwise</code></td>
<td>
<p>if FALSE, the tree is assumed to be in pruningwise order.</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_check.ultrametric">check.ultrametric</code></td>
<td>
<p>if FALSE, the tree is assumed to be
ultrametric and <code>D</code> needs to be provided. This is used for the
OU transformations only.</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_d">D</code></td>
<td>
<p>vector of ajustments for the external edge lengths, to make
the tree ultrametric. Used for the OU transformations only.</p>
</td></tr>
<tr><td><code id="transf.branch.lengths_+3A_check.names">check.names</code></td>
<td>
<p><code>D</code> needs to have names that match tip labels
unless check.names=FALSE, in which case the elements in <code>D</code> are
assumed to come in the same order as tip labels in the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible phylogenetic models are the Brownian motion model (BM), the
Ornstein-Uhlenbeck model (OU), Pagel's lambda model (lambda), Pagel's
kappa model (kappa), Pagel's delta model (delta), the early burst model
(EB), and the Brownian motion with a trend (trend). Edge lengths are
unchanged under BM and the trend model.
Under the kappa model, each branch length <code class="reqn">\ell</code> is transformed
to <code class="reqn">\ell^\kappa</code>. 
If the time from the root to a node is <code class="reqn">t</code> in <code>phy</code>,
it is transformed to
<code class="reqn"> T * (t/T)^\delta</code> 
under the delta model, where <code class="reqn">T</code> is the maximum root-to-tip
distance. The transformed tree has the same <code class="reqn">T</code>. 
Under EB, <code class="reqn">t</code> is transformed to 
<code class="reqn">(e^{\mathrm{rate}*t}-1)/\mathrm{rate}</code>, 
which is very close to <code class="reqn">t</code> (i.e. to the BM model)
when <code>rate</code> is close to 0. 
Under the lambda model, the time <code class="reqn">t</code> from the
root to a node is transformed to 
<code class="reqn">\lambda t</code> for an internal node and
is unchanged for a tip. 
Under &quot;OUrandomRoot&quot;, <code class="reqn">t</code> is transformed to 
<code class="reqn">\exp(-2\alpha (T-t))</code>, 
where <code class="reqn">T</code> is now the mean root-to-tip distance. 
Under &quot;OUfixedRroot&quot;, <code class="reqn">t</code> is transformed to 
<code class="reqn">\exp(-2\alpha (T-t))(1-\exp(-2 \alpha t))</code>. 
Under the OU models, <code>diagWeight</code> contains <code class="reqn">\exp(\alpha
  D_i)</code> for tip <code class="reqn">i</code>, where <code class="reqn">D_i</code> is the extra
length added to tip <code class="reqn">i</code> to make the tree ultrametric.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tree</code></td>
<td>
<p>a rooted tree with a root edge and transformed branch lengths.</p>
</td></tr>
<tr><td><code>diagWeight</code></td>
<td>
<p>a vector containing the diagonal elements of the
diagonal matrix  for the generalized 3-point structure.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The default choice for the parameters are as follows: <code>alpha=0</code> for
the selection strength in the OU model, <code>lambda=1</code>, <code>kappa=1</code>,
<code>delta=1</code>, <code>rate=0</code> for the EB model, <code>sigma2_error=0</code> for the variance of measurement errors. These default choices
correspond to the BM model.
</p>
<p>Edges in the output tree are in pruningwise order.
</p>
<p>If <code>model="BM"</code> or <code>model="trend"</code>, the output tree is the same as the
input tree except that the output tree is in pruningwise order.
</p>


<h3>Author(s)</h3>

<p>Lam Si Tung Ho</p>


<h3>References</h3>

<p>Ho, L. S. T. and Ane, C. <em>A linear-time algorithm for Gaussian
and non-Gaussian trait evolution models</em>. Systematic Biology <b>63</b>(3):397-408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+three.point.compute">three.point.compute</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
tre1 = rcoal(10)
tre2 = transf.branch.lengths(phy=tre1, model="OUrandomRoot",
                             parameters = list(alpha=1))
par(mfrow = c(2,1))
plot(tre1)
plot(tre2$tree,root.edge=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
