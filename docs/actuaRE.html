<!DOCTYPE html><html><head><title>Help for package actuaRE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {actuaRE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#actuaRE-package'>
<p>Handling Hierarchically Structured Risk Factors using Random Effects Models</p></a></li>
<li><a href='#.addREs'><p>Add random effects to the data frame</p></a></li>
<li><a href='#adjustIntercept'><p>Adjust the intercept to regain the balance property</p></a></li>
<li><a href='#BalanceProperty'><p>Balance property</p></a></li>
<li><a href='#dataCar'>
<p>data Car</p></a></li>
<li><a href='#findbars'><p>Determine random-effects expressions from a formula</p></a></li>
<li><a href='#fixef'><p>Extract fixed-effects estimates</p></a></li>
<li><a href='#fixef-actuaRE'><p>Extract the fixed-effects estimates from a fitted random effects model</p></a></li>
<li><a href='#hachemeisterLong'><p>Hachemeister Data Set</p></a></li>
<li><a href='#hierCredGLM'><p>Combining the hierarchical credibility model with a GLM (Ohlsson, 2008)</p></a></li>
<li><a href='#hierCredGLM-class'><p>Class &quot;hierCredGLM&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm</p></a></li>
<li><a href='#hierCredibility'><p>Hierarchical credibility model of Jewell</p></a></li>
<li><a href='#hierCredibility-class'><p>Class &quot;hierCredibility&quot; of fitted hierarchical credibility models</p></a></li>
<li><a href='#hierCredTweedie'><p>Combining the hierarchical credibility model with a GLM (Ohlsson, 2008)</p></a></li>
<li><a href='#hierCredTweedie-class'><p>Class &quot;hierCredTweedie&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm</p></a></li>
<li><a href='#is.formula'><p>Formula</p></a></li>
<li><a href='#isNested'><p>Is f1 nested within f2?</p></a></li>
<li><a href='#modular'><p>Modular Functions for Mixed Model Fits</p></a></li>
<li><a href='#nobars'><p>Omit terms separated by vertical bars in a formula</p></a></li>
<li><a href='#NrUnique'><p>Number of unique elements in a vector</p></a></li>
<li><a href='#plotRE'><p>Visualizing the random effect estimates using ggplot2</p></a></li>
<li><a href='#predict.hierCredGLM'><p>Model predictions</p></a></li>
<li><a href='#predict.hierCredibility'><p>Model predictions</p></a></li>
<li><a href='#predict.hierCredTweedie'><p>Model predictions</p></a></li>
<li><a href='#print.BalanceProperty'><p>Print method for an object of class <code>BalanceProperty</code></p></a></li>
<li><a href='#ranef'><p>Extract the modes of the random effects</p></a></li>
<li><a href='#ranef-actuaRE'><p>Extract the random effect estimates from a fitted random effects model</p></a></li>
<li><a href='#tweedieGLMM'><p>Fitting a Tweedie GLMM, using the initial estimates of hierCredTweedie</p></a></li>
<li><a href='#weights-actuaRE'><p>Extract the model weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling Hierarchically Structured Risk Factors using Random
Effects Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Using this package, you can fit a random effects model using either the hierarchical credibility model, a combination of the hierarchical credibility model with a generalized linear model or a Tweedie generalized linear mixed model. See Campo, B.D.C. and Antonio, K. (2023) &lt;<a href="https://doi.org/10.1080%2F03461238.2022.2161413">doi:10.1080/03461238.2022.2161413</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, methods, cplm</td>
</tr>
<tr>
<td>Imports:</td>
<td>statmod, nlme, lme4, magrittr, data.table, ggplot2, knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plyr, insuranceData, actuar, utils, lattice, minqa</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bavodc.github.io/websiteactuaRE/">https://bavodc.github.io/websiteactuaRE/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-20 09:46:37 UTC; u0095171</td>
</tr>
<tr>
<td>Author:</td>
<td>Campo Bavo D.C. [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Campo Bavo D.C. &lt;bavo.decock@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-20 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='actuaRE-package'>
Handling Hierarchically Structured Risk Factors using Random Effects Models
</h2><span id='topic+actuaRE-package'></span><span id='topic+actuaRE'></span>

<h3>Description</h3>

<p>Using this package, you can fit a random effects model using either the hierarchical credibility model, a combination of the hierarchical credibility model with a generalized linear model or a Tweedie generalized linear mixed model. See Campo, B.D.C. and Antonio, K. (2023) &lt;doi:10.1080/03461238.2022.2161413&gt;.
</p>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>
<p>Dannenburg, D. R., Kaas, R. and Goovaerts, M. J. (1996). <em>Practical actuarial credibility models</em>. Amsterdam: IAE (Institute of Actuarial Science and Econometrics of the University of Amsterdam).
</p>
<p>Jewell, W. S. (1975). <em>The use of collateral data in credibility theory: a hierarchical model</em>. Laxenburg: IIASA.
</p>
<p>Ohlsson, E. (2005). Simplified estimation of structure parameters in hierarchical credibility. <em>Presented at the Zurich ASTIN Colloquium</em>.<a href="http://www.actuaries.org/ASTIN/Colloquia/Zurich/Ohlsson.pdf">http://www.actuaries.org/ASTIN/Colloquia/Zurich/Ohlsson.pdf</a>
</p>
<p>Ohlsson, E. (2008). Combining generalized linear models and credibility models in practice. <em>Scandinavian Actuarial Journal</em> <b>2008</b>(4), 301–314.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredibility">hierCredibility</a></code>
<code><a href="#topic+hierCredGLM">hierCredGLM</a></code>
<code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>
<code><a href="#topic+tweedieGLMM">tweedieGLMM</a></code>
<code><a href="#topic+BalanceProperty">BalanceProperty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(actuaRE)
  # Vignette of the package
  vignette(package = "actuaRE")

  # Load data
  data(hachemeisterLong)
  data(dataCar)

  # Hierarchical credibility model of Jewell
  fit = hierCredibility(ratio, weight, cohort, state, hachemeisterLong)

  # Combination of the hierarchical credibility model with a GLM (Ohlsson, 2008)
  fit = hierCredGLM(Y ~ area + (1 | VehicleType / VehicleBody), dataCar, weights = w,
  p = 1.7)

</code></pre>

<hr>
<h2 id='.addREs'>Add random effects to the data frame</h2><span id='topic+.addREs'></span>

<h3>Description</h3>

<p>Internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.addREs(obj, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".addREs_+3A_obj">obj</code></td>
<td>
<p>object with model fit</p>
</td></tr>
<tr><td><code id=".addREs_+3A_newdata">newdata</code></td>
<td>
<p>an object coercible to <code>data.table</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='adjustIntercept'>Adjust the intercept to regain the balance property</h2><span id='topic+adjustIntercept'></span>

<h3>Description</h3>

<p>This function updates the intercept term of the model fit such that the balance property is satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustIntercept(obj, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustIntercept_+3A_obj">obj</code></td>
<td>
<p>an object of type <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="cplm.html#topic+cpglm">cpglm</a></code> or <code><a href="cplm.html#topic+cpglmm">cpglmm</a></code>
containing the model fit.</p>
</td></tr>
<tr><td><code id="adjustIntercept_+3A_data">data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="data.table.html#topic+data.table">data.table</a></code> object that was used to fit the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with the adjusted (fixed effects) coefficients.
</p>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>
<p>Wüthrich, M. V. (2020). Bias regularization in neural network models for general insurance pricing. <em>European actuarial journal</em> <b>10</b>(1), 179–202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(statmod)
datas  = dataCar[1:1e3, ]
Fit    = glm(Y ~ area + gender, data = datas, weights = datas$w, family = tweedie(1.75, 0),
model = TRUE, control = glm.control(epsilon = 1e-4, maxit = 5e2))
w      = weights(Fit, "prior")
y      = Fit$y
sum(w * y) == sum(w * fitted(Fit))
adjFit = adjustIntercept(Fit, datas)
coef(adjFit)
sum(w * y) == sum(w * fitted(adjFit))
</code></pre>

<hr>
<h2 id='BalanceProperty'>Balance property</h2><span id='topic+BalanceProperty'></span>

<h3>Description</h3>

<p>Function to assess whether the balance property holds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BalanceProperty(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BalanceProperty_+3A_obj">obj</code></td>
<td>
<p>an object containing the model fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the slots <code>call</code> (the original call), <code>BalanceProperty</code> (logical indicating whether the balance
property is satisfied) and <code>Alpha</code> (Ratio total observed damage to total predicted damage).
</p>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>
<p>Wüthrich, M. V. (2020). Bias regularization in neural network models for general insurance pricing. <em>European actuarial journal</em> <b>10</b>(1), 179–202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit = hierCredGLM(Y ~ area + (1 | VehicleType / VehicleBody), dataCar, weights = w,
 p = 1.75, epsilon = 1e-6)
BalanceProperty(fit)

</code></pre>

<hr>
<h2 id='dataCar'>
data Car
</h2><span id='topic+dataCar'></span>

<h3>Description</h3>

<p>This data set is taken from the <code><a href="insuranceData.html#topic+dataCar">dataCar</a></code> data set of the <code>insuranceData</code> package and slightly adjusted (see the code in examples for reproducing this data set).
The original data set is based on  one-year vehicle insurance policies taken    out in 2004 or 2005. There are 67566 policies, of which  4589 (6.8%) had at least one claim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataCar)</code></pre>


<h3>Format</h3>

<p>A data frame with 67566 observations on the following 15 variables.
</p>

<dl>
<dt><code>veh_value</code></dt><dd><p>vehicle value, in $10,000s</p>
</dd>
<dt><code>exposure</code></dt><dd><p>0-1</p>
</dd>
<dt><code>clm</code></dt><dd><p>occurrence of claim (0 = no, 1 = yes)</p>
</dd>
<dt><code>numclaims</code></dt><dd><p>number of claims</p>
</dd>
<dt><code>claimcst0</code></dt><dd><p>claim amount (0 if no claim)</p>
</dd>
<dt><code>veh_body</code></dt><dd><p>vehicle body, coded as <code>BUS</code> <code>CONVT</code> <code>COUPE</code> <code>HBACK</code> <code>HDTOP</code> <code>MCARA</code> <code>MIBUS</code> <code>PANVN</code> <code>RDSTR</code> <code>SEDAN</code> <code>STNWG</code> <code>TRUCK</code> <code>UTE</code></p>
</dd>
<dt><code>veh_age</code></dt><dd><p>1 (youngest), 2, 3, 4</p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>F</code> <code>M</code></p>
</dd>
<dt><code>area</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code></p>
</dd>
<dt><code>agecat</code></dt><dd><p>1 (youngest), 2, 3, 4, 5, 6</p>
</dd>
<dt><code>X_OBSTAT_</code></dt><dd><p>a factor with levels <code>01101    0    0    0</code></p>
</dd>
<dt><code>Y</code></dt><dd><p>the loss ratio, defined as the number of claims divided by the exposure</p>
</dd>
<dt><code>w</code></dt><dd><p>the exposure, identical to <code>exposure</code></p>
</dd>
<dt><code>VehicleType</code></dt><dd><p>type of vehicle, <code>common vehicle</code> or <code>uncommon vehicle</code></p>
</dd>
<dt><code>VehicleBody</code></dt><dd><p>vehicle body, identical to <code>veh_body</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Adjusted data set <code>dataCar</code>, where we removed claims with a loss ratio larger than 1 000 000. In addition, we summed the exposure per vehicle body and removed those where
the summed exposure was less than 100. Hereby, we ensure that there is sufficient exposure for each vehicle body category.</p>


<h3>Source</h3>

<p>http://www.acst.mq.edu.au/GLMsforInsuranceData</p>


<h3>References</h3>

<p>De Jong P., Heller G.Z. (2008), Generalized linear models for insurance data,
Cambridge University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # How to construct the data set using the original dataCar data set from the insuranceData package
  library(plyr)
  library(magrittr)
  data("dataCar", package = "insuranceData")
  dataCar$Y = with(dataCar, claimcst0 / exposure)
  dataCar$w = dataCar$exposure
  dataCar   = dataCar[which(dataCar$Y &lt; 1e6), ]
  Yw = ddply(dataCar, .(veh_body), function(x) c(crossprod(x$Y, x$w) / sum(x$w), sum(x$w)))
  dataCar = dataCar[!dataCar$veh_body %in% Yw[Yw$V2 &lt; 1e2, "veh_body"], ]
  dataCar$veh_body %&lt;&gt;% droplevels()
  dataCar$VehicleType = sapply(tolower(dataCar$veh_body), function(x) {
    if(x %in% c("sedan", "ute", "hback"))
      "Common vehicle"
    else
      "Uncommon vehicle"
  })
  dataCar$VehicleBody = dataCar$veh_body
</code></pre>

<hr>
<h2 id='findbars'>Determine random-effects expressions from a formula</h2><span id='topic+findbars'></span>

<h3>Description</h3>

<p>From the right hand side of a formula for a mixed-effects
model, determine the pairs of expressions that are
separated by the vertical bar operator.  Also expand the
slash operator in grouping factor expressions and expand
terms with the double vertical bar operator into separate,
independent random effect terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  findbars(term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findbars_+3A_term">term</code></td>
<td>
<p>a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pairs of expressions that were separated by vertical bars
</p>


<h3>Note</h3>

<p>This function is called recursively on individual terms
in the model, which is why the argument is called
<code>term</code> and not a name like <code>form</code>, indicating a
formula.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>Other utilities: <code><a href="lme4.html#topic+mkRespMod">mkRespMod</a></code>,
<code><a href="lme4.html#topic+mkReTrms">mkReTrms</a></code>, <code><a href="lme4.html#topic+nlformula">nlformula</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="lme4.html#topic+subbars">subbars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  findbars(f1 &lt;- Reaction ~ Days + (Days | Subject))
  ## =&gt; list( Days | Subject )
  ## These two are equivalent:% tests in ../inst/tests/test-doubleVertNotation.R
  findbars(y ~ Days + (1 | Subject) + (0 + Days | Subject))
  findbars(y ~ Days + (Days || Subject))
  ## =&gt; list of length 2:  list ( 1 | Subject ,  0 + Days | Subject)
  findbars(~ 1 + (1 | batch / cask))
  ## =&gt; list of length 2:  list ( 1 | cask:batch ,  1 | batch)
  
</code></pre>

<hr>
<h2 id='fixef'>Extract fixed-effects estimates</h2><span id='topic+fixed.effects'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>Extract the fixed-effects estimates
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>any fitted model object from which fixed
effects estimates can be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the fixed-effects parameters
from a fitted model.
</p>


<h3>Value</h3>

<p>a named, numeric vector of fixed-effects estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(lme4)
  fixef(lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy))
  fm2 &lt;- lmer(Reaction ~ Days + Days2 + (1|Subject),
              data=transform(sleepstudy,Days2=Days))
  fixef(fm2,add.dropped=TRUE)
  ## first two parameters are the same ...
  stopifnot(all.equal(fixef(fm2,add.dropped=TRUE)[1:2],
                      fixef(fm2)))
  
</code></pre>

<hr>
<h2 id='fixef-actuaRE'>Extract the fixed-effects estimates from a fitted random effects model</h2><span id='topic+fixef-actuaRE'></span><span id='topic+fixef.hierCredGLM'></span><span id='topic+fixef.hierCredTweedie'></span>

<h3>Description</h3>

<p>A generic function to extract the fixed effects (i.e. the company-specific effects) estimates from a fitted random effects model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredGLM'
fixef(object, ...)

## S3 method for class 'hierCredTweedie'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef-actuaRE_+3A_object">object</code></td>
<td>
<p>an object of type <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> or <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
<tr><td><code id="fixef-actuaRE_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named, numeric vector of fixed-effects estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit = hierCredGLM(Y ~ area + (1 | VehicleType / VehicleBody), dataCar,
weights = w, p = 1.75, epsilon = 1e-6)
fixef(fit)

</code></pre>

<hr>
<h2 id='hachemeisterLong'>Hachemeister Data Set</h2><span id='topic+hachemeisterLong'></span>

<h3>Description</h3>

<p>Long format of the Hachemeister (1975) data set giving average claim amounts in private passenger bodily injury insurance. We have data of five U.S. states over 12 quarters between July 1970 and June 1973
and we have the corresponding number of claims. To obtain a hierarchical structure, we created an artificial variable <code>cohort</code>. With this, we created a hierarchical multi-level factor, with <code>cohort</code>
as the first hierarchical level and <code>state</code> as the second hierarchical level, nested within <code>cohort</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hachemeisterLong</code></pre>


<h3>Format</h3>

<p>A data.frame with 60 rows and the following 5 columns:
</p>

<dl>
<dt><code>cohort</code></dt><dd><p>artificially created variable;</p>
</dd>
<dt><code>state</code></dt><dd><p>the state number;</p>
</dd>
<dt><code>time</code></dt><dd><p>time variable (quarter of the observation);</p>
</dd>
<dt><code>ratio</code></dt><dd><p>the average claim amount;</p>
</dd>
<dt><code>weight</code></dt><dd><p>the corresponding number of claims.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hachemeister, C. A. (1975), <em>Credibility for regression models with application to trend</em>, Proceedings of the Berkeley Actuarial Research Conference on Credibility, Academic Press.
</p>

<hr>
<h2 id='hierCredGLM'>Combining the hierarchical credibility model with a GLM (Ohlsson, 2008)</h2><span id='topic+hierCredGLM'></span>

<h3>Description</h3>

<p>Fit a random effects model using Ohlsson's methodology. In this function you explicitly specify the power parameter p.
See <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code> when you also want to estimate the p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierCredGLM(
  formula,
  data,
  weights,
  p = 1.5,
  link.power = 0,
  muHatGLM = TRUE,
  epsilon = 1e-04,
  maxiter = 500,
  maxiterGLM = 500,
  verbose = FALSE,
  returnData = TRUE,
  balanceProperty = TRUE,
  y = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredGLM_+3A_formula">formula</code></td>
<td>
<p>object of type <code><a href="stats.html#topic+formula">formula</a></code> that specifies which model should be fitted. Syntax is the same as for
<code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code>. For example, <code>Yijkt ~ x1 + x2 + (1 | Industry / Branch)</code>.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_data">data</code></td>
<td>
<p>an object that is coercible by <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, containing the variables in the model.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_weights">weights</code></td>
<td>
<p>variable name of the exposure weight.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_p">p</code></td>
<td>
<p>the value for the power parameter of the Tweedie distribution, which is passed to <code><a href="statmod.html#topic+tweedie">tweedie</a></code>. Default is <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_link.power">link.power</code></td>
<td>
<p>index of power link function, which is passed to <code><a href="statmod.html#topic+tweedie">tweedie</a></code>. <code>link.power = 0</code> produces a log-link.
Defaults to the canonical link, which is <code>1 - p</code>.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_muhatglm">muHatGLM</code></td>
<td>
<p>indicates which estimate has to be used in the algorithm for the intercept term. Default is <code>TRUE</code>,
which used the intercept as estimated by the GLM. If <code>FALSE</code>, the estimate of the hierarchical credibility model is used.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">\epsilon</code>; the iterations converge when 7
<code class="reqn">||\theta[k] - \theta[k - 1]||^2[[2]]/||\theta[k - 1]||^2[[2]] &lt; \epsilon</code>. Here, <code class="reqn">\theta[k]</code> is the parameter vector at the <code class="reqn">k^{th}</code> iteration.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_maxiterglm">maxiterGLM</code></td>
<td>
<p>maximum number of iterations when fitting the GLM part. Passed to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if output should be produced during the algorithm.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_returndata">returnData</code></td>
<td>
<p>logical indicating if input data has to be returned.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_balanceproperty">balanceProperty</code></td>
<td>
<p>logical indicating if the balance property should be satisfied.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_y">y</code></td>
<td>
<p>logical indicating whether the response vector should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="hierCredGLM_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>glm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>hierCredGLM</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>HierarchicalResults</code></td>
<td>
<p>results of the hierarchical credibility model.</p>
</td></tr>
<tr><td><code>fitGLM</code></td>
<td>
<p>the results from fitting the GLM part.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code>Converged</code></td>
<td>
<p>logical indicating whether the algorithm converged.</p>
</td></tr>
<tr><td><code>LevelsCov</code></td>
<td>
<p>object that summarizes the unique levels of each of the contract-specific covariates.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights (exposure) initially supplied.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>
<p>Ohlsson, E. (2008). Combining generalized linear models and credibility models in practice. <em>Scandinavian Actuarial Journal</em> <b>2008</b>(4), 301–314.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredGLM-class">hierCredGLM-class</a></code>, <code><a href="#topic+fitted.hierCredGLM">fitted.hierCredGLM</a></code>, <code><a href="#topic+predict.hierCredGLM">predict.hierCredGLM</a></code>, <code><a href="#topic+ranef-actuaRE">ranef-actuaRE</a></code>,
<code><a href="#topic+weights-actuaRE">weights-actuaRE</a></code>, <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>, <code><a href="#topic+plotRE">plotRE</a></code>,
<code><a href="#topic+adjustIntercept">adjustIntercept</a></code>, <code><a href="#topic+BalanceProperty">BalanceProperty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataCar")
fit = hierCredGLM(Y ~ area + (1 | VehicleType / VehicleBody), dataCar, weights = w,
p = 1.7)
fit
summary(fit)
ranef(fit)
fixef(fit)

</code></pre>

<hr>
<h2 id='hierCredGLM-class'>Class &quot;hierCredGLM&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm</h2><span id='topic+hierCredGLM-class'></span><span id='topic+print.hierCredGLM'></span><span id='topic+summary.hierCredGLM'></span><span id='topic+fitted.hierCredGLM'></span>

<h3>Description</h3>

<p>Class &quot;hierCredGLM&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredGLM'
print(x, ...)

## S3 method for class 'hierCredGLM'
summary(object, ...)

## S3 method for class 'hierCredGLM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredGLM-class_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredGLM">hierCredGLM</a></code></p>
</td></tr>
<tr><td><code id="hierCredGLM-class_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="hierCredGLM-class_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredGLM">hierCredGLM</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> returns an object of class <code>hierCredGLM</code>, which has the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>HierarchicalResults</code></td>
<td>
<p>results of the hierarchical credibility model.</p>
</td></tr>
<tr><td><code>fitGLM</code></td>
<td>
<p>the results from fitting the GLM part.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code>Converged</code></td>
<td>
<p>logical indicating whether the algorithm converged.</p>
</td></tr>
<tr><td><code>LevelsCov</code></td>
<td>
<p>object that summarizes the unique levels of each of the contract-specific covariates.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights (exposure) initially supplied.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>S3 methods</h3>


<dl>
<dt><code>print</code>:</dt><dd><p>Prints the <code>call</code>, the estimated variance parameters, the unique number of categories
of the hierarchical MLF and the output of the GLM part. The <code>...</code> argument is currently ignored. Returns an
invisible copy of the original object.</p>
</dd>
<dt><code>summary</code>:</dt><dd><p>In addition to the output of the <code>print.hierCredGLM</code> function, the <code>summary</code> function
also prints the random effect estimates and a summary of the GLM (see <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>). Returns an
invisible copy of the original object.</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Returns the fitted values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+hierCredGLM">hierCredGLM</a></code>
</p>

<hr>
<h2 id='hierCredibility'>Hierarchical credibility model of Jewell</h2><span id='topic+hierCredibility'></span>

<h3>Description</h3>

<p>Fit a random effects model, without contract-specific risk factors,  using the hierarchical credibility model of Jewell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierCredibility(
  Yijkt,
  wijkt,
  sector,
  group,
  data,
  muHat = NULL,
  type = c("additive", "multiplicative"),
  returnData = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredibility_+3A_yijkt">Yijkt</code></td>
<td>
<p>variable name of the response variable (the loss cost within actuarial applications).</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_wijkt">wijkt</code></td>
<td>
<p>variable name of the exposure weight.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_sector">sector</code></td>
<td>
<p>variable name of the first hierarchical level.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_group">group</code></td>
<td>
<p>variable name of the second hierarchical level that is nested within the first hierarchical level.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_data">data</code></td>
<td>
<p>an object that is coercible by <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, containing the variables in the model.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_muhat">muHat</code></td>
<td>
<p>estimate for the intercept term. Default is <code>NULL</code> and in this case, the estimator as given in Ohlsson (2005) is used.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_type">type</code></td>
<td>
<p>specifies whether the additive (Dannenburg, 1996) or multiplicative (Ohlsson, 2005) formulation of the hierarchical credibility model is used. Default is additive.</p>
</td></tr>
<tr><td><code id="hierCredibility_+3A_returndata">returnData</code></td>
<td>
<p>Logical, indicates whether the data object has to be returned. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>hierCredibility</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Whether additive or multiplicative hierarchical credibility model is used.</p>
</td></tr>
<tr><td><code>Variances</code></td>
<td>
<p>The estimated variance components. <code>s2</code> is the estimated variance of the individual contracts,
<code>tausq</code> the estimate of <code class="reqn">Var(V[j])</code> and <code>nusq</code> is the estimate of <code class="reqn">Var(V[jk])</code>.</p>
</td></tr>
<tr><td><code>Means</code></td>
<td>
<p>The estimated averages at the portfolio level (intercept term <code class="reqn">\mu</code>), at the first
hierarchical level (<code class="reqn">bar(Y)[\%.\% j \%.\% \%.\%]^z</code>) and at the second hierarchical level (<code class="reqn">bar(Y)[\%.\% jk \%.\%]</code>).</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>The weights at the first hierarchical level <code class="reqn">z[j\%.\%]</code> and at the second hierarchical level <code class="reqn">w[\%.\%jk\%.\%]</code>.</p>
</td></tr>
<tr><td><code>Credibility</code></td>
<td>
<p>The credibility weights at the first hierarchical level <code class="reqn">q[j\%.\%]</code> and at the second hierarchical level <code class="reqn">z[jk]</code>.</p>
</td></tr>
<tr><td><code>Premiums</code></td>
<td>
<p>The overall expectation <code class="reqn">widehat(\mu)</code>, sector expectation <code class="reqn">widehat(V)[j]</code> and group expectation <code class="reqn">widehat(V)[jk]</code>.</p>
</td></tr>
<tr><td><code>Relativity</code></td>
<td>
<p>The estimated random effects <code class="reqn">widehat(U)[j]</code> and <code class="reqn">widehat(U)[jk]</code> of the sector and group, respectively.</p>
</td></tr>
<tr><td><code>RawResults</code></td>
<td>
<p>Objects of type <code>data.table</code> with all intermediate results.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>
<p>Dannenburg, D. R., Kaas, R. and Goovaerts, M. J. (1996). <em>Practical actuarial credibility models</em>. Amsterdam: IAE (Institute of Actuarial Science and Econometrics of the University of Amsterdam).
</p>
<p>Jewell, W. S. (1975). <em>The use of collateral data in credibility theory: a hierarchical model</em>. Laxenburg: IIASA.
</p>
<p>Ohlsson, E. (2005). Simplified estimation of structure parameters in hierarchical credibility. <em>Presented at the Zurich ASTIN Colloquium</em>.<a href="http://www.actuaries.org/ASTIN/Colloquia/Zurich/Ohlsson.pdf">http://www.actuaries.org/ASTIN/Colloquia/Zurich/Ohlsson.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredibility-class">hierCredibility-class</a></code>, <code><a href="#topic+fitted.hierCredibility">fitted.hierCredibility</a></code>, <code><a href="#topic+predict.hierCredibility">predict.hierCredibility</a></code>, <code><a href="#topic+ranef-actuaRE">ranef-actuaRE</a></code>,
<code><a href="#topic+weights-actuaRE">weights-actuaRE</a></code>, <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code>, <code><a href="cplm.html#topic+cpglm">cpglm</a></code>, <code><a href="#topic+plotRE">plotRE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(actuar)
library(actuaRE)
data("hachemeister", package = "actuar")
Df = as.data.frame(hachemeister)
X  = as.data.frame(cbind(cohort = c(1, 2, 1, 2, 2), hachemeister))
Df = reshape(X, idvar = "state", varying = list(paste0("ratio.", 1:12),
 paste0("weight.", 1:12)), direction = "long")
fitActuar  = cm(~ cohort + cohort:state, data = X, ratios = ratio.1:ratio.12,
weights = weight.1:weight.12, method = "Ohlsson")
fitActuaRE = hierCredibility(ratio.1, weight.1, cohort, state, Df)
summary(fitActuar)
summary(fitActuaRE)
</code></pre>

<hr>
<h2 id='hierCredibility-class'>Class &quot;hierCredibility&quot; of fitted hierarchical credibility models</h2><span id='topic+hierCredibility-class'></span><span id='topic+print.hierCredibility'></span><span id='topic+summary.hierCredibility'></span><span id='topic+fitted.hierCredibility'></span>

<h3>Description</h3>

<p>Class &quot;hierCredibility&quot; of fitted hierarchical credibility models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredibility'
print(x, ...)

## S3 method for class 'hierCredibility'
summary(object, ...)

## S3 method for class 'hierCredibility'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredibility-class_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredibility">hierCredibility</a></code></p>
</td></tr>
<tr><td><code id="hierCredibility-class_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="hierCredibility-class_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredibility">hierCredibility</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code><a href="#topic+hierCredibility">hierCredibility</a></code> returns an object of class <code>hierCredibility</code>, which has the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Whether additive or multiplicative hierarchical credibility model is used.</p>
</td></tr>
<tr><td><code>Variances</code></td>
<td>
<p>The estimated variance components. <code>s2</code> is the estimated variance of the individual contracts,
<code>tausq</code> the estimate of <code class="reqn">Var(V[j])</code> and <code>nusq</code> is the estimate of <code class="reqn">Var(V[jk])</code>.</p>
</td></tr>
<tr><td><code>Means</code></td>
<td>
<p>The estimated averages at the portfolio level (intercept term <code class="reqn">\mu</code>), at the first
hierarchical level (<code class="reqn">bar(Y)[\%.\% j \%.\% \%.\%]^z</code>) and at the second hierarchical level (<code class="reqn">bar(Y)[\%.\% jk \%.\%]</code>).</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>The weights at the first hierarchical level <code class="reqn">z[j\%.\%]</code> and at the second hierarchical level <code class="reqn">w[\%.\%jk\%.\%]</code>.</p>
</td></tr>
<tr><td><code>Credibility</code></td>
<td>
<p>The credibility weights at the first hierarchical level <code class="reqn">q[j\%.\%]</code> and at the second hierarchical level <code class="reqn">z[jk]</code>.</p>
</td></tr>
<tr><td><code>Premiums</code></td>
<td>
<p>The overall expectation <code class="reqn">widehat(\mu)</code>, sector expectation <code class="reqn">widehat(V)[j]</code> and group expectation <code class="reqn">widehat(V)[jk]</code>.</p>
</td></tr>
<tr><td><code>Relativity</code></td>
<td>
<p>The estimated random effects <code class="reqn">widehat(U)[j]</code> and <code class="reqn">widehat(U)[jk]</code> of the sector and group, respectively.</p>
</td></tr>
<tr><td><code>RawResults</code></td>
<td>
<p>Objects of type <code>data.table</code> with all intermediate results.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
</table>


<h3>S3 methods</h3>


<dl>
<dt><code>print</code>:</dt><dd><p>Prints the <code>call</code>, the estimated variance parameters and the unique number of categories
of the hierarchical MLF. The <code>...</code> argument is currently ignored. Returns an invisible copy of the original
object.</p>
</dd>
<dt><code>summary</code>:</dt><dd><p>In addition to the output of the <code>print.hierCredibility</code> function, the <code>summary</code> function
prints the random effect estimates as well. Returns an invisible copy of the original object.</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Returns the fitted values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+hierCredibility">hierCredibility</a></code>
</p>

<hr>
<h2 id='hierCredTweedie'>Combining the hierarchical credibility model with a GLM (Ohlsson, 2008)</h2><span id='topic+hierCredTweedie'></span>

<h3>Description</h3>

<p>Fit a random effects model using Ohlsson's methodology. In this function you estimate the power parameter p. See <code>hierCredGLM</code> when
you want fix p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierCredTweedie(
  formula,
  data,
  weights,
  muHatGLM = TRUE,
  epsilon = 1e-04,
  maxiter = 500,
  verbose = FALSE,
  returnData = TRUE,
  cpglmControl = list(bound.p = c(1.01, 1.99)),
  balanceProperty = TRUE,
  optimizer = "bobyqa",
  y = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredTweedie_+3A_formula">formula</code></td>
<td>
<p>object of type <code><a href="stats.html#topic+formula">formula</a></code> that specifies which model should be fitted. Syntax is the same as for
<code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code>. For example, <code>Yijkt ~ x1 + x2 + (1 | Industry / Branch)</code>.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_data">data</code></td>
<td>
<p>an object that is coercible by <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, containing the variables in the model.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_weights">weights</code></td>
<td>
<p>variable name of the exposure weight.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_muhatglm">muHatGLM</code></td>
<td>
<p>indicates which estimate has to be used in the algorithm for the intercept term. Default is <code>TRUE</code>,
which used the intercept as estimated by the GLM. If <code>FALSE</code>, the estimate of the hierarchical credibility model is used.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">\epsilon</code>; the iterations converge when
<code class="reqn">||\theta[k] - \theta[k - 1]||^2[[2]]/||\theta[k - 1]||^2[[2]] &lt; \epsilon</code>. Here, <code class="reqn">\theta[k]</code> is the parameter vector at the <code class="reqn">k^{th}</code> iteration.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if output should be produced during the algorithm.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_returndata">returnData</code></td>
<td>
<p>logical indicating if input data has to be returned.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_cpglmcontrol">cpglmControl</code></td>
<td>
<p>a list of parameters to control the fitting process in the GLM part. By default,
<code>cpglmControl = list(bound.p = c(1.01, 1.99))</code> which restricts the range of the power parameter p to [1.01, 1.99] in the fitting
process. This list is passed to <code><a href="cplm.html#topic+cpglm">cpglm</a></code>.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_balanceproperty">balanceProperty</code></td>
<td>
<p>logical indicating if the balance property should be satisfied.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_optimizer">optimizer</code></td>
<td>
<p>a character string that determines which optimization routine is to be used in estimating the index and the dispersion parameters.
Possible choices are <code>"nlminb"</code> (the default, see <code><a href="stats.html#topic+nlminb">nlminb</a></code>), <code>"bobyqa"</code> (<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>) and <code>"L-BFGS-B"</code> (<code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_y">y</code></td>
<td>
<p>logical indicating whether the response vector should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="hierCredTweedie_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="cplm.html#topic+cpglm">cpglm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When estimating the GLM part, this function uses the <code><a href="cplm.html#topic+cpglm">cpglm</a></code> function from the <code>cplm</code> package.
</p>


<h3>Value</h3>

<p>An object of type <code>hierCredTweedie</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>HierarchicalResults</code></td>
<td>
<p>results of the hierarchical credibility model.</p>
</td></tr>
<tr><td><code>fitGLM</code></td>
<td>
<p>the results from fitting the GLM part.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code>Converged</code></td>
<td>
<p>logical indicating whether the algorithm converged.</p>
</td></tr>
<tr><td><code>LevelsCov</code></td>
<td>
<p>object that summarizes the unique levels of each of the contract-specific covariates.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights (exposure) initially supplied.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ohlsson, E. (2008). Combining generalized linear models and credibility models in practice. <em>Scandinavian Actuarial Journal</em> <b>2008</b>(4), 301–314.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredTweedie-class">hierCredTweedie-class</a></code>, <code><a href="#topic+fitted.hierCredTweedie">fitted.hierCredTweedie</a></code>, <code><a href="#topic+predict.hierCredTweedie">predict.hierCredTweedie</a></code>, <code><a href="#topic+ranef-actuaRE">ranef-actuaRE</a></code>,
<code><a href="#topic+weights-actuaRE">weights-actuaRE</a></code>, <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code>, <code><a href="cplm.html#topic+cpglm">cpglm</a></code>, <code><a href="#topic+plotRE">plotRE</a></code>,
<code><a href="#topic+adjustIntercept">adjustIntercept</a></code>, <code><a href="#topic+BalanceProperty">BalanceProperty</a></code>
@references   Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataCar")
fit = hierCredTweedie(Y ~ area + (1 | VehicleType / VehicleBody), dataCar,
weights = w, epsilon = 1e-6)
fit
summary(fit)
ranef(fit)
fixef(fit)

</code></pre>

<hr>
<h2 id='hierCredTweedie-class'>Class &quot;hierCredTweedie&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm</h2><span id='topic+hierCredTweedie-class'></span><span id='topic+print.hierCredTweedie'></span><span id='topic+summary.hierCredTweedie'></span><span id='topic+fitted.hierCredTweedie'></span>

<h3>Description</h3>

<p>Class &quot;hierCredTweedie&quot; of fitted random effects models estimated with Ohlsson's GLMC algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredTweedie'
print(x, ...)

## S3 method for class 'hierCredTweedie'
summary(object, ...)

## S3 method for class 'hierCredTweedie'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierCredTweedie-class_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
<tr><td><code id="hierCredTweedie-class_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="hierCredTweedie-class_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> returns an object of class <code>hierCredGLM</code>, which has the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>HierarchicalResults</code></td>
<td>
<p>results of the hierarchical credibility model.</p>
</td></tr>
<tr><td><code>fitGLM</code></td>
<td>
<p>the results from fitting the GLM part.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code>Converged</code></td>
<td>
<p>logical indicating whether the algorithm converged.</p>
</td></tr>
<tr><td><code>LevelsCov</code></td>
<td>
<p>object that summarizes the unique levels of each of the contract-specific covariates.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, resulting from the model fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights (exposure) initially supplied.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>S3 methods</h3>


<dl>
<dt><code>print</code>:</dt><dd><p>Prints the <code>call</code>, the estimated variance parameters, the unique number of categories
of the hierarchical MLF and the output of the GLM part. The <code>...</code> argument is currently ignored. Returns an
invisible copy of the original object.</p>
</dd>
<dt><code>summary</code>:</dt><dd><p>In addition to the output of the <code>print.hierCredTweedie</code> function, the <code>summary</code> function
also prints the random effect estimates and a summary of the GLM (see <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>). Returns an
invisible copy of the original object.</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Returns the fitted values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>
</p>

<hr>
<h2 id='is.formula'>Formula</h2><span id='topic+is.formula'></span>

<h3>Description</h3>

<p>Checks if the object is of the type formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.formula_+3A_x">x</code></td>
<td>
<p>the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if the object is a formula or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = formula(y ~ x)
is.formula(f)
</code></pre>

<hr>
<h2 id='isNested'>Is f1 nested within f2?</h2><span id='topic+isNested'></span>

<h3>Description</h3>

<p>Does every level of f1 occur in conjunction with exactly
one level of f2? The function is based on converting a
triplet sparse matrix to a compressed column-oriented
form in which the nesting can be quickly evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isNested(f1, f2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNested_+3A_f1">f1</code></td>
<td>
<p>factor 1</p>
</td></tr>
<tr><td><code id="isNested_+3A_f2">f2</code></td>
<td>
<p>factor 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if factor 1 is nested within factor 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(lme4)
  with(Pastes, isNested(cask, batch))   ## =&gt; FALSE
  with(Pastes, isNested(sample, batch))  ## =&gt; TRUE
</code></pre>

<hr>
<h2 id='modular'>Modular Functions for Mixed Model Fits</h2><span id='topic+glFormula'></span>

<h3>Description</h3>

<p>Modular functions for mixed model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  glFormula(formula, data = NULL, family = gaussian,
            subset, weights, na.action, offset, contrasts = NULL,
            start, mustart, etastart, control = glmerControl(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modular_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object
describing both the fixed-effects and random-effects parts
of the model, with the response on the left of a <code>~</code>
operator and the terms, separated by <code>+</code> operators,
on the right.  Random-effects terms are distinguished by
vertical bars (<code>"|"</code>) separating expressions for
design matrices from grouping factors.</p>
</td></tr>
<tr><td><code id="modular_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the
variables named in <code>formula</code>.  By default the
variables are taken from the environment from which
<code>lmer</code> is called. While <code>data</code> is optional, the
package authors <em>strongly</em> recommend its use,
especially when later applying methods such as
<code>update</code> and <code>drop1</code> to the fitted model
(<em>such methods are not guaranteed to work properly
if <code>data</code> is omitted</em>). If <code>data</code> is omitted,
variables will be taken from the environment of
<code>formula</code> (if specified as a formula) or from the
parent frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="modular_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the
subset of the rows of <code>data</code> that should be used in
the fit. This can be a logical vector, or a numeric
vector indicating which observation numbers are to be
included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="modular_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="modular_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should
happen when the data contain <code>NA</code>s.  The default
action (<code>na.omit</code>, inherited from the 'factory
fresh' value of <code>getOption("na.action")</code>) strips any
observations with any missing values in any variables.</p>
</td></tr>
<tr><td><code id="modular_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting.  This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if
more than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional <code><a href="base.html#topic+list">list</a></code>.  See the
<code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_control">control</code></td>
<td>
<p>a list giving
</p>

<dl>
<dt>for <code>[g]lFormula</code>:</dt><dd><p>all
options for running the model, see <code><a href="lme4.html#topic+lmerControl">lmerControl</a></code>;</p>
</dd>
<dt>for <code>mkLmerDevfun,mkGlmerDevfun</code>:</dt><dd><p>options
for the inner optimization step;</p>
</dd>
<dt>for <code>optimizeLmer</code> and <code>optimizeGlmer</code>:</dt><dd><p>control
parameters for nonlinear optimizer (typically inherited from the
... argument to <code><a href="lme4.html#topic+lmerControl">lmerControl</a></code>).</p>
</dd>

</dl>

</td></tr>
<tr><td><code id="modular_+3A_start">start</code></td>
<td>
<p>starting values (see <code><a href="lme4.html#topic+lmer">lmer</a></code>;
for <code>glFormula</code>, should be just a numeric vector of
fixed-effect coefficients)</p>
</td></tr>
<tr><td><code id="modular_+3A_family">family</code></td>
<td>
<p>a GLM family; see <code><a href="stats.html#topic+glm">glm</a></code>
and <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_mustart">mustart</code></td>
<td>
<p>optional starting values on the scale of
the conditional mean; see <code><a href="stats.html#topic+glm">glm</a></code> for details.</p>
</td></tr>
<tr><td><code id="modular_+3A_etastart">etastart</code></td>
<td>
<p>optional starting values on the scale of
the unbounded predictor; see <code><a href="stats.html#topic+glm">glm</a></code> for details.</p>
</td></tr>
<tr><td><code id="modular_+3A_...">...</code></td>
<td>
<p>other potential arguments; for <code>optimizeLmer</code> and
<code>optimizeGlmer</code>, these are passed to internal function
<code>optwrap</code>, which has relevant parameters <code>calc.derivs</code>
and <code>use.last.params</code> (see <code><a href="lme4.html#topic+lmerControl">lmerControl</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions make up the internal components of an [gn]lmer fit.
</p>

<ul>
<li> <p><code>[g]lFormula</code> takes the arguments that would normally be
passed to <code>[g]lmer</code>, checking for errors and processing the
formula and data input to create a list of objects required to fit a
mixed model.
</p>
</li>
<li> <p><code>mk(Gl|L)merDevfun</code> takes the output of the previous
step (minus the <code>formula</code> component) and creates a
deviance function
</p>
</li>
<li> <p><code>optimize(Gl|L)mer</code> takes a
deviance function and optimizes over <code>theta</code> (or
over <code>theta</code> and <code>beta</code>, if <code>stage</code> is set
to 2 for <code>optimizeGlmer</code>
</p>
</li>
<li> <p><code>updateGlmerDevfun</code> takes the first stage of a GLMM
optimization (with <code>nAGQ=0</code>, optimizing over <code>theta</code> only)
and produces a second-stage deviance function
</p>
</li>
<li> <p><code><a href="lme4.html#topic+mkMerMod">mkMerMod</a></code> takes the <em>environment</em> of a
deviance function, the results of an optimization, a list of
random-effect terms, a model frame, and a model all and produces a
<code>[g]lmerMod</code> object.
</p>
</li></ul>



<h3>Value</h3>

<p><code>lFormula</code> and <code>glFormula</code> return a list containing
components:
</p>

<dl>
<dt>fr</dt><dd><p>model frame</p>
</dd>
<dt>X</dt><dd><p>fixed-effect design matrix</p>
</dd>
<dt>reTrms</dt><dd><p>list containing information on random effects structure:
result of <code><a href="lme4.html#topic+mkReTrms">mkReTrms</a></code></p>
</dd>
</dl>

<p><code>mkLmerDevfun</code> and <code>mkGlmerDevfun</code> return a function to
calculate deviance (or restricted deviance) as a function of the
theta (random-effect) parameters.  <code>updateGlmerDevfun</code>
returns a function to calculate the deviance as a function of a
concatenation of theta and beta (fixed-effect) parameters. These
deviance functions have an environment containing objects required
for their evaluation. CAUTION: The <code><a href="base.html#topic+environment">environment</a></code> of
functions returned by <code>mk(Gl|L)merDevfun</code> contains reference
class objects (see <code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code>,
<code><a href="lme4.html#topic+merPredD-class">merPredD-class</a></code>, <code><a href="lme4.html#topic+lmResp-class">lmResp-class</a></code>), which
behave in ways that may surprise many users. For example, if the
output of <code>mk(Gl|L)merDevfun</code> is naively copied, then
modifications to the original will also appear in the copy (and
vice versa). To avoid this behavior one must make a deep copy (see
<code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code> for details).
</p>
<p><code>optimizeLmer</code> and <code>optimizeGlmer</code> return the results of an
optimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(lme4)
  ### Fitting a linear mixed model in 4 modularized steps

  ## 1.  Parse the data and formula:
  lmod &lt;- lFormula(Reaction ~ Days + (Days|Subject), sleepstudy)
  names(lmod)
  ## 2.  Create the deviance function to be optimized:
  (devfun &lt;- do.call(mkLmerDevfun, lmod))
  ls(environment(devfun)) # the environment of 'devfun' contains objects
  # required for its evaluation
  ## 3.  Optimize the deviance function:
  opt &lt;- optimizeLmer(devfun)
  opt[1:3]
  ## 4.  Package up the results:
  mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr)


  ### Same model in one line
  lmer(Reaction ~ Days + (Days|Subject), sleepstudy)


  ### Fitting a generalized linear mixed model in six modularized steps

  ## 1.  Parse the data and formula:
  glmod &lt;- glFormula(cbind(incidence, size - incidence) ~ period + (1 | herd),
                     data = cbpp, family = binomial)
  #.... see what've got :
  str(glmod, max=1, give.attr=FALSE)
  ## 2.  Create the deviance function for optimizing over theta:
  (devfun &lt;- do.call(mkGlmerDevfun, glmod))
  ls(environment(devfun)) # the environment of devfun contains lots of info
  ## 3.  Optimize over theta using a rough approximation (i.e. nAGQ = 0):
  (opt &lt;- optimizeGlmer(devfun))
  ## 4.  Update the deviance function for optimizing over theta and beta:
  (devfun &lt;- updateGlmerDevfun(devfun, glmod$reTrms))
  ## 5.  Optimize over theta and beta:
  opt &lt;- optimizeGlmer(devfun, stage=2)
  str(opt, max=1) # seeing what we'got
  ## 6.  Package up the results:
  (fMod &lt;- mkMerMod(environment(devfun), opt, glmod$reTrms, fr = glmod$fr))

  ### Same model in one line
  fM &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial)
  all.equal(fMod, fM, check.attributes=FALSE, tolerance = 1e-12)
  # ----  --  even tolerance = 0  may work
  
</code></pre>

<hr>
<h2 id='nobars'>Omit terms separated by vertical bars in a formula</h2><span id='topic+nobars'></span>

<h3>Description</h3>

<p>Remove the random-effects terms from a mixed-effects
formula, thereby producing the fixed-effects formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nobars(term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobars_+3A_term">term</code></td>
<td>
<p>the right-hand side of a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the fixed-effects part of the formula
</p>


<h3>Note</h3>

<p>This function is called recursively on individual terms
in the model, which is why the argument is called
<code>term</code> and not a name like <code>form</code>, indicating a
formula.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>Other utilities: <code><a href="lme4.html#topic+findbars">findbars</a></code>,
<code><a href="lme4.html#topic+mkRespMod">mkRespMod</a></code>, <code><a href="lme4.html#topic+mkReTrms">mkReTrms</a></code>,
<code><a href="lme4.html#topic+nlformula">nlformula</a></code>, <code><a href="lme4.html#topic+subbars">subbars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nobars(Reaction ~ Days + (Days|Subject)) ## =&gt; Reaction ~ Days
</code></pre>

<hr>
<h2 id='NrUnique'>Number of unique elements in a vector</h2><span id='topic+NrUnique'></span>

<h3>Description</h3>

<p>Number of unique elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NrUnique(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NrUnique_+3A_x">x</code></td>
<td>
<p>object of type <code>vector</code>.</p>
</td></tr>
<tr><td><code id="NrUnique_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating if missing values have to be removed. Default to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with the number of unique elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = sample(letters, 50, TRUE)
NrUnique(x)
</code></pre>

<hr>
<h2 id='plotRE'>Visualizing the random effect estimates using ggplot2</h2><span id='topic+plotRE'></span>

<h3>Description</h3>

<p>Using this function, you can create plots of the random effect estimates from fitted random effects models. To make
the plots, we rely on the <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRE(
  obj,
  levelRE = c("all", "first", "second"),
  colour = "black",
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRE_+3A_obj">obj</code></td>
<td>
<p>an object of type <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> or <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
<tr><td><code id="plotRE_+3A_levelre">levelRE</code></td>
<td>
<p>indicates which hierarchical level has to be used. <code>"all"</code> plots both levels in the hierarchy,
<code>"first"</code> the first level in the hierarchy and <code>"second"</code> the second level.</p>
</td></tr>
<tr><td><code id="plotRE_+3A_colour">colour</code></td>
<td>
<p>colour for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code></p>
</td></tr>
<tr><td><code id="plotRE_+3A_plot">plot</code></td>
<td>
<p>logical indicating if the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects have to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with <code>ggplot</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitHGLM &lt;- hierCredGLM(Y ~ area + gender + (1 | VehicleType / VehicleBody), dataCar, weights = w)
plotRE(fitHGLM)

</code></pre>

<hr>
<h2 id='predict.hierCredGLM'>Model predictions</h2><span id='topic+predict.hierCredGLM'></span>

<h3>Description</h3>

<p>Obtain predictions based on the model fit with <code>hierCredGLM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredGLM'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hierCredGLM_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.hierCredGLM_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.hierCredGLM_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>glm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random effects are taken into account by specifying these as an offset in the <code>predict.glm</code> function.
</p>


<h3>Value</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredGLM">hierCredGLM</a></code>
</p>

<hr>
<h2 id='predict.hierCredibility'>Model predictions</h2><span id='topic+predict.hierCredibility'></span>

<h3>Description</h3>

<p>Obtain predictions based on a model fit with <code>hierCredibility</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredibility'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hierCredibility_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.hierCredibility_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.hierCredibility_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredibility">hierCredibility</a></code>
</p>

<hr>
<h2 id='predict.hierCredTweedie'>Model predictions</h2><span id='topic+predict.hierCredTweedie'></span>

<h3>Description</h3>

<p>Obtain predictions based on the model fit with <code>hierCredTweedie</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredTweedie'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hierCredTweedie_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.hierCredTweedie_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.hierCredTweedie_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="cplm.html#topic+cpglm">cpglm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random effects are taken into account by specifying these as an offset in the <code>predict.cpglm</code> function.
</p>


<h3>Value</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for the fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>
</p>

<hr>
<h2 id='print.BalanceProperty'>Print method for an object of class <code>BalanceProperty</code></h2><span id='topic+print.BalanceProperty'></span>

<h3>Description</h3>

<p>Print method for an object of class <code>BalanceProperty</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BalanceProperty'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BalanceProperty_+3A_x">x</code></td>
<td>
<p>an object of type <code>BalanceProperty</code></p>
</td></tr>
<tr><td><code id="print.BalanceProperty_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the call and whether the balance property is satisfied or not. Returns an invisible copy
of the original object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BalanceProperty">BalanceProperty</a></code>
</p>

<hr>
<h2 id='ranef'>Extract the modes of the random effects</h2><span id='topic+ranef'></span>

<h3>Description</h3>

<p>A generic function to extract the conditional modes of
the random effects from a fitted model object.  For
linear mixed models the conditional modes of the random
effects are also the conditional means.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>an object of a class of fitted models with
random effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If grouping factor i has k levels and j random effects
per level the ith component of the list returned by
<code>ranef</code> is a data frame with k rows and j columns.
</p>


<h3>Value</h3>


<ul>
<li>
<p>From <code>ranef</code>:
An object composed of
a list of data frames, one for each grouping factor for
the random effects.  The number of rows in the data frame
is the number of levels of the grouping factor.  The
number of columns is the dimension of the random effect
associated with each level of the factor.
</p>

</li></ul>
 


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(lattice) ## for dotplot, qqmath
  library(lme4)
  fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
  fm2 &lt;- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy)
  fm3 &lt;- lmer(diameter ~ (1|plate) + (1|sample), Penicillin)
  ranef(fm1)
  
</code></pre>

<hr>
<h2 id='ranef-actuaRE'>Extract the random effect estimates from a fitted random effects model</h2><span id='topic+ranef-actuaRE'></span><span id='topic+ranef.hierCredibility'></span><span id='topic+ranef.hierCredGLM'></span><span id='topic+ranef.hierCredTweedie'></span>

<h3>Description</h3>

<p>A generic function to extract the estimates/predictions of the random effects from a fitted random effects model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hierCredibility'
ranef(object, ...)

## S3 method for class 'hierCredGLM'
ranef(object, ...)

## S3 method for class 'hierCredTweedie'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef-actuaRE_+3A_object">object</code></td>
<td>
<p>an object of type <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> or <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
<tr><td><code id="ranef-actuaRE_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, one for each grouping factor for the random effects. The number of rows in the data frame is the number of levels of the grouping factor.
The first (two) columns correspond(s) to the grouping factor. The last column corresponds to the estimated random effect.
</p>

<hr>
<h2 id='tweedieGLMM'>Fitting a Tweedie GLMM, using the initial estimates of hierCredTweedie</h2><span id='topic+tweedieGLMM'></span>

<h3>Description</h3>

<p>This function first estimates the random effects model using Ohlsson's GLMC algorithm (Ohlsson, 2008) and then uses
these estimates as initial estimates when fitting a Tweedie GLMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweedieGLMM(
  formula,
  data,
  weights,
  muHatGLM = FALSE,
  epsilon = 1e-04,
  maxiter = 500,
  verbose = FALSE,
  balanceProperty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tweedieGLMM_+3A_formula">formula</code></td>
<td>
<p>object of type <code><a href="stats.html#topic+formula">formula</a></code> that specifies which model should be fitted. Syntax is the same as for
<code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code>. For example, <code>Yijkt ~ x1 + x2 + (1 | Industry / Branch)</code>.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_data">data</code></td>
<td>
<p>an object that is coercible by <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, containing the variables in the model.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_weights">weights</code></td>
<td>
<p>variable name of the exposure weight.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_muhatglm">muHatGLM</code></td>
<td>
<p>indicates which estimate has to be used in the algorithm for the intercept term. Default is <code>TRUE</code>,
which used the intercept as estimated by the GLM. If <code>FALSE</code>, the estimate of the hierarchical credibility model is used.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">\epsilon</code>; the iterations converge when
<code class="reqn">||\theta[k] - \theta[k - 1]||^2[[2]]/||\theta[k - 1]||^2[[2]] &lt; \epsilon</code>. Here, <code class="reqn">\theta[k]</code> is the parameter vector at the <code class="reqn">k^{th}</code> iteration.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if output should be produced during the algorithm.</p>
</td></tr>
<tr><td><code id="tweedieGLMM_+3A_balanceproperty">balanceProperty</code></td>
<td>
<p>logical indicating if the balance property should be satisfied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>cpglmm</code>, containing the model fit.
</p>


<h3>References</h3>

<p>Campo, B.D.C. and Antonio, Katrien (2023). Insurance pricing with hierarchically structured data an illustration with a workers' compensation insurance portfolio. <em>Scandinavian Actuarial Journal</em>, doi: 10.1080/03461238.2022.2161413
</p>


<h3>See Also</h3>

<p><code><a href="cplm.html#topic+cpglmm">cpglmm</a></code> and <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataCar")
fitTweedieGLMM = tweedieGLMM(Y ~ area + gender + (1 | VehicleType / VehicleBody), dataCar,
 weights = w, verbose = TRUE, epsilon = 1e-4)

</code></pre>

<hr>
<h2 id='weights-actuaRE'>Extract the model weights</h2><span id='topic+weights-actuaRE'></span><span id='topic+weights.cpglm'></span><span id='topic+weights.hierCredGLM'></span><span id='topic+weights.hierCredTweedie'></span>

<h3>Description</h3>

<p><code>weights</code> is a generic function which extracts fitting weights from objects returned by modeling functions.
Methods can make use of <code><a href="stats.html#topic+napredict">napredict</a></code> methods to compensate for the omission of missing values. The default methods does so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpglm'
weights(object, type = c("prior", "working"), ...)

## S3 method for class 'hierCredGLM'
weights(object, type = c("prior", "working"), ...)

## S3 method for class 'hierCredTweedie'
weights(object, type = c("prior", "working"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights-actuaRE_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model weights is meaningful. Can be either <code><a href="cplm.html#topic+cpglm">cpglm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> or <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code></p>
</td></tr>
<tr><td><code id="weights-actuaRE_+3A_type">type</code></td>
<td>
<p>indicates if prior or working weights need to be extracted.</p>
</td></tr>
<tr><td><code id="weights-actuaRE_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weights extracted from the object <code>object</code>: the default method looks for component &quot;weights&quot; and if not <code>NULL</code> calls <code><a href="stats.html#topic+napredict">napredict</a></code> on it.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+weights">weights</a></code>, <code><a href="cplm.html#topic+cpglm">cpglm</a></code>, <code>glm</code>, <code><a href="#topic+hierCredibility">hierCredibility</a></code>, <code><a href="#topic+hierCredGLM">hierCredGLM</a></code> or <code><a href="#topic+hierCredTweedie">hierCredTweedie</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
