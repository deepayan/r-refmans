<!DOCTYPE html><html lang="en"><head><title>Help for package braidReports</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {braidReports}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#braidReports-package'><p>braidReports: Visualize Combined Action Response Surfaces and Report BRAID Analyses</p></a></li>
<li><a href='#basicBraidAnalysis'><p>Basic BRAID Analysis Conversion</p></a></li>
<li><a href='#geom_braid'><p>BRAID Heatmaps</p></a></li>
<li><a href='#geom_braid_contour'><p>Smoothed BRAID Surface Contours</p></a></li>
<li><a href='#geom_braid_smooth'><p>Smoothed BRAID Surfaces</p></a></li>
<li><a href='#kappa_trans'><p>BRAID kappa Transforms</p></a></li>
<li><a href='#makeBraidReport'><p>Render a BRAID Report</p></a></li>
<li><a href='#merckValues_stable'><p>Best-Fit Bayesian Stabilized Merck OPPS BRAID Values</p></a></li>
<li><a href='#merckValues_unstable'><p>Best-Fit Unstabilized Merck OPPS BRAID Values</p></a></li>
<li><a href='#runBraidAnalysis'><p>BRAID Surface Analysis</p></a></li>
<li><a href='#StatBraid'><p>Base ggproto classes for braidReports</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Visualize Combined Action Response Surfaces and Report BRAID
Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to visualize combined action data in 'ggplot2'.
    Also provides functions for producing full BRAID analysis reports with 
    custom layouts and aesthetics, using the BRAID method originally described 
    in Twarog et al. (2016) &lt;<a href="https://doi.org/10.1038%2Fsrep25523">doi:10.1038/srep25523</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>braidrm (&ge; 1.0.0), ggplot2, R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>basicdrm, cowplot, grid, gtable, scales, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-29 14:54:40 UTC; ntwarog</td>
</tr>
<tr>
<td>Author:</td>
<td>Anang Shelat [aut],
  Nathaniel R. Twarog [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathaniel R. Twarog &lt;nathaniel.twarog@stjude.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-29 22:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='braidReports-package'>braidReports: Visualize Combined Action Response Surfaces and Report BRAID Analyses</h2><span id='topic+braidReports'></span><span id='topic+braidReports-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides functions to visualize combined action data in 'ggplot2'. Also provides functions for producing full BRAID analysis reports with custom layouts and aesthetics, using the BRAID method originally described in Twarog et al. (2016) <a href="https://doi.org/10.1038/srep25523">doi:10.1038/srep25523</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nathaniel R. Twarog <a href="mailto:nathaniel.twarog@stjude.org">nathaniel.twarog@stjude.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Anang Shelat <a href="mailto:anang.shelat@stjude.org">anang.shelat@stjude.org</a>
</p>
</li></ul>


<hr>
<h2 id='basicBraidAnalysis'>Basic BRAID Analysis Conversion</h2><span id='topic+basicBraidAnalysis'></span>

<h3>Description</h3>

<p>Basic BRAID Analysis Conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicBraidAnalysis(bfit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basicBraidAnalysis_+3A_bfit">bfit</code></td>
<td>
<p>A BRAID fit object of class <code>braidrm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>While we strongly recommend using the <code><a href="#topic+runBraidAnalysis">runBraidAnalysis()</a></code> function for a
more complete treatment of a combination; there may be circumstances in
which is necessary or preferable to use an existing BRAID fit object (of
class <code>braidrm</code>).  Thsi function takes such a fit and wraps it in a minimal
<code>braidAnalysis</code> object which can then be passed to <code><a href="#topic+makeBraidReport">makeBraidReport()</a></code>
</p>


<h3>Value</h3>

<p>A BRAID analysis object of class <code>braidanalysis</code> containin only the
results from the given BRAID fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- antagonisticExample
fit &lt;- braidrm(measure ~ concA + concB, surface, model="kappa2")

analysis &lt;- basicBraidAnalysis(fit)

names(analysis)
</code></pre>

<hr>
<h2 id='geom_braid'>BRAID Heatmaps</h2><span id='topic+geom_braid'></span><span id='topic+stat_braid'></span><span id='topic+geom_braid_glass'></span><span id='topic+stat_braid_glass'></span>

<h3>Description</h3>

<p>Summarize and plot measurements of two inputs as a discrete raster or
&quot;stained-glass&quot; plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_braid(
  mapping = NULL,
  data = NULL,
  stat = "braid",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_braid(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_braid_glass(
  mapping = NULL,
  data = NULL,
  stat = "braid_glass",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_braid_glass(
  mapping = NULL,
  data = NULL,
  geom = "polygon",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_braid_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile()</a></code></p>
</td></tr>
<tr><td><code id="geom_braid_+3A_space">space</code></td>
<td>
<p>Parameter specifying the separation between marginal tiles and
the main grid.  Describes the distance from the center of the marginal tile
to the center of the nearest main grid tile, divided by the width or height
of the tile.  If a single value is provided, it is used for both left-right
and top-bottom margin tiles.  If two values are provided, the first is used
for left-right margin tiles and the second is used for top-bottom margin
tiles.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_trim">trim</code></td>
<td>
<p>Should values that are finite in one dimension be dropped if
their finite coordinates lie outside the bounds of the main grid?</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_shared">shared</code></td>
<td>
<p>Should marginal offsets and trimming be calculated separately
for each facet if plots are faceted.  If <code>FALSE</code>, the default, each facet
will have its own bounds and marginal offsets; if <code>TRUE</code>, offsets will be
calculated for the full data and shared across all facets.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a
warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_braid_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>While the existing <code>ggplot2</code> package includes several functions that are
extremely effective and versatile for visualizing two-dimensional responses,
including <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile()</a></code>, and
<code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>, a number of considerations particular to combination
data make these functions, as is, somewhat difficult to use.  First, these
functions are not designed for data in which pairs of x- and y-coordinates
are duplicated; yet this is very common in experimental data.  While such
duplications can be handled prior to calling a visualization function,
handling them automatically reduces the barrier to plotting.
</p>
<p>A second, and much more challenging consideration, is that for many drug
combination studies, drug concentrations are measured as a series of equal
ratio dilutions; visualizing such doses is most intuitive on a logarithmic
scale.  But when inputs are scaled logarithmically, zeros become infinite
and are automatically removed by nearly all <code>ggplot2</code> functions.  This makes
it very difficult to plot measurements of drugs in isolation and in
combination in the same plot.  <code>geom_braid</code> addresses this by automatically
offsetting any measurements whose transformed coordinates are infinite to
margins within the plotted space, so that all values can be plotted together.
</p>
<p>While <code>geom_braid</code> is suitable for most response surfaces, some surfaces
feature measurements that are not arranged in a evenly spaced checkerboard.
For such surfaces, <code>geom_braid_glass</code> produces a set of Voronoi polygons
centered on the available transformed coordinates, creating what we call a
&quot;stained glass&quot; plot.  Marginal points are still represented by rectangles,
but with width and height such that boundaries are equidistant between
adjacent points.
</p>
<p><code>stat_braid</code> and <code>stat_braid_glass</code> are simply the corresponding <code>stat_</code>
functions for these two functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>concentrations &lt;- c(0,2^(-3:3))
surface &lt;- data.frame(
	  concA = rep(rep(concentrations,each=length(concentrations)),each=3),
  concB = rep(rep(concentrations,times=length(concentrations)),each=3),
  replicate = rep(c(1,2,3),times=(length(concentrations)^2))
)
surface$actual &lt;- evalBraidModel(
  surface$concA,
 surface$concB,
 c(1, 1, 3, 3, 2, 0, 100, 100, 100)
)
surface$measure &lt;- surface$actual + rnorm(nrow(surface),sd=7)

ggplot(surface,aes(x=concA,y=concB))+
    geom_braid(aes(fill=measure))+
    scale_x_log10()+
    scale_y_log10()+
    scale_fill_distiller(palette="RdYlBu")+
    coord_equal()+
    labs(x="Drug A",y="Drug B",fill="Effect")

glassSurface &lt;- surface
glassSurface$concA[glassSurface$replicate==2] &lt;-
    glassSurface$concA[glassSurface$replicate==2]*1.25
glassSurface$concB[glassSurface$replicate==3] &lt;-
    glassSurface$concB[glassSurface$replicate==3]*1.25
glassSurface$actual &lt;- evalBraidModel(
    glassSurface$concA,
    glassSurface$concB,
    c(1, 1, 3, 3, -0.5, 0, 60, 100, 100)
)
glassSurface$measure &lt;- glassSurface$actual+rnorm(nrow(glassSurface),sd=7)

ggplot(glassSurface,aes(x=concA,y=concB))+
    geom_braid_glass(aes(fill=measure))+
    scale_x_log10("Drug A")+
    scale_y_log10("Drug B")+
    scale_fill_distiller("Effect",palette="RdYlBu")+
    coord_equal()

glassSurface$tilewidth &lt;- log10(2)*0.9
glassSurface$tilewidth[glassSurface$concA==0] &lt;- log10(2)/2

glassSurface$tileheight &lt;- log10(2)*0.9
glassSurface$tileheight[glassSurface$concB==0] &lt;- log10(2)/2

ggplot(glassSurface,aes(x=concA,y=concB))+
    geom_braid_glass(aes(fill=measure,width=tilewidth,height=tileheight),space=2)+
    scale_x_log10("Drug A")+
    scale_y_log10("Drug B")+
    scale_fill_distiller("Effect",palette="RdYlBu")+
    coord_equal()
</code></pre>

<hr>
<h2 id='geom_braid_contour'>Smoothed BRAID Surface Contours</h2><span id='topic+geom_braid_contour'></span><span id='topic+stat_braid_contour'></span>

<h3>Description</h3>

<p>Generate contours of a smoothed two-dimensional response surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_braid_contour(
  mapping = NULL,
  data = NULL,
  stat = "braid_contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  npoints = 50,
  tight = FALSE,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_braid_contour(
  mapping = NULL,
  data = NULL,
  geom = "contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  npoints = 50,
  tight = FALSE,
  trim = TRUE,
  shared = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_braid_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_bins">bins</code></td>
<td>
<p>Number of contour bins. Overridden by <code>breaks</code>.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the contour bins. Overridden by <code>bins</code>.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Numeric vector to set the contour breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output. A function can be created from a formula
(e.g. ~ fullseq(.x, .y)).
</p>
</li></ul>

<p>Overrides <code>binwidth</code> and <code>bins</code>. By default, this is a vector of length
ten with <code><a href="base.html#topic+pretty">pretty()</a></code> breaks.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_npoints">npoints</code></td>
<td>
<p>The number of interpolated values in the x- and y- directions
that are used to generate the smoothed raster function</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_tight">tight</code></td>
<td>
<p>If true, the generated raster will span the precise range of
transformed and plotted data; this will produce a range of tiles that are
strictly smaller than those produced by <a href="#topic+geom_braid">geom_braid</a> (as those tiles extend
above and below the plotted tile centers).  If <code>FALSE</code> (the default), the
interpolated values will be selected to span the same (slightly larger) range
of values that would be covered by running <a href="#topic+geom_braid">geom_braid</a> with the same
parameters.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_trim">trim</code></td>
<td>
<p>Should values that are finite in one dimension be dropped if
their finite coordinates lie outside the bounds of the main grid?</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_shared">shared</code></td>
<td>
<p>Should marginal offsets and trimming be calculated separately
for each facet if plots are faceted.  If <code>FALSE</code>, the default, each facet
will have its own bounds and marginal offsets; if <code>TRUE</code>, offsets will be
calculated for the full data and shared across all facets.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_braid_contour_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When evaluating a plotted response surface it is often more effective to
plot the precise contours at which a set of levels is reached by the
combination.  Because <a href="ggplot2.html#topic+geom_contour">ggplot2::stat_contour</a> requires that data lie in an
evenly space raster grid (and does not support duplicated values), it is
difficult to apply to more discrete or irregularly sampled data.  This
function uses the same smoothing and interpolation utilities as
<a href="#topic+geom_braid_smooth">geom_braid_smooth</a> to preprocess and smooth data, which is then passed to
the contour estimation code of <a href="ggplot2.html#topic+geom_contour">ggplot2::stat_contour</a>, producing contours
which are smoothed and sufficiently regularly spaced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- antagonisticExample

ggplot(surface,aes(x=concA,y=concB))+
   geom_braid_smooth(aes(fill=measure))+
   geom_braid_contour(aes(z=measure),colour="black",breaks=((1:9)/10))+
    scale_x_log10("Drug A")+
    scale_y_log10("Drug B")+
    scale_fill_distiller("Effect",palette="RdYlBu")+
    coord_equal()
</code></pre>

<hr>
<h2 id='geom_braid_smooth'>Smoothed BRAID Surfaces</h2><span id='topic+geom_braid_smooth'></span><span id='topic+stat_braid_smooth'></span>

<h3>Description</h3>

<p>Summarize and plot measurements of two inputs as a smoothed response surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_braid_smooth(
  mapping = NULL,
  data = NULL,
  stat = "braid_smooth",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  npoints = 50,
  tight = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_braid_smooth(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  space = 1.5,
  trim = TRUE,
  shared = FALSE,
  npoints = 50,
  tight = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_braid_smooth_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile()</a></code></p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_space">space</code></td>
<td>
<p>Parameter specifying the separation between marginal tiles and
the main grid.  Describes the distance from the center of the marginal tile
to the center of the nearest main grid tile, divided by the width or height
of the tile.  If a single value is provided, it is used for both left-right
and top-bottom margin tiles.  If two values are provided, the first is used
for left-right margin tiles and the second is used for top-bottom margin
tiles.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_trim">trim</code></td>
<td>
<p>Should values that are finite in one dimension be dropped if
their finite coordinates lie outside the bounds of the main grid?</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_shared">shared</code></td>
<td>
<p>Should marginal offsets and trimming be calculated separately
for each facet if plots are faceted.  If <code>FALSE</code>, the default, each facet
will have its own bounds and marginal offsets; if <code>TRUE</code>, offsets will be
calculated for the full data and shared across all facets.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_npoints">npoints</code></td>
<td>
<p>The number of interpolated values in the x- and y- directions
that are used to generate the smoothed raster function</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_tight">tight</code></td>
<td>
<p>If true, the generated raster will span the precise range of
transformed and plotted data; this will produce a range of tiles that are
strictly smaller than those produced by <a href="#topic+geom_braid">geom_braid</a> (as those tiles extend
above and below the plotted tile centers).  If <code>FALSE</code> (the default), the
interpolated values will be selected to span the same (slightly larger) range
of values that would be covered by running <a href="#topic+geom_braid">geom_braid</a> with the same
parameters.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a
warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_braid_smooth_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <a href="#topic+geom_braid">geom_braid</a>, this function involves several pre-processing steps to
allow quick visualization of drug combination data. These steps include
summarizing duplicated measurements and offsetting non-finite plotted
coordinates. In addition to these steps, <code>geom_braid_smooth</code> generates a
regular, densely sampled grid of coordinates and smoothly interpolates the
given data to produces a smoothed raster heatmap.  Smoothing in the x- and
y- directions is governed by the width and height aesthetic respectively; if
these aesthetics are not included, they are estimated from the minimum
spacing of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- synergisticExample

ggplot(surface,aes(x=concA,y=concB))+
   geom_braid_smooth(aes(fill=measure))+
    scale_x_log10("Drug A")+
    scale_y_log10("Drug B")+
    scale_fill_distiller("Effect",palette="RdYlBu")+
    coord_equal()
</code></pre>

<hr>
<h2 id='kappa_trans'>BRAID kappa Transforms</h2><span id='topic+kappa_trans'></span><span id='topic+scale_x_kappa'></span><span id='topic+scale_y_kappa'></span>

<h3>Description</h3>

<p>Functions to linearize the BRAID interaction parameter kappa, which ordinarily
ranges from -2 to infinity. <code>kappa_trans</code> produces a <code>scales</code> transform
object which can be used in <code>ggplot2</code> continuous scale object.
<code>scale_x_kappa</code> and <code>scale_y_kappa</code> are wrappers for <code>scale_x_continuous</code>
and <code>scale_y_continuous</code> which set the <code>trans</code> or <code>transform</code> parameter to
<code>kappa_trans()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_trans()

scale_x_kappa(...)

scale_y_kappa(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa_trans_+3A_...">...</code></td>
<td>
<p>Additional parameter to be passed to <code style="white-space: pre;">&#8288;scale_*_continuous&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>kappa_trans</code> a <code>scales</code> transform object.  For <code style="white-space: pre;">&#8288;scale_*_kappa&#8288;</code>,
a continuous position scale layer for a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transform &lt;- kappa_trans()

transform$transform(c(-1.96, 100))
transform$inverse(c(-1, 1))

data &lt;- merckValues_stable
ggplot(data,aes(x=kappa))+
    geom_density()+
    scale_x_kappa("BRAID kappa")
</code></pre>

<hr>
<h2 id='makeBraidReport'>Render a BRAID Report</h2><span id='topic+makeBraidReport'></span>

<h3>Description</h3>

<p>Produces a one page report depicting the results of a full BRAID analysis
for a single combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBraidReport(analysis, compounds, levels, limits, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeBraidReport_+3A_analysis">analysis</code></td>
<td>
<p>An object of class <code>braidAnalysis</code> produced by the
<code><a href="#topic+runBraidAnalysis">runBraidAnalysis()</a></code> or <code><a href="#topic+basicBraidAnalysis">basicBraidAnalysis()</a></code> functions</p>
</td></tr>
<tr><td><code id="makeBraidReport_+3A_compounds">compounds</code></td>
<td>
<p>A length-2 character vector containing the names of the
two compounds tested in the combination</p>
</td></tr>
<tr><td><code id="makeBraidReport_+3A_levels">levels</code></td>
<td>
<p>Two levels at which the IAE should be evaluated</p>
</td></tr>
<tr><td><code id="makeBraidReport_+3A_limits">limits</code></td>
<td>
<p>Two values representing the maximal achievable concentrations
for the compounds tested, used to esitmate the IAE</p>
</td></tr>
<tr><td><code id="makeBraidReport_+3A_control">control</code></td>
<td>
<p>A named list of additional control parameters adjusting the
appearance of the resulting report</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts, however foolhardily, to encompass many of the
details, plots, and values that the user might wish to report for a complete
BRAID analysis of a given drug combination.  All reports are built for a
single 8.5-by-11 inch page, either in landscape or potrait orientation, but
reports can be customized to contain more or less information.  Here is a
full list of what <em>can</em> appear in the BRAID report:
</p>

<ul>
<li><p> A raw and smoothed plot of the actual measured response data; the raw plot
is built using <code><a href="#topic+geom_braid">geom_braid()</a></code> or, for irregularly laid out data,
<code><a href="#topic+geom_braid_glass">geom_braid_glass()</a></code>, while the smoothed data is built using
<code><a href="#topic+geom_braid_smooth">geom_braid_smooth()</a></code>. (Included in all layouts)
</p>
</li>
<li><p> A plot of residual errors and a smoothed surface plot of the predicted
additive surface based on the dose response behavior of the individual
compounds alone.  In cases of pronounced interaction, this will differ
significantly from the best-fit BRAID plots.  (Included in the dense layout)
</p>
</li>
<li><p> A plot of residual errors and a smoothed surface plot of the best-fitting
BRAID surface. (Included in the all layouts)
</p>
</li>
<li><p> A table of the best-fitting BRAID response surface parameters (Included in
all layouts)
</p>
</li>
<li><p> A table of estimated IAE values at the specified effect levels (Included in
all layouts)
</p>
</li>
<li><p> Two tables of the dose required of one drug to produce a desired effect
level (the first value in <code>levels</code>) in the presence of several doses of the
other drug; used to gauge the degree of potentiation.  (Included in the
standard and dense layouts)
</p>
</li>
<li><p> Two plots depicting the predicted dose response of one drug in the presence
of various levels of the other, also used to gauge potentiation.  (Included
in the standard and dense layouts)
</p>
</li></ul>

<p>So the resulting report page can contain from six (simple layout) to twelve
(dense layout) elements depicting different aspects of the BRAID analysis.
</p>
<p>The precise appearance of the report page is controlled by various elements
of the <code>control</code> parameter.  Though the default value of the parameter is
an empty list, several fields will be filled in if they are unspecified. The
full set of possible control options is:
</p>

<ul>
<li> <p><code>abbs</code>: A pair of character strings specifying the abbreviations of the
tested compounds.  By default, the abbreviations consist of the firs three
characters of each compound's name, but for some compound names this is not
an appropriate abbreviation  Abbreviations are used in many axis labels and
tables
</p>
</li>
<li> <p><code>units</code>: If included, a single string or pair of strings specifying the
dose units for the two drugs tested, included in axis labels and tables.  If
left unspecified, units will not be included
</p>
</li>
<li> <p><code>xscale</code>: Either a character string specifying a named transformation
object (e.g &quot;log2&quot;, &quot;log10&quot;, &quot;sqrt&quot;) or a <code>ggplot2</code> continuous x-position
scale generated by <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code> or related functions.  This
scale will be applied to the x-dimension of all surface plots and the
x-dimension of the first potentiation plot. If a <code>name</code> is specified for the
scale, this will be the x-axis label; otherwise other defaults will be used.
Default value for this control parameter is &quot;log10&quot;.
</p>
</li>
<li> <p><code>yscale</code>: Either a character string specifying a named transformation
object (e.g &quot;log2&quot;, &quot;log10&quot;, &quot;sqrt&quot;) or a <code>ggplot2</code> continuous y-position
scale generated by <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_y_continuous()</a></code> or related functions.  This
scale will be applied to the y-dimension of all surface plots and the
x-dimension of the second potentiation plot. If a <code>name</code> is specified for the
scale, this will be the y-axis label; otherwise other defaults will be used.
Default value for this control parameter is &quot;log10&quot;.
</p>
</li>
<li> <p><code>fillscale</code>: If included, continuous fill scale object generated by one of
several <code>ggplot2</code> continuous fill scale functions. This fill scale will
control the fill appearance for all <em>effect</em> surface plots; fill colors
in residual error plots will use a different color palette.  In addition,
any names, labels, breaks, transformations, etc. included in this scale will
also be applied to the y-axis of both potentiation plots, as those also
represent the modeled effect.  If unspecified, will be set to a brewer
continuous color scale with palette &quot;RdYlBu&quot;.
</p>
</li>
<li> <p><code>colorscale</code>: If included, a discrete color scale object generated by one
of several <code>ggplot2</code> discrete color scale functions.  This color scale
controls the colors chosen for the curves in the two potentiation plots. If
left unspecified, will default to the output of
<code><a href="ggplot2.html#topic+scale_colour_discrete">ggplot2::scale_color_discrete()</a></code>
</p>
</li>
<li> <p><code>xname</code>: A string specifying the desired x-axis labels in surface plots.
Will be overridden if control parameter <code>xscale</code> is a scale object with a
non-empty <code>name</code> attribute. If unspecified, defaults the abbreviation of the
first compound followed by the units if included.
</p>
</li>
<li> <p><code>yname</code>: A string specifying the desired y-axis labels in surface plots.
Will be overridden if control parameter <code>yscale</code> is a scale object with a
non-empty <code>name</code> attribute. If unspecified, defaults the abbreviation of the
second compound followed by the units if included.
</p>
</li>
<li> <p><code>effectname</code>: The name of the modeled effect variable. Could be &quot;Growth&quot;
or &quot;Survival&quot; or &quot;Activity&quot;.  The default value is simply &quot;Effect&quot;
</p>
</li>
<li> <p><code>title</code>: A string containing the overall title of the report page.  If left
unspecified, will simply be the first compound &quot;vs.&quot; the second
</p>
</li>
<li> <p><code>contourcolor</code>: Contours of the smoothed surfaces at the levels specified
by the parameter <code>levels</code> are included in all smoothed plots.  By default,
they are black, but specifying this control parameter will change that color
</p>
</li>
<li> <p><code>irregular</code>: If <code>TRUE</code>, the data are not assumed to lie on a regular grid
in the plotted, and will be visualized with <code><a href="#topic+geom_braid_glass">geom_braid_glass()</a></code> rather than
<code><a href="#topic+geom_braid">geom_braid()</a></code>
</p>
</li>
<li> <p><code>swidth</code>: A numeric value specifying how widely the smooth surfaces should
be smoothed, passed as the <code>width</code> aesthetic to <code><a href="#topic+geom_braid_smooth">geom_braid_smooth()</a></code>
</p>
</li>
<li> <p><code>sheight</code>: A numeric value specifying how far in the y-direction the smooth
surfaces should be smoothed, passed as the <code>height</code> aesthetic to
<code><a href="#topic+geom_braid_smooth">geom_braid_smooth()</a></code>
</p>
</li>
<li> <p><code>npoints</code>: The density of points used in the smoothed plots.  See
<code><a href="#topic+geom_braid_smooth">geom_braid_smooth()</a></code> for details
</p>
</li>
<li> <p><code>leveltext</code>: A pair of strings indicating how the two IAE levels should be
displayed in tables.  In some cases, the precise number at which the IAE is
calculated does not reflect the level that the user wishes to express.  So
a user might want to refer to a relative survival value of 0.1 as IAE90 (for
90% killing); or a log2-fold growth inhibition as IAE50 (for 50% inhibition);
passing &quot;50&quot; or &quot;90&quot; as the <code>leveltext</code> in such cases will produce the
desired appearance.  If left unspecified, labels will simply be the string
representations of the paramter <code>levels</code>
</p>
</li>
<li> <p><code>metrics</code>: A named numeric or named character vector specifying additional
metrics for the combination; they will be added to the table containing the
calculated IAE values. Numeric values will be rounded to three significant
figures; string values will be included as is.  Names will be parsed by
default, so the string &quot;CI[90]&quot; will be displayed with the &quot;90&quot; as a
subscript
</p>
</li>
<li> <p><code>surftheme</code>: A <code>ggplot2</code> <code>theme</code> object specifying any additional theme
adjustments to add to all response surface plots
</p>
</li>
<li> <p><code>curvetheme</code>: A <code>ggplot2</code> <code>theme</code> object specifying any additional theme
adjustments to add to both potentiation curve plots
</p>
</li>
<li> <p><code>layout</code>: The specific layout to be used; determines which report elements
are included.  Can be &quot;simple&quot;, &quot;standard&quot; (the default), or &quot;dense&quot;
</p>
</li>
<li> <p><code>orientation</code>: The expected orientantion of the rendered page; can be
&quot;portrait&quot; (the default) or &quot;landscape&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>A graphical object containing all plots and tables, arranged
according to the desired format. The resulting object is optimized for a
single page, either portrait or landscape as specified in <code>control</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- synergisticExample
analysis &lt;- runBraidAnalysis(measure~concA+concB, surface,
                             defaults=c(0,1), getCIs=FALSE)

report &lt;- makeBraidReport(analysis,c("A Drug","B Drug"),
                          levels=c(0.5, 0.9),limits=c(5,5))
print(report)

control &lt;- list(abbs=c("A","B"),units=c("\u00B5M"),leveltext=c("50","90"),
                xscale=scale_x_log10(breaks=c(0.1,0.5,2,10),
                labels=as.character),
                fillscale=scale_fill_viridis_c(option="A"),
                colorscale=scale_color_brewer(palette="Set1"),
                title="Example Analysis")
nextReport &lt;- makeBraidReport(analysis,c("A Drug","B Drug"),
                              levels=c(0.5, 0.9),limits=c(5,5),
                              control=control)
print(nextReport)
</code></pre>

<hr>
<h2 id='merckValues_stable'>Best-Fit Bayesian Stabilized Merck OPPS BRAID Values</h2><span id='topic+merckValues_stable'></span>

<h3>Description</h3>

<p>A table of BRAID kappa and IAE values resulting from running the version
1.0.0 BRAID fitting code on the Merck oncopolypharmacology screen (OPPS),
with moderate Bayesian stabilization of kappa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merckValues_stable
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 columns:
</p>

<dl>
<dt>cell_line</dt><dd><p>The cancer cell line which the combination was tested</p>
</dd>
<dt>drugA</dt><dd><p>The first drug in the combination tested</p>
</dd>
<dt>drugB</dt><dd><p>The second drug in the combination tested</p>
</dd>
<dt>kappa</dt><dd><p>The best-fit value of the BRAID interaction parameter kappa
with moderate Bayesian stabilizatoin</p>
</dd>
<dt>IAE</dt><dd><p>The index of achievable efficacy (or IAE, a BRAID measure of
combined potency) estimated for the best-fit BRAID surface</p>
</dd>
</dl>


<hr>
<h2 id='merckValues_unstable'>Best-Fit Unstabilized Merck OPPS BRAID Values</h2><span id='topic+merckValues_unstable'></span>

<h3>Description</h3>

<p>A table of BRAID kappa and IAE values resulting from running the version
1.0.0 BRAID fitting code on the Merck oncopolypharmacology screen (OPPS),
with <em>no</em> Bayesian stabilization of kappa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merckValues_unstable
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 columns:
</p>

<dl>
<dt>cell_line</dt><dd><p>The cancer cell line which the combination was tested</p>
</dd>
<dt>drugA</dt><dd><p>The first drug in the combination tested</p>
</dd>
<dt>drugB</dt><dd><p>The second drug in the combination tested</p>
</dd>
<dt>kappa</dt><dd><p>The best-fit value of the BRAID interaction parameter kappa
with no Bayesian stabilizatoin</p>
</dd>
<dt>IAE</dt><dd><p>The index of achievable efficacy (or IAE, a BRAID measure of
combined potency) estimated for the best-fit BRAID surface</p>
</dd>
</dl>


<hr>
<h2 id='runBraidAnalysis'>BRAID Surface Analysis</h2><span id='topic+runBraidAnalysis'></span><span id='topic+runBraidAnalysis.formula'></span><span id='topic+runBraidAnalysis.default'></span>

<h3>Description</h3>

<p>Performs a convenient pre-built set of BRAID and dose-response analysis
tasks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBraidAnalysis(
  formula,
  data,
  defaults,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  useBIC = TRUE,
  ...
)

## S3 method for class 'formula'
runBraidAnalysis(
  formula,
  data,
  defaults,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  useBIC = TRUE,
  ...
)

## Default S3 method:
runBraidAnalysis(
  formula,
  data,
  defaults,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  useBIC = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runBraidAnalysis_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_defaults">defaults</code></td>
<td>
<p>Default minimal and maximal effect values used to fix effect
parameters during model selection.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_start">start</code></td>
<td>
<p>A BRAID parameter vector specifying the first guess where the
non-linear optimization should begin.  May be a length 7, 8, or 9 vector,
though a full length vector is always preferable.  If <code>NULL</code> (the default),
it will be estimated from the data.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_direction">direction</code></td>
<td>
<p>Determines the possible directionality of the BRAID
model.  If 0 (the default) no additional constraints are placed on the
parameters.  If greater than 0, the fitting will require that the maximal
effects are all <em>greater</em> than or equal to the minimal effect.  If less
than 0, the fitting will require that all maximal effect is <em>less</em> than or
equal to the minimal effect.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_lower">lower</code></td>
<td>
<p>A numeric vector of lower bounds on the fitted parameter values.
May be the same length as the number of fitted parameters, or a full,
length-9 vector. Missing or unspecified lower bounds may be included as <code>NA</code>
or <code>Inf</code>; if unspecified, lower bounds on the first five parameters (IDMA,
IDMB, na, nb, and kappa) will be automatically estimated from the data.
Bounds on the minimal and maximal effect parameters however (E0, EfA, EfB,
and Ef) will be assumed to be infinite unless specified.  A value of <code>NULL</code>,
the default, will be treated as all lower parameter bounds being
unspecified.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_upper">upper</code></td>
<td>
<p>A numeric vector of upper bounds on the fitted parameter values.
Used in the same way as <code>lower</code>.</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_usebic">useBIC</code></td>
<td>
<p>If <code>TRUE</code> (the default), the best (read: most parsimonious)
model will be selected from all tested models using the Bayesian information
criterion (Schwarz 1978).  If <code>FALSE</code> the function will follow the convention
of earlier versions of the <code>braidrm</code> package and use the Akaike information
criterion (Akaike 1974).</p>
</td></tr>
<tr><td><code id="runBraidAnalysis_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="braidrm.html#topic+findBestBraid">braidrm::findBestBraid()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>braidAnalysis</code>, containing the following values:
</p>

<ul>
<li> <p><code>concs</code>: a width-two array containing the two tested doses for each
measurement
</p>
</li>
<li> <p><code>act</code>: a numeric vector with as many values as <code>concs</code> has rows,
containing the measured values for each measurement
</p>
</li>
<li> <p><code>weights</code>: a numeric vector of weights, the same length as <code>act</code>,
specifying the weight given to each measurement in fitting.  All weights are
1 by default
</p>
</li>
<li> <p><code>braidFit</code>: a fit object of class <code>braidrm</code> containing the best-fit BRAID
surface according to the given constraints
</p>
</li>
<li> <p><code>hillFit1</code>: If the given data contains measurements of the first drug in
isolation, those measurements are fit using <a href="basicdrm.html#topic+findBestHillModel">basicdrm::findBestHillModel</a>;
the results of this analysis are stored as an object of class <code>hillrm</code> as
<code>hillFit1</code>. If no such measurements are found, this will be <code>NULL</code>
</p>
</li>
<li> <p><code>hillFit2</code>: the corresponding fit for measurements of the second drug
alone, if they are included; <code>NULL</code> otherwise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- synergisticExample

analysis &lt;- runBraidAnalysis(measure~concA+concB, surface, defaults=c(0,1))

names(analysis)
</code></pre>

<hr>
<h2 id='StatBraid'>Base ggproto classes for braidReports</h2><span id='topic+StatBraid'></span><span id='topic+StatBraidGlass'></span><span id='topic+StatBraidSmooth'></span><span id='topic+StatBraidContour'></span><span id='topic+braidReports-ggproto'></span>

<h3>Description</h3>

<p>Base ggproto classes for braidReports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatBraid

StatBraidGlass

StatBraidSmooth

StatBraidContour
</code></pre>


<h3>Format</h3>

<p>An object of class <code>StatBraid</code> (inherits from <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>
<p>An object of class <code>StatBraidGlass</code> (inherits from <code>StatBraid</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 3.
</p>
<p>An object of class <code>StatBraidSmooth</code> (inherits from <code>StatBraid</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>
<p>An object of class <code>StatBraidContour</code> (inherits from <code>StatContour</code>, <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 5.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggproto">ggproto()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
