<!DOCTYPE html><html lang="en"><head><title>Help for package smcryptoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smcryptoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sm2_encrypt'><p>SM2 Encrypt/Decrypt</p></a></li>
<li><a href='#sm2_encrypt_asna1'><p>SM2 Encrypt/Decrypt - asn.1</p></a></li>
<li><a href='#sm2_encrypt_c1c2c3'><p>SM2 Encrypt/Decrypt - c1c2c3</p></a></li>
<li><a href='#sm2_encrypt_hex'><p>SM2 Encrypt/Decrypt - hex and base64</p></a></li>
<li><a href='#sm2_encrypt_to_file'><p>SM2 Encrypt/Decrypt - file</p></a></li>
<li><a href='#sm2_gen_keypair'><p>SM2 Key Pair</p></a></li>
<li><a href='#sm2_keyexchange_1ab'><p>SM2 Key Exchange</p></a></li>
<li><a href='#sm2_sign'><p>SM2 Sign/Verify</p></a></li>
<li><a href='#sm3_hash'><p>SM3 Hash</p></a></li>
<li><a href='#sm4_encrypt_ecb'><p>SM4 Encrypt/Decrypt</p></a></li>
<li><a href='#sm4_encrypt_ecb_base64'><p>SM4 Encrypt/Decrypt - hex and base64</p></a></li>
<li><a href='#sm4_encrypt_ecb_to_file'><p>SM4 Encrypt/Decrypt - file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ShangMi(SM) Cryptographic Algorithms(SM2/SM3/SM4)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Bindings to 'smcrypto' <a href="https://github.com/zhuobie/smcrypto">https://github.com/zhuobie/smcrypto</a>: a 'Rust'
    implementation of China's Standards of Encryption Algorithms, which is usually 
    called 'ShangMi(SM)' algorithms. It contains 'SM3' message digest algorithm, 
    'SM2' asymmetric encryption algorithm and 'SM4' symmetric encryption algorithm. 
    Users can do message hash, encrypt/decrypt, sign/verify, key exchange and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zhuobie/smcryptoR">https://github.com/zhuobie/smcryptoR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zhuobie/smcryptoR/issues">https://github.com/zhuobie/smcryptoR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Cargo (Rust's package manager), rustc</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 14:09:54 UTC; yumeng</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Meng Yu &lt;610074@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 19:10:02 UTC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Meng Yu <a href="https://orcid.org/0009-0005-9794-5522"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
</table>
<hr>
<h2 id='sm2_encrypt'>SM2 Encrypt/Decrypt</h2><span id='topic+sm2_encrypt'></span><span id='topic+sm2_decrypt'></span>

<h3>Description</h3>

<p>SM2 is an asymmetric encryption algorithm that can also be used to directly
encrypt data. Typically, A encrypts a file or data using the public key,
passes the ciphertext to B, and B decrypts it using the corresponding private key.
SM2 encryption and decryption are suitable for shorter texts only.
For larger files, the process can be very slow. According to the SM2 algorithm
usage specifications, the encrypted ciphertext needs to be ASN.1 encoded.
We provide the functions sm2_encrypt_asna1 and sm2_decrypt_asna1 for this purpose.
Additionally, some scenarios use different arrangements of c1, c2, c3,
so we also offer the functions sm2_encrypt_c1c2c3 and sm2_decrypt_c1c2c3.
To facilitate the transmission of binary data, we also provide functions
to encrypt data into hexadecimal or base64 strings and decrypt from them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_encrypt(data, public_key)

sm2_decrypt(data, private_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_encrypt_+3A_data">data</code></td>
<td>
<p>data to be encrypted or decrypted, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_encrypt_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_encrypt">sm2_encrypt</a></dt><dd><p>returns a raw vector of the cipher text</p>
</dd>
<dt><a href="#topic+sm2_decrypt">sm2_decrypt</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## encrypt and decrypt - raw
keypair &lt;- sm2_gen_keypair()
private_key &lt;- keypair$private_key
public_key &lt;- keypair$public_key
data &lt;- 'abc' |&gt; charToRaw()
enc &lt;- sm2_encrypt(data, public_key)
enc
dec &lt;- sm2_decrypt(enc, private_key)
dec
</code></pre>

<hr>
<h2 id='sm2_encrypt_asna1'>SM2 Encrypt/Decrypt - asn.1</h2><span id='topic+sm2_encrypt_asna1'></span><span id='topic+sm2_decrypt_asna1'></span>

<h3>Description</h3>

<p>According to the usage specifications of the SM2 algorithm, the encrypted
data should be encoded using ASN.1, specifically including XCoordinate,
YCoordinate, HASH, and CipherText. Among them, XCoordinate and YCoordinate
each occupy 32 bytes, HASH occupies 32 bytes, and CipherText is the same
length as the plaintext, plus a one-byte &quot;04&quot; identifier. After SM2
encryption and ASN.1 encoding, the ciphertext data will be 97 bytes longer
than the original plaintext data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_encrypt_asna1(data, public_key)

sm2_decrypt_asna1(data, private_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_encrypt_asna1_+3A_data">data</code></td>
<td>
<p>data to be encrypted or decrypted, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_encrypt_asna1_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_asna1_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_encrypt_asna1">sm2_encrypt_asna1</a></dt><dd><p>returns a raw vector of the cipher text in the asn.1 encoding</p>
</dd>
<dt><a href="#topic+sm2_decrypt_asna1">sm2_decrypt_asna1</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## encrypt and decrypt as asn.1
keypair &lt;- sm2_gen_keypair()
private_key &lt;- keypair$private_key
public_key &lt;- keypair$public_key
data &lt;- 'abc' |&gt; charToRaw()
enc &lt;- sm2_encrypt_asna1(data, public_key)
enc
dec &lt;- sm2_decrypt_asna1(enc, private_key)
dec
</code></pre>

<hr>
<h2 id='sm2_encrypt_c1c2c3'>SM2 Encrypt/Decrypt - c1c2c3</h2><span id='topic+sm2_encrypt_c1c2c3'></span><span id='topic+sm2_decrypt_c1c2c3'></span>

<h3>Description</h3>

<p>The result of SM2 asymmetric encryption consists of three parts: C1, C2, and C3.
Among them, C1 is the elliptic curve point calculated based on a generated
random number, C2 is the ciphertext data, and C3 is the digest value of SM3.
Regarding the two modes of C1C2C3 and C1C3C2, the original Chinese national
standard specified the order of C1C2C3, while the new standard follows the
order of C1C3C2. These two different order modes are mainly designed to
facilitate the parsing and processing of SM2 encryption results across
different systems and environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_encrypt_c1c2c3(data, public_key)

sm2_decrypt_c1c2c3(data, private_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_encrypt_c1c2c3_+3A_data">data</code></td>
<td>
<p>data to be encrypted or decrypted, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_encrypt_c1c2c3_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_c1c2c3_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_encrypt_c1c2c3">sm2_encrypt_c1c2c3</a></dt><dd><p>returns a raw vector of the cipher text in the order of c1c2c3</p>
</dd>
<dt><a href="#topic+sm2_decrypt_c1c2c3">sm2_decrypt_c1c2c3</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## encrypt and decrypt as c1c2c3
keypair &lt;- sm2_gen_keypair()
private_key &lt;- keypair$private_key
public_key &lt;- keypair$public_key
data &lt;- 'abc' |&gt; charToRaw()
enc &lt;- sm2_encrypt_c1c2c3(data, public_key)
enc
dec &lt;- sm2_decrypt_c1c2c3(enc, private_key)
dec
</code></pre>

<hr>
<h2 id='sm2_encrypt_hex'>SM2 Encrypt/Decrypt - hex and base64</h2><span id='topic+sm2_encrypt_hex'></span><span id='topic+sm2_decrypt_hex'></span><span id='topic+sm2_encrypt_base64'></span><span id='topic+sm2_decrypt_base64'></span>

<h3>Description</h3>

<p>For ease of use, we have provided functions to encrypt data into hex or
base64 format and decrypt them from these formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_encrypt_hex(data, public_key)

sm2_decrypt_hex(data, private_key)

sm2_encrypt_base64(data, public_key)

sm2_decrypt_base64(data, private_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_encrypt_hex_+3A_data">data</code></td>
<td>
<p>for encrypt, data is a raw vector, for decrypt, data is a hex or base64 string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_hex_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_hex_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_encrypt_hex">sm2_encrypt_hex</a></dt><dd><p>returns a hex string of the cipher text</p>
</dd>
<dt><a href="#topic+sm2_decrypt_hex">sm2_decrypt_hex</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
<dt><a href="#topic+sm2_encrypt_base64">sm2_encrypt_base64</a></dt><dd><p>returns a base64 string of the cipher text</p>
</dd>
<dt><a href="#topic+sm2_decrypt_base64">sm2_decrypt_base64</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## encrypt and decrypt from hex string
keypair &lt;- sm2_gen_keypair()
private_key &lt;- keypair$private_key
public_key &lt;- keypair$public_key
data &lt;- 'abc' |&gt; charToRaw()
enc &lt;- sm2_encrypt_hex(data, public_key)
enc
dec &lt;- sm2_decrypt_hex(enc, private_key)
dec
enc &lt;- sm2_encrypt_base64(data, public_key)
enc
dec &lt;- sm2_decrypt_base64(enc, private_key)
dec
</code></pre>

<hr>
<h2 id='sm2_encrypt_to_file'>SM2 Encrypt/Decrypt - file</h2><span id='topic+sm2_encrypt_to_file'></span><span id='topic+sm2_decrypt_from_file'></span>

<h3>Description</h3>

<p>For ease of use, we have provided functions to encrypt or decrypt data directly from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_encrypt_to_file(data, enc_file, public_key)

sm2_decrypt_from_file(dec_file, private_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_encrypt_to_file_+3A_data">data</code></td>
<td>
<p>data to be encrypted, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_encrypt_to_file_+3A_enc_file">enc_file</code></td>
<td>
<p>the enctypted file to be saved</p>
</td></tr>
<tr><td><code id="sm2_encrypt_to_file_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_encrypt_to_file_+3A_dec_file">dec_file</code></td>
<td>
<p>the encrypted file to be loaded</p>
</td></tr>
<tr><td><code id="sm2_encrypt_to_file_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_encrypt_to_file">sm2_encrypt_to_file</a></dt><dd><p>returns nothing, an encrypted file will be saved in the specified path</p>
</dd>
<dt><a href="#topic+sm2_decrypt_from_file">sm2_decrypt_from_file</a></dt><dd><p>returns nothing, a decrypted file will be saved in the specified path</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## encrypt and decrypt from file
## Not run: 
  data &lt;- 'abc' |&gt; charToRaw()
  keypair &lt;- sm2_gen_keypair()
  private_key &lt;- keypair$private_key
  public_key &lt;- keypair$public_key
  sm2_encrypt_to_file(data, 'data.enc', public_key)
  sm2_decrypt_from_file('data.enc', private_key)

## End(Not run)

</code></pre>

<hr>
<h2 id='sm2_gen_keypair'>SM2 Key Pair</h2><span id='topic+sm2_gen_keypair'></span><span id='topic+sm2_pk_from_sk'></span><span id='topic+sm2_privkey_valid'></span><span id='topic+sm2_pubkey_valid'></span><span id='topic+sm2_keypair_from_pem_file'></span><span id='topic+sm2_keypair_to_pem_file'></span><span id='topic+sm2_pubkey_from_pem_file'></span><span id='topic+sm2_pubkey_to_pem_file'></span>

<h3>Description</h3>

<p>In the SM2 encryption algorithm, the private key and public key appear in pairs.
The private key is a 64-bit hexadecimal string, and the public key is a
128-bit hexadecimal string, excluding the &quot;04&quot; prefix at the beginning.
The public key is included in the private key and can be derived from the
private key. We use the public key for encryption, the private key for decryption,
the private key for signing, and the public key for verification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_gen_keypair()

sm2_pk_from_sk(private_key)

sm2_privkey_valid(private_key)

sm2_pubkey_valid(public_key)

sm2_keypair_from_pem_file(pem_file)

sm2_keypair_to_pem_file(private_key, pem_file)

sm2_pubkey_from_pem_file(pem_file)

sm2_pubkey_to_pem_file(public_key, pem_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_gen_keypair_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_gen_keypair_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_gen_keypair_+3A_pem_file">pem_file</code></td>
<td>
<p>local pem file path</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><a href="#topic+sm2_gen_keypair">sm2_gen_keypair</a></dt><dd><p>generate a ramdom key pair</p>
</dd>
<dt><a href="#topic+sm2_pk_from_sk">sm2_pk_from_sk</a></dt><dd><p>export public key from a private key</p>
</dd>
<dt><a href="#topic+sm2_privkey_valid">sm2_privkey_valid</a></dt><dd><p>check whether a private key is legal</p>
</dd>
<dt><a href="#topic+sm2_pubkey_valid">sm2_pubkey_valid</a></dt><dd><p>check whether a public key is legal</p>
</dd>
<dt><a href="#topic+sm2_keypair_from_pem_file">sm2_keypair_from_pem_file</a></dt><dd><p>import private key from a local pem file</p>
</dd>
<dt><a href="#topic+sm2_keypair_to_pem_file">sm2_keypair_to_pem_file</a></dt><dd><p>save a private key to a local pem file</p>
</dd>
<dt><a href="#topic+sm2_pubkey_from_pem_file">sm2_pubkey_from_pem_file</a></dt><dd><p>import public key from a local pem file</p>
</dd>
<dt><a href="#topic+sm2_pubkey_to_pem_file">sm2_pubkey_to_pem_file</a></dt><dd><p>save a public key to a local pem file</p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_gen_keypair">sm2_gen_keypair</a></dt><dd><p>returns a list contains a random private key and the corresponding public key</p>
</dd>
<dt><a href="#topic+sm2_pk_from_sk">sm2_pk_from_sk</a></dt><dd><p>returns a character string, the public key exported from a private key</p>
</dd>
<dt><a href="#topic+sm2_privkey_valid">sm2_privkey_valid</a></dt><dd><p>returns 1 if valid, 0 if invalid</p>
</dd>
<dt><a href="#topic+sm2_pubkey_valid">sm2_pubkey_valid</a></dt><dd><p>returns 1 if valid, 0 if invalid</p>
</dd>
<dt><a href="#topic+sm2_keypair_from_pem_file">sm2_keypair_from_pem_file</a></dt><dd><p>returns a list contains a random private key and the corresponding public key</p>
</dd>
<dt><a href="#topic+sm2_keypair_to_pem_file">sm2_keypair_to_pem_file</a></dt><dd><p>returns nothing, and a local file contains the keypair will be saved in the specified path</p>
</dd>
<dt><a href="#topic+sm2_pubkey_from_pem_file">sm2_pubkey_from_pem_file</a></dt><dd><p>returns a character string, the public key saved in the local file</p>
</dd>
<dt><a href="#topic+sm2_pubkey_to_pem_file">sm2_pubkey_to_pem_file</a></dt><dd><p>returns nothing, and a local file contains the public key will be saved in the specified path</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## generate a ramdom keypair
keypair &lt;- sm2_gen_keypair()
keypair$private_key
keypair$public_key
## export public key from private key
sm2_pk_from_sk(keypair$private_key)
## check whether the private key is legal
sm2_privkey_valid(keypair$private_key)
## check whether the public key is legal
sm2_pubkey_valid(keypair$public_key)
## Not run: 
  sm2_keypair_to_pem_file(keypair, 'keypair.pem')
  sm2_keypair_from_pem_file('keypair.pem')
  sm2_pubkey_to_pem_file(keypair$public_key, 'pubkey.pem')
  sm2_pubkey_from_pem_file('pubkey.pem')

## End(Not run)
</code></pre>

<hr>
<h2 id='sm2_keyexchange_1ab'>SM2 Key Exchange</h2><span id='topic+sm2_keyexchange_1ab'></span><span id='topic+sm2_keyexchange_2a'></span><span id='topic+sm2_keyexchange_2b'></span>

<h3>Description</h3>

<p>SM2 is an asymmetric encryption algorithm, therefore, it can also be used for
key agreement or key exchange. If A and B want to generate a recognized key
for encryption or authentication, this algorithm can ensure that the key
itself will not be transmitted through untrusted channels, and the private
keys of A and B will not be disclosed. Even if an attacker intercepts the
data exchanged by A and B, they cannot calculate the key agreed upon by A and B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_keyexchange_1ab(klen, id, private_key)

sm2_keyexchange_2a(id, private_key, private_key_r, recive_bytes)

sm2_keyexchange_2b(id, private_key, private_key_r, recive_bytes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_keyexchange_1ab_+3A_klen">klen</code></td>
<td>
<p>the key length, must be an integer</p>
</td></tr>
<tr><td><code id="sm2_keyexchange_1ab_+3A_id">id</code></td>
<td>
<p>id of A or B, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_keyexchange_1ab_+3A_private_key">private_key</code></td>
<td>
<p>private key of A or B represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_keyexchange_1ab_+3A_private_key_r">private_key_r</code></td>
<td>
<p>temp private_key of A or B</p>
</td></tr>
<tr><td><code id="sm2_keyexchange_1ab_+3A_recive_bytes">recive_bytes</code></td>
<td>
<p>for A or B, the recived data from B or A</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_keyexchange_1ab">sm2_keyexchange_1ab</a></dt><dd><p>returns a list, 'data' for the raw data sent to B(for A) or A(for B), 'private_key_r' for the temporary private key</p>
</dd>
<dt><a href="#topic+sm2_keyexchange_2a">sm2_keyexchange_2a</a></dt><dd><p>returns a list, 'k' for the key of length 'klen', 's12' for the sm3 hash in asn.1 encoding</p>
</dd>
<dt><a href="#topic+sm2_keyexchange_2b">sm2_keyexchange_2b</a></dt><dd><p>returns a list, 'k' for the key of length 'klen', 's12' for the sm3 hash in asn.1 encoding</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Step 1
klen &lt;- 16
id_a &lt;- "a@company.com" |&gt; charToRaw()
id_b &lt;- "b@company.com" |&gt; charToRaw()
private_key_a &lt;- sm2_gen_keypair()$private_key
private_key_b &lt;- sm2_gen_keypair()$private_key
step_1_a &lt;- sm2_keyexchange_1ab(klen, id_a, private_key_a)
step_1_b &lt;- sm2_keyexchange_1ab(klen, id_b, private_key_b)

## Step 2
step_2_a &lt;- sm2_keyexchange_2a(id_a, private_key_a, step_1_a$private_key_r, step_1_b$data)
step_2_b &lt;- sm2_keyexchange_2b(id_b, private_key_b, step_1_b$private_key_r, step_1_a$data)
step_2_a$k
step_2_b$k
</code></pre>

<hr>
<h2 id='sm2_sign'>SM2 Sign/Verify</h2><span id='topic+sm2_sign'></span><span id='topic+sm2_verify'></span><span id='topic+sm2_sign_to_file'></span><span id='topic+sm2_verify_from_file'></span>

<h3>Description</h3>

<p>SM2 is an asymmetric encryption algorithm, so it can be used to sign and verify
signatures of data. The purpose of doing this is to ensure the integrity of
the data and guarantee its authenticity. Typically, the data owner uses the
SM3 message digest algorithm to calculate the hash value and signs it with the
private key, generating signed data. Then the owner distributes the original
data and the signed data of the original data to the receiver. The receiver
uses the public key and the received signed data to perform the verification
operation. If the verification is successful, it is considered that the
received original data has not been tampered with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2_sign(id, data, private_key)

sm2_verify(id, data, sign, public_key)

sm2_sign_to_file(id, data, sign_file, private_key)

sm2_verify_from_file(id, data, sign_file, public_key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm2_sign_+3A_id">id</code></td>
<td>
<p>the signer's id, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_sign_+3A_data">data</code></td>
<td>
<p>orignal data, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm2_sign_+3A_private_key">private_key</code></td>
<td>
<p>a private key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_sign_+3A_sign">sign</code></td>
<td>
<p>sign data of the original data or file</p>
</td></tr>
<tr><td><code id="sm2_sign_+3A_public_key">public_key</code></td>
<td>
<p>a public key represented as a hexadecimal string</p>
</td></tr>
<tr><td><code id="sm2_sign_+3A_sign_file">sign_file</code></td>
<td>
<p>file path of the sign data to load</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm2_sign">sm2_sign</a></dt><dd><p>returns a raw vector contains the signature</p>
</dd>
<dt><a href="#topic+sm2_verify">sm2_verify</a></dt><dd><p>returns 1 if verified, 0 if not verified</p>
</dd>
<dt><a href="#topic+sm2_sign_to_file">sm2_sign_to_file</a></dt><dd><p>returns nothing, and a signature file will be saved in the specified path</p>
</dd>
<dt><a href="#topic+sm2_verify_from_file">sm2_verify_from_file</a></dt><dd><p>returns 1 if verified, 0 if not verified</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## sign and verify
id &lt;- charToRaw('yumeng@company.com')
data &lt;- charToRaw('abc')
keypair &lt;- sm2_gen_keypair()
private_key &lt;- keypair$private_key
public_key &lt;- keypair$public_key
sign_data &lt;- sm2_sign(id, data, private_key)
verify_result &lt;- sm2_verify(id, data, sign_data, public_key)
## Not run: 
  sm2_sign_to_file(id, data, 'sign_data.sig', private_key)
  sm2_verify_from_file(id, data, 'sign_data.sig', public_key)

## End(Not run)
</code></pre>

<hr>
<h2 id='sm3_hash'>SM3 Hash</h2><span id='topic+sm3_hash'></span><span id='topic+sm3_hash_string'></span><span id='topic+sm3_hash_file'></span>

<h3>Description</h3>

<p>SM3 is a cryptographic hash function designed for digital signatures and
other cryptographic applications. The output of SM3 is a 256-bit hash value,
which is commonly represented as a 64-hexadecimal digit string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm3_hash(msg)

sm3_hash_string(msg_string)

sm3_hash_file(file_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm3_hash_+3A_msg">msg</code></td>
<td>
<p>data to be hashed</p>
</td></tr>
<tr><td><code id="sm3_hash_+3A_msg_string">msg_string</code></td>
<td>
<p>a character string to be hashed</p>
</td></tr>
<tr><td><code id="sm3_hash_+3A_file_path">file_path</code></td>
<td>
<p>a local file to be hashed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the functions mentioned - <a href="#topic+sm3_hash">sm3_hash</a>, <a href="#topic+sm3_hash_string">sm3_hash_string</a>, and <a href="#topic+sm3_hash_file">sm3_hash_file</a> -
return a 64-character hexadecimal string representing the 256-bit hash value
generated by the SM3 cryptographic hash function. This hexadecimal string is
commonly used to represent the hash output in a human-readable format.
The <a href="#topic+sm3_hash">sm3_hash</a> function calculates the SM3 hash of a raw vector input and
returns a 64-character hexadecimal string. Similarly, <a href="#topic+sm3_hash_string">sm3_hash_string</a> takes
a string as input and also returns a 64-character hexadecimal string
representing the SM3 hash of the input string. The <a href="#topic+sm3_hash_file">sm3_hash_file</a> function,
on the other hand, takes a file path as input, reads the contents of the file,
calculates its SM3 hash, and returns the corresponding 64-character hexadecimal string.
</p>


<h3>Value</h3>

<p>a 64-characters hex string, which will be the sm3 hash result of the data, string or file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Raw vector hashing
msg &lt;- charToRaw('abc')
sm3_hash(msg)

## character string hashing
sm3_hash_string('abc')

## local file hashing
## Not run: 
  sm3_hash_file('test.docx')

## End(Not run)
</code></pre>

<hr>
<h2 id='sm4_encrypt_ecb'>SM4 Encrypt/Decrypt</h2><span id='topic+sm4_encrypt_ecb'></span><span id='topic+sm4_decrypt_ecb'></span><span id='topic+sm4_encrypt_cbc'></span><span id='topic+sm4_decrypt_cbc'></span>

<h3>Description</h3>

<p>The SM4 algorithm is a block symmetric encryption algorithm with a block size
and key length of 128 bits. Compared to the SM2 algorithm, it has higher
encryption and decryption efficiency and can be used to encrypt larger amounts
of data. SM4 supports both the ECB (Electronic Codebook) mode and the
CBC (Cipher Block Chaining) mode. The ECB mode is a simple block cipher
encryption mode that encrypts each data block independently without depending
on other blocks. The CBC mode, on the other hand, is a chained block cipher
encryption mode where the encryption of each block depends on the previous
ciphertext block. Therefore, it requires an initialization vector (IV) of
the same 128-bit length. The CBC mode provides higher security than the ECB mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm4_encrypt_ecb(input_data, key)

sm4_decrypt_ecb(input_data, key)

sm4_encrypt_cbc(input_data, key, iv)

sm4_decrypt_cbc(input_data, key, iv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm4_encrypt_ecb_+3A_input_data">input_data</code></td>
<td>
<p>data bytes to be encrypted, must be a raw vector</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_+3A_key">key</code></td>
<td>
<p>the key, must be a raw vector of length 16</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_+3A_iv">iv</code></td>
<td>
<p>the initialization vector, must be a raw vector of 16</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm4_encrypt_ecb">sm4_encrypt_ecb</a></dt><dd><p>returns a raw vector of the cipher text using ecb mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_ecb">sm4_decrypt_ecb</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
<dt><a href="#topic+sm4_encrypt_cbc">sm4_encrypt_cbc</a></dt><dd><p>returns a raw vector of the cipher text using cbc mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_cbc">sm4_decrypt_cbc</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## ecb mode
data &lt;- 'abc' |&gt; charToRaw()
key &lt;- '1234567812345678' |&gt; charToRaw()
iv &lt;- '0000000000000000' |&gt; charToRaw()
enc &lt;- sm4_encrypt_ecb(data, key)
enc
dec &lt;- sm4_decrypt_ecb(enc, key)
dec
## cbc mode
enc &lt;- sm4_encrypt_cbc(data, key, iv)
enc
dec &lt;- sm4_decrypt_cbc(enc, key, iv)
dec
</code></pre>

<hr>
<h2 id='sm4_encrypt_ecb_base64'>SM4 Encrypt/Decrypt - hex and base64</h2><span id='topic+sm4_encrypt_ecb_base64'></span><span id='topic+sm4_encrypt_ecb_hex'></span><span id='topic+sm4_decrypt_ecb_base64'></span><span id='topic+sm4_decrypt_ecb_hex'></span><span id='topic+sm4_encrypt_cbc_base64'></span><span id='topic+sm4_encrypt_cbc_hex'></span><span id='topic+sm4_decrypt_cbc_base64'></span><span id='topic+sm4_decrypt_cbc_hex'></span>

<h3>Description</h3>

<p>For ease of use, we have provided functions to encrypt data into hex or
base64 format and decrypt them from these formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm4_encrypt_ecb_base64(input_data, key)

sm4_encrypt_ecb_hex(input_data, key)

sm4_decrypt_ecb_base64(input_data, key)

sm4_decrypt_ecb_hex(input_data, key)

sm4_encrypt_cbc_base64(input_data, key, iv)

sm4_encrypt_cbc_hex(input_data, key, iv)

sm4_decrypt_cbc_base64(input_data, key, iv)

sm4_decrypt_cbc_hex(input_data, key, iv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm4_encrypt_ecb_base64_+3A_input_data">input_data</code></td>
<td>
<p>for encrypt, data is a raw vector, for decrypt, data is a hex or base64 string</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_base64_+3A_key">key</code></td>
<td>
<p>the key, must be a raw vector of length 16</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_base64_+3A_iv">iv</code></td>
<td>
<p>the initialization vector, must be a raw vector of 16</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm4_encrypt_ecb_base64">sm4_encrypt_ecb_base64</a></dt><dd><p>returns a base64 string of the cipher text using ecb mode</p>
</dd>
<dt><a href="#topic+sm4_encrypt_ecb_hex">sm4_encrypt_ecb_hex</a></dt><dd><p>returns a hex string of the cipher text using ecb mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_ecb_base64">sm4_decrypt_ecb_base64</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
<dt><a href="#topic+sm4_decrypt_ecb_hex">sm4_decrypt_ecb_hex</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
<dt><a href="#topic+sm4_encrypt_cbc_base64">sm4_encrypt_cbc_base64</a></dt><dd><p>returns a base64 string of the cipher text using cbc mode</p>
</dd>
<dt><a href="#topic+sm4_encrypt_cbc_hex">sm4_encrypt_cbc_hex</a></dt><dd><p>returns a hex string of the cipher text using cbc mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_cbc_base64">sm4_decrypt_cbc_base64</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
<dt><a href="#topic+sm4_decrypt_cbc_hex">sm4_decrypt_cbc_hex</a></dt><dd><p>returns a raw vector of the plain text</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## SM4 Encrypt/Decrypt - hex and base64
data &lt;- 'abc' |&gt; charToRaw()
key &lt;- '1234567812345678' |&gt; charToRaw()
iv &lt;- '0000000000000000' |&gt; charToRaw()
## ecb mode
enc &lt;- sm4_encrypt_ecb_base64(data, key)
enc
dec &lt;- sm4_decrypt_ecb_base64(enc, key)
dec
enc &lt;- sm4_encrypt_ecb_hex(data, key)
enc
dec &lt;- sm4_decrypt_ecb_hex(enc, key)
dec
## cbc mode
enc &lt;- sm4_encrypt_cbc_base64(data, key, iv)
enc
dec &lt;- sm4_decrypt_cbc_base64(enc, key, iv)
dec
enc &lt;- sm4_encrypt_cbc_hex(data, key, iv)
enc
dec &lt;- sm4_decrypt_cbc_hex(enc, key, iv)
dec
</code></pre>

<hr>
<h2 id='sm4_encrypt_ecb_to_file'>SM4 Encrypt/Decrypt - file</h2><span id='topic+sm4_encrypt_ecb_to_file'></span><span id='topic+sm4_decrypt_ecb_from_file'></span><span id='topic+sm4_encrypt_cbc_to_file'></span><span id='topic+sm4_decrypt_cbc_from_file'></span>

<h3>Description</h3>

<p>For ease of use, we have provided functions to encrypt or decrypt data directly from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm4_encrypt_ecb_to_file(input_file, output_file, key)

sm4_decrypt_ecb_from_file(input_file, output_file, key)

sm4_encrypt_cbc_to_file(input_file, output_file, key, iv)

sm4_decrypt_cbc_from_file(input_file, output_file, key, iv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm4_encrypt_ecb_to_file_+3A_input_file">input_file</code></td>
<td>
<p>the original file for encrypt, or the encrypted file for decrypt</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_to_file_+3A_output_file">output_file</code></td>
<td>
<p>the encrypted file for encrypt, or the decrypted file for decrypt</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_to_file_+3A_key">key</code></td>
<td>
<p>the key, must be a raw vector of length 16</p>
</td></tr>
<tr><td><code id="sm4_encrypt_ecb_to_file_+3A_iv">iv</code></td>
<td>
<p>the initialization vector, must be a raw vector of 16</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><a href="#topic+sm4_encrypt_ecb_to_file">sm4_encrypt_ecb_to_file</a></dt><dd><p>returns nothing, and an encrypted file will be saved in the specified path using ecb mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_ecb_from_file">sm4_decrypt_ecb_from_file</a></dt><dd><p>returns nothing, and a decrypted file will be saved in the specified path using ecb mode</p>
</dd>
<dt><a href="#topic+sm4_encrypt_cbc_to_file">sm4_encrypt_cbc_to_file</a></dt><dd><p>returns nothing, and an encrypted file will be saved in the specified path using cbc mode</p>
</dd>
<dt><a href="#topic+sm4_decrypt_cbc_from_file">sm4_decrypt_cbc_from_file</a></dt><dd><p>returns nothing, and a decrypted file will be saved in the specified path using cbc mode</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  key &lt;- '1234567812345678' |&gt; charToRaw()
  iv &lt;- '0000000000000000' |&gt; charToRaw()
  ## ecb mode
  sm4_encrypt_ecb_to_file('a.txt', 'a.enc', key)
  sm4_decrypt_ecb_from_file('a.enc', 'a.dec', key)
  ## cbc mode
  sm4_encrypt_cbc_to_file('a.txt', 'a.enc', key, iv)
  sm4_decrypt_cbc_from_file('a.enc', 'a.dec', key, iv)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
