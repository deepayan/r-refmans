<!DOCTYPE html><html><head><title>Help for package COCONUT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {COCONUT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#COCONUT-package'><p>COmbat CO-Normalization Using conTrols:</p>
COmbat CO-Normalization Using conTrols (COCONUT)</a></li>
<li><a href='#COCONUT'>
<p>COmbat CO-Normalization Using conTrols: COCONUT</p></a></li>
<li><a href='#combineCOCOoutput'>
<p>Combine COCONUT output from multiple objects into a single object</p></a></li>
<li><a href='#GSEs.test'>
<p>COCONUT test data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>COmbat CO-Normalization Using conTrols (COCONUT)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-09-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Timothy E Sweeney, MD, PhD [aut,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Timothy E Sweeney &lt;tes17@alumni.stanford.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>limma, parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for pooled analysis of microarray data by batch-correcting control samples, and then applying the derived correction parameters to non-control samples to obtain bias-free, inter-dataset corrected data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-19 02:35:09 UTC; timsweeney</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-19 07:55:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='COCONUT-package'>COmbat CO-Normalization Using conTrols:
COmbat CO-Normalization Using conTrols (COCONUT)
</h2><span id='topic+COCONUT-package'></span>

<h3>Description</h3>

<p>Allows for pooled analysis of microarray data by batch-correcting control samples, and then applying the derived correction parameters to non-control samples to obtain bias-free, inter-dataset corrected data.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> COCONUT</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> COmbat CO-Normalization Using conTrols (COCONUT)</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-09-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Timothy E Sweeney, MD, PhD [aut,cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Timothy E Sweeney &lt;tes17@alumni.stanford.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> stats</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> limma, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Enhances: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Allows for pooled analysis of microarray data by batch-correcting control samples, and then applying the derived correction parameters to non-control samples to obtain bias-free, inter-dataset corrected data.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2017-09-18 23:03:57 UTC; timsweeney</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
COCONUT                 COmbat CO-Normalization Using conTrols: COCONUT
COCONUT-package         COmbat CO-Normalization Using conTrols: COmbat
                        CO-Normalization Using conTrols (COCONUT)
GSEs.test               COCONUT test data
combineCOCOoutput       Combine COCONUT output from multiple objects
                        into a single object
</pre>
<p>Direct comparison of different microarray cohorts is impossible due both to inherent differences in underlying microarray platform and processing (technical) batch effects. In order to make use of these data, we need to co-normalize cohorts in such a way that (1) no bias is introduced (i.e., the normalization protocol should be blind to disease state); (2) there should be no change to the distribution of a gene within a study, and (3) a gene should show the same distributions between studies after normalization.
</p>
<p>We thus developed a modified version of the ComBat empiric Bayes normalization method (Johnson et al., Biostatistics 2007) to co-normalize control samples from different cohorts to allow for direct comparison of diseased samples from those same cohorts. We call this method COmbat CO-Normalization Using conTrols, or 'COCONUT' . COCONUT makes one strong assumption, which is that it forces controls/healthy patients from different cohorts to represent the same distribution.
</p>
<p>Briefly, all cohorts are split into the control and diseased components. The control components undergo ComBat co-normalization without covariates. The ComBat estimated parameters are obtained for each dataset for the control component, and then applied onto the diseased component. This forces the diseased components of all cohorts to be from the same background distribution, but retain their relative distance from the control component . Importantly, it also does not require any a priori knowledge of what type of disease is present in the diseased portion of the data. This method does have the notable requirement that controls/healthy patients are required to be present in a dataset in order for it to be pooled with other available data. Also, since control/healthy patients are set to be in the same distribution, it should only be used where such an assumption is reasonable (i.e., within the same tissue type, among the same species, etc.).
</p>
<p>COCONUT requires a list of objects with two components, $gene and $pheno. It is assumed that each item in the list represents a different study, and that these have already been internally batch-corrected and normalized as appropriate. It is assumed that data object structure $gene is a matrix (genes in rows, samples in columns) and that $pheno is a data.frame (samples in rows, variables in columns). Note that COCONUT (like ComBat) requires identical rownames (genes) across all batches; so probes data will not work unless all matrices are from the same manufacturer (common probe names).
</p>
<p>Also note that, unlike sva::ComBat, no co-variates are allowed.
</p>


<h3>Author(s)</h3>

<p>Timothy E Sweeney, MD, PhD [aut,cre]
</p>
<p>Maintainer: Timothy E Sweeney &lt;tes17@alumni.stanford.edu&gt;
</p>


<h3>References</h3>

<p>Sweeney TE et al., &quot;Robust classification of bacterial and viral infections via integrated host gene expression diagnostics&quot;, Science Translational Medicine, 2016
</p>

<hr>
<h2 id='COCONUT'>
COmbat CO-Normalization Using conTrols: COCONUT
</h2><span id='topic+COCONUT'></span>

<h3>Description</h3>

<p>COCONUT is a modified version of the ComBat empiric Bayes batch correction method (Johnson et al., Biostatistics 2007). It allows for batch correction of microarray datasets using control samples, which allows for diseased samples to be compared in pooled analysis. It makes a strong assumption that all controls come from the same distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COCONUT(GSEs, control.0.col, disease.col=NULL, byPlatform = FALSE, platformCol,
        par.prior=TRUE, itConv=1e-04, parallel=FALSE, mc.cores=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COCONUT_+3A_gses">GSEs</code></td>
<td>

<p>A list of data objects. See details below.
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_control.0.col">control.0.col</code></td>
<td>

<p>The column name in the $pheno data.frames (in GSEs) that notes which samples are controls. These samples MUST be marked with a 0 (zero).
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_disease.col">disease.col</code></td>
<td>

<p>Optional; if passed, refers to a column name in the $pheno data.frames (in GSEs) from which disease samples are returned. Only checks to remove missing (NA) samples from disease.col. Useful if there is a class of samples that need to be removed from the analysis (i.e., samples that are not controls but also not the disease of interest). If NOT supplied, COCONUT assumes all non-0 rows in control.0.col are diseased.
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_byplatform">byPlatform</code></td>
<td>

<p>Natively, byPlatform=F. If T, will group datasets by the batches found in platformCol.
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_platformcol">platformCol</code></td>
<td>

<p>If byPlatform=T, platformCol is the name of a column in $pheno data.frames (in GSEs) that indicates platform type. For instance, in the data example, each $pheno has a $platform_id which contains that dataset's GPL ID. Note: the microarray ID type supplied should be constant within a column (but of course can vary between datasets).
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_par.prior">par.prior</code></td>
<td>

<p>Whether to use parametric or non-parametric priors in empiric Bayes updates. Defaults to parametric. Non-parametric can be quite time-consuming.
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_itconv">itConv</code></td>
<td>

<p>Allows user to change threshold for iterative solver. For advanced users only.
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_parallel">parallel</code></td>
<td>

<p>Parallel derivation of priors. Uses parallel:mclapply, and so will not work on Windows machines (sorry).
</p>
</td></tr>
<tr><td><code id="COCONUT_+3A_mc.cores">mc.cores</code></td>
<td>

<p>If parallel=T, mc.cores should be set to the desired number of cores. Defaults to 1, so unless this is changed, functionality will be serial.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GSEs:
A list of (named) data objects. Each data object must have two components, $pheno (a data.frame of phenotype information with samples in rows and phenotype variables in columns), and $genes (a matrix of genes in rows and samples in columns). Further, the rownames of $pheno should match the colnames of $genes within each dataset. See the example data object for details.
</p>
<p>byPlatform:
Natively, COCONUT will assume each dataset in GSEs is a batch. However, there is enough similarity between microarrays (if the same normalization protocols are used) that each TYPE of microarray can be considered a batch. The advantage to this process is that datasets that share platforms can pool control samples, meaning datasets without controls can be potentially brought into the pool. The drawback is that there is still a substantial batch effect among datasets that used the same microarray type but were processed separately. Quantile normalization is used to overcome this to some degree, but it cannot be fixed altogether.
</p>


<h3>Value</h3>

<p>COCONUT returns a list of lists. In the main list:
</p>
<table>
<tr><td><code>COCONUTList</code></td>
<td>

<p>COCONUTList is itself a list, with the same names as the datasets in the input objects. Only diseased (or non-control) samples are passed back here (controls are dealt with separately, as below). The post-COCONUT-conormalized values are found in $COCONUTList[GSEname]$genes. See example below for single-line code to collapse these into a single matrix for pooled analysis.
</p>
</td></tr>
<tr><td><code>rawDiseaseList</code></td>
<td>

<p>rawDiseaseList is returned so that the user can make easy comparisons between pre- and post-COCONUT-co-normalized disease data. This contains the same data as the input object, except that all control samples have been removed.
</p>
</td></tr>
<tr><td><code>controlList</code></td>
<td>

<p>controlList returns the ComBat-normalized controls in $GSEs, and the derived empiric Bayes parameters in $bayesParams. It is generally assumed that these will be useful mainly for proving what COCONUT has done, etc., and not for downstream analyses. Note that this does NOT contain the non-co-normalized control data. To compare distributions, for example, you will need the original data object. See example below.
</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>COCONUT makes the strong assumption that the control data are from the same distribution. This may not always be an appropriate assumption. Users are advised to think carefully about how to apply COCONUT locally.
</p>


<h3>Author(s)</h3>

<p>Timothy E Sweeney, MD, PhD (tes17 [at] stanford [dot] edu)
</p>


<h3>References</h3>

<p>Sweeney TE et al., &quot;Robust classification of bacterial and viral infections via integrated host gene expression diagnostics&quot;, Science Translational Medicine, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+COCONUT-package">COCONUT-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GSEs.test)

## apply COCONUT to a very small test case
## (3 datasets with 10 patients and 2000 genes)
GSEs.COCONUT &lt;- COCONUT(GSEs=GSEs.test,
                        control.0.col="Healthy0.Sepsis1",
                        byPlatform=FALSE)

## make gene matrices
COCONUTgenes &lt;- Reduce(cbind, lapply(GSEs.COCONUT$COCONUTList, function(x) x$genes))
rawgenes &lt;- Reduce(cbind, lapply(GSEs.COCONUT$rawDiseaseList, function(x) x$genes))

### plot not run; (uncomment for plot)
### plot pre- and post-normalized data
# plot(x=1:ncol(COCONUTgenes), y=COCONUTgenes["ATP6V1B1", ], ylim=c(0,6), pch=20, col=1)
# points(x=1:ncol(rawgenes), y=rawgenes["ATP6V1B1", ], ylim=c(0,6), pch=20, col=2)


## compare distributions before and after COCONUT
classvec &lt;- GSEs.test$GSE28750$pheno$Healthy0.Sepsis1
prior &lt;- GSEs.test$GSE28750$genes
post &lt;- cbind(GSEs.COCONUT$controlList$GSEs$GSE28750$genes,
              GSEs.COCONUT$COCONUTList$GSE28750$genes)

prior.t.stats &lt;- apply(prior, 1, function(geneRow){
    geneByClass &lt;- split(geneRow, classvec)
    gene.test &lt;- t.test(geneByClass[[1]], geneByClass[[2]])
    gene.test$statistic
})

post.t.stats &lt;- apply(post, 1, function(geneRow){
    geneByClass &lt;- split(geneRow, classvec)
    gene.test &lt;- t.test(geneByClass[[1]], geneByClass[[2]])
    gene.test$statistic
})

summary(prior.t.stats-post.t.stats)

## thus gene distributions are preserved within datasets, but normalized
## between datasets

</code></pre>

<hr>
<h2 id='combineCOCOoutput'>
Combine COCONUT output from multiple objects into a single object
</h2><span id='topic+combineCOCOoutput'></span>

<h3>Description</h3>

<p>Combine COCONUT output from multiple objects into a single object. Makes pooled analysis of COCONUT-co-normalized data easier. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineCOCOoutput(COCONUT.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineCOCOoutput_+3A_coconut.out">COCONUT.out</code></td>
<td>

<p>Output from a call to COCONUT().
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output from COCONUT() can be a bit daunting, and the separate dataobjects remain separated by input cohort, plus are separated into control and diseased components. 
</p>


<h3>Value</h3>

<p>This function will knit all data together into a list with three parts: 
</p>
<table>
<tr><td><code>gene</code></td>
<td>

<p>contains a single matrix with all COCONUT-conormalized data (both control and disease)
</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>

<p>contains a single data.frame with all phenotype info from the input samples, but ONLY from those columns whose colnames are same across all cohorts
</p>
</td></tr>
<tr><td><code>class.cntl0.dis1</code></td>
<td>

<p>a binary vector that contains control/disease assignment for all columns in $genes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Timothy E Sweeney, MD, PhD (tes17 [at] stanford [dot] edu)
</p>


<h3>References</h3>

<p>Sweeney TE et al., &quot;Robust classification of bacterial and viral infections via integrated host gene expression diagnostics&quot;, 2016
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GSEs.test)

## apply COCONUT to a very small test case
## (3 datasets with 10 patients and 2000 genes)
GSEs.COCONUT &lt;- COCONUT(GSEs=GSEs.test,
                        control.0.col="Healthy0.Sepsis1",
                        byPlatform=FALSE)

## combine output
GSEs.COCO.combined &lt;- combineCOCOoutput(GSEs.COCONUT)
str(GSEs.COCO.combined)

</code></pre>

<hr>
<h2 id='GSEs.test'>
COCONUT test data
</h2><span id='topic+GSEs.test'></span>

<h3>Description</h3>

<p>A list of lists, specifically, a list of three data objects (GSEs) from the NIH GEO repository. Each has been converted from a probe matrix to a gene matrix, and subsetted to have only 10 samples (5 healthy and 5 diseased) with only 2000 genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GSEs.test)</code></pre>


<h3>Format</h3>

<p>A list of lists. Within the list, each named object consists of:
</p>

<dl>
<dt><code>genes</code></dt><dd><p>a numeric matrix, gene names in rows and sample IDs in columns.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>a data.frame, with sample IDs in rows and phenotype variables in columns.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data all come from the NIH GEO repository, and are subsets of their respective GSE IDs.
</p>


<h3>Source</h3>

<p>http://www.ncbi.nlm.nih.gov/geo/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see help(COCONUT) for further example
data(GSEs.test)
str(GSEs.test)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
