<!DOCTYPE html><html><head><title>Help for package netrankr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netrankr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netrankr-package'><p>netrankr: An R package for centrality and partial rankings in networks</p></a></li>
<li><a href='#aggregate_positions'><p>Quantification of (indirect) relations</p></a></li>
<li><a href='#approx_rank_expected'><p>Approximation of expected ranks</p></a></li>
<li><a href='#approx_rank_relative'><p>Approximation of relative rank probabilities</p></a></li>
<li><a href='#as.matrix.netrankr_full'><p>Extract probabilities from netrankr_full object</p></a></li>
<li><a href='#comparable_pairs'><p>Comparable pairs in a partial order</p></a></li>
<li><a href='#compare_ranks'><p>Count occurrences of pairs in rankings</p></a></li>
<li><a href='#dbces11'><p>dbces11 graph</p></a></li>
<li><a href='#dominance_graph'><p>Partial ranking as directed graph</p></a></li>
<li><a href='#exact_rank_prob'><p>Probabilistic centrality rankings</p></a></li>
<li><a href='#florentine_m'><p>Florentine family marriage network</p></a></li>
<li><a href='#get_rankings'><p>Rankings that extend a partial ranking</p></a></li>
<li><a href='#hyperbolic_index'><p>Hyperbolic (centrality) index</p></a></li>
<li><a href='#incomparable_pairs'><p>Incomparable pairs in a partial order</p></a></li>
<li><a href='#index_builder'><p>Centrality Index Builder</p></a></li>
<li><a href='#indirect_relations'><p>Indirect relations in a network</p></a></li>
<li><a href='#is_preserved'><p>Check preservation</p></a></li>
<li><a href='#majorization_gap'><p>Majorization gap</p></a></li>
<li><a href='#mcmc_rank_prob'><p>Estimate rank probabilities with Markov Chains</p></a></li>
<li><a href='#neighborhood_inclusion'><p>Neighborhood-inclusion preorder</p></a></li>
<li><a href='#plot_rank_intervals'><p>Plot rank intervals</p></a></li>
<li><a href='#plot.netrankr_full'><p>Plot netrankr_full object</p></a></li>
<li><a href='#plot.netrankr_interval'><p>plot netrankr_interval objects</p></a></li>
<li><a href='#plot.netrankr_mcmc'><p>Plot netrankr_mcmc object</p></a></li>
<li><a href='#positional_dominance'><p>Generalized Dominance Relations</p></a></li>
<li><a href='#print.netrankr_full'><p>Print netrankr_full object to terminal</p></a></li>
<li><a href='#print.netrankr_interval'><p>Print netrankr_interval object to terminal</p></a></li>
<li><a href='#print.netrankr_mcmc'><p>Print netrankr_mcmc object to terminal</p></a></li>
<li><a href='#rank_intervals'><p>Rank interval of nodes</p></a></li>
<li><a href='#spectral_gap'><p>Spectral gap of a graph</p></a></li>
<li><a href='#summary.netrankr_full'><p>Summary of a netrankr_full object</p></a></li>
<li><a href='#threshold_graph'><p>Random threshold graphs</p></a></li>
<li><a href='#transform_relations'><p>Transform indirect relations</p></a></li>
<li><a href='#transitive_reduction'><p>Transitive Reduction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing Partial Rankings in Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for centrality related analyses of networks. 
    While the package includes the possibility to build more than 20 indices, 
    its main focus lies on index-free assessment of centrality via partial 
    rankings obtained by neighborhood-inclusion or positional dominance. These 
    partial rankings can be analyzed with different methods, including 
    probabilistic methods like computing expected node ranks and relative 
    rank probabilities (how likely is it that a node is more central than another?).
    The methodology is described in depth in the vignettes and in
    Schoch (2018) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2017.12.003">doi:10.1016/j.socnet.2017.12.003</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schochastics/netrankr/">https://github.com/schochastics/netrankr/</a>,
<a href="https://schochastics.github.io/netrankr/">https://schochastics.github.io/netrankr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schochastics/netrankr/issues">https://github.com/schochastics/netrankr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 1.0.1), Rcpp (&ge; 0.12.8), Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, magrittr, testthat, shiny (&ge; 0.13), miniUI
(&ge; 0.1.1), rstudioapi (&ge; 0.5), covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 19:43:40 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Julian Müller [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='netrankr-package'>netrankr: An R package for centrality and partial rankings in networks</h2><span id='topic+netrankr-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>netrankr provides several functions to analyze partial rankings for network
centrality. The main focus lies on methods that do not necessarily rely on indices like degree,
betweenness or closeness. However, the package also provides more than 20 indices,
which can be constructed via a Rstudio addin.
</p>
<p>The package follows the philosophy, that centrality
can be decomposed in a series of micro steps. Starting from a network,
<a href="#topic+indirect_relations">indirect_relations</a> can be derived which can either be aggregated into an index with
<a href="#topic+aggregate_positions">aggregate_positions</a>, or alternatively turned into a partial ranking with <a href="#topic+positional_dominance">positional_dominance</a>.
The partial ranking can then be further analyzed with <a href="#topic+exact_rank_prob">exact_rank_prob</a>, to obtain
probabilistic centrality rankings.
</p>


<h3>Details</h3>

<p>Some features of the package are:
</p>

<ul>
<li><p> Working with the neighborhood inclusion preorder. This forms the bases
for any centrality analysis on undirected and unweighted graphs.
More details can be found in the dedicated vignette:
<code>vignette("neighborhood_inclusion",package = "netrankr")</code>
</p>
</li>
<li><p> Constructing graphs with a unique centrality ranking.
This class of graphs, known as threshold graphs, can be used to benchmark
centrality indices, since they only allow for one ranking of the nodes.
For more details consult the vignette: <code>vignette("threshold_graph",package = "netrankr")</code>
</p>
</li>
<li><p> Probabilistic centrality. Why apply a handful of indices and choosing
the one that fits best, when it is possible to analyze <strong>all</strong> centrality rankings at once?
The package includes several function to calculate rank probabilities of nodes
in a network. These include expected ranks and relative rank probabilities
(how likely is it that a node is more central than another?)
Consult <code>vignette("probabilistic_cent",package = "netrankr")</code> for more info.
</p>
</li></ul>

<p>The package provides several additional vignettes that explain the functionality
of netrankr and its conceptual ideas. See <code>browseVignettes(package = 'netrankr')</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Schoch <a href="mailto:david@schochastics.net">david@schochastics.net</a> (<a href="https://orcid.org/0000-0003-2952-4812">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Julian Müller <a href="mailto:julian.mueller@gess.ethz.ch">julian.mueller@gess.ethz.ch</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/schochastics/netrankr/">https://github.com/schochastics/netrankr/</a>
</p>
</li>
<li> <p><a href="https://schochastics.github.io/netrankr/">https://schochastics.github.io/netrankr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/schochastics/netrankr/issues">https://github.com/schochastics/netrankr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aggregate_positions'>Quantification of (indirect) relations</h2><span id='topic+aggregate_positions'></span>

<h3>Description</h3>

<p>Function to aggregate positions defined via indirect relations to construct centrality
scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_positions(tau_x, type = "sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_positions_+3A_tau_x">tau_x</code></td>
<td>
<p>Numeric matrix containing indirect relations calculated with <a href="#topic+indirect_relations">indirect_relations</a>.</p>
</td></tr>
<tr><td><code id="aggregate_positions_+3A_type">type</code></td>
<td>
<p>String indicating the type of aggregation to be used. See Details for options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predefined functions are mainly wrappers around base R functions.
type='sum', for instance, is equivalent to <code>rowSums()</code>. A non-base functions is
type='invsum' which calculates the inverse of type='sum'.
type='self' is mostly useful for walk based relations, e.g. to count closed walks.
Other self explanatory options are type='mean', type='min', type='max' and type='prod'.
</p>


<h3>Value</h3>

<p>Scores for the index defined by the indirect relation <code>tau_x</code> and the
used aggregation type.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+indirect_relations">indirect_relations</a>, <a href="#topic+transform_relations">transform_relations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(magrittr)

data("dbces11")
# degree
dbces11 %&gt;%
    indirect_relations(type = "adjacency") %&gt;%
    aggregate_positions(type = "sum")

# closeness centrality
dbces11 %&gt;%
    indirect_relations(type = "dist_sp") %&gt;%
    aggregate_positions(type = "invsum")

# betweenness centrality
dbces11 %&gt;%
    indirect_relations(type = "depend_sp") %&gt;%
    aggregate_positions(type = "sum")

# eigenvector centrality
dbces11 %&gt;%
    indirect_relations(type = "walks", FUN = walks_limit_prop) %&gt;%
    aggregate_positions(type = "sum")

# subgraph centrality
dbces11 %&gt;%
    indirect_relations(type = "walks", FUN = walks_exp) %&gt;%
    aggregate_positions(type = "self")
</code></pre>

<hr>
<h2 id='approx_rank_expected'>Approximation of expected ranks</h2><span id='topic+approx_rank_expected'></span>

<h3>Description</h3>

<p>Implements a variety of functions to approximate expected ranks
for partial rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_rank_expected(P, method = "lpom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_rank_expected_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="approx_rank_expected_+3A_method">method</code></td>
<td>
<p>String indicating which method to be used. see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>method</em> parameter can be set to
</p>

<dl>
<dt>lpom</dt><dd><p>local partial order model</p>
</dd>
<dt>glpom</dt><dd><p>extension of the local partial order model.</p>
</dd>
<dt>loof1</dt><dd><p>based on a connection with relative rank probabilities.</p>
</dd>
<dt>loof2</dt><dd><p>extension of the previous method.</p>
</dd>
</dl>

<p>Which of the above methods performs best depends on the structure and size of the partial
ranking. See <code>vignette("benchmarks",package="netrankr")</code> for more details.
</p>


<h3>Value</h3>

<p>A vector containing approximated expected ranks.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Brüggemann R., Simon, U., and Mey,S, 2005. Estimation of averaged
ranks by extended local partial order models. <em>MATCH Commun. Math.
Comput. Chem.</em>, 54:489-518.
</p>
<p>Brüggemann, R. and Carlsen, L., 2011. An improved estimation of averaged ranks
of partial orders. <em>MATCH Commun. Math. Comput. Chem.</em>,
65(2):383-414.
</p>
<p>De Loof, L., De Baets, B., and De Meyer, H., 2011. Approximation of Average
Ranks in Posets. <em>MATCH Commun. Math. Comput. Chem.</em>, 66:219-229.
</p>


<h3>See Also</h3>

<p><a href="#topic+approx_rank_relative">approx_rank_relative</a>, <a href="#topic+exact_rank_prob">exact_rank_prob</a>, <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, rep(0, 10)), 5, 5, byrow = TRUE)
# Exact result
exact_rank_prob(P)$expected.rank

approx_rank_expected(P, method = "lpom")
approx_rank_expected(P, method = "glpom")
</code></pre>

<hr>
<h2 id='approx_rank_relative'>Approximation of relative rank probabilities</h2><span id='topic+approx_rank_relative'></span>

<h3>Description</h3>

<p>Approximate relative rank probabilities <code class="reqn">P(rk(u)&lt;rk(v))</code>.
In a network context, <code class="reqn">P(rk(u)&lt;rk(v))</code> is the probability that u is
less central than v, given the partial ranking P.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_rank_relative(P, iterative = TRUE, num.iter = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_rank_relative_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="approx_rank_relative_+3A_iterative">iterative</code></td>
<td>
<p>Logical scalar if iterative approximation should be used.</p>
</td></tr>
<tr><td><code id="approx_rank_relative_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations to be used. defaults to 10 (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterative approach generally gives better approximations
than the non iterative, if only slightly. The default number of iterations
is based on the observation, that the approximation does not improve
significantly beyond this value. This observation, however, is based on
very small networks such that increasing it for large network may yield
better results. See <code>vignette("benchmarks",package="netrankr")</code> for more details.
</p>


<h3>Value</h3>

<p>a matrix containing approximation of relative rank probabilities.
<code>relative.rank[i,j]</code> is the probability that i is ranked lower than j
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>De Loof, K. and De Baets, B and De Meyer, H., 2008. Properties of mutual
rank probabilities in partially ordered sets. In <em>Multicriteria Ordering and
Ranking: Partial Orders, Ambiguities and Applied Issues</em>, 145-165.
</p>


<h3>See Also</h3>

<p><a href="#topic+approx_rank_expected">approx_rank_expected</a>, <a href="#topic+exact_rank_prob">exact_rank_prob</a>, <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, rep(0, 10)), 5, 5, byrow = TRUE)
P
approx_rank_relative(P, iterative = FALSE)
approx_rank_relative(P, iterative = TRUE)
</code></pre>

<hr>
<h2 id='as.matrix.netrankr_full'>Extract probabilities from netrankr_full object</h2><span id='topic+as.matrix.netrankr_full'></span>

<h3>Description</h3>

<p>extract probabilities as matrices from the result of an object obtained from <a href="#topic+exact_rank_prob">exact_rank_prob</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_full'
as.matrix(x, type = "rank", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.netrankr_full_+3A_x">x</code></td>
<td>
<p>A netrankr_full object</p>
</td></tr>
<tr><td><code id="as.matrix.netrankr_full_+3A_type">type</code></td>
<td>
<p>which probabilities to return. &quot;rank&quot; for rank probabilities, &quot;relative&quot; for relative rank probabilities and &quot;expected&quot; for expected rank probabilities and their variants</p>
</td></tr>
<tr><td><code id="as.matrix.netrankr_full_+3A_...">...</code></td>
<td>
<p>additional parameters for as.matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='comparable_pairs'>Comparable pairs in a partial order</h2><span id='topic+comparable_pairs'></span>

<h3>Description</h3>

<p>Calculates the fraction of comparable pairs in a partial order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparable_pairs(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparable_pairs_+3A_p">P</code></td>
<td>
<p>A partial order as matrix object, e.g. calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fraction of comparable pairs in <code>P</code>.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+incomparable_pairs">incomparable_pairs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(100, 0.1)
P &lt;- neighborhood_inclusion(g)
comparable_pairs(P)
# All pairs of vertices are comparable in a threshold graph
tg &lt;- threshold_graph(100, 0.3)
P &lt;- neighborhood_inclusion(g)
comparable_pairs(P)
</code></pre>

<hr>
<h2 id='compare_ranks'>Count occurrences of pairs in rankings</h2><span id='topic+compare_ranks'></span>

<h3>Description</h3>

<p>Counts the number of concordant, discordant and (left/right) ties between two rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_ranks(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_ranks_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="compare_ranks_+3A_y">y</code></td>
<td>
<p>A numeric vector with the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explicitly calculating the number of occurring cases is more robust
than using correlation indices as given in the <code>cor</code> function. Especially
left and right ties can significantly alter correlations.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>concordant</code></td>
<td>
<p>number of concordant pairs: <code>x[i]</code> &gt; <code>x[j]</code> and <code>y[i]</code> &gt; <code>y[j]</code></p>
</td></tr>
<tr><td><code>discordant</code></td>
<td>
<p>number of discordant pairs: <code>x[i]</code> &gt; <code>x[j]</code> and <code>y[i]</code> &lt; <code>y[j]</code></p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p>number of tied pairs:  <code>x[i]</code> == <code>x[j]</code> and <code>y[i]</code> == <code>y[j]</code></p>
</td></tr>
<tr><td><code>left</code></td>
<td>
<p>number of left ties: <code>x[i]</code> == <code>x[j]</code> and <code>y[i]</code> != <code>y[j]</code></p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>number of right ties: <code>x[i]</code> != <code>x[j]</code> and <code>y[i]</code> == <code>y[j]</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
tg &lt;- threshold_graph(100, 0.2)
compare_ranks(degree(tg), closeness(tg)) # only concordant pairs
compare_ranks(degree(tg), betweenness(tg)) # no discordant pairs
## Rank Correlation
cor(degree(tg), closeness(tg), method = "kendall") # 1
cor(degree(tg), betweenness(tg), method = "kendall") # not 1, although no discordant pairs
</code></pre>

<hr>
<h2 id='dbces11'>dbces11 graph</h2><span id='topic+dbces11'></span>

<h3>Description</h3>

<p>Smallest graph (11 nodes and 17 edges) where the centers according to (d)egree, (b)etweenness, (c)loseness, (e)igenvector centrality, and (s)ubgraph centrality are all different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbces11
</code></pre>


<h3>Format</h3>

<p>igraph object
</p>

<hr>
<h2 id='dominance_graph'>Partial ranking as directed graph</h2><span id='topic+dominance_graph'></span>

<h3>Description</h3>

<p>Turns a partial ranking into a directed graph. An edge (u,v) is
present if <code>P[u,v]=1</code>, meaning that u is dominated by v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominance_graph(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominance_graph_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Directed graph as an igraph object.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- threshold_graph(20, 0.1)
P &lt;- neighborhood_inclusion(g)
d &lt;- dominance_graph(P)
## Not run: 
plot(d)

## End(Not run)

# to reduce overplotting use transitive reduction
P &lt;- transitive_reduction(P)
d &lt;- dominance_graph(P)
## Not run: 
plot(d)

## End(Not run)
</code></pre>

<hr>
<h2 id='exact_rank_prob'>Probabilistic centrality rankings</h2><span id='topic+exact_rank_prob'></span>

<h3>Description</h3>

<p>Performs a complete and exact rank analysis of a given partial ranking.
This includes rank probabilities, relative rank probabilities and expected ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_rank_prob(P, only.results = TRUE, verbose = FALSE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_rank_prob_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="exact_rank_prob_+3A_only.results">only.results</code></td>
<td>
<p>Logical. return only results (default) or additionally
the ideal tree and lattice if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="exact_rank_prob_+3A_verbose">verbose</code></td>
<td>
<p>Logical. should diagnostics be printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="exact_rank_prob_+3A_force">force</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), stops the analysis if the partial
ranking has more than 40 elements and less than 0.4 comparable pairs.
Only change if you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function derives rank probabilities from a given partial ranking
(for instance returned by <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a> or <a href="#topic+positional_dominance">positional_dominance</a>). This includes the
calculation of expected ranks, (relative) rank probabilities and the number of possible rankings.
Note that the set of rankings grows exponentially in the number of elements and the exact
calculation becomes infeasible quite quickly and approximations need to be used.
See <code>vignette("benchmarks")</code> for guidelines and <a href="#topic+approx_rank_relative">approx_rank_relative</a>,
<a href="#topic+approx_rank_expected">approx_rank_expected</a>, and <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a> for approximative methods.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lin.ext</code></td>
<td>
<p>Number of possible rankings that extend <code>P</code>.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>Array giving the equivalence classes of <code>P</code>.</p>
</td></tr>
<tr><td><code>rank.prob</code></td>
<td>
<p>Matrix containing rank probabilities: <code>rank.prob[u,k]</code> is the probability that u has rank k.</p>
</td></tr>
<tr><td><code>relative.rank</code></td>
<td>
<p>Matrix containing relative rank probabilities: <code>relative.rank[u,v]</code> is the probability that u is ranked lower than v.</p>
</td></tr>
<tr><td><code>expected.rank</code></td>
<td>
<p>Expected ranks of nodes in any centrality ranking.</p>
</td></tr>
<tr><td><code>rank.spread</code></td>
<td>
<p>Standard deviation of the ranking probabilities.</p>
</td></tr>
<tr><td><code>topo.order</code></td>
<td>
<p>Random ranking used to build the lattice of ideals (if <code>only.results = FALSE</code>).</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>Adjacency list (incoming) of the tree of ideals (if <code>only.results = FALSE</code>).</p>
</td></tr>
<tr><td><code>lattice</code></td>
<td>
<p>Adjacency list (incoming) of the lattice of ideals (if <code>only.results = FALSE</code>).</p>
</td></tr>
<tr><td><code>ideals</code></td>
<td>
<p>List of order ideals (if <code>only.results = FALSE</code>).</p>
</td></tr>
</table>
<p>In all cases, higher numerical ranks imply a higher position in the ranking. That is,
the lowest ranked node has rank 1.
</p>


<h3>Author(s)</h3>

<p>David Schoch, Julian Müller
</p>


<h3>References</h3>

<p>De Loof, K. 2009. Efficient computation of rank probabilities in posets.
<em>Phd thesis</em>, Ghent University.
</p>
<p>De Loof, K., De Meyer, H. and De Baets, B., 2006. Exploiting the
lattice of ideals representation of a poset. <em>Fundamenta Informaticae</em>, 71(2,3):309-321.
</p>


<h3>See Also</h3>

<p><a href="#topic+approx_rank_relative">approx_rank_relative</a>, <a href="#topic+approx_rank_expected">approx_rank_expected</a>, <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, rep(0, 10)), 5, 5, byrow = TRUE)
P
res &lt;- exact_rank_prob(P)

# a warning is displayed if only one ranking is possible
tg &lt;- threshold_graph(20, 0.2)
P &lt;- neighborhood_inclusion(tg)
res &lt;- exact_rank_prob(P)
</code></pre>

<hr>
<h2 id='florentine_m'>Florentine family marriage network</h2><span id='topic+florentine_m'></span>

<h3>Description</h3>

<p>Florentine family marriage network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>florentine_m
</code></pre>


<h3>Format</h3>

<p>An igraph object containing marriage links of florentine families
</p>


<h3>References</h3>

<p>Padgett, J.F. and Ansell, C.K., 1993.
Robust Action and the Rise of the Medici, 1400-1434. <em>American Journal of Sociology</em>, <strong>98</strong>(6), 1259-1319.
</p>

<hr>
<h2 id='get_rankings'>Rankings that extend a partial ranking</h2><span id='topic+get_rankings'></span>

<h3>Description</h3>

<p>Returns all possible rankings that extend a partial ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rankings(data, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rankings_+3A_data">data</code></td>
<td>
<p>List as returned by <a href="#topic+exact_rank_prob">exact_rank_prob</a> when run with <code>only.results = FALSE</code></p>
</td></tr>
<tr><td><code id="get_rankings_+3A_force">force</code></td>
<td>
<p>Logical scalar. Stops function if the number of rankings is too large.
Only change to TRUE if you know what you are doing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>i</code>th row of the matrix contains the rank of node <code>i</code> in all possible rankings
that are in accordance with the partial ranking <code>P</code>. The lowest rank possible is
associated with <code>1</code>.
</p>


<h3>Value</h3>

<p>A matrix containing ranks of nodes in all possible rankings.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, rep(0, 10)), 5, 5, byrow = TRUE)
P
res &lt;- exact_rank_prob(P, only.results = FALSE)
get_rankings(res)
</code></pre>

<hr>
<h2 id='hyperbolic_index'>Hyperbolic (centrality) index</h2><span id='topic+hyperbolic_index'></span>

<h3>Description</h3>

<p>The hyperbolic index is an index that considers all closed
walks of even or odd length on induced neighborhoods of a vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperbolic_index(g, type = "odd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperbolic_index_+3A_g">g</code></td>
<td>
<p>igraph object.</p>
</td></tr>
<tr><td><code id="hyperbolic_index_+3A_type">type</code></td>
<td>
<p>string. 'even' if only even length walks should be considered. 'odd' (Default)
if only odd length walks should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyperbolic index is an illustrative index that should
not be used for any serious analysis. Its purpose is to show that with enough mathematical
trickery, any desired result can be obtained when centrality indices are used.
</p>


<h3>Value</h3>

<p>A vector containing centrality scores.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)

data("dbces11")
hyperbolic_index(dbces11, type = "odd")
hyperbolic_index(dbces11, type = "even")
</code></pre>

<hr>
<h2 id='incomparable_pairs'>Incomparable pairs in a partial order</h2><span id='topic+incomparable_pairs'></span>

<h3>Description</h3>

<p>Calculates the fraction of incomparable pairs in a partial order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incomparable_pairs(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incomparable_pairs_+3A_p">P</code></td>
<td>
<p>A partial order as matrix object, e.g. calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fraction of incomparable pairs in <code>P</code>.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+comparable_pairs">comparable_pairs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(100, 0.1)
P &lt;- neighborhood_inclusion(g)
comparable_pairs(P)
# All pairs of vertices are comparable in a threshold graph
tg &lt;- threshold_graph(100, 0.3)
P &lt;- neighborhood_inclusion(g)
comparable_pairs(P)
</code></pre>

<hr>
<h2 id='index_builder'>Centrality Index Builder</h2><span id='topic+index_builder'></span>

<h3>Description</h3>

<p>This shiny gadget can be used to build centrality indices based on specific indirect relations,
transformations and aggregation functions. use the dropdown menus to select
components that make up the index. Depending on your choices, some options
are not available at later stages. At the end, code is being inserted into
the current script to use the index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_builder()
</code></pre>


<h3>Value</h3>

<p>code to calculate the specified index.
</p>

<hr>
<h2 id='indirect_relations'>Indirect relations in a network</h2><span id='topic+indirect_relations'></span>

<h3>Description</h3>

<p>Derive indirect relations for a given network.
Observed relations, like presents or absence of a relation, are commonly not the center
of analysis, but are transformed in a new set of indirect relation like shortest path
distances among nodes. These transformations are usually an implicit step when centrality
indices are used. Making this step explicit gives more possibilities, for example
calculating partial centrality rankings with <a href="#topic+positional_dominance">positional_dominance</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirect_relations(
  g,
  type = "dist_sp",
  lfparam = NULL,
  dwparam = NULL,
  netflowmode = "",
  rspxparam = NULL,
  FUN = identity,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indirect_relations_+3A_g">g</code></td>
<td>
<p>igraph object. The network for which relations should be derived.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_type">type</code></td>
<td>
<p>String giving the relation to be calculated. See Details for options.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_lfparam">lfparam</code></td>
<td>
<p>Numeric parameter. Only used if type = &quot;dist_lf&quot;.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_dwparam">dwparam</code></td>
<td>
<p>Numeric parameter. Only used if type = &quot;dist_walk&quot;.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_netflowmode">netflowmode</code></td>
<td>
<p>String, one of raw, frac, or norm. Only used if type = &quot;depend_netflow&quot;.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_rspxparam">rspxparam</code></td>
<td>
<p>Numeric parameter. Only used if type = &quot;depend_rsps&quot; or type = &quot;depend_rspn&quot;.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_fun">FUN</code></td>
<td>
<p>A function that allows the transformation of relations. See Details.</p>
</td></tr>
<tr><td><code id="indirect_relations_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to FUN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>type</code> parameter has the following options.
</p>
<p><em>'adjacency'</em> returns the adjacency matrix of the network.
</p>
<p><em>'weights'</em> returns the weighted adjacency matrix of the network if an edge
attribute 'weight' is present.
</p>
<p><em>'dist_sp'</em> returns shortest path distances between all pairs of nodes.
</p>
<p><em>'depend_sp'</em> returns dyadic dependencies
</p>
<p style="text-align: center;"><code class="reqn">\delta(u,s) = \sum_{t \in V} \frac{\sigma(s,t|u)}{\sigma(s,t)}</code>
</p>

<p>where <code class="reqn">\sigma(s,t|u)</code> is the number of shortest paths from s to t that include u and
<code class="reqn">\sigma(s,t)</code> is the total number of shortest (s,t)-paths. This relation is used
for betweenness-like centrality indices.
</p>
<p><em>'walks'</em> returns walk counts between pairs of nodes, usually they are
weighted decreasingly in their lengths or other properties which can be done by adding
a function in <code>FUN</code>.  See <a href="#topic+transform_relations">transform_relations</a> for options.
</p>
<p><em>'dist_resist'</em> returns the resistance distance between all pairs of nodes.
</p>
<p><em>'dist_lf'</em> returns a logarithmic forest distance <code class="reqn">d_\alpha(s,t)</code>. The logarithmic forest
distances form a one-parametric family of distances, converging to shortest path distances as <code class="reqn">\alpha -&gt; 0</code>
and to the resistance distance as <code class="reqn">\alpha -&gt; \infty</code>. See (Chebotarev, 2011) for more details.
The parameter <code>lfparam</code> can be used to tune <code class="reqn">\alpha</code>.
</p>
<p><em>'dist_walk'</em> returns the walk distance <code class="reqn">d_\alpha^W(s,t)</code> between nodes. The walk distances form a one-parametric
family of distances, converging to shortest path distances as <code class="reqn">\alpha -&gt; 0</code> and to longest
walk distances for <code class="reqn">\alpha -&gt; \infty</code>. Walk distances contain the logarithmic forest
distances as a special case. See (Chebotarev, 2012) for more details.
</p>
<p><em>'dist_rwalk'</em> returns the expected length of a random walk between two nodes. For more
details see (Noh and Rieger, 2004)
</p>
<p><em>'depend_netflow'</em> returns dependencies based on network flow (See Freeman et al.,1991).
If <code>netflowmode="raw"</code>, the function returns
</p>
<p style="text-align: center;"><code class="reqn">\delta(u,s) = \sum_{t \in V} f(s,t,G)-f(s,t,G-v)</code>
</p>

<p>where f(s,t,G) is the maximum flow from s to t in G and f(s,t,G-v) in G without the node v.
For <code>netflowmode="frac"</code> it returns dependencies in the form, similar to shortest path dependencies:
</p>
<p style="text-align: center;"><code class="reqn">\delta(u,s) = \sum_{t \in V} \frac{f(s,t,G)-f(s,t,G-v)}{f(s,t,G)}</code>
</p>

<p><em>'depend_curflow'</em> returns pairwise dependencies based on current flow. The relation is
based on the same idea as 'depend_sp' and 'depend_netflow'. However, instead of considering
shortest paths or network flow, the current flow (or equivalent: random walks) between nodes
are of interest. See (Newman, 2005) for details.
</p>
<p><em>'depend_exp'</em> returns pairwise dependencies based on 'communicability':
</p>
<p style="text-align: center;"><code class="reqn">\delta(u,s)=\sum_{t \in V} \frac{exp(A)_{st}-exp(A+E(u))_{st}}{exp(A)_{st}},</code>
</p>

<p>where E(u) has nonzeros only in row and column u, and
in this row and column has -1 if A has +1. See (Estrada et al., 2009) for additional details.
</p>
<p><em>'depend_rsps'</em>. Simple randomized shortest path dependencies.
The simple RSP dependency of a node u with respect to absorbing paths from s to t,
is defined as the expected number of visits through u over all s-t-walks. The
parameter <code>rspxparam</code> is the &quot;inverse temperature parameter&quot;.
If it converges to infinity, only shortest paths are considered and the expected
number of visits to a node on a shortest path approaches the probability of
following that particular path. When the parameter converges to zero, then the
dependencies converge to the expected number of visits to a node over all absorbing
walks with respect to the unbiased random walk probabilities. This means for undirected networks,
that the relations converge to adjacency. See (Kivimäki et al., 2016) for details.
</p>
<p><em>'depend_rspn'</em> Net randomized shortest path dependencies.
The parameter <code>rspxparam</code> is the &quot;inverse temperature parameter&quot;. The asymptotic
for the infinity case are the same as for 'depend_rsps'. If the parameter approaches zero, then
it converges to 'depend_curflow'. The net randomized shortest path dependencies
are closely related to the random walk interpretation of current flows.
See (Kivimäki et al., 2016) for technical details.
</p>
<p>The function <code>FUN</code> is used to transform the indirect
relation. See <a href="#topic+transform_relations">transform_relations</a> for predefined functions and additional help.
</p>


<h3>Value</h3>

<p>A matrix containing indirect relations in a network.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Chebotarev, P., 2012. The walk distances in graphs. <em>Discrete Applied Mathematics</em>, 160(10), pp.1484-1500.
</p>
<p>Chebotarev, P., 2011. A class of graph-geodetic distances generalizing the shortest-path and
the resistance distances. <em>Discrete Applied Mathematics</em> 159,295-302.
</p>
<p>Noh, J.D. and Rieger, H., 2004. Random walks on complex networks. <em>Physical Review Letters</em>, 92(11), p.118701.
</p>
<p>Freeman, L.C., Borgatti, S.P., and White, D.R., 1991.
Centrality in Valued Graphs: A Measure of Betweenness Based on Network Flow. <em>Social Networks</em> 13(2), 141-154.
</p>
<p>Newman, M.E., 2005. A measure of betweenness centrality based on random walks. <em>Social Networks</em>, 27(1), pp.39-54.
</p>
<p>Estrada, E., Higham, D.J., and Hatano, N., 2009.
Communicability betweenness in complex networks. <em>Physica A</em> 388,764-774.
</p>
<p>Kivimäki, I., Lebichot, B., Saramäki, J., and Saerens, M., 2016.
Two betweenness centrality measures based on Randomized Shortest Paths
<em>Scientific Reports</em> 6: 19668
</p>


<h3>See Also</h3>

<p><a href="#topic+aggregate_positions">aggregate_positions</a> to build centrality indices, <a href="#topic+positional_dominance">positional_dominance</a> to derive dominance relations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
data("dbces11")

# shortest path distances
D &lt;- indirect_relations(dbces11, type = "dist_sp")

# inverted shortest path distances
D &lt;- indirect_relations(dbces11, type = "dist_sp", FUN = dist_inv)

# shortes path dependencies (used for betweenness)
D &lt;- indirect_relations(dbces11, type = "depend_sp")

# walks attenuated exponentially by their length
W &lt;- indirect_relations(dbces11, type = "walks", FUN = walks_exp)
</code></pre>

<hr>
<h2 id='is_preserved'>Check preservation</h2><span id='topic+is_preserved'></span>

<h3>Description</h3>

<p>Checks if a partial ranking is preserved in the ranking induced by <code>scores</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_preserved(P, scores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_preserved_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="is_preserved_+3A_scores">scores</code></td>
<td>
<p>Numeric vector containing the scores of a centrality index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for a score vector to preserve a partial ranking, the following
condition must be fulfilled:
<code>P[u,v]==1 &amp; scores[i]&lt;=scores[j]</code>.
</p>


<h3>Value</h3>

<p>Logical scaler whether <code>scores</code> preserves the relations in <code>P</code>.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
# standard measures of centrality preserve the neighborhood inclusion preorder
data("dbces11")
P &lt;- neighborhood_inclusion(dbces11)

is_preserved(P, degree(dbces11))
is_preserved(P, betweenness(dbces11))
is_preserved(P, closeness(dbces11))
</code></pre>

<hr>
<h2 id='majorization_gap'>Majorization gap</h2><span id='topic+majorization_gap'></span>

<h3>Description</h3>

<p>Calculates the (normalized) majorization gap of an undirected graph.
The majorization gap indicates how far the degree sequence of a graph is
from a degree sequence of a <a href="#topic+threshold_graph">threshold_graph</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>majorization_gap(g, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="majorization_gap_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="majorization_gap_+3A_norm">norm</code></td>
<td>
<p><code>True</code> (Default) if the normalized majorization gap should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance is measured by the number of <em>reverse unit
transformations</em> necessary to turn the degree sequence into a threshold sequence.
First, the <em>corrected conjugated degree sequence</em> d' is calculated from the degree sequence d as follows:
</p>
<p style="text-align: center;"><code class="reqn">d'_k= |\{ i : i&lt;k \land d_i\geq k-1 \} | +
| \{ i : i&gt;k \land d_i\geq k \} |.</code>
</p>

<p>the majorization gap is then defined as
</p>
<p style="text-align: center;"><code class="reqn">1/2 \sum_{k=1}^n \max\{d'_k - d_k,0\}</code>
</p>

<p>The higher the value, the further away is a graph to be a threshold graph.
</p>


<h3>Value</h3>

<p>Majorization gap of an undirected graph.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Schoch, D., Valente, T. W. and Brandes, U., 2017. Correlations among centrality
indices and a class of uniquely ranked graphs. <em>Social Networks</em> <strong>50</strong>, 46–54.
</p>
<p>Arikati, S.R. and Peled, U.N., 1994. Degree sequences and majorization.
<em>Linear Algebra and its Applications</em>, <strong>199</strong>, 179-211.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- graph.star(5, "undirected")
majorization_gap(g) # 0 since star graphs are threshold graphs

g &lt;- sample_gnp(100, 0.15)
majorization_gap(g, norm = TRUE) # fraction of reverse unit transformation
majorization_gap(g, norm = FALSE) # number of reverse unit transformation
</code></pre>

<hr>
<h2 id='mcmc_rank_prob'>Estimate rank probabilities with Markov Chains</h2><span id='topic+mcmc_rank_prob'></span>

<h3>Description</h3>

<p>Performs a probabilistic rank analysis based on an almost uniform
sample of possible rankings that preserve a partial ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_rank_prob(P, rp = nrow(P)^3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_rank_prob_+3A_p">P</code></td>
<td>
<p>P A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="mcmc_rank_prob_+3A_rp">rp</code></td>
<td>
<p>Integer indicating the number of samples to be drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used instead of <a href="#topic+exact_rank_prob">exact_rank_prob</a>
if the number of elements in <code>P</code> is too large for an exact computation. As a rule of thumb,
the number of samples should be at least cubic in the number of elements in <code>P</code>.
See <code>vignette("benchmarks",package="netrankr")</code> for guidelines and benchmark results.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expected.rank</code></td>
<td>
<p>Estimated expected ranks of nodes</p>
</td></tr>
<tr><td><code>relative.rank</code></td>
<td>
<p>Matrix containing estimated relative rank probabilities:
<code>relative.rank[u,v]</code> is the probability that u is ranked lower than v.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Bubley, R. and Dyer, M., 1999. Faster random generation of linear extensions.
<em>Discrete Mathematics</em>, <strong>201</strong>(1):81-88
</p>


<h3>See Also</h3>

<p><a href="#topic+exact_rank_prob">exact_rank_prob</a>, <a href="#topic+approx_rank_relative">approx_rank_relative</a>, <a href="#topic+approx_rank_expected">approx_rank_expected</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("florentine_m")
P &lt;- neighborhood_inclusion(florentine_m)
res &lt;- exact_rank_prob(P)
mcmc &lt;- mcmc_rank_prob(P, rp = vcount(g)^3)

# mean absolute error (expected ranks)
mean(abs(res$expected.rank - mcmc$expected.rank))

## End(Not run)
</code></pre>

<hr>
<h2 id='neighborhood_inclusion'>Neighborhood-inclusion preorder</h2><span id='topic+neighborhood_inclusion'></span>

<h3>Description</h3>

<p>Calculates the neighborhood-inclusion preorder of an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood_inclusion(g, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhood_inclusion_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="neighborhood_inclusion_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to create a sparse matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neighborhood-inclusion is defined as
</p>
<p style="text-align: center;"><code class="reqn">N(u)\subseteq N[v]</code>
</p>

<p>where <code class="reqn">N(u)</code> is the neighborhood of <code class="reqn">u</code> and <code class="reqn">N[v]=N(v)\cup \lbrace v\rbrace</code> is the closed neighborhood of <code class="reqn">v</code>.
<code class="reqn">N(u) \subseteq N[v]</code> implies that <code class="reqn">c(u) \leq c(v)</code>,
where <code class="reqn">c</code> is a centrality index based on a specific path algebra. Indices
falling into this category are closeness (and variants), betweenness
(and variants) as well as many walk-based indices (eigenvector and subgraph
centrality, total communicability,...).
</p>


<h3>Value</h3>

<p>The neighborhood-inclusion preorder of <code>g</code> as matrix object. <code>P[u,v]=1</code> if <code class="reqn">N(u)\subseteq N[v]</code>
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Schoch, D. and Brandes, U., 2016. Re-conceptualizing centrality in social networks.
<em>European Journal of Applied Mathematics</em> 27(6), 971-985.
</p>
<p>Brandes, U. Heine, M., Müller, J. and Ortmann, M., 2017.
Positional Dominance: Concepts and Algorithms.
<em>Conference on Algorithms and Discrete Applied Mathematics</em>, 60-71.
</p>


<h3>See Also</h3>

<p><a href="#topic+positional_dominance">positional_dominance</a>, <a href="#topic+exact_rank_prob">exact_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
# the neighborhood inclusion preorder of a star graph is complete
g &lt;- graph.star(5, "undirected")
P &lt;- neighborhood_inclusion(g)
comparable_pairs(P)

# the same holds for threshold graphs
tg &lt;- threshold_graph(50, 0.1)
P &lt;- neighborhood_inclusion(tg)
comparable_pairs(P)

# standard centrality indices preserve neighborhood-inclusion
data("dbces11")
P &lt;- neighborhood_inclusion(dbces11)

is_preserved(P, degree(dbces11))
is_preserved(P, closeness(dbces11))
is_preserved(P, betweenness(dbces11))
</code></pre>

<hr>
<h2 id='plot_rank_intervals'>Plot rank intervals</h2><span id='topic+plot_rank_intervals'></span>

<h3>Description</h3>

<p>This function is deprecated. Use <code>plot(rank_intervals(P))</code> instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rank_intervals(P, cent.df = NULL, ties.method = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rank_intervals_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
<tr><td><code id="plot_rank_intervals_+3A_cent.df">cent.df</code></td>
<td>
<p>A data frame containing centrality scores of indices (optional). See Details.</p>
</td></tr>
<tr><td><code id="plot_rank_intervals_+3A_ties.method">ties.method</code></td>
<td>
<p>String specifying how ties are treated in the base <code><a href="base.html#topic+rank">rank</a></code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+rank_intervals">rank_intervals</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
data("dbces11")
P &lt;- neighborhood_inclusion(dbces11)
## Not run: 
plot_rank_intervals(P)

## End(Not run)

# adding index based rankings
cent_scores &lt;- data.frame(
    degree = degree(dbces11),
    betweenness = round(betweenness(dbces11), 4),
    closeness = round(closeness(dbces11), 4),
    eigenvector = round(eigen_centrality(dbces11)$vector, 4)
)
## Not run: 
plot_rank_intervals(P, cent.df = cent_scores)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.netrankr_full'>Plot netrankr_full object</h2><span id='topic+plot.netrankr_full'></span>

<h3>Description</h3>

<p>Plots the result of an object obtained from <a href="#topic+exact_rank_prob">exact_rank_prob</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_full'
plot(x, icols = NULL, bcol = "grey66", ecol = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netrankr_full_+3A_x">x</code></td>
<td>
<p>A netrankr_full object</p>
</td></tr>
<tr><td><code id="plot.netrankr_full_+3A_icols">icols</code></td>
<td>
<p>a list of colors (an internal palette is used if missing)</p>
</td></tr>
<tr><td><code id="plot.netrankr_full_+3A_bcol">bcol</code></td>
<td>
<p>color used for the barcharts</p>
</td></tr>
<tr><td><code id="plot.netrankr_full_+3A_ecol">ecol</code></td>
<td>
<p>color used for errorbars</p>
</td></tr>
<tr><td><code id="plot.netrankr_full_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='plot.netrankr_interval'>plot netrankr_interval objects</h2><span id='topic+plot.netrankr_interval'></span>

<h3>Description</h3>

<p>Plots results from <a href="#topic+rank_intervals">rank_intervals</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_interval'
plot(x, cent_scores = NULL, cent_cols = NULL, ties.method = "min", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netrankr_interval_+3A_x">x</code></td>
<td>
<p>A netrank object</p>
</td></tr>
<tr><td><code id="plot.netrankr_interval_+3A_cent_scores">cent_scores</code></td>
<td>
<p>A data frame containing centrality scores of indices (optional)</p>
</td></tr>
<tr><td><code id="plot.netrankr_interval_+3A_cent_cols">cent_cols</code></td>
<td>
<p>colors for centrality indices. If NULL a default palette is used. Length must be equal to columns in cent_scores.</p>
</td></tr>
<tr><td><code id="plot.netrankr_interval_+3A_ties.method">ties.method</code></td>
<td>
<p>how to treat ties in the rankings. see <a href="base.html#topic+rank">rank</a> for details</p>
</td></tr>
<tr><td><code id="plot.netrankr_interval_+3A_...">...</code></td>
<td>
<p>additional arguments to plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='plot.netrankr_mcmc'>Plot netrankr_mcmc object</h2><span id='topic+plot.netrankr_mcmc'></span>

<h3>Description</h3>

<p>Plots the result of an object obtained from <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_mcmc'
plot(x, icols = NULL, bcol = "grey66", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netrankr_mcmc_+3A_x">x</code></td>
<td>
<p>A netrankr_mcmc object</p>
</td></tr>
<tr><td><code id="plot.netrankr_mcmc_+3A_icols">icols</code></td>
<td>
<p>a list of colors (an internal)</p>
</td></tr>
<tr><td><code id="plot.netrankr_mcmc_+3A_bcol">bcol</code></td>
<td>
<p>color used for the barcharts</p>
</td></tr>
<tr><td><code id="plot.netrankr_mcmc_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='positional_dominance'>Generalized Dominance Relations</h2><span id='topic+positional_dominance'></span>

<h3>Description</h3>

<p>generalized dominance relations that can be computed on one and two mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positional_dominance(A, type = "one-mode", map = FALSE, benefit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positional_dominance_+3A_a">A</code></td>
<td>
<p>Matrix containing attributes or relations, for instance calculated by <a href="#topic+indirect_relations">indirect_relations</a>.</p>
</td></tr>
<tr><td><code id="positional_dominance_+3A_type">type</code></td>
<td>
<p>A string which is either 'one-mode' (Default) if <code>A</code> is a regular one-mode network
or 'two-mode' if <code>A</code> is a general data matrix.</p>
</td></tr>
<tr><td><code id="positional_dominance_+3A_map">map</code></td>
<td>
<p>Logical scalar, whether rows can be sorted or not (Default). See Details.</p>
</td></tr>
<tr><td><code id="positional_dominance_+3A_benefit">benefit</code></td>
<td>
<p>Logical scalar, whether the attributes or relations are benefit or cost variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Positional dominance is a generalization of neighborhood-inclusion for
arbitrary network data. In the default case, it checks for all pairs <code class="reqn">u,v</code> if
<code class="reqn">A_{ut} \ge A_{vt}</code> holds for all <code class="reqn">t</code> if <code>benefit = TRUE</code> or
<code class="reqn">A_{ut} \le A_{vt}</code> holds for all <code class="reqn">t</code> if <code>benefit = FALSE</code>.
This form of dominance is referred to as <em>dominance under total heterogeneity</em>.
If <code>map=TRUE</code>, the rows of <code class="reqn">A</code> are sorted decreasingly (<code>benefit = TRUE</code>)
or increasingly (<code>benefit = FALSE</code>) and then the dominance condition is checked. This second
form of dominance is referred to as <em>dominance under total homogeneity</em>, while the
first is called <em>dominance under total heterogeneity</em>.
</p>


<h3>Value</h3>

<p>Dominance relations as matrix object. An entry <code style="white-space: pre;">&#8288;[u,v]&#8288;</code> is <code>1</code> if u is dominated by v.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Brandes, U., 2016. Network positions. <em>Methodological Innovations</em> 9,
2059799116630650.
</p>
<p>Schoch, D. and Brandes, U., 2016. Re-conceptualizing centrality in social networks.
<em>European Journal of Applied Mathematics</em> 27(6), 971-985.
</p>


<h3>See Also</h3>

<p><a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>, <a href="#topic+indirect_relations">indirect_relations</a>, <a href="#topic+exact_rank_prob">exact_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

data("dbces11")

P &lt;- neighborhood_inclusion(dbces11)
comparable_pairs(P)

# positional dominance under total heterogeneity
dist &lt;- indirect_relations(dbces11, type = "dist_sp")
D &lt;- positional_dominance(dist, map = FALSE, benefit = FALSE)
comparable_pairs(D)

# positional dominance under total homogeneity
D_map &lt;- positional_dominance(dist, map = TRUE, benefit = FALSE)
comparable_pairs(D_map)
</code></pre>

<hr>
<h2 id='print.netrankr_full'>Print netrankr_full object to terminal</h2><span id='topic+print.netrankr_full'></span>

<h3>Description</h3>

<p>Prints the result of an object obtained from <a href="#topic+exact_rank_prob">exact_rank_prob</a> to terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_full'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netrankr_full_+3A_x">x</code></td>
<td>
<p>A netrankr_full object</p>
</td></tr>
<tr><td><code id="print.netrankr_full_+3A_...">...</code></td>
<td>
<p>additional arguments to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='print.netrankr_interval'>Print netrankr_interval object to terminal</h2><span id='topic+print.netrankr_interval'></span>

<h3>Description</h3>

<p>Prints the result of an object obtained from <a href="#topic+rank_intervals">rank_intervals</a> to terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_interval'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netrankr_interval_+3A_x">x</code></td>
<td>
<p>A netrankr_interval object</p>
</td></tr>
<tr><td><code id="print.netrankr_interval_+3A_...">...</code></td>
<td>
<p>additional arguments to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='print.netrankr_mcmc'>Print netrankr_mcmc object to terminal</h2><span id='topic+print.netrankr_mcmc'></span>

<h3>Description</h3>

<p>Prints the result of an object obtained from <a href="#topic+mcmc_rank_prob">mcmc_rank_prob</a> to terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_mcmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netrankr_mcmc_+3A_x">x</code></td>
<td>
<p>A netrank object</p>
</td></tr>
<tr><td><code id="print.netrankr_mcmc_+3A_...">...</code></td>
<td>
<p>additional arguments to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='rank_intervals'>Rank interval of nodes</h2><span id='topic+rank_intervals'></span>

<h3>Description</h3>

<p>Calculate the maximal and minimal rank possible for each node
in any ranking that is in accordance with the partial ranking <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_intervals(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_intervals_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the returned <code>mid_point</code> is not the same as the expected
rank, for instance computed with <a href="#topic+exact_rank_prob">exact_rank_prob</a>.
It is simply the average of <code>min_rank</code> and <code>max_rank</code>. For exact rank probabilities
use <a href="#topic+exact_rank_prob">exact_rank_prob</a>.
</p>


<h3>Value</h3>

<p>An object of type netrankr_interval
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+exact_rank_prob">exact_rank_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, rep(0, 10)), 5, 5, byrow = TRUE)
rank_intervals(P)
</code></pre>

<hr>
<h2 id='spectral_gap'>Spectral gap of a graph</h2><span id='topic+spectral_gap'></span>

<h3>Description</h3>

<p>The spectral (or eigen) gap of a graph is the absolute
difference between the biggest and second biggest eigenvalue
of the adjacency matrix. To compare spectral gaps across networks, the fraction can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_gap(g, method = "frac")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_gap_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="spectral_gap_+3A_method">method</code></td>
<td>
<p>A string, either &quot;frac&quot; or &quot;abs&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral gap is bounded between 0 and 1 if <code>method="frac"</code>. The closer
the value to one, the bigger the gap.
</p>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The fractional spectral gap of a threshold graph is usually close to 1
g &lt;- threshold_graph(50, 0.3)
spectral_gap(g, method = "frac")
</code></pre>

<hr>
<h2 id='summary.netrankr_full'>Summary of a netrankr_full object</h2><span id='topic+summary.netrankr_full'></span>

<h3>Description</h3>

<p>Summarizes the result of an object obtained from <a href="#topic+exact_rank_prob">exact_rank_prob</a> to terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netrankr_full'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.netrankr_full_+3A_object">object</code></td>
<td>
<p>A netrankr_full object</p>
</td></tr>
<tr><td><code id="summary.netrankr_full_+3A_...">...</code></td>
<td>
<p>additional arguments to summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='threshold_graph'>Random threshold graphs</h2><span id='topic+threshold_graph'></span>

<h3>Description</h3>

<p>Constructs a random threshold graph.
A threshold graph is a graph where the neighborhood inclusion preorder is complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold_graph(n, p, bseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_graph_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="threshold_graph_+3A_p">p</code></td>
<td>
<p>The probability of inserting dominating vertices. Equates approximately
to the density of the graph. See Details.</p>
</td></tr>
<tr><td><code id="threshold_graph_+3A_bseq">bseq</code></td>
<td>
<p>(0,1)-vector a binary sequence that produces a threshold grah. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>n</code> and <code>p</code>, or <code>bseq</code> must be specified.
Threshold graphs can be constructed with a binary sequence. For each 0, an isolated
vertex is inserted and for each 1, a vertex is inserted that connects to all previously inserted
vertices. The probability of inserting a dominating vertices is controlled with parameter <code>p</code>.
If <code>bseq</code> is given instead, a threshold graph is constructed from that sequence.
An important property of threshold graphs is, that all centrality indices induce the same ranking.
</p>


<h3>Value</h3>

<p>A threshold graph as igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Mahadev, N. and Peled, U. N. , 1995. Threshold graphs and related topics.
</p>
<p>Schoch, D., Valente, T. W. and Brandes, U., 2017. Correlations among centrality
indices and a class of uniquely ranked graphs. <em>Social Networks</em> 50, 46–54.
</p>


<h3>See Also</h3>

<p><a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>, <a href="#topic+positional_dominance">positional_dominance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- threshold_graph(10, 0.3)
## Not run: 
plot(g)

# star graphs and complete graphs are threshold graphs
complete &lt;- threshold_graph(10, 1) # complete graph
plot(complete)

star &lt;- threshold_graph(10, 0) # star graph
plot(star)

## End(Not run)

# centrality scores are perfectly rank correlated
cor(degree(g), closeness(g), method = "kendall")
</code></pre>

<hr>
<h2 id='transform_relations'>Transform indirect relations</h2><span id='topic+transform_relations'></span><span id='topic+dist_2pow'></span><span id='topic+dist_inv'></span><span id='topic+dist_dpow'></span><span id='topic+dist_powd'></span><span id='topic+walks_limit_prop'></span><span id='topic+walks_exp'></span><span id='topic+walks_exp_even'></span><span id='topic+walks_exp_odd'></span><span id='topic+walks_attenuated'></span><span id='topic+walks_uptok'></span>

<h3>Description</h3>

<p>Mostly wrapper functions that can be used in conjunction
with <a href="#topic+indirect_relations">indirect_relations</a> to fine tune indirect relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_2pow(x)

dist_inv(x)

dist_dpow(x, alpha = 1)

dist_powd(x, alpha = 0.5)

walks_limit_prop(x)

walks_exp(x, alpha = 1)

walks_exp_even(x, alpha = 1)

walks_exp_odd(x, alpha = 1)

walks_attenuated(x, alpha = 1/max(x) * 0.99)

walks_uptok(x, alpha = 1, k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_relations_+3A_x">x</code></td>
<td>
<p>Matrix of relations.</p>
</td></tr>
<tr><td><code id="transform_relations_+3A_alpha">alpha</code></td>
<td>
<p>Potential weighting factor.</p>
</td></tr>
<tr><td><code id="transform_relations_+3A_k">k</code></td>
<td>
<p>For walk counts up to a certain length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predefined functions follow the naming scheme <code>relation_transformation</code>.
Predefined functions <code style="white-space: pre;">&#8288;walks_*&#8288;</code> are thus best used with type=&quot;walks&quot; in
<a href="#topic+indirect_relations">indirect_relations</a>. Theoretically, however, any transformation can be used with any relation.
The results might, however, not be interpretable.
</p>
<p>The following functions are implemented so far:
</p>
<p><code>dist_2pow</code> returns <code class="reqn">2^{-x}</code>
</p>
<p><code>dist_inv</code> returns <code class="reqn">1/x</code>
</p>
<p><code>dist_dpow</code> returns <code class="reqn">x^{-\alpha}</code> where <code class="reqn">\alpha</code> should be chosen greater than 0.
</p>
<p><code>dist_powd</code> returns <code class="reqn">\alpha^x</code> where <code class="reqn">\alpha</code> should be chosen between 0 and 1.
</p>
<p><code>walks_limit_prop</code> returns the limit proportion of walks between pairs of nodes. Calculating
rowSums of this relation will result in the principle eigenvector of the network.
</p>
<p><code>walks_exp</code> returns <code class="reqn">\sum_{k=0}^\infty \frac{A^k}{k!}</code>
</p>
<p><code>walks_exp_even</code> returns <code class="reqn">\sum_{k=0}^\infty \frac{A^{2k}}{(2k)!}</code>
</p>
<p><code>walks_exp_odd</code> returns <code class="reqn">\sum_{k=0}^\infty \frac{A^{2k+1}}{(2k+1)!}</code>
</p>
<p><code>walks_attenuated</code> returns <code class="reqn">\sum_{k=0}^\infty \alpha^k A^k</code>
</p>
<p><code>walks_uptok</code> returns <code class="reqn">\sum_{j=0}^k \alpha^j A^j</code>
</p>
<p>Walk based transformation are defined on the eigen decomposition of the
adjacency matrix using the fact that
</p>
<p style="text-align: center;"><code class="reqn">f(A)=Xf(\Lambda)X^T.</code>
</p>

<p>Care has to be taken when using user defined functions.
</p>


<h3>Value</h3>

<p>Transformed relations as matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='transitive_reduction'>Transitive Reduction</h2><span id='topic+transitive_reduction'></span>

<h3>Description</h3>

<p>Calculates the transitive reduction of a partial ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitive_reduction(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitive_reduction_+3A_p">P</code></td>
<td>
<p>A partial ranking as matrix object calculated with <a href="#topic+neighborhood_inclusion">neighborhood_inclusion</a>
or <a href="#topic+positional_dominance">positional_dominance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transitive reduction of <code>P</code>
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

g &lt;- threshold_graph(100, 0.1)
P &lt;- neighborhood_inclusion(g)
sum(P)

R &lt;- transitive_reduction(P)
sum(R)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
