<!DOCTYPE html><html><head><title>Help for package doFuture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {doFuture}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#doFuture'><p>doFuture: Foreach Parallel Adapter using Futures</p></a></li>
<li><a href='#+25dofuture+25'><p>Loop over a Foreach Expression using Futures</p></a></li>
<li><a href='#doFuture.options'><p>Options used by the doFuture adapter</p></a></li>
<li><a href='#makeChunks'><p>Create Chunks of Index Vectors</p></a></li>
<li><a href='#registerDoFuture'><p>Use the Foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> Adapter with Futures</p></a></li>
<li><a href='#withDoRNG'><p>Evaluates a foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> expression with the doRNG adapter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Use Foreach to Parallelize via the Future Framework</td>
</tr>
<tr>
<td>Depends:</td>
<td>foreach (&ge; 1.5.0), future (&ge; 1.32.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>future.apply, globals, iterators, parallel, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doRNG (&ge; 1.8.2), markdown, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'future' package provides a unifying parallelization framework for R that supports many parallel and distributed backends. The 'foreach' package provides a powerful API for iterating over an R expression in parallel. The 'doFuture' package brings the best of the two together. There are two alternative ways to use this package. The recommended approach is to use 'y &lt;- foreach(...) %dofuture% { ... }', which does not require using 'registerDoFuture()' and has many advantages over '%dopar%'. The alternative is the traditional 'foreach' approach by registering the 'foreach' adapter 'registerDoFuture()' and so that 'y &lt;- foreach(...) %dopar% { ... }' runs in parallelizes with the 'future' framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doFuture.futureverse.org">https://doFuture.futureverse.org</a>,
<a href="https://github.com/HenrikBengtsson/doFuture">https://github.com/HenrikBengtsson/doFuture</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/doFuture/issues">https://github.com/HenrikBengtsson/doFuture/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 06:58:45 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Bengtsson <a href="https://orcid.org/0000-0002-7579-5165"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-20 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='doFuture'>doFuture: Foreach Parallel Adapter using Futures</h2><span id='topic+doFuture'></span><span id='topic+doFuture-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">doFuture</span> package provides mechanisms for using the
<strong><a href="foreach.html#topic+foreach">foreach</a></strong> package together with the <strong><a href="future.html#topic+future">future</a></strong> package
such that <code>foreach()</code> parallelizes via <em>any</em> future backend.
</p>


<h3>Usage</h3>

<p>There are two alternative ways to use this package:
</p>

<ol>
<li> <p><code>y &lt;- foreach(...) %dofuture% { ... }</code>
</p>
</li>
<li> <p><code>y &lt;- foreach(...) %dopar% { ... }</code> with <code>registerDoFuture()</code>
</p>
</li></ol>

<p>The <em>first alternative</em> (recommended), which uses <code><a href="#topic++25dofuture+25">%dofuture%</a></code>, avoids
having to use <code>registerDoFuture()</code>.  The <code><a href="#topic++25dofuture+25">%dofuture%</a></code> operator provides
a more consistent behavior than <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>, e.g. there is a unique set of
foreach arguments instead of one per possible adapter.  Identification
of globals, random number generation (RNG), and error handling is
handled by the future ecosystem, just like with other map-reduce
solutions such as <strong><a href="https://cran.r-project.org/package=future.apply">future.apply</a></strong> and <strong><a href="https://cran.r-project.org/package=furrr">furrr</a></strong>.
An example is:
</p>
<div class="sourceCode r"><pre>library(doFuture)
plan(multisession)

y &lt;- foreach(x = 1:4, y = 1:10) %dofuture% {
  z &lt;- x + y
  slow_sqrt(z)
}
</pre></div>
<p>This alternative is the recommended way to let <code>foreach()</code> parallelize
via the future framework if you start out from scratch.
</p>
<p>See <code><a href="#topic++25dofuture+25">%dofuture%</a></code> for more details and examples on this approach.
</p>
<p>The <em>second alternative</em> is based on the traditional <strong>foreach</strong>
approach where one registers a foreach adapter to be used by <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>.
A popular adapter is <code>doParallel::registerDoParallel()</code>, which
parallelizes on the local machine using the <strong>parallel</strong> package.
This package provides <code>registerDoFuture()</code>, which parallelizes using
the <strong>future</strong> package, meaning any future-compliant parallel backend
can be used.
An example is:
</p>
<div class="sourceCode r"><pre>library(doFuture)
registerDoFuture()
plan(multisession)

y &lt;- foreach(x = 1:4, y = 1:10) %dopar% {
  z &lt;- x + y
  slow_sqrt(z)
}
</pre></div>
<p>This alternative is useful if you already have a lot of R code that
uses <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> and you just want to switch to using the future
framework for parallelization.  Using <code>registerDoFuture()</code> is also
useful when you wish to use the future framework with packages and
functions that uses <code>foreach()</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> internally,
e.g. <strong><a href="https://cran.r-project.org/package=caret">caret</a></strong>, <strong><a href="https://cran.r-project.org/package=plyr">plyr</a></strong>, <strong><a href="https://cran.r-project.org/package=NMF">NMF</a></strong>, and <strong><a href="https://cran.r-project.org/package=glmnet">glmnet</a></strong>.  It can
also be used to configure the Bioconductor <strong><a href="https://bioconductor.org/packages/BiocParallel/">BiocParallel</a></strong> package,
and any package that rely on it, to parallelize via the future
framework.
</p>
<p>See <code><a href="#topic+registerDoFuture">registerDoFuture()</a></code> for more details and examples on this approach.
</p>

<hr>
<h2 id='+25dofuture+25'>Loop over a Foreach Expression using Futures</h2><span id='topic++25dofuture+25'></span>

<h3>Description</h3>

<p>Loop over a Foreach Expression using Futures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreach %dofuture% expr
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25dofuture+2B25_+3A_foreach">foreach</code></td>
<td>
<p>A <code>foreach</code> object created by <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>
and <code><a href="foreach.html#topic+foreach">foreach::times()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B25dofuture+2B25_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a replacement for <code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code> of the <span class="pkg">foreach</span> package
that leverages the <span class="pkg">future</span> framework.
</p>
<p>When using <code style="white-space: pre;">&#8288;%dofuture%&#8288;</code>:
</p>

<ul>
<li><p> there is no need to use <code>registerDoFuture()</code>
</p>
</li>
<li><p> there is no need to use <code style="white-space: pre;">&#8288;%dorng%&#8288;</code> of the <strong>doRNG</strong> package
(but you need to specify <code>.options.future = list(seed = TRUE)</code>
whenever using random numbers in the <code>expr</code> expression)
</p>
</li>
<li><p> global variables and packages are identified automatically by
the <span class="pkg">future</span> framework
</p>
</li>
<li><p> errors are relayed as-is (with <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> they captured and modified)
</p>
</li></ul>



<h3>Value</h3>

<p>The value of the foreach call.
</p>


<h3>Global variables and packages</h3>

<p>When using <code style="white-space: pre;">&#8288;%dofuture%&#8288;</code>, the future framework identifies globals and
packages automatically (via static code inspection).  However, there
are cases where it fails to find some of the globals or packages. When
this happens, one can specify the <code><a href="future.html#topic+future">future::future()</a></code> arguments <code>globals</code>
and <code>packages</code> via foreach argument <code>.options.future</code>.  For example,
if you specify argument
<code>.options.future = list(globals = structure(TRUE, ignore = "b", add = "a"))</code>
then globals are automatically identified (<code>TRUE</code>), but it ignores <code>b</code> and
always adds <code>a</code>.
</p>
<p>An alternative to specifying the <code>globals</code> and the <code>packages</code> options via
<code>.options.future</code>, is to use the <code><a href="future.html#topic++25globals+25">%globals%</a></code>
and the <code><a href="future.html#topic++25packages+25">%packages%</a></code> operators.
See the examples for an illustration.
</p>
<p>For further details and instructions, see <code><a href="future.html#topic+future">future::future()</a></code>.
</p>


<h3>Random Number Generation (RNG)</h3>

<p>The <code style="white-space: pre;">&#8288;%dofuture%&#8288;</code> uses the future ecosystem to generate proper random
numbers in parallel in the same way they are generated in, for instance,
<span class="pkg">future.apply</span>. For this to work, you need to specify
<code>.options.future = list(seed = TRUE)</code>.  For example,
</p>
<div class="sourceCode r"><pre>y &lt;- foreach(i = 1:3, .options.future = list(seed = TRUE)) %dofuture% {
  rnorm(1)
}
</pre></div>
<p>Unless <code>seed</code> is <code>FALSE</code> or <code>NULL</code>, this guarantees that the exact same
sequence of random numbers are generated <em>given the same initial
seed / RNG state</em> - this regardless of type of future backend, number of
workers, and scheduling (&quot;chunking&quot;) strategy.
</p>
<p>RNG reproducibility is achieved by pregenerating the random seeds for all
iterations by using L'Ecuyer-CMRG RNG streams.  In each
iteration, these seeds are set before evaluating the foreach expression.
<em>Note, for large number of iterations this may introduce a large overhead.</em>
</p>
<p>If <code>seed = TRUE</code>, then <code><a href="base.html#topic+Random">.Random.seed</a></code>
is used if it holds a L'Ecuyer-CMRG RNG seed, otherwise one is created
randomly.
</p>
<p>If <code>seed = FALSE</code>, it is expected that none of the foreach iterations
use random number generation.
If they do, then an informative warning or error is produces depending
on settings. See <a href="future.html#topic+future">future::future</a> for more details.
Using <code>seed = NULL</code>, is like <code>seed = FALSE</code> but without the check
whether random numbers were generated or not.
</p>
<p>As input, <code>seed</code> may also take a fixed initial seed (integer),
either as a full L'Ecuyer-CMRG RNG seed (vector of 1+6 integers), or
as a seed generating such a full L'Ecuyer-CMRG seed. This seed will
be used to generated one L'Ecuyer-CMRG RNG stream for each iteration.
</p>
<p>An alternative to specifying the <code>seed</code> option via <code>.options.future</code>,
is to use the <code><a href="future.html#topic++25seed+25">%seed%</a></code> operator.  See
the examples for an illustration.
</p>
<p>For further details and instructions, see
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code>.
</p>


<h3>Load balancing (&quot;chunking&quot;)</h3>

<p>Whether load balancing (&quot;chunking&quot;) should take place or not can be
controlled by specifying either argument
<code style="white-space: pre;">&#8288;.options.future = list(scheduling = &lt;ratio&gt;)&#8288;</code> or
<code style="white-space: pre;">&#8288;.options.future = list(chunk.size = &lt;count&gt;)&#8288;</code> to <code>foreach()</code>.
</p>
<p>The value <code>chunk.size</code> specifies the average number of elements
processed per future (&quot;chunks&quot;).
If <code>+Inf</code>, then all elements are processed in a single future (one worker).
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.
</p>
<p>The value <code>scheduling</code> specifies the average number of futures
(&quot;chunks&quot;) that each worker processes.
If <code>0.0</code>, then a single future is used to process all iterations;
none of the other workers are not used.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures (if there are
enough iterations).
If <code>+Inf</code> or <code>FALSE</code>, then one future per iteration is used.
The default value is <code>scheduling = 1.0</code>.
</p>
<p>For further details and instructions, see
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code>.
</p>


<h3>Control processing order of iterations</h3>

<p>Attribute <code>ordering</code> of <code>chunk.size</code> or <code>scheduling</code> can be used to
control the ordering the elements are iterated over, which only affects
the processing order and <em>not</em> the order values are returned.
This attribute can take the following values:
</p>

<ul>
<li><p> index vector - an numeric vector of length <code>nX</code>.
</p>
</li>
<li><p> function     - an function taking one argument which is called as
<code>ordering(nX)</code> and which must return an
index vector of length <code>nX</code>, e.g.
<code>function(n) rev(seq_len(n))</code> for reverse ordering.
</p>
</li>
<li> <p><code>"random"</code>   - this will randomize the ordering via random index
vector <code>sample.int(nX)</code>.
</p>
</li></ul>

<p>where <code>nX</code> is the number of foreach iterations to be done.
</p>
<p>For example,
<code>.options.future = list(scheduling = structure(2.0, ordering = "random"))</code>.
</p>
<p><em>Note</em>, when elements are processed out of order, then captured standard
output and conditions are also relayed in that order, that is, out of order.
</p>
<p>For further details and instructions, see
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code>.
</p>


<h3>Reporting on progress</h3>

<p>How to report on progress is a frequently asked question, especially
in long-running tasks and parallel processing.  The <strong>foreach</strong>
framework does <em>not</em> have a built-in mechanism for progress
reporting(*).
</p>
<p>When using <strong>doFuture</strong>, and the Futureverse in general, for
processing, the <strong>progressr</strong> package can be used to signal progress
updates in a near-live fashion.  There is special argument related to
<code>foreach()</code> or <strong>doFuture</strong> to achieve this. Instead, one calls a
a, so called, &quot;progressor&quot; function within each iteration.  See
the <a href="https://cran.r-project.org/package=progressr"><strong>progressr</strong></a>
package and its <code>vignette(package = "progressr")</code> for examples.
</p>
<p>(*) The legacy <strong>doSNOW</strong> package uses a special <code>foreach()</code> argument
<code>.options.doSNOW$progress</code> that can be used to make a progress update
each time results from a parallel workers is returned. This approach
is limited by how chunking works, requires the developer to set that
argument, and the code becomes incompatible with foreach adaptors
registered by other <strong>doNnn</strong> packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plan(multisession)  # parallelize futures on the local machine

y &lt;- foreach(x = 1:10, .combine = rbind) %dofuture% {
  y &lt;- sqrt(x)
  data.frame(x = x, y = y, pid = Sys.getpid())
}
print(y)


## Random number generation
y &lt;- foreach(i = 1:3, .combine = rbind, .options.future = list(seed = TRUE)) %dofuture% {
  data.frame(i = i, random = runif(n = 1L)) 
}
print(y)

## Random number generation (alternative specification)
y &lt;- foreach(i = 1:3, .combine = rbind) %dofuture% {
  data.frame(i = i, random = runif(n = 1L)) 
} %seed% TRUE
print(y)

## Random number generation with the foreach() %:% nested operator
y &lt;- foreach(i = 1:3, .combine = rbind) %:%
       foreach(j = 3:5, .combine = rbind, .options.future = list(seed = TRUE)) %dofuture% {
  data.frame(i = i, j = j, random = runif(n = 1L)) 
}
print(y)

## Random number generation with the nested foreach() calls
y &lt;- foreach(i = 1:3, .combine = rbind, .options.future = list(seed = TRUE)) %dofuture% {
  foreach(j = 3:5, .combine = rbind, .options.future = list(seed = TRUE)) %dofuture% {
    data.frame(i = i, j = j, random = runif(n = 1L)) 
  }
}
print(y)




</code></pre>

<hr>
<h2 id='doFuture.options'>Options used by the doFuture adapter</h2><span id='topic+doFuture.options'></span>

<h3>Description</h3>

<p>Below are all <span class="rlang"><b>R</b></span> options specific to the <span class="pkg">doFuture</span> package.
For options controlling futures in general, see
<a href="future.html#topic+future.options">the options</a> for the <span class="pkg">future</span> package.<br />
<br />
<em>WARNING: Note that the names and the default values of
these options may change in future versions of the package.
Please use with care until further notice.</em>
</p>


<h3>Details</h3>


<dl>
<dt><span class="option">doFuture.foreach.export</span>:</dt><dd>
<p>Specifies to what extent the <code>.export</code> argument of
<code><a href="foreach.html#topic+foreach">foreach</a>()</code> should be respected or if globals
should be automatically identified.
</p>
<p>If <code>".export"</code>, then the globals specified by the <code>.export</code>
argument will be used &quot;as is&quot;.
</p>
<p>If <code>".export-and-automatic"</code>, then globals specified by
<code>.export</code> as well as those automatically identified are used.
</p>
<p>The <code>".export-and-automatic-with-warning"</code> is the same as
<code>".export-and-automatic"</code>, but produces a warning if <code>.export</code>
lacks some of the globals that the automatic identification locates
</p>

<ul>
<li><p> this is helpful feedback to developers using <code>foreach()</code>.
</p>
</li></ul>

<p>(Default: <code>".export-and-automatic"</code>)
</p>
</dd>
<dt><span class="option">doFuture.debug</span>:</dt><dd><p>If <code>TRUE</code>, extensive debug messages are
generated. (Default: <code>FALSE</code>)</p>
</dd>
</dl>


<hr>
<h2 id='makeChunks'>Create Chunks of Index Vectors</h2><span id='topic+makeChunks'></span>

<h3>Description</h3>

<p><em>This is an internal function.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeChunks(
  nbrOfElements,
  nbrOfWorkers,
  future.scheduling = 1,
  future.chunk.size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeChunks_+3A_nbrofelements">nbrOfElements</code></td>
<td>
<p>(integer) Total number of elements to iterate over.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_nbrofworkers">nbrOfWorkers</code></td>
<td>
<p>(integer) Number of workers available.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_future.scheduling">future.scheduling</code></td>
<td>
<p>(numeric) A strictly positive scalar.
Only used if argument <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_future.chunk.size">future.chunk.size</code></td>
<td>
<p>(numeric) The maximum number of elements per
chunk, or <code>NULL</code>.  If <code>NULL</code>, then the chunk sizes are given by the
<code>future.scheduling</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of chunks, where each chunk is an integer vector of
unique indices <code>[1, nbrOfElements]</code>.  The union of all chunks
holds <code>nbrOfElements</code> elements and equals <code>1:nbrOfElements</code>.
If <code>nbrOfElements == 0</code>, then an empty list is returned.
</p>


<h3>Control processing order of elements</h3>

<p>Attribute <code>ordering</code> of <code>future.chunk.size</code> or <code>future.scheduling</code> can
be used to control the ordering the elements are iterated over, which
only affects the processing order <em>not</em> the order values are returned.
This attribute can take the following values:
</p>

<ul>
<li><p> index vector - an numeric vector of length <code>nbrOfElements</code> specifying
how elements are remapped
</p>
</li>
<li><p> function     - an function taking one argument which is called as
<code>ordering(nbrOfElements)</code> and which much return an
index vector of length <code>nbrOfElements</code>, e.g.
<code>function(n) rev(seq_len(n))</code> for reverse ordering.
</p>
</li>
<li> <p><code>"random"</code>   - this will randomize the ordering via random index
vector <code>sample.int(nbrOfElements)</code>.
</p>
</li></ul>


<hr>
<h2 id='registerDoFuture'>Use the Foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> Adapter with Futures</h2><span id='topic+registerDoFuture'></span>

<h3>Description</h3>

<p>The <code>registerDoFuture()</code> function makes the
<code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code> operator of the
<span class="pkg">foreach</span> package to process foreach iterations via any of
the future backends supported by the <span class="pkg">future</span> package, which
includes various parallel and distributed backends.
In other words, <em>if a computational backend is supported via
the Future API, it'll be automatically available for all functions
and packages making using the <span class="pkg">foreach</span> framework.</em>
Neither the developer nor the end user has to change any code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerDoFuture()
</code></pre>


<h3>Value</h3>

<p><code>registerDoFuture()</code> returns, invisibly, the previously registered
foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> backend.
</p>


<h3>Parallel backends</h3>

<p>To use futures with the <span class="pkg">foreach</span> package and its
<code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code> operator, use
<code>doFuture::registerDoFuture()</code> to register <span class="pkg">doFuture</span> to be
used as a <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> adapter.  After this, <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> will
parallelize with whatever <span class="pkg">future</span> backend is set by
<code><a href="future.html#topic+plan">future::plan()</a></code>.
</p>
<p>The built-in <span class="pkg">future</span> backends are always available, e.g.
<a href="future.html#topic+sequential">sequential</a> (sequential processing),
<a href="future.html#topic+multicore">multicore</a> (forked processes),
<a href="future.html#topic+multisession">multisession</a> (background R sessions),
and <a href="future.html#topic+cluster">cluster</a> (background R sessions on
local and remote machines).
For example, <code>plan(multisession)</code> will make <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>
parallelize via R processes running in the background on the
local machine, and
<code>plan(cluster, workers = c("n1", "n2", "n2", "n3"))</code> will
parallelize via R processes running on external machines.
</p>
<p>Additional backends are provided by other future-compliant
packages.  For example, the <span class="pkg">future.batchtools</span> package
provides support for high-performance compute (HPC) cluster
schedulers such as SGE, Slurm, and TORQUE / PBS.
As an illustration, <code>plan(batchtools_slurm)</code> will parallelize
by submitting the foreach iterations as tasks to the Slurm
scheduler, which in turn will distribute the tasks to one
or more compute nodes.
</p>


<h3>Global variables and packages</h3>

<p>Unless running locally in the global environment (= at the <span class="rlang"><b>R</b></span> prompt),
the <span class="pkg">foreach</span> package requires you do specify what global variables
and packages need to be available and attached in order for the
&quot;foreach&quot; expression to be evaluated properly.  It is not uncommon to
get errors on one or missing variables when moving from running a
<code>res &lt;- foreach() %dopar% { ... }</code> statement on the local machine
to, say, another machine on the same network.  The solution to the
problem is to explicitly export those variables by specifying them in
the <code>.export</code> argument to <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>,
e.g. <code>foreach(..., .export = c("mu", "sigma"))</code>.  Likewise, if the
expression needs specific packages to be attached, they can be listed
in argument <code>.packages</code> of <code>foreach()</code>.
</p>
<p>When using <code>registerDoFuture()</code>, the above becomes less
critical, because by default the Future API identifies all globals and
all packages automatically (via static code inspection).  This is done
exactly the same way regardless of future backend.
This automatic identification of globals and packages is illustrated
by the below example, which does <em>not</em> specify
<code>.export = c("my_stat")</code>.  This works because the future framework
detects that function <code>my_stat()</code> is needed and makes sure it is
exported.  If you would use, say, <code>cl &lt;- parallel::makeCluster(2)</code>
and <code>doParallel::registerDoParallel(cl)</code>, you would get a run-time
error on <code>Error in { : task 1 failed - \"could not find function "my_stat" ...</code>.
</p>
<p>Having said this, note that, in order for your &quot;foreach&quot; code to work
everywhere and with other types of foreach adapters as well, you may
want to make sure that you always specify arguments <code>.export</code>
and <code>.packages</code>.
</p>


<h3>Load balancing (&quot;chunking&quot;)</h3>

<p>Whether load balancing (&quot;chunking&quot;) should take place or not can be
controlled by specifying either argument
<code style="white-space: pre;">&#8288;.options.future = list(scheduling = &lt;ratio&gt;)&#8288;</code> or
<code style="white-space: pre;">&#8288;.options.future = list(chunk.size = &lt;count&gt;)&#8288;</code> to <code>foreach()</code>.
</p>
<p>The value <code>chunk.size</code> specifies the average number of elements
processed per future (&quot;chunks&quot;).
If <code>+Inf</code>, then all elements are processed in a single future (one worker).
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.
</p>
<p>The value <code>scheduling</code> specifies the average number of futures
(&quot;chunks&quot;) that each worker processes.
If <code>0.0</code>, then a single future is used to process all iterations;
none of the other workers are not used.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures (if there are
enough iterations).
If <code>+Inf</code> or <code>FALSE</code>, then one future per iteration is used.
The default value is <code>scheduling = 1.0</code>.
</p>
<p>The name of <code>foreach()</code> argument <code>.options.future</code> follows the naming
conventions of the <span class="pkg">doMC</span>, <span class="pkg">doSNOW</span>, and <span class="pkg">doParallel</span> packages,
<em>This argument should not be mistaken for the <span class="rlang"><b>R</b></span>
<a href="future.html#topic+future.options">options of the future package</a></em>.
</p>
<p>For backward-compatibility reasons with existing foreach code, one may
also use arguments <code style="white-space: pre;">&#8288;.options.multicore = list(preschedule = &lt;logical&gt;)&#8288;</code> and
<code style="white-space: pre;">&#8288;.options.snow = list(preschedule = &lt;logical&gt;)&#8288;</code> when using <span class="pkg">doFuture</span>.
<code>.options.multicore = list(preschedule = TRUE)</code> is equivalent to
<code>.options.future = list(scheduling = 1.0)</code> and
<code>.options.multicore = list(preschedule = FALSE)</code> is equivalent to
<code>.options.future = list(scheduling = +Inf)</code>.
and analogously for <code>.options.snow</code>.
Argument <code>.options.future</code> takes precedence over argument
<code>.option.multicore</code> which takes precedence over argument <code>.option.snow</code>,
when it comes to chunking.
</p>


<h3>Random Number Generation (RNG)</h3>

<p>The doFuture adapter registered by <code>registerDoFuture()</code> does <em>not</em> itself
provide a framework for generating proper random numbers in parallel.
This is a deliberate design choice based on how the foreach ecosystem is
set up and to align it with other foreach adapters, e.g. <strong>doParallel</strong>.
To generate statistically sound parallel RNG, it is recommended to use
the <span class="pkg">doRNG</span> package, where the <code><a href="doRNG.html#topic++25dorng+25">%dorng%</a></code>
operator is used in place of <code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code>.
For example,
</p>
<div class="sourceCode r"><pre>y &lt;- foreach(i = 1:3) %dorng% {
  rnorm(1)
}
</pre></div>
<p>This works because <span class="pkg">doRNG</span> is designed to work with any type of foreach
<code style="white-space: pre;">&#8288;%dopar%&#8288;</code> adapter including the one provided by <span class="pkg">doFuture</span>.
</p>
<p>If you forget to use <code style="white-space: pre;">&#8288;%dorng%&#8288;</code> instead of <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> when the foreach
iteration generates random numbers, <span class="pkg">doFuture</span> will detect the
mistake and produce an informative warning.
</p>


<h3>For package developers</h3>

<p>Please refrain from modifying the foreach backend inside your package or
functions, i.e. do not call any <code>registerNnn()</code> in your code.  Instead,
leave the control on what backend to use to the end user.  This idea is
part of the core philosophy of the <span class="pkg">foreach</span> framework.
</p>
<p>However, if you think it necessary to register the <span class="pkg">doFuture</span> backend
in a function, please make sure to undo your changes when exiting the
function. This can be done using:
</p>
<pre>
  oldDoPar &lt;- registerDoFuture()
  on.exit(with(oldDoPar, foreach::setDoPar(fun=fun, data=data, info=info)), add = TRUE)
  [...]
</pre>
<p>This is important, because the end-user might have already registered a
foreach backend elsewhere for other purposes and will most likely not known
that calling your function will break their setup.
<em>Remember, your package and its functions might be used in a greater
context where multiple packages and functions are involved and those might
also rely on the foreach framework, so it is important to avoid stepping on
others' toes.</em>
</p>


<h3>Reporting on progress</h3>

<p>How to report on progress is a frequently asked question, especially
in long-running tasks and parallel processing.  The <strong>foreach</strong>
framework does <em>not</em> have a built-in mechanism for progress
reporting(*).
</p>
<p>When using <strong>doFuture</strong>, and the Futureverse in general, for
processing, the <strong>progressr</strong> package can be used to signal progress
updates in a near-live fashion.  There is special argument related to
<code>foreach()</code> or <strong>doFuture</strong> to achieve this. Instead, one calls a
a, so called, &quot;progressor&quot; function within each iteration.  See
the <a href="https://cran.r-project.org/package=progressr"><strong>progressr</strong></a>
package and its <code>vignette(package = "progressr")</code> for examples.
</p>
<p>(*) The legacy <strong>doSNOW</strong> package uses a special <code>foreach()</code> argument
<code>.options.doSNOW$progress</code> that can be used to make a progress update
each time results from a parallel workers is returned. This approach
is limited by how chunking works, requires the developer to set that
argument, and the code becomes incompatible with foreach adaptors
registered by other <strong>doNnn</strong> packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(iterators)  # iter()
registerDoFuture()  # (a) tell %dopar% to use the future framework
plan(multisession)  # (b) parallelize futures on the local machine


## Example 1
A &lt;- matrix(rnorm(100^2), nrow = 100)
B &lt;- t(A)

y1 &lt;- apply(B, MARGIN = 2L, FUN = function(b) {
  A %*% b
})

y2 &lt;- foreach(b = iter(B, by = "col"), .combine = cbind) %dopar% {
  A %*% b
}
stopifnot(all.equal(y2, y1))



## Example 2 - Chunking (4 elements per future [= worker])
y3 &lt;- foreach(b = iter(B, by = "col"), .combine = cbind,
              .options.future = list(chunk.size = 10)) %dopar% {
  A %*% b
}
stopifnot(all.equal(y3, y1))


## Example 3 - Simulation with parallel RNG
library(doRNG)

my_stat &lt;- function(x) {
  median(x)
}

my_experiment &lt;- function(n, mu = 0.0, sigma = 1.0) {
  ## Important: use %dorng% whenever random numbers
  ##            are involved in parallel evaluation
  foreach(i = 1:n) %dorng% {
    x &lt;- rnorm(i, mean = mu, sd = sigma)
    list(mu = mean(x), sigma = sd(x), own = my_stat(x))
  }
}

## Reproducible results when using the same RNG seed
set.seed(0xBEEF)
y1 &lt;- my_experiment(n = 3)

set.seed(0xBEEF)
y2 &lt;- my_experiment(n = 3)

stopifnot(identical(y2, y1))

## But only then
y3 &lt;- my_experiment(n = 3)
str(y3)
stopifnot(!identical(y3, y1))




</code></pre>

<hr>
<h2 id='withDoRNG'>Evaluates a foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> expression with the doRNG adapter</h2><span id='topic+withDoRNG'></span>

<h3>Description</h3>

<p>Evaluates a foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> expression with the doRNG adapter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withDoRNG(expr, substitute = TRUE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withDoRNG_+3A_expr">expr</code></td>
<td>
<p>An R <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="withDoRNG_+3A_substitute">substitute</code></td>
<td>
<p>(logical) If TRUE, <code>expr</code> is substituted, otherwise not.</p>
</td></tr>
<tr><td><code id="withDoRNG_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> where to evaluate <code>expr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when there is a foreach <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> expression that
uses the random-number generator (RNG).  Such code should ideally use
<code style="white-space: pre;">&#8288;%doRNG%&#8288;</code> of the <span class="pkg">doRNG</span> package instead of <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>.  Alternatively,
and second best, is if the code would temporarily register the <strong>doRNG</strong>
foreach adapter.  If neither is done, then there is a risk that the
random numbers are not statistically sound, e.g. they might be correlated.
For what it is worth, the <strong>doFuture</strong> adapter, which is set by
<code><a href="#topic+registerDoFuture">registerDoFuture()</a></code>, detects when <strong>doRNG</strong> is forgotten, and produced
an informative warning reminding us to use <strong>doRNG</strong>.
</p>
<p>If you do not have control over the foreach code, you can use
<code>withDoRNG()</code> to evaluate the foreach statement with
<code>doRNG::registerDoRNG()</code> temporarily set.
</p>


<h3>Value</h3>

<p>The value of <code>expr</code>.
</p>


<h3>Examples</h3>

<p>Consider a function:
</p>
<div class="sourceCode r"><pre>my_fcn &lt;- function(n) {
  y &lt;- foreach(i = seq_len(n)) %dopar% {
    stats::runif(n = 1L)
  }
  mean(unlist(y))
}
</pre></div>
<p>This function generates random numbers, but without involving <span class="pkg">doRNG</span>,
which risks generating poor randomness.  If we call it as-is, with the
<strong>doFuture</strong> adapter, we will get a warning about the problem:
</p>
<div class="sourceCode r"><pre>&gt; my_fcn(10)
[1] 0.5846141
Warning message:
UNRELIABLE VALUE: One of the foreach() iterations ('doFuture-1')
unexpectedly generated random numbers without declaring so. There is a
risk that those random numbers are not statistically sound and the overall
results might be invalid. To fix this, use '%dorng%' from the 'doRNG'
package instead of '%dopar%'. This ensures that proper, parallel-safe
random numbers are produced via the L'Ecuyer-CMRG method. To disable this
check, set option 'doFuture.rng.onMisuse' to "ignore".
&gt;
</pre></div>
<p>To fix this, we use <code>withDoRNG()</code> as:
</p>
<div class="sourceCode r"><pre>&gt; withDoRNG(my_fcn(10))
[1] 0.535326
</pre></div>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
