<!DOCTYPE html><html><head><title>Help for package mpm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mpm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#export'><p>Generic Function to Export Output to Files</p></a></li>
<li><a href='#export.summary.mpm'><p>Export the summary output for an mpm object to a text file</p>
Output the mpm summary to a tab-demimited file for processing by other
programs (Excel, Spotfire...)  If the filename is empty, return the data
instead of writing to file (useful for web services).</a></li>
<li><a href='#Famin81A'><p>Famin81A Data</p>
Data with demographic indicators by region of the world</a></li>
<li><a href='#Golub'><p>Golub (1999) Data</p></a></li>
<li><a href='#mpm'><p>Spectral Map Analysis</p></a></li>
<li><a href='#plot.mpm'><p>Spectral Map Plot of Multivariate Data</p>
Produces a spectral map plot (biplot) of an object of class <code>mpm</code></a></li>
<li><a href='#print.mpm'><p>Print Method for mpm Objects</p></a></li>
<li><a href='#print.summary.mpm'><p>Print Method for summary.mpm Objects</p></a></li>
<li><a href='#summary.mpm'><p>Summary Statistics for Spectral Map Analysis</p>
Summary method for object of class <code>mpm</code>.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-23</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-31</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Projection Methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, KernSmooth</td>
</tr>
<tr>
<td>Description:</td>
<td>Exploratory graphical analysis of multivariate data,
    specifically gene expression data with different projection
    methods: principal component analysis, correspondence analysis,
    spectral map analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mpm.r-forge.r-project.org">http://mpm.r-forge.r-project.org</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'export.summary.mpm.R' 'Famin81A.R' 'Golub.R' 'mpm.R'
'plot.mpm.R' 'print.mpm.R' 'print.summary.mpm.R'
'summary.mpm.R' 'zzz.R'</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-01 12:40:09 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-01 12:05:43 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Luc Wouters [aut],
  Tobias Verbeke [ctb],
  Laure Cougnaud [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laure Cougnaud &lt;laure.cougnaud@openanalytics.eu&gt;</td>
</tr>
</table>
<hr>
<h2 id='export'>Generic Function to Export Output to Files</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>Generic Function to Export Output to Files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(x, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_x">x</code></td>
<td>
<p>object to export to a file</p>
</td></tr>
<tr><td><code id="export_+3A_filename">filename</code></td>
<td>
<p>name of the file to which the output should be exported</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>further arguments for the method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Verbeke
</p>

<hr>
<h2 id='export.summary.mpm'>Export the summary output for an mpm object to a text file
Output the mpm summary to a tab-demimited file for processing by other
programs (Excel, Spotfire...)  If the filename is empty, return the data
instead of writing to file (useful for web services).</h2><span id='topic+export.summary.mpm'></span>

<h3>Description</h3>

<p>Polar (spherical) coordinates are added if the <code>summary.spm</code> object
contains 2 (3) dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mpm'
export(x, filename = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.summary.mpm_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.mpm</code> as produced by the function of
the same name</p>
</td></tr>
<tr><td><code id="export.summary.mpm_+3A_filename">filename</code></td>
<td>
<p>prefix used to name the output file following &lt;filename&gt;_xyz.txt</p>
</td></tr>
<tr><td><code id="export.summary.mpm_+3A_...">...</code></td>
<td>
<p>further arguments; currently none are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is returned invisibly
</p>


<h3>Author(s)</h3>

<p>Rudi Verbeeck, Tobias Verbeke
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.mpm">summary.mpm</a></code>
</p>

<hr>
<h2 id='Famin81A'>Famin81A Data
Data with demographic indicators by region of the world</h2><span id='topic+Famin81A'></span>

<h3>Description</h3>

<p>Famin81A Data
Data with demographic indicators by region of the world
</p>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 5 variables.
</p>
 
<dl>
<dt>Region</dt><dd><p>a factor with 18 levels giving the
region</p>
</dd> 
<dt>Population.growth</dt><dd><p>a numeric vector</p>
</dd>
<dt>Infant.Mortality</dt><dd><p>a numeric vector; Infant mortality</p>
</dd>
<dt>Dietary.Energy</dt><dd><p>a numeric vector; Dietary Energy</p>
</dd>
<dt>Productivity</dt><dd><p>a numeric vector; Productivity</p>
</dd> 
</dl>



<h3>References</h3>

<p>Friday, L. and Laskey, R. (1989). The Fragile Environment, The
Darwin College Lecture. Cambridge University Press, UK.
</p>

<hr>
<h2 id='Golub'>Golub (1999) Data</h2><span id='topic+Golub'></span><span id='topic+Golub.grp'></span>

<h3>Description</h3>

<p>Golub et al. (1999) data on gene expression profiles of 38 patients
suffering from acute leukemia and a validation sample of 34 patients.
</p>


<h3>Format</h3>

<p>The expression data are available in data frame <code>Golub</code> with
5327 observations on the following 73 variables.  
</p>

<dl>
<dt>list(&quot;Gene&quot;)</dt><dd><p>a character vector with gene identifiers</p>
</dd>  
<dt>list(&quot;1&quot;)</dt><dd><p>gene expression data for sample 1</p>
</dd>
<dt>list(&quot;2&quot;)</dt><dd><p>gene expression data for sample 2</p>
</dd> 
<dt>list(&quot;3&quot;)</dt><dd><p>gene expression data for sample 3</p>
</dd> 
<dt>list(&quot;4&quot;)</dt><dd><p>gene expression data for sample 4</p>
</dd> 
<dt>list(&quot;5&quot;)</dt><dd><p>gene expression data for sample 5</p>
</dd>
<dt>list(&quot;6&quot;)</dt><dd><p>gene expression data for sample 6</p>
</dd> 
<dt>list(&quot;7&quot;)</dt><dd><p>gene expression data for sample 7</p>
</dd> 
<dt>list(&quot;8&quot;)</dt><dd><p>gene expression data for sample 8</p>
</dd> 
<dt>list(&quot;9&quot;)</dt><dd><p>gene expression data for sample 9</p>
</dd>
<dt>list(&quot;10&quot;)</dt><dd><p>gene expression data for sample 10</p>
</dd>
<dt>list(&quot;11&quot;)</dt><dd><p>gene expression data for sample 11</p>
</dd>
<dt>list(&quot;12&quot;)</dt><dd><p>gene expression data for sample 12</p>
</dd>
<dt>list(&quot;13&quot;)</dt><dd><p>gene expression data for sample 13</p>
</dd>
<dt>list(&quot;14&quot;)</dt><dd><p>gene expression data for sample 14</p>
</dd>
<dt>list(&quot;15&quot;)</dt><dd><p>gene expression data for sample 15</p>
</dd>
<dt>list(&quot;16&quot;)</dt><dd><p>gene expression data for sample 16</p>
</dd>
<dt>list(&quot;17&quot;)</dt><dd><p>gene expression data for sample 17</p>
</dd>
<dt>list(&quot;18&quot;)</dt><dd><p>gene expression data for sample 18</p>
</dd>
<dt>list(&quot;19&quot;)</dt><dd><p>gene expression data for sample 19</p>
</dd>
<dt>list(&quot;20&quot;)</dt><dd><p>gene expression data for sample 20</p>
</dd>
<dt>list(&quot;21&quot;)</dt><dd><p>gene expression data for sample 21</p>
</dd>
<dt>list(&quot;22&quot;)</dt><dd><p>gene expression data for sample 22</p>
</dd>
<dt>list(&quot;23&quot;)</dt><dd><p>gene expression data for sample 23</p>
</dd>
<dt>list(&quot;24&quot;)</dt><dd><p>gene expression data for sample 24</p>
</dd>
<dt>list(&quot;25&quot;)</dt><dd><p>gene expression data for sample 25</p>
</dd>
<dt>list(&quot;26&quot;)</dt><dd><p>gene expression data for sample 26</p>
</dd>
<dt>list(&quot;27&quot;)</dt><dd><p>gene expression data for sample 27</p>
</dd>
<dt>list(&quot;34&quot;)</dt><dd><p>gene expression data for sample 34</p>
</dd>
<dt>list(&quot;35&quot;)</dt><dd><p>gene expression data for sample 35</p>
</dd>
<dt>list(&quot;36&quot;)</dt><dd><p>gene expression data for sample 36</p>
</dd>
<dt>list(&quot;37&quot;)</dt><dd><p>gene expression data for sample 37</p>
</dd>
<dt>list(&quot;38&quot;)</dt><dd><p>gene expression data for sample 38</p>
</dd>
<dt>list(&quot;28&quot;)</dt><dd><p>gene expression data for sample 28</p>
</dd>
<dt>list(&quot;29&quot;)</dt><dd><p>gene expression data for sample 29</p>
</dd>
<dt>list(&quot;30&quot;)</dt><dd><p>gene expression data for sample 30</p>
</dd>
<dt>list(&quot;31&quot;)</dt><dd><p>gene expression data for sample 31</p>
</dd>
<dt>list(&quot;32&quot;)</dt><dd><p>gene expression data for sample 32</p>
</dd>
<dt>list(&quot;33&quot;)</dt><dd><p>gene expression data for sample 33</p>
</dd>
<dt>list(&quot;39&quot;)</dt><dd><p>gene expression data for sample 39</p>
</dd>
<dt>list(&quot;40&quot;)</dt><dd><p>gene expression data for sample 40</p>
</dd>
<dt>list(&quot;42&quot;)</dt><dd><p>gene expression data for sample 42</p>
</dd>
<dt>list(&quot;47&quot;)</dt><dd><p>gene expression data for sample 47</p>
</dd>
<dt>list(&quot;48&quot;)</dt><dd><p>gene expression data for sample 48</p>
</dd>
<dt>list(&quot;49&quot;)</dt><dd><p>gene expression data for sample 49</p>
</dd>
<dt>list(&quot;41&quot;)</dt><dd><p>gene expression data for sample 41</p>
</dd>
<dt>list(&quot;43&quot;)</dt><dd><p>gene expression data for sample 43</p>
</dd>
<dt>list(&quot;44&quot;)</dt><dd><p>gene expression data for sample 44</p>
</dd>
<dt>list(&quot;45&quot;)</dt><dd><p>gene expression data for sample 45</p>
</dd>
<dt>list(&quot;46&quot;)</dt><dd><p>gene expression data for sample 46</p>
</dd>
<dt>list(&quot;70&quot;)</dt><dd><p>gene expression data for sample 70</p>
</dd>
<dt>list(&quot;71&quot;)</dt><dd><p>gene expression data for sample 71</p>
</dd>
<dt>list(&quot;72&quot;)</dt><dd><p>gene expression data for sample 72</p>
</dd>
<dt>list(&quot;68&quot;)</dt><dd><p>gene expression data for sample 68</p>
</dd>
<dt>list(&quot;69&quot;)</dt><dd><p>gene expression data for sample 69</p>
</dd>
<dt>list(&quot;67&quot;)</dt><dd><p>gene expression data for sample 67</p>
</dd>
<dt>list(&quot;55&quot;)</dt><dd><p>gene expression data for sample 55</p>
</dd>
<dt>list(&quot;56&quot;)</dt><dd><p>gene expression data for sample 56</p>
</dd>
<dt>list(&quot;59&quot;)</dt><dd><p>gene expression data for sample 59</p>
</dd>
<dt>list(&quot;52&quot;)</dt><dd><p>gene expression data for sample 52</p>
</dd>
<dt>list(&quot;53&quot;)</dt><dd><p>gene expression data for sample 53</p>
</dd>
<dt>list(&quot;51&quot;)</dt><dd><p>gene expression data for sample 51</p>
</dd>
<dt>list(&quot;50&quot;)</dt><dd><p>gene expression data for sample 50</p>
</dd>
<dt>list(&quot;54&quot;)</dt><dd><p>gene expression data for sample 54</p>
</dd>
<dt>list(&quot;57&quot;)</dt><dd><p>gene expression data for sample 57</p>
</dd>
<dt>list(&quot;58&quot;)</dt><dd><p>gene expression data for sample 58</p>
</dd>
<dt>list(&quot;60&quot;)</dt><dd><p>gene expression data for sample 60</p>
</dd>
<dt>list(&quot;61&quot;)</dt><dd><p>gene expression data for sample 61</p>
</dd>
<dt>list(&quot;65&quot;)</dt><dd><p>gene expression data for sample 65</p>
</dd>
<dt>list(&quot;66&quot;)</dt><dd><p>gene expression data for sample 66</p>
</dd>
<dt>list(&quot;63&quot;)</dt><dd><p>gene expression data for sample 63</p>
</dd>
<dt>list(&quot;64&quot;)</dt><dd><p>gene expression data for sample 64</p>
</dd>
<dt>list(&quot;62&quot;)</dt><dd><p>gene expression data for sample 62</p>
</dd> </dl>

<p>The classes are in a separate numeric vector <code>Golub.grp</code> with values
<code>1</code> for the 38 ALL B-Cell samples, <code>2</code> for the 9 ALL T-Cell
samples and <code>3</code> for the 25 AML samples.
</p>


<h3>Details</h3>

<p>The original data of Golub et al. (1999) were preprocessed as follows: genes
that were called 'absent' in all samples were removed from the data sets,
since these measurements are considered unreliable by the manufacturer of
the technology.  Negative measurements in the data were set to 1.
</p>
<p>The resulting data frame contains 5327 genes of the 6817 originally reported
by Golub et al. (1999).
</p>


<h3>Note</h3>

<p>Luc Wouters et al. (2003), p. 1134 contains a typo concerning the
sample sizes of AML- and ALL-type and erroneously reported
</p>


<h3>Source</h3>

<p>Golub, T. R., Slonim, D. K., Tamayo, P., et al. (1999). Molecular
classification of cancer: Class discovery and class prediction by gene
expression monitoring. Science 286, 531 &ndash; 537.
</p>


<h3>References</h3>

<p>Luc Wouters et al. (2003). Graphical Exploration of Gene
Expression Data: A Comparative Study of Three Multivariate Methods,
Biometrics, 59, 1131-1139.
</p>

<hr>
<h2 id='mpm'>Spectral Map Analysis</h2><span id='topic+mpm'></span>

<h3>Description</h3>

<p>Produces an object of class <code>mpm</code> that allows for exploratory
multivariate analysis of large data matrices, such as gene expression data
from microarray experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm(
  data,
  logtrans = TRUE,
  logrepl = 1e-09,
  center = c("double", "row", "column", "global", "none"),
  normal = c("global", "row", "column", "none"),
  closure = c("none", "row", "column", "global", "double"),
  row.weight = c("constant", "mean", "median", "max", "logmean", "RW"),
  col.weight = c("constant", "mean", "median", "max", "logmean", "CW"),
  CW = rep(1, ncol(data) - 1),
  RW = rep(1, nrow(data)),
  pos.row = rep(FALSE, nrow(data)),
  pos.column = rep(FALSE, ncol(data) - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_+3A_data">data</code></td>
<td>
<p>a data frame with the row descriptors in the first column. For
microarray data rows indicate genes and columns biological samples.</p>
</td></tr>
<tr><td><code id="mpm_+3A_logtrans">logtrans</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, data are first
transformed to logarithms (base e) before the other operations.
Non-positive numbers are replaced by <code>logrepl</code>. If <code>FALSE</code>, data
are left unchanged. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_logrepl">logrepl</code></td>
<td>
<p>an optional numeric value that replaces non-positive numbers
in log-transformations. Defaults to <code>1e-9</code>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_center">center</code></td>
<td>
<p>optional character string specifying the centering operation
that is carried out on the optionally log-transformed, closed data matrix.
If <kbd>"double"</kbd> both row- and column-means are subtracted. If
<kbd>"row"</kbd> row-means are subtracted. If <kbd>"column"</kbd> column-means are
subtracted. If <kbd>"none"</kbd> the data are left uncentered. Defaults to
<kbd>"double"</kbd>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_normal">normal</code></td>
<td>
<p>optional character string specifying the normalization
operation that is carried out on the optionally log-transformed, closed,
and centered data matrix. If <kbd>"global"</kbd> the data are normalized using
the global standard deviation. If <kbd>"row"</kbd> data are divided by the
standard deviations of the respective row. If <kbd>"column"</kbd> data are
divided by their respective column standard deviation. If <kbd>"none"</kbd> no
normalization is carried out. Defaults to <kbd>"global"</kbd>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_closure">closure</code></td>
<td>
<p>optional character string specifying the closure operation
that is carried out on the optionally log-transformed data matrix. If
<kbd>"double"</kbd>, data are divided by row- and column-totals. If <kbd>"row"</kbd>
data are divided by row-totals. If <kbd>"column"</kbd> data are divided by
column-totals. If <kbd>"none"</kbd> no closure is carried out. Defaults to
<kbd>"none"</kbd>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_row.weight">row.weight</code></td>
<td>
<p>optional character string specifying the weights of the
different rows in the analysis. This can be <kbd>"constant"</kbd>,
<kbd>"mean"</kbd>, <kbd>"median"</kbd>, <kbd>"max"</kbd>, <kbd>"logmean"</kbd>, or <kbd>"RW"</kbd>.
If <kbd>"RW"</kbd> is specified, weights must be supplied in the vector
<kbd>RW</kbd>. In other cases weights are computed from the data. Defaults to
<kbd>"constant"</kbd>, i.e. constant weighting.</p>
</td></tr>
<tr><td><code id="mpm_+3A_col.weight">col.weight</code></td>
<td>
<p>optional character string specifying the weights of the
different columns in the analysis. This can be <kbd>"constant"</kbd>,
<kbd>"mean"</kbd>, <kbd>"median"</kbd>, <kbd>"max"</kbd>, <kbd>"logmean"</kbd>, or <kbd>"CW"</kbd>.
If <kbd>"CW"</kbd> is specified, weights must be supplied in the vector
<code>CW</code>. In other cases weights are computed from the data. Defaults to
<kbd>"constant"</kbd>, i.e. constant weighting.</p>
</td></tr>
<tr><td><code id="mpm_+3A_cw">CW</code></td>
<td>
<p>optional numeric vector with external column weights. Defaults to
1 (constant weights).</p>
</td></tr>
<tr><td><code id="mpm_+3A_rw">RW</code></td>
<td>
<p>optional numeric vector with external row weights. Defaults to 1
(constant weights).</p>
</td></tr>
<tr><td><code id="mpm_+3A_pos.row">pos.row</code></td>
<td>
<p>logical vector indicating rows that are not to be included in
the analysis but must be positioned on the projection obtained with the
remaining rows. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_+3A_pos.column">pos.column</code></td>
<td>
<p>logical vector indicating columns that are not to be
included in the analysis but must be positioned on the projection obtained
with the remaining columns. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mpm</code> presents a unified approach to exploratory
multivariate analysis encompassing principal component analysis,
correspondence factor analysis, and spectral map analysis. The algorithm
computes projections of high dimensional data in an orthogonal space. The
resulting object can subsequently be used in the construction of biplots
(i.e. <code>plot.mpm</code>).
</p>
<p>The projection of the pre-processed data matrix in the orthogonal space is
calculated using the <code>La.svd</code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>mpm</code> representing the projection of data
after the different operations of transformation, closure, centering, and
normalization in an orthogonal space. Generic functions <code>plot</code> and
<code>summary</code> have methods to show the results of the analysis in more
detail. The object consists of the following components:
</p>
<table>
<tr><td><code>TData</code></td>
<td>
<p>matrix with the data after optional log-transformation,
closure, centering and normalization.</p>
</td></tr> <tr><td><code>row.names</code></td>
<td>
<p>character vector
with names of the row elements as supplied in the first column of the
original data matrix</p>
</td></tr> <tr><td><code>col.names</code></td>
<td>
<p>character vector with the names of
columns obtained from the column names from the original data matrix</p>
</td></tr>
<tr><td><code>closure</code></td>
<td>
<p>closure operation as specified in the function call</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>centering operation as specified in the function call</p>
</td></tr>
<tr><td><code>normal</code></td>
<td>
<p>normalization operation as specified in the function call</p>
</td></tr>
<tr><td><code>row.weight</code></td>
<td>
<p>type of weighting used for rows as specified in the
function call</p>
</td></tr> <tr><td><code>col.weight</code></td>
<td>
<p>type of weighting used for columns as
specified in the function call</p>
</td></tr> <tr><td><code>Wn</code></td>
<td>
<p>vector with calculated weights
for rows</p>
</td></tr> <tr><td><code>Wp</code></td>
<td>
<p>vector with calculated weights for columns</p>
</td></tr>
<tr><td><code>RM</code></td>
<td>
<p>vector with row means of original data</p>
</td></tr> <tr><td><code>CM</code></td>
<td>
<p>vector with
column means of original data</p>
</td></tr> <tr><td><code>pos.row</code></td>
<td>
<p>logical vector indicating
positioned rows as specified in the function call</p>
</td></tr>
<tr><td><code>pos.column</code></td>
<td>
<p>logical vector indicating positioned columns as
specified in the function call</p>
</td></tr> <tr><td><code>SVD</code></td>
<td>
<p>list with components returned
by <code>La.svd</code></p>
</td></tr> <tr><td><code>eigen</code></td>
<td>
<p>eigenvalues for each orthogonal factor from
obtained from the weighted singular value decomposition</p>
</td></tr>
<tr><td><code>contrib</code></td>
<td>
<p>contributions of each factor to the total variance of the
pre-processed data, i.e. the eigenvalues as a fraction of the total
eigenvalue.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Principal component analysis is defined as the projection onto an
orthogonal space of the column-centered and column-normalized data. In
correspondence factor analysis the data are pre-processed by double
closure, double centering, and global normalization. Orthogonal projection
is carried out using the weighted singular value decomposition. Spectral
map analysis is in essence a principal component analysis on the
log-transformed, double centered and global normalized data. Weighted
spectral map analysis has been proven to be successful in the detection of
patterns in gene expression data (Wouters et al., 2003).
</p>


<h3>Author(s)</h3>

<p>Luc Wouters, Rudi Verbeeck, Tobias Verbeke
</p>


<h3>References</h3>

<p>Wouters, L., Goehlmann, H., Bijnens, L., Kass, S.U.,
Molenberghs, G., Lewi, P.J. (2003). Graphical exploration of gene
expression data: a comparative study of three multivariate methods.
<em>Biometrics</em> <b>59</b>, 1131-1140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mpm">plot.mpm</a></code>, <code><a href="#topic+summary.mpm">summary.mpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Golub)
  # Principal component analysis
  r.pca &lt;- mpm(Golub[,1:39], center = "column", normal = "column")
  # Correspondence factor analysis
  r.cfa &lt;- mpm(Golub[,1:39],logtrans = FALSE, row.weight = "mean",
             col.weight = "mean", closure = "double")
  # Weighted spectral map analysis
  r.sma &lt;- mpm(Golub[,1:39], row.weight = "mean", col.weight = "mean")
</code></pre>

<hr>
<h2 id='plot.mpm'>Spectral Map Plot of Multivariate Data
Produces a spectral map plot (biplot) of an object of class <code>mpm</code></h2><span id='topic+plot.mpm'></span>

<h3>Description</h3>

<p>Spectral maps are special types of biplots with the area of the symbols
proportional to some measure, usually the row or column mean value and an
identification of row- and column-items.  For large matrices, such as gene
expression data, where there is an abundance of rows, this can obscure the
plot.  In this case, the argument <code>label.tol</code> can be used to select the
most informative rows, i.e. rows that are most distant from the center of
the plot.  Only these row-items are then labeled and represented as circles
with their areas proportional to the marginal mean value.  For the
column-items it can be useful to apply some grouping specified by
<code>col.group</code>. Examples of groupings are different pathologies, such as
specified in <code>Golub.grp</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpm'
plot(
  x,
  scale = c("singul", "eigen", "uvr", "uvc"),
  dim = c(1, 2),
  zoom = rep(1, 2),
  show.row = c("all", "position"),
  show.col = c("all", "position"),
  col.group = rep(1, length(x$col.names)),
  colors = c("orange1", "red", rainbow(length(unique(col.group)), start = 2/6, end =
    4/6)),
  col.areas = TRUE,
  col.symbols = c(1, rep(2, length(unique(col.group)))),
  sampleNames = TRUE,
  rot = rep(-1, length(dim)),
  labels = NULL,
  label.tol = 1,
  label.col.tol = 1,
  lab.size = 0.725,
  col.size = 10,
  row.size = 10,
  do.smoothScatter = FALSE,
  do.plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mpm_+3A_x">x</code></td>
<td>
<p>object of class <code>mpm</code> a result of a call to <code>mpm</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_scale">scale</code></td>
<td>
<p>optional character string specifying the type of factor scaling
of the biplot. This can be either <kbd>"singul"</kbd> (singular value scaling),
<kbd>"eigen"</kbd> (eigenvalue scaling), <kbd>"uvr"</kbd> (unit row-variance
scaling), <kbd>"uvc"</kbd> (unit column-variance scaling). The latter is of
particular value when analyzing large matrices, such as gene expression
data. Singular value scaling <kbd>"singul"</kbd> is customary in spectral map
analysis. Defaults to <kbd>"singul"</kbd>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_dim">dim</code></td>
<td>
<p>optional principal factors that are plotted along the horizontal
and vertical axis. Defaults to <code>c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_zoom">zoom</code></td>
<td>
<p>optional zoom factor for row and column items. Defaults to
<code>c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_show.row">show.row</code></td>
<td>
<p>optional character string indicating whether all rows
(<kbd>"all"</kbd>) are to be plotted or just the positioned rows
<kbd>"position"</kbd>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_show.col">show.col</code></td>
<td>
<p>optional character string indicating whether all columns
(<kbd>"all"</kbd>) are to be plotted or just the positioned columns
<kbd>"position"</kbd>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_col.group">col.group</code></td>
<td>
<p>optional vector (character or numeric) indicating the
different groupings of the columns, e.g. <code>Golub.grp</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_colors">colors</code></td>
<td>
<p>vector specifying the colors for the annotation of the plot;
the first two elements concern the rows; the third till the last element
concern the columns; the first element will be used to color the unlabeled
rows; the second element for the labeled rows and the remaining elements
to give different colors to different groups of columns.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_col.areas">col.areas</code></td>
<td>
<p>logical value indicating whether columns should be plotted
as squares with areas proportional to their marginal mean and colors
representing the different groups (<code>TRUE</code>), or with symbols
representing the groupings and identical size (<code>FALSE</code>). Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_col.symbols">col.symbols</code></td>
<td>
<p>vector of symbols when <code>col.areas=FALSE</code> corresponds
to the <code>pch</code> argument of the function <code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_samplenames">sampleNames</code></td>
<td>
<p>Either a logical vector of length one or a character
vector of length equal to the number of samples in the dataset. If a
logical is provided, sample names will be displayed on the plot
(<code>TRUE</code>; default) or not (<code>FALSE</code>); if a character vector is
provided, the names provided will be used to label the samples instead of
the default column names.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_rot">rot</code></td>
<td>
<p>rotation of plot. Defaults to <code>c(-1,-1)</code>.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_labels">labels</code></td>
<td>
<p>character vector to be used for labeling points on the graph;
if <code>NULL</code>, the row names of <code>x</code> are used instead</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_label.tol">label.tol</code></td>
<td>
<p>numerical value specifying either the percentile
(<code>label.tol&lt;=1</code>) of rows or the number of rows (<code>label.tol&gt;1</code>)
most distant from the plot-center (0,0) that are labeled and are plotted
as circles with area proportional to the marginal means of the original
data.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_label.col.tol">label.col.tol</code></td>
<td>
<p>numerical value specifying either the percentile
(<code>label.col.tol&lt;=1</code>) of columns or the number of columns (<code>label.col.tol&gt;1</code>)
most distant from the plot-center (0,0) that are labeled and are plotted
as circles with area proportional to the marginal means of the original
data.</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_lab.size">lab.size</code></td>
<td>
<p>size of identifying labels for row- and column-items as
<code>cex</code> parameter of the <code>text</code> function</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_col.size">col.size</code></td>
<td>
<p>size in mm of the column symbols</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_row.size">row.size</code></td>
<td>
<p>size in mm of the row symbols</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_do.smoothscatter">do.smoothScatter</code></td>
<td>
<p>use smoothScatter or not instead of plotting
individual points</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_do.plot">do.plot</code></td>
<td>
<p>produce a plot or not</p>
</td></tr>
<tr><td><code id="plot.mpm_+3A_...">...</code></td>
<td>
<p>further arguments to <code>eqscaleplot</code> which draws the canvas
for the plot; useful for adding a <code>main</code> or a custom <code>sub</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plot.mpm</code> that has the following
components: </p>
<table>
<tr><td><code>Rows</code></td>
<td>
<p>a data frame with the X and Y coordinates of the
rows and an indication <code>Select</code> of whether the row was selected
according to <code>label.tol</code></p>
</td></tr> <tr><td><code>Columns</code></td>
<td>
<p>a data frame with the X and
Y coordinates of the columns</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>value</code> is returned invisibly, but is available for further use
when an explicit assignment is made
</p>


<h3>Author(s)</h3>

<p>Luc Wouters
</p>


<h3>References</h3>

<p>Wouters, L., Goehlmann, H., Bijnens, L., Kass, S.U.,
Molenberghs, G., Lewi, P.J. (2003). Graphical exploration of gene
expression data: a comparative study of three multivariate methods.
<em>Biometrics</em> <b>59</b>, 1131-1140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm">mpm</a></code>, <code><a href="#topic+summary.mpm">summary.mpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Weighted spectral map analysis
  data(Golub) # Gene expression data of leukemia patients
  data(Golub.grp) # Pathological classes coded as 1, 2, 3
  r.sma &lt;- mpm(Golub[,1:39], row.weight = "mean", col.weight = "mean")
  # Spectral map biplot with result
  r &lt;- plot(r.sma, label.tol = 20, scale = "uvc",
            col.group = (Golub.grp)[1:38], zoom = c(1,1.2), col.size = 5)
  Golub[r$Rows$Select, 1] # 20 most extreme genes

</code></pre>

<hr>
<h2 id='print.mpm'>Print Method for mpm Objects</h2><span id='topic+print.mpm'></span>

<h3>Description</h3>

<p>Print Method for mpm Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mpm_+3A_x">x</code></td>
<td>
<p>object of class mpm</p>
</td></tr>
<tr><td><code id="print.mpm_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be printed</p>
</td></tr>
<tr><td><code id="print.mpm_+3A_...">...</code></td>
<td>
<p>further arguments for the print method (for printing the contributions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x is returned invisibly
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='print.summary.mpm'>Print Method for summary.mpm Objects</h2><span id='topic+print.summary.mpm'></span>

<h3>Description</h3>

<p>Print Method for summary.mpm Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mpm'
print(x, digits = 2, what = c("columns", "rows", "all"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mpm_+3A_x">x</code></td>
<td>
<p>object of class summary.mpm</p>
</td></tr>
<tr><td><code id="print.summary.mpm_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to print, defaults to 2</p>
</td></tr>
<tr><td><code id="print.summary.mpm_+3A_what">what</code></td>
<td>
<p>one of <code>"columns"</code> (default), <code>"rows"</code> or <code>"all"</code>, specifying respectively
whether columns, rows or both need to be printed</p>
</td></tr>
<tr><td><code id="print.summary.mpm_+3A_...">...</code></td>
<td>
<p>further arguments for the print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x is returned invisibly
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='summary.mpm'>Summary Statistics for Spectral Map Analysis
Summary method for object of class <code>mpm</code>.</h2><span id='topic+summary.mpm'></span>

<h3>Description</h3>

<p>The function <code>summary.mpm</code> computes and returns a list of summary
statistics of the spectral map analysis given in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpm'
summary(object, maxdim = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mpm_+3A_object">object</code></td>
<td>
<p>an object of class <code>mpm</code> resulting from a call to
<code>mpm</code></p>
</td></tr>
<tr><td><code id="summary.mpm_+3A_maxdim">maxdim</code></td>
<td>
<p>maximum number of principal factors to be reported. Defaults
to <code>4</code></p>
</td></tr>
<tr><td><code id="summary.mpm_+3A_...">...</code></td>
<td>
<p>further arguments; currently none are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.mpm</code> with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call to <code>mpm</code></p>
</td></tr> <tr><td><code>Vxy</code></td>
<td>
<p>sum of eigenvalues</p>
</td></tr>
<tr><td><code>VPF</code></td>
<td>
<p>a matrix with on the first line the eigenvalues and on the
second line the cumulative eigenvalues of each of the principal factors
(<code>PRF1</code> to <code>PRFmaxdim</code>) followed by the residual 
eigenvalues and the total eigenvalue.</p>
</td></tr> <tr><td><code>Rows</code></td>
<td>
<p>a data frame with
summary statistics for the row-items, as described below.</p>
</td></tr>
<tr><td><code>Columns</code></td>
<td>
<p>a data frame with with summary statistics for the
column-items, as described below.<br /><br /> The <code>Rows</code> and <code>Columns</code>
data frames contain the following columns:<br /><br /></p>
</td></tr> <tr><td><code>Posit</code></td>
<td>
<p>binary
indication of whether the row or column was positioned (<code>1</code>) or not
(<code>0</code>).</p>
</td></tr> <tr><td><code>Weight</code></td>
<td>
<p>weight applied to the row or column in the
function <code>mpm</code>.</p>
</td></tr> <tr><td><code>PRF1-PRFmaxdim</code></td>
<td>
<p>factor scores or loadings for
the first <code>maxdim</code> factors using eigenvalue scaling.</p>
</td></tr>
<tr><td><code>Resid</code></td>
<td>
<p>residual score or loading not accounted for by the first
<code>maxdim</code> factors.</p>
</td></tr> <tr><td><code>Norm</code></td>
<td>
<p>length of the vector representing the
row or column in factor space.</p>
</td></tr> <tr><td><code>Contrib</code></td>
<td>
<p>contribution of row or
column to the sum of eigenvalues.</p>
</td></tr> <tr><td><code>Accuracy</code></td>
<td>
<p>accuracy of the
representation of the row or column by means of the first <code>maxdim</code>
principal factors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luc Wouters
</p>


<h3>References</h3>

<p>Wouters, L., Goehlmann, H., Bijnens, L., Kass, S.U.,
Molenberghs, G., Lewi, P.J. (2003). Graphical exploration of gene
expression data: a comparative study of three multivariate methods.
<em>Biometrics</em> <b>59</b>, 1131-1140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm">mpm</a></code>, <code><a href="#topic+plot.mpm">plot.mpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Example 1 weighted spectral map analysis Golub data
  data(Golub)
  r.sma &lt;- mpm(Golub[,1:39], row.weight = "mean", col.weight = "mean")
  # summary report
  summary(r.sma)
  # Example 2 using print function
  data(Famin81A)
  r.fam &lt;- mpm(Famin81A, row.weight = "mean", col.weight = "mean")
  r.sum &lt;- summary(r.fam)
  print(r.sum, what = "all")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
