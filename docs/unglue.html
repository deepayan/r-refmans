<!DOCTYPE html><html lang="en"><head><title>Help for package unglue</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unglue}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unglue'><p>unglue</p></a></li>
<li><a href='#unglue_detect'><p>Detect if strings are matched by a set of unglue patterns</p></a></li>
<li><a href='#unglue_regex'><p>Converts unglue pattern to regular regex pattern</p></a></li>
<li><a href='#unglue_sub'><p>unglue_sub</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extract Matched Substrings Using a Pattern</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Use syntax inspired by the package 'glue' to extract matched substrings in a more intuitive and compact way than by using standard regular expressions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glue, testthat (&ge; 2.1.0), rlang, covr, knitr, rmarkdown,
magrittr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-11 00:17:24 UTC; afabri</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Fabri [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Fabri &lt;antoine.fabri@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-11 05:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='unglue'>unglue</h2><span id='topic+unglue'></span><span id='topic+unglue_data'></span><span id='topic+unglue_vec'></span><span id='topic+unglue_unnest'></span>

<h3>Description</h3>

<p>The functions <code>unglue_data()</code>, <code>unglue()</code>, <code>unglue_vec()</code> and <code>unglue_unnest()</code>
extract matched substrings using a syntax inspired from <code>glue::glue()</code>.
Simple cases don't require regex knowledge at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unglue(x, patterns, open = "{", close = "}", convert = FALSE, multiple = NULL)

unglue_data(
  x,
  patterns,
  open = "{",
  close = "}",
  convert = FALSE,
  multiple = NULL,
  na = NA_character_
)

unglue_vec(
  x,
  patterns,
  var = 1,
  open = "{",
  close = "}",
  convert = FALSE,
  multiple = NULL,
  na = NA_character_
)

unglue_unnest(
  data,
  col,
  patterns,
  open = "{",
  close = "}",
  remove = TRUE,
  convert = FALSE,
  multiple = NULL,
  na = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unglue_+3A_x">x</code></td>
<td>
<p>a character vector to unglue.</p>
</td></tr>
<tr><td><code id="unglue_+3A_patterns">patterns</code></td>
<td>
<p>a character vector or a list of character vectors, if a list,
items will be pasted using an empty separator (<code>""</code>).</p>
</td></tr>
<tr><td><code id="unglue_+3A_open">open</code></td>
<td>
<p>The opening delimiter.</p>
</td></tr>
<tr><td><code id="unglue_+3A_close">close</code></td>
<td>
<p>The closing delimiter.</p>
</td></tr>
<tr><td><code id="unglue_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will convert columns of output using
<code>utils::type.convert()</code> with parameter <code>as.is = TRUE</code>, alternatively, can
be a converting function, such as <code>readr::type_convert</code>. Formula notation
is supported if the package <code>rlang</code> is installed, so things like
<code>convert = ~type_convert(., numerals = "warn.loss")</code> are possible.</p>
</td></tr>
<tr><td><code id="unglue_+3A_multiple">multiple</code></td>
<td>
<p>The aggregation function to use if several subpatterns are
named the same, by default no function is used and subpatterns named the
same will match the same value. If a function is provided it will be fed
the conflicting values as separate arguments. Formula notation
is supported if the package <code>rlang</code> is installed.</p>
</td></tr>
<tr><td><code id="unglue_+3A_na">na</code></td>
<td>
<p>string to use when there is no match</p>
</td></tr>
<tr><td><code id="unglue_+3A_var">var</code></td>
<td>
<p>for <code>unglue_vec()</code>, the numeric index or the name of the subpattern to extract from</p>
</td></tr>
<tr><td><code id="unglue_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="unglue_+3A_col">col</code></td>
<td>
<p>column containing the character vector to extract values from.</p>
</td></tr>
<tr><td><code id="unglue_+3A_remove">remove</code></td>
<td>
<p>whether to remove the column <code>col</code> once extraction is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the task you might want:
</p>

<ul>
<li> <p><code>unglue_data()</code> to return a data frame from a character vector,
just as <code>glue::glue_data()</code> does in reverse
</p>
</li>
<li> <p><code>unglue()</code> to return a list of data frames containing the matches
</p>
</li>
<li> <p><code>unglue_vec()</code> to extract one value by element of <code>x</code>, chosen by index or by
name.
</p>
</li>
<li> <p><code>unglue_unnest()</code> to extract value from a column of a data frame to new columns
</p>
</li></ul>

<p>To build the relevant regex pattern special characters will be escaped in the
input pattern and the subpatterns will be replaced with <code style="white-space: pre;">&#8288;(.*?)&#8288;</code> if in standard
<code>"{foo}"</code> form. An alternate regular expression can be provided after <code>=</code> so that
<code>"{foo=\\d}"</code> will be translated into <code>"(\\d)"</code>.
</p>
<p>Sometimes we might want to use regex to match a part of the text that won't
be extracted, in these cases we just need to omit the name as in <code>"{=\\d}"</code>.
</p>
<p><code>unglue_unnest()</code>'s name is a tribute to <code>tidyr::unnest()</code> because
<code>unglue_unnest(data, col, patterns)</code> returns a similar output as
<code>dplyr::mutate(data, unglued = unglue(col, patterns)) %&gt;% tidyr::unnest()</code>
(without requiring any extra package).
It is also very close to <code>tidyr::extract()</code> and efforts were made to make
the syntax consistent with the latter.
</p>


<h3>Value</h3>

<p>For <code>unglue()</code>a list of one row data frames, for <code>unglue_data</code> a
data frame, for <code>unglue_unnest</code> the data frame input with additional columns
built from extracted values, for <code>unglue_vec</code> an atomic vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using an awample from ?glue::glue
if(require(magrittr) &amp;&amp; require(glue)) {
  glued_data &lt;- mtcars %&gt;% glue_data("{rownames(.)} has {hp} hp")
  unglue_data(glued_data, "{rownames(.)} has {hp} hp")
}

facts &lt;- c("Antarctica is the largest desert in the world!",
"The largest country in Europe is Russia!",
"The smallest country in Europe is Vatican!",
"Disneyland is the most visited place in Europe! Disneyland is in Paris!",
"The largest island in the world is Green Land!")
facts_df &lt;- data.frame(id = 1:5, facts)

patterns &lt;- c("The {adjective} {place_type} in {bigger_place} is {place}!",
            "{place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*}")
unglue_data(facts, patterns)

sentences &lt;- c("666 is [a number]", "foo is [a word]",
              "42 is [the answer]", "Area 51 is [unmatched]")
patterns &lt;- c("{number=\\d+} is [{what}]", "{word=\\D+} is [{what}]")
unglue_data(sentences, patterns)

unglue_unnest(facts_df, facts, patterns)
unglue_unnest(facts_df, facts, patterns, remove = FALSE)
</code></pre>

<hr>
<h2 id='unglue_detect'>Detect if strings are matched by a set of unglue patterns</h2><span id='topic+unglue_detect'></span>

<h3>Description</h3>

<p>Returns a logical indicating whether input strings were matched by one or more patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unglue_detect(
  x,
  patterns,
  open = "{",
  close = "}",
  convert = FALSE,
  multiple = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unglue_detect_+3A_x">x</code></td>
<td>
<p>a character vector to unglue.</p>
</td></tr>
<tr><td><code id="unglue_detect_+3A_patterns">patterns</code></td>
<td>
<p>a character vector or a list of character vectors, if a list,
items will be pasted using an empty separator (<code>""</code>).</p>
</td></tr>
<tr><td><code id="unglue_detect_+3A_open">open</code></td>
<td>
<p>The opening delimiter.</p>
</td></tr>
<tr><td><code id="unglue_detect_+3A_close">close</code></td>
<td>
<p>The closing delimiter.</p>
</td></tr>
<tr><td><code id="unglue_detect_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will convert columns of output using
<code>utils::type.convert()</code> with parameter <code>as.is = TRUE</code>, alternatively, can
be a converting function, such as <code>readr::type_convert</code>. Formula notation
is supported if the package <code>rlang</code> is installed, so things like
<code>convert = ~type_convert(., numerals = "warn.loss")</code> are possible.</p>
</td></tr>
<tr><td><code id="unglue_detect_+3A_multiple">multiple</code></td>
<td>
<p>The aggregation function to use if several subpatterns are
named the same, by default no function is used and subpatterns named the
same will match the same value. If a function is provided it will be fed
the conflicting values as separate arguments. Formula notation
is supported if the package <code>rlang</code> is installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sentences &lt;- c("666 is [a number]", "foo is [a word]",
               "42 is [the answer]", "Area 51 is [unmatched]")
patterns &lt;- c("{number=\\d+} is [{what}]", "{word=\\D+} is [{what}]")
unglue_detect(sentences, patterns)
</code></pre>

<hr>
<h2 id='unglue_regex'>Converts unglue pattern to regular regex pattern</h2><span id='topic+unglue_regex'></span>

<h3>Description</h3>

<p>Transforms a vector of patterns given in the unglue
format to a vector of proper regex (PCRE) patterns (so they can for instance
be used with functions from other packages).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unglue_regex(
  patterns,
  open = "{",
  close = "}",
  use_multiple = FALSE,
  named_capture = FALSE,
  attributes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unglue_regex_+3A_patterns">patterns</code></td>
<td>
<p>a character vector or a list of character vectors, if a list,
items will be pasted using an empty separator (<code>""</code>).</p>
</td></tr>
<tr><td><code id="unglue_regex_+3A_open">open</code></td>
<td>
<p>The opening delimiter.</p>
</td></tr>
<tr><td><code id="unglue_regex_+3A_close">close</code></td>
<td>
<p>The closing delimiter.</p>
</td></tr>
<tr><td><code id="unglue_regex_+3A_use_multiple">use_multiple</code></td>
<td>
<p>whether we should consider that duplicate labels can match
different substrings.</p>
</td></tr>
<tr><td><code id="unglue_regex_+3A_named_capture">named_capture</code></td>
<td>
<p>whether to incorporate the names of the groups in the
output regex</p>
</td></tr>
<tr><td><code id="unglue_regex_+3A_attributes">attributes</code></td>
<td>
<p>whether to give group attributes to the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>patterns &lt;- c("{number=\\d+} is [{what}]", "{word=\\D+} is [{what}]")
unglue_regex(patterns)
</code></pre>

<hr>
<h2 id='unglue_sub'>unglue_sub</h2><span id='topic+unglue_sub'></span>

<h3>Description</h3>

<p>substitute substrings using strings or replacement functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unglue_sub(x, patterns, repl, open = "{", close = "}")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unglue_sub_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="unglue_sub_+3A_patterns">patterns</code></td>
<td>
<p>a character vector or a list of character vectors, if a list,
items will be pasted using an empty separator (<code>""</code>).</p>
</td></tr>
<tr><td><code id="unglue_sub_+3A_repl">repl</code></td>
<td>
<p>function to apply on matched substrings, formula (if package rlang
is installed), substring, or named list of such.</p>
</td></tr>
<tr><td><code id="unglue_sub_+3A_open">open</code></td>
<td>
<p>The opening delimiter.</p>
</td></tr>
<tr><td><code id="unglue_sub_+3A_close">close</code></td>
<td>
<p>The closing delimiter.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>unglue_sub(
  c("a and b", "foo or bar"),
  c("{x} and {y}", "{x} or {z}"),
  "XXX")

unglue_sub(
  c("a and b", "foo or bar"),
  c("{x} and {y}", "{x} or {z}"),
  toupper)

unglue_sub(
  c("a and b", "foo or BAR"),
  c("{x} and {y}", "{x} or {z}"),
  list(x= "XXX", y = toupper, z = tolower))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
