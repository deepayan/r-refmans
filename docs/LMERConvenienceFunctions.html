<!DOCTYPE html><html><head><title>Help for package LMERConvenienceFunctions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LMERConvenienceFunctions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bfFixefLMER_F.fnc'><p>Back-fits an LMER model on p-values from ANOVA, llrt, AIC, BIC, relLik.AIC or relLik.BIC.</p></a></li>
<li><a href='#bfFixefLMER_t.fnc'><p>Back-fits an LMER model on absolute t-value and, optionally, on LLRT.</p></a></li>
<li><a href='#cd'><p>Change directory.</p></a></li>
<li><a href='#cdf'><p>Change directory; list files and directories in new directory using function <code>f</code>.</p></a></li>
<li><a href='#cdup'>
<p>Change directory one level up.</p></a></li>
<li><a href='#cn'><p>List the column names of a data frame in matrix format.</p></a></li>
<li><a href='#f'><p>List files and directories in current directory.</p></a></li>
<li><a href='#ffRanefLMER.fnc'><p>Forward-fit the random effect structure of an LMER model.</p></a></li>
<li><a href='#fitLMER.fnc'><p>Back-fit fixed effects and forward-fit random effects of an LMER model.</p></a></li>
<li><a href='#LMERConvenienceFunctions-package'><p>Model Selection and Post-Hoc Analysis for (G)LMER Models</p></a></li>
<li><a href='#mcp.fnc'><p>Model criticism plots.</p></a></li>
<li><a href='#mcposthoc.fnc'><p>Posthoc analyses for LMER models using parallel capabilities.</p></a></li>
<li><a href='#pamer.fnc'><p>ANOVA with upper- and lower-bound <em>p</em>-values and R-sqaured values for LMER.</p></a></li>
<li><a href='#perSubjectTrim.fnc'><p>Per-subject Trimming of Response Variable.</p></a></li>
<li><a href='#plotDensity3d.fnc'><p>Kernel density estimation for two continuous variables.</p></a></li>
<li><a href='#plotLMER.fnc'><p>plot a mer object</p></a></li>
<li><a href='#plotLMER3d.fnc'><p>Dynamic 3d plot for <code>mer</code> object.</p></a></li>
<li><a href='#plotRaw3d.fnc'><p>Visualize raw surface averages (3d)</p></a></li>
<li><a href='#relLik'><p>Relative log-likehood.</p></a></li>
<li><a href='#romr.fnc'><p>Exclude outliers.</p></a></li>
<li><a href='#summary.mcposthoc'><p>Summarize a &quot;mcposthoc&quot; object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Selection and Post-Hoc Analysis for (G)LMER Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Tremblay, Statistics Canada, and Johannes Ransijn, University of Copenhagen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Antoine Tremblay, Statistics Canada" &lt;trea26@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The main function of the package is to perform backward selection of fixed effects, forward fitting of the random effects, and post-hoc analysis using parallel capabilities. Other functionality includes the computation of ANOVAs with upper- or lower-bound p-values and R-squared values for each model term, model criticism plots, data trimming on model residuals, and data visualization. The data to run examples is contained in package LCF_data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>lme4</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, LCFdata, fields, mgcv, parallel, methods, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-06 03:39:48 UTC; antoine</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-06 10:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bfFixefLMER_F.fnc'>Back-fits an LMER model on p-values from ANOVA, llrt, AIC, BIC, relLik.AIC or relLik.BIC.</h2><span id='topic+bfFixefLMER_F.fnc'></span>

<h3>Description</h3>

<p>This function back-fits an initial LMER model either on upper- or lower-bound <em>p</em>-values obtained from function <code>pamer.fnc</code>, log-likelihood ratio testing (LLRT), AIC, BIC, relLik.AIC, or relLik.BIC. Note that this function CANNOT be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfFixefLMER_F.fnc(model, item = FALSE, 
method = c("F", "llrt", "AIC", "BIC", "relLik.AIC", 
"relLik.BIC"), threshold = NULL, alpha = NULL, 
alphaitem = NULL, prune.ranefs = TRUE, 
p.value = "upper", set.REML.FALSE = TRUE, 
keep.single.factors=FALSE, reset.REML.TRUE = TRUE, 
log.file = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). Note that
this function cannot be used with generalized linear mixed-effects models
(<code>glmer</code>s).</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_item">item</code></td>
<td>
<p>Whether or not to evaluate the addition of by-item random
intercepts to the model, evaluated by way of log-likelihood ratio test.
Either <code>FALSE</code> (the default) or the column name (quoted) of the item
identifier (e.g., <code>"Item"</code>, or <code>"Word"</code>).</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_method">method</code></td>
<td>
<p>Backfitting method. One of &quot;F&quot; (<em>p</em>-value), &quot;llrt&quot;, &quot;AIC&quot;,
&quot;BIC&quot;, &quot;relLik.AIC&quot;, or &quot;relLik.BIC&quot; (relative likelihood, see function
<code>relLik</code>). Defaults to <code>F</code>. You can find information regarding
differences between AIC and BIC from
<code>http://methodology.psu.edu/eresources/ask/sp07</code>.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_threshold">threshold</code></td>
<td>
<p>Method-specific threshold for parameter selection. It refers
to alpha in the case of &quot;F&quot; and &quot;llrt&quot;, to the minimum reduction in
likelihood in the case of &quot;AIC&quot; and &quot;BIC&quot;, or to the minimum difference
in probability in the case of &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;. Defaults
<code>NULL</code>, which means <code>0.05</code> for &quot;F&quot; and &quot;llrt&quot;, 5 for &quot;AIC&quot; and
&quot;BIC&quot;, and 4 for &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;.</p>
</td></tr> <tr><td><code id="bfFixefLMER_F.fnc_+3A_alpha">alpha</code></td>
<td>
<p>If the
method is <code>F</code>, it is the <em>p</em>-value (from <code>pamer.fnc</code>)
above which a model term is dropped. In this case, it defaults to the
value passed to argument <code>threshold</code>, i.e., 0.05. Otherwise it is
the <em>p</em>-value threshold above which a test (see <code>method</code>) is
performed between a model with the term under consideration and a simpler
model without it (in this case, defaults to <code>0</code>, i.e. all terms will
be tested).</p>
</td></tr> <tr><td><code id="bfFixefLMER_F.fnc_+3A_alphaitem">alphaitem</code></td>
<td>
<p>Alpha value for the evaluation of by-item
random intercepts. Defaults to <code>0.05</code> or to the specified
threshold.</p>
</td></tr> <tr><td><code id="bfFixefLMER_F.fnc_+3A_prune.ranefs">prune.ranefs</code></td>
<td>
<p>Logical. Whether to remove any random
effect for which its variable is not also present in the fixed effects
structure (with the exception of the grouping variables such as
<code>"Subjects"</code> and <code>"Items"</code>). Defaults to <code>TRUE</code>. For
example, if the random effects structure contains the terms
<code>Condition + ROI + Group</code>, and the random effects structure contains
the terms <code>(1 | Subject) + (0 + TrialNum | Subject)</code>, the random
effect <code>(0 + TrialNum | Subject)</code> will be pruned from the model
given that it is not in the model's fixed effects structure.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_p.value">p.value</code></td>
<td>
<p>If <code>method = "F"</code>, whether to use upper-bound (&ldquo;upper&rdquo;;
the default) or lower-bound (&ldquo;lower&rdquo;) <em>p</em>-values during
backfitting.</p>
</td></tr> <tr><td><code id="bfFixefLMER_F.fnc_+3A_set.reml.false">set.REML.FALSE</code></td>
<td>
<p>Logical. Whether or not to set
<code>REML</code> to <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_keep.single.factors">keep.single.factors</code></td>
<td>
<p>Logical. Whether or not main effects are kept (not
subjected to testing and reduction). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_F.fnc_+3A_reset.reml.true">reset.REML.TRUE</code></td>
<td>
<p>Logical. Whether or not to re-set the back-fitted
model to <code>REML = TRUE</code>.</p>
</td></tr> <tr><td><code id="bfFixefLMER_F.fnc_+3A_log.file">log.file</code></td>
<td>
<p>Whether a back-fitting log
should be saved. Defaults to <code>NULL</code>, which means that a log is saved
in a temporary folder with the file name <code>file.path(tempdir(),
		  paste("bfFixefLMER_F_log_", gsub(":", "-", gsub(" ", "_", date())),
		  ".txt", sep = ""))</code>. The path and file name of the log can be changed
to whatever the use wishes. Set to <code>FALSE</code> to disable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The back-fitting process works as follows: </p>
 <ol>
<li><p> If
argument <code>method</code> is not set to <code>F</code>, <code>REML</code> is set to
<code>FALSE</code>; </p>
</li>
<li><p> First consider only highest-order interaction model
terms: </p>
 <ol>
<li><p> If <code>method</code> is <code>F</code>, the model term
with the highest ANOVA <em>p</em>-value is identified. If this
<em>p</em>-value is higher than <code>alpha</code>,the model term is
removed and a new model is fitted. This is repeated for each model
term that has a <em>p</em>-value higher than the <code>alpha</code> value.
The algorithm then moves on to step (b). If <code>method</code> is not
<code>F</code>, the model term with the lowest <em>p</em>-value is
identified and the following is evaluated: </p>
 <ol>
<li><p> A new
model without this model term is fitted; </p>
</li>
<li><p> The more complex
and simpler models are compared by way of a log-likelihood
ratio test in case <code>method</code> is &quot;llrt&quot;, by way of AIC or
BIC values in case <code>method</code> is &quot;AIC&quot; or &quot;BIC&quot;, or by
calculating the <code>relLik</code> based on AIC or BIC in case
<code>method</code> is &quot;relLik.AIC&quot; or &quot;relLik.BIC&quot;. If the result
determines that the term under consideration does not increase
model fit, it is removed; otherwise it is kept.  </p>
</li>
<li><p> Move on
to the next model term with the smallest <em>p</em>-value smaller
than <code>alpha</code> and repeat steps (i)&ndash;(iii).  </p>
</li></ol>
 </li>
<li><p> Once
all highest-order interaction terms have been evaluated, go down to
the second highest order interactions: Repeat steps (ai)&ndash;(aiii)
with the following addition: If a term would be removed from the
model, but it is part of a high-order interaction, keep it. Once
all terms of the interaction level have been evaluated, move down
to the next lower-order level until main effects have been
evaluated, after which the process stops. If <code>keep.single
				factors = TRUE</code>, the process stops after the evaluation of all
interaction terms.  </p>
</li></ol>
 </li>
<li><p> If argument <code>method</code> is set to
something else other than &quot;F&quot;, set <code>reset.REML.TRUE</code> to
<code>TRUE</code> (default) unless otherwise specified.  </p>
</li></ol>

<p>In brief, if <code>method</code> is set to &quot;F&quot;, a term remains in the model if its
<em>p</em>-value is equal to or greater than <code>alpha</code>; if <code>method</code> is
set to something else, a term remains in the model if </p>
 <ol>
<li><p> its
<em>p</em>-value from the ANOVA is equal to or smaller than <code>alpha</code>;
</p>
</li>
<li><p> it significantly increases model fit as determined by the specified
method; </p>
</li>
<li><p> it is part of a significant higher-order interaction term.  </p>
</li></ol>

<p>This backfitting method was used in Newman, Tremblay, Nichols, Neville, and
Ullman (2012). If factorial terms are included in the initial model,
back-fitting on F is recommended.  </p>


<h3>Value</h3>

<p>A <code>mer</code> model
with back-fitted fixed effects is returned and a log of the back-fitting
process is printed on screen and (by default) in a log file in a temporary
file.</p>


<h3>Warnings</h3>

<p>Upper-bound <em>p</em>-values can be anti-conservative, while
lower-bound <em>p</em>-values can be conservative. See function
<code>pamer.fnc</code>.</p>


<h3>Note</h3>

<p>If you get this error:
</p>
<pre>

Error in model.frame.default(data = ..2, formula = log_Segment_Duration ~  :
The ... list does not contain 2 elements </pre>
<p>It is probably because you updated the model using function <code>update</code> and
the data now appears as <code>data = ..2</code> or something similar to this. You can
check this by typing <code>model@call</code>. If this is the case, re-fit your model
as <code>lmer(DV ~ IV + IV + (RANEF), data = dat)</code>.</p>


<h3>Author(s)</h3>

<p>Antoine
Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a> and Johannes Ransijn
<a href="mailto:johannesransijn@gmail.com">johannesransijn@gmail.com</a>.</p>


<h3>References</h3>

<p> Newman, A.J., Tremblay, A., Nichols, E.S., Neville, H.J.,
and Ullman, M.T. (2012). The Influence of Language Proficiency on Lexical
Semantic Processing in Native and Late Learners of English. <em>Journal of
Cognitive Neuroscience</em>, <em>25</em>, 1205&ndash;1223.  </p>


<h3>See Also</h3>

<p><code><a href="#topic+bfFixefLMER_t.fnc">bfFixefLMER_t.fnc</a>; </code>
<code><a href="#topic+ffRanefLMER.fnc">ffRanefLMER.fnc</a>; </code>
<code><a href="#topic+fitLMER.fnc">fitLMER.fnc</a>; </code>
<code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a>; </code>
<code><a href="#topic+pamer.fnc">pamer.fnc</a>; </code>
<code><a href="#topic+mcp.fnc">mcp.fnc</a>; </code>
<code><a href="#topic+relLik">relLik</a>; </code>
<code><a href="#topic+romr.fnc">romr.fnc</a>; </code>
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a>.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='bfFixefLMER_t.fnc'>Back-fits an LMER model on absolute t-value and, optionally, on LLRT.</h2><span id='topic+bfFixefLMER_t.fnc'></span>

<h3>Description</h3>

<p>This function back-fits an initial LMER model on <em>t</em>-values, and, if enabled, log-likelihood ratio testing. Note that, this function CAN be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfFixefLMER_t.fnc(model, item = FALSE,
method = c("t", "z", "llrt", "AIC", "BIC", "relLik.AIC", 
"relLik.BIC"), threshold = NULL, t.threshold = NULL, 
alphaitem = NULL, prune.ranefs = TRUE, set.REML.FALSE = TRUE, 
keep.single.factors=FALSE, reset.REML.TRUE = TRUE, 
log.file = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). Note that this function can be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_item">item</code></td>
<td>
<p>Whether or not to evaluate the addition of by-item random intercepts to the model, evaluated by way of log-likelihood ratio test. Either <code>FALSE</code> (the default) or the column name (quoted) of the item identifier (e.g., <code>"Item"</code>, or <code>"Word"</code>).</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_method">method</code></td>
<td>
<p>Backfitting method. One of &quot;t&quot; (lmer), &quot;z&quot; (glmer), &quot;llrt&quot;, &quot;AIC&quot;, &quot;BIC&quot;, &quot;relLik.AIC&quot;, or &quot;relLik.BIC&quot; (the latter two are based on relative likelihood, see function <code>relLik</code>). Defaults to &quot;t&quot;. You can find information regarding differences between AIC and BIC from <code>http://methodology.psu.edu/eresources/ask/sp07</code>.</p>
</td></tr>  
<tr><td><code id="bfFixefLMER_t.fnc_+3A_threshold">threshold</code></td>
<td>
<p>Method-specific threshold for parameter selection. It refers to the minimum <em>t</em>/<em>z</em>-value in the case of &quot;t&quot; or &quot;z&quot;, to the alpha value in the case of &quot;llrt&quot;, to the minimum reduction in likelihood in the case of &quot;AIC&quot; and &quot;BIC&quot;, or to the minimum difference in probability in the case of &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;. Defaults <code>NULL</code>, which means <code>2</code> for &quot;t&quot; and &quot;z&quot;, <code>0.05</code> for &quot;llrt&quot;, 5 for &quot;AIC&quot; and &quot;BIC&quot;, and 4 for &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_t.threshold">t.threshold</code></td>
<td>
<p>Defaults to <code>NULL</code>. If the <code>method = "t"</code> or <code>method = "z"</code>, it is the <em>t</em>/<em>z</em>-value below which a model term is dropped (if <code>t.threshold = NULL</code>, it will be set to 2). Otherwise it is the threshold for <em>t</em>/<em>z</em>-value below which a test (see <code>method</code>) is performed between a model with the term under consideration and a simpler model without it (if <code>t.threshold = NULL</code>, it is set to <code>Inf</code>, which means that all terms are tested.</p>
</td></tr> 
<tr><td><code id="bfFixefLMER_t.fnc_+3A_alphaitem">alphaitem</code></td>
<td>
<p>Alpha value for the evaluation of by-item random intercepts. Defaults to <code>0.05</code> or to the specified threshold in case <code>method</code> is <code>llrt</code>.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_prune.ranefs">prune.ranefs</code></td>
<td>
<p>Logical. Whether to remove any random effect for which its variable is not also present in the fixed effects structure (with the exception of the grouping variables such as <code>"Subjects"</code> and <code>"Items"</code>). Defaults to <code>TRUE</code>. For example, if the random effects structure contains the terms <code>Condition + ROI + Group</code>, and the random effects structure contains the terms <code>(1 | Subject) + (0 + TrialNum | Subject)</code>, the random effect <code>(0 + TrialNum | Subject)</code> will be pruned from the model given that it is not in the model's fixed effects structure.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_set.reml.false">set.REML.FALSE</code></td>
<td>
<p>Logical. Whether or not to set REML to <code>FALSE</code>. Defaults to <code>TRUE</code>. Not used for glmer models.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_reset.reml.true">reset.REML.TRUE</code></td>
<td>
<p>Logical. Whether or not to re-set the back-fitted model to <code>REML = TRUE</code>. Not used for glmer models.</p>
</td></tr>
<tr><td><code id="bfFixefLMER_t.fnc_+3A_keep.single.factors">keep.single.factors</code></td>
<td>
<p>Logical. Whether or not main effects are kept (not subjected to testing and reduction). Defaults to <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="bfFixefLMER_t.fnc_+3A_log.file">log.file</code></td>
<td>
<p>Whether a back-fitting log should be saved. Defaults to <code>NULL</code>, which means that a log is saved in a temporary folder with the file name <code>file.path(tempdir(), paste("bfFixefLMER_F_log_", gsub(":", "-", gsub(" ", "_", date())), ".txt", sep = ""))</code>. The path and file name of the log can be changed to whatever the use wishes. Set to <code>FALSE</code> to disable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The back-fitting process works as follows:
</p>

<ol>
<li><p> If argument <code>method</code> is not set to &quot;t&quot;, <code>REML</code> is set to <code>FALSE</code>;
</p>
</li>
<li><p> First consider only highest-order interaction model terms:
</p>

<ol>
<li><p> If <code>method</code> is &quot;t&quot; or &quot;z&quot;, the model term with the lowest <em>t</em>/<em>z</em>-value is identified. If this <em>t</em>/<em>z</em>-value is smaller than <code>threshold</code>, the model term is removed and a new model is fitted. This is repeated for each model term for term that has a <em>t</em>-value smaller than the threshold value. The algorithm then moves on to step (b). If <code>method</code> is not &quot;t&quot; or &quot;z&quot;, the model term with the lowest <em>t</em>/<em>z</em>-value-value is identified and the following is evaluated:
</p>

<ol>
<li><p> A new model without this model term is fitted; 
</p>
</li>
<li><p> The more complex and simpler models are compared by way of a log-likelihood ratio test in case <code>method</code> is &quot;llrt&quot;, by way of AIC or BIC comparison if <code>method</code> is &quot;AIC&quot; &quot;BIC&quot;, or by calculating the <code>relLik</code> based on AIC or BIC in case <code>method</code> is &quot;relLik.AIC&quot; or &quot;relLik.BIC&quot;. If the result determines that the term under consideration does not increase model fit, it is removed; otherwise it is kept.
</p>
</li>
<li><p> Move on to the next model term with the smallest <em>t</em>/<em>z</em>-value smaller than <code>threshold</code> and repeat steps (i)&ndash;(iii).
</p>
</li></ol>

</li>
<li><p> Once all highest-order interaction terms have been evaluated, go down to the second highest order interactions: Repeat steps (ai)&ndash;(aiii) with the following addition: If a term would be removed from the model, but it is part of a high-order interaction, keep it. Once all terms of the interaction level have been evaluated, move down to the next lower-order level until main effects have been evaluated, after which the process stops. If <code>keep.single factors = TRUE</code>, the process stops after the evaluation of all interaction terms.
</p>
</li></ol>

</li>
<li><p> If argument <code>method</code> is set to something other than <code>t</code> or <code>z</code>, set <code>reset.REML.TRUE</code> to <code>TRUE</code> (default) unless otherwise specified.
</p>
</li></ol>

<p>In brief, if <code>method</code> is set to &quot;t&quot; or &quot;z&quot;, a term remains in the model if its <em>t</em>/<em>z</em>-value is equal to or greater than <code>threshold</code>; if <code>method</code> is set to something else, a term remains in the model if
</p>

<ol>
<li><p> its <em>t</em>/<em>z</em>-value is equal to or greater than <code>threshold</code>;
</p>
</li>
<li><p> it significantly increases model fit as determined by the specified method;
</p>
</li>
<li><p> it is part of a significant interaction term.
</p>
</li></ol>

<p>This backfitting method was used in Tremblay &amp; Tucker (2011). If factorial terms with more than two levels are included in the initial model, back-fitting on F is recommended. 
</p>


<h3>Value</h3>

<p>A <code>mer</code> model with back-fitted fixed effects (on <code>t</code>-values) is returned and a log of the back-fitting process is printed on screen and (by default) in a log file.</p>


<h3>Note</h3>

<p>If you get this error:
</p>
<pre>

Error in model.frame.default(data = ..2, formula = log_Segment_Duration ~  : 
  The ... list does not contain 2 elements
</pre>
<p>It is probably because you updated the model using function <code>update</code> and the data now appears as <code>data = ..2</code> or something similar to this. You can check this by typing <code>model@call</code>. If this is the case, re-fit your model as <code>lmer(DV ~ IV + IV + (RANEF), data = dat)</code>.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a> and Johannes Ransijn <a href="mailto:johannesransijn@gmail.com">johannesransijn@gmail.com</a>.</p>


<h3>References</h3>

<p>Tremblay, A. and Tucker B. V. (2011). The Effects of N-gram Probabilistic Measures on the Processing and Production of Four-word Sequences. <em>The Mental Lexicon</em>, <em>6(2)</em>, 302&ndash;324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfFixefLMER_F.fnc">bfFixefLMER_F.fnc</a>; </code>
<code><a href="#topic+ffRanefLMER.fnc">ffRanefLMER.fnc</a>; </code>
<code><a href="#topic+fitLMER.fnc">fitLMER.fnc</a>; </code>
<code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a>; </code>
<code><a href="#topic+pamer.fnc">pamer.fnc</a>; </code>
<code><a href="#topic+mcp.fnc">mcp.fnc</a>; </code>
<code><a href="#topic+relLik">relLik</a>; </code>
<code><a href="#topic+romr.fnc">romr.fnc</a>; </code>
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a>. </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='cd'>Change directory.</h2><span id='topic+cd'></span>

<h3>Description</h3>

<p>Change directory to the one corresponding to the row number listed by function <code>f</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd(dir)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cd_+3A_dir">dir</code></td>
<td>
<p>The row number corresponding to the directory list returned by function <code>f</code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>Change directory to the selected one.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+f">f</a>; </code>
<code><a href="#topic+cdf">cdf</a>; </code>
<code><a href="#topic+cdup">cdup</a>; </code>
<code><a href="base.html#topic+setwd">setwd</a> </code>
</p>

<hr>
<h2 id='cdf'>Change directory; list files and directories in new directory using function <code>f</code>.</h2><span id='topic+cdf'></span>

<h3>Description</h3>

<p>Change directory to the one corresponding to the row number returned by function <code>f</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(dir)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_+3A_dir">dir</code></td>
<td>
<p>The row number corresponding to the directory listed by function <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cheange to new directory and list files and directories in new directory using function <code>f</code>.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+f">f</a>; </code>
<code><a href="#topic+cd">cd</a>; </code>
<code><a href="#topic+cdup">cdup</a>; </code>
<code><a href="base.html#topic+setwd">setwd</a> </code>
</p>

<hr>
<h2 id='cdup'>
Change directory one level up. 
</h2><span id='topic+cdup'></span>

<h3>Description</h3>

<p>Change directory one level up and list directory and files in new directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdup()
</code></pre>


<h3>Value</h3>

<p>Change directory one level up.
</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, &lt;trea26@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f">f</a>; </code>
<code><a href="#topic+cd">cd</a>; </code>
<code><a href="#topic+cdf">cdf</a>; </code>
<code><a href="base.html#topic+setwd">setwd</a> </code>
</p>

<hr>
<h2 id='cn'>List the column names of a data frame in matrix format.</h2><span id='topic+cn'></span>

<h3>Description</h3>

<p>The colum names of the specified data frame are listed in matrix format, that is, each one appears in one row preceded by the row number.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cn(data.frame)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cn_+3A_data.frame">data.frame</code></td>
<td>
<p>A data frame.</p>
</td></tr></table>


<h3>Value</h3>

<p>A matrix containing the column names of the data frame.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colnames">colnames</a></code>
</p>

<hr>
<h2 id='f'>List files and directories in current directory.</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>List files and directories in current directory in matrix format. Each row is preceded by a row number.</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(path = ".", pattern = NULL, all.files = FALSE, 
full.names = FALSE, recursive = FALSE, ignore.case = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_+3A_path">path</code></td>
<td>
<p>A character vector of full path names; the default corresponds to the working directory <code>getwd()</code>. Missing values will be ignored.</p>
</td></tr>
<tr><td><code id="f_+3A_pattern">pattern</code></td>
<td>
<p>An optional regular expression. Only file names which match the regular expression will be returned.</p>
</td></tr>
<tr><td><code id="f_+3A_all.files">all.files</code></td>
<td>
<p>Logical. If <code>FALSE</code>, only the names of visible files are returned.  If <code>TRUE</code>, all file names will be returned.</p>
</td></tr>
<tr><td><code id="f_+3A_full.names">full.names</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the directory path is prepended to the file names.  If <code>FALSE</code>, only the file names are returned.</p>
</td></tr>
<tr><td><code id="f_+3A_recursive">recursive</code></td>
<td>
<p>Logical. Should the listing recurse into directories?</p>
</td></tr>
<tr><td><code id="f_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical. Should pattern-matching be case-insensitive?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the names of the files and directories, preceded by a row number, in the specified directories. If a path does not exist or is not a directory or is unreadable it is skipped, with a warning.  
</p>
<p>The files are sorted in alphabetical order, on the full path if <code>full.names = TRUE</code>. Directories are included only if <code>recursive = FALSE</code>.</p>


<h3>Note</h3>

<p>File naming conventions are platform dependent.  <code>recursive = TRUE</code> is not supported on all platforms and may be ignored (with a warning).</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+list.files">list.files</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f()
</code></pre>

<hr>
<h2 id='ffRanefLMER.fnc'>Forward-fit the random effect structure of an LMER model.</h2><span id='topic+ffRanefLMER.fnc'></span>

<h3>Description</h3>

<p>Forward-fit an LMER model's random effect structure by comparing a model without one of the specified random effects and a model with it by way of log-likelihood ratio testing. If the more complex model is a significantly better fit, the random effect is kept, otherwise it is dropped. This function can now be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffRanefLMER.fnc(model, ran.effects = list(ran.intercepts = 
as.character(), slopes = as.character(), corr = as.character(), 
by.vars = as.character()), alpha = 0.05, if.warn.not.add = TRUE, 
log.file = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffRanefLMER.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). This function can now be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>
</td></tr>
<tr><td><code id="ffRanefLMER.fnc_+3A_ran.effects">ran.effects</code></td>
<td>
<p>Can be either a vector or a list. In the former case, the random effects to be evaluated are provided. For example <code>c("(1 + Frequency | Subject)", "(0 + Length | Subject)", "(1 + NSynSet | Subject)")</code>. In the latter case, the list can be composed of (i) a vector of random intercepts to be evaluated (<code>ran.intercepts</code>), (ii) a vector of random slopes to be evaluated (<code>slopes</code>), (iii) a vector specifying, for each element of <code>slopes</code>, whether the correlation between the slope and by-variables specified in <code>by.vars</code> should be added (<code>corr</code>), and (iv) a vector of &ldquo;by&rdquo; variables for the random slopes (<code>by.vars</code>). Values that can be supplied to the <code>corr</code> argument are <code>1</code> (add correlation), <code>0</code> (do not add correlation), and <code>NA</code> (for when the &quot;slope&quot; is a factor variable). Note that if a term in <code>slopes</code> is a factor variable, the <code>corr</code> value tied to it will be automatically set to <code>NA</code>. Also note that if no values are supplied to <code>corr</code>, a vector of 0 as long as the <code>slopes</code> vector will be automatically supplied. For example <code>list(ran.intercepts = "Word", slopes = c("Frequency", "Length", "NSynSet","Class"), corr = c(0, 0, 1, NA), by.vars = "Subject")</code>. Another example is <code>list(slopes = c("Trial", "Class"), by.vars = "Subject")</code>, where the <code>corr</code> argument will be equal to <code>c(0, NA)</code>.</p>
</td></tr>
<tr><td><code id="ffRanefLMER.fnc_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance for log-likelihood ratio test. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="ffRanefLMER.fnc_+3A_if.warn.not.add">if.warn.not.add</code></td>
<td>
<p>Logical. If a warning is issued after fitting a model with a new random effect (e.g., <code>false convergence</code> or the like), should the random effect nevertheless be evaluated? Defaults to <code>TRUE</code>, meaning that if such a warning is issued, the random effect will not be added to the random effects structure of the model. If set to <code>FALSE</code>, the random effect will be evaluated for inclusion as any other random effects would be via log likelihood ratio testing even if a warning is issued.</p>
</td></tr>
<tr><td><code id="ffRanefLMER.fnc_+3A_log.file">log.file</code></td>
<td>
<p>Should the back-fitting log be saved? Defaults to <code>NULL</code>, which means that a log file is saved in a temporary folder as <code>paste("ffRanefLMER_log_", gsub(":", "-", gsub(" ", "_", date())), ".txt", sep = "")</code>. The path and file name of the log can be changed to whatever the use wishes. Set to <code>FALSE</code> to disable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mer</code> object with forward-fitted random effect structure as well as a log of the process is printed on screen and, optionally, printed in a log file.</p>


<h3>Note</h3>

<p>The removal of a random effect from the random effects structure if the variables that compose it are not also in the fixed effects structure has been turned off in this version.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <code>trea26@gmail.com</code>.</p>


<h3>References</h3>

<p>Pinheiro, J.C. and Bates, D.M. (2000). <em>Mixed Effects Models in S and S-Plus</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfFixefLMER_F.fnc">bfFixefLMER_F.fnc</a>; </code>
<code><a href="#topic+bfFixefLMER_t.fnc">bfFixefLMER_t.fnc</a>; </code>
<code><a href="#topic+fitLMER.fnc">fitLMER.fnc</a>; </code>
<code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a>; </code>
<code><a href="#topic+pamer.fnc">pamer.fnc</a>; </code>
<code><a href="#topic+mcp.fnc">mcp.fnc</a>; </code>
<code><a href="#topic+romr.fnc">romr.fnc</a>; </code>
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a>. </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='fitLMER.fnc'>Back-fit fixed effects and forward-fit random effects of an LMER model.</h2><span id='topic+fitLMER.fnc'></span>

<h3>Description</h3>

<p>The function follows these steps: (1) If <code>llrt</code> is set to <code>TRUE</code>, set <code>REML</code> to <code>FALSE</code> (unless specified otherwise); (2) back-fit initial model either on <em>F</em>- (by default) or on <em>t</em>/<em>z</em>-values; (3) forward-fit random effects; (4) re-back-fit fixed effects; (5) if <code>llrt</code> is set to <code>TRUE</code>, set <code>REML</code> to <code>TRUE</code> (unless specified otherwise). Note that, this function CAN be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitLMER.fnc(model, item = FALSE, backfit.on = c("F",
"t"), method = c("F", "t", "z", "llrt", "AIC", "BIC", "relLik.AIC", 
"relLik.BIC"), threshold = NULL, t.threshold = NULL, 
ran.effects = list(ran.intercepts = as.character(), 
slopes = as.character(), corr = as.character(), 
by.vars = as.character()), alpha = NULL, alphaitem = NULL, 
if.warn.not.add = TRUE, prune.ranefs = TRUE, p.value = "upper", 
set.REML.FALSE = TRUE, keep.single.factors = FALSE, 
reset.REML.TRUE = TRUE, log.file.name = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitLMER.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). This function can be used with generalized linear mixed-effects models (<code>glmer</code>s) if argument <code>backfit.on</code> is set to &quot;t&quot;, but not if it is set to &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_item">item</code></td>
<td>
<p>Whether or not to evaluate the addition of by-item random intercepts to the model, evaluated by way of log-likelihood ratio test. Either <code>FALSE</code> (the default, does not evaluate this addition) or the column name (quoted) of the item identifier (e.g., <code>"Item"</code>, <code>"Word"</code>).</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_backfit.on">backfit.on</code></td>
<td>
<p>Either &quot;F&quot; (default) or &quot;t&quot;. Refers to the statistic which will be used to determine which term to test and potentially remove from the model. If you are backfitting a generalized linear mixed-effects model (<code>glmer</code>), make sure to set <code>backfit.on</code> to &quot;t&quot;; the algorithm efectively backfits on &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_method">method</code></td>
<td>
<p>Backfitting method. One of &quot;F&quot; (<em>p</em>-value), &quot;t&quot; (<em>t</em> statistic), &quot;z&quot; (<em>z</em> statistic), &quot;llrt&quot;, &quot;AIC&quot;, &quot;BIC&quot;, &quot;relLik.AIC&quot;, or &quot;relLik.BIC&quot; (the latter two are based on relative likelihood, see function <code>relLik</code>). Defaults to &quot;t&quot;. You can find information regarding differences between AIC and BIC from <code>http://methodology.psu.edu/eresources/ask/sp07</code>.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_threshold">threshold</code></td>
<td>
<p>Method-specific threshold for parameter selection. It refers to alpha in the case of &quot;F&quot; and &quot;llrt&quot;, to the <em>t</em>/<em>z</em>-value in case of &quot;t&quot; or &quot;z&quot;, to the minimum reduction in likelihood in the case of &quot;AIC&quot; and &quot;BIC&quot;, or to the minimum difference in probability in the case of &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;. Defaults <code>NULL</code>, which means <code>0.05</code> for &quot;F&quot; and &quot;llrt&quot;, 2 for &quot;t&quot;, 5 for &quot;AIC&quot; and &quot;BIC&quot;, and 4 for &quot;relLik.AIC&quot; and &quot;relLik.BIC&quot;.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_t.threshold">t.threshold</code></td>
<td>
<p>Defaults to <code>NULL</code>. If the <code>method = "t"</code> or <code>method = "z"</code>, it is the <em>t</em>/<em>z</em>-value below which a model term is dropped (if <code>t.threshold = NULL</code>, it will be set to 2). Otherwise it is the threshold for <em>t</em>/<em>z</em>-value below which a test (see <code>method</code>) is performed between a model with the term under consideration and a simpler model without it (if <code>t.threshold = NULL</code>, it is set to <code>Inf</code>, which means that all terms are tested.</p>
</td></tr> 
<tr><td><code id="fitLMER.fnc_+3A_ran.effects">ran.effects</code></td>
<td>
<p>Can be either a vector or a list. In the former case, the random effects to be evaluated are provided. For example <code>c("(1 + Frequency | Subject)", "(0 + Length | Subject)", "(1 + NSynSet | Subject)")</code>. In the latter case, the list can be composed of (i) a vector of random intercepts to be evaluated (<code>ran.intercepts</code>), (ii) a vector of random slopes to be evaluated (<code>slopes</code>), (iii) a vector specifying, for each element of <code>slopes</code>, whether the correlation between the slope and by-variables specified in <code>by.vars</code> should be added (<code>corr</code>), and (iv) a vector of &ldquo;by&rdquo; variables for the random slopes (<code>by.vars</code>). Values that can be supplied to the <code>corr</code> argument are <code>1</code> (add correlation), <code>0</code> (do not add correlation), and <code>NA</code> (for when the &quot;slope&quot; is a factor variable). Note that if a term in <code>slopes</code> is a factor variable, the <code>corr</code> value tied to it will be automatically set to <code>NA</code>. Also note that if no values are supplied to <code>corr</code>, a vector of 0 as long as the <code>slopes</code> vector will be automatically supplied. For example <code>list(ran.intercepts = "Word", slopes = c("Frequency", "Length", "NSynSet","Class"), corr = c(0, 0, 1, NA), by.vars = "Subject")</code>. Another example is <code>list(slopes = c("Trial", "Class"), by.vars = "Subject")</code>, where the <code>corr</code> argument will be equal to <code>c(0, NA)</code>.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_alpha">alpha</code></td>
<td>
<p>If the method is <code>F</code>, it is the <em>p</em>-value (from <code>pamer.fnc</code>) above which a model term is dropped. In this case, it defaults to the value passed to argument <code>threshold</code>, i.e., 0.05. Otherwise it is the <em>p</em>-value threshold above which a test (see <code>method</code>) is performed between a model with the term under consideration and a simpler model without it (in this case, defaults to <code>0</code>, i.e. all terms will be tested).</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_alphaitem">alphaitem</code></td>
<td>
<p>Alpha value for the evaluation of by-item random intercepts. Defaults to <code>0.05</code> or to the specified threshold.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_if.warn.not.add">if.warn.not.add</code></td>
<td>
<p>Logical. If a warning is issued after fitting a model with a new random effect (e.g., <code>false convergence</code> or the like), should the random effect nevertheless be evaluated? Defaults to <code>TRUE</code>, meaning that if such a warning is issued, the random effect will not be added to the random effects structure of the model. If set to <code>FALSE</code>, the random effect will be evaluated for inclusion as any other random effects would be via log likelihood ratio testing even if a warning is issued.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_prune.ranefs">prune.ranefs</code></td>
<td>
<p>Logical. Whether to remove any random effect for which its variable is not also present in the fixed effects structure (with the exception of the grouping variables such as <code>"Subjects"</code> and <code>"Items"</code>). Defaults to <code>TRUE</code>. For example, if the random effects structure contains the terms <code>Condition + ROI + Group</code>, and the random effects structure contains the terms <code>(1 | Subject) + (0 + TrialNum | Subject)</code>, the ranedom effect <code>(0 + TrialNum | Subject)</code> will be pruned from the model given that it is not in the model's fixed effects structure.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_p.value">p.value</code></td>
<td>
<p>Whether to use upper-bound (&ldquo;upper&rdquo;; the default) or lower-bound (&ldquo;lower&rdquo;) <em>p</em>-values when back-fitting with method &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_set.reml.false">set.REML.FALSE</code></td>
<td>
<p>Logical. Whether or not to set <code>REML</code> to <code>FALSE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_reset.reml.true">reset.REML.TRUE</code></td>
<td>
<p>Logical. Whether or not to re-set the back-fitted model to <code>REML = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitLMER.fnc_+3A_keep.single.factors">keep.single.factors</code></td>
<td>
<p>Logical. Whether or not main effects are kept (not subjected to testing and reduction). Defaults to <code>FALSE</code>.</p>
</td></tr>     
<tr><td><code id="fitLMER.fnc_+3A_log.file.name">log.file.name</code></td>
<td>
<p>Should the back-fitting log be saved? Defaults to <code>NULL</code>, which means that a log file is saved in a temporary folder (platform dependent) as <code>file.path(tempdir(), paste("fitLMER_log_", gsub(":", "-", gsub(" ", "_", date())), ".txt", sep = ""))</code>. The path and file name of the log can be changed to whatever the use wishes. Set to <code>FALSE</code> to disable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The process has three stages. In the first stage, either <code>bfFixefLMER_F.fnc</code> or <code>bfFixefLMER_t.fnc</code> is called (depending on the user's choice) and the fixed effects are back-fitted accordingly. In the second stage, <code>ffRanefLMER.fnc</code> is called and random effects are forward-fitted. In the third stage, the fixed effects are back-fitted again. This is done because the inclusion of certain random effects sometimes renders certain fixed effects non-significant. This process was used in Tremblay and Tucker (2011) and in Newman, Tremblay, Nichols, Neville, and Ullman (2012).
</p>
<p>If, for example, you have many analyses to run and a cluster is available, write a bash script that will create (1) <code>.R</code> files that will relevel the conditions and update the model, and (2) an associated <code>.sh</code> job submission script to submit the <code>.R</code> files. For example, let's consider two ERP analyses all in a time window ranging from 100 to 250 ms. Two three-way interactions were considered: Position (factor; 1 to 6) X  Length of the second word of a four-word sequence (e.g., <em>in the middle of</em>) X Working Memory Capacity score (continuous, from 0 to 100) and Trial (continuous; 1 to 432) X Length X Working Memory Capacity. Analyses were performed at electrodes Fp1 Fp2 AF3 AF4 F7 F3 Fz F4 F8 FC5 FC1 FC2 FC6 T7 C3 Cz C4 T8 CP5 CP1 CP2 CP6. See Tremblay and Newman (In preparation) for more details. The analysis script named <code>Fp1-CP6_100250.sh</code> we used on the ACEnet cluster is as follows: 
</p>
<pre>
      electrodes=(Fp1 Fp2 AF3 AF4 F7 F3 Fz F4 F8 FC5 FC1 FC2 FC6 T7 C3 Cz C4 T8 CP5 CP1 CP2 CP6)
      for e in ${electrodes[*]}; do 
            export E=$e;
            # create .R script to load data, perform necessary manipulations
            # and perform the analysis using fitLMER.fnc
            echo 'e&lt;-Sys.getenv("E")' &gt; $e".R"
            echo 'load("../data/eeg600_trim_v2.rda")' &gt;&gt; $e".R"
            echo 'dat0&lt;-dat' &gt;&gt; $e".R"
            echo 'rm(dat);gc(T,T)' &gt;&gt; $e".R"
            echo 'dat &lt;- dat0[dat0$Time &gt;= 100 &amp; dat0$Time &lt;= 250, , drop = TRUE]' &gt;&gt; $e".R"
            echo 'dat &lt;- dat[dat$Electrode == e, , drop = TRUE]' &gt;&gt; $e".R"
            echo 'subj&lt;-sort(unique(dat$Subject))' &gt;&gt; $e".R"
            echo 'for(i in subj){' &gt;&gt; $e".R"
            echo 'tmp&lt;-dat[dat$Subject==i,,drop=TRUE]' &gt;&gt; $e".R"
            echo 'tmp$newfact&lt;-paste(tmp$Block,tmp$Position,sep="_")' &gt;&gt; $e".R"
            echo 'newvec&lt;-vector("numeric")' &gt;&gt; $e".R"
            echo 'for(j in 1:length(unique(tmp$newfact))){' &gt;&gt; $e".R"
            echo 'newvec&lt;-c(newvec,rep(j,nrow(tmp[tmp$newfact==unique(tmp$newfact)[j],])))' &gt;&gt; $e".R"
            echo '}' &gt;&gt; $e".R"
            echo 'tmp$Trial&lt;-newvec' &gt;&gt; $e".R"
            echo 'if(grep(i,subj)[1]==1){' &gt;&gt; $e".R"
            echo 'newdat&lt;-tmp' &gt;&gt; $e".R"
            echo '}else{' &gt;&gt; $e".R"
            echo 'newdat&lt;-rbind(newdat,tmp)' &gt;&gt; $e".R"
            echo '}' &gt;&gt; $e".R"
            echo '}' &gt;&gt; $e".R"
            echo 'dat&lt;-newdat' &gt;&gt; $e".R"
            echo 'dat$Position&lt;-as.factor(dat$Position)' &gt;&gt; $e".R"
            echo 'm7 &lt;- lmer(Amplitude ~ (Position + Trial)*(LengthBc * WMCc) + ' &gt;&gt; $e".R"
            echo '(1 | Subject), data = dat)' &gt;&gt; $e".R"
            echo 'm7b&lt;-fitLMER.fnc(m7,item="Item",ran.effects=c("(0+Trial|Subject)",' &gt;&gt; $e".R"
            echo '"(0+LengthBc|Subject)","(0+Trial|Item)","(0+WMCc|Item)",' &gt;&gt; $e".R"
            echo '"(Position|Subject)"))' &gt;&gt; $e".R"
            echo 'smry&lt;-pamer.fnc(m7b)' &gt;&gt; $e".R"
            echo 'save(m7b,file=file.path("..","models",paste("m7b_",e,"_100250.rda",sep="")))' &gt;&gt; $e".R"
            echo 'save(smry,file=file.path("..","summaries",paste("smry_m7b_",e,"_100250.rda",sep="")))' &gt;&gt; $e".R"
  
            ### create the job submission script for the .R file created above
            echo '#$ -S /bin/bash' &gt; "job."$e".sh"
            echo '#$ -cwd' &gt;&gt; "job."$e".sh"
            echo '#$ -j y' &gt;&gt; "job."$e".sh"
            echo '#$ -l h_rt=48:00:00' &gt;&gt; "job."$e".sh"
            echo '#$ -l h_vmem=8G' &gt;&gt; "job."$e".sh"
            echo '#$ -R y' &gt;&gt; "job."$e".sh"
            echo '#$ -N '$e &gt;&gt; "job."$e".sh"
            echo 'R -q -f '$e'.R' &gt;&gt; "job."$e".sh"
            
            ### submit the job
            qsub  "job."$e".sh"
      done;

</pre>
<p>and then type in the console
</p>
<pre>
      . Fp1-CP6_100250.sh

</pre>
<p>On the ACEnet cluster, this results in 22 independent analyses, simultaneously using a total of 22 cores and 176 GB of RAM. This analysis completes in about 30 minutes to 1 hour.
</p>


<h3>Value</h3>

<p>A <code>mer</code> object with back-fitted fixed effects and forward-fitted random effects, as well as a log of the process, which is printed on screen and, optionally, printed in a log file.</p>


<h3>Warnings</h3>

<p>Upper-bound <em>p</em>-values can be anti-conservative, while lower-bound <em>p</em>-values can be conservative. See function <code>pamer.fnc</code>.</p>


<h3>Note</h3>

<p>The removal of a random effect from the random effects structure if the variables that compose it are not also in the fixed effects structure has been turned off in this version.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>References</h3>

<p>Baayen, R.H., Davidson, D.J. and Bates, D.M. (2008). Mixed-effects modeling with crossed random effects for subjects and items. Journal of Memory and Language, 59, 390&ndash;412.
</p>
<p>Newman, A.J., Tremblay, A., Nichols, E.S., Neville, H.J., and Ullman, M.T. (2012). The Influence of Language Proficiency on Lexical Semantic Processing in Native and Late Learners of English. <em>Journal of Cognitive Neuroscience</em>, <em>25</em>, 1205&ndash;1223.
</p>
<p>Pinheiro, J.C. and Bates, D.M. (2000). <em>Mixed Effects Models in S and S-Plus</em>. New York: Springer.
</p>
<p>Tremblay, A. and Tucker B. V. (2011). The Effects of N-gram Probabilistic Measures on the Processing and Production of Four-word Sequences. <em>The Mental Lexicon</em>, <em>6(2)</em>, 302&ndash;324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfFixefLMER_F.fnc">bfFixefLMER_F.fnc</a>; </code>
<code><a href="#topic+bfFixefLMER_t.fnc">bfFixefLMER_t.fnc</a>; </code>
<code><a href="#topic+ffRanefLMER.fnc">ffRanefLMER.fnc</a>; </code>
<code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a>; </code>
<code><a href="#topic+pamer.fnc">pamer.fnc</a>; </code>
<code><a href="#topic+mcp.fnc">mcp.fnc</a>; </code>
<code><a href="#topic+relLik">relLik</a>; </code>
<code><a href="#topic+romr.fnc">romr.fnc</a>; </code>
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a>. </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='LMERConvenienceFunctions-package'>Model Selection and Post-Hoc Analysis for (G)LMER Models</h2><span id='topic+LMERConvenienceFunctions-package'></span><span id='topic+LMERConvenienceFunctions'></span>

<h3>Description</h3>

<p>The main function of the package is to perform backward selection of fixed effects, forward fitting of the random effects, and post-hoc analyses using parallel capabilities. Other functionality includes the computation of ANOVAs with upper- or lower-bound p-values and R-squared values for each model term, model criticism plots, data trimming on model residuals, and data visualization. The data to run examples is contained in package <code>LCF_data</code>.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> LMERConvenienceFunctions</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-09-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, and Johannes Ransijn, University of Copenhagen
</p>
<p>Maintainer: &quot;Antoine Tremblay, Statistics Canada&quot; &lt;trea26@gmail.com&gt;
</p>


<h3>References</h3>

<p>Baayen, R.H. (2008). <em>Analyzing Linguistic Data. A Practical Introduction to Statistics Using R</em>. Cambridge, UK: Cambridge University Press. 
</p>
<p>Baayen, R.H., Davidson, D.J. and Bates, D.M. (2008). Mixed-effects modeling with crossed random effects for subjects and items. <em>Journal of Memory and Language</em>, <em>59</em>, 390&ndash;412.
</p>
<p>Newman, A.J., Tremblay, A., Nichols, E.S., Neville, H.J., and Ullman, M.T. (2012). The Influence of Language Proficiency on Lexical Semantic Processing in Native and Late Learners of English. <em>Journal of Cognitive Neuroscience</em>, <em>25</em>, 1205&ndash;1223.
</p>
<p>Newman, A.J., Tremblay, A., Neville, H.J., and Ullman, M.T. (In preparation).  The relationship between proficiency and ERP components evoked by grammatical violations in native and late learners of English.
</p>
<p>Pinheiro, J.C. and Bates, D.M. (2000). <em>Mixed Effects Models in S and S-Plus</em>. New York: Springer.
</p>
<p>Quene, H., &amp; van den Bergh, H. (2008). Examples of mixed-effects modeling with crossed random effects and with binomial data. <em>Journal of Memory and Language</em>, 59, 413&ndash;425. doi: 10.1016/j.jml.2008.02.002.
</p>
<p>Symonds, M.R.E and Moussalli, A. (2011). <em>A brief guide to model selection, multimodel inference and model averaging in behavioural ecology using Akaike's information criterion.</em> <em>Behavioral Ecology and Sociobiology</em>, 65, 13&ndash;21. doi: 10.1007/s00265-010-1037-6
</p>
<p>Tremblay, Antoine. (2009). <em>Processing Advantages of Lexical Bundles: Evidence from Self-paced Reading, Word and Sentence Recall, and Free Recall with Event-related Brain Potential Recordings</em>. Ph.D. Dissertation. University of Alberta, Edmonton, Canada.
</p>
<p>Tremblay, A. and Tucker B. V. (2011). The Effects of N-gram Probabilistic Measures on the Processing and Production of Four-word Sequences. <em>The Mental Lexicon</em>, <em>6(2)</em>, 302&ndash;324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfFixefLMER_F.fnc">bfFixefLMER_F.fnc</a></code>;
<code><a href="#topic+bfFixefLMER_t.fnc">bfFixefLMER_t.fnc</a></code>;
<code><a href="#topic+ffRanefLMER.fnc">ffRanefLMER.fnc</a></code>;
<code><a href="#topic+fitLMER.fnc">fitLMER.fnc</a></code>;
<code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a></code>;
<code><a href="#topic+summary.mcposthoc">summary.mcposthoc</a></code>;
<code><a href="#topic+pamer.fnc">pamer.fnc</a></code>;
<code><a href="#topic+mcp.fnc">mcp.fnc</a></code>;
<code><a href="#topic+relLik">relLik</a></code>;
<code><a href="#topic+romr.fnc">romr.fnc</a></code>;
<code><a href="#topic+plotLMER.fnc">plotLMER.fnc</a></code>;
<code><a href="#topic+plotLMER3d.fnc">plotLMER3d.fnc</a></code>;
<code><a href="#topic+plotDensity3d.fnc">plotDensity3d.fnc</a></code>;
<code><a href="#topic+plotRaw3d.fnc">plotRaw3d.fnc</a></code>;
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a></code>;
<code><a href="#topic+cn">cn</a></code>;
<code><a href="#topic+f">f</a></code>;
<code><a href="#topic+cd">cd</a></code>;
<code><a href="#topic+cdf">cdf</a></code>;
<code><a href="#topic+cdup">cdup</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ############################################
  #            Load and format data.         #
  ############################################
  library(LCFdata)
  data(eeg)

  # restrict to electrode Fz and 80--180 ms window
  eeg &lt;- eeg[eeg$Time &gt;= 80 &amp; eeg$Time &lt;= 180, ]
  eeg &lt;- eeg[, c("Subject", "Item", "Time", "Fz",
    "FreqB", "LengthB", "WMC")]

  # mean center FreqB
  eeg$FreqBc &lt;- eeg$FreqB - mean(eeg$FreqB)
  # split FreqBc into 3 categories. Doesn't make sense, 
  # but it's merely for example
  eeg$FreqBdc &lt;- "high"
  eeg$FreqBdc[eeg$FreqBc&lt;=quantile(eeg$FreqBc)[3]] &lt;- "mid"
  eeg$FreqBdc[eeg$FreqBc&lt;=quantile(eeg$FreqBc)[2]] &lt;- "low"
  eeg$FreqBdc &lt;- as.factor(eeg$FreqBdc)
  eeg$FreqBdc &lt;- relevel(eeg$FreqBdc, "low")

  # mean center LengthB
  eeg$LengthBc &lt;- eeg$LengthB - mean(eeg$LengthB)

  # mean center WMC
  eeg$WMCc &lt;- eeg$WMC - mean(eeg$WMC)

  ############################################
  #      Demonstrate plotDensity3d.fnc.      #
  ############################################
  plotDensity3d.fnc(x = sort(unique(eeg$WMCc)), 
    y = sort(unique(eeg$LengthBc)))

  ############################################
  #        Demonstrate plotRaw3d.fnc.        #
  ############################################
  plotRaw3d.fnc(data = eeg, response = "Fz", pred = "WMCc",
    intr = "LengthBc", plot.type = "persp", theta = 150)

  ############################################
  #       Analyze data. Demonstrate model    #
  #       selection, and diagnostic plots.   #
  #       Also demonstrate forward fitting   #
  #       of random effects and back fitting #
  #       of fixed effects. Finally,         #
  #       demonstrate pamer.fnc.             # 
  ############################################
  library(lme4)
  # fit initial model
  m0 &lt;- lmer(Fz ~ (FreqBdc + LengthBc + WMCc)^2 + (1 | Subject), 
    data = eeg)
  m1 &lt;- lmer(Fz ~ (FreqBdc + LengthBc + WMCc)^2 + (1 | Subject) +
    (1 | Item), data = eeg)

  # which model to choose?
  relLik(m0, m1)

  # choose m1
  # check model assumptions 
  mcp.fnc(m1)

  # remove outliers
  eeg &lt;- romr.fnc(m1, eeg, trim = 2.5)
  eeg$n.removed
  eeg$percent.removed
  eeg&lt;-eeg$data

  # update model
  m1 &lt;- lmer(Fz ~ (FreqBdc + LengthBc + WMCc)^2 + (1 | Subject) +
    (1 | Item), data = eeg)
  
  # re-check model assumptions 
  mcp.fnc(m1)

  # forward-fit random effect structure (simple for the purposes
  # of the example).
  m2 &lt;- ffRanefLMER.fnc(model = m1, ran.effects = 
    c("(0 + LengthBc | Subject)", "(0 + WMCc | Item)"), 
    log.file = FALSE)

  # backfit model m2. In this case, could use bfFixefLMER_t.fnc instead.
  m3 &lt;- bfFixefLMER_F.fnc(m2, log.file = FALSE)

  # The calls to ffRanefLMER.fnc and bfFixefLMER_F.fnc could 
  # be replaced by a call to fitLMER.fnc. In this latter case, however, 
  # bfFixefLMER_F.fnc would be called first, then the random effect 
  # structure would be forward fitted, and finally teh fixed effects
  # would be backfitted again.
  m3b &lt;- fitLMER.fnc(model = m1, ran.effects = c("(0 + LengthBc | Subject)",
    "(0 + WMCc | Item)"), backfit.on = "F", log.file = FALSE)
  pamer.fnc(m3b)
  # The results are the same. This may not necessarily be the case
  # elsewhere. First forward fitting the random effect structure and
  # then backfitting the fixed effects, potentially pruning irrelevant 
  # random effects, is probably the best approach. Nonetheless, there is 
  # no hard evidence to this effect.

  # check model assumptions 
  mcp.fnc(m3)

  # check significance of model terms
  pamer.fnc(m3)

  ############################################
  #       Demonstrate mcposthoc.fnc and      #
  #       summary.mcposthoc.                 #
  ############################################
  # Only the intercept is significant. For purposes of the 
  # example, let's perform a posthoc analysis on FreqBdc on
  # model m2.
  m2.ph &lt;- mcposthoc.fnc(model = m2, var = list(ph1 = "FreqBdc"))

  # Now check if and how the different levels differ between
  # each other. First check high vs mid and high vs low:
  summary(m2.ph, term = "FreqBdchigh") 
  # Then low vs mid (the low vs high row is redundant from the 
  # above summary):
  summary(m2.ph, term = "FreqBdcmid")
  # Note that none of the levels differ from each other. Indeed, 
  # the backfitting process indicated that the model only has an 
  # intercept (i.e., the FreqBc factor variable was not significant).

  # Just to show how one would look at posthocs for interactions. Let's 
  # look at the effect of Length at each FreqB bin:
  summary(object = m2.ph, term = "LengthBc")
  # Does Length effect different Freq bins? Start with low 
  # versus mid and high
  smry &lt;- summary(object = m2.ph, term = "FreqBdchigh:LengthBc")
  # then mid versus low and high
  smry &lt;- summary(object = m2.ph, term = "FreqBdcmid:LengthBc")

  ############################################
  #       Demonstrate `revived' version of   #
  #       plotLMER.fnc and plotLMER3d.fnc.   #
  ############################################
  # Generate plot for Length X Freq with function plotLMER.fnc.
  plotLMER.fnc(m2, pred = "LengthBc", intr = list("FreqBdc", 
    levels(eeg$FreqBdc), "beg", list(1 : 3, 1 : 3)))

  # Plotting the Length:WMC interaction with plotLMER3d.fnc. It'll
  # take a little bit of time.
  plotLMER3d.fnc(m2,"LengthBc","WMCc")
  # Plot it a second time to demonstrate caching. You can notice the 
  # speed-up.
  plotLMER3d.fnc(m2,"LengthBc","WMCc")


  ############################################
  #       Demonstrate modeling and           #
  #       backfitting of glmer.              #
  ############################################
  # Split FreqBc into 2 categories.
  eeg$FreqBdc &lt;- "high"
  eeg$FreqBdc[eeg$FreqBc&lt;=median(eeg$FreqBc)] &lt;- "low"
  eeg$FreqBdc &lt;- as.factor(eeg$FreqBdc)
  eeg$FreqBdc &lt;- relevel(eeg$FreqBdc, "low")

  # Fit glmer model.
  m4 &lt;- glmer(FreqBdc ~ (Fz + LengthBc + WMCc)^2 + (1 | Subject),
	family = "binomial", data = eeg)
  summary(m4)
  pamer.fnc(m4)

  # Back fit fixed effects, forward fit random effects, and then
  # re-back fit fixed effects. Need to set argument backfit.on to "t".
  m5 &lt;- fitLMER.fnc(model = m4, ran.effects = "(0 + LengthBc | Subject)",
	backfit.on = "t", log.file = FALSE)
  summary(m5)
  pamer.fnc(m5)

  # Plot the 2-way interaction.
  plotLMER.fnc(m5, pred = "Fz", intr = list("LengthBc", 
	quantile(eeg$LengthBc), "med",list(1:5,1:5)))

  # Look at the same plot, but in 3d.
  plotLMER3d.fnc(m5, pred = "Fz", intr = "LengthBc")

  ############################################
  #       Test backfitting on AIC,           #
  #       BIC, llrt, relLik.AIC, and         #
  #       relLik.BIC.                        #
  ############################################
  # AIC
  m.test &lt;- bfFixefLMER_F.fnc(m2, method = "AIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m2, method = "AIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m4, method = "AIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_F.fnc(m4, method = "AIC",
	log.file = FALSE)

  # BIC
  m.test &lt;- bfFixefLMER_F.fnc(m2, method = "BIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m2, method = "BIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m4, method = "BIC",
	log.file = FALSE)

  # llrt
  m.test &lt;- bfFixefLMER_F.fnc(m2, method = "llrt",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m2, method = "llrt",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m4, method = "llrt",
	log.file = FALSE)

  # relLik.AIC
  m.test &lt;- bfFixefLMER_F.fnc(m2, method = "relLik.AIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m2, method = "relLik.AIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m4, method = "relLik.AIC",
	log.file = FALSE)

  # relLik.BIC
  m.test &lt;- bfFixefLMER_F.fnc(m2, method = "relLik.BIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m2, method = "relLik.BIC",
	log.file = FALSE)
  m.test &lt;- bfFixefLMER_t.fnc(m4, method = "relLik.BIC",
	log.file = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcp.fnc'>Model criticism plots.</h2><span id='topic+mcp.fnc'></span>

<h3>Description</h3>

<p>A function to graph criticism plots for an LMER model (as in Baayen, 2008, chapter 7). Note that this function cannot be used with generalized linear mixed-effects models (GLMERs). Also note that the fourth plot (dffits) is omitted until we can figure out how to calculate dffits for a <code>merMod</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcp.fnc(model, trim = 2.5, col = "red")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcp.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). Note that, at the moment, this function cannot be used with generalized linear mixed-effects models (GLMERs).</p>
</td></tr>
<tr><td><code id="mcp.fnc_+3A_trim">trim</code></td>
<td>
<p>Used to plot lines in the fitted ~ standardized residuals plot. The lines correspond to the threshold at which residuals would be or were removed. Defaults to 2.5 (standard deviations above and below the residuals mean).</p>
</td></tr>
<tr><td><code id="mcp.fnc_+3A_col">col</code></td>
<td>
<p>Color of the lines added to the quantile-quantile plot and fitted ~ standardized residuals plot. Defaults to red.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first of the four plots graphs the density of the model residuals. The second plot graphs the quantile-quantile plot (actual standardized residuals versus theoretical quantiles). The third plot illustrates the fitted values versus the standardized residuals. The fourth graph plots the absolute values of the <code>dffits</code> of the residuals (not producing this plot as of version 2.2; might come back in future versions).</p>


<h3>Value</h3>

<p>Returns the four plots described above.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>.</p>


<h3>References</h3>

<p>Baayen, R.H. (2008). <em>Analyzing Linguistic Data. A Practical Introduction to Statistics Using R</em>. Cambridge, UK: Cambridge University Press.</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='mcposthoc.fnc'>Posthoc analyses for LMER models using parallel capabilities.</h2><span id='topic+mcposthoc.fnc'></span>

<h3>Description</h3>

<p>This function uses the <code>parallel</code> package. For each factor level, a slave process is sent to one of the computer's cores unsing function <code>mclapply</code> where the specified factor variables are re-leveled to each one of their levels, the <code>mer</code> model updated, and summaries returned. <em>MCMC p-value calculation is now implemented</em>. R will wait until all slave processes have finished running. See package <code>parallel</code> for more information about parallel computing. Note that tradional sequential computing can be achieved by specifying <code>mc.cores = 1</code>. Posthoc results can be viewed with function <code>summary.mcposthoc</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcposthoc.fnc(model, var, two.tailed = TRUE, 
mcmc = FALSE, nsim = 10000, ndigits = 4, mc.cores = 1, 
verbosity = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcposthoc.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>) or an <code>lm</code> object (fitted by function <code>lm</code>).</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_var">var</code></td>
<td>
<p>A named list of variable on which to perform the posthoc analysis. For example <code>list(ph1 = c("PronomOfTheme", "AnimacyOfRec", "DefinOfRec"), ph2 = c("SemanticClass"))</code>.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_two.tailed">two.tailed</code></td>
<td>
<p>Logical. Whether to perform one- or two-tailed <em>t</em>-tests. Defaults to <code>TRUE</code>, i.e., two-tailed.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_mcmc">mcmc</code></td>
<td>
<p>Logical. Whether to calculate <em>p</em>-values using function <code>pamer.fnc</code> (the default) or using function <code>pvals.fnc</code> from package <code>languageR</code>.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_nsim">nsim</code></td>
<td>
<p>An integer denoting the required number of Markov chain Monte Carlo samples. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_ndigits">ndigits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used in the <em>t</em> tables. Defaults to 4.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. how many processes will be spawned (at most).</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric. The amount of information printed to screen during the modeling process. The higher the number, the more information is printed. <code>0</code> turns this option off. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mcposthoc.fnc_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to &quot;mclapply&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>var = list(ph1 = c("PronomOfTheme", "AnimacyOfRec", "DefinOfRec"))</code>, for example, the function will re-level and update the model on each combination of the variable levels as follows:
</p>
<pre>
(1) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "nonpronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "animate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "definite")

(2) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "nonpronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "inanimate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "definite")

(3) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "nonpronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "animate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "indefinite")

(4) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "pronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "animate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "definite")

(5) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "nonpronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "inanimate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "indefinite")

(6) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "pronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "animate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "indefinite")

(7) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "pronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "inanimate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "indefinite")

(8) data$PronomOfTheme &lt;- relevel(data$PronomOfTheme = "pronominal")
    data$AnimacyOfTheme &lt;- relevel(data$AnimacyOfTheme = "inanimate")
    data$DefinOfTheme &lt;- relevel(data$DefinOfTheme = "definite")
</pre>
<p>On a cluster, instead of using <code>mcposthoc.fnc</code> it is better (faster and less complicated) to write a bash script that will create (1) <code>.R</code> files that will relevel the conditions and update the model, and (2) an associated <code>.sh</code> job submission script to submit the <code>.R</code> files. For example, let's consider two ERP analyses (regular past tense inflection and phrase structure) with three time windows each (300&ndash;400 ms, 550&ndash;700 ms, 750&ndash;850 in the regular past tense analysis, and 300&ndash;400 ms, 400&ndash;600 ms, and 750&ndash;850 ms in the phrase structure analysis). We investigated the effects of proficiency on ERP amplitudes. The initial models included a four-way interaction between Region of Interest (ROI) &ndash; with levels left anterior, left central, left posterior, midline anterior, midline central, midline posterior, right anterior, right central, and right posterior) &ndash; Group (with levels L1 and L2), Condition (wth levels control and violation), and Proficiency. After back-fitting the fixed effects, forward-fitting randomg effects, and reback-fitting the fixed effects as per <code>fitLMER.fnc</code>, the four-way interaction remained in every model. See Newman et al. (In preparation) for more details. The posthoc analysis script named <code>posthocs.sh</code> we used on the ACEnet cluster is as follows: 
</p>
<pre>
      time=(Reg300400 Reg550700 Reg750850 PS300400 PS400600 PS750850)
      condition=(Good Bad)
      group=(L1 L2)
      roi=(Lant Lcent Lpost Mant Mcent Mpost Rant Rcent Rpost)
      
      for t in ${time[*]}; do for i in ${condition[*]}; do for j in ${group[*]}; do for k in ${roi[*]}; do 
          ### create .R file where the modell is updated on the data where 
          ### re-leveld on each possible combination of variable levels
          export CONDITION=$i;
          export GROUP=$j;
          export ROI=$k; 
          echo 'condition&lt;-Sys.getenv("CONDITION")' &gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'group&lt;-Sys.getenv("GROUP")' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'roi&lt;-Sys.getenv("ROI")' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'load("models/m1'$t'.rda")' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'dat&lt;-m1@frame' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'dat$Condition&lt;-relevel(dat$Condition,'condition')' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'dat$Group&lt;-relevel(dat$Group,'group')' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'dat$ROI&lt;-relevel(dat$ROI,'roi')' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'm1&lt;-update(m1,.~.,data=dat)' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
          echo 'save(m1,file="ph'$t$CONDITION$GROUP$ROI'.rda")' &gt;&gt; "ph"$t$CONDITION$GROUP$ROI".R"
      
          ### create the job submission script for the .R file created above
          echo '#$ -S /bin/bash' &gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -cwd' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -j y' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -l h_rt=48:00:00' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -l h_vmem=8G' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -R y' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo '#$ -N "ph'$t$CONDITION$GROUP$ROI'"' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
          echo 'R -q -f ph'$t$CONDITION$GROUP$ROI'.R' &gt;&gt; "job.ph"$t$CONDITION$GROUP$ROI".sh"
      
          ### submit the job
          qsub  "job.ph"$t$CONDITION$GROUP$ROI".sh"
      done; done; done; done

</pre>
<p>and then type in the console
</p>
<pre>
      . posthocs.sh

</pre>
<p>On the ACEnet cluster, this results in 2 * 3 * 9 * 2 * 2 = 216 independent analyses, simultaneously using a total of 216 cores and 1728 GB of RAM. This posthoc analysis completes in about 3-6 hours.
</p>


<h3>Value</h3>

<p>An object of class &quot;mcposthoc&quot; with the following slots:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>The number of data points in data frame <code>data</code>.</p>
</td></tr>        
<tr><td><code>var</code></td>
<td>
<p>A named list containing the names of the variables used in the posthoc.</p>
</td></tr>
<tr><td><code>summaries</code></td>
<td>
<p>A named list containing the posthoc summaries for each factor re-leveling. If <code>mcmc = FALSE</code>, data frames with upper- and lower-bound (anti-conservative and conservative, respectively) <em>df</em>s, <em>p</em>-values, and deviance explained (%) for each model term. If <code>mcmc = TRUE</code>, data frames with the estimated coefficients, their MCMC mean, the HPD 95 and the probability based on the <em>t</em> distribution with the number of observations minus the number of fixed-effects coefficients as degrees of freedom.  This last <em>p</em>-value is anti-conservative, especially for small data sets.</p>
</td></tr>
</table>


<h3>warning</h3>

<p>Parallel computing capabilities will not be available on Windows because <code>mclapply</code> relies on forking. Sequential computing, however, will work on Windows if <code>mc.cores = 1</code> (the default).</p>


<h3>Note</h3>

<p>It is not possible anymore to get p-values with function <code>pvals.fnc</code> of package <code>languageR</code>. Please see <code>http://stackoverflow.com/questions/19199713/lme4-and-languager-compatibility-error-input-model-is-not-a-mer-object</code> for other possible avenues to get p-values.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.mcposthoc">summary.mcposthoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='pamer.fnc'>ANOVA with upper- and lower-bound <em>p</em>-values and R-sqaured values for LMER.</h2><span id='topic+pamer.fnc'></span>

<h3>Description</h3>

<p>Compute upper- and lower-bound <em>p</em>-values for the analysis of variance (or deviance) as well as the amount of deviance explained (%) for each fixed-effect of an LMER model. Note that for <code>glmer</code> models, there is no deviance explained column.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pamer.fnc(model, ndigits = 4)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pamer.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). Note that, at the moment, this function cannot be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>
</td></tr>
<tr><td><code id="pamer.fnc_+3A_ndigits">ndigits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used in the ANOVA table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upper-bound <em>p</em>-values are computed by using as denominator <em>df</em> <code>nrow(model@frame) - qr(model@X)4rank</code> (i.e., number of data points minus number of fixed effects including the intercept), which are anti-conservative. Lower-bound <em>p</em>-values are computed by using as denominator <em>df</em> <code>nrow(model@frame) - qr(model@X)4rank - number of random effects</code> (e.g., if by-subject intercepts and slopes, and there are 10 subjects, <code>10 * 2 = 20</code>). The amount of deviance explained by each model term (i.e., eta squared) is calculated as <code>[Sum of Squares for the effect] / [Sum of Squares total]</code>. More specifically: <code>as.data.frame(anova(model))[,2] / sum((model@frame[, dv]-mean(model@frame[, dv]))^2)</code> where <code>dv</code> is a vector of the names of the independent variables in the model.</p>


<h3>Value</h3>

<p>This function returns an object of class <code>data frame</code> with upper- and lower-bound (anti-conservative and conservative, respectively) <em>df</em>s, <em>p</em>-values, and deviance explained (%) for each model term. Note that for <code>glmer</code> models, there is no deviance explained column.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>References</h3>

<p><code>[R] lmer, p-values and all that</code> available at https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html.</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='perSubjectTrim.fnc'>Per-subject Trimming of Response Variable.</h2><span id='topic+perSubjectTrim.fnc'></span>

<h3>Description</h3>

<p>For each subject, removes data points that are, e.g., 2.5 standard deviations above or below the subject mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>perSubjectTrim.fnc(data, response, subject, trim = 2.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perSubjectTrim.fnc_+3A_data">data</code></td>
<td>
<p>The data frame containing the data to be trimmed.</p>
</td></tr>
<tr><td><code id="perSubjectTrim.fnc_+3A_response">response</code></td>
<td>
<p>The quoted name of the column containing the to-be-trimmed data.</p>
</td></tr>
<tr><td><code id="perSubjectTrim.fnc_+3A_subject">subject</code></td>
<td>
<p>The quoted name of the column contain subject identifiers.</p>
</td></tr>
<tr><td><code id="perSubjectTrim.fnc_+3A_trim">trim</code></td>
<td>
<p>Threshold at which data points will be removed. Defaults to 2.5 (standard deviations above and below each subject's mean).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the following objects:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The data with outliers removed.</p>
</td></tr>
<tr><td><code>data0</code></td>
<td>
<p>The original data prior to removing the outliers.</p>
</td></tr>
<tr><td><code>n.removed</code></td>
<td>
<p>The number of data points removed.</p>
</td></tr>
<tr><td><code>percent.removed</code></td>
<td>
<p>The percentage of removed data points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcp.fnc">mcp.fnc</a></code>
<code><a href="#topic+romr.fnc">romr.fnc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if("LCFdata" %in% .packages(all.available=TRUE)){
data(eegWide)
dat&lt;-eegWide
rm(eegWide)
gc(TRUE,TRUE)
# per subject trimming
dat &lt;- perSubjectTrim.fnc(dat, response = "Fz", 
      subject = "Subject", trim = 2.5)$data
# ......
# n.removed = 5130 
# percent.removed = 1.584507 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='plotDensity3d.fnc'>Kernel density estimation for two continuous variables.</h2><span id='topic+plotDensity3d.fnc'></span>

<h3>Description</h3>

<p>The densities of two continuous variables is first computed using the <code>density</code> function from package <code>stats</code>. The outer product of the two densities is computed, which can be plotted as a contour map or a perspective plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDensity3d.fnc(x, y, plot.type = "contour", color = "terrain", 
xlab = NULL, ylab = NULL, zlab = NULL, main = NULL, cex = 1, 
lit = TRUE, theta = 0, phi = 0, bw = "nrd0", adjust = 1, kernel = c("gaussian", 
"epanechnikov", "rectangular", "triangular", "biweight", "cosine", 
"optcosine"), weights = NULL, window = kernel, width, give.Rkern = FALSE, 
n = 50, from, to, cut = 3, na.rm = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDensity3d.fnc_+3A_x">x</code>, <code id="plotDensity3d.fnc_+3A_y">y</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot to make. Can be any of <code>"contour"</code> (default) or <code>"persp"</code>.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_color">color</code></td>
<td>
<p>The colour scheme to use for plots. One of &ldquo;<code>topo</code>&rdquo;, &ldquo;<code>heat</code>&rdquo;, &ldquo;<code>cm</code>&rdquo;, &ldquo;<code>terrain</code>&rdquo;, &ldquo;<code>gray</code>&rdquo; or &ldquo;<code>bw</code>&rdquo;.  Schemes &ldquo;<code>gray</code>&rdquo; and &ldquo;<code>bw</code>&rdquo; also modify the colors used.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_xlab">xlab</code>, <code id="plotDensity3d.fnc_+3A_ylab">ylab</code>, <code id="plotDensity3d.fnc_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the axes. N.B. These must be character strings; expressions are not accepted. Numbers will be coerced to character strings.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_main">main</code></td>
<td>
<p>The main title on top of the plot.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_cex">cex</code></td>
<td>
<p>The size of label and main text.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_lit">lit</code></td>
<td>
<p>Logical, specifying if lighting calculation should take place on geometry.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_theta">theta</code></td>
<td>
<p>Angle defining the viewing direction. <code>theta</code> gives the azimuthal direction. Used only if <code>plot.type = "persp"</code>.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_phi">phi</code></td>
<td>
<p>Angle defining the viewing direction. <code>phi</code> gives the colatitude. Used only if <code>plot.type = "persp"</code>.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_bw">bw</code>, <code id="plotDensity3d.fnc_+3A_adjust">adjust</code>, <code id="plotDensity3d.fnc_+3A_kernel">kernel</code>, <code id="plotDensity3d.fnc_+3A_weights">weights</code>, <code id="plotDensity3d.fnc_+3A_window">window</code>, <code id="plotDensity3d.fnc_+3A_width">width</code>, <code id="plotDensity3d.fnc_+3A_give.rkern">give.Rkern</code>, <code id="plotDensity3d.fnc_+3A_n">n</code>, <code id="plotDensity3d.fnc_+3A_from">from</code>, <code id="plotDensity3d.fnc_+3A_to">to</code>, <code id="plotDensity3d.fnc_+3A_cut">cut</code>, <code id="plotDensity3d.fnc_+3A_na.rm">na.rm</code></td>
<td>
<p>See help page to function <code>density</code>.</p>
</td></tr>
<tr><td><code id="plotDensity3d.fnc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions <code>image</code>, <code>contour</code> or <code>persp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See help page to the <code>density</code> function.</p>


<h3>Value</h3>

<p>Either a contour map or a perspective plot. Invisibly returns
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric vector supplied in argument <code>x</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The numeric vector supplied in argument <code>y</code>.</p>
</td></tr>
<tr><td><code>xd</code></td>
<td>
<p>The density object tied to vector <code>x</code>.</p>
</td></tr>
<tr><td><code>yd</code></td>
<td>
<p>The density object tied to vector <code>y</code>.</p>
</td></tr>
<tr><td><code>mat</code></td>
<td>
<p>The outer product of the <code>x</code> and <code>y</code> densities in matrix format.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>The color used for plotting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>;
<code><a href="graphics.html#topic+persp">persp</a></code>;
<code><a href="stats.html#topic+density">density</a></code>;
<code><a href="base.html#topic+outer">outer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='plotLMER.fnc'>plot a mer object</h2><span id='topic+plotLMER.fnc'></span>

<h3>Description</h3>

<p>Plot partial effects of a (generalized) linear mixed-effects model fit with
<code>lmer</code> (compatible with package <code>lme4</code> version &gt; 1.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLMER.fnc(model, xlabel = NA, xlabs = NA, ylabel = NA, 
ylimit = NA, ilabel = NA, fun = NA, pred = NA, control = NA, 
ranefs = NA, n = 100, intr = NA,lockYlim = TRUE, addlines = FALSE, 
withList = FALSE, cexsize = 0.5, linecolor = 1, 
addToExistingPlot = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLMER.fnc_+3A_model">model</code></td>
<td>
<p> a <code>mer</code> model object </p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_xlabel">xlabel</code></td>
<td>
<p> label for X-axis (if other than the variable name in the
original model formula)</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_xlabs">xlabs</code></td>
<td>
<p> character vector with labels for X-axes in multipanel plot (if 
other than the variable names in the original model formula); if used, 
<code>xlabel</code> should not be specified</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_ylabel">ylabel</code></td>
<td>
<p> label for Y-axis (if other than the variable name of 
the dependent variable in the original model formula) </p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_ylimit">ylimit</code></td>
<td>
<p> range for vertical axis; if not specified, this range will 
be chosen such that all data points across all subplots, including HPD intervals, will be accommodated </p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_ilabel">ilabel</code></td>
<td>
<p> label for the interaction shown in the lower right-hand margin of the plot, overriding the original variable name in the model formula</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_fun">fun</code></td>
<td>
<p> a function to be applied for transforming the dependent variable, 
if <code>NA</code>, no transformation is applied; for models with <code>family = "binomial"</code>, 
fun is set to <code>plogis</code> by default; this can be disabled by setting
<code>fun=function(x)return(x)</code>.</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_pred">pred</code></td>
<td>
<p> character string with name of predictor; 
if specified, a single plot will produced for the partial effect of this
specific predictor</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_control">control</code></td>
<td>
<p> a two-element list <code>list(predictor, val)</code> specifying a <code>predictor</code> the value of which has to be set to <code>val</code> in the partial effect plot(s); the predictor name should be exactly as specified in <code>names(model@fixef)</code>.  It is up to the user to make sure that name and value make sense, the code here hands full 'control' to the user.</p>
</td></tr> 
<tr><td><code id="plotLMER.fnc_+3A_ranefs">ranefs</code></td>
<td>
<p>a four-element list <code>Group, Level, Predictor</code>, specifying a random-effect Group (e.g. <code>Subject</code>), a level (e.g., <code>S10</code>) and a value (e.g., <code>LogFrequency</code>) for which partial effects have to be calibrated.</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_n">n</code></td>
<td>
<p> integer denoting number of points for the plot, chosen at equally
spaced intervals across the empirical range of the predictor variable </p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_intr">intr</code></td>
<td>
<p> a list specifying an interaction to be graphed; obligatory
arguments are (1) the name of the interaction variable, followed by (2) 
a vector of values for that variable, followed by (3) the position for 
interaction labels ('&quot;beg&quot;', '&quot;mid&quot;', or '&quot;end&quot;', or 'NA' if no labels are 
desired), optionally followed by (4) a list with as first element
a vector of colors and as second element a vector of line types. The number
of elements in both vectors should match the number of values specified 
under (2) for the interaction predictor.</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_lockylim">lockYlim</code></td>
<td>
<p> logical specifying whether all subplots should have the same
range of values for the vertical axis; if <code>TRUE</code>, this range will be
chosen to accomodate all fitted values including HDP intervals for all
predictors across all plots</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_addlines">addlines</code></td>
<td>
<p> if TRUE, adds line(s) between levels of same factor(s)</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_withlist">withList</code></td>
<td>
<p> logical, if <code>TRUE</code>, a list will be output with all data 
frames for the subplots</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_cexsize">cexsize</code></td>
<td>
<p> character expansion size (cex) for additional information in
the plot for interactions</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_linecolor">linecolor</code></td>
<td>
<p> color of lines in the plot, by default set to 1 (black) </p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_addtoexistingplot">addToExistingPlot</code></td>
<td>
<p> default FALSE, if set to TRUE, plot will be added to previous plot, but only if pred is specified</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_verbose">verbose</code></td>
<td>
<p> if TRUE (default), effect sizes and default transformations are reported</p>
</td></tr>
<tr><td><code id="plotLMER.fnc_+3A_...">...</code></td>
<td>
<p> further graphical parameters to be passed down; warning: <code>col</code>, 
<code>pch</code>, <code>lty</code> and <code>cex</code> will often generate an error as they are 
internally already fully specified for specialized subplots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no predictor is specified, a series of plots is produced for the partial
effects of each predictor.  The graphs are shown for the reference level for
factors and are adjusted for the median value for the other numerical
predicors in the model.  Interactions are not shown.  The user should set up the
appropriate number of subplots on the graphics device before running plotLMER.fnc().
</p>
<p>Instead of showing all predictors jointly, plotLMER.fnc() can also be used to
plot the partial effect of a specific predictor.  When a specific predictor
is specified (with <code>pred = ...</code>), a single plot is produced for that
predictor.  In this case, the <code>intr</code> argument can be used to specify a
single second predictor that enters into an interaction with the selected
main predictor.  
</p>
<p>Polynomials have to be fitted with <code>poly(..., degree, raw=TRUE)</code> and
restricted cubic splines with <code>rcs()</code> from the <code>rms</code> package.
</p>
<p>Note that any MCMC capabilities available in the <code>languageR</code> version of this function are not available in this version. 
</p>


<h3>Value</h3>

<p>A plot is produced on the graphical device.
</p>


<h3>Note</h3>

<p> This code needs much more work, including (i) extension to <code>poly</code> with <code>raw=FALSE</code>, and (ii) general clean-up of the code.</p>


<h3>Author(s)</h3>

<p>R. H. Baayen, tweaked by Antoine Tremblay</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLMER3d.fnc">plotLMER3d.fnc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='plotLMER3d.fnc'>Dynamic 3d plot for <code>mer</code> object.</h2><span id='topic+plotLMER3d.fnc'></span>

<h3>Description</h3>

<p>Plot dynamic 3d partial effects of a (generalized) linear mixed-effects model fit with <code>LMER</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLMER3d.fnc(model = NULL, pred, intr, plot.type = "contour",
xlim = range(x, na.rm = TRUE), ylim = range(y, na.rm = TRUE), 
zlim = range(z, na.rm = TRUE), xlab = NULL, 
ylab = NULL, zlab = NULL, main = NULL, shift = 0, scale = 1, cex = 1, 
fun = NA, n = 30, color = "topo", theta = 0, phi = 0,
contourstepsize = 0.2, legend.args = NULL, rug = FALSE, 
plot.dat = "default", path = "default", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLMER3d.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object or <code>NULL</code> (the default) to plot from an existing data-plotting object returned by this function and saved as an <code>.rda</code> file.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_pred">pred</code></td>
<td>
<p>The quoted name of a model predictor.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_intr">intr</code></td>
<td>
<p>The quoted name of a continuous model predicor.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot to make. Can be any of <code>"contour"</code> (default), or <code>"image.plot"</code> if package <code>fields</code> is available, <code>"persp"</code></p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_xlim">xlim</code>, <code id="plotLMER3d.fnc_+3A_ylim">ylim</code>, <code id="plotLMER3d.fnc_+3A_zlim">zlim</code></td>
<td>
<p><em>x-</em>, <em>y-</em> and <em>z-</em>limits. The plot is produced so that the rectangular volume defined by these limits is visible.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_xlab">xlab</code>, <code id="plotLMER3d.fnc_+3A_ylab">ylab</code>, <code id="plotLMER3d.fnc_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the axes. N.B. These must be character strings; expressions are not accepted. Numbers will be coerced to character strings.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_main">main</code></td>
<td>
<p>The main title on top of the plot.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_shift">shift</code></td>
<td>
<p>Constant to add to the smooth (on the scale of the linear predictor) before plotting. Defaults to 0. Passed to <code>plotRaw3d.fnc</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_scale">scale</code></td>
<td>
<p>Constant by which to multiply the smooth before plotting. Defaults to 1. Passed to <code>plotRaw3d.fnc</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_cex">cex</code></td>
<td>
<p>The size of label and main text.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_fun">fun</code></td>
<td>
<p>A function to be applied for transforming the dependent variable, if <code>NA</code>, no transformation is applied; for models with <code>family = "binomial"</code>, fun is set to <code>plogis</code> by default; this can be disabled by setting <code>fun=function(x)return(x)</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_n">n</code></td>
<td>
<p>Integer denoting number of points for the plot, chosen at equally spaced intervals across the empirical range of the predictor variable.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_color">color</code></td>
<td>
<p>The colour scheme to use for plots. One of <code>topo</code>, <code>heat</code>, <code>cm</code>, <code>terrain</code>, <code>gray</code> or <code>bw</code>.  Schemes <code>gray</code>, <code>grey</code>, and <code>bw</code> also modify the colors used.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_theta">theta</code></td>
<td>
<p>Angle defining the viewing direction. <code>theta</code> gives the azimuthal direction. Used only if <code>plot.type = "persp"</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_phi">phi</code></td>
<td>
<p>Angle defining the viewing direction. <code>phi</code> gives the colatitude. Used only if <code>plot.type = "persp"</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_contourstepsize">contourstepsize</code></td>
<td>
<p>The size of the steps from contour line to contour line.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_legend.args">legend.args</code></td>
<td>
<p>When <code>plot.type = "image.plot"</code>, arguments for a complete specification of the legend label. This is in the form of list and is just passed to the mtext function. (See example in <code>image.plot</code> help page). Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_rug">rug</code></td>
<td>
<p>Whether a rug ought to be plotted on the 3d surface. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_plot.dat">plot.dat</code>, <code id="plotLMER3d.fnc_+3A_path">path</code></td>
<td>
<p>Whether to cache the plotting data generated by a previous call to <code>plotLMER3d.fnc</code>. Generating the 3d plots can be time consuming. If the <code>plot.dat</code> argument is non-FALSE, the plotting information generated in the first call to the function will be saved so that in a second call to the function with exactly the same argument values, the plotting information will be retrieved and plotting will be significantly quicker. If <code>plotting.data = "default"</code> and <code>path = "default"</code>, the plotting information will be saved in a temporary directory and the name of the file containing the information will equal to <code>paste("lmer___",model@call,pred,intr,".rda",sep="")</code>. The name of the file and the path where it will be saved can be set by the user in the <code>plot.dat</code> and <code>path</code> arguments. For example, <code>plot.dat = "my_plotting.data", path = "Documents"</code>. Note that <code>"lmer___"</code> will be appended to the begining of whatever is specified in <code>plot.dat</code> and <code>".rda"</code> to the end. Also note that if the user wants to save the plotting information returned by this function, the name of this object has to be <code>z</code>.</p>
</td></tr>
<tr><td><code id="plotLMER3d.fnc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>image</code>, <code>contour</code>, <code>image.plot</code>, <code>persp</code>, or <code>persp3d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See help page to Harald Baayen's <code>plotLMER.fnc</code> function as well as to Duncan Murdoch's <code>persp3d</code> function and the help page to function <code>image.plot</code> from package <code>fields</code>. To save screenshots of &quot;persp3d&quot; plots (after plotting), use function <code>rgl.snapshot</code> (produces <code>png</code> files) or function <code>rgl.postscript</code> (produces <code>eps</code> files).</p>


<h3>Value</h3>

<p>Invisibly returns plotting information (<code>x</code> and <code>y</code> vectors, <code>z</code> matrix, and colors, <code>col</code>). If <code>plot.type = "contour"</code>, <code>plot.type = "image.plot"</code>, or <code>plot.type = "persp"</code>, a contour or perspective plot, respectively. If <code>ret = TRUE</code>, a two-element list is returned containing the <em>matrix</em> and the matrix of corresponding colors is returned. If argument <code>intel</code> in non-null, a file containing plotting information will be saved.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+persp">persp</a></code>;
<code><a href="graphics.html#topic+contour">contour</a></code>;
<code><a href="#topic+plotLMER.fnc">plotLMER.fnc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(try(require(LCFdata,quietly=TRUE))){
	data(z)
	temp.dir &lt;- tempdir()
	save(z,file=file.path(temp.dir,"lmer___z.rda"))

  plotLMER3d.fnc(pred = "LengthBc", intr = "WMCc", 
    plot.dat = "z", path = temp.dir)
  plotLMER3d.fnc(pred = "LengthBc", intr = "WMCc",
    plot.type = "persp", phi = 25, plot.dat = "z", 
    path = temp.dir)
}
</code></pre>

<hr>
<h2 id='plotRaw3d.fnc'>Visualize raw surface averages (3d)</h2><span id='topic+plotRaw3d.fnc'></span>

<h3>Description</h3>

<p>For a specified response variable and interacting continuous predictors, visualize in 3d the surface average.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRaw3d.fnc(data = NULL, response = NULL, pred = NULL, intr = NULL, 
xy = TRUE, color = "topo", zlim = NULL, xlab = NULL, ylab = NULL, 
zlab = NULL, main = NULL, shift = 0, scale = 1, plot.type = "contour", 
theta = 30, phi = 30, ticktype = "detailed", 
contourstepsize = 1, legend.args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRaw3d.fnc_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_response">response</code></td>
<td>
<p>The quoted name of a continuous response variable.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_pred">pred</code></td>
<td>
<p>The quoted name of a continuous predictor.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_intr">intr</code></td>
<td>
<p>The quoted name of an interacting continuous predictor.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_xy">xy</code></td>
<td>
<p>Whether to the <code>x</code> and <code>y</code> values from the data or to set them to <code>seq(0, 1, len = nrow(z))</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_color">color</code></td>
<td>
<p>The colour scheme to use. One of <code>"topo"</code>, <code>"heat"</code>, <code>"cm"</code>, <code>"terrain"</code>, <code>"gray"</code> or <code>"bw"</code>.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_zlim">zlim</code></td>
<td>
<p>A two element vector specifying the plotting limits for the <em>z</em>-axis.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_xlab">xlab</code>, <code id="plotRaw3d.fnc_+3A_ylab">ylab</code>, <code id="plotRaw3d.fnc_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the axes. N.B. These must be character strings; expressions are not accepted. Numbers will be coerced to character strings.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_main">main</code></td>
<td>
<p>The main title on top of the plot.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_shift">shift</code></td>
<td>
<p>Constant to add to the smooth (on the scale of the linear predictor) before plotting. Defaults to 0.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_scale">scale</code></td>
<td>
<p>Constant by which to multiply the smooth before plotting. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot to make. Can be any of <code>"contour"</code> or <code>"persp"</code>.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_theta">theta</code></td>
<td>
<p>Angle defining the viewing direction. <code>theta</code> gives the azimuthal direction.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_phi">phi</code></td>
<td>
<p>Angle defining the viewing direction. <code>phi</code> gives the colatitude.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_ticktype">ticktype</code></td>
<td>
<p>Character: <code>"simple"</code> draws just an arrow parallel to the axis to indicate direction of increase; <code>"detailed"</code> draws normal ticks as per 2D plots.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_contourstepsize">contourstepsize</code></td>
<td>
<p>The size of the steps from contour line to contour line. Defaults to 1. Used only if <code>plot.type = "contour"</code>.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_legend.args">legend.args</code></td>
<td>
<p>When <code>plot.type = "image.plot"</code>, arguments for a complete specification of the legend label. This is in the form of list and is just passed to the mtext function. (See example in <code>image.plot</code> help page). Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotRaw3d.fnc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions <code>image</code>, <code>image.plot</code>, <code>contour</code> or <code>persp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code>s will be set to <code>0</code>.</p>


<h3>Value</h3>

<p>Either a dynamic 3d perspective plot, a perspective plot, or a contour plot. Also invisibly returns the plotting matrix and the color vector.</p>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='relLik'>Relative log-likehood.</h2><span id='topic+relLik'></span>

<h3>Description</h3>

<p>Calculate the relative log-likehood between two models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relLik(x, y, method = c("AIC", "BIC"), ndigits = 6, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relLik_+3A_x">x</code>, <code id="relLik_+3A_y">y</code></td>
<td>
<p>Fitted model objects for which there exists a <code>logLik</code> method to extract the corresponding log-likelihood, or objects inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="relLik_+3A_method">method</code></td>
<td>
<p>Whether to base the comparison on <code>AIC</code> or <code>BIC</code>. Defaults to &quot;AIC&quot;.</p>
</td></tr>
<tr><td><code id="relLik_+3A_ndigits">ndigits</code></td>
<td>
<p>An integer denoting the number of decimal digits in the output.</p>
</td></tr>
<tr><td><code id="relLik_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code>AIC</code> or <code>BIC</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative log-likelihood is calculated as <code>exp((abs(AIC(x) - AIC(y)))/2)</code> or <code>exp((abs(BIC(x) - BIC(y)))/2)</code>, depending on the method.
</p>
<p>You can find information regarding differences between AIC and BIC from <code>http://methodology.psu.edu/eresources/ask/sp07</code>.</p>


<h3>Value</h3>

<p>A vector with values:
</p>
<table>
<tr><td><code>AIC(x)</code>, <code>BIC(x)</code></td>
<td>
<p>The <code>AIC</code> or ]codeBIC value of the first model object.</p>
</td></tr>
<tr><td><code>AIC(y)</code>, <code>BIC(y)</code></td>
<td>
<p>The <code>AIC</code> or ]codeBIC value of the second model object.</p>
</td></tr>
<tr><td><code>relLik</code></td>
<td>
<p>The relative likelihood between the two models. Model <code>y</code> will be that much more likely given the data than model <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>References</h3>

<p>On AIC and relative log-likelihood (which they call evidence ratio):
</p>
<p>Symonds, M.R.E and Moussalli, A. (2011). <em>A brief guide to model selection, multimodel inference and model averaging in behavioural ecology using Akaike's information criterion.</em> <em>Behavioral Ecology and Sociobiology</em>, 65, 13&ndash;21. doi: 10.1007/s00265-010-1037-6
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a>; </code>
<code><a href="stats.html#topic+AIC">AIC</a>; </code>
<code><a href="stats.html#topic+BIC">BIC</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='romr.fnc'>Exclude outliers.</h2><span id='topic+romr.fnc'></span>

<h3>Description</h3>

<p>Exclude outliers with a standardized residual at a distance greater than 2.5 standard deviations from 0. Note that this function cannot be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>romr.fnc(model, data, trim = 2.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="romr.fnc_+3A_model">model</code></td>
<td>
<p>A <code>mer</code> object (fitted by function <code>lmer</code>). Note that this function cannot be used with generalized linear mixed-effects models (<code>glmer</code>s).</p>
</td></tr>
<tr><td><code id="romr.fnc_+3A_data">data</code></td>
<td>
<p>The data frame on which the <code>mer</code> object was fitted.</p>
</td></tr>
<tr><td><code id="romr.fnc_+3A_trim">trim</code></td>
<td>
<p>Threshold at which residuals will be removed. Defaults to 2.5 (standard deviations above and below the residuals mean).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the following objects:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The data with outliers removed.</p>
</td></tr>
<tr><td><code>data0</code></td>
<td>
<p>The original data prior to removing the outliers.</p>
</td></tr>
<tr><td><code>n.removed</code></td>
<td>
<p>The number of data points removed.</p>
</td></tr>
<tr><td><code>percent.removed</code></td>
<td>
<p>The percentage of removed data points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a>, with contrbutions from Andy Flies, Michigan State University.</p>


<h3>References</h3>

<p>Baayen, R.H. (2008). <em>Analyzing Linguistic Data. A Practical Introduction to Statistics Using R</em>. Cambridge, UK: Cambridge University Press. 
</p>
<p>Newman, A.J., Tremblay, A., Nichols, E.S., Neville, H.J., and Ullman, M.T. (submitted). The Influence of Language Proficiency on Lexical-Semantic Processing in Native and Late Learners of English: ERP evidence. Submitted to the <em>Journal of Cognitive Neuroscience</em>.
</p>
<p>Tremblay, A. and Tucker B. V. (submitted). What can the production of four-word sequences tell us about the mental lexicon? Submitted to <em>The Mental Lexicon</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcp.fnc">mcp.fnc</a></code>
<code><a href="#topic+perSubjectTrim.fnc">perSubjectTrim.fnc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in LMERConvenienceFunctions help page.
</code></pre>

<hr>
<h2 id='summary.mcposthoc'>Summarize a &quot;mcposthoc&quot; object.</h2><span id='topic+summary.mcposthoc'></span>

<h3>Description</h3>

<p>This function extracts the desired portions of an &quot;mcposthoc&quot; object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcposthoc'
summary(object, ph.list = NULL, 
term = NULL, print = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcposthoc_+3A_object">object</code></td>
<td>
<p>An &quot;mcposthoc&quot; object as returned by function <code>mcposthoc.fnc</code>.</p>
</td></tr>
<tr><td><code id="summary.mcposthoc_+3A_ph.list">ph.list</code></td>
<td>
<p>The name of the posthoc analysis for which results are desired. For example, if, in function <code>mcposthoc.fnc</code>, argument <code>var</code> was set to <code>list(ph1 = c("PronomOfTheme", "AnimacyOfRec", "DefinOfRec"), ph2 = c("SemanticClass"))</code>, <code>ph.list</code> should be one of &quot;ph1&quot; or &quot;ph2&quot;. Defaults to <code>NULL</code>. If <code>ph.list = NULL</code> and more than one posthoc analysis was performed, the user will be prompted to select one of the analyses.</p>
</td></tr>
<tr><td><code id="summary.mcposthoc_+3A_term">term</code></td>
<td>
<p>The model term for which posthoc results are desired. Defaults to <code>NULL</code>, in which case the user will be prompted to select a term.</p>
</td></tr>
<tr><td><code id="summary.mcposthoc_+3A_print">print</code></td>
<td>
<p>Whether to print to screen the posthoc summary. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.mcposthoc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a summary data frame from statistics obtained from an &quot;mcposthoc&quot; object for the specified term. It goes through each element of the <code>ph.list</code> &ndash; each list element is the summary of the model re-leveled on one factor level (or combination of factor levels) &ndash; extracts the row corresponding to the <code>term</code>, and binds it to the other extracted rows.</p>


<h3>Value</h3>

<table>
<tr><td><code>ph.list</code></td>
<td>
<p>The posthoc list in the &quot;mcposthoc&quot; object from which the summary originates.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The term from the posthoc list for which a summary is desired.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>The posthoc summary.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Tremblay, Statistics Canada, <a href="mailto:trea26@gmail.com">trea26@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mcposthoc.fnc">mcposthoc.fnc</a>; </code>
<code><a href="#topic+pamer.fnc">pamer.fnc</a>. </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### See examples from mcposthoc.fnc() help page.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
