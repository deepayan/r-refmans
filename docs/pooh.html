<!DOCTYPE html><html lang="en"><head><title>Help for package pooh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pooh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsort'><p>Topological Sort</p></a></li>
<li><a href='#weak'><p>Equivalence Classes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-03-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Orders and Relations</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Finds equivalence classes corresponding to a symmetric relation
    or undirected graph.  Finds total order consistent with partial order
    or directed graph (so-called topological sort).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.umn.edu/geyer/pooh/">http://www.stat.umn.edu/geyer/pooh/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-26 23:05:48 UTC; geyer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-27 00:00:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsort'>Topological Sort</h2><span id='topic+tsort'></span>

<h3>Description</h3>

<p>Find One Total Order Consistent with Partial Order or With Directed
Acyclic Graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsort(from, to, domain, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsort_+3A_from">from</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
<tr><td><code id="tsort_+3A_to">to</code></td>
<td>
<p>an atomic vector of the same mode and length as <code>from</code></p>
</td></tr>
<tr><td><code id="tsort_+3A_domain">domain</code></td>
<td>
<p>an atomic vector of the same mode as <code>from</code> containing
all the elements of <code>from</code> and <code>to</code>.  If missing,
<code>union(from, to)</code> is used.  The domain of the relation or the
nodes of the graph.</p>
</td></tr>
<tr><td><code id="tsort_+3A_strict">strict</code></td>
<td>
<p>logical.  If <code>TRUE</code> then <code>from[i] == to[i]</code> is
an error.  Otherwise, such edges of the graph are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairs <code>(from[i], to[i])</code> can be though of either as elements of
a relation on a set or as edges in a directed graph.
This function finds one total order on the domain (nodes of the graph)
that is consistent with the relation (graph) if one exists (that is if the
graph is directed).
</p>


<h3>Value</h3>

<p>A vector that is a reordering of <code>domain</code> so that every element of
<code>from</code> appears in the value before the corresponding element of <code>to</code>.
</p>
<p>Throws an error if there is no consistent total order (the graph has a cycle).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from &lt;-   LETTERS[c(1, 1, 1, 1, 2, 2, 6)]
to &lt;- LETTERS[c(2, 3, 4, 5, 3, 5, 7)]
from
to
tsort(from, to)
</code></pre>

<hr>
<h2 id='weak'>Equivalence Classes</h2><span id='topic+weak'></span>

<h3>Description</h3>

<p>Calculates Equivalence Classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weak(from, to, domain, markers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weak_+3A_from">from</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
<tr><td><code id="weak_+3A_to">to</code></td>
<td>
<p>an atomic vector of the same mode and length as <code>from</code></p>
</td></tr>
<tr><td><code id="weak_+3A_domain">domain</code></td>
<td>
<p>an atomic vector of the same mode as <code>from</code> containing
all the elements of <code>from</code> and <code>to</code>.  If missing,
<code>union(from, to)</code> is used.  The domain of the relation or the
nodes of the graph.</p>
</td></tr>
<tr><td><code id="weak_+3A_markers">markers</code></td>
<td>
<p>controls the type of result; see Values below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairs <code>(from[i], to[i])</code> can be though of either as elements of
a symmetric relation on a set or as edges in an undirected graph.
This function calculates the equivalence classes of the transitive
closure of the relation or the components of the graph.  If the edges
are thought of as directed, then we calculate the weak components,
meaning the components of the associated undirected graph, rather than
the so-called strong components of the directed graph.
</p>


<h3>Value</h3>

<p>If <code>markers = FALSE</code>,
a list, elements of which are the components (equivalence classes).
If <code>markers = TRUE</code>, an integer vector of the same length as
<code>domain</code> or as <code>union(from, to)</code> if <code>domain</code> is missing,
elements of which are the same if and only if the corresponding elements
of the domain (nodes of the graph) are in the same connected component
(equivalence class).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to &lt;- sample(1:100, 75, replace = TRUE)
from &lt;- sample(1:100, 75, replace = TRUE)
out &lt;- weak(from, to)
sapply(out, length)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
