<!DOCTYPE html><html lang="en"><head><title>Help for package NCmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NCmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NCmisc-package'>
<p>Miscellaneous Functions for Creating Adaptive Functions and Scripts</p></a></li>
<li><a href='#check.linux.install'><p>Check whether a given system command is installed (e.g, bash)</p></a></li>
<li><a href='#comify'><p>Function to add commas for large numbers</p></a></li>
<li><a href='#comma.list'><p>Print out comma separated list of values in X, truncating if many (good for error messages)</p></a></li>
<li><a href='#cor.with'><p>Simulate a correlated variable</p></a></li>
<li><a href='#Dim'><p>A more general dimension function</p></a></li>
<li><a href='#dup.pairs'><p>Obtain an index of all instances of values with duplicates (ordered)</p></a></li>
<li><a href='#estimate.memory'><p>Estimate the memory required for an object.</p></a></li>
<li><a href='#exists.not.function'><p>Does object exist ignoring functions</p>
</p>
<p>The exists() function can tell you whether an object exists</p>
at all, or whether an object exists with a certain type, but
it can be useful to know whether an object exists as genuine
data (and not a function) which can be important when a variable
or object is accidently or intentionally given the same name as
a function. This function usually returns a logical value as to
the existence of the object (ignoring functions) but can also
be set to return the non-function type if the object exists.</a></li>
<li><a href='#extend.pc'><p>Extend an interval by percentage</p></a></li>
<li><a href='#fakeLines'><p>Create fake text for testing purposes</p></a></li>
<li><a href='#file.split'><p>Split a text file into multiple parts</p></a></li>
<li><a href='#force.percentage'><p>Force argument to be a percentage with length one</p></a></li>
<li><a href='#force.scalar'><p>Force argument to be a numeric type with length one</p></a></li>
<li><a href='#get.distinct.cols'><p>Return up to 22 distinct colours.</p></a></li>
<li><a href='#getRepositories'><p>Detect all available R repositories.</p></a></li>
<li><a href='#has.method'><p>Determine whether a function can be applied to an S4 class/object</p></a></li>
<li><a href='#Header'><p>Print heading text with a border.</p></a></li>
<li><a href='#headl'><p>A good way to preview large lists.</p></a></li>
<li><a href='#is.vec.logical'><p>Determine robustly whether a vector contains logical data</p></a></li>
<li><a href='#is.vec.numeric'><p>Determine robustly whether a vector contains numeric data</p></a></li>
<li><a href='#list.functions.in.file'><p>Show all functions used in an R script file, by package</p></a></li>
<li><a href='#list.to.env'><p>Create variables from a list</p></a></li>
<li><a href='#loess.scatter'><p>Draw a scatterplot with a fit line</p></a></li>
<li><a href='#loop.tracker'><p>Creates a progess bar within a loop</p></a></li>
<li><a href='#memory.summary'><p>Summary of RAM footprint for all R objects in the current session.</p>
Not my function, but taken from an R-Help response by Elizabeth Purdom,
at Berkeley. Simply applies the function 'object.size' to the objects
in ls(). Also very similar to an example in the 'Help' for the
utils::object.size() function.</a></li>
<li><a href='#Mode'><p>Find the mode of a vector.</p></a></li>
<li><a href='#must.use.package'><p>Do everything possible to load an R package.</p></a></li>
<li><a href='#narm'><p>Return an object with missing values removed.</p></a></li>
<li><a href='#NCmisc-internal'><p>Internal NCmisc Functions</p></a></li>
<li><a href='#nearest.to'><p>Select the nearest point in an array to a given value</p></a></li>
<li><a href='#Numerify'><p>Convert all possible columns of a data.frame to numeric</p></a></li>
<li><a href='#out.of'><p>Easily display fraction and percentages</p></a></li>
<li><a href='#p.to.Z'><p>Convert p-values to Z-scores</p></a></li>
<li><a href='#packages.loaded'><p>Check whether a set of packages has been loaded</p></a></li>
<li><a href='#pad.left'><p>Print a vector with appropriate padding so each has equal char length.</p></a></li>
<li><a href='#pctile'><p>Find data thresholds corresponding to percentiles</p></a></li>
<li><a href='#ppa'><p>Posterior probability of association function</p></a></li>
<li><a href='#preview'><p>Output variable states within functions during testing/debugging</p></a></li>
<li><a href='#prv'><p>Output variable states within functions/loops during testing/debugging</p></a></li>
<li><a href='#prv.large'><p>Tidy display function for matrix objects</p></a></li>
<li><a href='#replace.missing.df'><p>Iterate through numeric columns of a dataframe and replace missing with the mean</p></a></li>
<li><a href='#Rfile.index'><p>Create an index file for an R function file</p></a></li>
<li><a href='#rmv.names'><p>Remove names from a named vector or list</p></a></li>
<li><a href='#rmv.spc'><p>Remove leading and trailing spaces (or other character).</p></a></li>
<li><a href='#search.cran'><p>Search all CRAN packages for those containing keyword(s).</p></a></li>
<li><a href='#sim.cor'><p>Simulate a dataset with correlated measures</p></a></li>
<li><a href='#simple.date'><p>Simple representation and retrieval of Date/Time</p></a></li>
<li><a href='#spc'><p>Print a character a specified number of times.</p></a></li>
<li><a href='#standardize'><p>Convert a numeric vector to Z-scores.</p></a></li>
<li><a href='#Substitute'><p>Convert objects as arguments to object names</p></a></li>
<li><a href='#summarise.r.datasets'><p>Summarise the dimensions and type of available R example datasets</p></a></li>
<li><a href='#summary2'><p>Descriptive summary with SD/SE + improved formatting</p></a></li>
<li><a href='#table2d'><p>Wrapper for the base table() function that includes</p>
zero counts - useful to get consistent dimensions across
multiple runs with different responding patterns
Forces a 2d table with every possible cell (allow zero counts)
Only for tables where there are two vectors entered, while
the base function allows for more, or also allows just 1.
If the wrong arguments are entered, attempts to pass the input
to the base version of 'table' instead.</a></li>
<li><a href='#textogram'><p>Make an ascii histogram in the console.</p></a></li>
<li><a href='#timeit'><p>Times an expression, with breakdown of time spent in each function</p>
!DEPRECATED October 14, 2022!</a></li>
<li><a href='#toheader'><p>Return a string with each first letter of each word in upper case.</p></a></li>
<li><a href='#top'><p>Monitor CPU, RAM and Processes</p></a></li>
<li><a href='#Unlist'><p>Unlist a list, starting only from a set depth.</p></a></li>
<li><a href='#wait'><p>Wait for a period of time.</p></a></li>
<li><a href='#which.outlier'><p>Return vector indexes of statistical univariate outliers</p></a></li>
<li><a href='#Z.to.p'><p>Convert Z-scores to p-values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for Creating Adaptive Functions and
Scripts</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Cooper</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Cooper &lt;njcooper@gmx.co.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.10), grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of handy functions. Includes a versatile one line progress bar, one 
 line function timer with detailed output, time delay function, text histogram, object 
 preview, CRAN package search, simpler package installer, Linux command install check, 
 a flexible Mode function, top function, simulation of correlated data, and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-17 08:12:29 UTC; ncooper</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-17 09:15:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='NCmisc-package'>
Miscellaneous Functions for Creating Adaptive Functions and Scripts
</h2><span id='topic+NCmisc-package'></span><span id='topic+NCmisc'></span>

<h3>Description</h3>

<p>A set of handy functions. Includes a versatile one line progress bar, one 
line function timer with detailed output, time delay function, text histogram, object 
preview, CRAN package search, simpler package installer, Linux command install check, 
a flexible Mode function, top function, simulation of correlated data, and more.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> NCmisc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-10-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>A package of general purpose functions that might save time or help tidy up code. 
Some of these functions are similar to existing functions but are simpler to use
or have  more features (e.g, timeit and loop.tracker reduce an initialisation, 
'during' and close three-line call structure, to a single function call.
Also, some of these functions are useful for building packages and pipelines,
for instance: Header(), to provide strong visual deliniation between 
procedures in console output, by an ascii bordered heading; loop.tracker()
to track the progress of loops (called with only 1 line of code), with the
option to periodically backup a key object during the loop; estimate.memory()
to determine whether the object may exceed some threshold before creating it,
timeit(), a one line wrapper for proftools which gives a detailed breakdown of
time taken, and time within each function called during a procedure; and 
check.linux.install() to verify installation status of terminal commands before 
using system(), top() to examine current memory and CPU usage [using the system
'top' command]. prv() is useful for debugging as it allows a detailed preview of
objects, and is as easy as placing print statements within loops/functions but
gives more information, and gives compact output for large objects. For testing
sim.cor() provides a simple way to simulate a correlated data matrix, as often
this is more realistic than completely random data. Otherwise summarise.r.datasets
gives a list of all available datasets and their structure and dimensionality.
</p>
<p>List of key functions:
</p>

<ul>
<li><p><em>check.linux.install </em> Check whether a given system command is installed (e.g, bash)
</p>
</li>
<li><p><em>comma.list </em> Nicely format output lists with comma separation and length control
</p>
</li>
<li><p><em>comify </em> Function to add commas for large numbers
</p>
</li>
<li><p><em>cor.with </em> simulate a variable with a specified correlation to an existing variable
</p>
</li>
<li><p><em>Dim </em> same as dim() function but works for more objects, including vectors 
</p>
</li>
<li><p><em>dup.pairs </em> Obtain an ordered index of all instances of values with duplicates
</p>
</li>
<li><p><em>estimate.memory </em> Estimate the memory required for an object
</p>
</li>
<li><p><em>exists.not.function </em> same as exists() function but ignores functions 
</p>
</li>
<li><p><em>extend.pc </em> Extend an interval by percentage
</p>
</li>
<li><p><em>fakeLines </em> Create randomized lines of text for testing
</p>
</li>
<li><p><em>force.percentage </em> Force argument to be a decimal percentage
</p>
</li>
<li><p><em>force.scalar </em> Force argument to be a scalar
</p>
</li>
<li><p><em>get.distinct.cols </em> Return up to 22 distinct colours
</p>
</li>
<li><p><em>getRepositories </em> Return list of available repositories
</p>
</li>
<li><p><em>has.method </em> Determine whether a function can be applied to an S4 class/object
</p>
</li>
<li><p><em>headl </em> A good way to preview large lists
</p>
</li>
<li><p><em>Header </em> Print heading text with a border
</p>
</li>
<li><p><em>is.vec.logical </em> Test whether vector is logical independent of type
</p>
</li>
<li><p><em>is.vec.numeric </em> Test whether vector is numeric independent of type
</p>
</li>
<li><p><em>list.functions.in.file </em> Show all functions used in an R script file, by package
</p>
</li>
<li><p><em>list.to.env </em> Inserts new variables in current environment from a named list
</p>
</li>
<li><p><em>loess.scatter </em> Draw a scatterplot with a fit line
</p>
</li>
<li><p><em>loop.tracker </em> Creates a progess bar within a loop with only 1 line
</p>
</li>
<li><p><em>Mode </em> Find the mode(s) of a vector
</p>
</li>
<li><p><em>must.use.package </em> Do everything possible to load an R package
</p>
</li>
<li><p><em>narm </em> Return an object with missing values removed
</p>
</li>
<li><p><em>nearest.to </em> Similar to base match function but picks nearest instead of exact match
</p>
</li>
<li><p><em>Numerify </em> Convert only suitable columns to numeric format in data.frame
</p>
</li>
<li><p><em>out.of </em> Simplify outputting fractions/percentages
</p>
</li>
<li><p><em>p.to.Z </em> Convert p-values to Z-scores
</p>
</li>
<li><p><em>packages.loaded </em> quietly test whether packages are loaded without using require 
</p>
</li>
<li><p><em>pad.left </em> Print a vector with appropriate padding so each has equal char length
</p>
</li>
<li><p><em>pctile </em> Find data thresholds corresponding to percentiles
</p>
</li>
<li><p><em>ppa </em> Posterior probability for p-values
</p>
</li>
<li><p><em>preview </em> same as prv, but enter arguments as strings
</p>
</li>
<li><p><em>prv.large </em> tidy representation for large matrices/data.frames
</p>
</li>
<li><p><em>prv </em> compact preview of objects (more complete than 'print')
</p>
</li>
<li><p><em>replace.missing.df </em> replace missing values in data.frame automatically 
</p>
</li>
<li><p><em>Rfile.index </em> Create an index file for an R function file
</p>
</li>
<li><p><em>rmv.names </em> Remove names from object 
</p>
</li>
<li><p><em>rmv.spc </em> Remove leading and trailing spaces (or other character)
</p>
</li>
<li><p><em>search.cran </em> Search all CRAN packages for those containing keyword(s)
</p>
</li>
<li><p><em>sim.cor </em> simulate a correlated dataset
</p>
</li>
<li><p><em>simple.date </em> generate a string with compact summary of date/time 
</p>
</li>
<li><p><em>spc </em> Print a character a specified number of times
</p>
</li>
<li><p><em>standardize </em> Convert a numeric vector to Z-scores
</p>
</li>
<li><p><em>Substitute </em> multivariable version of substitute (base)
</p>
</li>
<li><p><em>summary2 </em> Extension of base:summary that adds SD, SE and keeps names fixed and cleaner
</p>
</li>
<li><p><em>summarise.r.datasets </em> show and summarise all available example datasets 
</p>
</li>
<li><p><em>table2d </em> Extension of base:table that forces fixed rows and columns
</p>
</li>
<li><p><em>textogram </em> Make an ascii histogram in the console
</p>
</li>
<li><p><em>timeit </em> Times an expression, with breakdown of time spent in functions
</p>
</li>
<li><p><em>toheader </em> Return a string with each first letter of each word in upper case
</p>
</li>
<li><p><em>top </em> report on CPU and memory usage, overall or by process 
</p>
</li>
<li><p><em>Unlist </em> Unlist a list, starting only from a set depth
</p>
</li>
<li><p><em>wait </em> Wait for a period of time
</p>
</li>
<li><p><em>which.outlier </em> Return indexes of univariate outliers
</p>
</li>
<li><p><em>Z.to.p </em> Convert Z-scores to p-values
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>
<p>Maintainer: 
Nicholas Cooper &lt;njcooper@gmx.co.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="reader.html#topic+reader-package">reader</a></code> ~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#text histogram suited to working from a console without GUI graphics
textogram(rnorm(10000),range=c(-3,3))
# wait 0.2 seconds
wait(0.2,silent=FALSE) 
# see whether a system command is installed
check.linux.install("sed") 
# a nice progress bar
max &lt;- 100; for (cc in 1:max) { loop.tracker(cc,max); wait(0.004,"s") }
# nice header
Header(c("SPACE","The final frontier"))
# memory req'd for proposed or actual object
estimate.memory(matrix(rnorm(100),nrow=10)) 
# a mode function (there isn't one included as part of base)
Mode(c(1,2,3,3,4,4,4))
# search for packages containing text, eg, 'misc'
search.cran("misc", repos="http://cran.ma.imperial.ac.uk/") 
# simulate a correlated dataset
corDat &lt;- sim.cor(200,5)
cor(corDat) # show correlation matrix
prv(corDat) # show compact preview of matrix
# Dim() versus dim()
Dim(1:10); dim(1:10)
# find nearest match in a vector:
nearest.to(1:100, 50.5)
</code></pre>

<hr>
<h2 id='check.linux.install'>Check whether a given system command is installed (e.g, bash)</h2><span id='topic+check.linux.install'></span>

<h3>Description</h3>

<p>Tests whether a command is installed and callable by system().
Will return a warning if run on windows when linux.more=TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.linux.install(cmd = c("plink", "perl", "sed"), linux.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.linux.install_+3A_cmd">cmd</code></td>
<td>
<p>character vector of commands to test</p>
</td></tr>
<tr><td><code id="check.linux.install_+3A_linux.mode">linux.mode</code></td>
<td>
<p>logical, alternate way of command testing that only works on linux and
mac OS X, to turn this on, set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns true or false for each command in 'cmd'
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check.linux.install("R") # should be standard
check.linux.install(c("perl","sed","fake-cmd"))
</code></pre>

<hr>
<h2 id='comify'>Function to add commas for large numbers</h2><span id='topic+comify'></span>

<h3>Description</h3>

<p>Often for nice presentation of genomic locations it is helpful
to insert commas every 3 digits when numbers are large. This function
makes it simple and allows specification of digits if a decimal number
is in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comify(x, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comify_+3A_x">x</code></td>
<td>
<p>a vector of numbers, either as character, integer or numeric form</p>
</td></tr>
<tr><td><code id="comify_+3A_digits">digits</code></td>
<td>
<p>integer, if decimal numbers are in use, how many digits to display, 
same as input to base::round()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a character vector with commas inserted every 3 digits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comify("23432")
comify(x=c(1,25,306,999,1000,43434,732454,65372345326))
comify(23432.123456)
comify(23432.123456,digits=0)
</code></pre>

<hr>
<h2 id='comma.list'>Print out comma separated list of values in X, truncating if many (good for error messages)</h2><span id='topic+comma.list'></span>

<h3>Description</h3>

<p>Often for nice presentation of error messages you wish to display a list of values.
This adds commas between entries and will truncate the list above a length of 50
items with an ellipsis. Very simple but convenient function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comma.list(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comma.list_+3A_x">X</code></td>
<td>
<p>a vector to be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string with entries separated by commas, and if long, entries skipped
indicated by an ellipsis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comma.list(1:100)
cat("The following entries were ignored: ", comma.list(c(1,7,10:14)), "\n")
</code></pre>

<hr>
<h2 id='cor.with'>Simulate a correlated variable</h2><span id='topic+cor.with'></span>

<h3>Description</h3>

<p>Simulate a variable correlated at level 'r' with cector x (of the same length). Can
either 'preserve' the mean and standard-deviation, leave standardizeed, 
or select new mean 'mn' and standard deviation 'st'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.with(x, r = 0.5, preserve = FALSE, mn = NA, st = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.with_+3A_x">x</code></td>
<td>
<p>existing variable, to which you want to simulate a new correlated variable</p>
</td></tr>
<tr><td><code id="cor.with_+3A_r">r</code></td>
<td>
<p>the 'expected' correlation you want to target (randomness 
will mean that the actual correlation will vary around this value)</p>
</td></tr>
<tr><td><code id="cor.with_+3A_preserve">preserve</code></td>
<td>
<p>logical, whether to preserve the same mean and standard deviation(SD)
as x, for the new variable</p>
</td></tr>
<tr><td><code id="cor.with_+3A_mn">mn</code></td>
<td>
<p>optional, set the mean for the new simulated variable [must also set st if using this]</p>
</td></tr>
<tr><td><code id="cor.with_+3A_st">st</code></td>
<td>
<p>optional, set the SD for the new simulated variable [must also set mn if using this]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the new variable with an expected correlation of 'r' with x
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>References</h3>

<p>http://www.uvm.edu/~dhowell/StatPages/More_Stuff/CorrGen.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.cor">sim.cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(10,100,14)
cor.with(X,r=.5) # create a variable correlated .5 with X
cor(X,cor.with(X)) # check the actual correlation
# some variability in the actual correlation, so run 1000 times:
print(mean(replicate(1000,{cor(X,cor.with(X))})))
cor.with(X,preserve=TRUE) # preserve original mean and standard deviation
X[c(4,10)] &lt;- NA # works fine with NAs, but new var will have same missing
cor.with(X,mn=50,st=2) # specify new mean and standard deviation
</code></pre>

<hr>
<h2 id='Dim'>A more general dimension function</h2><span id='topic+Dim'></span>

<h3>Description</h3>

<p>A more general 'dim' function. For arrays simply calls the dim() function, but for other data types, tries to
provide an equivalent, for instance will call length(x) for vectors, and will
recursively report dims for lists, and will attempt something sensible for other datatypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dim(x, cat.lists = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dim_+3A_x">x</code></td>
<td>
<p>the object to find the dimension for</p>
</td></tr>
<tr><td><code id="Dim_+3A_cat.lists">cat.lists</code></td>
<td>
<p>logical, for lists, TRUE will concatenate the dimesions to a single string,
or FALSE will return the sizes as a list of the same structure as the original.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dimension(s) of the object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prv">prv</a></code>, <code><a href="#topic+preview">preview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create variables of different types to show output styles #
Dim(193)
Dim(1:10)
testvar &lt;- matrix(rnorm(100),nrow=25)
Dim(matrix(rnorm(100),nrow=25))
Dim(list(first="test",second=testvar,third=100:110))
Dim(list(first="test",second=testvar,third=100:110),FALSE)
</code></pre>

<hr>
<h2 id='dup.pairs'>Obtain an index of all instances of values with duplicates (ordered)</h2><span id='topic+dup.pairs'></span>

<h3>Description</h3>

<p>The standard 'duplicated' function, called with which(duplicated(x)) will 
only return the indexes of the extra values, not the first instances. For instance
in the sequence: A,B,A,C,D,B,E; it would return: 3,6. This function will also
return the first instances, so in this example would give: 1,3,2,6 [note it
will also be ordered]. This index can be helpful for diagnosis if duplicates 
are unexpected, for instance in a data.frame, and you wish to compare the differences
between the rows with the duplicate values occuring. Also, duplicate values are sorted
to be together in the listing, which can help for manual troubleshooting of undesired
duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.pairs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dup.pairs_+3A_x">x</code></td>
<td>
<p>a vector that you wish to extract duplicates from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of indices of which values in 'x' are duplicates (including
the first observed value in pairs, or sets of &gt;2), ordered by set, then
by appearance in x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set &lt;- c(1,1,2,2,3,4,5,6,2,2,2,2,12,1,3,3,1)
dup.pairs(set) # shows the indexes (ordered) of duplicated values
set[dup.pairs(set)] # shows the values that were duplicated (only 1's, 2's and 3's)
</code></pre>

<hr>
<h2 id='estimate.memory'>Estimate the memory required for an object.</h2><span id='topic+estimate.memory'></span>

<h3>Description</h3>

<p>Can enter an existing object or just the dimensions or total length of a proposed object.
The estimate is based on the object being of numeric type. Integers use half the space
of numeric, raw() use 1/8th of the space. Factors and characters can vary, although
factors will always use less than numeric, and character variables may easily use up
to twice as much depending on the length [nchar()] of each element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.memory(
  dat,
  integer = FALSE,
  raw = FALSE,
  unit = c("gb", "mb", "kb", "b"),
  add.unit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.memory_+3A_dat">dat</code></td>
<td>
<p>either a vector/matrix/dataframe object, or else up to 10 dimensions of such an
object, or a potential object, i.e; c(nrow,ncol). If entering an object directly,
you can leave out the 'integer' and 'raw' arguments as these will be detected from
the object type. Any set of dimensions &gt;10 will be assumed to be a vector, so
if you have such an object, better to submit the total product [base::prod()].</p>
</td></tr>
<tr><td><code id="estimate.memory_+3A_integer">integer</code></td>
<td>
<p>if the object or potential object is integer or logical type,
set this argument to TRUE, if this is TRUE, the parameter 'RAW' will
be ignored; integer and logical types use 1/2 of the memory of numeric types</p>
</td></tr>
<tr><td><code id="estimate.memory_+3A_raw">raw</code></td>
<td>
<p>if the object or potential object is of 'raw' type,
set this argument to TRUE, note that if 'integer' is TRUE, this parameter 'RAW' will
be ignored; raw types use 1/8 of the memory of numeric types</p>
</td></tr>
<tr><td><code id="estimate.memory_+3A_unit">unit</code></td>
<td>
<p>the storage units to use for the result, ie, &quot;gb&quot;, &quot;mb&quot;,&quot;kb&quot;, &quot;b&quot; for
gigabytes, megabytes, kilobytes, or bytes respectively.</p>
</td></tr>
<tr><td><code id="estimate.memory_+3A_add.unit">add.unit</code></td>
<td>
<p>logical, whether to append the unit being used to the result,
making the result character type instead of numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the minimum memory requirement to store and object of the specified
size, as a numeric scalar, in gigabytes (default) or else using the units specified by 'unit',
and if add.unit = TRUE, then the result will be character type instead of numeric, with
the units appended.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myMatrix &lt;- matrix(rnorm(100),nrow=10)
myVec &lt;- sample(1:1000)
estimate.memory(myMatrix,unit="bytes") # enter a matrix object
estimate.memory(myVec,unit="kb" ,add.unit=TRUE) # enter a vector object
estimate.memory(c(10,10,10,10,10),unit="kb") # 5 dimensional array
estimate.memory(c(10^6,10^4), add.unit=TRUE) # large matrix
estimate.memory(5.4*10^8, add.unit=TRUE)  # entering argument as # total cells, rather than dims
estimate.memory(5.4*10^8, integer=TRUE, add.unit=TRUE)
estimate.memory(5.4*10^8, raw=TRUE, add.unit=TRUE)
estimate.memory(5.4*10^8, TRUE, TRUE, add.unit=TRUE) #  'integer' overrides 'raw'
</code></pre>

<hr>
<h2 id='exists.not.function'>Does object exist ignoring functions
The exists() function can tell you whether an object exists
at all, or whether an object exists with a certain type, but
it can be useful to know whether an object exists as genuine 
data (and not a function) which can be important when a variable
or object is accidently or intentionally given the same name as
a function. This function usually returns a logical value as to
the existence of the object (ignoring functions) but can also
be set to return the non-function type if the object exists.</h2><span id='topic+exists.not.function'></span>

<h3>Description</h3>

<p>Does object exist ignoring functions
</p>
<p>The exists() function can tell you whether an object exists
at all, or whether an object exists with a certain type, but
it can be useful to know whether an object exists as genuine 
data (and not a function) which can be important when a variable
or object is accidently or intentionally given the same name as
a function. This function usually returns a logical value as to
the existence of the object (ignoring functions) but can also
be set to return the non-function type if the object exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exists.not.function(x, ret.type = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exists.not.function_+3A_x">x</code></td>
<td>
<p>the object name to search for</p>
</td></tr>
<tr><td><code id="exists.not.function_+3A_ret.type">ret.type</code></td>
<td>
<p>logical, if TRUE then will return the objects' type (if it exists) rather
than TRUE or FALSE. If the object doesn't exist the empty string will be returned as the type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether non-function object exists, or else the type if ret.type=TRUE
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "test"
# the standard exists function, for all modes, correct mode, and other modes:
exists("x")
exists("x",mode="character")
exists("x",mode="numeric")
# standard case for a non-function variable
exists.not.function("x",TRUE)
# compare results for a non-existent variable
exists("aVarNotSeen")
exists.not.function("aVarNotSeen")
# compare results for variable that is a function
exists("mean")
exists.not.function("mean")
# define a variable with same name as a function
mean &lt;- 1.4
# exists.not.function returns the type of the variable ignoring the function of the same name
exists.not.function("mean",TRUE)
exists("mean",mode="function")
exists("mean",mode="numeric")
</code></pre>

<hr>
<h2 id='extend.pc'>Extend an interval by percentage</h2><span id='topic+extend.pc'></span>

<h3>Description</h3>

<p>For various reasons, such as applying windows, setting custom range limits for plots, it may 
be desirable to extend an interval by a certain percentage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend.pc(X, pc = 0.5, pos = TRUE, neg = TRUE, swap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend.pc_+3A_x">X</code></td>
<td>
<p>a numeric range, should be length 2. If a longer numeric, will be coerced with range()</p>
</td></tr>
<tr><td><code id="extend.pc_+3A_pc">pc</code></td>
<td>
<p>percentage by which to extend X, can be entered in either percentage style: 0&lt;pc&lt;1; 
or 1&lt;pc&lt;100</p>
</td></tr>
<tr><td><code id="extend.pc_+3A_pos">pos</code></td>
<td>
<p>logical, if TRUE, make an extension in the positive direction</p>
</td></tr>
<tr><td><code id="extend.pc_+3A_neg">neg</code></td>
<td>
<p>logical, if TRUE, make an extension in the negative direction</p>
</td></tr>
<tr><td><code id="extend.pc_+3A_swap">swap</code></td>
<td>
<p>logical, if TRUE, flip the extension directions if X[2]&lt;X[1], ie, not in numerical
order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>extend.pc(c(2,10),0.25) # extend X symmetrically
extend.pc(c(2:10),0.25) # extend the range of X
# the following 3 examples extend X by 1% only in the 'positive' direction
extend.pc(c(25000,55000),.01,neg=FALSE) # standard positive extension
extend.pc(c(55000,25000),.01,neg=FALSE) # ranges in reverse order, not swapped
extend.pc(c(55000,25000),.01,neg=FALSE,swap=TRUE) # ranges in reverse order, swapped
</code></pre>

<hr>
<h2 id='fakeLines'>Create fake text for testing purposes</h2><span id='topic+fakeLines'></span>

<h3>Description</h3>

<p>Returns randomized input as if reading lines from a file, like 'readLines()'
Can be used to test i/o functions, robustness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fakeLines(
  max.lines = 10,
  max.chars = 100,
  pc.space = 0.35,
  delim = " ",
  can.null = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fakeLines_+3A_max.lines">max.lines</code></td>
<td>
<p>maxmimum number of fake lines to read</p>
</td></tr>
<tr><td><code id="fakeLines_+3A_max.chars">max.chars</code></td>
<td>
<p>maximum number of characters per line</p>
</td></tr>
<tr><td><code id="fakeLines_+3A_pc.space">pc.space</code></td>
<td>
<p>percentage of randomly generated characters that should be a delimiter</p>
</td></tr>
<tr><td><code id="fakeLines_+3A_delim">delim</code></td>
<td>
<p>what should the simulated delimiter be, e.g, a space, comma etc. If you wish not
to include such either set the delimiter as &quot;&quot;, or set pc.space=0.</p>
</td></tr>
<tr><td><code id="fakeLines_+3A_can.null">can.null</code></td>
<td>
<p>whether with probability 1/max.lines to return NULL instead of any lines of text,
which simulates an empty file, which for testing purposes you may want to be able to handle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character entries up 'max.chars' long, or sometimes only NULL if can.null=TRUE
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fakeLines() # should produce between zero and ten lines of random text, 35% of which are spaces
</code></pre>

<hr>
<h2 id='file.split'>Split a text file into multiple parts</h2><span id='topic+file.split'></span>

<h3>Description</h3>

<p>Wrapper for the bash command 'split' that can separate a text file into multiple 
roughly equal sized parts. This function removes the need to remember syntax and
suffixes of the bash command
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file.split(
  fn,
  size = 50000,
  same.dir = FALSE,
  verbose = TRUE,
  suf = "part",
  win = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file.split_+3A_fn">fn</code></td>
<td>
<p>character, file name of the text file to split, if the file is an imcompatible format
the linux command should return an error message to the console</p>
</td></tr>
<tr><td><code id="file.split_+3A_size">size</code></td>
<td>
<p>integer, the maximum number of lines for the split parts of the file produced</p>
</td></tr>
<tr><td><code id="file.split_+3A_same.dir">same.dir</code></td>
<td>
<p>logical, whether the resulting files should be moved to the same
directory as the original file, or simply left in the working directory [getwd()]</p>
</td></tr>
<tr><td><code id="file.split_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to report the resulting file names to the console</p>
</td></tr>
<tr><td><code id="file.split_+3A_suf">suf</code></td>
<td>
<p>character, suffix for the split files, default is 'part', the original file
extension will be appended after this suffix</p>
</td></tr>
<tr><td><code id="file.split_+3A_win">win</code></td>
<td>
<p>logical, set to FALSE if running a standard windows setup (cmd.ext), and the file
split will run natively in R. Set to TRUE if you have a unix-alike command system, such as
CygWin, sh.exe, csh.exe, tsh.exe, running, and this will then check to see whether the POSIX
'split' command is present (this provides a speed advantage). If in doubt, windows users
can always set win=TRUE; the only case where this will cause an issue is if there is a
different command installed with the same name (i.e, 'split').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the list of file names produced (including path)
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.dir &lt;- getwd(); setwd(tempdir()); # move to temporary dir
file.name &lt;- "myfile.txt"
writeLines(fakeLines(max.lines=1000),con=file.name)
new.files &lt;- file.split(file.name,size=50)
unlink(new.files); unlink(file.name)
setwd(orig.dir) # reset working dir to original
</code></pre>

<hr>
<h2 id='force.percentage'>Force argument to be a percentage with length one</h2><span id='topic+force.percentage'></span>

<h3>Description</h3>

<p>Sometimes it is nice to be able to take a percentage as an argument and not
have to specify whether it should be entered as a number between 0 and 100, 
e.g, 50 = 50
than 1 and less than 100 will be divided by 100. Anything outside 0,100 will be
set to 0,100 respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.percentage(x, default = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force.percentage_+3A_x">x</code></td>
<td>
<p>the object to ensure is a oercentage</p>
</td></tr>
<tr><td><code id="force.percentage_+3A_default">default</code></td>
<td>
<p>the value to revert to if the format of x is illegal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object x if already legal, first element if a vector, the min or
max value if x is outside the specified bounds, or the value of default otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+force.scalar">force.scalar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create variables of different types to show output styles #
force.percentage(45)
force.percentage(450)
force.percentage(.45)
force.percentage(-45)
force.percentage("twenty")
force.percentage(NA,default=0.25)
</code></pre>

<hr>
<h2 id='force.scalar'>Force argument to be a numeric type with length one</h2><span id='topic+force.scalar'></span>

<h3>Description</h3>

<p>Sometimes arguments must be numeric, scalar and within a certain range.
Rather than using many if statements, this will do everything possible to 
coerce input to a scalar, failing that will replace with a default value.
Can also provide a maximum and minimum range that the result must lie within.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.scalar(x, default = 1, min = -10^10, max = 10^10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force.scalar_+3A_x">x</code></td>
<td>
<p>the object to ensure is a scalar</p>
</td></tr>
<tr><td><code id="force.scalar_+3A_default">default</code></td>
<td>
<p>the value to revert to if the format of x is illegal</p>
</td></tr>
<tr><td><code id="force.scalar_+3A_min">min</code></td>
<td>
<p>a lower bound for the output, anything below this is set to min</p>
</td></tr>
<tr><td><code id="force.scalar_+3A_max">max</code></td>
<td>
<p>an upper bound for the output, anything above this is set to max</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object x if already legal, first element if a vector, the min or
max value if x is outside the specified bounds, or the value of default otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+force.percentage">force.percentage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>force.scalar(1.5)
force.scalar(NULL,default=.5)
force.scalar(NA,default=.4,min=5,max=10) # default is outside range!
force.scalar(rnorm(1000))
force.scalar(101,max=50)
force.scalar(list(0.4,1,2,3,4,"test"))
force.scalar(data.frame(test=c(1,2,3),name=c("test","me","few")))
force.scalar(Inf)
</code></pre>

<hr>
<h2 id='get.distinct.cols'>Return up to 22 distinct colours.</h2><span id='topic+get.distinct.cols'></span>

<h3>Description</h3>

<p>Useful if you want to colour 22 autosomes, etc, because most R
colour palettes only provide 12 or fewer colours, or else provide,
a gradient which is not distinguishable for discrete categories.
Manually curated so the most similar colours aren't side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.distinct.cols(n = 22)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.distinct.cols_+3A_n">n</code></td>
<td>
<p>number of unique colours to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vector of n colours
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.distinct.cols(10)
plot(1:22,pch=19,col=get.distinct.cols(22))
</code></pre>

<hr>
<h2 id='getRepositories'>Detect all available R repositories.</h2><span id='topic+getRepositories'></span>

<h3>Description</h3>

<p>In addition to the default CRAN repository, there are other repositories such
as R-Forge, Omegahat, and bioConductor (which is split in to software, annotation,
experiments and extras). This function allows you to retrieve which are available.
This function complements (and takes code from) utils::setRepositories(), which
will just set, not return which are available, but see there for more information
about how this works. Detecting the available repositories can be useful to precede
a call to setRepositories, and allows you to utilise these repositories without
calling setRepositories (which is hard to reverse). This function can be used to
expand the search space of the function search.cran() to include bioconductor packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRepositories(ind = NULL, table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRepositories_+3A_ind">ind</code></td>
<td>
<p>index, same as for 'setRepositories', if NULL this function returns all available
repositories, or if an index, returns a subset.</p>
</td></tr>
<tr><td><code id="getRepositories_+3A_table">table</code></td>
<td>
<p>logical, if TRUE, return a table of information, else just return the URLs, 
which are the required input for the 'repos' argument for relevant functions, 
e.g, available.packages() or search.cran()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of repositories with URLS, note that it is the URL that works best for
use for passing a value for 'repos' to various functions.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repos &lt;- "http://cran.ma.imperial.ac.uk/" # OR: repos &lt;- getOption("repos")
getRepositories(table=TRUE) # shows all available
getRepositories(2:5,FALSE) # returns index for all bioconductor repositories (on my system at least)
# does not find this bioconductor package on CRAN
## not run # search.cran("genoset",repos=getRepositories(1))
# should now, because all repositories are used
## not run # search.cran("genoset",repos=getRepositories())
</code></pre>

<hr>
<h2 id='has.method'>Determine whether a function can be applied to an S4 class/object</h2><span id='topic+has.method'></span>

<h3>Description</h3>

<p>Wrapper for 'showMethods', allows easy testing whether a function
(can be specified as a string, or the actual function itself (FUN)) can be
applied to a specific object or class of objects (CLASS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.method(FUN, CLASS, false.if.error = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has.method_+3A_fun">FUN</code></td>
<td>
<p>the function to test, can be specified as a string, or the actual function itself</p>
</td></tr>
<tr><td><code id="has.method_+3A_class">CLASS</code></td>
<td>
<p>a specific object or a class of objects specified by a string, e.g, &quot;GRanges&quot;</p>
</td></tr>
<tr><td><code id="has.method_+3A_false.if.error">false.if.error</code></td>
<td>
<p>logical, the default value is FALSE, in which case an error is returned
when FUN is not an S4 generic function. If this parameter is set to TRUE, 'FALSE' will
be returned with a warning instead of an error.</p>
</td></tr>
<tr><td><code id="has.method_+3A_...">...</code></td>
<td>
<p>additional arguments to showMethods(), e.g, 'where' to specify the environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns logical (TRUE/FALSE), or if the function is not S4 will return an error,
although this could potentially be because the function's package has not been loaded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Matrix); require(methods)
has.method("t","dgeMatrix") # t() is the transpose method for a dgeMatrix object
has.method(t,"dgeMatrix") # also works without quotes for the method
m.example &lt;- as(matrix(rnorm(100),ncol=5),"dgeMatrix")
has.method(t, m.example) # works with an instance of an object type too
has.method("band", m.example) # band is a function for a 'denseMatrix' but not 'dgeMatrix'
## not run # has.method("notAFunction","GRanges") # should return error
## not run # has.method("notAFunction","GRanges",TRUE) # should return FALSE and a warning
</code></pre>

<hr>
<h2 id='Header'>Print heading text with a border.</h2><span id='topic+Header'></span>

<h3>Description</h3>

<p>Makes highly visible headings, can separately horizontal, 
vertical and corner characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Header(txt, h = "=", v = h, corner = h, align = "center")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Header_+3A_txt">txt</code></td>
<td>
<p>The text to display in the centre</p>
</td></tr>
<tr><td><code id="Header_+3A_h">h</code></td>
<td>
<p>the ascii character to use on the horizontal sections of
the border, and used for v,corner too if not specified separately</p>
</td></tr>
<tr><td><code id="Header_+3A_v">v</code></td>
<td>
<p>the character to use on vertical sections of the border</p>
</td></tr>
<tr><td><code id="Header_+3A_corner">corner</code></td>
<td>
<p>the character to use on corner sections of the border</p>
</td></tr>
<tr><td><code id="Header_+3A_align">align</code></td>
<td>
<p>alignment of the writing, when there are multiple lines,
e.g, &quot;right&quot;, &quot;left&quot;, &quot;centre&quot;/&quot;center&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing, simply prints the heading to the console
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Header("Section 1")
Header("Section 1",h="-",v="|",corner="*")
Header(c("SPACE","The final frontier"))
Header(c("MY SCRIPT","Part 1"),align="left",h=".")
</code></pre>

<hr>
<h2 id='headl'>A good way to preview large lists.</h2><span id='topic+headl'></span>

<h3>Description</h3>

<p>An alternative to head(list) which allows limiting of large list 
components in the console display
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headl(x, n = 6, skip = 20, skip2 = 10, ind = "", ind2 = "  ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="headl_+3A_x">x</code></td>
<td>
<p>a list to preview</p>
</td></tr>
<tr><td><code id="headl_+3A_n">n</code></td>
<td>
<p>The number of values to display for the deepest nodes
of the list</p>
</td></tr>
<tr><td><code id="headl_+3A_skip">skip</code></td>
<td>
<p>number of first level elements to display before skipping
the remainder</p>
</td></tr>
<tr><td><code id="headl_+3A_skip2">skip2</code></td>
<td>
<p>number of subsequent level elements to display before 
skipping the remainder</p>
</td></tr>
<tr><td><code id="headl_+3A_ind">ind</code></td>
<td>
<p>indent character for first level elements</p>
</td></tr>
<tr><td><code id="headl_+3A_ind2">ind2</code></td>
<td>
<p>indent character for subsequent level elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints truncated preview of a large list
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sub1 &lt;- list(list(1:100),list(2:101),list(101:200),list(201:300),list(301:400))
big.list &lt;- list(sub1,sub1,sub1,sub1,sub1,sub1)
headl(sub1)
headl(big.list,skip=2)
</code></pre>

<hr>
<h2 id='is.vec.logical'>Determine robustly whether a vector contains logical data</h2><span id='topic+is.vec.logical'></span>

<h3>Description</h3>

<p>This is an improvement on base:is.logical because data may be encoded as
a different type (e.g, string, &quot;TRUE&quot;, &quot;FALSE&quot;) especially if imported from
a file. This does not include logical vectors coded as 0,1; such will
return FALSE with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.vec.logical(x, thresh = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.vec.logical_+3A_x">x</code></td>
<td>
<p>a vector to check for logical status</p>
</td></tr>
<tr><td><code id="is.vec.logical_+3A_thresh">thresh</code></td>
<td>
<p>threshold to decide that a variable is logical. NA values will
be ignored in the test. Then it looks at the proportion of values that are
successfully coerced to logical without giving 'NA'. If this threshold is
0.9, then any column where at least 90
converted to logical type, will return TRUE for this function call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a logical TRUE or FALSE for the logical status of x.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numeric &lt;- 1:10
string &lt;- paste("one", "two", "three", "four")
logic1 &lt;- c(TRUE,FALSE,FALSE,TRUE,FALSE,NA)
logic2 &lt;- c("TRUE", "FALSE", "TRUE", NA, "TRUE", NA, NA, NA)
logic3 &lt;- c("True", "False", "True", "False")
numlogic &lt;- c(0,1,0,0,0,1,1,1,0)
is.vec.logical(numeric)
is.vec.logical(string)
is.vec.logical(logic1)
is.vec.logical(logic2)
is.vec.logical(logic3)
is.vec.logical(numlogic)
</code></pre>

<hr>
<h2 id='is.vec.numeric'>Determine robustly whether a vector contains numeric data</h2><span id='topic+is.vec.numeric'></span>

<h3>Description</h3>

<p>This is an improvement on base:is.numeric because data may be encoded as
a different type (e.g, string) especially if imported from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.vec.numeric(x, logical.is.numeric = FALSE, thresh = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.vec.numeric_+3A_x">x</code></td>
<td>
<p>a vector to check for numeric status</p>
</td></tr>
<tr><td><code id="is.vec.numeric_+3A_logical.is.numeric">logical.is.numeric</code></td>
<td>
<p>by default this is FALSE, which means
logical vectors will return FALSE to being numeric. If set to
TRUE, then a variable will get a return value of TRUE if it is
based on numbers or appears to be of 'logical' type.</p>
</td></tr>
<tr><td><code id="is.vec.numeric_+3A_thresh">thresh</code></td>
<td>
<p>threshold to decide that a variable is numeric. NA values will
be ignored in the test. Then it looks at the proportion of values that are
successfully coerced to numeric without giving 'NA'. If this threshold is
0.9, then any column where at least 90
converted to numeric type, will return TRUE for this function call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a logical TRUE or FALSE for the numeric status of x.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numeric1 &lt;- 1:10
numeric2 &lt;- paste(1:10)
string &lt;- paste("one", "two", "three", "four")
logic1 &lt;- c(TRUE,FALSE,FALSE,TRUE,FALSE,NA)
numericish &lt;- paste(c(NA, NA, 6:10, "5|6", "7|8", 1))
is.vec.numeric(numeric1)
is.vec.numeric(numeric2)
is.vec.numeric(string)
is.vec.numeric(logic1)
is.vec.numeric(logic1, logical.is.numeric=TRUE)
is.vec.numeric(numericish)
is.vec.numeric(numericish, thresh=0.7)
</code></pre>

<hr>
<h2 id='list.functions.in.file'>Show all functions used in an R script file, by package</h2><span id='topic+list.functions.in.file'></span>

<h3>Description</h3>

<p>Parses all functions called by an R script and then lists
them by package. Wrapper for 'getParseData'. Inspired by
'hrbrmstr', on StackExchange 3/1/2015. May be of great
use for those developing a package to help see what 
namespace 'importsFrom' calls will be required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.functions.in.file(filename, alphabetic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list.functions.in.file_+3A_filename">filename</code></td>
<td>
<p>path to an R file containing R code.</p>
</td></tr>
<tr><td><code id="list.functions.in.file_+3A_alphabetic">alphabetic</code></td>
<td>
<p>logical, whether to list functions alphabetically.
If FALSE, will list in order of appearance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. Parses all functions called by an R script 
and then lists them by package. Those from the script itself are listed
under '.GlobalEnv' and any functions that may originate
from multiple packages have all possibilities listed. Those listed under
'character(0)' are those for which a package could not be found- may be
functions within functions, or from packages that aren't loaded.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rfile.index">Rfile.index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run:  rfile &lt;- file.choose() # choose an R script file with functions
# not run:  list.functions.in.file(rfile)
</code></pre>

<hr>
<h2 id='list.to.env'>Create variables from a list</h2><span id='topic+list.to.env'></span>

<h3>Description</h3>

<p>Places named objects in a list into the working environment as individual variables.
Can be particularly helpful when you want to call a function that produces a list of
multiple return variables; this gives a way to access them all at once in the environment
from which the function was called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.to.env(list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list.to.env_+3A_list">list</code></td>
<td>
<p>list, with named objects, each element will become a named variable in
the current environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New variables will be added to the current environment. Use with care as any 
already existing with the same name will be overwritten.
</p>


<h3>See Also</h3>

<p>base::list2env
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.to.env(list(myChar="a string", myNum=1234, myList=list("list within a list",c(1,2,3))))
print(myChar)
print(myNum)
print(myList)
two.arg.return &lt;- function(X) { return(list(Y=X+1,Z=X*10)) } 
result &lt;- two.arg.return(11) # function returns list with 2 variables
list.to.env(result)
print(Y); print(Z)
</code></pre>

<hr>
<h2 id='loess.scatter'>Draw a scatterplot with a fit line</h2><span id='topic+loess.scatter'></span>

<h3>Description</h3>

<p>Drawing a fit line usually requires some manual steps requiring several lines of code,
such as ensuring the data is sorted by x, and for some functions doesn't contain missing values.
This function takes care of these steps and automatically adds a loess fitline, or non-linear 
fitline. The type of scatter defaults to 'plot', but other scatter plot functions can be 
specified, such as graphics::smoothScatter(), for example. If 'file' is specifed, will 
automatically plot to a pdf of that name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess.scatter(
  x,
  y,
  file = NULL,
  loess = TRUE,
  span = 0.75,
  scatter = plot,
  ...,
  ylim = NULL,
  return.vectors = FALSE,
  fit.col = "red",
  fit.lwd = 2,
  fit.lty = "solid",
  fit.leg = TRUE,
  fit.r2 = TRUE,
  fast.loess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loess.scatter_+3A_x">x</code></td>
<td>
<p>data for the horizontal axis (independent variable)</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_y">y</code></td>
<td>
<p>data for the vertical axis (dependent variable)</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_file">file</code></td>
<td>
<p>file name for pdf export, leave as NULL if simply plotting to the GUI. File 
extension will be added automatically if missing</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_loess">loess</code></td>
<td>
<p>logical, if TRUE, fit using loess(), else use a polynomial fit</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_span">span</code></td>
<td>
<p>numeric scalar, argument passed to the 'span' parameter of loess(), see ?loess for details</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_scatter">scatter</code></td>
<td>
<p>function, by default is graphics::plot(), but any scatter-plot function of the 
form F(x,y,...) can be used, for example graphics::smoothScatter().</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_...">...</code></td>
<td>
<p>further arguments to the plot function specified by 'scatter', e.g, 'main', 'xlab', etc</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_ylim">ylim</code></td>
<td>
<p>numeric range for y axis, argument passed to plot(), see ?plot.</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_return.vectors">return.vectors</code></td>
<td>
<p>logical, if TRUE, do not plot anything, just return the x and y coordinates
of the fit line as a list of vectors, x and y.</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fit.col">fit.col</code></td>
<td>
<p>colour of the fit line</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>width of the fit line</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fit.lty">fit.lty</code></td>
<td>
<p>type of the fit line</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fit.leg">fit.leg</code></td>
<td>
<p>whether to include an automatic legend for the fit line (will alter the y-limits
to fit)</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fit.r2">fit.r2</code></td>
<td>
<p>logical, whether to display r squared of the fit in the fit legend</p>
</td></tr>
<tr><td><code id="loess.scatter_+3A_fast.loess">fast.loess</code></td>
<td>
<p>logical, if TRUE will alter control parameters to make the loess calculation
faster, which is useful for datasets with more than 1000 points. Also reduce the value of 'span'
to increase speed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if file is a character argument, plots data x,y to a file, else will generate a plot to
the current plotting environment/GUI. The display of the x,y points defaults to 'plot', but 
alternate scatter plot functions can be specified, such as graphics::smoothScatter() which used 
density smoothing, for example. Also, another option is to set return.vectors=TRUE, and then
the coordinates of the fit line will be returned, and no plot will be produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(NCmisc)
require(KernSmooth)
DD &lt;- sim.cor(1000,4) # create a simulated, correlated dataset
loess.scatter(DD[,3],DD[,4],loess=FALSE,bty="n",pch=".",cex=2)
loess.scatter(DD[,3],DD[,4],scatter=smoothScatter)
xy &lt;- loess.scatter(DD[,3],DD[,4],return.vectors=TRUE)
prv(xy) # preview the vectors produced
</code></pre>

<hr>
<h2 id='loop.tracker'>Creates a progess bar within a loop</h2><span id='topic+loop.tracker'></span>

<h3>Description</h3>

<p>Only requires a single line within a loop to run, in contrast
with the built-in tracker which requires a line to initialise,
and a line to close. Also has option to backup objects during long loops.
Ideal for a loop with a counter such as a for loop.
Tracks progress as either percentage of time remaining or
by intermittently displaying the estimated number of minutes to go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop.tracker(
  cc,
  max,
  st.time = NULL,
  sav.obj = NULL,
  sav.fn = NA,
  sav.freq = 10,
  unit = c("m", "s", "h")[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loop.tracker_+3A_cc">cc</code></td>
<td>
<p>integer, current value of the loop counter</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_max">max</code></td>
<td>
<p>integer, final value of the loop counter</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_st.time">st.time</code></td>
<td>
<p>'start time' when using 'time to go' mode, taken 
from a call to proc.time()</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_sav.obj">sav.obj</code></td>
<td>
<p>optionally an object to backup during the course of 
a very long loop, to restore in the event of a crash.</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_sav.fn">sav.fn</code></td>
<td>
<p>the file name to save 'save.obj'</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_sav.freq">sav.freq</code></td>
<td>
<p>how often to update 'sav.obj' to file, in terms of 
percentage of run-time</p>
</td></tr>
<tr><td><code id="loop.tracker_+3A_unit">unit</code></td>
<td>
<p>time units h/m/s if using 'time to go' mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing, simply prints progress to the console
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example with a for-loop
max &lt;- 100; for (cc in 1:max) { loop.tracker(cc,max); wait(0.004,"s") }
#example using the 'time to go' with a while loop
cc &lt;- 0; max &lt;- 10; start &lt;- proc.time()
while(cc &lt; max) { cc &lt;- cc + 1; wait(0.05,"s"); loop.tracker(cc,max,start,unit="s") }
# example with saving an object, and restoring after a crash
X &lt;- matrix(rnorm(5000),nrow=50); max &lt;- nrow(X); sums &lt;- numeric(max)
for (cc in 1:max) { 
  sums[cc] &lt;- sum(X[cc,])
  wait(.05) # just so this trivial loop doesn't finish so quickly
  loop.tracker(cc,max, sav.obj=sums, sav.fn="temp.rda", sav.freq=5);
  if(cc==29) { warning("faked a crash at iteration 29!"); rm(sums); break }
}
cat("\nloaded latest backup from iteration 28:",paste(load("temp.rda")),"\n")
print(sav.obj); unlink("temp.rda")
</code></pre>

<hr>
<h2 id='memory.summary'>Summary of RAM footprint for all R objects in the current session.
Not my function, but taken from an R-Help response by Elizabeth Purdom,
at Berkeley. Simply applies the function 'object.size' to the objects
in ls(). Also very similar to an example in the 'Help' for the 
utils::object.size() function.</h2><span id='topic+memory.summary'></span>

<h3>Description</h3>

<p>Summary of RAM footprint for all R objects in the current session.
Not my function, but taken from an R-Help response by Elizabeth Purdom,
at Berkeley. Simply applies the function 'object.size' to the objects
in ls(). Also very similar to an example in the 'Help' for the 
utils::object.size() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memory.summary(unit = c("kb", "mb", "gb", "b"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="memory.summary_+3A_unit">unit</code></td>
<td>
<p>default is to display &quot;kb&quot;, but you can also choose
&quot;b&quot;=bytes, &quot;mb&quot;= megabyte, or &quot;gb&quot; = gigabytes. Only the first
letter is used, and is not case sensitive, so enter units how you
like.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of object names with memory usage in bytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>memory.summary() # shows memory used by all objects in the current session in kb
memory.summary("mb") # change units to megabytes
</code></pre>

<hr>
<h2 id='Mode'>Find the mode of a vector.</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>The mode is the most common value in a series.
This function can return multiple values if there are equally
most frequent values, and can also work with non-numeric types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x, multi = FALSE, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>The data to take the mode from. Dimensions and NA's are 
removed if possible, strings, factors, numeric all permitted</p>
</td></tr>
<tr><td><code id="Mode_+3A_multi">multi</code></td>
<td>
<p>Logical, whether to return multiple modes if values
have equal frequency</p>
</td></tr>
<tr><td><code id="Mode_+3A_warn">warn</code></td>
<td>
<p>Logical, whether to give warnings when multiple values
are found (if multi=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The most frequent value, or sorted set of most frequent
values if multi==TRUE and there are more than one. Numeric if x 
is numeric, else as strings
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mode(c(1,2,3,3,4,4)) # 2 values are most common, as multi=FALSE, 
# selects the last value (after sort)
Mode(c(1,2,3,3,4,4),multi=TRUE) # same test with multi=T, 
# returns both most frequent
Mode(matrix(1:16,ncol=4),warn=TRUE) # takes mode of the entire
# matrix treating as a vector, but all values occur once
Mode(c("Tom","Dick","Harry"),multi=FALSE,warn=TRUE) # selects last
# sorted value, but warns there are multiple modes
Mode(c("Tom","Dick","Harry"),multi=TRUE,warn=TRUE) # multi==TRUE so
# warning is negated
</code></pre>

<hr>
<h2 id='must.use.package'>Do everything possible to load an R package.</h2><span id='topic+must.use.package'></span>

<h3>Description</h3>

<p>Like 'require()' except it will attempt to install a package if
necessary. Installation of bioconductor packages is deprecated.
Useful if you wish to share code with people who
may not have the same libraries as you, you can include a call to
this function which will simply load the library if present, or
else install, then load, if they do not have it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>must.use.package(
  pcknms,
  ask = FALSE,
  reload = FALSE,
  avail = FALSE,
  quietly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="must.use.package_+3A_pcknms">pcknms</code></td>
<td>
<p>list of packages to load/install</p>
</td></tr>
<tr><td><code id="must.use.package_+3A_ask">ask</code></td>
<td>
<p>whether to get the user's permission to install a
required package, or just go ahead and do it</p>
</td></tr>
<tr><td><code id="must.use.package_+3A_reload">reload</code></td>
<td>
<p>indicates to reload the package even if loaded</p>
</td></tr>
<tr><td><code id="must.use.package_+3A_avail">avail</code></td>
<td>
<p>see whether pcknms are in the list
of available CRAN packages</p>
</td></tr>
<tr><td><code id="must.use.package_+3A_quietly">quietly</code></td>
<td>
<p>passed to library/require, display installation
text or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, simply loads the packages specified if possible
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run : run if you are ok to install/already have these packages
# must.use.package(c("MASS","nlme","lme4"),ask=FALSE)
# search() # show packages have loaded, then detach them again:
# sapply(paste("package",c("MASS","nlme","lme4"),sep=":"),detach,character.only=TRUE)
</code></pre>

<hr>
<h2 id='narm'>Return an object with missing values removed.</h2><span id='topic+narm'></span>

<h3>Description</h3>

<p>Convenience function, removes NAs from most standard objects.
Uses function na.exclude for matrices and dataframes. 
Main difference to na.exlude is that it simply performs the 
transformation, without adding attributes
For unknown types, leaves unchanged with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>narm(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="narm_+3A_x">X</code></td>
<td>
<p>The object to remove NAs, any vector, matrix or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector minus NA's, or the matrix/data.frame minus NA rows.
If it's a character vector then values of &quot;NA&quot; will also be excluded
in addition to values = NA, so be careful if &quot;NA&quot; is a valid value
of your character vector. Note that &quot;NA&quot; values occur when 'paste(...,NA,...)' is
applied to a vector of any type, whereas 'as.character(...,NA,...)'
avoids this.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>narm(c(1,2,4,NA,5))
DF &lt;- data.frame(x = c(1, 2, 3), y = c(0, 10, NA))
DF; narm(DF)
# if a list, will only completely remove NA from the lowest levels
# empty places will be left at top levels
print(narm(list(1,2,3,NA,list(1,2,3,NA))))
</code></pre>

<hr>
<h2 id='NCmisc-internal'>Internal NCmisc Functions</h2><span id='topic+get.ext'></span><span id='topic+suck.bytes'></span><span id='topic+suck.mem'></span><span id='topic+suck.cpu'></span><span id='topic+suck.num.from.txt'></span><span id='topic+divide.top.txt'></span><span id='topic+make.top.tab'></span><span id='topic+make.divisor'></span><span id='topic+display.var'></span><span id='topic+cat.path'></span><span id='topic+dir.force.slash'></span><span id='topic+file.split.windows'></span><span id='topic+is.ch'></span><span id='topic+rmv.ext'></span><span id='topic+head2'></span><span id='topic+tools_read_repositories'></span><span id='topic+check.bio'></span><span id='topic+is.col.numeric'></span><span id='topic+i_numerify'></span><span id='topic+is.missing'></span><span id='topic+se.na'></span>

<h3>Description</h3>

<p>Internal NCmisc functions
</p>


<h3>Details</h3>

<p>These are not recommended/needed to be called by the user 
</p>

<hr>
<h2 id='nearest.to'>Select the nearest point in an array to a given value</h2><span id='topic+nearest.to'></span>

<h3>Description</h3>

<p>Similar to the base function match() but allows for data where you
won't find an exact match. Selects the nearest value from 'array' to the
value 'point'. Sometimes there are multiple points with equal distance
in which case choose from 3 possible 'dispute.method's for choosing
which of the equidistant array values to index.
returns the index of 'array' to which 'point' is nearest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest.to(array, point, dispute.method = c("first", "last", "random"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearest.to_+3A_array">array</code></td>
<td>
<p>a numeric vector or POSIXct vector of date-times.</p>
</td></tr>
<tr><td><code id="nearest.to_+3A_point">point</code></td>
<td>
<p>the value that you want to find the nearest point to.</p>
</td></tr>
<tr><td><code id="nearest.to_+3A_dispute.method">dispute.method</code></td>
<td>
<p>when there are equidistant values to 'point' in
array, choose either the first, last, or a random select, based
on the original order in 'array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index value of the nearest point in 'array'.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myArray &lt;- 1:100
nearest.to(myArray, 7.7)
nearest.to(myArray, 50.5)
nearest.to(myArray, 50.5, dispute.method="last")
</code></pre>

<hr>
<h2 id='Numerify'>Convert all possible columns of a data.frame to numeric</h2><span id='topic+Numerify'></span>

<h3>Description</h3>

<p>Importing data from csv files can often lead to numeric variables being
coded as factors or strings. This will not work well with many R functions.
This function provides a quick way to deal with this across a whole data frame
while attempting to leave columns untouched that are not genuinely numeric data.
In edge cases you might need to adjust 'threshold' to get the correct result,
usually an issue if mostly numeric columns often have strings amongst them, for
instance a column with mostly numbers, but occassionally pipe-separated values
like '4.4|5.0|6.1', etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Numerify(df, except = NULL, force = FALSE, digits = NA, thresh = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Numerify_+3A_df">df</code></td>
<td>
<p>data.frame to transform to numeric (where possible)</p>
</td></tr>
<tr><td><code id="Numerify_+3A_except">except</code></td>
<td>
<p>avoid changing any colnames in this array</p>
</td></tr>
<tr><td><code id="Numerify_+3A_force">force</code></td>
<td>
<p>force all columns to numeric without checking types</p>
</td></tr>
<tr><td><code id="Numerify_+3A_digits">digits</code></td>
<td>
<p>if a non-NA integer value is used, will round numeric columns
to this many decimal places after making numeric.</p>
</td></tr>
<tr><td><code id="Numerify_+3A_thresh">thresh</code></td>
<td>
<p>threshold to decide that a variable is numeric. NA values will
be ignored in the test. Then it looks at the proportion of values that are
successfully coerced to numeric without giving 'NA'. If this threshold is
0.9, then any column where at least 90
converted to numeric type, will be kept as numeric, else they will be left
as they were.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with numeric type for any applicable columns
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(first=c(1:5),
 second=paste(6:10),
 third=c("jake", "fred", "cathy", "sandra", "mike"))
sapply(sapply(df, is), "[", 1) # check type of each column
dfN &lt;- Numerify(df)
sapply(sapply(dfN, is), "[", 1) # now second column is numeric
df2 &lt;- data.frame(first=c(1:10),
 second=paste(c(NA, NA, 6:10, "5|6", "7|8", 1)),
 third=rep(c("jake", "fred", "cathy", "sandra", "mike"),2))
sapply(sapply(df2, is), "[", 1)
df2N1 &lt;- Numerify(df2, thresh=0.7)
df2N2 &lt;- Numerify(df2, thresh=0.8)
sapply(sapply(df2N1, is), "[", 1) # at this threshold second column goes to numeric
sapply(sapply(df2N2, is), "[", 1) # second column stays a string at this threshold
</code></pre>

<hr>
<h2 id='out.of'>Easily display fraction and percentages</h2><span id='topic+out.of'></span>

<h3>Description</h3>

<p>For a subset 'n' and total 'N', nicely prints text n/N and/or percentage
Often we want to display proportions and this simple function reduces the
required amount of code for fraction and percentage reporting. If 
insufficient digits are provided small percentage may truncate to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out.of(n, N = 100, digits = 2, pc = TRUE, oo = TRUE, use.sci = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="out.of_+3A_n">n</code></td>
<td>
<p>numeric, the count for the subset of N (the numerator)</p>
</td></tr>
<tr><td><code id="out.of_+3A_n">N</code></td>
<td>
<p>numeric, the total size of the full set (the denominator)</p>
</td></tr>
<tr><td><code id="out.of_+3A_digits">digits</code></td>
<td>
<p>integer, the number of digits to display in the percentage</p>
</td></tr>
<tr><td><code id="out.of_+3A_pc">pc</code></td>
<td>
<p>logical, whether to display the percentage of N that n comprises</p>
</td></tr>
<tr><td><code id="out.of_+3A_oo">oo</code></td>
<td>
<p>logical, whether to display n/N as a fraction</p>
</td></tr>
<tr><td><code id="out.of_+3A_use.sci">use.sci</code></td>
<td>
<p>logical, whether to allow scientific notation for small/large
percentages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string showing the fraction n/N and percentage (or just one of these)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out.of(345,12144)
out.of(345,12144,pc=FALSE)
out.of(3,10^6,digits=6,oo=FALSE)
out.of(3,10^6,digits=6,oo=FALSE,use.sci=TRUE)
</code></pre>

<hr>
<h2 id='p.to.Z'>Convert p-values to Z-scores</h2><span id='topic+p.to.Z'></span>

<h3>Description</h3>

<p>Simple conversion of two-tailed p-values to Z-scores. Written
in a way that allows maximum precision for small p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.to.Z(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.to.Z_+3A_p">p</code></td>
<td>
<p>p-values (between 0 and 1), numeric, scalar, vector or matrix, 
or other types coercible using as.numeric()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Z scores with the same dimension as the input
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Z.to.p">Z.to.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p.to.Z(0.0001)
p.to.Z("5E-8")
p.to.Z(c(".05",".01",".005"))
p.to.Z(matrix(runif(16),nrow=4))
</code></pre>

<hr>
<h2 id='packages.loaded'>Check whether a set of packages has been loaded</h2><span id='topic+packages.loaded'></span>

<h3>Description</h3>

<p>Returns TRUE if the whole set of packages entered has been loaded, or FALSE
otherwise. This can be useful when developing a package where there is optional
functionality depending if another package is in use (but the other package is
not part of 'depends' because it is not essential). Because 'require' cannot
be used within functions submitted as part of a CRAN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packages.loaded(pcks = "", ..., cran.check = FALSE, repos = getRepositories())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="packages.loaded_+3A_pcks">pcks</code></td>
<td>
<p>character, a package name, or vector of names, if left blank will return all loaded</p>
</td></tr>
<tr><td><code id="packages.loaded_+3A_...">...</code></td>
<td>
<p>further package names as character (same as entering via pcks, 
but avoids need for c() in pcks)</p>
</td></tr>
<tr><td><code id="packages.loaded_+3A_cran.check">cran.check</code></td>
<td>
<p>logical, in the case at least one package is not found, whether
to search CRAN and see whether the package(s) even exist on CRAN.</p>
</td></tr>
<tr><td><code id="packages.loaded_+3A_repos">repos</code></td>
<td>
<p>repository to use if package is not loaded and cran.check=TRUE,
if NULL, will attempt to use the repository in getOptions(&quot;repos&quot;) or will
default to the imperial.ac.uk mirror. Otherwise the default is to use
all available repositories from getRepositories()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE or FALSE whether the whole list of packages are available
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>packages.loaded("NCmisc","reader")
packages.loaded() # no argument means all loaded packages are listed
</code></pre>

<hr>
<h2 id='pad.left'>Print a vector with appropriate padding so each has equal char length.</h2><span id='topic+pad.left'></span>

<h3>Description</h3>

<p>Print a vector with appropriate padding so each has equal char length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad.left(X, char = " ", numdigits = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pad.left_+3A_x">X</code></td>
<td>
<p>vector of data to pad to equal length</p>
</td></tr>
<tr><td><code id="pad.left_+3A_char">char</code></td>
<td>
<p>character to pad with, space is default, but zero might
be a desirable choice for padding numbers</p>
</td></tr>
<tr><td><code id="pad.left_+3A_numdigits">numdigits</code></td>
<td>
<p>if using numeric data, the number of digits to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the vector in character format with equal nchar()
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad.left(1:10)
phone.numbers &lt;- c("07429719234","7876345123","7123543765")
pad.left(phone.numbers,"0")
pad.left(rnorm(10),numdigits=3)
</code></pre>

<hr>
<h2 id='pctile'>Find data thresholds corresponding to percentiles</h2><span id='topic+pctile'></span>

<h3>Description</h3>

<p>Finds the top and bottom bounds corresponding to percentile
'pc' of the data 'dat'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pctile(dat, pc = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pctile_+3A_dat">dat</code></td>
<td>
<p>numeric vector of data</p>
</td></tr>
<tr><td><code id="pctile_+3A_pc">pc</code></td>
<td>
<p>the percentile to seek, c(pc, 1-pc)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the upper and lower threshold
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pctile(rnorm(100000),.025)
pctile(sample(100),.9)
</code></pre>

<hr>
<h2 id='ppa'>Posterior probability of association function</h2><span id='topic+ppa'></span>

<h3>Description</h3>

<p>Estimate the probability of your hypothesis being true,
given the observed p-value and a prior probability of
the hypothesis being true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppa(p = 0.05, prior = 0.5, BF = NULL, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppa_+3A_p">p</code></td>
<td>
<p>p-value you want to test [p&lt;0.367], or 'bayes factor'</p>
</td></tr>
<tr><td><code id="ppa_+3A_prior">prior</code></td>
<td>
<p>prior odds for the hypothesis (Ha) being tested</p>
</td></tr>
<tr><td><code id="ppa_+3A_bf">BF</code></td>
<td>
<p>logical, set to TRUE if you have entered a bayes factor
as 'p' rather than a p-value</p>
</td></tr>
<tr><td><code id="ppa_+3A_quiet">quiet</code></td>
<td>
<p>logical, whether to display verbose information for
calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints calculations, then returns the posterior 
probability of association given the observed p-value 
under the specified prior
</p>


<h3>References</h3>

<p>Equations 1, 2 from
http://www.readcube.com/articles/10.1038/nrg2615
Equations 2, 3 from
http://www.tandfonline.com/doi/pdf/10.1198/000313001300339950
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ps &lt;- rep(c(.05,.01),3)
prs &lt;- rep(c(.05,.50,.90),each=2)
mapply(ps,prs,FUN=ppa)  # replicate Nuzzo 2014 table
# try with bayes factors
ppa(BF=3,prior=.9)
ppa(BF=10,prior=.5)
</code></pre>

<hr>
<h2 id='preview'>Output variable states within functions during testing/debugging</h2><span id='topic+preview'></span>

<h3>Description</h3>

<p>A versatile function to compactly display most common R objects. Will
return the object name, type, dimension, and a compact representation of
object contents, for instance using prv.large() to display matrices,
so as to not overload the console for large objects. Useful for debugging,
can be placed inside loops and functions to track values, dimensions, and data types.
Particularly when debugging complex code, the automatic display of the variable name
prevents confusion versus using regular print statements.
By listing variables to track as character(), provides 'cat()' output 
of compact and informative variable state information, e.g, variable name, value,
datatype and dimension. Can also specify array or list elements, or custom labels.
prv() is the same as preview() except it can take objects without using double quotes
and has no 'labels' command (and doesn't need one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview(
  varlist,
  labels = NULL,
  counts = NULL,
  assume.char = FALSE,
  prv.call = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preview_+3A_varlist">varlist</code></td>
<td>
<p>character vector, the list of variable(s) to report, which will trigger
automatic labelling of the variable name, otherwise if entered as the variable value (ie.
without quotes, then will by default be displayed as 'unknown variable')</p>
</td></tr>
<tr><td><code id="preview_+3A_labels">labels</code></td>
<td>
<p>will label 'unknown variables' (see above) if entered as variables without quotes</p>
</td></tr>
<tr><td><code id="preview_+3A_counts">counts</code></td>
<td>
<p>a list of array index values; so if calling during a counting loop, the
value can be reported each iteration, also printing the count index; if the list is
named the name will also appear, e.g, variable[count=1]. This list must be the same
length as varlist (and labels if not NULL), and each element [[i]] must contain as many values
as the original corresponding varlist[i] has dimensions. The dimensions must result in a 1x1 scalar</p>
</td></tr>
<tr><td><code id="preview_+3A_assume.char">assume.char</code></td>
<td>
<p>usually 'varlist' is a character vector of variable names, but in the case
that it is actually a character variable, using assume.char=TRUE will ensure that it will be assumed
the character variable is the object to preview, rather than a list of variable names. So long
as none of the values are found to be variable names in the global environment. preview() can
also find variables in local environments, and if this is where the target variable lies, it is
best to use assume.char=FALSE, otherwise the search for alternative environments might not happen.
Note that in most cases the automatic detection of the input should understand what you want, regardless
of the value of assume.char.</p>
</td></tr>
<tr><td><code id="preview_+3A_prv.call">prv.call</code></td>
<td>
<p>It is recommended to always leave this argument as FALSE when calling preview()
directly. If set to TRUE, it will first search 2 generations back for the parent frame, instead 
of one, as it will assume that the variable(s) to preview are not directly called by preview(),
but through a wrapper for preview, such as prv().</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Dim">Dim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create variables of different types to show output styles #
testvar1 &lt;- 193
testvar2 &lt;- "Atol"
testvar3 &lt;- c(1:10)
testvar4 &lt;- matrix(rnorm(100),nrow=25)
testvar5 &lt;- list(first="test",second=testvar4,third=100:110)
preview("testvar1")
preview("testvar4")
preview(paste("testvar",1:5,sep=""))
preview(testvar1,"myvarname")
preview(testvar1)
# examples with loops and multiple dimensions / lists
for (cc in 1:4) {
 for (dd in 1:4) { preview("testvar4",counts=list(cc,dd)) }}

for (dd in 1:3) { preview("testvar5",counts=list(dd=dd)) }
</code></pre>

<hr>
<h2 id='prv'>Output variable states within functions/loops during testing/debugging</h2><span id='topic+prv'></span>

<h3>Description</h3>

<p>Same as preview but no labels command, and input is without quotes
and should be plain variable names of existing variables (no indices, args, etc)
A versatile function to compactly display most common R objects. Will
return the object name, type, dimension, and a compact representation of
object contents, for instance using prv.large() to display matrices,
so as to not overload the console for large objects. Useful for debugging,
can be placed inside loops and functions to track values, dimensions, and data types.
Particularly when debugging complex code, the automatic display of the variable name
prevents confusion versus using regular print statements.
By listing variables to track as character(), provides 'cat()' output 
of compact and informative variable state information, e.g, variable name, value,
datatype and dimension. Can also specify array or list elements, or custom labels.
prv() is the same as preview() except it can take objects without using double quotes
and has no 'labels' command (and doesn't need one). If expressions are entered rather
than variable names, then prv() will attempt to pass the arguments to preview().
prv() assumes that the variable(s) to report originate from the environment calling
prv(), and if not found there, then it will search through all accessible environments
starting with the global environment, and then will report the first instance found,
which in exceptional circumstances (be warned) may not be the instance you intended
to retrieve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prv(..., counts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prv_+3A_...">...</code></td>
<td>
<p>series of variable(s) to report, separated by commas, which will trigger
automatic labelling of the variable name</p>
</td></tr>
<tr><td><code id="prv_+3A_counts">counts</code></td>
<td>
<p>a list of array index values; so if calling during a counting loop, the
value can be reported each iteration, also printing the count index; if the list is
named the name will also appear, e.g, variable[count=1]. This list must be the same
length as the variable list ... , and each element [[i]] must contain as many values
as the original corresponding variable list[i] has dimensions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Dim">Dim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create variables of different types to show output styles #
testvar1 &lt;- 193
testvar2 &lt;- "Atol"
testvar3 &lt;- c(1:10)
testvar4 &lt;- matrix(rnorm(100),nrow=25)
testvar5 &lt;- list(first="test",second=testvar4,third=100:110)
preview("testvar1"); prv(testvar1)
prv(testvar1,testvar2,testvar3,testvar4)
prv(matrix(rnorm(100),nrow=25)) # expression sent to preview() with no label
prv(193) # fails as there are no object names involved
</code></pre>

<hr>
<h2 id='prv.large'>Tidy display function for matrix objects</h2><span id='topic+prv.large'></span>

<h3>Description</h3>

<p>This function prints the first and last columns and rows of a matrix, and
more, if desired. Allows previewing of a matrix without 
overloading the console. Most useful when data has row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prv.large(
  largeMat,
  rows = 3,
  cols = 2,
  digits = 4,
  rL = "Row#",
  rlab = "rownames",
  clab = "colnames",
  rownums = T,
  ret = FALSE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prv.large_+3A_largemat">largeMat</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="prv.large_+3A_rows">rows</code></td>
<td>
<p>number of rows to display</p>
</td></tr>
<tr><td><code id="prv.large_+3A_cols">cols</code></td>
<td>
<p>number of columns to display</p>
</td></tr>
<tr><td><code id="prv.large_+3A_digits">digits</code></td>
<td>
<p>number of digits to display for numeric data</p>
</td></tr>
<tr><td><code id="prv.large_+3A_rl">rL</code></td>
<td>
<p>row label to describe the row names/numbers, e.g, row number, ID, etc</p>
</td></tr>
<tr><td><code id="prv.large_+3A_rlab">rlab</code></td>
<td>
<p>label to describe the data rows</p>
</td></tr>
<tr><td><code id="prv.large_+3A_clab">clab</code></td>
<td>
<p>label to describe the data columns</p>
</td></tr>
<tr><td><code id="prv.large_+3A_rownums">rownums</code></td>
<td>
<p>logical, whether to display rownumbers or ignore them</p>
</td></tr>
<tr><td><code id="prv.large_+3A_ret">ret</code></td>
<td>
<p>logical, whether to return the result as a formatted object, or just print to console</p>
</td></tr>
<tr><td><code id="prv.large_+3A_warn">warn</code></td>
<td>
<p>logical, whether to warn if the object type is not supported</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(1000),nrow=50)
rownames(mat) &lt;- paste("ID",1:50,sep="")
colnames(mat) &lt;- paste("Var",1:20,sep="")
prv.large(mat)
prv.large(mat,rows=9,cols=4,digits=1,rlab="samples",clab="variables",rownums=FALSE)
</code></pre>

<hr>
<h2 id='replace.missing.df'>Iterate through numeric columns of a dataframe and replace missing with the mean</h2><span id='topic+replace.missing.df'></span>

<h3>Description</h3>

<p>To simple replace missing data without changing column means.
This will also use criteria to decide whether each column is numeric,
so that illegal operations aren't performed on strings, etc.
Also adjusting the 'error' parameter allows adding variance to the
missing observations to help to reduce bias associated with inserting
many of the same replacement value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.missing.df(
  X,
  repl.fun = mean,
  error = 0,
  thresh = 0.9,
  digits = 99,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace.missing.df_+3A_x">X</code></td>
<td>
<p>a data.frame to replace missing values in</p>
</td></tr>
<tr><td><code id="replace.missing.df_+3A_repl.fun">repl.fun</code></td>
<td>
<p>the function to perform the replacement. Default
is 'mean'. A replacement should take a vector 'x' and produce a
single scalar as a result.</p>
</td></tr>
<tr><td><code id="replace.missing.df_+3A_error">error</code></td>
<td>
<p>default value is 0, meaning replacements will be all
the same value for each column of the data.frame X. If you give
a positive value, this amount of gaussian noise (in StDev units of
the original variable) will be added to the replacement values.</p>
</td></tr>
<tr><td><code id="replace.missing.df_+3A_thresh">thresh</code></td>
<td>
<p>passed to function 'is.vec.numeric', see explanation there.</p>
</td></tr>
<tr><td><code id="replace.missing.df_+3A_digits">digits</code></td>
<td>
<p>Trim replacement values to this many digits</p>
</td></tr>
<tr><td><code id="replace.missing.df_+3A_force">force</code></td>
<td>
<p>TRUE means replace missing for all columns with testing for numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.frame with the same dimensions with missing
values for numeric values imputed using the repl.fun function,
optionally with noise added.
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(first=c(1,2,NA,4,5),
  second=paste(c(6,7,8,NA,10)),
  third=c("jake", "fred", "cathy", "sandra", "mike"))
df
replace.missing.df(df)
replace.missing.df(df, force=TRUE)
df2 &lt;- data.frame(first=c(1:5, NA, NA, NA,9, 10),
  second=paste(c(NA, NA, 6:10, "5|6", "7|8", 1)),
  third=rep(c("jake", "fred", "cathy", "sandra", "mike"),2))
df2
replace.missing.df(df2)
replace.missing.df(df2, thresh=0.7)
replace.missing.df(df2, error = 1, thresh=0.7, digits=4)
</code></pre>

<hr>
<h2 id='Rfile.index'>Create an index file for an R function file</h2><span id='topic+Rfile.index'></span>

<h3>Description</h3>

<p>Create a html index for an R function file by looking for functions,
add descriptions using comments directly next to the function()
command. Note that if too much code other than well-formatted
functions is in the file then the result is likely not to be
a nicely formatted index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rfile.index(fn, below = TRUE, fn.out = "out.htm", skip.indent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rfile.index_+3A_fn">fn</code></td>
<td>
<p>an R file containing functions in standard R script</p>
</td></tr>
<tr><td><code id="Rfile.index_+3A_below">below</code></td>
<td>
<p>whether to search for comment text below or above
the function() calls</p>
</td></tr>
<tr><td><code id="Rfile.index_+3A_fn.out">fn.out</code></td>
<td>
<p>optional name for the output file, else will be 
based on the name of the input file</p>
</td></tr>
<tr><td><code id="Rfile.index_+3A_skip.indent">skip.indent</code></td>
<td>
<p>whether to skip functions that are indented,
the assumption being they are functions within functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates an html file with name and description of each function
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.functions.in.file">list.functions.in.file</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run:  rfile &lt;- file.choose() # choose an R script file with functions
# not run:  out &lt;- Rfile.index(rfile,fn.out="temp.htm")
# unlink("temp.htm") # run once you've inspected this file in a browser
</code></pre>

<hr>
<h2 id='rmv.names'>Remove names from a named vector or list</h2><span id='topic+rmv.names'></span>

<h3>Description</h3>

<p>Convenience function, it's very easy to set names to NULL, but
this requires a dedicated line of code. Using this function
can make your code simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmv.names(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmv.names_+3A_x">X</code></td>
<td>
<p>object for which you want to remove name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original object but without names
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(boo=1, hiss=2)
rmv.names(x)
X &lt;- list(testing=c(1,2,3), thankyou=TRUE)
rmv.names(X)
</code></pre>

<hr>
<h2 id='rmv.spc'>Remove leading and trailing spaces (or other character).</h2><span id='topic+rmv.spc'></span>

<h3>Description</h3>

<p>Remove leading and trailing spaces (or other character).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmv.spc(str, before = TRUE, after = TRUE, char = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmv.spc_+3A_str">str</code></td>
<td>
<p>character vector, may containing leading or trailing chars</p>
</td></tr>
<tr><td><code id="rmv.spc_+3A_before">before</code></td>
<td>
<p>logical, whether to remove leading spaces</p>
</td></tr>
<tr><td><code id="rmv.spc_+3A_after">after</code></td>
<td>
<p>logical, whether to remove trailing spaces</p>
</td></tr>
<tr><td><code id="rmv.spc_+3A_char">char</code></td>
<td>
<p>an alternative character to be removed instead of spaces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vectors without the leading/trailing characters
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spc">spc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmv.spc("  mid sentence  ")
rmv.spc("0012300",after=FALSE,char="0")
rmv.spc(" change nothing ",after=FALSE,before=FALSE)
</code></pre>

<hr>
<h2 id='search.cran'>Search all CRAN packages for those containing keyword(s).</h2><span id='topic+search.cran'></span>

<h3>Description</h3>

<p>Can be useful for trying to find new packages for a particular
purpose. No need for these packages to be installed or loaded.
Further searching can be done using utils::RSiteSearch()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.cran(txt, repos = "", all.repos = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search.cran_+3A_txt">txt</code></td>
<td>
<p>text to search for, a character vector, not case-sensitive</p>
</td></tr>
<tr><td><code id="search.cran_+3A_repos">repos</code></td>
<td>
<p>repository(s) (CRAN mirror) to use, &quot;&quot; defaults to getOption(&quot;repos&quot;)</p>
</td></tr>
<tr><td><code id="search.cran_+3A_all.repos">all.repos</code></td>
<td>
<p>logical, if TRUE, then use all available repositories from getRepositories()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of hits for each keyword (txt)
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## not run # repos &lt;- "http://cran.ma.imperial.ac.uk/" # OR: repos &lt;- getOption("repos")
## not run # search.cran("draw")
## not run # search.cran(c("hmm", "markov", "hidden"))
</code></pre>

<hr>
<h2 id='sim.cor'>Simulate a dataset with correlated measures</h2><span id='topic+sim.cor'></span>

<h3>Description</h3>

<p>Simulate a dataset with correlated measures (normal simulation with e.g, rnorm() usually
only gives small randomly distributed correlations between variables). This is a quick
and unsophisticated method, but should be able to provide a dataset with slightly more
realistic structure than simple rnorm() type functions. Varying the last three parameters
gives some control on the way the data is generated. It starts with a seed random variable,
then creates 'k' random variables with an expected correlation of r=genr() with that seed 
variable. Then after this, one of the variables in the set (including the seed) is randomly
selected to run through the same process of generating 'k' new variables; this is repeated
until columns are full up. 'mix.order' then randomizes the column order destroying the
relationship between column number and correlation structure, although in some cases,
such relationships might be desired as representative of some real life datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cor(
  nrow = 100,
  ncol = 100,
  genx = rnorm,
  genr = runif,
  k = 3,
  mix.order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cor_+3A_nrow">nrow</code></td>
<td>
<p>integer, number of rows to simulate</p>
</td></tr>
<tr><td><code id="sim.cor_+3A_ncol">ncol</code></td>
<td>
<p>integer, number of columns to simulate</p>
</td></tr>
<tr><td><code id="sim.cor_+3A_genx">genx</code></td>
<td>
<p>the generating function for data, e.g rnorm(), runif(), etc</p>
</td></tr>
<tr><td><code id="sim.cor_+3A_genr">genr</code></td>
<td>
<p>the generating function for desired correlation, e.g, runif()</p>
</td></tr>
<tr><td><code id="sim.cor_+3A_k">k</code></td>
<td>
<p>number of steps generating from the same seed before choosing a new seed</p>
</td></tr>
<tr><td><code id="sim.cor_+3A_mix.order">mix.order</code></td>
<td>
<p>whether to randomize the column order after simulating</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor.with">cor.with</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corDat &lt;- sim.cor(200,5)
prv(corDat) # preview of simulated normal data with r uniformly varying
cor(corDat) # correlation matrix
corDat &lt;- sim.cor(500,4,genx=runif,genr=function(x) { 0.5 },mix.order=FALSE)
prv(corDat) # preview of simulated uniform data with r fixed at 0.5
cor(corDat) # correlation matrix
</code></pre>

<hr>
<h2 id='simple.date'>Simple representation and retrieval of Date/Time</h2><span id='topic+simple.date'></span>

<h3>Description</h3>

<p>Retrieve a simple representation of date_time or just date, 
for generating day/time specific file names, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.date(sep = "_", long = FALSE, time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple.date_+3A_sep">sep</code></td>
<td>
<p>character, separator to use for the date/time, eg, 
underscore or &lt;space&gt; &quot; &quot;.</p>
</td></tr>
<tr><td><code id="simple.date_+3A_long">long</code></td>
<td>
<p>logical, whether to display a longer version of the
date and time, or just a simple version</p>
</td></tr>
<tr><td><code id="simple.date_+3A_time">time</code></td>
<td>
<p>logical, whether to include the time, or just the date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the date: MMMDD and optionally time HRam/pm.
Or if long=TRUE, a longer representation: DAY MM DD HH.MM.SS YYYY.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simple.date()
simple.date(" ",long=TRUE)
simple.date(time=FALSE)
</code></pre>

<hr>
<h2 id='spc'>Print a character a specified number of times.</h2><span id='topic+spc'></span>

<h3>Description</h3>

<p>Returns 'char' X_i number of times for each element i of X.
Useful for padding for alignment purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc(X, char = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spc_+3A_x">X</code></td>
<td>
<p>numeric vector of number of repeats</p>
</td></tr>
<tr><td><code id="spc_+3A_char">char</code></td>
<td>
<p>The character to repeat (longer will be shortened)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vectors of strings of char, lengths X
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmv.spc">rmv.spc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(paste(spc(9),"123\n"))
cat(paste(spc(8),"1234\n"))
spc(c(1:5),".")
</code></pre>

<hr>
<h2 id='standardize'>Convert a numeric vector to Z-scores.</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Transform a vector to z scores by subtracting its mean
and dividing by its standard deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_+3A_x">X</code></td>
<td>
<p>numeric vector to standardize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the same length in standardised form
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(10,100,15); x2 &lt;- sample(10)
print(x1) ;  standardize(x1)
print(x2) ;  standardize(x2)
</code></pre>

<hr>
<h2 id='Substitute'>Convert objects as arguments to object names</h2><span id='topic+Substitute'></span>

<h3>Description</h3>

<p>Equivalent to the base function substitute() but can do any length of arguments instead
of just one. Converts the objects in parentheses into text arguments as if they
had been entered with double quote strings. The objects must exist and be accessible in
the environment the function is called from for the function to work (same as for substitute()).
One application for this is to be able to create functions where object arguments can be
entered without quotation marks (simpler), or where you want to use the name of the object
as well as the data in the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Substitute(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Substitute_+3A_x">x</code></td>
<td>
<p>compulsory, simply the first object in the list, no difference to any further objects</p>
</td></tr>
<tr><td><code id="Substitute_+3A_...">...</code></td>
<td>
<p>any further objects to return string names for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character list of x,... object names
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prv">prv</a></code>, <code><a href="#topic+preview">preview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myvar &lt;- list(test=c(1,2,3)); var2 &lt;- "testme"; var3 &lt;- 10:14
print(myvar)
# single variable case, equivalent to base::substitute()
print(substitute(myvar))
print(Substitute(myvar))
# multi variable case, substitute won't work
Substitute(myvar,var2,var3)
# prv() is a wrapper for preview() allowing arguments without parentheses
# which is achieved internally by passing the arguments to Substitute()
preview(c("myvar","var2","var3"))
prv(myvar,var2,var3)
</code></pre>

<hr>
<h2 id='summarise.r.datasets'>Summarise the dimensions and type of available R example datasets</h2><span id='topic+summarise.r.datasets'></span>

<h3>Description</h3>

<p>This function will parse the current workspace to see what R datasets
are available. Using the toHTML function from the 'tools' package to interpret
the data() call, each dataset is examined in turn for type and dimensionality.
Can also use a filter for dataset types, to only show, for instance, matrix 
datasets. Also you can specify whether to only look for base datasets, or to
search for datasets in all available packages. Result is a printout to the
console of the available datasets and their characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise.r.datasets(
  filter = FALSE,
  types = c("data.frame", "matrix"),
  all = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.r.datasets_+3A_filter">filter</code></td>
<td>
<p>logical, whether to filter datasets by 'types'</p>
</td></tr>
<tr><td><code id="summarise.r.datasets_+3A_types">types</code></td>
<td>
<p>if filter=TRUE, which data types to include in the result</p>
</td></tr>
<tr><td><code id="summarise.r.datasets_+3A_all">all</code></td>
<td>
<p>logical, if all=TRUE, look for datasets in all available packages, else just base</p>
</td></tr>
<tr><td><code id="summarise.r.datasets_+3A_...">...</code></td>
<td>
<p>if all is false, further arguments to the data() function to search datasets</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summarise.r.datasets()
summarise.r.datasets(filter=TRUE,"matrix")
</code></pre>

<hr>
<h2 id='summary2'>Descriptive summary with SD/SE + improved formatting</h2><span id='topic+summary2'></span>

<h3>Description</h3>

<p>Wrapper for the base function summary() but adds standard deviation,
standard error, and an 'N' and missing 'NA' count that are consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary2(x, digits = NULL, neaten.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary2_+3A_x">x</code></td>
<td>
<p>vector of numeric data</p>
</td></tr>
<tr><td><code id="summary2_+3A_digits">digits</code></td>
<td>
<p>number of digits to round resulting values to</p>
</td></tr>
<tr><td><code id="summary2_+3A_neaten.names">neaten.names</code></td>
<td>
<p>logical, TRUE removes period and space from names
of the results returned by summary() to make the names better for
use in a data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of descriptive statistics for x
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
summary2(x, digits=2)
summary2(c(x, NA, NA), digits=2)
</code></pre>

<hr>
<h2 id='table2d'>Wrapper for the base table() function that includes
zero counts - useful to get consistent dimensions across
multiple runs with different responding patterns
Forces a 2d table with every possible cell (allow zero counts)
Only for tables where there are two vectors entered, while
the base function allows for more, or also allows just 1.
If the wrong arguments are entered, attempts to pass the input
to the base version of 'table' instead.</h2><span id='topic+table2d'></span>

<h3>Description</h3>

<p>Wrapper for the base table() function that includes
zero counts - useful to get consistent dimensions across
multiple runs with different responding patterns
Forces a 2d table with every possible cell (allow zero counts)
Only for tables where there are two vectors entered, while
the base function allows for more, or also allows just 1.
If the wrong arguments are entered, attempts to pass the input
to the base version of 'table' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table2d(
  ...,
  col,
  row,
  rn = NULL,
  cn = NULL,
  use.order = TRUE,
  remove.na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table2d_+3A_...">...</code></td>
<td>
<p>vector arguments, see input for base:table() function</p>
</td></tr>
<tr><td><code id="table2d_+3A_col">col</code></td>
<td>
<p>categories to include as columns of the table</p>
</td></tr>
<tr><td><code id="table2d_+3A_row">row</code></td>
<td>
<p>categories to include as rows of the table</p>
</td></tr>
<tr><td><code id="table2d_+3A_rn">rn</code></td>
<td>
<p>optionally replace the raw value names with desired row names.
Must be same length as 'row'.</p>
</td></tr>
<tr><td><code id="table2d_+3A_cn">cn</code></td>
<td>
<p>optionally replace the raw value names with desired column names.
Must be same length as 'col'.</p>
</td></tr>
<tr><td><code id="table2d_+3A_use.order">use.order</code></td>
<td>
<p>TRUE to use the order in 'col' and 'row' for table, otherwise
use the default order of table() - which is usually alphabetical</p>
</td></tr>
<tr><td><code id="table2d_+3A_remove.na">remove.na</code></td>
<td>
<p>remove NA values from row/col if present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a table, just like the base:table() function
but the row and column names are fixed regardless of count
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nm &lt;- c("Mike", "Anna", "John", "Tony")
vec_r &lt;- sample(tolower(nm)[c(1,3,4)], 50, replace=TRUE)
vec_c &lt;- sample(c(1,2,4,5), 50, replace=TRUE)
table(vec_r, vec_c)
table2d(vec_r, vec_c, row=tolower(nm), col=paste(1:5))
table2d(vec_r, vec_c, row=tolower(nm), col=paste(1:5), use.order = FALSE)
table2d(vec_r, vec_c, row=tolower(nm), col=paste(1:5), rn=nm, cn=c("I", "II", "III", "IV", "V"))
</code></pre>

<hr>
<h2 id='textogram'>Make an ascii histogram in the console.</h2><span id='topic+textogram'></span>

<h3>Description</h3>

<p>Uses a call to base::hist(...) and uses the densities to make a
a text histogram in the console
Particularly useful when working in the terminal without graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textogram(X, range = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="textogram_+3A_x">X</code></td>
<td>
<p>numeric vector of data</p>
</td></tr>
<tr><td><code id="textogram_+3A_range">range</code></td>
<td>
<p>optional sub-range of X to test; c(low,high)</p>
</td></tr>
<tr><td><code id="textogram_+3A_...">...</code></td>
<td>
<p>additional arguments passed to base::hist()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs an ascii histogram to the console
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>textogram(runif(100000))
textogram(rnorm(10000),range=c(-3,3))
</code></pre>

<hr>
<h2 id='timeit'>Times an expression, with breakdown of time spent in each function
!DEPRECATED October 14, 2022!</h2><span id='topic+timeit'></span>

<h3>Description</h3>

<p>A wrapper for the proftools package Rprof() function.
It is to Rprof() as system.time() is to proc.time() (base)
Useful for identifying which functions are taking the
most time. This procedure will return an error unless
expr takes more than ~0.1 seconds to evaluate. I 
could not see any simple way to avoid this limitation. Occassionally
other errors are produced for no apparent reason which are due
to issues within the proftools package that are out of my
control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeit(expr, suppressResult = F, total.time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeit_+3A_expr">expr</code></td>
<td>
<p>an expression, must take at least 1 second (roughly)</p>
</td></tr>
<tr><td><code id="timeit_+3A_suppressresult">suppressResult</code></td>
<td>
<p>logical, if true, will return timing 
information rather than the result of expr</p>
</td></tr>
<tr><td><code id="timeit_+3A_total.time">total.time</code></td>
<td>
<p>to sort by total.time, else by self.time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns matrix where rows are function names, and columns
are self.time and total.time. total.time is total time spent 
in that function, including function calls made by that function.
self.time doesn't count other functions within a function
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function writes and removes a temporary file
# run only if ok to do this in your temporary directory
#not run# timeit(wait(0.1,"s") ,total.time=TRUE)
#not run# timeit(wait(0.1,"s") ,total.time=FALSE)
</code></pre>

<hr>
<h2 id='toheader'>Return a string with each first letter of each word in upper case.</h2><span id='topic+toheader'></span>

<h3>Description</h3>

<p>Return a string with each first letter of each word in upper case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toheader(txt, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toheader_+3A_txt">txt</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code id="toheader_+3A_strict">strict</code></td>
<td>
<p>whether to force non-leading letters to lowercase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector minus NA's, or the matrix/data.frame minus NA rows
</p>


<h3>Author(s)</h3>

<p>via R Core
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toheader(c("using AIC for model selection"))
toheader(c("using AIC", "for MODEL selection"), strict=TRUE)
</code></pre>

<hr>
<h2 id='top'>Monitor CPU, RAM and Processes</h2><span id='topic+top'></span>

<h3>Description</h3>

<p>This function runs the unix 'top' command and returns the overall CPU and RAM usage,
and optionally the table of processes and resource use for each. Works only with
unix-based systems such as Mac OS X and Linux, where 'top' is installed. Default
is to return CPU and RAM overall stats, to get detailed stats instead, set Table=TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top(
  CPU = !Table,
  RAM = !Table,
  Table = FALSE,
  procs = 20,
  mem.key = NULL,
  cpu.key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_+3A_cpu">CPU</code></td>
<td>
<p>logical, whether to return overall CPU usage information</p>
</td></tr>
<tr><td><code id="top_+3A_ram">RAM</code></td>
<td>
<p>logical, whether to return overall RAM usage information</p>
</td></tr>
<tr><td><code id="top_+3A_table">Table</code></td>
<td>
<p>logical, whether to return system information for separate processes. This
is returned as table with all of the same columns as a command line 'top' command. If
'Table=TRUE' is set, then the default becomes not to return the overall CPU/RAM usage stats.
The dataframe returned will have been sorted by descending memory usage.</p>
</td></tr>
<tr><td><code id="top_+3A_procs">procs</code></td>
<td>
<p>integer, if Table=TRUE, then the maximum number of processes to return (default 20)</p>
</td></tr>
<tr><td><code id="top_+3A_mem.key">mem.key</code></td>
<td>
<p>character, default for Linux is 'mem' and for Mac OS X, 'physmem', but if the 'top'
command on your system displays memory usage using a different label, then enter it here
(case insensitive) to override defaults.</p>
</td></tr>
<tr><td><code id="top_+3A_cpu.key">cpu.key</code></td>
<td>
<p>character, default for Linux and Mac OS X is 'cpu', but if the top
command on your system displays CPU usage using a different label, then enter it here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing CPU and RAM usage, or with alternate parameters can return stats for each process
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run #  top()
# not run #  top(Table=TRUE,proc=5)
</code></pre>

<hr>
<h2 id='Unlist'>Unlist a list, starting only from a set depth.</h2><span id='topic+Unlist'></span>

<h3>Description</h3>

<p>Allows unlisting preserving the top levels of a list.
Can specify the number of list depth levels to skip 
before running unlist()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unlist(obj, depth = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unlist_+3A_obj">obj</code></td>
<td>
<p>the list to unlist</p>
</td></tr>
<tr><td><code id="Unlist_+3A_depth">depth</code></td>
<td>
<p>skip to what layer of the list before unlisting; eg.
the base unlist() function would correspond to depth=0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns vectors of strings of char, lengths X
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>complex.list &lt;- list(1,1:3,list(2,2:4,list(3,3:4,list(10))),list(4,5:7,list(3)))
Unlist(complex.list,0) # equivalent to unlist()
Unlist(complex.list,1) # unlist within the top level lists
Unlist(complex.list,2) # unlist within the second level lists
Unlist(complex.list,10) # once depth &gt;= list-depth, no difference
unlist(complex.list,recursive=FALSE) # not the same as any of the above
</code></pre>

<hr>
<h2 id='wait'>Wait for a period of time.</h2><span id='topic+wait'></span>

<h3>Description</h3>

<p>Waits a number of hours minutes or seconds (doing nothing).
Note that this 'waiting' will use 100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait(dur, unit = "s", silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wait_+3A_dur">dur</code></td>
<td>
<p>waiting time</p>
</td></tr>
<tr><td><code id="wait_+3A_unit">unit</code></td>
<td>
<p>time units h/m/s, seconds are the default</p>
</td></tr>
<tr><td><code id="wait_+3A_silent">silent</code></td>
<td>
<p>print text showing that waiting is in progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wait(.25,silent=FALSE) # wait 0.25 seconds
wait(0.005, "m")
wait(0.0001, "Hours", silent=FALSE)
</code></pre>

<hr>
<h2 id='which.outlier'>Return vector indexes of statistical univariate outliers</h2><span id='topic+which.outlier'></span>

<h3>Description</h3>

<p>Performs simplistic outlier detection and returns indexes for outliers.
Acts like the which() function, return indices of elements of a vector
satisfying the condition, which by default are outliers exceeding 2 SD
above or below the mean. However, the threshold can be specified, only
high or low values can be considered outliers, and percentile and interquartile
range thresholds can also be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.outlier(
  x,
  thr = 2,
  method = c("sd", "iq", "pc"),
  high = TRUE,
  low = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.outlier_+3A_x">x</code></td>
<td>
<p>numeric, or coercible, the vector to test for outliers</p>
</td></tr>
<tr><td><code id="which.outlier_+3A_thr">thr</code></td>
<td>
<p>numeric, threshold for cutoff, e.g, when method=&quot;sd&quot;, standard deviations,
when 'iq', interquartile ranges (thr=1.5 is most typical here), or when 'pc', you might
select the extreme 1%, 5%, etc.</p>
</td></tr>
<tr><td><code id="which.outlier_+3A_method">method</code></td>
<td>
<p>character, one of &quot;sd&quot;,&quot;iq&quot; or &quot;pc&quot;, selecting whether to test for outliers
by standard deviation, interquartile range, or percentile.</p>
</td></tr>
<tr><td><code id="which.outlier_+3A_high">high</code></td>
<td>
<p>logical, whether to test for outliers greater than the mean</p>
</td></tr>
<tr><td><code id="which.outlier_+3A_low">low</code></td>
<td>
<p>logical, whether to test for outliers less than the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>indexes of the vector x that are outliers according to either
a SD cutoff, interquartile range, or percentile threshold, above (high) and/or
below (low) the mean/median.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.vec &lt;- rnorm(200)
summary(test.vec)
ii &lt;- which.outlier(test.vec) # 2 SD outliers
prv(ii); vals &lt;- test.vec[ii]; prv(vals)
ii &lt;- which.outlier(test.vec,1.5,"iq") # e.g, 'stars' on a box-plot
prv(ii)
ii &lt;- which.outlier(test.vec,5,"pc",low=FALSE) # only outliers &gt;mean
prv(ii)
</code></pre>

<hr>
<h2 id='Z.to.p'>Convert Z-scores to p-values</h2><span id='topic+Z.to.p'></span>

<h3>Description</h3>

<p>Simple conversion of Z-scores to two-tailed p-values. Written
in a way that allows maximum precision for small p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z.to.p(Z, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Z.to.p_+3A_z">Z</code></td>
<td>
<p>Z score, numeric, scalar, vector or matrix, or other types coercible
using as.numeric()</p>
</td></tr>
<tr><td><code id="Z.to.p_+3A_warn">warn</code></td>
<td>
<p>logical, whether to give a warning for very low p-values when
precision limits are exceeded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-valuues with the same dimension as the input
</p>


<h3>Author(s)</h3>

<p>Nicholas Cooper <a href="mailto:njcooper@gmx.co.uk">njcooper@gmx.co.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.to.Z">p.to.Z</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z.to.p("1.96")
Z.to.p(p.to.Z(0.0001))
Z.to.p(37, TRUE)
Z.to.p(39, TRUE) # maximum precision exceeded, warnings on
Z.to.p(39) # maximum precision exceeded, warnings off
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
