<!DOCTYPE html><html><head><title>Help for package interlineaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {interlineaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#interlineaR'><p>Importing interlinearized corpora and dictionaries as produced by descriptive linguistics software</p></a></li>
<li><a href='#lift-format'><p>Information about the structure of the LIFT XML format in order to easily</p>
generate XPath expression and extract information.</a></li>
<li><a href='#lift.specification'><p>List of the available pieces of information for each entry (ie column in the entry table)</p></a></li>
<li><a href='#read.emeld'><p>Read an EMELD XML document containing an interlinearized corpus.</p></a></li>
<li><a href='#read.lift'><p>Parse a dictionary in XML LIFT (Lexicon Interchange FormaT) vocabulary</p>
and turn it into a set of data.frame</a></li>
<li><a href='#read.pangloss'><p>Read a file in the format used in the pangloss collection</p></a></li>
<li><a href='#read.toolbox'><p>Parse a Toolbox (SIL) text file</p></a></li>
<li><a href='#vatlongos'><p>A corpus of 10 texts of the Vatlongos (vtk) language</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Importing Interlinearized Corpora and Dictionaries as Produced
by Descriptive Linguistics Software</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Interlinearized glossed texts (IGT) are used in descriptive linguistics for
 representing a morphological analysis of a text through a morpheme-by-morpheme gloss.
 'InterlineaR' provide a set of functions that targets several popular formats of IGT
 ('SIL Toolbox', 'EMELD XML') and that turns an IGT into a set of data frames following
 a relational model (the tables represent the different linguistic units: texts,
 sentences, word, morphems).
 The same pieces of software ('SIL FLEX', 'SIL Toolbox') typically produce dictionaries
 of the morphemes used in the glosses. 'InterlineaR' provide a function for turning
 the LIFT XML dictionary format into a set of data frames following a relational model
 in order to represent the dictionary entries, the sense(s) attached to the entries,
 the example(s) attached to senses, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14), xml2, reshape2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sylvainloiseau/interlineaR">https://github.com/sylvainloiseau/interlineaR</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>read.emeld.R read.lift.R interlineaR-package.R read.toolbox.R
read.pangloss.R dataset.R lift.specifications.R common.R</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>xz</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-19 06:35:56 UTC; sloiseau</td>
</tr>
<tr>
<td>Author:</td>
<td>Sylvain Loiseau [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sylvain Loiseau &lt;sylvain.loiseau@univ-paris13.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-22 12:17:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='interlineaR'>Importing interlinearized corpora and dictionaries as produced by descriptive linguistics software</h2><span id='topic+interlineaR'></span><span id='topic+interlineaR-package'></span><span id='topic+interlineaR-package'></span>

<h3>Description</h3>

<p>Importing interlinearized corpora and dictionaries as produced by descriptive linguistics software
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sylvain Loiseau <a href="mailto:sylvain.loiseau@univ-paris13.fr">sylvain.loiseau@univ-paris13.fr</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/sylvainloiseau/interlineaR">https://github.com/sylvainloiseau/interlineaR</a>
</p>
</li></ul>


<hr>
<h2 id='lift-format'>Information about the structure of the LIFT XML format in order to easily
generate XPath expression and extract information.</h2><span id='topic+lift-format'></span><span id='topic+entry.fields.spec'></span><span id='topic+lift-format'></span><span id='topic+sense.fields.spec'></span><span id='topic+lift-format'></span><span id='topic+example.fields.spec'></span><span id='topic+lift-format'></span><span id='topic+relation.fields.spec'></span>

<h3>Description</h3>

<p>There are four fonctions: one for each table to be built (entries, senses, examples, relations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entry.fields.spec()

sense.fields.spec()

example.fields.spec()

relation.fields.spec()
</code></pre>


<h3>Details</h3>

<p>Each functions return a table with the following columns:
A name for this field
&quot;Path&quot;: an XPath expression toward an element.
&quot;Type&quot; how to retreive the content of this element in some frequent cases:
- &quot;form&quot; indicates that the content is in ./form/text; form contains an attribute @lang
with either vernacular languages code(s), or analysis language code(s).
In this case, the Sub-type column state vernacular of analysis accordingly.
- &quot;trait&quot; indicate that the content is in a @value attribute;
the trait has a &quot;name&quot; attribute give in the Sub-type column.
- &quot;gloss&quot; is similar to &quot;form&quot; above.
&quot;Sub-type&quot;: in the cases where Type has the values &quot;form&quot; or &quot;gloss&quot;, indicats if
@lang is vernacular ou analysis;
in the cases where Type has the value &quot;trait&quot; : the value of @name.
&quot;Concat&quot; an XPath expression for building the value with the element using XPath concat()
&quot;Collapse&quot;: TRUE = element may appears several time and have to be collapsed
in order to build the cell value.
</p>


<h3>Value</h3>

<p>a data.frame
</p>
<p>a data.frame
</p>
<p>a data.frame
</p>
<p>a data.frame
</p>

<hr>
<h2 id='lift.specification'>List of the available pieces of information for each entry (ie column in the entry table)</h2><span id='topic+lift.specification'></span><span id='topic+available.entry.fields'></span><span id='topic+available.sense.fields'></span><span id='topic+available.example.fields'></span><span id='topic+available.relation.fields'></span>

<h3>Description</h3>

<p>List of the available pieces of information for each entry (ie column in the entry table)
</p>
<p>List of the available pieces of information for each sense (ie column in the sense table)
</p>
<p>List of the available pieces of information for each example (ie column in the example table)
</p>
<p>List of the available pieces of information for each relation (ie column in the relation table)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available.entry.fields()

available.sense.fields()

available.example.fields()

available.relation.fields()
</code></pre>


<h3>Value</h3>

<p>a character vector of entries.
</p>
<p>a character vector of entries.
</p>
<p>a character vector of entries.
</p>
<p>a character vector of entries.
</p>

<hr>
<h2 id='read.emeld'>Read an EMELD XML document containing an interlinearized corpus.</h2><span id='topic+read.emeld'></span>

<h3>Description</h3>

<p>The EMELD XML vocabulary has been proposed for the encoding of interlinear glosses.
It is used by the FieldWorks software (SIL FLEX) as an export format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.emeld(file, vernacular.languages, analysis.languages = "en",
  get.morphemes = TRUE, get.words = TRUE, get.sentences = TRUE,
  get.texts = TRUE, text.fields = c("title", "title-abbreviation", "source",
  "comment"), sentence.fields = c("segnum", "gls", "lit", "note"),
  words.vernacular.fields = "txt", words.analysis.fields = c("gls", "pos"),
  morphemes.vernacular.fields = c("txt", "cf"),
  morphemes.analysis.fields = c("gls", "msa", "hn"), sep = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.emeld_+3A_file">file</code></td>
<td>
<p>the path (or url) to a document in ELMED vocabulary</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_vernacular.languages">vernacular.languages</code></td>
<td>
<p>character vector: one or more codes of languages analysed in the document.</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_analysis.languages">analysis.languages</code></td>
<td>
<p>character vector: one or more codes of languages used for the analyses (in glosses, translations, notes) in the document.</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_get.morphemes">get.morphemes</code></td>
<td>
<p>logical vector: should the returned list include a slot for the description of morphemes?</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_get.words">get.words</code></td>
<td>
<p>logical vector: should the returned list include a slot for the description of words?</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_get.sentences">get.sentences</code></td>
<td>
<p>logical vector: should the returned list include a slot for the description of sentences?</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_get.texts">get.texts</code></td>
<td>
<p>logical vector: should the returned list include a slot for the description of texts?</p>
</td></tr>
<tr><td><code id="read.emeld_+3A_text.fields">text.fields</code></td>
<td>
<p>character vector: information to be extracted for the texts
(and turned into corresponding column in the data.frame describing texts)
The default are:
</p>

<ul>
<li><p> &quot;title&quot;
</p>
</li>
<li><p> &quot;title-abbreviation&quot;
</p>
</li>
<li><p> &quot;source&quot;
</p>
</li>
<li><p> &quot;comment&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_sentence.fields">sentence.fields</code></td>
<td>
<p>character vector: information to be extracted for the sentences
(and turned into corresponding column in the data.frame describing sentences)
The default are:
</p>

<ul>
<li><p> &quot;segnum&quot; : an ID of the sentende
</p>
</li>
<li><p> &quot;gls&quot;: a translation (possibly in all analysis languages)
</p>
</li>
<li><p> &quot;lit&quot;: a litteral translation (possibly in all analysis languages)
</p>
</li>
<li><p> &quot;note&quot;: note (possibly in all analysis languages)
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_words.vernacular.fields">words.vernacular.fields</code></td>
<td>
<p>character vector: information (in vernacular language(s))
to be extracted for the words (and turned into corresponding columns in the data.frame describing words)
The default are:
</p>

<ul>
<li><p> &quot;txt&quot; : the original text
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_words.analysis.fields">words.analysis.fields</code></td>
<td>
<p>character vector: information (in analysis language(s))
to be extracted for the words (and turned into corresponding columns in the data.frame describing words)
The default are:
</p>

<ul>
<li><p> &quot;gls&quot; : a gloss of the word
</p>
</li>
<li><p> &quot;pos&quot; : the part of speech of the word
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_morphemes.vernacular.fields">morphemes.vernacular.fields</code></td>
<td>
<p>character vector: information (in vernacular language(s)) to be extracted for the morphemes (and turned into corresponding columns in the data.frame describing morphemes). May be null or empty.
</p>

<ul>
<li><p> &quot;txt&quot; : the text of the morpheme
</p>
</li>
<li><p> &quot;cf&quot; : the canonical form of the morpheme
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_morphemes.analysis.fields">morphemes.analysis.fields</code></td>
<td>
<p>character vector: information (in analysis language(s)) to be extracted for the morphemes (and turned into corresponding columns in the data.frame describing morphemes). May be null or empty.
</p>

<ul>
<li><p> &quot;gls&quot; : the gloss of the morpheme
</p>
</li>
<li><p> &quot;msa&quot; : the part of speech of the morpheme
</p>
</li>
<li><p> &quot;hn&quot; : a number for the identifiation of the morpheme amongst its homophone.
</p>
</li></ul>
</td></tr>
<tr><td><code id="read.emeld_+3A_sep">sep</code></td>
<td>
<p>character vector: the character used to join multiple notes in the same language.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If several 'note' fields in the same language are present in a sentence,
they will be concatenated (see the &quot;sep&quot; argument)
</p>


<h3>Value</h3>

<p>a list with slots named &quot;morphemes&quot;, &quot;words&quot;, &quot;sentences&quot;, &quot;texts&quot; 
(some slot may have been excluded throuth the &quot;get.*&quot; arguments, see above).
Each slot is a data.frame containing the information on the corresponding unit.
In each data.frame, each row describe an occurrence (the first row of the result$morphemes data.frame describe the first morpheme of the corpus).
In each data.frame, the first columns give ids refering to the line in other data.frame (so that we can link the first morpheme to the text, the sentence or the word it belongs to).
The following columns give information about the corresponding occurrence of the unit. Which information are extracted from the document and included in the data frame depends upton the *.fields parameters (see above).
Columns made are coined using the field name and the language code. For instance, if read.emeld is called with the parameters vernacular.languages=&quot;tww&quot; and morphemes.vernacular.fields=c(&quot;txt&quot;, &quot;cf&quot;), then the column txt.tww and cf.tww will be created in the morphemes slot data frame.
</p>


<h3>References</h3>

<p>Baden Hughes, Steven Bird and Catherine Bow <em>Encoding and Presenting Interlinear Text Using XML Technologies</em>, http://www.aclweb.org/anthology/U03-1008
</p>
<p>SIL FieldWorks: https://software.sil.org/fieldworks/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("exampleData", "tuwariInterlinear.xml", package="interlineaR")
corpus &lt;- read.emeld(path, vernacular="tww", analysis="en")
head(corpus$morphemes)

# In some cases, one may have to combine information coming from various data.frame.
# Lets imagine one needs to have in the same data.frame the morphemes data 
# plus the "note" field attached to sentences:
# - The easy way is to combine all the columns of the two data frame 'morphemes' and 'sentence' :
combined &lt;- merge(corpus$morphemes, corpus$sentences, by.x="sentence_id", by.y="sentence_id")
head(combined)

# - Alternatively, one may use vector extraction in order to add only the desired column
# to the morphemes data frame:
corpus$morphemes$note = corpus$sentences$note.en[ corpus$morphemes$sentence_id ]
head(corpus$morphemes)
</code></pre>

<hr>
<h2 id='read.lift'>Parse a dictionary in XML LIFT (Lexicon Interchange FormaT) vocabulary
and turn it into a set of data.frame</h2><span id='topic+read.lift'></span>

<h3>Description</h3>

<p>The dictionary is turned into a list of up to four data frame: &quot;entries&quot;, &quot;senses&quot;, &quot;examples&quot; and &quot;relations&quot;.
The data frame are pointing to each other through IDs, following a relational data model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.lift(file, vernacular.languages, analysis.languages = "en",
  get.entry = TRUE, get.sense = TRUE, get.example = TRUE,
  get.relation = TRUE, entry.fields = available.entry.fields(),
  sense.fields = available.sense.fields(),
  example.fields = available.example.fields(),
  relation.fields = available.relation.fields(), simplify = FALSE,
  sep = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.lift_+3A_file">file</code></td>
<td>
<p>: a length-one character vector containing the path to a LIFT XML document.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_vernacular.languages">vernacular.languages</code></td>
<td>
<p>character vector: the code of the vernacular language.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_analysis.languages">analysis.languages</code></td>
<td>
<p>character vector: code of the object language used in the glosses and analyses.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_get.entry">get.entry</code></td>
<td>
<p>logical length-1 vector: include the entries table in the result?</p>
</td></tr>
<tr><td><code id="read.lift_+3A_get.sense">get.sense</code></td>
<td>
<p>logical length-1 vector: include the senses table in the result?</p>
</td></tr>
<tr><td><code id="read.lift_+3A_get.example">get.example</code></td>
<td>
<p>logical length-1 vector: include the examples table in the result?</p>
</td></tr>
<tr><td><code id="read.lift_+3A_get.relation">get.relation</code></td>
<td>
<p>logical length-1 vector: include the relations table in the result?</p>
</td></tr>
<tr><td><code id="read.lift_+3A_entry.fields">entry.fields</code></td>
<td>
<p>character vector: names of the fields to be included in the entries table. See available.entry.fields() for the complete list of the available fields.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_sense.fields">sense.fields</code></td>
<td>
<p>character vector: names of the fields to be included in the senses table. See available.sense.fields() for the complete list of the available fields.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_example.fields">example.fields</code></td>
<td>
<p>character vector: names of the fields to be included in the examples table. See available.example.fields() for the complete list of the available fields.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_relation.fields">relation.fields</code></td>
<td>
<p>character vector: names of the fields to be included in the relations table. See available.relation.fields() for the complete list of the available fields.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_simplify">simplify</code></td>
<td>
<p>logical length-1 vector: if true, columns containing only empty values are removed from all data frame.</p>
</td></tr>
<tr><td><code id="read.lift_+3A_sep">sep</code></td>
<td>
<p>character vector: the character used to join multiple notes in the same language.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Field&quot; in this document denote a piece of information in LIFT, such as the &quot;gloss&quot;
in a sense or &quot;citation form&quot; of an entry. A field may correspond to several columns in the resulting data frame,
since fields are multilingual. &quot;gloss&quot; is an analysis field, thus if two
analysis.languages are declared, for instance &quot;en&quot; and &quot;fr&quot;, then two columns
will be present, gloss.en and gloss.fr, in the senses data frame.
The &quot;citation form&quot; field, on the other hand, is an vernacular language field, thus if
several vernacular fields are declared, several form columns will be present in the entries data frame.
</p>


<h3>Value</h3>

<p>a list with up to four slots named &quot;entries&quot;, &quot;senses&quot;, &quot;examples&quot; and &quot;relations&quot;,
each slot containing a data.frame
</p>


<h3>References</h3>

<p>http://code.google.com/p/lift-standard
</p>


<h3>See Also</h3>

<p>write.CLDF for serialization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("exampleData", "tuwariDictionary.lift", package="interlineaR")
dictionary &lt;- read.lift(path, vernacular.languages="tww")

# Reduce the size of the data frames by filtering to columns actually containing something...
dictionary &lt;- read.lift(path, vernacular.languages="tww", simplify=TRUE)

# Get information in the different analysis languages used in the document (english and tok pisin)
dictionary &lt;- read.lift(path, vernacular.languages="tww", analysis.languages=c("en", "tpi"))

# Restrict to entries and senses dataframe, and explicitly ask for some fields:
dictionary &lt;- read.lift(
  path,
  vernacular.languages="tww",
  get.example=FALSE,
  get.relation=FALSE,
  entry.fields=c("lexical-unit", "morph-type"),
  sense.fields=c("grammatical-info.value", "gloss", "definition",
  "semantic-domain-ddp4", "grammatical-info.traits")
)

</code></pre>

<hr>
<h2 id='read.pangloss'>Read a file in the format used in the pangloss collection</h2><span id='topic+read.pangloss'></span>

<h3>Description</h3>

<p>The pangloss collection (http://lacito.vjf.cnrs.fr/pangloss/index_en.html) is a large collection of interlinearized texts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pangloss(url, DOI = NULL, get.texts = TRUE, get.sentences = TRUE,
  get.words = TRUE, get.morphemes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pangloss_+3A_url">url</code></td>
<td>
<p>a length one character vector with the url of the document to be imported</p>
</td></tr>
<tr><td><code id="read.pangloss_+3A_doi">DOI</code></td>
<td>
<p>an unique identifier</p>
</td></tr>
<tr><td><code id="read.pangloss_+3A_get.texts">get.texts</code></td>
<td>
<p>should the 'texts' data.frame be included in the result ?</p>
</td></tr>
<tr><td><code id="read.pangloss_+3A_get.sentences">get.sentences</code></td>
<td>
<p>should the 'sentences' data.frame be included in the result ?</p>
</td></tr>
<tr><td><code id="read.pangloss_+3A_get.words">get.words</code></td>
<td>
<p>should the 'words' data.frame be included in the result ?</p>
</td></tr>
<tr><td><code id="read.pangloss_+3A_get.morphemes">get.morphemes</code></td>
<td>
<p>should the 'morphemes' data.frame be included in the result ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with up to 5 slots corresponding to different units and named &quot;texts&quot;, &quot;sentences&quot;, &quot;words&quot;, &quot;morphemes&quot;.
Each slot contains a data frame where each line describe an occurrence of the corresponding unit.
</p>


<h3>References</h3>

<p>http://lacito.vjf.cnrs.fr/pangloss/index_en.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("exampleData", "FOURMI.xml", package="interlineaR")
corpus &lt;- read.pangloss(path)
head(corpus$morphemes)
</code></pre>

<hr>
<h2 id='read.toolbox'>Parse a Toolbox (SIL) text file</h2><span id='topic+read.toolbox'></span>

<h3>Description</h3>

<p>Parse a Toolbox (SIL) text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.toolbox(path, text.fields.suppl = NULL, sentence.fields.suppl = c("tx",
  "nt", "ft"), word.fields.suppl = NULL, morpheme.fields.suppl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.toolbox_+3A_path">path</code></td>
<td>
<p>length-1 character vector: the path to a toolbox text file.</p>
</td></tr>
<tr><td><code id="read.toolbox_+3A_text.fields.suppl">text.fields.suppl</code></td>
<td>
<p>character vector: the code of supplementary fields to be searched for each text (genre, ...). &quot;id&quot; is mandatory and need not to be listed here.</p>
</td></tr>
<tr><td><code id="read.toolbox_+3A_sentence.fields.suppl">sentence.fields.suppl</code></td>
<td>
<p>character vector: the code of supplementary fields to be searched for each sentence (such as ft, nt). &quot;ref&quot; is mandatory and need not to be listed here.</p>
</td></tr>
<tr><td><code id="read.toolbox_+3A_word.fields.suppl">word.fields.suppl</code></td>
<td>
<p>character vector: the code of supplementary fields to be searched for each word. &quot;tx&quot; is mandatory and need not to be listed here.</p>
</td></tr>
<tr><td><code id="read.toolbox_+3A_morpheme.fields.suppl">morpheme.fields.suppl</code></td>
<td>
<p>character vector: the code of supplementary fields to be searched for each morpheme. &quot;mb&quot;, &quot;ge&quot;, &quot;ps&quot; are mandatory and need not to be listed here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with four slots &quot;texts&quot;, &quot;sentences&quot;, &quot;words&quot; and &quot;morphemes&quot;,
each one containing a data frame. In these data frame, each row describe an occurrence
of the corresponding unit.
</p>


<h3>References</h3>

<p>https://software.sil.org/toolbox/
</p>


<h3>See Also</h3>

<p><a href="#topic+read.emeld">read.emeld</a> (XML vocabulary for interlinearized glossed texts)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corpuspath &lt;- system.file("exampleData", "tuwariToolbox.txt", package="interlineaR")
corpus &lt;- read.toolbox(corpuspath)
</code></pre>

<hr>
<h2 id='vatlongos'>A corpus of 10 texts of the Vatlongos (vtk) language</h2><span id='topic+vatlongos'></span>

<h3>Description</h3>

<p>The corpus is produced with the read.emeld() function. It is a list of 4 slots representing four 
units: &quot;texts&quot; &quot;sentences&quot; &quot;words&quot; &quot;morphems&quot;. Each slot contains a data frame, and each row
in the data.frame describe one occurrences of the corresponding unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vatlongos
</code></pre>


<h3>Format</h3>

<p>A list with 4 slots</p>


<h3>Details</h3>


<ul>
<li><p> texts : a data frame of 95 units and 5 columns (&quot;text_id&quot;, &quot;title.en&quot;, &quot;title.abbreviation.en&quot;, &quot;source.en&quot;, &quot;comment.en&quot;)
</p>
</li>
<li><p> sentenes : a data frame of 3967 units and 6 columns (&quot;text_id&quot;, &quot;sentence_id&quot;, &quot;segnum.en&quot;, &quot;gls.en&quot;, &quot;lit.en&quot;, &quot;note.en&quot;)
</p>
</li>
<li><p> words : a data frame of 52983 units and 6 columns (&quot;text_id&quot; &quot;sentence_id&quot; &quot;word_id&quot; &quot;txt.tvk&quot; &quot;gls.en&quot; &quot;pos.en&quot;)
</p>
</li>
<li><p> mophems numeric : a data frame of 56354 units and 10 columns (&quot;text_id&quot; &quot;sentence_id&quot; &quot;word_id&quot; &quot;morphem_id&quot; &quot;type&quot; &quot;txt.tvk&quot; &quot;cf.tvk&quot; &quot;gls.en&quot; &quot;msa.en&quot; &quot;hn.en&quot; )
</p>
</li></ul>

<p>See the vignette vatlongos for Case study based on this corpus.
</p>


<h3>References</h3>

<p>Eleanor Ridge &lt;Eleanor_Ridge@soas.ac.uk&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
