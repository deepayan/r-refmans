<!DOCTYPE html><html><head><title>Help for package WaveSampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WaveSampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distUnitk'><p>Squared Euclidean distances of the unit k.</p></a></li>
<li><a href='#IB'><p>Spreading measure based on Moran's <code class="reqn">I</code> index</p></a></li>
<li><a href='#sb_vk'><p>Values <code class="reqn">v_k</code> to compute the Spatial balance</p></a></li>
<li><a href='#varHAJ'><p>Hajek-Rosen variance estimator</p></a></li>
<li><a href='#wave'><p>Weakly associated vectors sampling</p></a></li>
<li><a href='#wpik'><p>Stratification matrix from inclusion probabilities</p></a></li>
<li><a href='#wpikInv'><p>Stratification matrix from inverse inclusion probabilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weakly Associated Vectors (WAVE) Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial data are generally auto-correlated, meaning that if two 
  units selected are close to each other, then it is likely that they share the
  same properties. For this reason, when sampling in the population it is often
  needed that the sample is well spread over space. A new method to draw a sample
  from a population with spatial coordinates is proposed. This method is called
  wave (Weakly Associated Vectors) sampling. It uses the less correlated vector
  to a spatial weights matrix to update the inclusion probabilities vector
  into a sample. For more details see Raphaël Jauslin and Yves Tillé (2019) &lt;<a href="https://doi.org/10.1007%2Fs13253-020-00407-1">doi:10.1007/s13253-020-00407-1</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RJauslin/WaveSampling">https://github.com/RJauslin/WaveSampling</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RJauslin/WaveSampling/issues">https://github.com/RJauslin/WaveSampling/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, sampling, BalancedSampling, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-02 13:40:57 UTC; jauslinr</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphaël Jauslin <a href="https://orcid.org/0000-0003-1088-3356"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Yves Tillé <a href="https://orcid.org/0000-0003-0904-5523"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raphaël Jauslin &lt;raphael.jauslin@unine.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-02 17:42:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='distUnitk'>Squared Euclidean distances of the unit k.</h2><span id='topic+distUnitk'></span>

<h3>Description</h3>

<p>Calculate the squared Euclidean distance from unit <code class="reqn">k</code> to the other units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distUnitk(X, k, tore, toreBound)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distUnitk_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_k">k</code></td>
<td>
<p>the unit index to be used.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_tore">tore</code></td>
<td>
<p>an optional logical value, if we are considering the distance on a tore. See Details.</p>
</td></tr>
<tr><td><code id="distUnitk_+3A_torebound">toreBound</code></td>
<td>
<p>an optional numeric value that specify the length of the tore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\mathbf{x}_k,\mathbf{x}_l</code> be the spatial coordinates of the unit <code class="reqn">k,l \in U</code>. The classical euclidean distance is given by
</p>
<p style="text-align: center;"><code class="reqn">d^2(k,l) = (\mathbf{x}_k - \mathbf{x}_l)^\top (\mathbf{x}_k - \mathbf{x}_l). </code>
</p>

<p>When the points are distributed on a <code class="reqn">N_1 \times N_2</code> regular grid of <code class="reqn">R^2</code>.
It is possible to consider the units like they were placed on a tore. It can be illustrated by Pac-Man passing through the wall to get away from ghosts. Specifically,
we could consider two units on the same column (resp. row) that are on the opposite have a small distance,
</p>
<p style="text-align: center;"><code class="reqn"> d^2_T(k,l) = min( (x_{k_1} - x_{l_1})^2,
                      (x_{k_1} + N_1 - x_{l_1})^2,
                      (x_{k_1} - N_1 - x_{l_1})^2) +</code>
</p>

<p style="text-align: center;"><code class="reqn"> min( (x_{k_2} - x_{l_2})^2,
                      (x_{k_2} + N_2 - x_{l_2})^2,
                      (x_{k_2} - N_2 - x_{l_2})^2).</code>
</p>

<p>The option <code>toreBound</code> specify the length of the tore in the case of <code class="reqn">N_1 = N_2 = N</code>. 
It is omitted if the <code>tore</code> option is equal to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>a vector of length <code class="reqn">N</code> that contains the distances from the unit <code class="reqn">k</code> to all other units.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpik">wpik</a></code>, <code><a href="#topic+wave">wave</a></code> and <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  N &lt;- 5
  x &lt;- seq(1,N,1)
  X &lt;- as.matrix(expand.grid(x,x))
  distUnitk(X,k = 2,tore = TRUE,toreBound = 5)
  distUnitk(X,k = 2,tore = FALSE,toreBound = -1)
</code></pre>

<hr>
<h2 id='IB'>Spreading measure based on Moran's <code class="reqn">I</code> index</h2><span id='topic+IB'></span>

<h3>Description</h3>

<p>This function implements the spreading measure based on Moran's <code class="reqn">I</code> index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IB(W, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IB_+3A_w">W</code></td>
<td>
<p>a stratification matrix inheriting from <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> that represents the spatial weights. See <code><a href="#topic+wpik">wpik</a></code>.</p>
</td></tr>
<tr><td><code id="IB_+3A_s">s</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> with elements equal to 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for non-chosen units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index is developped by Tillé et al. (2018) and measure the spreading of a sample drawn from a population.
It uses a corrected version of the traditional Moran's <code class="reqn">I</code> index. Each row of the matrix <code class="reqn">\bf W</code> should represents a stratum. Each 
stratum is defined by a particular unit and its neighbouring units. See <code><a href="#topic+wpik">wpik</a></code>.
The spatial balance measure is equal to
</p>
<p style="text-align: center;"><code class="reqn">I_B =\frac{( \bf s- \bar{s}_w)^\top  W ( s- \bar{s}_w)}{\bf \sqrt{( s- \bar{s}_w)^\top  D ( s- \bar{s}_w) ( s- \bar{s}_w)^\top  B ( s- \bar{s}_w)}},</code>
</p>

<p>where <code class="reqn">\bf D</code> is the diagonal matrix containing the <code class="reqn">w_i</code>, 
</p>
<p style="text-align: center;"><code class="reqn"> \bf \bar{s}_w =  1 \frac{ s^\top  W  1}{ 1^\top  W  1}</code>
</p>

<p>and 
</p>
<p style="text-align: center;"><code class="reqn"> \bf B =  W^\top  D^{-1}  W - \frac{ W^\top  1 1^\top  W}{1^\top  W  1}.</code>
</p>

<p>To specify the spatial weights uses the argument <code>W</code>.
</p>


<h3>Value</h3>

<p>A numeric value that represents the spatial balance. It could be any real value between -1 (spread) and 1 (clustered).
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>References</h3>

<p>Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
<em>Spatial Statistics</em>, 23, 182-192.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpik">wpik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  N &lt;- 36
  n &lt;- 12
  x &lt;- seq(1,sqrt(N),1)
  X &lt;- expand.grid(x,x)
  pik &lt;- rep(n/N,N)
  W &lt;- wpik(as.matrix(X),pik,bound = 1,tore = TRUE,shift = FALSE,toreBound = sqrt(N))
  W &lt;- W - diag(diag(W))
  s &lt;- wave(as.matrix(X),pik,tore = TRUE,shift = TRUE,comment = TRUE)
  IB(W,s)

</code></pre>

<hr>
<h2 id='sb_vk'>Values <code class="reqn">v_k</code> to compute the Spatial balance</h2><span id='topic+sb_vk'></span>

<h3>Description</h3>

<p>Calculates the <code class="reqn">v_k</code> values of the spatial balance developped by Stevens and Olsen (2004) and suggested by Grafström et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sb_vk(pik, X, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sb_vk_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities. The length should be equal to <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="sb_vk_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="sb_vk_+3A_s">s</code></td>
<td>
<p>A vector of size <code class="reqn">N</code> with elements equal 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for non-chosen unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial balance measure based on the Voronoï polygons is defined by 
</p>
<p style="text-align: center;"><code class="reqn">B(S) = \frac{1}{n}\sum_{k\in S} (v_k -1)^2 .</code>
</p>

<p>The function return the <code class="reqn">v_k</code> values and is mainly based on the function <code><a href="BalancedSampling.html#topic+sb">sb</a></code> of the package <code>BalancedSampling</code> Grafström and Lisic (2019).
</p>


<h3>Value</h3>

<p>A vector of size <code class="reqn">N</code> with elements equal to the <code class="reqn">v_k</code> values. If the unit is not selected then the value is equal to 0.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>References</h3>

<p>Grafström, A., Lundström, N.L.P. and Schelin, L. (2012). Spatially balanced sampling through the Pivotal method. 
<em>Biometrics</em>, 68(2), 514-520
</p>
<p>Grafström, A., Lisic J. (2019). BalancedSampling: Balanced and Spatially Balanced Sampling. R package version 1.5.5.
https://CRAN.R-project.org/package=BalancedSampling
</p>
<p>Stevens, D. L. Jr. and Olsen, A. R. (2004). Spatially balanced sampling of natural resources.
<em>Journal of the American Statistical Association 99, 262-278</em>
</p>


<h3>See Also</h3>

<p><code><a href="BalancedSampling.html#topic+sb">BalancedSampling::sb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 50
n &lt;- 10
X &lt;- as.matrix(cbind(runif(N),runif(N)))
pik &lt;- rep(n/N,N)
s &lt;- wave(X,pik)
v &lt;- sb_vk(pik,X,s)

</code></pre>

<hr>
<h2 id='varHAJ'>Hajek-Rosen variance estimator</h2><span id='topic+varHAJ'></span>

<h3>Description</h3>

<p>Estimator of the variance of the Horvitz-Thompson estimator. It is based on the variance estimator of the conditional Poisson sampling design. See Tillé (2020, Chapter 5) for more informations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varHAJ(y, pik, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varHAJ_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">n</code> that represent the variable of interest.</p>
</td></tr>
<tr><td><code id="varHAJ_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities. The length should be equal to <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="varHAJ_+3A_s">s</code></td>
<td>
<p>index vector of size <code class="reqn">n</code> with elements equal to the selected units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the following quantity :
</p>
<p style="text-align: center;"><code class="reqn">v_{HAJ}(\widehat{Y}_{HT}) = \frac{n}{n-1} \sum_{k\in S} (1-\pi_k)\left( \frac{y_k}{\pi_k}-\frac{ \sum_{l\in S} (1-\pi_k)/\pi_k }{\sum_{l\in S} (1-\pi_k) } \right)^2 .</code>
</p>

<p>This estimator is well-defined for maximum entropy sampling design and use only inclusion probabilities of order one.
</p>


<h3>Value</h3>

<p>A number, the variance
</p>


<h3>References</h3>

<p>Tillé, Y. (2020). Sampling and estimation from finite populations. New York: Wiley
</p>

<hr>
<h2 id='wave'>Weakly associated vectors sampling</h2><span id='topic+wave'></span>

<h3>Description</h3>

<p>Select a spread sample from inclusion probabilities using the weakly associated vectors sampling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave(
  X,
  pik,
  bound = 1,
  tore = FALSE,
  shift = FALSE,
  toreBound = -1,
  comment = FALSE,
  fixedSize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="wave_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities. The length should be equal to N.</p>
</td></tr>
<tr><td><code id="wave_+3A_bound">bound</code></td>
<td>
<p>a scalar representing the bound to reach. See Details. Default is 1.</p>
</td></tr>
<tr><td><code id="wave_+3A_tore">tore</code></td>
<td>
<p>an optional logical value, if we are considering the distance on a tore. See Details. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wave_+3A_shift">shift</code></td>
<td>
<p>an optional logical value, if you would use a shift perturbation. See Details. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wave_+3A_torebound">toreBound</code></td>
<td>
<p>a numeric value that specify the size of the grid. Default is -1.</p>
</td></tr>
<tr><td><code id="wave_+3A_comment">comment</code></td>
<td>
<p>an optional logical value, indicating some informations during the execution. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wave_+3A_fixedsize">fixedSize</code></td>
<td>
<p>an optional logical value, if you would impose a fixed sample size. Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea is derived from the cube method (Devill and Tillé, 2004). At each step, the inclusion probabilities vector <code>pik</code>
is randomly modified. This modification is carried out in a direction that best preserves the spreading of the sample.
</p>
<p>A stratification matrix <code class="reqn">\bf A</code> is computed from the spatial weights matrix calculated from the function <code><a href="#topic+wpik">wpik</a></code>.
Depending if <code class="reqn">\bf A</code> is full rank or not, the vector giving the direction is not selected in the same way.
</p>
<p>If matrix <code class="reqn">\bf A</code> is not full rank, a vector that is contained in the right null space is selected:
</p>
<p style="text-align: center;"><code class="reqn"> Null(\bf A) = \{ \bf x \in R^N | \bf A\bf x = \bf 0  \}. </code>
</p>

<p>If matrix <code class="reqn">\bf A</code> is full rank, we find <code class="reqn">\bf v</code>, <code class="reqn">\bf u</code> the singular vectors associated to the 
smallest singular value <code class="reqn">\sigma </code> of <code class="reqn">\bf A</code> such that
</p>
<p style="text-align: center;"><code class="reqn"> \bf A\bf v = \sigma \bf u,~~~~ \bf A^\top \bf u = \sigma \bf v.</code>
</p>

<p>Vector <code class="reqn"> \bf v </code> is then centered to ensure fixed sample size. At each step, inclusion probabilities is modified and at least on component is set to 0 or 1. Matrix <code class="reqn">\bf A </code> is updated 
from the new inclusion probabilities. The whole procedure it repeated until it remains only one component that is not equal to 0 or 1.
</p>
<p>For more informations on the options <code>tore</code> and <code>toreBound</code>, see <code><a href="#topic+distUnitk">distUnitk</a></code>. If <code>tore</code> is set up <code>TRUE</code> and <code>toreBound</code> not specified the <code>toreBound</code> is equal to 
</p>
<p style="text-align: center;"><code class="reqn">N^{1/p}</code>
</p>

<p>where <code class="reqn">p</code> is equal to the number of column of the matrix <code>X</code>.
</p>
<p>For more informations on the option <code>shift</code>, see <code><a href="#topic+wpik">wpik</a></code>.
</p>
<p>If <code>fixedSize</code> is equal <code>TRUE</code>, the weakest associated vector is centered at each step of the algorithm. This ensures that the size of the selected sample is equal to the sum of the inclusion probabilities.
</p>


<h3>Value</h3>

<p>A vector of size <code class="reqn">N</code> with elements equal 0 or 1. The value 1 indicates that the unit is selected while the value 0 is for non-chosen unit.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>References</h3>

<p>Deville, J. C. and Tillé, Y. (2004). Efficient balanced sampling: the cube method. Biometrika, 91(4), 893-912
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpik">wpik</a></code>, <code><a href="#topic+distUnitk">distUnitk</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#------------
# Example 2D
#------------

N &lt;- 50
n &lt;- 15
pik &lt;- rep(n/N,N)
X &lt;- as.matrix(cbind(runif(N),runif(N)))
s &lt;- wave(X,pik)

#------------
# Example 2D grid 
#------------

N &lt;- 36 # 6 x 6 grid
n &lt;- 12 # number of unit selected
x &lt;- seq(1,sqrt(N),1)
X &lt;- as.matrix(cbind(rep(x,times = sqrt(N)),rep(x,each = sqrt(N))))
pik &lt;- rep(n/N,N)
s &lt;- wave(X,pik, tore = TRUE,shift = FALSE)

#------------
# Example 1D
#------------

N &lt;- 100
n &lt;- 10
X &lt;- as.matrix(seq(1,N,1))
pik &lt;- rep(n/N,N)
s &lt;- wave(X,pik,tore = TRUE,shift =FALSE,comment = TRUE)


</code></pre>

<hr>
<h2 id='wpik'>Stratification matrix from inclusion probabilities</h2><span id='topic+wpik'></span>

<h3>Description</h3>

<p>The stratification matrix is calculated from the inclusion probabilities. It takes the distances between units into account. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpik(X, pik, bound = 1, tore = FALSE, shift = FALSE, toreBound = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpik_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="wpik_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities. The length should be equal to <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="wpik_+3A_bound">bound</code></td>
<td>
<p>a scalar representing the bound to reach. Default is 1.</p>
</td></tr>
<tr><td><code id="wpik_+3A_tore">tore</code></td>
<td>
<p>an optional logical value, if we are considering the distance on a tore. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wpik_+3A_shift">shift</code></td>
<td>
<p>an optional logical value, if you would use a shift perturbation. See Details for more informations. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wpik_+3A_torebound">toreBound</code></td>
<td>
<p>a numeric value that specify the size of the grid. Default is -1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entries of the stratification matrix indicates how the units are close from each others. Hence a large value <code class="reqn">w_{kl}</code> means that the unit <code class="reqn">k</code> 
is close to the unit <code class="reqn">l</code>. This function considers that a unit represents its neighbor till their inclusion probabilities
sum up to <code>bound</code>.
</p>
<p>We define <code class="reqn">G_k</code> the set of the nearest neighbor of the unit <code class="reqn">k</code> including <code class="reqn">k</code> such that the sum of their inclusion
probabilities is just greater than <code>bound</code>. Moreover, let <code class="reqn">g_k = \#{G_k}</code>, the number of elements in <code class="reqn">G_k</code>.
The matrix <code class="reqn">\bf W</code> is then defined as follows,
</p>

<ul>
<li> <p><code class="reqn"> w_{kl} = \pi_l</code> if unit <code class="reqn">l</code> is in the set of the  <code class="reqn">g_k - 1</code> nearest neighbor of <code class="reqn">k</code>.
</p>
</li>
<li> <p><code class="reqn"> w_{kl} = \pi_l + 1 - (\sum_{t \in G_k} \pi_t)</code> if unit <code class="reqn">l</code> is the <code class="reqn">g_k</code> nearest neighbour of <code class="reqn">k</code>.
</p>
</li>
<li> <p><code class="reqn">w_{kl} = 0</code> otherwise.
</p>
</li></ul>

<p>Hence, the <code class="reqn">k</code>th row of the matrix represents
neighborhood or stratum of the unit such that the inclusion probabilities sum up to 1 and
the <code class="reqn">k</code>th column the weights that unit <code class="reqn">k</code> takes for each stratum. 
</p>
<p>The option <code>shift</code> add a small normally distributed perturbation <code>rnorm(0,0.01)</code> to the coordinates
of the centroid of the stratum considered. This could be useful if there are many unit that have the same distances.
Indeed, if two units have the same distance and are the last unit before that the bound is reached, then the weights
of the both units is updated. If a shift perturbation is used then all the distances are differents and only one unit
weight is update such that the bound is reached. 
</p>
<p>The shift perturbation is generated at the beginning of the procedure such that each stratum is shifted by the same perturbation.
</p>


<h3>Value</h3>

<p>A sparse matrix representing the spatial weights.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpikInv">wpikInv</a></code>, <code><a href="#topic+distUnitk">distUnitk</a></code>, <code><a href="#topic+wave">wave</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 25
n &lt;- 5
X &lt;- as.matrix(cbind(runif(N),runif(N)))
pik &lt;- rep(n/N,N)
W &lt;- wpik(X,pik)

</code></pre>

<hr>
<h2 id='wpikInv'>Stratification matrix from inverse inclusion probabilities</h2><span id='topic+wpikInv'></span>

<h3>Description</h3>

<p>The stratification matrix is calculated from the inverse inclusion probabilities. It is a direct
implementation of the spatial weights specified in Tillé et al., (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpikInv(X, pik, tore = FALSE, shift = FALSE, toreBound = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpikInv_+3A_x">X</code></td>
<td>
<p>matrix representing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="wpikInv_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities. The length should be equal to N.</p>
</td></tr>
<tr><td><code id="wpikInv_+3A_tore">tore</code></td>
<td>
<p>an optional logical value, if we are considering the distance on a tore. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wpikInv_+3A_shift">shift</code></td>
<td>
<p>an optional logical value, if you would use a shift perturbation. See Details for more informations. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wpikInv_+3A_torebound">toreBound</code></td>
<td>
<p>a numeric value that specify the size of the grid. Default is -1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entries of the stratification matrix indicates how the units are close from each others. Hence a large value <code class="reqn">w_{kl}</code> means that the unit <code class="reqn">k</code> 
is close to the unit <code class="reqn">l</code>. This function considers that if unit <code class="reqn">k</code> were selected in the sample drawn from the population then
<code class="reqn">k</code> would represent <code class="reqn">1/\pi_k</code> units in the population and, as a consequence, it would be natural to consider that
<code class="reqn">k</code> has <code class="reqn">n_k =  (1/\pi_k - 1)</code> neighbours in the population. The <code class="reqn">n_k</code> neighbours are the nearest neighbours of <code class="reqn">k</code> according to distances.
The weights are so calculated as follows :
</p>

<ul>
<li> <p><code class="reqn"> w_{kl} = 1</code> if unit <code class="reqn">l \in N_{\lfloor n_k \rfloor }</code>
</p>
</li>
<li> <p><code class="reqn"> w_{kl} = n_k - \lfloor n_k \rfloor</code> if unit <code class="reqn">l</code> is the <code class="reqn">\lceil n_k \rceil</code> nearest neighbour of <code class="reqn">k</code>.
</p>
</li>
<li> <p><code class="reqn">w_{kl} = 0</code> otherwise.
</p>
</li></ul>

<p><code class="reqn">\lfloor n_k \rfloor </code> and <code class="reqn">\lceil n_k \rceil</code> are the inferior and the superior integers of <code class="reqn">n_k</code>.
</p>
<p>The option <code>shift</code> add a small normally distributed perturbation <code>rnorm(0,0.01)</code> to the coordinates
of the centroid of the stratum considered. This could be useful if there are many unit that have the same distances.
Indeed, if two units have the same distance and are the last unit before that the bound is reached, then the weights
of the both units is updated. If a shift perturbation is used then all the distances are differents and only one unit
weight is update such that the bound is reached. 
</p>
<p>The shift perturbation is generated at the beginning of the procedure such that each stratum is shifted by the same perturbation.
</p>


<h3>Value</h3>

<p>A sparse matrix representing the spatial weights.
</p>


<h3>Author(s)</h3>

<p>Raphaël Jauslin <a href="mailto:raphael.jauslin@unine.ch">raphael.jauslin@unine.ch</a>
</p>


<h3>References</h3>

<p>Tillé, Y., Dickson, M.M., Espa, G., and Guiliani, D. (2018). Measuring the spatial balance of a sample: A new measure based on Moran's I index.
<em>Spatial Statistics</em>, 23, 182-192.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpik">wpik</a></code>, <code><a href="#topic+distUnitk">distUnitk</a></code>, <code><a href="#topic+wave">wave</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 25
n &lt;- 5
X &lt;- as.matrix(cbind(runif(N),runif(N)))
pik &lt;- rep(n/N,N)
W &lt;- wpikInv(X,pik)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
