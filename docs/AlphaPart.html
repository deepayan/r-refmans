<!DOCTYPE html><html><head><title>Help for package AlphaPart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AlphaPart}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlphaPart'><p>AlphaPart.R</p></a></li>
<li><a href='#AlphaPart.ped'><p>Sample pedigree for partition.</p></a></li>
<li><a href='#AlphaPartSubset'><p>AlphaPartSubset.R</p></a></li>
<li><a href='#AlphaPartSum'><p>AlphaPartSum.R</p></a></li>
<li><a href='#centerPop'><p>Calculate parent average for base population.</p></a></li>
<li><a href='#getScale'><p>Get scale information</p></a></li>
<li><a href='#mapLevels'><p>Mapping levels</p></a></li>
<li><a href='#object.size'><p>Report the Space Allocated for Objects</p></a></li>
<li><a href='#pedFixBirthYear'><p>pedFixBirthYear.R</p></a></li>
<li><a href='#pedSetBase'><p>pedSetBase.R</p></a></li>
<li><a href='#plot.summaryAlphaPart'><p>A function to plot summary of partitioned breeding values.</p></a></li>
<li><a href='#print.AlphaPart'><p>Print method for the output of AlphaPart function.</p></a></li>
<li><a href='#print.plotSummaryAlphaPart'><p>Print a plot generate by the function</p>
<code>plotSummaryAlphaPart</code></a></li>
<li><a href='#print.summaryAlphaPart'><p>Print method for objects of the class summaryAlphaPart.</p></a></li>
<li><a href='#savePlot'><p>Save plot method for <code>AlphaPart</code></p></a></li>
<li><a href='#savePlot.plotSummaryAlphaPart'><p>Save plot objects on the disk for permanent storage. Function</p>
<code>savePlot</code> from the <span class="pkg">grDevices</span> package
works for current page on graphical device. This is an attempt to
make this function generic so that one can define <code>savePlot</code>
methods for particular needs.</a></li>
<li><a href='#sEBV'><p>Scale EBVs for objects of the class summaryAlphaPart.</p></a></li>
<li><a href='#summary.AlphaPart'><p>A function to summarize AlphaPart object.</p></a></li>
<li><a href='#UnknownFuns'><p>Change given unknown value to NA and vice versa.</p></a></li>
<li><a href='#write.csv'><p>write.csv.R</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Partition/Decomposition of Breeding Values by Paths of
Information</td>
</tr>
<tr>
<td>Description:</td>
<td>A software that implements a method for partitioning genetic trends to
    quantify the sources of genetic gain in breeding programmes.
    The partitioning method is described in Garcia-Cortes et al.
    (2008) &lt;<a href="https://doi.org/10.1017%2FS175173110800205X">doi:10.1017/S175173110800205X</a>&gt;. The package includes the
    main function AlphaPart for partitioning breeding values and auxiliary
    functions for manipulating data and summarizing, visualizing, and saving
    results.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregor Gorjanc &lt;highlander.research.lab@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>directlabels (&ge; 1.1), ggplot2 (&ge; 0.8.9), pedigree (&ge;
1.3.1), Rcpp (&ge; 0.9.4), methods (&ge; 3.6.2), reshape, dplyr,
magrittr, tibble (&ge; 3.1.7),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer (&ge; 1.0-2), truncnorm (&ge; 1.0-5), knitr,
rmarkdown, testthat (&ge; 3.0.0), covr, ggridges (&ge; 0.5.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-13</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-13 15:13:00 UTC; thiago</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2.9000</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregor Gorjanc <a href="https://orcid.org/0000-0001-8008-2787"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jana Obsteter <a href="https://orcid.org/0000-0003-1511-3916"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Thiago de Paula Oliveira
    <a href="https://orcid.org/0000-0002-4555-2584"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 21:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='AlphaPart'>AlphaPart.R</h2><span id='topic+AlphaPart'></span>

<h3>Description</h3>

<p>A function to partition breeding values by a path
variable. The partition method is described in García-Cortés et
al., 2008: Partition of the genetic trend to validate multiple
selection decisions.  Animal : an international journal of animal
bioscience. DOI:  doi: <a href="https://doi.org/10.1017/S175173110800205X">10.1017/S175173110800205X</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaPart(x, pathNA, recode, unknown, sort, verbose, profile,
  printProfile, pedType, colId, colFid, colMid, colPath, colBV,
  colBy, center, scaleEBV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlphaPart_+3A_x">x</code></td>
<td>
<p>data.frame , with (at least) the following columns:
individual, father, and mother identif ication, and year of birth;
see arguments <code>colId</code>, <code>colFid</code>, <code>colMid</code>,
<code>colPath</code>, and <code>colBV</code>; see also details about the
validity of pedigree.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_pathna">pathNA</code></td>
<td>
<p>Logical, set dummy path (to &quot;XXX&quot;) where path
information is unknown (missing).</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_recode">recode</code></td>
<td>
<p>Logical, internally recode individual, father and,
mother identification to <code>1:n</code> codes, while missing parents
are defined with <code>0</code>; this option must be used if identif
ications in <code>x</code> are not already given as <code>1:n</code> codes, see
also argument <code>sort</code>.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_unknown">unknown</code></td>
<td>
<p>Value(s) used for representing unknown (missing)
parent in <code>x</code>; this options has an effect only when
<code>recode=FALSE</code> as it is only needed in that situation.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_sort">sort</code></td>
<td>
<p>Logical, initially sort <code>x</code> using <code>orderPed()</code>
so that children follow parents in order to make imputation as
optimal as possible (imputation is performed within a loop from the
first to the last unknown birth year); at the end original order is
restored.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, print additional information: <code>0</code> -
print nothing, <code>1</code> - print some summaries about the data.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_profile">profile</code></td>
<td>
<p>Logical, collect timings and size of objects.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_printprofile">printProfile</code></td>
<td>
<p>Character, print profile info on the fly
(<code>"fly"</code>) or at the end (<code>"end"</code>).</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_pedtype">pedType</code></td>
<td>
<p>Character, pedigree type: the most common form is
<code>"IPP"</code> for Individual, Parent 1 (say father), and Parent 2
(say mother) data; the second form is <code>"IPG"</code> for Individual,
Parent 1 (say father), and one of Grandparents of Parent 2 (say
maternal grandfather).</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colid">colId</code></td>
<td>
<p>Numeric or character, position or name of a column
holding individual identif ication.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colfid">colFid</code></td>
<td>
<p>Numeric or character, position or name of a column
holding father identif ication.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colmid">colMid</code></td>
<td>
<p>Numeric or character, position or name of a column
holding mother identif ication or maternal grandparent identif
ication if <code>pedType="IPG"</code> .</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colpath">colPath</code></td>
<td>
<p>Numeric or character, position or name of a column
holding path information.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colbv">colBV</code></td>
<td>
<p>Numeric or character, position(s) or name(s) of
column(s) holding breeding Values.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_colby">colBy</code></td>
<td>
<p>Numeric or character, position or name of a column
holding group information (see details).</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_center">center</code></td>
<td>
<p>Logical, if <code>center=TRUE</code> detect a shift in base
population mean and attributes it as parent average effect rather
than Mendelian sampling effect, otherwise, if center=FALSE, the base
population values are only accounted as Mendelian sampling
effect. Default is <code>center = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AlphaPart_+3A_scaleebv">scaleEBV</code></td>
<td>
<p>a list with two arguments defining whether is
appropriate to center and/or scale the <code>colBV</code> columns in respect to
the base population. The list may contain the following components:
</p>

<ul>
<li> <p><code>center</code>: a logical value
</p>
</li>
<li> <p><code>scale</code>: a logical value. If <code>center = TRUE</code> and <code>scale = TRUE</code> then the
base population is set to has zero mean and unit variance.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Pedigree in <code>x</code> must be valid in a sense that there
are:
</p>

<ul>
<li><p> no directed loops (the simplest example is that the individual
identification is equal to the identification of a father or mother)
</p>
</li>
<li><p> no bisexuality, e.g., fathers most not appear as mothers
</p>
</li>
<li><p> father and/or mother can be unknown (missing) - defined with
any &quot;code&quot; that is different from existing identifications
</p>
</li></ul>

<p>Unknown (missing) values for breeding values are propagated down the
pedigree to provide all available values from genetic
evaluation. Another option is to cut pedigree links - set parents to
unknown and remove them from pedigree prior to using this function -
see <code><a href="#topic+pedSetBase">pedSetBase</a></code> function.  Warning is issued
in the case of unknown (missing) values.
</p>
<p>In animal breeding/genetics literature the model with the underlying
pedigree type <code>"IPP"</code> is often called animal model, while the
model for pedigree type <code>"IPG"</code> is often called sire - maternal
grandsire model. With a combination of <code>colFid</code> and
<code>colMid</code> mother - paternal grandsire model can be accomodated as
well.
</p>
<p>Argument <code>colBy</code> can be used to directly perform a summary
analysis by group, i.e., <code>summary(AlphaPart(...),
by="group")</code>. See <code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> for
more. This can save some CPU time by skipping intermediate
steps. However, only means can be obtained, while <code>summary</code>
method gives more flexibility.
</p>


<h3>Value</h3>

<p>An object of class <code>AlphaPart</code>, which can be used in
further analyses - there is a handy summary method
(<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> works on objects of
<code>AlphaPart</code> class) and a plot method for its output
(<code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code> works on objects of
<code>summaryAlphaPart</code> class).  Class <code>AlphaPart</code> is a
list. The first <code>length(colBV)</code> components (one for each trait
and named with trait label, say trt) are data frames. Each
data.frame contains:
</p>

<ul>
<li> <p><code>x</code> columns from initial data <code>x</code>
</p>
</li>
<li> <p><code>trt_pa</code> parent average
</p>
</li>
<li> <p><code>trt_w</code>Mendelian sampling term
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;trt_path1, trt_path2, ...&#8288;</code> breeding value partitions
</p>
</li></ul>

<p>The last component of returned object is also a list named
<code>info</code> with the following components holding meta information
about the analysis:
</p>

<ul>
<li> <p><code>path</code> column name holding path information
</p>
</li>
<li> <p><code>nP</code> number of paths
</p>
</li>
<li> <p><code>lP</code> path labels
</p>
</li>
<li> <p><code>nT</code> number of traits
</p>
</li>
<li> <p><code>lT</code> trait labels
</p>
</li>
<li> <p><code>warn</code> potential warning messages associated with this object
</p>
</li></ul>

<p>If <code>colBy!=NULL</code> the resulting object is of a class
<code>summaryAlphaPart</code>, see
<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> for details.
</p>
<p>If <code>profile=TRUE</code>, profiling info is printed on screen to spot
any computational bottlenecks.
</p>


<h3>References</h3>

<p>Garcia-Cortes, L. A. et al. (2008) Partition of the
genetic trend to validate multiple selection decisions. Animal,
2(6):821-824. doi: <a href="https://doi.org/10.1017/S175173110800205X">10.1017/S175173110800205X</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> for summary
method that works on output of <code>AlphaPart</code>,
<code><a href="#topic+pedSetBase">pedSetBase</a></code> for setting base population,
<code><a href="#topic+pedFixBirthYear">pedFixBirthYear</a></code> for imputing unknown
(missing) birth years, <code><a href="pedigree.html#topic+orderPed">orderPed</a></code> in
<span class="pkg">pedigree</span> package for sorting pedigree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small pedigree with additive genetic (=breeding) values
ped &lt;- data.frame(  id=c(  1,   2,   3,   4,   5,   6),
                   fid=c(  0,   0,   2,   0,   4,   0),
                   mid=c(  0,   0,   1,   0,   3,   3),
                   loc=c("A", "B", "A", "B", "A", "A"),
                   gen=c(  1,   1,   2,   2,   3,   3),
                  trt1=c(100, 120, 115, 130, 125, 125),
                  trt2=c(100, 110, 105, 100,  85, 110))

## Partition additive genetic values
tmp &lt;- AlphaPart(x=ped, colBV=c("trt1", "trt2"))
print(tmp)

## Summarize by generation (genetic mean)
summary(tmp, by="gen")

## Summarize by generation (genetic variance)
summary(tmp, by="gen", FUN = var)



## There are also two demos
  demo(topic="AlphaPart_deterministic", package="AlphaPart",
       ask=interactive())
  demo(topic="AlphaPart_stochastic",     package="AlphaPart",
       ask=interactive())

</code></pre>

<hr>
<h2 id='AlphaPart.ped'>Sample pedigree for partition.</h2><span id='topic+AlphaPart.ped'></span>

<h3>Description</h3>

<p>A dataset containing pedigree information and breeding values
for six individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaPart.ped
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 8 variables:
</p>

<dl>
<dt>IId</dt><dd><p>individual's ID</p>
</dd>
<dt>FId</dt><dd><p>Father's ID</p>
</dd>
<dt>MId</dt><dd><p>Mother's ID</p>
</dd>
<dt>gen</dt><dd><p>Generation</p>
</dd>
<dt>country</dt><dd><p>Country</p>
</dd>
<dt>gender</dt><dd><p>Individual's sex</p>
</dd>
<dt>bv1</dt><dd><p>Breeding value for trait 1</p>
</dd>
<dt>bv2</dt><dd><p>Breeding value for trait 1</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulation.
</p>

<hr>
<h2 id='AlphaPartSubset'>AlphaPartSubset.R</h2><span id='topic+AlphaPartSubset'></span>

<h3>Description</h3>

<p>A function to choose the partition paths to keep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaPartSubset(x, paths = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlphaPartSubset_+3A_x">x</code></td>
<td>
<p>AlphaPart or summaryAlphaPart, object from the <code>AlphaPart(...)</code> or <code>summary(AlphaPart(...), ...)</code> call.</p>
</td></tr>
<tr><td><code id="AlphaPartSubset_+3A_paths">paths</code></td>
<td>
<p>Character, names of paths to be kept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displaying results of partitions for many paths is often confusing.
This function helps in selecting only paths of interest.
Unspecified paths are removed from the input object <code>x</code>.
Meta information is modified accordingly. Default setting does nothing.
</p>


<h3>Value</h3>

<p>An object of class <code>AlphaPart</code> or <code>summaryAlphaPart</code> with only some paths.
Meta information in slot &quot;info&quot; is modified as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code> for the main method,
<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> for summary method that works on output of <code>AlphaPart</code>,
<code><a href="#topic+AlphaPartSum">AlphaPartSum</a></code> for sum method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small pedigree with additive genetic (=breeding) values
ped &lt;- data.frame(  id=c(  1,   2,   3,   4,   5,   6),
                  fid=c(  0,   0,   2,   0,   4,   0),
                  mid=c(  0,   0,   1,   0,   3,   3),
                  loc=c("A", "B", "A", "B", "A", "A"),
                  gen=c(  1,   1,   2,   2,   3,   3),
                 trt1=c(100, 120, 115, 130, 125, 125),
                 trt2=c(100, 110, 105, 100,  85, 110))

## Partition additive genetic values
(tmp &lt;- AlphaPart(x=ped, colBV=c("trt1", "trt2")))

## Keep some partitions (working on object of class AlphaPart)
(tmp2 &lt;- AlphaPartSubset(x=tmp, paths="A"))

## Summarize by generation
(tmpS &lt;- summary(tmp, by="gen"))

## Keep some partitions (working on object of class summaryAlphaPart)
(tmpS2 &lt;- AlphaPartSubset(x=tmpS, paths="A"))

## ... must be equal to
(tmpS3 &lt;- summary(tmp2, by="gen"))
</code></pre>

<hr>
<h2 id='AlphaPartSum'>AlphaPartSum.R</h2><span id='topic+AlphaPartSum'></span>

<h3>Description</h3>

<p>A function to sum partitions of several paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaPartSum(
  x,
  map = NULL,
  remove = TRUE,
  zeroPath = TRUE,
  call = "AlphaPartSum"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlphaPartSum_+3A_x">x</code></td>
<td>
<p>summaryAlphaPart, object from the <code>AlphaPart(...)</code> or <code>summary(AlphaPart(...), ...)</code> call.</p>
</td></tr>
<tr><td><code id="AlphaPartSum_+3A_map">map</code></td>
<td>
<p>List, a map of summing paths; see details and examples.</p>
</td></tr>
<tr><td><code id="AlphaPartSum_+3A_remove">remove</code></td>
<td>
<p>Logical, remove original paths or not.</p>
</td></tr>
<tr><td><code id="AlphaPartSum_+3A_zeropath">zeroPath</code></td>
<td>
<p>Logical, set called path to zero if it does not exist.</p>
</td></tr>
<tr><td><code id="AlphaPartSum_+3A_call">call</code></td>
<td>
<p>character, for internal use with <code>AlphaPartSubset</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes partitions of particular paths are very small or we want to sum
paths that have some similarity. These actions are easy to achive manually
but this functions provides a way to do this consistently with the given
object <code>x</code>.
</p>
<p>Arguments <code>map</code> must be a list of vectors of length at least
two. Vectors of length one are skipped. The idea is that the first element
is the new or existing path into which we add up all the remaining specified
paths, say <code>list(c("A", "B"), c("X", "X", "Y"), c("Z", "X"))</code> would
imply A = B, X = X + Y, and Z = X = X + Y. Note that once X is changed its
changed value is used in further calculations. Specify different (new) names
for new targets if you want to avoid this.
</p>
<p>Be carefull with <code>remove=TRUE</code>, which is the default setting, as all
partitions defined after the first (target/new) partition in vector in list
will be removed, for example with <code>list(c("A", "B"), c("X", "X", "Y"),
c("Z", "X"))</code> partitions B and Y will be removed, while X will not be removed
as it is defined as a target/new partition.
</p>


<h3>Value</h3>

<p>An object of class <code>AlphaPart</code> or <code>summaryAlphaPart</code> with modified partitions.
Meta information in slot &quot;info&quot; is modified as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code> for the main method,
<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> for summary method that works on output of <code>AlphaPart</code>,
<code><a href="#topic+AlphaPartSubset">AlphaPartSubset</a></code> for subset/keep method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small pedigree with additive genetic (=breeding) values
ped &lt;- data.frame(  id=c(  1,   2,   3,   4,   5,   6),
                  fid=c(  0,   0,   2,   0,   4,   0),
                  mid=c(  0,   0,   1,   0,   3,   3),
                  loc=c("A", "B", "A", "B", "A", "A"),
                  gen=c(  1,   1,   2,   2,   3,   3),
                 trt1=c(100, 120, 115, 130, 125, 125),
                 trt2=c(100, 110, 105,  140,  85, 110))

## Partition additive genetic values
(tmp &lt;- AlphaPart(x=ped, colBV=c("trt1", "trt2")))

## Sum some partitions (working on object of class AlphaPart)
(tmp2 &lt;- AlphaPartSum(x=tmp, map=list(c("X", "A", "B"), c("A", "B"))))

## Summarize by generation
(tmpS &lt;- summary(tmp, by="gen"))

## Sum some partitions (working on object of class summaryAlphaPart)
(tmpS2 &lt;- AlphaPartSum(x=tmpS, map=list(c("X", "A", "B"), c("A", "B"))))

## ... must be equal to
(tmpS3 &lt;- summary(tmp2, by="gen"))
</code></pre>

<hr>
<h2 id='centerPop'>Calculate parent average for base population.</h2><span id='topic+centerPop'></span>

<h3>Description</h3>

<p>This is an internally called functions used to calculate
parent average for base population.
</p>


<h3>Author(s)</h3>

<p>Thiago de Paula Oliveira
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='getScale'>Get scale information</h2><span id='topic+getScale'></span>

<h3>Description</h3>

<p>This is an internally called function
</p>


<h3>Author(s)</h3>

<p>Thiago de Paula Oliveira
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='mapLevels'>Mapping levels</h2><span id='topic+mapLevels'></span><span id='topic+mapLevels.default'></span><span id='topic+mapLevels.character'></span><span id='topic+mapLevels.list'></span><span id='topic+mapLevels.data.frame'></span><span id='topic+print.levelsMap'></span><span id='topic+print.listLevelsMap'></span><span id='topic+is.levelsMap'></span><span id='topic+is.listLevelsMap'></span><span id='topic+.checkLevelsMap'></span><span id='topic+.checkListLevelsMap'></span><span id='topic++22+5B.levelsMap+22'></span><span id='topic++22+5B.listLevelsMap+22'></span><span id='topic+c.levelsMap'></span><span id='topic+c.listLevelsMap'></span><span id='topic+unique.levelsMap'></span><span id='topic+sort.levelsMap'></span><span id='topic+mapLevels+3C-'></span><span id='topic+mapLevels+3C-.default'></span><span id='topic+mapLevels+3C-.factor'></span><span id='topic+mapLevels+3C-.character'></span><span id='topic+mapLevels+3C-.list'></span><span id='topic+mapLevels+3C-.data.frame'></span><span id='topic+mapLevels.factor'></span><span id='topic+.unlistLevelsMap'></span><span id='topic++5B.levelsMap'></span><span id='topic++5B.listLevelsMap'></span><span id='topic+.isCharacterMap'></span><span id='topic+as.levelsMap'></span><span id='topic+as.listLevelsMap'></span>

<h3>Description</h3>

<p><code>mapLevels</code> produces a map with information on levels and/or internal integer codes. As such can be conveniently used to store level mapping when one needs to work with internal codes of a factor and later transfrorm back to factor or when working with several factors that should have the same levels and therefore the same internal coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapLevels(x, codes=TRUE, sort=TRUE, drop=FALSE, combine=FALSE, ...)

mapLevels(x) &lt;- value

## Default S3 method:
mapLevels(x, codes, sort, drop, combine, ...)

## S3 method for class 'character'
mapLevels(x, codes, sort, drop, combine, ...)

## S3 method for class 'factor'
mapLevels(x, codes, sort, drop, combine, ...)

## S3 method for class 'list'
mapLevels(x, codes, sort, drop, combine, ...)

## S3 method for class 'data.frame'
mapLevels(x, codes, sort, drop, combine, ...)

.unlistLevelsMap(x, ind = FALSE)

## S3 method for class 'levelsMap'
print(x, ...)

## S3 method for class 'listLevelsMap'
print(x, ...)

## S3 method for class 'levelsMap'
x[i]

## S3 method for class 'listLevelsMap'
x[i]

is.levelsMap(x)

is.listLevelsMap(x)

.isCharacterMap(x)

as.levelsMap(x, check = TRUE, ...)

as.listLevelsMap(x, check = TRUE)

.checkLevelsMap(x, method)

.checkListLevelsMap(x, method)

## S3 method for class 'levelsMap'
c(..., sort = TRUE, recursive = FALSE)

## S3 method for class 'listLevelsMap'
c(..., sort = TRUE, recursive = FALSE)

## S3 method for class 'levelsMap'
sort(x, decreasing = FALSE, na.last = TRUE, ...)

## S3 method for class 'levelsMap'
unique(x, incomparables = FALSE, ...)

mapLevels(x) &lt;- value

## Default S3 replacement method:
mapLevels(x) &lt;- value

## S3 replacement method for class 'list'
mapLevels(x) &lt;- value

## S3 replacement method for class 'data.frame'
mapLevels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapLevels_+3A_x">x</code></td>
<td>
<p>object whose levels will be mapped, look into details <code>codes</code> boolean,
create integer levelsMap (with internal codes) or character levelsMap (with level names)</p>
</td></tr>
<tr><td><code id="mapLevels_+3A_codes">codes</code></td>
<td>
<p>boolean, create integer levelsMap (with internal codes) or character levelsMap (with level names)</p>
</td></tr>
<tr><td><code id="mapLevels_+3A_sort">sort</code></td>
<td>
<p>boolean, sort levels of character <code>x</code>, look into details</p>
</td></tr>
<tr><td><code id="mapLevels_+3A_drop">drop</code></td>
<td>
<p>boolean, drop unused levels</p>
</td></tr>
<tr><td><code id="mapLevels_+3A_combine">combine</code></td>
<td>
<p>boolean, combine levels, look into details</p>
</td></tr>
<tr><td><code id="mapLevels_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>sort</code></p>
</td></tr>
<tr><td><code id="mapLevels_+3A_value">value</code></td>
<td>
<p>levelsMap or listLevelsMap, output of <code>mapLevels</code> methods or constructed by user, look into details</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregor Gorjanc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='object.size'>Report the Space Allocated for Objects</h2><span id='topic+object.size'></span><span id='topic+c.object_sizes'></span><span id='topic+as.object_sizes'></span><span id='topic+is.object_sizes'></span><span id='topic+format.object_sizes'></span><span id='topic+print.object_sizes'></span>

<h3>Description</h3>

<p>Provides an estimate of the memory that is being used to store <code>R</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'object_sizes'
print(
  x,
  quote = FALSE,
  humanReadable = getOption("humanReadable"),
  standard = "IEC",
  units,
  digits = 1,
  width = NULL,
  sep = " ",
  justify = c("right", "left"),
  ...
)

## S3 method for class 'object_sizes'
format(
  x,
  humanReadable = getOption("humanReadable"),
  standard = "IEC",
  units,
  digits = 1,
  width = NULL,
  sep = " ",
  justify = c("right", "left"),
  ...
)

is.object_sizes(x)

as.object_sizes(x)

## S3 method for class 'object_sizes'
c(..., recursive = FALSE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='pedFixBirthYear'>pedFixBirthYear.R</h2><span id='topic+pedFixBirthYear'></span>

<h3>Description</h3>

<p>A function to fix (impute) missing birth years in pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedFixBirthYear(
  x,
  interval,
  down = FALSE,
  na.rm = TRUE,
  sort = TRUE,
  direct = TRUE,
  report = TRUE,
  colId = 1,
  colFid = 2,
  colMid = 3,
  colBY = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedFixBirthYear_+3A_x">x</code></td>
<td>
<p>data.frame , with (at least) the following columns: individual, father, and mother identification,
and year of birth; see arguments <code>colId</code>,
<code>colFid</code>, <code>colMid</code>, and <code>colBY</code></p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_interval">interval</code></td>
<td>
<p>Numeric, a value for generation interval in years.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_down">down</code></td>
<td>
<p>Logical, the default is to impute birth years based on the birth year of children
starting from the youngest to the oldest individuals, while with <code>down=TRUE</code>
birth year is imputed based on the birth year of parents in the opposite order.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, remove <code>NA</code> values when searching for the minimal (maximal) year of birth
in children (parents); setting this to <code>FALSE</code> can lead to decreased success of
imputation</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_sort">sort</code></td>
<td>
<p>Logical, initially sort <code>x</code> using <code>orderPed()</code> so that children follow
parents in order to make imputation as optimal as possible (imputation is performed
within a loop from the first to the last unknown birth year); at the end original
order is restored.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_direct">direct</code></td>
<td>
<p>Logical, insert inferred birth years immediately so they can be used for successive
individuals within the loop.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_report">report</code></td>
<td>
<p>Logical, report success.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_colid">colId</code></td>
<td>
<p>Numeric or character, position or name of a column holding individual identification.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_colfid">colFid</code></td>
<td>
<p>Numeric or character, position or name of a column holding father identification.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_colmid">colMid</code></td>
<td>
<p>Numeric or character, position or name of a column holding mother identification.</p>
</td></tr>
<tr><td><code id="pedFixBirthYear_+3A_colby">colBY</code></td>
<td>
<p>Numeric or character, position or name of a column holding birth year.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warnings are issued when there is no information to use to impute birth years or missing
values (<code>NA</code>) are propagated.
</p>
<p>Arguments <code>down</code> and <code>na.rm</code> allow for repeated use of this function, i.e., with
<code>down=FALSE</code> and with <code>down=TRUE</code> (both in combination with <code>na.rm=TRUE</code>) in order to
propagate information over the pedigree until &quot;convergence&quot;.
</p>
<p>This function can be very slow on large pedigrees with extensive missingness of birth years.
</p>


<h3>Value</h3>

<p>Object <code>x</code> with imputed birth years based on the birth year of children or parents.
If <code>report=TRUE</code> success is printed on the screen as the number of initially, fixed,
and left unknown birth years is printed.
</p>


<h3>See Also</h3>

<p><code><a href="pedigree.html#topic+orderPed">orderPed</a></code> in <span class="pkg">pedigree</span> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example pedigree with missing (unknown) birth year for some individuals
ped0 &lt;- data.frame(     id=c( 1, 2, 3,  4, 5, 6, 7,  8, 9, 10, 11, 12, 13, 14),
                        fid=c( 0, 0, 0,  1, 1, 1, 3,  3, 3,  5,  4,  0,  0, 12),
                        mid=c( 0, 0, 0,  2, 0, 2, 2,  2, 5,  0,  0,  0,  0, 13),
                        birth_dt=c(NA, 0, 1, NA, 3, 3, 3, 3, 4, 4, 5, NA, 6, 6) + 2000)

## First run - using information from children
ped1 &lt;- pedFixBirthYear(x=ped0, interval=1)

## Second run - using information from parents
ped2 &lt;- pedFixBirthYear(x=ped1, interval=1, down=TRUE)

## Third run - using information from children, but with no success
ped3 &lt;- pedFixBirthYear(x=ped2, interval=1)
</code></pre>

<hr>
<h2 id='pedSetBase'>pedSetBase.R</h2><span id='topic+pedSetBase'></span>

<h3>Description</h3>

<p>A function to set the base population in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedSetBase(
  x,
  keep = NULL,
  unknown = NA,
  report = TRUE,
  colId = 1,
  colFid = 2,
  colMid = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedSetBase_+3A_x">x</code></td>
<td>
<p>data.frame , with (at least) the following columns: individual, father, and mother identification,
and year of birth; see arguments <code>colId</code>,
<code>colFid</code>, <code>colMid</code>, and <code>colBY</code></p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_keep">keep</code></td>
<td>
<p>Logical, indicator that defines which individuals should stay in the
the pedigree; see details.</p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_unknown">unknown</code></td>
<td>
<p>Value used to represent unknown/missing identification</p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_report">report</code></td>
<td>
<p>Logical, report success.</p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_colid">colId</code></td>
<td>
<p>Numeric or character, position or name of a column holding individual identification.</p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_colfid">colFid</code></td>
<td>
<p>Numeric or character, position or name of a column holding father identification.</p>
</td></tr>
<tr><td><code id="pedSetBase_+3A_colmid">colMid</code></td>
<td>
<p>Numeric or character, position or name of a column holding mother identification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Base population in the pedigree is set by removing rows for some individuals, while their
presence as parents is also removed.
</p>
<p>Arguments <code>down</code> and <code>na.rm</code> allow for repeated use of this function, i.e., with
<code>down=FALSE</code> and with <code>down=TRUE</code> (both in combination with <code>na.rm=TRUE</code>) in order to
propagate information over the pedigree until &quot;convergence&quot;.
</p>
<p>This function can be very slow on large pedigrees with extensive missingness of birth years.
</p>


<h3>Value</h3>

<p>Object <code>x</code> with removed rows for some individuals and their presence as parents.
If <code>report=TRUE</code> progress is printed on the screen.
</p>


<h3>See Also</h3>

<p><code><a href="pedigree.html#topic+orderPed">orderPed</a></code> in <span class="pkg">pedigree</span> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example pedigree
ped &lt;- data.frame(      id=1:10,
                       fid=c(0, 0, 0, 1, 1, 1, 3, 3, 3, 5),
                       mid=c(0, 0, 0, 2, 0, 2, 2, 2, 5, 0),
                  birth_dt=c(0, 0, 1, 2, 3, 3, 3, 4, 4, 5) + 2000)

## Set base population as those individuals that were born after year 2002
pedSetBase(x=ped, keep=ped$birth_dt &gt; 2002, unknown=0)

</code></pre>

<hr>
<h2 id='plot.summaryAlphaPart'>A function to plot summary of partitioned breeding values.</h2><span id='topic+plot.summaryAlphaPart'></span>

<h3>Description</h3>

<p>A function to plot summary of partitioned breeding values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryAlphaPart'
plot(x, by, sortValue,
  sortValueFUN, sortValueDec, addSum, paths, xlab, ylab, xlim, ylim,
  color, lineSize, lineType, lineTypeList, useDirectLabels, method,
  labelPath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summaryAlphaPart_+3A_x">x</code></td>
<td>
<p>summaryAlphaPart, object from the <code>AlphaPart(...)</code> or
<code>summary(AlphaPart(...), ...)</code> call.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_by">by</code></td>
<td>
<p>Character, the name of a column by which summary function
FUN should be applied; if <code>NULL</code> (default) summary is given
for the whole table.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_sortvalue">sortValue</code></td>
<td>
<p>Logical, affect legend attributes via sort of paths
according to <code>sortValueFUN</code> function; if not logical, then
ordered paths are given as a character vector.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_sortvaluefun">sortValueFUN</code></td>
<td>
<p>Function, that produces single value for one
vector, say <code>mean</code> or <code>sum</code>.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_sortvaluedec">sortValueDec</code></td>
<td>
<p>Logical, sort decreasing.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_addsum">addSum</code></td>
<td>
<p>Logical, plot the overall trend.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_paths">paths</code></td>
<td>
<p>Character or list or characters, name of paths to plot;
if <code>NULL</code> plot all paths; see examples.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_xlab">xlab</code></td>
<td>
<p>Character, x-axis label.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_ylab">ylab</code></td>
<td>
<p>Character, y-axis label; can be a vector of several
labels if there are more traits in <code>x</code> (recycled!).</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_xlim">xlim</code></td>
<td>
<p>Numeric, a vector of two values with x-axis limits; use a
list of vectors for more traits.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_ylim">ylim</code></td>
<td>
<p>Numeric, a vector of two values with y-axis limits; use a
list of vectors for more traits.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_color">color</code></td>
<td>
<p>Character, color names; by default a set of 54 colors is
predefined from the <span class="pkg">RColorBrewer</span> package; in addition a black
colour is attached at the begining for the overall trend; if there
are more paths than colors then recycling occours.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_linesize">lineSize</code></td>
<td>
<p>Numeric, line width.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_linetype">lineType</code></td>
<td>
<p>Numeric, line type (recycled); can be used only if
lineTypeList=NULL.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_linetypelist">lineTypeList</code></td>
<td>
<p>List, named list of numeric values that help to
point out a set of paths (distinguished with line type) within
upper level of paths (distinguished by, color), e.g.,
lineTypeList=list(&quot;-1&quot;=1, &quot;-2&quot;=2, def=1) will lead to use of line
2, for paths having &quot;-2&quot; at the end of path name, while line type 1
(default) will, be used for other paths; specification of this
argument also causes recycling of colors for the upper level of
paths; if NULL all lines have a standard line type, otherwise
<code>lineType</code> does not have any effect.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_usedirectlabels">useDirectLabels</code></td>
<td>
<p>Logical, use directlabels package for legend.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_method">method</code></td>
<td>
<p>List, method for direct.label.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_labelpath">labelPath</code></td>
<td>
<p>Character, legend title; used only if
<code>useDirectLabels=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.summaryAlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions (not used at the
moment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information in summaries of partitions of breeding values
can be overhelming due to a large volume of numbers. Plot method
can be used to visualise this data in eye pleasing way using
ggplot2 graphics.
</p>


<h3>Value</h3>

<p>A list of ggplot objects that can be further modified or
displayed.  For each trait in <code>x</code> there is one plot
visualising summarized values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Partition additive genetic values by country
(res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2")))

## Summarize population by generation (=trend)
(ret &lt;- summary(res, by="gen"))

## Plot the partitions
p &lt;- plot(ret, ylab=c("bv for trait 1", "bv for trait 2"), xlab="Generation")
print(p[[1]]$abs)
print(p[[2]]$abs)
print(p)

## Partition additive genetic values by country and sex
AlphaPart.ped$country.gender &lt;- with(AlphaPart.ped, paste(country, gender, sep="-"))
(res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country.gender", colBV=c("bv1", "bv2")))

## Summarize population by generation (=trend)
(ret &lt;- summary(res, by="gen"))

## Plot the partitions
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation")
print(p)
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation",
        lineTypeList=list("-1"=1, "-2"=2, def=3))
print(p)
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation",
        lineTypeList=list("-1"=1, "-2"=2, def=3), useGgplot2=FALSE, useDirectLabels = FALSE)
print(p)

## Plot control (color and type of lines + limits)
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation",
        useGgplot2=TRUE, color=c("green", "gray"), lineType=c(2, 3),
        sortValue=FALSE, lineSize=4,
        xlim=c(-1, 7))
print(p)

</code></pre>

<hr>
<h2 id='print.AlphaPart'>Print method for the output of AlphaPart function.</h2><span id='topic+print.AlphaPart'></span>

<h3>Description</h3>

<p>Partitioning of breeding values if often performed on
quite large datasets, which quickly fills in the whole
screen. Print method therefore prints out paths, number of
individuals and the first and the last few lines for each trait to
quickly see what kind of data is in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AlphaPart'
print(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.AlphaPart_+3A_x">x</code></td>
<td>
<p>AlphaPart, output object from
<code><a href="#topic+AlphaPart">AlphaPart</a></code> function.</p>
</td></tr>
<tr><td><code id="print.AlphaPart_+3A_n">n</code></td>
<td>
<p>Integer, number of the first and last rows in <code>x</code> to
print out using <code><a href="utils.html#topic+head">head</a></code> and <code><a href="utils.html#topic+tail">tail</a></code>.</p>
</td></tr>
<tr><td><code id="print.AlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>print</code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small pedigree with additive genetic (=breeding) values
ped &lt;- data.frame(  id=c(  1,   2,   3,   4,   5,   6),
                   fid=c(  0,   0,   2,   0,   4,   0),
                   mid=c(  0,   0,   1,   0,   3,   3),
                   loc=c("A", "B", "A", "B", "A", "A"),
                   gen=c(  1,   1,   2,   2,   3,   3),
                  trt1=c(100, 120, 115, 130, 125, 125),
                  trt2=c(100, 110, 105, 100,  85, 110))

## Partition additive genetic values
tmp &lt;- AlphaPart(x=ped, colBV=c("trt1", "trt2"))
print(tmp)

## Summarize by generation (genetic mean)
summary(tmp, by="gen")

## Summarize by generation (genetic variance)
summary(tmp, by="gen", FUN = var)



## There are also two demos
  demo(topic="AlphaPart_deterministic", package="AlphaPart",
       ask=interactive())
  demo(topic="AlphaPart_stochastic",     package="AlphaPart",
       ask=interactive())

</code></pre>

<hr>
<h2 id='print.plotSummaryAlphaPart'>Print a plot generate by the function
<code>plotSummaryAlphaPart</code></h2><span id='topic+print.plotSummaryAlphaPart'></span>

<h3>Description</h3>

<p>Plot output object from
<code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plotSummaryAlphaPart'
print(x, ask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plotSummaryAlphaPart_+3A_x">x</code></td>
<td>
<p>plotSummaryAlphaPart, output object from
<code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code> function</p>
</td></tr>
<tr><td><code id="print.plotSummaryAlphaPart_+3A_ask">ask</code></td>
<td>
<p>Logical, ask before printing another plot?</p>
</td></tr>
<tr><td><code id="print.plotSummaryAlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions (not used at the
moment).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Partition additive genetic values
(res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2")))

## Summarize population by generation (=trend)
(ret &lt;- summary(res, by="gen"))

## Plot the partitions
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation")
print(p[[1]])
print(p[[2]])
#print(p)
</code></pre>

<hr>
<h2 id='print.summaryAlphaPart'>Print method for objects of the class summaryAlphaPart.</h2><span id='topic+print.summaryAlphaPart'></span>

<h3>Description</h3>

<p>Print method for objects of the class
<code>summaryAlphaPart</code> (result of <code>summary(AlphaPart(...))</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryAlphaPart'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summaryAlphaPart_+3A_x">x</code></td>
<td>
<p>summaryAlphaPart, output object from
<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> function.</p>
</td></tr>
<tr><td><code id="print.summaryAlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions (not used at the
moment).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Partition additive genetic values by loc ---
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2"))

## Summarize whole population
ret &lt;- summary(res)

## Summarize population by generation (=trend)
ret &lt;- summary(res, by="gen")

## Summarize population by generation (=trend) but only for domestic location
ret &lt;- summary(res, by="gen", subset=res[[1]]$country == "domestic")

## --- Partition additive genetic values by loc and gender ---

AlphaPart.ped$country.gender &lt;- with(AlphaPart.ped, paste(country, gender, sep="-"))
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country.gender", colBV=c("bv1", "bv2"))

## Summarize population by generation (=trend)
ret &lt;- summary(res, by="gen")

## Summarize population by generation (=trend) but only for domestic location
ret &lt;- summary(res, by="gen", subset=res[[1]]$country == "domestic")
</code></pre>

<hr>
<h2 id='savePlot'>Save plot method for <code>AlphaPart</code></h2><span id='topic+savePlot'></span>

<h3>Description</h3>

<p>Save plot method for <code>AlphaPart</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savePlot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="savePlot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>type</code> specific methods, say
<code>width</code> and <code>height</code> for <code>type="pdf"</code> etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Beside the side effect of saving plots to disk, filenames are printed on
screen during the process and at the end invisibly returned.
</p>

<hr>
<h2 id='savePlot.plotSummaryAlphaPart'>Save plot objects on the disk for permanent storage. Function
<code><a href="grDevices.html#topic+savePlot">savePlot</a></code> from the <span class="pkg">grDevices</span> package
works for current page on graphical device. This is an attempt to
make this function generic so that one can define <code>savePlot</code>
methods for particular needs.</h2><span id='topic+savePlot.plotSummaryAlphaPart'></span><span id='topic+savePlot.default'></span>

<h3>Description</h3>

<p>Save plot objects of class
<code>plotSummaryAlphaPart</code> on the disk for permanent storage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plotSummaryAlphaPart'
savePlot(x, filename, type,
  device, pre.hook, traitsAsDir, ...)

## Default S3 method:
savePlot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_x">x</code></td>
<td>
<p>Object on which to chose savePLot method.</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_filename">filename</code></td>
<td>
<p>Character, filename to save to.</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_type">type</code></td>
<td>
<p>Character, file/device type.</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_device">device</code></td>
<td>
<p>Device, the device to save from.</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_pre.hook">pre.hook</code></td>
<td>
<p>Function, call some code before calling print method for plots (see examples).</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_traitsasdir">traitsAsDir</code></td>
<td>
<p>Logical, should plots be saved within trait folders; the construction is
<code>file.path(dirname(file), trait, basename(file))</code>.
folders are created if they do not exist.</p>
</td></tr>
<tr><td><code id="savePlot.plotSummaryAlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>type</code> specific methods, say
<code>width</code> and <code>height</code> for <code>type="pdf"</code> etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Beside the side effect of saving plots to disk, filenames are printed on
screen during the process and at the end invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+savePlot">savePlot</a></code> help page on the default <code>savePlot</code>
method in the <span class="pkg">grDevices</span> package; <code><a href="#topic+savePlot.plotSummaryAlphaPart">savePlot.plotSummaryAlphaPart</a></code>
help page on the method for the objects of <code>plotSummaryAlphaPart</code> class; and
<code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code> for ploting results of summaryAlphaPart object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Partition additive genetic values
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2"))

## Summarize population by generation (=trend)
ret &lt;- summary(res, by="gen")

## Plot the partitions
p &lt;- plot(ret, ylab=c("BV for trait 1", "BV for trait 2"), xlab="Generation")

## Save the plots
tmp &lt;- savePlot(x = p, filename="test", type="png")

## Remove the files
unlink(tmp)

</code></pre>

<hr>
<h2 id='sEBV'>Scale EBVs for objects of the class summaryAlphaPart.</h2><span id='topic+sEBV'></span>

<h3>Description</h3>

<p>This is an internally called functions used to Scale
EBVs in respect to base population for objects of the class
<code>AlphaPart</code>.
</p>


<h3>Author(s)</h3>

<p>Thiago de Paula Oliveira
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='summary.AlphaPart'>A function to summarize AlphaPart object.</h2><span id='topic+summary.AlphaPart'></span>

<h3>Description</h3>

<p>Breedng values of individuals are often summarized,
either by year of birth or some other classification. Function
<code>summary.AlphaPart</code> provides a way to ease the computation of
such summaries on partitions of breeding values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AlphaPart'
summary(object, by, FUN, labelSum, subset,
  sums, cov,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.AlphaPart_+3A_object">object</code></td>
<td>
<p>AlphaPart, output object from
<code><a href="#topic+AlphaPart">AlphaPart</a></code> function.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_by">by</code></td>
<td>
<p>Character, the name of a column by which summary function
FUN should be applied; if <code>NULL</code> (default) summary is given
for the whole table.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_fun">FUN</code></td>
<td>
<p>Function, which function should be used in summary;
function should return single value per each level of by.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_labelsum">labelSum</code></td>
<td>
<p>Character, label used for the overall breeding value.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_subset">subset</code></td>
<td>
<p>Logical, perform summary only on a subset of
<code>object</code> subsetted by this argument.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_sums">sums</code></td>
<td>
<p>Logical, link between <code><a href="#topic+AlphaPart">AlphaPart</a></code>
and <code>summary.AlphaPart()</code> (only for internal use!).</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_cov">cov</code></td>
<td>
<p>Logical, if FALSE returns <code>n</code> variances plus one
additional column containing two times the sum of all covariances;
otherwise returns <code>n</code> variance and <code>n(n-1)/2</code> covariances
in the form of <code>2*Cov(., .)</code>, where <code>n</code> is the number of
partitions. This argument only works when <code>FUN = var</code>. Defaut
<code>cov = FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.AlphaPart_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions (not used at the
moment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summaryAlphaPart</code>, which is a list
of data frames with summary statistics on breeding value
partitions. For each trait there a dataframe holds summary for the
&quot;whole/original&quot; breeding value and its partitions.  In addition
another list is added (named <code>info</code>) with the following
components holdinfg meta info:
</p>

<ul>
<li> <p><code>path</code> column name holding path information
</p>
</li>
<li> <p><code>nP</code> number of paths
</p>
</li>
<li> <p><code>lP</code> path labels
</p>
</li>
<li> <p><code>nT</code> number of traits
</p>
</li>
<li> <p><code>lT</code> trait labels
</p>
</li>
<li> <p><code>by</code> column name of variable by which summary was performed
</p>
</li>
<li> <p><code>warn</code> potential warning messages associated with this object
</p>
</li>
<li> <p><code>labelSum</code> column name of summary for &quot;whole/original&quot; breeding values
</p>
</li></ul>

<p>There is a handy plot method (<code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code>) for output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code> for partitioning breeding
values, <code><a href="#topic+plot.summaryAlphaPart">plot.summaryAlphaPart</a></code> for plotting
output of summary method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Partition additive genetic values by loc ---
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2"))

## Summarize whole population
ret &lt;- summary(res)

## Summarize population by generation (=trend)
ret &lt;- summary(res, by="gen")

## Summarize population by generation (=trend) but only for domestic location
ret &lt;- summary(res, by="gen", subset=res[[1]]$country == "domestic")

## --- Partition additive genetic values by loc and gender ---

AlphaPart.ped$country.gender &lt;- with(AlphaPart.ped, paste(country, gender, sep="-"))
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country.gender", colBV=c("bv1", "bv2"))

## Summarize population by generation (=trend)
ret &lt;- summary(res, by="gen")

## Summarize population by generation (=trend) but only for domestic location
ret &lt;- summary(res, by="gen", subset=res[[1]]$country == "domestic")
</code></pre>

<hr>
<h2 id='UnknownFuns'>Change given unknown value to NA and vice versa.</h2><span id='topic+UnknownFuns'></span><span id='topic+isUnknown'></span><span id='topic+isUnknown.default'></span><span id='topic+isUnknown.POSIXlt'></span><span id='topic+isUnknown.list'></span><span id='topic+isUnknown.data.frame'></span><span id='topic+isUnknown.matrix'></span><span id='topic+unknownToNA'></span><span id='topic+unknownToNA.default'></span><span id='topic+unknownToNA.factor'></span><span id='topic+unknownToNA.list'></span><span id='topic+unknownToNA.data.frame'></span><span id='topic+NAToUnknown'></span><span id='topic+NAToUnknown.default'></span><span id='topic+NAToUnknown.factor'></span><span id='topic+NAToUnknown.list'></span><span id='topic+NAToUnknown.data.frame'></span><span id='topic+.unknownList'></span>

<h3>Description</h3>

<p>Unknown or missing values (<code>NA</code> in <code>R</code>) can be represented in various ways (as 0, 999, etc.) in different programs. <code>isUnknown</code>, <code>unknownToNA</code>, and <code>NAToUnknown</code> can help to change unknown values to <code>NA</code> and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUnknown(x, unknown=NA, ...)

unknownToNA(x, unknown, warning=FALSE, ...)

NAToUnknown(x, unknown, force=FALSE, call.=FALSE, ...)

## Default S3 method:
isUnknown(x, unknown, ...)

## S3 method for class 'POSIXlt'
isUnknown(x, unknown, ...)

## S3 method for class 'list'
isUnknown(x, unknown, ...)

## S3 method for class 'data.frame'
isUnknown(x, unknown, ...)

## S3 method for class 'matrix'
isUnknown(x, unknown, ...)

unknownToNA(x, unknown, warning = FALSE, ...)

## Default S3 method:
unknownToNA(x, unknown, warning, ...)

## S3 method for class 'factor'
unknownToNA(x, unknown, warning, ...)

## S3 method for class 'list'
unknownToNA(x, unknown, warning, ...)

## S3 method for class 'data.frame'
unknownToNA(x, unknown, warning, ...)

NAToUnknown(x, unknown, force = FALSE, call. = FALSE, ...)

## Default S3 method:
NAToUnknown(x, unknown, force, call., ...)

## S3 method for class 'factor'
NAToUnknown(x, unknown, force, call., ...)

## S3 method for class 'list'
NAToUnknown(x, unknown, force, call., ...)

## S3 method for class 'data.frame'
NAToUnknown(x, unknown, force, call., ...)

.unknownList(x, unknown)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnknownFuns_+3A_x">x</code></td>
<td>
<p>generic, object with unknown value(s)</p>
</td></tr>
<tr><td><code id="UnknownFuns_+3A_unknown">unknown</code></td>
<td>
<p>generic, value used instead of <code>NA</code></p>
</td></tr>
<tr><td><code id="UnknownFuns_+3A_...">...</code></td>
<td>
<p>arguments pased to other methods (as.character for POSIXlt in case of isUnknown)</p>
</td></tr>
<tr><td><code id="UnknownFuns_+3A_warning">warning</code></td>
<td>
<p>logical, issue warning if <code>x</code> already has <code>NA</code></p>
</td></tr>
<tr><td><code id="UnknownFuns_+3A_force">force</code></td>
<td>
<p>logical, force to apply already existing value in <code>x</code></p>
</td></tr>
<tr><td><code id="UnknownFuns_+3A_call.">call.</code></td>
<td>
<p>logical, look in <code><a href="base.html#topic+warning">warning</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregor Gorjanc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AlphaPart">AlphaPart</a></code>
</p>

<hr>
<h2 id='write.csv'>write.csv.R</h2><span id='topic+write.csv'></span><span id='topic+write.csv.default'></span><span id='topic+write.csv.AlphaPart'></span><span id='topic+write.csv.summaryAlphaPart'></span>

<h3>Description</h3>

<p>Save summaries of partitioned breeding values to CSV files on disk for further
analyses of processing with other software or just for saving (backing up)
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.csv(...)

## Default S3 method:
write.csv(...)

## S3 method for class 'AlphaPart'
write.csv(x, file, traitsAsDir = FALSE, csv2 = TRUE, row.names = FALSE, ...)

## S3 method for class 'summaryAlphaPart'
write.csv(x, file, traitsAsDir = FALSE, csv2 = TRUE, row.names = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.csv_+3A_...">...</code></td>
<td>
<p>Other options passed to <code><a href="utils.html#topic+write.csv2">write.csv2</a></code> or <code><a href="utils.html#topic+write.csv">write.csv</a></code>.</p>
</td></tr>
<tr><td><code id="write.csv_+3A_x">x</code></td>
<td>
<p>AlphaPart, object returned from <code><a href="#topic+AlphaPart">AlphaPart</a></code> function or
summaryAlphaPart, object returned from <code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> function.</p>
</td></tr>
<tr><td><code id="write.csv_+3A_file">file</code></td>
<td>
<p>Character, file name with or without .csv extension, e.g., both &quot;file&quot; and &quot;file.csv&quot; are valid.</p>
</td></tr>
<tr><td><code id="write.csv_+3A_traitsasdir">traitsAsDir</code></td>
<td>
<p>Logical, should results be saved within trait folders;
the construction is <code>file.path(dirname(file), trait, basename(file))</code>;
folders are created if they do not exist.</p>
</td></tr>
<tr><td><code id="write.csv_+3A_csv2">csv2</code></td>
<td>
<p>Logical, export using <code><a href="utils.html#topic+write.csv2">write.csv2</a></code> or <code><a href="utils.html#topic+write.csv">write.csv</a></code>.</p>
</td></tr>
<tr><td><code id="write.csv_+3A_row.names">row.names</code></td>
<td>
<p>Logical, export row names as well?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="utils.html#topic+write.csv">write.csv</a></code> from the <span class="pkg">utils</span> package works
when exported object is a <code><a href="base.html#topic+data.frame">data.frame</a></code> or a
<code><a href="base.html#topic+matrix">matrix</a></code>. This is an attempt to make this function generic
so that one can define <code>write.csv</code> methods for other objects.
</p>


<h3>Value</h3>

<p>It contains:
</p>

<ul>
<li> <p><code>write.csv</code> - see <code><a href="utils.html#topic+write.csv">write.csv</a></code> for details.
</p>
</li>
<li> <p><code>write.csv.AlphaPart</code> - for each trait (list component in <code>x</code>) a file
is saved on disk with name &quot;AlphaPart_trait.csv&quot;, where the file will hold
original data and breeding value partitions. With <code>traitsAsDir=TRUE</code>
files are saved as &quot;trait/file_trait.csv&quot;. File names are printed on screen
during the process of export and at the end invisibly returned.
</p>
</li>
<li> <p><code>write.csv.summaryAlphaPart</code> - for each trait (list component in <code>x</code>)
a file partitions named &quot;file_trait.csv&quot; is saved on disk. With
<code>traitsAsDir=TRUE</code> files are saved as &quot;trait/file_trait_*.csv&quot;. File
names are printed on screen during the process of export and at the end
invisibly returned.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default <code>write.csv</code> method.
</p>
</li>
<li> <p><code>AlphaPart</code>: Save partitioned breeding values to CSV files on disk on disk for further
analyses or processing with other software or just for saving (backing up)
results.
</p>
</li>
<li> <p><code>summaryAlphaPart</code>: Save summaries of partitioned breeding values to CSV files on disk for further
analyses of processing with other software or just for saving (backing up)
results.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.csv">write.csv</a></code> help page on the default <code>write.csv</code> and <code>write.csv2</code>
methods in the <span class="pkg">utils</span> package;
<code><a href="#topic+summary.AlphaPart">summary.AlphaPart</a></code> and <code><a href="#topic+AlphaPart">AlphaPart</a></code>
help pages on the objects of <code>summaryAlphaPart</code> and <code>AlphaPart</code> classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Partition additive genetic values
res &lt;- AlphaPart(x=AlphaPart.ped, colPath="country", colBV=c("bv1", "bv2"))

## Write summary on the disk and collect saved file names
fileName &lt;- file.path(tempdir(), "AlphaPart")
ret &lt;- write.csv(x=res, file=fileName)
print(ret)
file.show(ret[1])

## Clean up
files &lt;- dir(path=tempdir(), pattern="AlphaPart*")
unlink(x=files)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
