<!DOCTYPE html><html><head><title>Help for package adproclus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adproclus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adproclus-package'><p>adproclus: Additive Profile Clustering Algorithms</p></a></li>
<li><a href='#adpc'><p>Constructor for a (low dimensional) ADPROCLUS solution object</p></a></li>
<li><a href='#adproclus'><p>Additive profile clustering</p></a></li>
<li><a href='#adproclus_low_dim'><p>Low dimensional ADPROCLUS</p></a></li>
<li><a href='#CGdata'><p>Randomly generated data with underlying overlapping clusters.</p></a></li>
<li><a href='#get_random'><p>Generate initial random start</p></a></li>
<li><a href='#get_rational'><p>Generate start allocation based on a priori profiles</p></a></li>
<li><a href='#get_semirandom'><p>Generate initial semi-random start</p></a></li>
<li><a href='#plot_cluster_network'><p>Network plot of a (low dimensional) ADPROCLUS solution</p></a></li>
<li><a href='#plot_profiles'><p>Plot profile matrix of ADPROCLUS solution</p></a></li>
<li><a href='#plot_vars_by_comp'><p>Plot variable to component matrix of ADPROCLUS solution</p></a></li>
<li><a href='#plot.adpc'><p>Plotting a (low dimensional) ADPROCLUS solution</p></a></li>
<li><a href='#print.adpc'><p>Print basic information on ADPROCLUS solution</p></a></li>
<li><a href='#print.summary.adpc'><p>Print (low dimensional) ADPROCLUS summary</p></a></li>
<li><a href='#summary.adpc'><p>Summary of ADPROCLUS solution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Additive Profile Clustering Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Obtain overlapping clustering models for object-by-variable data
        matrices using the Additive Profile Clustering (ADPROCLUS) method. 
        Also contains the low dimensional ADPROCLUS method 
        for simultaneous dimension reduction and overlapping clustering. 
        For reference see Depril, Van Mechelen, Mirkin (2008) 
        &lt;<a href="https://doi.org/10.1016%2Fj.csda.2008.04.014">doi:10.1016/j.csda.2008.04.014</a>&gt; and Depril, Van Mechelen, Wilderjans 
        (2012) &lt;<a href="https://doi.org/10.1007%2Fs00357-012-9112-5">doi:10.1007/s00357-012-9112-5</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, corrplot, gtools, igraph, NMFN, qgraph, stats,
withr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adproclus-package.R' 'adproclus_classes.R' 'clustering.R'
'data.R' 'get_starts.R' 'utils.R' 'visualize.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/henry-heppe/adproclus">https://github.com/henry-heppe/adproclus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/henry-heppe/adproclus/issues">https://github.com/henry-heppe/adproclus/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-09 20:56:50 UTC; a1224</td>
</tr>
<tr>
<td>Author:</td>
<td>Henry Heppe [aut, cre, cph],
  Julian Rossbroich [aut],
  Jeffrey Durieux [aut],
  Tom Wilderjans [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henry Heppe &lt;heppe.henry@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 23:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adproclus-package'>adproclus: Additive Profile Clustering Algorithms</h2><span id='topic+adproclus-package'></span>

<h3>Description</h3>

<p>Obtain overlapping clustering models for object-by-variable data matrices using the Additive Profile Clustering (ADPROCLUS) method. Also contains the low dimensional ADPROCLUS method for simultaneous dimension reduction and overlapping clustering. For reference see Depril, Van Mechelen, Mirkin (2008) <a href="https://doi.org/10.1016/j.csda.2008.04.014">doi:10.1016/j.csda.2008.04.014</a> and Depril, Van Mechelen, Wilderjans (2012) <a href="https://doi.org/10.1007/s00357-012-9112-5">doi:10.1007/s00357-012-9112-5</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Henry Heppe <a href="mailto:heppe.henry@gmail.com">heppe.henry@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Julian Rossbroich
</p>
</li>
<li><p> Jeffrey Durieux
</p>
</li>
<li><p> Tom Wilderjans
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/henry-heppe/adproclus">https://github.com/henry-heppe/adproclus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/henry-heppe/adproclus/issues">https://github.com/henry-heppe/adproclus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adpc'>Constructor for a (low dimensional) ADPROCLUS solution object</h2><span id='topic+adpc'></span>

<h3>Description</h3>

<p>Yields an object of class <code>adpc</code>, which can be printed, plotted and
summarized by the corresponding methods. Mandatory input are the membership
matrix <code class="reqn">A</code> and the profile matrix <code class="reqn">P</code>
(where the number of columns from <code class="reqn">A</code> corresponds to
the number of rows in <code class="reqn">P</code>),
if the object is to represent a full dimensional ADPROCLUS model.
For a low dimensional ADPROCLUS model, the matrices <code class="reqn">C</code>
and <code class="reqn">B</code> have to be provided and <code class="reqn">P</code> can
be inferred from those. All other inputs are optional but may be included
so that the output from the <code>summary(), print(), plot()</code> is complete.
For further details on the (low dimensional) ADPROCLUS model and
what every element of the objects means
see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adpc(
  A,
  P,
  sse = NULL,
  totvar = NULL,
  explvar = NULL,
  iterations = NULL,
  timer = NULL,
  timer_one_run = NULL,
  initial_start = NULL,
  C = NULL,
  B = NULL,
  runs = NULL,
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adpc_+3A_a">A</code></td>
<td>
<p>Membership matrix A.</p>
</td></tr>
<tr><td><code id="adpc_+3A_p">P</code></td>
<td>
<p>Profile matrix P.</p>
</td></tr>
<tr><td><code id="adpc_+3A_sse">sse</code></td>
<td>
<p>Sum of Squared Error.</p>
</td></tr>
<tr><td><code id="adpc_+3A_totvar">totvar</code></td>
<td>
<p>Total variance.</p>
</td></tr>
<tr><td><code id="adpc_+3A_explvar">explvar</code></td>
<td>
<p>Explained variance.</p>
</td></tr>
<tr><td><code id="adpc_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="adpc_+3A_timer">timer</code></td>
<td>
<p>Time needed to run the complete algorithm.</p>
</td></tr>
<tr><td><code id="adpc_+3A_timer_one_run">timer_one_run</code></td>
<td>
<p>Time to complete this single algorithm start.</p>
</td></tr>
<tr><td><code id="adpc_+3A_initial_start">initial_start</code></td>
<td>
<p>List containing type of start and
<code>start_allocation</code> matrix.</p>
</td></tr>
<tr><td><code id="adpc_+3A_c">C</code></td>
<td>
<p>Low dimensional profiles matrix C.</p>
</td></tr>
<tr><td><code id="adpc_+3A_b">B</code></td>
<td>
<p>Matrix of base vectors connecting low dimensional components with
original variables B.</p>
</td></tr>
<tr><td><code id="adpc_+3A_runs">runs</code></td>
<td>
<p>List of suboptimal models.</p>
</td></tr>
<tr><td><code id="adpc_+3A_parameters">parameters</code></td>
<td>
<p>List of algorithm parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create the information needed for a minimal object of class adpc
x &lt;- stackloss
result &lt;- adproclus(x, 3)
A &lt;- result$A
P &lt;- result$P

# Use constructor to obtain object of class adpc
result_object &lt;- adpc(A, P)

</code></pre>

<hr>
<h2 id='adproclus'>Additive profile clustering</h2><span id='topic+adproclus'></span>

<h3>Description</h3>

<p>Perform additive profile clustering (ADPROCLUS) on object-by-variable data.
Creates a model that assigns the objects to overlapping clusters which are
characterized in terms of the variables by the so-called profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adproclus(
  data,
  nclusters,
  start_allocation = NULL,
  nrandomstart = 3,
  nsemirandomstart = 3,
  algorithm = "ALS1",
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adproclus_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional matrix of binary values as starting
allocation for first run. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts (see <code><a href="#topic+get_random">get_random</a></code>).
Can be zero. Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts
(see <code><a href="#topic+get_semirandom">get_semirandom</a></code>)). Can be zero. Increase for better
results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string &quot;<code>ALS1</code>&quot; (default) or &quot;<code>ALS2</code>&quot;,
denoting the type of alternating least squares algorithm. Can be
abbreviated with &quot;1&quot; or &quot;2&quot;.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the results of all algorithm
starts are returned. By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, Mirkin's (1987, 1990) Additive Profile Clustering
(ADPROCLUS) method is used to obtain an unrestricted overlapping clustering
model of the object by variable data provided by <code>data</code>.
</p>
<p>The ADPROCLUS model approximates an <code class="reqn">I \times J</code> object by
variable data matrix <code class="reqn">X</code> by an <code class="reqn">I \times J</code> model matrix
<code class="reqn">M</code> that can be decomposed into an <code class="reqn">I \times K</code> binary
cluster membership matrix <code class="reqn">A</code> and a <code class="reqn">K \times J</code>
real-valued cluster profile matrix <code class="reqn">P</code>, with <code class="reqn">K</code>
indicating the number of overlapping clusters.
In particular, the aim of an ADPROCLUS analysis is therefore,
given a number of clusters <code class="reqn">K</code>, to estimate a
model matrix <code class="reqn">M = AP</code> which reconstructs the data matrix
<code class="reqn">X</code> as close as possible in a least squares sense
(i.e. sum of squared residuals). For a detailed illustration of the
ADPROCLUS model and associated loss function, see Wilderjans et al. (2011).
</p>
<p>The alternating least squares algorithms (&quot;<code>ALS1</code>&quot; and &quot;<code>ALS2</code>&quot;)
that can be used for minimization of the loss function were proposed by
Depril et al. (2008). In &quot;<code>ALS2</code>&quot;, starting from an initial random or
rational estimate of <code class="reqn">A</code> (see <code><a href="#topic+get_random">get_random</a></code> and
<code><a href="#topic+get_semirandom">get_semirandom</a></code>), <code class="reqn">A</code> and <code class="reqn">P</code>
are alternately re-estimated conditionally upon each other until convergence.
The &quot;<code>ALS1</code>&quot; algorithm differs from the previous one in that each
row in <code class="reqn">A</code> is updated independently and that the
conditionally optimal <code class="reqn">P</code> is recalculated after each row
update, instead of the end of the matrix. For a discussion and comparison of
the different algorithms, see Depril et al., 2008.
</p>
<p><strong>Warning:</strong> Computation time increases exponentially with increasing
number of clusters, <code class="reqn">K</code>. We recommend to determine the computation time
of a single start for each specific dataset and <code class="reqn">K</code> before increasing the
number of starts.
</p>


<h3>Value</h3>

<p><code>adproclus()</code> returns a list with the following
components, which describe the best model (from the multiple starts):
</p>

<dl>
<dt><code>model</code></dt><dd><p>matrix. The obtained overlapping clustering model
<strong>M</strong> of the same size as <code>data</code>.</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix. The membership matrix <strong>A</strong> of the clustering
model. Clusters are sorted by size.</p>
</dd>
<dt><code>P</code></dt><dd><p>matrix. The profile matrix
<strong>P</strong> of the clustering model.</p>
</dd>
<dt><code>sse</code></dt><dd><p>numeric. The
residual sum of squares of the clustering model, which is minimized by the
ALS algorithm.</p>
</dd>
<dt><code>totvar</code></dt><dd><p>numeric. The total sum of squares
of <code>data</code>.</p>
</dd>
<dt><code>explvar</code></dt><dd><p>numeric. The proportion of variance
in <code>data</code> that is accounted for by the clustering model.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>numeric. The number of iterations of the
algorithm.</p>
</dd>
<dt><code>timer</code></dt><dd><p>numeric. The amount of time (in seconds) the complete
algorithm ran for.</p>
</dd>
<dt><code>timer_one_run</code></dt><dd><p>numeric. The amount of time (in seconds) the
relevant single start ran for.</p>
</dd>
<dt><code>initial_start</code></dt><dd><p>list. Containing the initial
membership matrix, as well as the type of start that was used
to obtain the clustering solution. (as returned by <code><a href="#topic+get_random">get_random</a></code>
or <code><a href="#topic+get_semirandom">get_semirandom</a></code>)</p>
</dd>
<dt><code>runs</code></dt><dd><p>list. Each element represents one model obtained from
one of the multiple starts.
Each element contains all of the above information for the
respective start.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>list. Contains the parameters used for the
model.</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2011S). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B. (2008). Algorithms for additive
clustering of rectangular data tables. <em>Computational Statistics and
Data Analysis, 52,</em> 4923-4938.
</p>
<p>Mirkin, B. G. (1987). The method of principal clusters. <em>Automation
and Remote Control</em>, 10:131-143.
</p>
<p>Mirkin, B. G. (1990). A sequential fitting procedure for linear data
analysis models. <em>Journal of Classification</em>, 7(2):167-195.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for low dimensional ADPROCLUS</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick clustering with K = 2 clusters
clust &lt;- adproclus(data = x, nclusters = 2)

# Clustering with K = 3 clusters,
# using the ALS2 algorithm,
# with 2 random and 2 semi-random starts
clust &lt;- adproclus(x, 3,
  nrandomstart = 2, nsemirandomstart = 2, algorithm = "ALS2"
)

# Saving the results of all starts
clust &lt;- adproclus(x, 3,
  nrandomstart = 2, nsemirandomstart = 2, save_all_starts = TRUE
)

# Clustering using a user-defined rational start profile matrix
# (here the first 4 rows of the data)
start &lt;- get_rational(x, x[1:4, ])$A
clust &lt;- adproclus(x, 4, start_allocation = start)

</code></pre>

<hr>
<h2 id='adproclus_low_dim'>Low dimensional ADPROCLUS</h2><span id='topic+adproclus_low_dim'></span>

<h3>Description</h3>

<p>Perform <strong>low dimensional</strong> additive profile clustering (ADPROCLUS) on
object by variable data. Use case: data to cluster consists of a large set of
variables, where it can be useful to interpret the cluster profiles in terms
of a smaller set of components that represent the original variables well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adproclus_low_dim(
  data,
  nclusters,
  ncomponents,
  start_allocation = NULL,
  nrandomstart = 3,
  nsemirandomstart = 3,
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adproclus_low_dim_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_ncomponents">ncomponents</code></td>
<td>
<p>Number of components (dimensions) to which the profiles
should be restricted. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional matrix of binary values as starting
allocation for first run. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts (see <code><a href="#topic+get_random">get_random</a></code>).
Can be zero. Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts
(see <code><a href="#topic+get_semirandom">get_semirandom</a></code>)). Can be zero.
Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>logical. If <code>TRUE</code>, the results of all algorithm
starts are returned. By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, an extension by Depril et al. (2012) of
Mirkins (1987, 1990) additive profile clustering method is used to obtain a
low dimensional overlapping clustering model of the object by variable data
provided by <code>data</code>.
More precisely, the low dimensional ADPROCLUS model approximates an
<code class="reqn">I \times J</code> object by variable data matrix <code class="reqn">X</code> by an
<code class="reqn">I \times J</code> model matrix <code class="reqn">M</code>. For <code class="reqn">K</code> overlapping
clusters, <code class="reqn">M</code> can be decomposed into an <code class="reqn">I \times K</code>
binary cluster membership matrix <code class="reqn">A</code> and a <code class="reqn">K \times J</code>
real-valued cluster profile matrix <code class="reqn">P</code> s.t. <code class="reqn">M = AP.</code>
With the simultaneous dimension reduction, <code class="reqn">P</code> is restricted
to be of reduced rank <code class="reqn">S &lt; min(K,J)</code>, such that it can be decomposed
into <code class="reqn">P = CB',</code> with <code class="reqn">C</code> a <code class="reqn">K \times S</code> matrix and
<code class="reqn">B</code> a <code class="reqn">J \times S</code> matrix. Now, a row in
<code class="reqn">C</code> represents the profile values associated with the
respective cluster in terms of the <code class="reqn">S</code> components, while
the entries of <code class="reqn">B</code> can be used to interpret the components
in terms of the complete set of variables. In particular, the aim of an
ADPROCLUS analysis is therefore, given a number of clusters <code class="reqn">K</code> and a
number of dimensions <code class="reqn">S</code>, to estimate a model matrix <code class="reqn">M</code>
that reconstructs data matrix
<code class="reqn">X</code> as close as possible in a least squares sense and
simultaneously reduce the dimensions of the data.
For a detailed illustration of the low dimensional ADPROCLUS model and
associated loss function, see Depril et al. (2012).
</p>
<p><strong>Warning:</strong> Computation time increases exponentially with increasing
number of clusters, <code class="reqn">K</code>. We recommend to determine the computation time
of a single start for each specific dataset and <code class="reqn">K</code> before increasing the
number of starts.
</p>


<h3>Value</h3>

<p><code>adproclus_low_dim()</code> returns a list with the following
components, which describe the best model (from the multiple starts):
</p>

<dl>
<dt><code>model</code></dt><dd><p>matrix. The obtained overlapping clustering model
<code class="reqn">M</code> of the same size as <code>data</code>.</p>
</dd>
<dt><code>model_lowdim</code></dt><dd><p>matrix. The obtained low dimensional clustering
model <code class="reqn">AC</code> of size <code class="reqn">I \times S</code></p>
</dd>
<dt><code>A</code></dt><dd><p>matrix. The membership matrix <code class="reqn">A</code> of the
clustering model. Clusters are sorted by size.</p>
</dd>
<dt><code>P</code></dt><dd><p>matrix. The profile matrix <code class="reqn">P</code> of the
clustering model.</p>
</dd>
<dt><code>c</code></dt><dd><p>matrix. The profile values in terms of the low dimensional
components.</p>
</dd>
<dt><code>B</code></dt><dd><p>Variables-by-components matrix.
Base vectors connecting low dimensional components with original variables.
matrix. Warning: for computing
<code class="reqn">P</code> use <code class="reqn">B'</code>.</p>
</dd>
<dt><code>sse</code></dt><dd><p>numeric. The
residual sum of squares of the clustering model, which is minimized by the
ALS algorithm.</p>
</dd>
<dt><code>totvar</code></dt><dd><p>numeric. The total sum of squares
of <code>data</code>.</p>
</dd>
<dt><code>explvar</code></dt><dd><p>numeric. The proportion of variance
in <code>data</code> that is accounted for by the clustering model.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>numeric. The number of iterations of the
algorithm.</p>
</dd>
<dt><code>timer</code></dt><dd><p>numeric. The amount of time (in seconds) the complete
algorithm ran for.</p>
</dd>
<dt><code>timer_one_run</code></dt><dd><p>numeric. The amount of time (in seconds) the
relevant single start ran for.</p>
</dd>
<dt><code>initial_start</code></dt><dd><p>list. A list containing the initial
membership matrix, as well as the type of start that was used
to obtain the clustering solution. (as returned by <code><a href="#topic+get_random">get_random</a></code>
or <code><a href="#topic+get_semirandom">get_semirandom</a></code>)</p>
</dd>
<dt><code>runs</code></dt><dd><p>list. Each element represents one model obtained
from one of the multiple starts.
Each element contains all of the above information.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>list. Containing the parameters used for the
model.</p>
</dd></dl>



<h3>References</h3>

<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code></dt><dd><p>for full dimensional ADPROCLUS</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Low dimensional clustering with K = 3 clusters
# where the resulting profiles can be characterized in S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, ncomponents = 1)

</code></pre>

<hr>
<h2 id='CGdata'>Randomly generated data with underlying overlapping clusters.</h2><span id='topic+CGdata'></span>

<h3>Description</h3>

<p>A computer generated object-by-variable dataset with an underlying
nonrestricted overlapping clustering structure. For illustrative purposes
within the ADPROCLUS package only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 15 variables
</p>

<hr>
<h2 id='get_random'>Generate initial random start</h2><span id='topic+get_random'></span>

<h3>Description</h3>

<p>Generate an initial random start for the (low dimensional) Additive Profile
Clustering algorithm (see <code><a href="#topic+adproclus">adproclus</a></code> and
<code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random(data, nclusters, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_random_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="get_random_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator. Default: NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_random</code> generates a random initial binary membership matrix
<strong>A</strong> such that each entry is an independen draw from a
Bernoulli Distribution with <code class="reqn">\pi = 0.5</code>.
</p>
<p>For generating an initial start from random draws from the data, see
<code><a href="#topic+get_semirandom">get_semirandom</a></code>.
For generating an initial start based on a specific set of initial cluster
centers, see <code><a href="#topic+get_rational">get_rational</a></code>.
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model.
To perform aditive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_random()</code> returns a list with the following components:
</p>
 <dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Random Start')</p>
</dd> <dt><code>A</code></dt><dd><p>A randomly generated initial Membership
matrix</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2010). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B.
(2008). Algorithms for additive clustering of rectangular data tables.
<em>Computational Statistics and Data Analysis, 52,</em> 4923-4938.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from data set "Stackloss" and generate start allocation
start_allocation &lt;- get_random(stackloss, 3)$A

</code></pre>

<hr>
<h2 id='get_rational'>Generate start allocation based on a priori profiles</h2><span id='topic+get_rational'></span>

<h3>Description</h3>

<p>If cluster profiles are given a priori, this function can be used to compute
the conditionally optimal cluster membership matrix A which can then be
used as a rational starting allocation for the (low dimensional) ADPROCLUS
procedure (see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rational(data, starting_profiles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rational_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_rational_+3A_starting_profiles">starting_profiles</code></td>
<td>
<p>A matrix where each row represents the profile
values for a cluster. Needs to be of same dimensions as <code class="reqn">P</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the same quadratic loss function and minimization method as
the (low dimensional) ADPROCLUS procedure does to find the next conditionally
optimal membership matrix A. (for details, see Depril et al., 2012).
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model. To
perform additive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_rational()</code> returns a list with the following components:
</p>

<dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Rational Start')</p>
</dd>
<dt><code>A</code></dt><dd><p>An initial Membership matrix</p>
</dd></dl>



<h3>References</h3>

<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from standard data set "Stackloss"
x &lt;- stackloss

# Obtaining a user-defined rational start profile matrix
# (here the first 4 rows of the data)
start_allocation &lt;- get_rational(x, x[1:4, ])$A

</code></pre>

<hr>
<h2 id='get_semirandom'>Generate initial semi-random start</h2><span id='topic+get_semirandom'></span>

<h3>Description</h3>

<p>Generate an initial semi-random start for the (low dimensional) Additive
Profile Clustering
algorithm (see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_semirandom(data, nclusters, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_semirandom_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_semirandom_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="get_semirandom_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator. Default: NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An initial cluster membership matrix <code class="reqn">A</code> is generated by
finding the best <code class="reqn">A</code> conditional
on an initial profile matrix
<code class="reqn">P</code> generated by drawing <em>k</em> randomly chosen, distinct,
rows from <code>data</code> (for details, see Depril et al., 2012).
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model. To
perform aditive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_semirandom</code> returns a list with the following components:
</p>

<dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Semi-random Start')</p>
</dd>
<dt><code>A</code></dt><dd><p>An initial Membership matrix</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2010). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B. (2008). Algorithms for additive
clustering of rectangular data tables. <em>Computational Statistics and
Data Analysis, 52,</em> 4923-4938.
</p>
<p>#' Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from data set "Stackloss" and generate start allocation
start_allocation &lt;- get_semirandom(stackloss, 3)$A

</code></pre>

<hr>
<h2 id='plot_cluster_network'>Network plot of a (low dimensional) ADPROCLUS solution</h2><span id='topic+plot_cluster_network'></span>

<h3>Description</h3>

<p>Produce a representation of a (low dimensional) ADPROCLUS solution,
where each cluster is a vertex and the edge between two vertices represents
the overlap between the corresponding clusters.
The size of a vertex corresponds to the cluster size.
The overlap is represented through color, width and numerical label
of the edge.
The numerical edge labels can be relative
(number of overlap observations / total observations)
or absolute (number of observations in both clusters).
<strong>NOTE:</strong> This function can be called through the
<code>plot(model, type = "Network")</code> function with model an
object of class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster_network(
  model,
  title = "Cluster network of ADPROCLUS solution",
  relative_overlap = TRUE,
  filetype = NULL,
  filename = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cluster_network_+3A_model">model</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>). Low dimensional model
possible.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_title">title</code></td>
<td>
<p>String. Default: &quot; Cluster network of ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_relative_overlap">relative_overlap</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the number of
observations belonging to two clusters
is divided by the total number of observations. If <code>FALSE</code>
the number of observations in a cluster overlap will be displayed on the
edges.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_filetype">filetype</code></td>
<td>
<p>Optional. Choose type of file to save the plot.
Possible choices: <code>"R", "pdf", "svg", "tex", "jpg", "tiff", "png", ""</code>
Default: <code>NULL</code> does not create a file.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_filename">filename</code></td>
<td>
<p>Optional. Name of the file without extension.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>qgraph::qgraph()</code> function, to customize the graph visualization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Plot the overlapping the clusters
plot_cluster_network(clust)
</code></pre>

<hr>
<h2 id='plot_profiles'>Plot profile matrix of ADPROCLUS solution</h2><span id='topic+plot_profiles'></span>

<h3>Description</h3>

<p>Produce a representation of profile matrix <code class="reqn">P</code>
(or <code class="reqn">C</code> for low dimensional solution) of an ADPROCLUS
solution of class <code>adpc</code>.
The plot displays the profiles in the style of a correlation plot.
<strong>NOTE:</strong> This function can also be called through the
<code>plot(model, type = "Profiles")</code> function with model an object of
class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_profiles(model, title = "Profiles of ADPROCLUS solution", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_profiles_+3A_model">model</code></td>
<td>
<p>Object of class <code>adpc</code>. (Low dimensional) ADPROCLUS
solution</p>
</td></tr>
<tr><td><code id="plot_profiles_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;Profiles of ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="plot_profiles_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>corrplot::corrplot()</code> function, to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick clustering with K = 3 clusters
clust &lt;- adproclus(x, 3)

# Plot the profile scores of each cluster
plot_profiles(clust)
</code></pre>

<hr>
<h2 id='plot_vars_by_comp'>Plot variable to component matrix of ADPROCLUS solution</h2><span id='topic+plot_vars_by_comp'></span>

<h3>Description</h3>

<p>Produce a representation of variable to component matrix
<code class="reqn">B'</code> of a <strong>low dimensional</strong> ADPROCLUS solution
of class <code>adpc</code>. The plot displays the scores in the style of a
correlation plot.
<strong>NOTE:</strong> This function can be called through the
<code>plot(model, type = "VarsByComp")</code> function
with model an object of class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vars_by_comp(
  model,
  title = "B' of Low Dimensional ADPROCLUS Solution",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_vars_by_comp_+3A_model">model</code></td>
<td>
<p>Object of class <code>adpc</code>. Must be <strong>Low dimensional</strong>
ADPROCLUS solution</p>
</td></tr>
<tr><td><code id="plot_vars_by_comp_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;B' of Low Dimensional ADPROCLUS Solution&quot;</p>
</td></tr>
<tr><td><code id="plot_vars_by_comp_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>corrplot::corrplot()</code> function, to customize the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Plot the matrix B', connecting components with variables
plot_vars_by_comp(clust)
</code></pre>

<hr>
<h2 id='plot.adpc'>Plotting a (low dimensional) ADPROCLUS solution</h2><span id='topic+plot.adpc'></span>

<h3>Description</h3>

<p>When passing a (low dimensional) ADPROCLUS solution of class <code>adpc</code> to
the generic <code>plot()</code>, this method plots the solution in one of the
following three ways:
</p>

<dl>
<dt>Network</dt><dd><p>Each cluster is a vertex and
the edge between two vertices represents the overlap between the
corresponding clusters. The size of a vertex corresponds to the cluster size.
The overlap is represented through color, width and numerical label of the
edge. The numerical edge-labels can be relative
(number of overlap observations / total observations)
or absolute (number of observations in both clusters).</p>
</dd>
<dt>Profiles</dt><dd><p>Plot the profile matrix (<code class="reqn">P</code>
for full dimensional model, <code class="reqn">C</code> for low dimensional model)
in the style of a correlation plot to visualize the relation of each cluster
with each variable.</p>
</dd>
<dt>Variables by components</dt><dd><p>Plot the low dimensional
component-by-variable matrix <code class="reqn">B'</code> in the style of a
correlation plot to visualize the relation of each component with each
original variable. <strong>NOTE:</strong> Only works for low dimensional ADPROCLUS.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
plot(x, type = "Network", title = NULL, relative_overlap = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.adpc_+3A_x">x</code></td>
<td>
<p>Object of class <code>adpc</code>. (Low dimensional) ADPROCLUS solution</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_type">type</code></td>
<td>
<p>Choice for type of plot: one of <code>"Network", "Profiles",
"vars_by_comp"</code>. Default: <code>"Network"</code>.</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_title">title</code></td>
<td>
<p>String. OPTIONAL.</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_relative_overlap">relative_overlap</code></td>
<td>
<p>Logical, only applies to plot of
<code>type = "Network"</code>. If <code>TRUE</code> (default), the number of observations
belonging to two clusters is divided by the total number of observations.</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed on to the functions
<code>plot_cluster_network(), plot_profiles(), plot_vars_by_comp()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Produce three plots of the model
plot(clust, type = "Network")
plot(clust, type = "Profiles")
plot(clust, type = "vars_by_comp")
</code></pre>

<hr>
<h2 id='print.adpc'>Print basic information on ADPROCLUS solution</h2><span id='topic+print.adpc'></span>

<h3>Description</h3>

<p>For an object of class <code>adpc</code> as input, this method prints basic
information about the ADPROCLUS solution represented by the object.
Works for both full and low dimensional solutions. Adjust the parameters
<code>digits, matrix_rows, matrix_cols</code>
to change the level of detail printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
print(
  x,
  title = "ADPROCLUS solution",
  digits = 3,
  matrix_rows = 10,
  matrix_cols = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adpc_+3A_x">x</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>)</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits that all decimal numbers will
be rounded to.</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_matrix_rows">matrix_rows</code></td>
<td>
<p>Integer. The number of matrix rows to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_matrix_cols">matrix_cols</code></td>
<td>
<p>Integer. The number of matrix columns to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, print model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
print(model)
</code></pre>

<hr>
<h2 id='print.summary.adpc'>Print (low dimensional) ADPROCLUS summary</h2><span id='topic+print.summary.adpc'></span>

<h3>Description</h3>

<p>Prints an object of class <code>summary.adpc</code> to represent and summarize a
(low dimensional) ADPROCLUS solution. A number of parameters for how the
results should be printed can be passed as an argument to
<code>summary.adpc()</code> which then passes it on to this method. This method
does not take a model of class <code>adpc</code> directly as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.adpc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.adpc_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary.adpc</code></p>
</td></tr>
<tr><td><code id="print.summary.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns object of class <code>summary.adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, print summary of model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
print(summary(model))
</code></pre>

<hr>
<h2 id='summary.adpc'>Summary of ADPROCLUS solution</h2><span id='topic+summary.adpc'></span>

<h3>Description</h3>

<p>For an object of class <code>adpc</code> as input, this method yields a summary
object of class <code>summary.adpc</code> including group characteristics of the
clusters in the solution. Works for both full and low dimensional solutions.
Adjust the parameters <code>digits, matrix_rows, matrix_cols</code> to change the
level of detail for the printing of the summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
summary(
  object,
  title = "ADPROCLUS solution",
  digits = 3,
  matrix_rows = 10,
  matrix_cols = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.adpc_+3A_object">object</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>). Low dimensional model
possible.</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of digits that all decimal numbers will be
rounded to.</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_matrix_rows">matrix_rows</code></td>
<td>
<p>Integer. The number of matrix rows to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_matrix_cols">matrix_cols</code></td>
<td>
<p>Integer. The number of matrix columns to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns object of class <code>summary.adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, summarize model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
model_summary &lt;- summary(model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
