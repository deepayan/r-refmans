<!DOCTYPE html><html lang="en"><head><title>Help for package adproclus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adproclus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adproclus-package'><p>adproclus: Additive Profile Clustering Algorithms</p></a></li>
<li><a href='#adpc'><p>Constructor for a (low dimensional) ADPROCLUS solution object</p></a></li>
<li><a href='#adproclus'><p>Additive profile clustering</p></a></li>
<li><a href='#adproclus_low_dim'><p>Low dimensional ADPROCLUS</p></a></li>
<li><a href='#CGdata'><p>Randomly generated data with underlying overlapping clusters.</p></a></li>
<li><a href='#cluster_means'><p>Cluster Means based on Original Variables</p></a></li>
<li><a href='#get_random'><p>Generate initial random start</p></a></li>
<li><a href='#get_rational'><p>Generate start allocation based on a priori profiles</p></a></li>
<li><a href='#get_semirandom'><p>Generate initial semi-random start</p></a></li>
<li><a href='#mselect_adproclus'><p>Model selection helper for ADPROCLUS</p></a></li>
<li><a href='#mselect_adproclus_low_dim'><p>Model selection helper for low dimensional ADPROCLUS</p></a></li>
<li><a href='#plot_cluster_network'><p>Network plot of a (low dimensional) ADPROCLUS solution</p></a></li>
<li><a href='#plot_profiles'><p>Plot profile matrix of ADPROCLUS solution</p></a></li>
<li><a href='#plot_scree_adpc'><p>Scree plot of (low dimensional) ADPROCLUS models</p></a></li>
<li><a href='#plot_scree_adpc_preselected'><p>Scree plot of a pre-selection of low dimensional ADPROCLUS models</p></a></li>
<li><a href='#plot_vars_by_comp'><p>Plot variable to component matrix of ADPROCLUS solution</p></a></li>
<li><a href='#plot.adpc'><p>Plotting a (low dimensional) ADPROCLUS solution</p></a></li>
<li><a href='#print.adpc'><p>Print basic information on ADPROCLUS solution</p></a></li>
<li><a href='#print.summary.adpc'><p>Print (low dimensional) ADPROCLUS summary</p></a></li>
<li><a href='#select_by_CHull'><p>Automatic Model Selection for ADPROCLUS with CHull Method</p></a></li>
<li><a href='#summary.adpc'><p>Summary of ADPROCLUS solution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Additive Profile Clustering Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Obtain overlapping clustering models for object-by-variable data
        matrices using the Additive Profile Clustering (ADPROCLUS) method. 
        Also contains the low dimensional ADPROCLUS method 
        for simultaneous dimension reduction and overlapping clustering. 
        For reference see Depril, Van Mechelen, Mirkin (2008) 
        &lt;<a href="https://doi.org/10.1016%2Fj.csda.2008.04.014">doi:10.1016/j.csda.2008.04.014</a>&gt; and Depril, Van Mechelen, Wilderjans 
        (2012) &lt;<a href="https://doi.org/10.1007%2Fs00357-012-9112-5">doi:10.1007/s00357-012-9112-5</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, corrplot, ggplot2, ggrepel, gtools, igraph,
matrixStats, multichull, NMFN, qgraph, readr, rlang, scales,
stats, tidyr, withr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adproclus-package.R' 'adproclus_classes.R' 'clustering.R'
'data.R' 'get_starts.R' 'model_selection.R' 'utils.R'
'visualize.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/henry-heppe/adproclus">https://github.com/henry-heppe/adproclus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/henry-heppe/adproclus/issues">https://github.com/henry-heppe/adproclus/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-17 17:46:49 UTC; a1224</td>
</tr>
<tr>
<td>Author:</td>
<td>Henry Heppe [aut, cre, cph],
  Julian Rossbroich [aut],
  Jeffrey Durieux [aut],
  Tom Wilderjans [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henry Heppe &lt;heppe.henry@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-17 18:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='adproclus-package'>adproclus: Additive Profile Clustering Algorithms</h2><span id='topic+adproclus-package'></span>

<h3>Description</h3>

<p>Obtain overlapping clustering models for object-by-variable data matrices using the Additive Profile Clustering (ADPROCLUS) method. Also contains the low dimensional ADPROCLUS method for simultaneous dimension reduction and overlapping clustering. For reference see Depril, Van Mechelen, Mirkin (2008) <a href="https://doi.org/10.1016/j.csda.2008.04.014">doi:10.1016/j.csda.2008.04.014</a> and Depril, Van Mechelen, Wilderjans (2012) <a href="https://doi.org/10.1007/s00357-012-9112-5">doi:10.1007/s00357-012-9112-5</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Henry Heppe <a href="mailto:heppe.henry@gmail.com">heppe.henry@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Julian Rossbroich
</p>
</li>
<li><p> Jeffrey Durieux
</p>
</li>
<li><p> Tom Wilderjans
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/henry-heppe/adproclus">https://github.com/henry-heppe/adproclus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/henry-heppe/adproclus/issues">https://github.com/henry-heppe/adproclus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adpc'>Constructor for a (low dimensional) ADPROCLUS solution object</h2><span id='topic+adpc'></span>

<h3>Description</h3>

<p>Yields an object of class <code>adpc</code>, which can be printed, plotted and
summarized by the corresponding methods. Mandatory input are the membership
matrix <code class="reqn">A</code> and the profile matrix <code class="reqn">P</code>
(where the number of columns from <code class="reqn">A</code> corresponds to
the number of rows in <code class="reqn">P</code>),
if the object is to represent a full dimensional ADPROCLUS model.
For a low dimensional ADPROCLUS model, the matrices <code class="reqn">C</code>
and <code class="reqn">B</code> have to be provided and <code class="reqn">P</code> can
be inferred from those. All other inputs are optional but may be included
so that the output from the <code>summary(), print(), plot()</code> is complete.
For further details on the (low dimensional) ADPROCLUS model and
what every element of the objects means
see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adpc(
  A,
  P,
  sse = NULL,
  totvar = NULL,
  explvar = NULL,
  iterations = NULL,
  timer = NULL,
  timer_one_run = NULL,
  initial_start = NULL,
  C = NULL,
  B = NULL,
  runs = NULL,
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adpc_+3A_a">A</code></td>
<td>
<p>Membership matrix A.</p>
</td></tr>
<tr><td><code id="adpc_+3A_p">P</code></td>
<td>
<p>Profile matrix P.</p>
</td></tr>
<tr><td><code id="adpc_+3A_sse">sse</code></td>
<td>
<p>Sum of Squared Error.</p>
</td></tr>
<tr><td><code id="adpc_+3A_totvar">totvar</code></td>
<td>
<p>Total variance.</p>
</td></tr>
<tr><td><code id="adpc_+3A_explvar">explvar</code></td>
<td>
<p>Explained variance.</p>
</td></tr>
<tr><td><code id="adpc_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="adpc_+3A_timer">timer</code></td>
<td>
<p>Time needed to run the complete algorithm.</p>
</td></tr>
<tr><td><code id="adpc_+3A_timer_one_run">timer_one_run</code></td>
<td>
<p>Time to complete this single algorithm start.</p>
</td></tr>
<tr><td><code id="adpc_+3A_initial_start">initial_start</code></td>
<td>
<p>List containing type of start and
<code>start_allocation</code> matrix.</p>
</td></tr>
<tr><td><code id="adpc_+3A_c">C</code></td>
<td>
<p>Low dimensional profiles matrix C.</p>
</td></tr>
<tr><td><code id="adpc_+3A_b">B</code></td>
<td>
<p>Matrix of base vectors connecting low dimensional components with
original variables B.</p>
</td></tr>
<tr><td><code id="adpc_+3A_runs">runs</code></td>
<td>
<p>List of suboptimal models.</p>
</td></tr>
<tr><td><code id="adpc_+3A_parameters">parameters</code></td>
<td>
<p>List of algorithm parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create the information needed for a minimal object of class adpc
x &lt;- stackloss
result &lt;- adproclus(x, 3)
A &lt;- result$A
P &lt;- result$P

# Use constructor to obtain object of class adpc
result_object &lt;- adpc(A, P)

</code></pre>

<hr>
<h2 id='adproclus'>Additive profile clustering</h2><span id='topic+adproclus'></span>

<h3>Description</h3>

<p>Perform additive profile clustering (ADPROCLUS) on object-by-variable data.
Creates a model that assigns the objects to overlapping clusters which are
characterized in terms of the variables by the so-called profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adproclus(
  data,
  nclusters,
  start_allocation = NULL,
  nrandomstart = 3,
  nsemirandomstart = 3,
  algorithm = "ALS2",
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adproclus_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional matrix of binary values as starting
allocation for first run. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts (see <code><a href="#topic+get_random">get_random</a></code>).
Can be zero. Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts
(see <code><a href="#topic+get_semirandom">get_semirandom</a></code>)). Can be zero. Increase for better
results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string &quot;<code>ALS1</code>&quot; (default) or &quot;<code>ALS2</code>&quot;,
denoting the type of alternating least squares algorithm. Can be
abbreviated with &quot;1&quot; or &quot;2&quot;.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the results of all algorithm
starts are returned. By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="adproclus_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, Mirkin's (1987, 1990) Additive Profile Clustering
(ADPROCLUS) method is used to obtain an unrestricted overlapping clustering
model of the object by variable data provided by <code>data</code>.
</p>
<p>The ADPROCLUS model approximates an <code class="reqn">I \times J</code> object by
variable data matrix <code class="reqn">X</code> by an <code class="reqn">I \times J</code> model matrix
<code class="reqn">M</code> that can be decomposed into an <code class="reqn">I \times K</code> binary
cluster membership matrix <code class="reqn">A</code> and a <code class="reqn">K \times J</code>
real-valued cluster profile matrix <code class="reqn">P</code>, with <code class="reqn">K</code>
indicating the number of overlapping clusters.
In particular, the aim of an ADPROCLUS analysis is therefore,
given a number of clusters <code class="reqn">K</code>, to estimate a
model matrix <code class="reqn">M = AP</code> which reconstructs the data matrix
<code class="reqn">X</code> as close as possible in a least squares sense
(i.e. sum of squared residuals). For a detailed illustration of the
ADPROCLUS model and associated loss function, see Wilderjans et al. (2011).
</p>
<p>The alternating least squares algorithms (&quot;<code>ALS1</code>&quot; and &quot;<code>ALS2</code>&quot;)
that can be used for minimization of the loss function were proposed by
Depril et al. (2008). In &quot;<code>ALS2</code>&quot;, starting from an initial random or
rational estimate of <code class="reqn">A</code> (see <code><a href="#topic+get_random">get_random</a></code> and
<code><a href="#topic+get_semirandom">get_semirandom</a></code>), <code class="reqn">A</code> and <code class="reqn">P</code>
are alternately re-estimated conditionally upon each other until convergence.
The &quot;<code>ALS1</code>&quot; algorithm differs from the previous one in that each
row in <code class="reqn">A</code> is updated independently and that the
conditionally optimal <code class="reqn">P</code> is recalculated after each row
update, instead of the end of the matrix. For a discussion and comparison of
the different algorithms, see Depril et al., 2008.
</p>
<p><strong>Warning:</strong> Computation time increases exponentially with increasing
number of clusters, <code class="reqn">K</code>. We recommend to determine the computation time
of a single start for each specific dataset and <code class="reqn">K</code> before increasing the
number of starts.
</p>


<h3>Value</h3>

<p><code>adproclus()</code> returns a list with the following
components, which describe the best model (from the multiple starts):
</p>

<dl>
<dt><code>model</code></dt><dd><p>matrix. The obtained overlapping clustering model
<strong>M</strong> of the same size as <code>data</code>.</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix. The membership matrix <strong>A</strong> of the clustering
model. Clusters are sorted by size.</p>
</dd>
<dt><code>P</code></dt><dd><p>matrix. The profile matrix
<strong>P</strong> of the clustering model.</p>
</dd>
<dt><code>sse</code></dt><dd><p>numeric. The
residual sum of squares of the clustering model, which is minimized by the
ALS algorithm.</p>
</dd>
<dt><code>totvar</code></dt><dd><p>numeric. The total sum of squares
of <code>data</code>.</p>
</dd>
<dt><code>explvar</code></dt><dd><p>numeric. The proportion of variance
in <code>data</code> that is accounted for by the clustering model.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>numeric. The number of algorithm iterations
until convergence of the relevant single start.</p>
</dd>
<dt><code>timer_one_run</code></dt><dd><p>numeric. The amount of time (in seconds) the
relevant single start ran for.</p>
</dd>
<dt><code>initial_start</code></dt><dd><p>list. Containing the initial
membership matrix, as well as the type of start that was used
to obtain the clustering solution. (as returned by <code><a href="#topic+get_random">get_random</a></code>
or <code><a href="#topic+get_semirandom">get_semirandom</a></code>)</p>
</dd>
<dt><code>runs</code></dt><dd><p>list. Each element represents one model obtained from
one of the multiple starts.
Each element contains all of the above information for the
respective start.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>list. Contains the parameters used for the
model.</p>
</dd>
<dt><code>timer</code></dt><dd><p>numeric. The amount of time (in seconds) the complete
algorithm ran for.</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2011S). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B. (2008). Algorithms for additive
clustering of rectangular data tables. <em>Computational Statistics and
Data Analysis, 52,</em> 4923-4938.
</p>
<p>Mirkin, B. G. (1987). The method of principal clusters. <em>Automation
and Remote Control</em>, 10:131-143.
</p>
<p>Mirkin, B. G. (1990). A sequential fitting procedure for linear data
analysis models. <em>Journal of Classification</em>, 7(2):167-195.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for low dimensional ADPROCLUS</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick clustering with K = 2 clusters
clust &lt;- adproclus(data = x, nclusters = 2)

# Clustering with K = 3 clusters,
# using the ALS2 algorithm,
# with 2 random and 2 semi-random starts
clust &lt;- adproclus(x, 3,
  nrandomstart = 2, nsemirandomstart = 2, algorithm = "ALS2"
)

# Saving the results of all starts
clust &lt;- adproclus(x, 3,
  nrandomstart = 2, nsemirandomstart = 2, save_all_starts = TRUE
)

# Clustering using a user-defined rational start profile matrix
# (here the first 4 rows of the data)
start &lt;- get_rational(x, x[1:4, ])$A
clust &lt;- adproclus(x, 4, start_allocation = start)

</code></pre>

<hr>
<h2 id='adproclus_low_dim'>Low dimensional ADPROCLUS</h2><span id='topic+adproclus_low_dim'></span>

<h3>Description</h3>

<p>Perform <strong>low dimensional</strong> additive profile clustering (ADPROCLUS) on
object by variable data. Use case: data to cluster consists of a large set of
variables, where it can be useful to interpret the cluster profiles in terms
of a smaller set of components that represent the original variables well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adproclus_low_dim(
  data,
  nclusters,
  ncomponents,
  start_allocation = NULL,
  nrandomstart = 3,
  nsemirandomstart = 3,
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adproclus_low_dim_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_ncomponents">ncomponents</code></td>
<td>
<p>Number of components (dimensions) to which the profiles
should be restricted. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional matrix of binary values as starting
allocation for first run. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts (see <code><a href="#topic+get_random">get_random</a></code>).
Can be zero. Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts
(see <code><a href="#topic+get_semirandom">get_semirandom</a></code>)). Can be zero.
Increase for better results, though longer computation time.
Some research finds 500 starts to be a useful reference.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>logical. If <code>TRUE</code>, the results of all algorithm
starts are returned. By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="adproclus_low_dim_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, an extension by Depril et al. (2012) of
Mirkins (1987, 1990) additive profile clustering method is used to obtain a
low dimensional overlapping clustering model of the object by variable data
provided by <code>data</code>.
More precisely, the low dimensional ADPROCLUS model approximates an
<code class="reqn">I \times J</code> object by variable data matrix <code class="reqn">X</code> by an
<code class="reqn">I \times J</code> model matrix <code class="reqn">M</code>. For <code class="reqn">K</code> overlapping
clusters, <code class="reqn">M</code> can be decomposed into an <code class="reqn">I \times K</code>
binary cluster membership matrix <code class="reqn">A</code> and a <code class="reqn">K \times J</code>
real-valued cluster profile matrix <code class="reqn">P</code> s.t. <code class="reqn">M = AP.</code>
With the simultaneous dimension reduction, <code class="reqn">P</code> is restricted
to be of reduced rank <code class="reqn">S &lt; min(K,J)</code>, such that it can be decomposed
into <code class="reqn">P = CB',</code> with <code class="reqn">C</code> a <code class="reqn">K \times S</code> matrix and
<code class="reqn">B</code> a <code class="reqn">J \times S</code> matrix. Now, a row in
<code class="reqn">C</code> represents the profile values associated with the
respective cluster in terms of the <code class="reqn">S</code> components, while
the entries of <code class="reqn">B</code> can be used to interpret the components
in terms of the complete set of variables. In particular, the aim of an
ADPROCLUS analysis is therefore, given a number of clusters <code class="reqn">K</code> and a
number of dimensions <code class="reqn">S</code>, to estimate a model matrix <code class="reqn">M</code>
that reconstructs data matrix
<code class="reqn">X</code> as close as possible in a least squares sense and
simultaneously reduce the dimensions of the data.
For a detailed illustration of the low dimensional ADPROCLUS model and
associated loss function, see Depril et al. (2012).
</p>
<p><strong>Warning:</strong> Computation time increases exponentially with increasing
number of clusters, <code class="reqn">K</code>. We recommend to determine the computation time
of a single start for each specific dataset and <code class="reqn">K</code> before increasing the
number of starts.
</p>


<h3>Value</h3>

<p><code>adproclus_low_dim()</code> returns a list with the following
components, which describe the best model (from the multiple starts):
</p>

<dl>
<dt><code>model</code></dt><dd><p>matrix. The obtained overlapping clustering model
<code class="reqn">M</code> of the same size as <code>data</code>.</p>
</dd>
<dt><code>model_lowdim</code></dt><dd><p>matrix. The obtained low dimensional clustering
model <code class="reqn">AC</code> of size <code class="reqn">I \times S</code></p>
</dd>
<dt><code>A</code></dt><dd><p>matrix. The membership matrix <code class="reqn">A</code> of the
clustering model. Clusters are sorted by size.</p>
</dd>
<dt><code>P</code></dt><dd><p>matrix. The profile matrix <code class="reqn">P</code> of the
clustering model.</p>
</dd>
<dt><code>c</code></dt><dd><p>matrix. The profile values in terms of the low dimensional
components.</p>
</dd>
<dt><code>B</code></dt><dd><p>Variables-by-components matrix.
Base vectors connecting low dimensional components with original variables.
matrix. Warning: for computing
<code class="reqn">P</code> use <code class="reqn">B'</code>.</p>
</dd>
<dt><code>sse</code></dt><dd><p>numeric. The
residual sum of squares of the clustering model, which is minimized by the
ALS algorithm.</p>
</dd>
<dt><code>totvar</code></dt><dd><p>numeric. The total sum of squares
of <code>data</code>.</p>
</dd>
<dt><code>explvar</code></dt><dd><p>numeric. The proportion of variance
in <code>data</code> that is accounted for by the clustering model.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>numeric. The number of algorithm iterations
until convergence of the relevant single start.</p>
</dd>
<dt><code>timer_one_run</code></dt><dd><p>numeric. The amount of time (in seconds) the
relevant single start ran for.</p>
</dd>
<dt><code>initial_start</code></dt><dd><p>list. A list containing the initial
membership matrix, as well as the type of start that was used
to obtain the clustering solution. (as returned by <code><a href="#topic+get_random">get_random</a></code>
or <code><a href="#topic+get_semirandom">get_semirandom</a></code>)</p>
</dd>
<dt><code>runs</code></dt><dd><p>list. Each element represents one model obtained
from one of the multiple starts.
Each element contains all of the above information.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>list. Containing the parameters used for the
model.</p>
</dd>
<dt><code>timer</code></dt><dd><p>numeric. The amount of time (in seconds) the complete
algorithm ran for.</p>
</dd></dl>



<h3>References</h3>

<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code></dt><dd><p>for full dimensional ADPROCLUS</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Low dimensional clustering with K = 3 clusters
# where the resulting profiles can be characterized in S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, ncomponents = 1)

</code></pre>

<hr>
<h2 id='CGdata'>Randomly generated data with underlying overlapping clusters.</h2><span id='topic+CGdata'></span>

<h3>Description</h3>

<p>A computer generated object-by-variable dataset with an underlying
nonrestricted overlapping clustering structure. For illustrative purposes
within the ADPROCLUS package only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 15 variables
</p>

<hr>
<h2 id='cluster_means'>Cluster Means based on Original Variables</h2><span id='topic+cluster_means'></span>

<h3>Description</h3>

<p>Obtain a cluster-by-variable dataframe where the values are the cluster means
for the given variables. Takes as input a (low dimensional) ADPROCLUS model
of class <code>adpc</code> and a dataset. This dataset must have the same number
of rows as the cluster membership matrix $A$ of the model. The variables can
be different from the ones the model was trained on. The function uses the
cluster membership matrix of the model to computer per cluster the mean of
the variables in the dataset. In the output matrix of cluster means,
the last row <code>Cl0</code> corresponds to the baseline cluster consisting
of all the observations that were not assigned to a cluster,
if this cluster is not empty. This function effectively computes column means
of the dataset separately for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_means(data, model, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_means_+3A_data">data</code></td>
<td>
<p>Object-by-variable matrix. Can contain other variables than
the ADPROCLUS model. IMPORTANT: The number of rows must be equal to the
number of observations in the ADPROCLUS model.</p>
</td></tr>
<tr><td><code id="cluster_means_+3A_model">model</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>). Low dimensional model
possible.</p>
</td></tr>
<tr><td><code id="cluster_means_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of decimal places that all decimal numbers will
be rounded to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is worth noting that the output of this function is different
from the last output matrix in the
<code>summary()</code> method applied to an ADPROCLUS model.
The former computes the means over the original variable values
while the latter computes them over the approximated model variable values.
</p>


<h3>Value</h3>

<p>Cluster-by-variable dataframe where the values are the cluster means
for the given variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, report cluster means
x &lt;- CGdata
model &lt;- adproclus(x, 3)
cluster_means(data = x, model = model)
</code></pre>

<hr>
<h2 id='get_random'>Generate initial random start</h2><span id='topic+get_random'></span>

<h3>Description</h3>

<p>Generate an initial random start for the (low dimensional) Additive Profile
Clustering algorithm (see <code><a href="#topic+adproclus">adproclus</a></code> and
<code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random(data, nclusters, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_random_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_random_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="get_random_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator. Default: NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_random</code> generates a random initial binary membership matrix
<strong>A</strong> such that each entry is an independen draw from a
Bernoulli Distribution with <code class="reqn">\pi = 0.5</code>.
</p>
<p>For generating an initial start from random draws from the data, see
<code><a href="#topic+get_semirandom">get_semirandom</a></code>.
For generating an initial start based on a specific set of initial cluster
centers, see <code><a href="#topic+get_rational">get_rational</a></code>.
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model.
To perform aditive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_random()</code> returns a list with the following components:
</p>
 <dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Random Start')</p>
</dd> <dt><code>A</code></dt><dd><p>A randomly generated initial Membership
matrix</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2010). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B.
(2008). Algorithms for additive clustering of rectangular data tables.
<em>Computational Statistics and Data Analysis, 52,</em> 4923-4938.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from data set "Stackloss" and generate start allocation
start_allocation &lt;- get_random(stackloss, 3)$A

</code></pre>

<hr>
<h2 id='get_rational'>Generate start allocation based on a priori profiles</h2><span id='topic+get_rational'></span>

<h3>Description</h3>

<p>If cluster profiles are given a priori, this function can be used to compute
the conditionally optimal cluster membership matrix A which can then be
used as a rational starting allocation for the (low dimensional) ADPROCLUS
procedure (see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rational(data, starting_profiles)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rational_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_rational_+3A_starting_profiles">starting_profiles</code></td>
<td>
<p>A matrix where each row represents the profile
values for a cluster. Needs to be of same dimensions as <code class="reqn">P</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the same quadratic loss function and minimization method as
the (low dimensional) ADPROCLUS procedure does to find the next conditionally
optimal membership matrix A. (for details, see Depril et al., 2012). For the full
dimensional ADPROCLUS it uses the algorithm <code>ALS2</code> and not <code>ALS1</code>.
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model. To
perform additive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_rational()</code> returns a list with the following components:
</p>

<dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Rational Start')</p>
</dd>
<dt><code>A</code></dt><dd><p>An initial Membership matrix</p>
</dd></dl>



<h3>References</h3>

<p>Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_semirandom">get_semirandom</a></code></dt><dd><p>for generating semi-random starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from standard data set "Stackloss"
x &lt;- stackloss

# Obtaining a user-defined rational start profile matrix
# (here the first 4 rows of the data)
start_allocation &lt;- get_rational(x, x[1:4, ])$A

</code></pre>

<hr>
<h2 id='get_semirandom'>Generate initial semi-random start</h2><span id='topic+get_semirandom'></span>

<h3>Description</h3>

<p>Generate an initial semi-random start for the (low dimensional) Additive
Profile Clustering
algorithm (see <code><a href="#topic+adproclus">adproclus</a></code> and <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_semirandom(data, nclusters, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_semirandom_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="get_semirandom_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to be used. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="get_semirandom_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator. Default: NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An initial cluster membership matrix <code class="reqn">A</code> is generated by
finding the best <code class="reqn">A</code> conditional
on an initial profile matrix
<code class="reqn">P</code> generated by drawing <em>k</em> randomly chosen, distinct,
rows from <code>data</code> (for details, see Depril et al., 2012).
</p>
<p><strong>Warning:</strong> This function does <em>not</em> obtain an ADPRCOLUS model. To
perform aditive profile clustering, see <code><a href="#topic+adproclus">adproclus</a></code>.
</p>


<h3>Value</h3>

<p><code>get_semirandom</code> returns a list with the following components:
</p>

<dl>
<dt><code>type</code></dt><dd><p>A character string denoting the type of start
('Semi-random Start')</p>
</dd>
<dt><code>A</code></dt><dd><p>An initial Membership matrix</p>
</dd></dl>



<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., &amp; Depril, D.
(2010). ADPROCLUS: a graphical user interface for fitting additive profile
clustering models to object by variable data matrices. <em>Behavior
Research Methods, 43</em>(1), 56-65.
</p>
<p>Depril, D., Van Mechelen, I., &amp; Mirkin, B. (2008). Algorithms for additive
clustering of rectangular data tables. <em>Computational Statistics and
Data Analysis, 52,</em> 4923-4938.
</p>
<p>#' Depril, D., Van Mechelen, I., &amp; Wilderjans, T. F.
(2012). Lowdimensional additive overlapping clustering.
<em>Journal of classification, 29,</em> 297-320.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code>, <code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for details
about membership and profile matrices</p>
</dd>
<dt><code><a href="#topic+get_random">get_random</a></code></dt><dd><p>for generating random starts</p>
</dd>
<dt><code><a href="#topic+get_rational">get_rational</a></code></dt><dd><p>for generating rational starts</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Obtain data from data set "Stackloss" and generate start allocation
start_allocation &lt;- get_semirandom(stackloss, 3)$A

</code></pre>

<hr>
<h2 id='mselect_adproclus'>Model selection helper for ADPROCLUS</h2><span id='topic+mselect_adproclus'></span>

<h3>Description</h3>

<p>Performs ADPROCLUS for the number of clusters from <code>min_nclusters</code> to <code>max_nclusters</code>.
This replaces the need to manually estimate multiple models to select the best
number of clusters and returns the results in a format compatible with
<code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code> to obtain a scree plot.
Output is also compatible with <code><a href="#topic+select_by_CHull">select_by_CHull</a></code> to
automatically select a suitable number of clusters.
The compatibility with both functions is only given if
<code>return_models = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mselect_adproclus(
  data,
  min_nclusters,
  max_nclusters,
  return_models = FALSE,
  unexplvar = TRUE,
  start_allocation = NULL,
  nrandomstart = 1,
  nsemirandomstart = 1,
  algorithm = "ALS2",
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mselect_adproclus_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_min_nclusters">min_nclusters</code></td>
<td>
<p>Minimum number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_max_nclusters">max_nclusters</code></td>
<td>
<p>Maximum number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_return_models">return_models</code></td>
<td>
<p>Boolean. If <code>FALSE</code> a vector of model fit scores is
returned, which is compatible with the <code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code> function.
If <code>TRUE</code> the list of actually estimated models is returned.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_unexplvar">unexplvar</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the model fit is specified in terms
of unexplained variance. Otherwise it will be specified in terms of
Sum of Squared Errors (SSE). This propagates through to the scree plots.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional starting cluster membership matrix to be
passed to the ADPROCLUS procedure. See <code><a href="#topic+get_rational">get_rational</a></code> for more information.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts computed for each model.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts computed for each model.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string &quot;<code>ALS1</code>&quot; or &quot;<code>ALS2</code>&quot; (default),
denoting the type of alternating least squares algorithm. Can be
abbreviated with &quot;1&quot; or &quot;2&quot;.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>return_models = TRUE</code>,
the results of all algorithm starts are returned.
By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with one column of SSE or unexplained variance scores for all estimated
models. Row names are the value of the cluster parameter for the relevant model.
Depends on the choice of <code>return_models</code>.
If <code>TRUE</code> a list of estimated models is returned.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus">adproclus</a></code></dt><dd><p>for the actual ADPROCLUS procedure</p>
</dd>
<dt><code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code></dt><dd><p>for plotting the model fits</p>
</dd>
<dt><code><a href="#topic+select_by_CHull">select_by_CHull</a></code></dt><dd><p>for automatic model selection via CHull method</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Estimating models with cluster parameter values ranging from 1 to 4
model_fits &lt;- mselect_adproclus(data = x, min_nclusters = 1, max_nclusters = 4, seed = 10)

# Plot the results as a scree plot to select the appropriate number of clusters
plot_scree_adpc(model_fits)

</code></pre>

<hr>
<h2 id='mselect_adproclus_low_dim'>Model selection helper for low dimensional ADPROCLUS</h2><span id='topic+mselect_adproclus_low_dim'></span>

<h3>Description</h3>

<p>Performs low dimensional ADPROCLUS for the number of clusters from
<code>min_nclusters</code> to <code>max_nclusters</code> and the number of components
from <code>min_ncomponents</code> to <code>max_ncomponents</code>.
This replaces the need to manually estimate multiple models to select the best
number of clusters and components and returns the results in a format compatible with
<code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code> to obtain a scree plot / multiple scree plots.
Output is also compatible with <code><a href="#topic+select_by_CHull">select_by_CHull</a></code> to
automatically select a suitable number of components for each number of clusters.
The compatibility with both functions is only given if
<code>return_models = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mselect_adproclus_low_dim(
  data,
  min_nclusters,
  max_nclusters,
  min_ncomponents,
  max_ncomponents,
  return_models = FALSE,
  unexplvar = TRUE,
  start_allocation = NULL,
  nrandomstart = 1,
  nsemirandomstart = 1,
  save_all_starts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mselect_adproclus_low_dim_+3A_data">data</code></td>
<td>
<p>Object-by-variable data matrix of class <code>matrix</code> or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_min_nclusters">min_nclusters</code></td>
<td>
<p>Minimum number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_max_nclusters">max_nclusters</code></td>
<td>
<p>Maximum number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_min_ncomponents">min_ncomponents</code></td>
<td>
<p>Minimum number of components to estimate.
Must be smaller or equal than <code>min_nclusters</code>.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_max_ncomponents">max_ncomponents</code></td>
<td>
<p>Maximum number of components to estimate.
Must be smaller or equal than <code>max_nclusters</code>.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_return_models">return_models</code></td>
<td>
<p>Boolean. If <code>FALSE</code> a matrix of model fit scores is
returned, which is compatible with the <code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code> function.
If <code>TRUE</code> the list of actually estimated models is returned.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_unexplvar">unexplvar</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the model fit is specified in terms
of unexplained variance. Otherwise it will be specified in terms of
Sum of Squared Errors (SSE). This propagates through to the scree plots.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_start_allocation">start_allocation</code></td>
<td>
<p>Optional starting cluster membership matrix to be
passed to the low dimensional ADPROCLUS procedure.
See <code><a href="#topic+get_rational">get_rational</a></code> for more information.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_nrandomstart">nrandomstart</code></td>
<td>
<p>Number of random starts computed for each model.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_nsemirandomstart">nsemirandomstart</code></td>
<td>
<p>Number of semi-random starts computed for each model.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_save_all_starts">save_all_starts</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>return_models = TRUE</code>,
the results of all algorithm starts are returned.
By default, only the best solution is retained.</p>
</td></tr>
<tr><td><code id="mselect_adproclus_low_dim_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for the random number generator.
Default: NULL, meaning no reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of clusters by number of components matrix
where the values are SSE or unexplained variance scores for all estimated
models. Row names are the value of the cluster parameter for the relevant
model. Column names contain the value of the components parameter.
Depends on the choice of <code>return_models</code>.
If <code>TRUE</code> a list of estimated models is returned.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+adproclus_low_dim">adproclus_low_dim</a></code></dt><dd><p>for the actual low dimensional ADPROCLUS procedure</p>
</dd>
<dt><code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code></dt><dd><p>for plotting the model fits</p>
</dd>
<dt><code><a href="#topic+select_by_CHull">select_by_CHull</a></code></dt><dd><p>for automatic model selection via CHull method</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Estimating models with cluster parameter values ranging from 1 to 4
# and component parameter values also ranging from 1 to 4
model_fits &lt;- mselect_adproclus_low_dim(data = x, 1, 4, 1, 4, seed = 1)

# Plot the results as a scree plot to select the appropriate number of clusters
plot_scree_adpc(model_fits)

</code></pre>

<hr>
<h2 id='plot_cluster_network'>Network plot of a (low dimensional) ADPROCLUS solution</h2><span id='topic+plot_cluster_network'></span>

<h3>Description</h3>

<p>Produce a representation of a (low dimensional) ADPROCLUS solution,
where each cluster is a vertex and the edge between two vertices represents
the overlap between the corresponding clusters.
The size of a vertex corresponds to the cluster size.
The overlap is represented through color, width and numerical label
of the edge.
The numerical edge labels can be relative
(number of overlap observations / total observations)
or absolute (number of observations in both clusters).
<strong>NOTE:</strong> This function can be called through the
<code>plot(model, type = "network")</code> function with model an
object of class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster_network(
  model,
  title = NULL,
  relative_overlap = TRUE,
  filetype = NULL,
  filename = "network_plot",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cluster_network_+3A_model">model</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>). Low dimensional model
possible.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_title">title</code></td>
<td>
<p>String. Optional title.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_relative_overlap">relative_overlap</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the number of
observations belonging to two clusters
is divided by the total number of observations. If <code>FALSE</code>
the number of observations in a cluster overlap will be displayed on the
edges.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_filetype">filetype</code></td>
<td>
<p>Optional. Choose type of file to save the plot.
Possible choices: <code>"R", "pdf", "svg", "tex", "jpg", "tiff", "png", ""</code>
Default: <code>NULL</code> does not create a file.</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_filename">filename</code></td>
<td>
<p>Optional. Name of the file without extension. Default: &quot;network_plot&quot;</p>
</td></tr>
<tr><td><code id="plot_cluster_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>qgraph::qgraph()</code> function, to customize the graph visualization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Plot the overlapping the clusters
plot_cluster_network(clust)
</code></pre>

<hr>
<h2 id='plot_profiles'>Plot profile matrix of ADPROCLUS solution</h2><span id='topic+plot_profiles'></span>

<h3>Description</h3>

<p>Produce a representation of profile matrix <code class="reqn">P</code>
(or <code class="reqn">C</code> for low dimensional solution) of an ADPROCLUS
solution of class <code>adpc</code>.
The plot displays the profiles in the style of a correlation plot.
<strong>NOTE:</strong> This function can also be called through the
<code>plot(model, type = "profiles")</code> function with model an object of
class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_profiles(model, title = NULL, label_color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_profiles_+3A_model">model</code></td>
<td>
<p>Object of class <code>adpc</code>. (Low dimensional) ADPROCLUS
solution</p>
</td></tr>
<tr><td><code id="plot_profiles_+3A_title">title</code></td>
<td>
<p>String. Optional title.</p>
</td></tr>
<tr><td><code id="plot_profiles_+3A_label_color">label_color</code></td>
<td>
<p>String. The color of the text labels. Default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot_profiles_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>corrplot::corrplot()</code> function, to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick clustering with K = 3 clusters
clust &lt;- adproclus(x, 3)

# Plot the profile scores of each cluster
plot_profiles(clust)
</code></pre>

<hr>
<h2 id='plot_scree_adpc'>Scree plot of (low dimensional) ADPROCLUS models</h2><span id='topic+plot_scree_adpc'></span>

<h3>Description</h3>

<p>Used for scree-plot based model selection. Visualizes a set of ADPROClUS models
in terms of their number of clusters and model fit (SSE or unexplained variance).
For low dimensional ADPROCLUS models plots are made with the number of
components on the x-axis for each given number of clusters. One can then
choose to have them displayed all in one plot (<code>grid = FALSE</code>) or next
to each other in separate plots (<code>grid = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scree_adpc(model_fit, title = NULL, grid = FALSE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scree_adpc_+3A_model_fit">model_fit</code></td>
<td>
<p>Matrix of SSE or unexplained variance scores as given by the
output of <code><a href="#topic+mselect_adproclus">mselect_adproclus</a></code> or
<code><a href="#topic+mselect_adproclus_low_dim">mselect_adproclus_low_dim</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scree_adpc_+3A_title">title</code></td>
<td>
<p>String. Optional title.</p>
</td></tr>
<tr><td><code id="plot_scree_adpc_+3A_grid">grid</code></td>
<td>
<p>Boolean. <code>FALSE</code> means for low dimensional ADPROCLUS all
lines will be in one plot. <code>TRUE</code> means separate plots.</p>
</td></tr>
<tr><td><code id="plot_scree_adpc_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of decimal places to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the <code>ggplot2</code> object.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+mselect_adproclus">mselect_adproclus</a></code></dt><dd><p>to obtain the <code>model_fit</code> input from the possible ADPROCLUS models</p>
</dd>
<dt><code><a href="#topic+mselect_adproclus_low_dim">mselect_adproclus_low_dim</a></code></dt><dd><p>to obtain the <code>model_fit</code> input from the possible low dimensional ADPROCLUS models</p>
</dd>
<dt><code><a href="#topic+select_by_CHull">select_by_CHull</a></code></dt><dd><p>for automatic model selection via CHull method</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Estimating models with cluster parameter values ranging from 1 to 4
model_fits &lt;- mselect_adproclus(data = x, min_nclusters = 1, max_nclusters = 4, seed = 1)

# Plot the results as a scree plot to select the appropriate number of clusters
plot_scree_adpc(model_fits)

# Estimating models with cluster parameter values ranging from 1 to 4
# and component parameter values also ranging from 1 to 4
model_fits &lt;- mselect_adproclus_low_dim(data = x, 1, 4, 1, 4, seed = 1)

# Plot the results as a scree plot to select the appropriate number of clusters
plot_scree_adpc(model_fits)

</code></pre>

<hr>
<h2 id='plot_scree_adpc_preselected'>Scree plot of a pre-selection of low dimensional ADPROCLUS models</h2><span id='topic+plot_scree_adpc_preselected'></span>

<h3>Description</h3>

<p>To be used when one has selected a number of components for each number
of clusters. Plots the remaining sets of models to compare SSE or unexplained
variances. The input <code>model_fit</code> is supposed to be the output from the
<code><a href="#topic+select_by_CHull">select_by_CHull</a></code> function applied to the output from
the <code><a href="#topic+mselect_adproclus_low_dim">mselect_adproclus_low_dim</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scree_adpc_preselected(model_fit, title = NULL, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scree_adpc_preselected_+3A_model_fit">model_fit</code></td>
<td>
<p>Matrix with SSE or unexplained variance values.
Can be obtained from <code><a href="#topic+select_by_CHull">select_by_CHull</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scree_adpc_preselected_+3A_title">title</code></td>
<td>
<p>String. Optional title.</p>
</td></tr>
<tr><td><code id="plot_scree_adpc_preselected_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of decimal places to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Estimating models with cluster parameter values ranging from 1 to 4
# and component parameter values also ranging from 1 to 4
model_fits &lt;- mselect_adproclus_low_dim(data = x, 1, 4, 1, 4, seed = 1)

# Choosing for each number of cluster the best number of components
model_fits_preselected &lt;- select_by_CHull(model_fits)

# Plot the results as a scree plot to select the appropriate number of clusters
plot_scree_adpc_preselected(model_fits_preselected)
</code></pre>

<hr>
<h2 id='plot_vars_by_comp'>Plot variable to component matrix of ADPROCLUS solution</h2><span id='topic+plot_vars_by_comp'></span>

<h3>Description</h3>

<p>Produce a representation of variable to component matrix
<code class="reqn">B'</code> of a <strong>low dimensional</strong> ADPROCLUS solution
of class <code>adpc</code>. The plot displays the scores in the style of a
correlation plot.
<strong>NOTE:</strong> This function can be called through the
<code>plot(model, type = "vars_by_comp")</code> function
with model an object of class <code>adpc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vars_by_comp(model, title = NULL, label_color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_vars_by_comp_+3A_model">model</code></td>
<td>
<p>Object of class <code>adpc</code>. Must be <strong>Low dimensional</strong>
ADPROCLUS solution</p>
</td></tr>
<tr><td><code id="plot_vars_by_comp_+3A_title">title</code></td>
<td>
<p>String. Optional title.</p>
</td></tr>
<tr><td><code id="plot_vars_by_comp_+3A_label_color">label_color</code></td>
<td>
<p>String. The color of the text labels. Default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot_vars_by_comp_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the
<code>corrplot::corrplot()</code> function, to customize the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Plot the matrix B', connecting components with variables
plot_vars_by_comp(clust)
</code></pre>

<hr>
<h2 id='plot.adpc'>Plotting a (low dimensional) ADPROCLUS solution</h2><span id='topic+plot.adpc'></span>

<h3>Description</h3>

<p>When passing a (low dimensional) ADPROCLUS solution of class <code>adpc</code> to
the generic <code>plot()</code>, this method plots the solution in one of the
following three ways:
</p>

<dl>
<dt>Network</dt><dd><p>Each cluster is a vertex and
the edge between two vertices represents the overlap between the
corresponding clusters. The size of a vertex corresponds to the cluster size.
The overlap is represented through color, width and numerical label of the
edge. The numerical edge-labels can be relative
(number of overlap observations / total observations)
or absolute (number of observations in both clusters).</p>
</dd>
<dt>Profiles</dt><dd><p>Plot the profile matrix (<code class="reqn">P</code>
for full dimensional model, <code class="reqn">C</code> for low dimensional model)
in the style of a correlation plot to visualize the relation of each cluster
with each variable.</p>
</dd>
<dt>Variables by components</dt><dd><p>Plot the low dimensional
component-by-variable matrix <code class="reqn">B'</code> in the style of a
correlation plot to visualize the relation of each component with each
original variable. <strong>NOTE:</strong> Only works for low dimensional ADPROCLUS.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
plot(x, type = "network", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.adpc_+3A_x">x</code></td>
<td>
<p>Object of class <code>adpc</code>. (Low dimensional) ADPROCLUS solution</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_type">type</code></td>
<td>
<p>Choice for type of plot: one of <code>"network", "profiles",
"vars_by_comp"</code>. Default: <code>"network"</code>. Partial matching allowed.</p>
</td></tr>
<tr><td><code id="plot.adpc_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed on to the functions
<code>plot_cluster_network(), plot_profiles(), plot_vars_by_comp()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Quick low dimensional clustering with K = 3 clusters and S = 1 dimensions
clust &lt;- adproclus_low_dim(x, 3, 1)

# Produce three plots of the model
plot(clust, type = "network")
plot(clust, type = "profiles")
plot(clust, type = "vars_by_comp")
</code></pre>

<hr>
<h2 id='print.adpc'>Print basic information on ADPROCLUS solution</h2><span id='topic+print.adpc'></span>

<h3>Description</h3>

<p>For an object of class <code>adpc</code> as input, this method prints basic
information about the ADPROCLUS solution represented by the object.
Works for both full and low dimensional solutions. Adjust the parameters
<code>digits, matrix_rows, matrix_cols</code>
to change the level of detail printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
print(
  x,
  title = "ADPROCLUS solution",
  digits = 3,
  matrix_rows = 10,
  matrix_cols = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.adpc_+3A_x">x</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>)</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of decimal places that all decimal numbers will
be rounded to.</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_matrix_rows">matrix_rows</code></td>
<td>
<p>Integer. The number of matrix rows to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_matrix_cols">matrix_cols</code></td>
<td>
<p>Integer. The number of matrix columns to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="print.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, print model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
print(model)
</code></pre>

<hr>
<h2 id='print.summary.adpc'>Print (low dimensional) ADPROCLUS summary</h2><span id='topic+print.summary.adpc'></span>

<h3>Description</h3>

<p>Prints an object of class <code>summary.adpc</code> to represent and summarize a
(low dimensional) ADPROCLUS solution. A number of parameters for how the
results should be printed can be passed as an argument to
<code>summary.adpc()</code> which then passes it on to this method. This method
does not take a model of class <code>adpc</code> directly as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.adpc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.adpc_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary.adpc</code></p>
</td></tr>
<tr><td><code id="print.summary.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns object of class <code>summary.adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, print summary of model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
print(summary(model))
</code></pre>

<hr>
<h2 id='select_by_CHull'>Automatic Model Selection for ADPROCLUS with CHull Method</h2><span id='topic+select_by_CHull'></span>

<h3>Description</h3>

<p>For a set of full dimensional ADPROCLUS models (each with different number of clusters),
this function finds the &quot;elbow&quot; in the scree plot by using the
CHull procedure (Wilderjans, Ceuleman &amp; Meers, 2013) implemented in
the <code>multichull</code> package.
For a matrix of low dimensional ADPROCLUS models
(each with different number of cluster and components),
this function finds the &quot;elbow&quot; in the scree plot for each
number of clusters with the CHull methods.
That is, it reduces the number of model to choose from to the number of
different cluster parameter values by choosing the &quot;elbow&quot; number of
components for a given number of clusters. The resulting list can in turn
be visualized with <code><a href="#topic+plot_scree_adpc_preselected">plot_scree_adpc_preselected</a></code>.
For this procedure to work, the SSE or unexplained variance values must be
decreasing in the number of clusters (components). If that is not the case
increasing the number of (semi-) random starts can help.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_by_CHull(model_fit, percentage_fit = 1e-04, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_by_CHull_+3A_model_fit">model_fit</code></td>
<td>
<p>Matrix containing SSEs or unexplained variance of all models
as in the output of <code><a href="#topic+mselect_adproclus">mselect_adproclus</a></code> or <code><a href="#topic+mselect_adproclus_low_dim">mselect_adproclus_low_dim</a></code>.</p>
</td></tr>
<tr><td><code id="select_by_CHull_+3A_percentage_fit">percentage_fit</code></td>
<td>
<p>Required proportion of increase in fit of a more complex model.</p>
</td></tr>
<tr><td><code id="select_by_CHull_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on to <code>multichull::CHull()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure cannot choose the model with
the largest or smallest number of clusters (components), i.e. for a set of
three models it will always choose the middle one. If for a given number of
clusters exactly two models were estimated, this function chooses the model
with the lower SSE/unexplained variance.
</p>
<p>The name of the model fit criterion is propagated from the input matrix based
on the first column name. It is either &quot;SSE&quot; or &quot;Unexplained_Variance&quot;.
</p>


<h3>Value</h3>

<p>For full dimensional ADPROCLUS a <code>CHull</code> object describing the
chosen model.
For low dimensional ADPROCLUS a matrix containing the list of chosen models
and the relevant model parameter, compatible with
<code><a href="#topic+plot_scree_adpc_preselected">plot_scree_adpc_preselected</a></code>.
</p>


<h3>References</h3>

<p>Wilderjans, T. F., Ceulemans, E., &amp; Meers, K. (2012). CHull: A generic convex hull based model
selection method. <em>Behavior Research Methods</em>, 45, 1-15
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+mselect_adproclus">mselect_adproclus</a></code></dt><dd><p>to obtain the <code>model_fit</code> input from the possible ADPROCLUS models</p>
</dd>
<dt><code><a href="#topic+mselect_adproclus_low_dim">mselect_adproclus_low_dim</a></code></dt><dd><p>to obtain the <code>model_fit</code> input from the possible low dimensional ADPROCLUS models</p>
</dd>
<dt><code><a href="#topic+plot_scree_adpc">plot_scree_adpc</a></code></dt><dd><p>for plotting the model fits</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Loading a test dataset into the global environment
x &lt;- stackloss

# Estimating models with cluster parameter values ranging from 1 to 4
model_fits &lt;- mselect_adproclus(data = x, min_nclusters = 1, max_nclusters = 4)

# Use and visualize CHull method
selected_model &lt;- select_by_CHull(model_fits)
selected_model
plot(selected_model)

# Estimating low dimensional models with cluster parameter values
# ranging from 1 to 4 and component parameter values also ranging from 1 to 4
model_fits &lt;- mselect_adproclus_low_dim(data = x, 1, 4, 1, 4, nsemirandomstart = 10, seed = 1)

# Using the CHull method
pre_selection &lt;- select_by_CHull(model_fits)

# Visualize pre-selected models
plot_scree_adpc_preselected(pre_selection)

</code></pre>

<hr>
<h2 id='summary.adpc'>Summary of ADPROCLUS solution</h2><span id='topic+summary.adpc'></span>

<h3>Description</h3>

<p>For an object of class <code>adpc</code> as input, this method yields a summary
object of class <code>summary.adpc</code> including group characteristics of the
clusters in the solution in terms of the model variables.
Works for both full and low dimensional solutions.
Adjust the parameters <code>digits, matrix_rows, matrix_cols</code> to change the
level of detail for the printing of the summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpc'
summary(
  object,
  title = "ADPROCLUS solution",
  digits = 3,
  matrix_rows = 10,
  matrix_cols = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.adpc_+3A_object">object</code></td>
<td>
<p>ADPROCLUS solution (class: <code>adpc</code>). Low dimensional model
possible.</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_title">title</code></td>
<td>
<p>String. Default: &quot;ADPROCLUS solution&quot;</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_digits">digits</code></td>
<td>
<p>Integer. The number of decimal places that all decimal numbers will be
rounded to.</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_matrix_rows">matrix_rows</code></td>
<td>
<p>Integer. The number of matrix rows to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_matrix_cols">matrix_cols</code></td>
<td>
<p>Integer. The number of matrix columns to display. OPTIONAL</p>
</td></tr>
<tr><td><code id="summary.adpc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns object of class <code>summary.adpc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data, compute model, summarize model
x &lt;- stackloss
model &lt;- adproclus(x, 3)
model_summary &lt;- summary(model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
