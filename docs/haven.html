<!DOCTYPE html><html lang="en"><head><title>Help for package haven</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {haven}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#haven-package'><p>haven: Import and Export 'SPSS', 'Stata' and 'SAS' Files</p></a></li>
<li><a href='#as_factor'><p>Convert labelled vectors to factors</p></a></li>
<li><a href='#labelled'><p>Create a labelled vector.</p></a></li>
<li><a href='#labelled_spss'><p>Labelled vectors for SPSS</p></a></li>
<li><a href='#print_labels'><p>Print the labels of a labelled vector</p></a></li>
<li><a href='#read_dta'><p>Read and write Stata DTA files</p></a></li>
<li><a href='#read_sas'><p>Read SAS files</p></a></li>
<li><a href='#read_spss'><p>Read and write SPSS files</p></a></li>
<li><a href='#read_xpt'><p>Read and write SAS transport files</p></a></li>
<li><a href='#tagged_na'><p>&quot;Tagged&quot; missing values</p></a></li>
<li><a href='#vec_arith.haven_labelled'><p>Internal vctrs methods</p></a></li>
<li><a href='#write_sas'><p>Write SAS files</p></a></li>
<li><a href='#zap_empty'><p>Convert empty strings into missing values</p></a></li>
<li><a href='#zap_formats'><p>Remove format attributes</p></a></li>
<li><a href='#zap_label'><p>Zap variable labels</p></a></li>
<li><a href='#zap_labels'><p>Zap value labels</p></a></li>
<li><a href='#zap_missing'><p>Zap special missings to regular R missings</p></a></li>
<li><a href='#zap_widths'><p>Remove display width attributes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Import and Export 'SPSS', 'Stata' and 'SAS' Files</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Import foreign statistical formats into R via the embedded
    'ReadStat' C library, <a href="https://github.com/WizardMac/ReadStat">https://github.com/WizardMac/ReadStat</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://haven.tidyverse.org">https://haven.tidyverse.org</a>, <a href="https://github.com/tidyverse/haven">https://github.com/tidyverse/haven</a>,
<a href="https://github.com/WizardMac/ReadStat">https://github.com/WizardMac/ReadStat</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/haven/issues">https://github.com/tidyverse/haven/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.0), forcats (&ge; 0.2.0), hms, lifecycle, methods,
readr (&ge; 0.1.0), rlang (&ge; 0.4.0), tibble, tidyselect, vctrs
(&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, fs, knitr, pillar (&ge; 1.4.0), rmarkdown,
testthat (&ge; 3.0.0), utf8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, zlib: zlib1g-dev (deb), zlib-devel (rpm)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 13:28:43 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Evan Miller [aut, cph] (Author of included ReadStat code),
  Danny Smith [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='haven-package'>haven: Import and Export 'SPSS', 'Stata' and 'SAS' Files</h2><span id='topic+haven'></span><span id='topic+haven-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Import foreign statistical formats into R via the embedded 'ReadStat' C library, <a href="https://github.com/WizardMac/ReadStat">https://github.com/WizardMac/ReadStat</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Evan Miller (Author of included ReadStat code) [copyright holder]
</p>
</li>
<li><p> Danny Smith
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://haven.tidyverse.org">https://haven.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/haven">https://github.com/tidyverse/haven</a>
</p>
</li>
<li> <p><a href="https://github.com/WizardMac/ReadStat">https://github.com/WizardMac/ReadStat</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/haven/issues">https://github.com/tidyverse/haven/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_factor'>Convert labelled vectors to factors</h2><span id='topic+as_factor'></span><span id='topic+as_factor.data.frame'></span><span id='topic+as_factor.haven_labelled'></span><span id='topic+as_factor.labelled'></span>

<h3>Description</h3>

<p>The base function <code>as.factor()</code> is not a generic, but <code><a href="forcats.html#topic+as_factor">forcats::as_factor()</a></code>
is. haven provides <code>as_factor()</code> methods for <code><a href="#topic+labelled">labelled()</a></code> and
<code><a href="#topic+labelled_spss">labelled_spss()</a></code> vectors, and data frames. By default, when applied to a
data frame, it only affects labelled columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as_factor(x, ..., only_labelled = TRUE)

## S3 method for class 'haven_labelled'
as_factor(
  x,
  levels = c("default", "labels", "values", "both"),
  ordered = FALSE,
  ...
)

## S3 method for class 'labelled'
as_factor(
  x,
  levels = c("default", "labels", "values", "both"),
  ordered = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_factor_+3A_x">x</code></td>
<td>
<p>Object to coerce to a factor.</p>
</td></tr>
<tr><td><code id="as_factor_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
<tr><td><code id="as_factor_+3A_only_labelled">only_labelled</code></td>
<td>
<p>Only apply to labelled columns?</p>
</td></tr>
<tr><td><code id="as_factor_+3A_levels">levels</code></td>
<td>
<p>How to create the levels of the generated factor:
</p>

<ul>
<li><p> &quot;default&quot;: uses labels where available, otherwise the values.
Labels are sorted by value.
</p>
</li>
<li><p> &quot;both&quot;: like &quot;default&quot;, but pastes together the level and value
</p>
</li>
<li><p> &quot;label&quot;: use only the labels; unlabelled values become <code>NA</code>
</p>
</li>
<li><p> &quot;values: use only the values
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_factor_+3A_ordered">ordered</code></td>
<td>
<p>If <code>TRUE</code> create an ordered (ordinal) factor, if
<code>FALSE</code> (the default) create a regular (nominal) factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Includes methods for both class <code>haven_labelled</code> and <code>labelled</code>
for backward compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- labelled(sample(5, 10, replace = TRUE), c(Bad = 1, Good = 5))

# Default method uses values where available
as_factor(x)
# You can also extract just the labels
as_factor(x, levels = "labels")
# Or just the values
as_factor(x, levels = "values")
# Or combine value and label
as_factor(x, levels = "both")

# as_factor() will preserve SPSS missing values from values and ranges
y &lt;- labelled_spss(1:10, na_values = c(2, 4), na_range = c(8, 10))
as_factor(y)
# use zap_missing() first to convert to NAs
zap_missing(y)
as_factor(zap_missing(y))
</code></pre>

<hr>
<h2 id='labelled'>Create a labelled vector.</h2><span id='topic+labelled'></span><span id='topic+is.labelled'></span>

<h3>Description</h3>

<p>A labelled vector is a common data structure in other statistical
environments, allowing you to assign text labels to specific values.
This class makes it possible to import such labelled vectors in to R
without loss of fidelity. This class provides few methods, as I
expect you'll coerce to a standard R class (e.g. a <code><a href="base.html#topic+factor">factor()</a></code>)
soon after importing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelled(x = double(), labels = NULL, label = NULL)

is.labelled(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelled_+3A_x">x</code></td>
<td>
<p>A vector to label. Must be either numeric (integer or double) or
character.</p>
</td></tr>
<tr><td><code id="labelled_+3A_labels">labels</code></td>
<td>
<p>A named vector or <code>NULL</code>. The vector should be the same type
as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction
of the values might be labelled.</p>
</td></tr>
<tr><td><code id="labelled_+3A_label">label</code></td>
<td>
<p>A short, human-readable description of the vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- labelled(c("M", "M", "F"), c(Male = "M", Female = "F"))
s2 &lt;- labelled(c(1, 1, 2), c(Male = 1, Female = 2))
s3 &lt;- labelled(
  c(1, 1, 2),
  c(Male = 1, Female = 2),
  label = "Assigned sex at birth"
)

# Unfortunately it's not possible to make as.factor work for labelled objects
# so instead use as_factor. This works for all types of labelled vectors.
as_factor(s1)
as_factor(s1, levels = "values")
as_factor(s2)

# Other statistical software supports multiple types of missing values
s3 &lt;- labelled(
  c("M", "M", "F", "X", "N/A"),
  c(Male = "M", Female = "F", Refused = "X", "Not applicable" = "N/A")
)
s3
as_factor(s3)

# Often when you have a partially labelled numeric vector, labelled values
# are special types of missing. Use zap_labels to replace labels with missing
# values
x &lt;- labelled(c(1, 2, 1, 2, 10, 9), c(Unknown = 9, Refused = 10))
zap_labels(x)
</code></pre>

<hr>
<h2 id='labelled_spss'>Labelled vectors for SPSS</h2><span id='topic+labelled_spss'></span>

<h3>Description</h3>

<p>This class is only used when <code>user_na = TRUE</code> in
<code><a href="#topic+read_sav">read_sav()</a></code>. It is similar to the <code><a href="#topic+labelled">labelled()</a></code> class
but it also models SPSS's user-defined missings, which can be up to
three distinct values, or for numeric vectors a range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelled_spss(
  x = double(),
  labels = NULL,
  na_values = NULL,
  na_range = NULL,
  label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelled_spss_+3A_x">x</code></td>
<td>
<p>A vector to label. Must be either numeric (integer or double) or
character.</p>
</td></tr>
<tr><td><code id="labelled_spss_+3A_labels">labels</code></td>
<td>
<p>A named vector or <code>NULL</code>. The vector should be the same type
as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction
of the values might be labelled.</p>
</td></tr>
<tr><td><code id="labelled_spss_+3A_na_values">na_values</code></td>
<td>
<p>A vector of values that should also be considered as missing.</p>
</td></tr>
<tr><td><code id="labelled_spss_+3A_na_range">na_range</code></td>
<td>
<p>A numeric vector of length two giving the (inclusive) extents
of the range. Use <code>-Inf</code> and <code>Inf</code> if you want the range to be
open ended.</p>
</td></tr>
<tr><td><code id="labelled_spss_+3A_label">label</code></td>
<td>
<p>A short, human-readable description of the vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- labelled_spss(1:10, c(Good = 1, Bad = 8), na_values = c(9, 10))
is.na(x1)

x2 &lt;- labelled_spss(
  1:10,
  c(Good = 1, Bad = 8),
  na_range = c(9, Inf),
  label = "Quality rating"
)
is.na(x2)

# Print data and metadata
x2
</code></pre>

<hr>
<h2 id='print_labels'>Print the labels of a labelled vector</h2><span id='topic+print_labels'></span>

<h3>Description</h3>

<p>This is a convenience function, useful to explore the variables of
a newly imported dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_labels(x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_labels_+3A_x">x</code></td>
<td>
<p>A labelled vector</p>
</td></tr>
<tr><td><code id="print_labels_+3A_name">name</code></td>
<td>
<p>The name of the vector (optional)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- labelled(c("M", "M", "F"), c(Male = "M", Female = "F"))
s2 &lt;- labelled(c(1, 1, 2), c(Male = 1, Female = 2))
labelled_df &lt;- tibble::tibble(s1, s2)

for (var in names(labelled_df)) {
  print_labels(labelled_df[[var]], var)
}
</code></pre>

<hr>
<h2 id='read_dta'>Read and write Stata DTA files</h2><span id='topic+read_dta'></span><span id='topic+read_stata'></span><span id='topic+write_dta'></span>

<h3>Description</h3>

<p>Currently haven can read and write logical, integer, numeric, character
and factors. See <code><a href="#topic+labelled">labelled()</a></code> for how labelled variables in
Stata are handled in R.
</p>
<p>Character vectors will be stored as <code>strL</code> if any components are
<code>strl_threshold</code> bytes or longer (and <code>version</code> &gt;= 13); otherwise they will
be stored as the appropriate <code>str#</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dta(
  file,
  encoding = NULL,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)

read_stata(
  file,
  encoding = NULL,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)

write_dta(
  data,
  path,
  version = 14,
  label = attr(data, "label"),
  strl_threshold = 2045,
  adjust_tz = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_dta_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding used for the file. Generally,
only needed for Stata 13 files and earlier. See Encoding section
for details.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_col_select">col_select</code></td>
<td>
<p>One or more selection expressions, like in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Use <code>c()</code> or <code>list()</code> to use more than one expression.
See <code>?dplyr::select</code> for details on available selection options. Only the
specified columns will be read from <code>data_file</code>.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_data">data</code></td>
<td>
<p>Data frame to write.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_path">path</code></td>
<td>
<p>Path to a file where the data will be written.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_version">version</code></td>
<td>
<p>File version to use. Supports versions 8-15.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_label">label</code></td>
<td>
<p>Dataset label to use, or <code>NULL</code>. Defaults to the value stored in
the &quot;label&quot; attribute of <code>data</code>. Must be &lt;= 80 characters.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_strl_threshold">strl_threshold</code></td>
<td>
<p>Any character vectors with a maximum length greater
than <code>strl_threshold</code> bytes will be stored as a long string (strL) instead
of a standard string (str#) variable if <code>version</code> &gt;= 13. This defaults to
2045, the maximum length of str# variables. See the Stata <a href="https://www.stata.com/features/overview/long-strings/">long string</a>
documentation for more details.</p>
</td></tr>
<tr><td><code id="read_dta_+3A_adjust_tz">adjust_tz</code></td>
<td>
<p>Stata, SPSS and SAS do not have a concept of time zone,
and all <a href="base.html#topic+date-time">date-time</a> variables are treated as UTC. <code>adjust_tz</code> controls
how the timezone of date-time values is treated when writing.
</p>

<ul>
<li><p> If <code>TRUE</code> (the default) the timezone of date-time values is ignored, and
they will display the same in R and Stata/SPSS/SAS, e.g.
<code>"2010-01-01 09:00:00 NZDT"</code> will be written as <code>"2010-01-01 09:00:00"</code>.
Note that this changes the underlying numeric data, so use caution if
preserving between-time-point differences is critical.
</p>
</li>
<li><p> If <code>FALSE</code>, date-time values are written as the corresponding UTC value,
e.g. <code>"2010-01-01 09:00:00 NZDT"</code> will be written as
<code>"2009-12-31 20:00:00"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, data frame variant with nice defaults.
</p>
<p>Variable labels are stored in the &quot;label&quot; attribute of each variable.
It is not printed on the console, but the RStudio viewer will show it.
</p>
<p>If a dataset label is defined in Stata, it will stored in the &quot;label&quot;
attribute of the tibble.
</p>
<p><code>write_dta()</code> returns the input <code>data</code> invisibly.
</p>


<h3>Character encoding</h3>

<p>Prior to Stata 14, files did not declare a text encoding, and the
default encoding differed across platforms. If <code>encoding = NULL</code>,
haven assumes the encoding is windows-1252, the text encoding used by
Stata on Windows. Unfortunately Stata on Mac and Linux use a different
default encoding, &quot;latin1&quot;. If you encounter an error such as
&quot;Unable to convert string to the requested encoding&quot;, try
<code>encoding = "latin1"</code>
</p>
<p>For Stata 14 and later, you should not need to manually specify <code>encoding</code>
value unless the value was incorrectly recorded in the source file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("examples", "iris.dta", package = "haven")
read_dta(path)

tmp &lt;- tempfile(fileext = ".dta")
write_dta(mtcars, tmp)
read_dta(tmp)
read_stata(tmp)
</code></pre>

<hr>
<h2 id='read_sas'>Read SAS files</h2><span id='topic+read_sas'></span>

<h3>Description</h3>

<p><code>read_sas()</code> supports both sas7bdat files and the accompanying sas7bcat files
that SAS uses to record value labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sas(
  data_file,
  catalog_file = NULL,
  encoding = NULL,
  catalog_encoding = encoding,
  col_select = NULL,
  skip = 0L,
  n_max = Inf,
  cols_only = deprecated(),
  .name_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_sas_+3A_data_file">data_file</code>, <code id="read_sas_+3A_catalog_file">catalog_file</code></td>
<td>
<p>Path to data and catalog files. The files are
processed with <code><a href="readr.html#topic+datasource">readr::datasource()</a></code>.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_encoding">encoding</code>, <code id="read_sas_+3A_catalog_encoding">catalog_encoding</code></td>
<td>
<p>The character encoding used for the
<code>data_file</code> and <code>catalog_encoding</code> respectively. A value of <code>NULL</code> uses the
encoding specified in the file; use this argument to override it if it is
incorrect.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_col_select">col_select</code></td>
<td>
<p>One or more selection expressions, like in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Use <code>c()</code> or <code>list()</code> to use more than one expression.
See <code>?dplyr::select</code> for details on available selection options. Only the
specified columns will be read from <code>data_file</code>.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_cols_only">cols_only</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>cols_only</code> is no longer
supported; use <code>col_select</code> instead.</p>
</td></tr>
<tr><td><code id="read_sas_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, data frame variant with nice defaults.
</p>
<p>Variable labels are stored in the &quot;label&quot; attribute of each variable. It is
not printed on the console, but the RStudio viewer will show it.
</p>
<p><code>write_sas()</code> returns the input <code>data</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("examples", "iris.sas7bdat", package = "haven")
read_sas(path)
</code></pre>

<hr>
<h2 id='read_spss'>Read and write SPSS files</h2><span id='topic+read_spss'></span><span id='topic+read_sav'></span><span id='topic+read_por'></span><span id='topic+write_sav'></span>

<h3>Description</h3>

<p><code>read_sav()</code> reads both <code>.sav</code> and <code>.zsav</code> files; <code>write_sav()</code> creates
<code>.zsav</code> files when <code>compress = TRUE</code>. <code>read_por()</code> reads <code>.por</code> files.
<code>read_spss()</code> uses either <code>read_por()</code> or <code>read_sav()</code> based on the
file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sav(
  file,
  encoding = NULL,
  user_na = FALSE,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)

read_por(
  file,
  user_na = FALSE,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)

write_sav(data, path, compress = c("byte", "none", "zsav"), adjust_tz = TRUE)

read_spss(
  file,
  user_na = FALSE,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_spss_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding used for the file. The default,
<code>NULL</code>, use the encoding specified in the file, but sometimes this
value is incorrect and it is useful to be able to override it.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_user_na">user_na</code></td>
<td>
<p>If <code>TRUE</code> variables with user defined missing will
be read into <code><a href="#topic+labelled_spss">labelled_spss()</a></code> objects. If <code>FALSE</code>, the
default, user-defined missings will be converted to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_col_select">col_select</code></td>
<td>
<p>One or more selection expressions, like in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Use <code>c()</code> or <code>list()</code> to use more than one expression.
See <code>?dplyr::select</code> for details on available selection options. Only the
specified columns will be read from <code>data_file</code>.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_data">data</code></td>
<td>
<p>Data frame to write.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_path">path</code></td>
<td>
<p>Path to a file where the data will be written.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_compress">compress</code></td>
<td>
<p>Compression type to use:
</p>

<ul>
<li><p> &quot;byte&quot;: the default, uses byte compression.
</p>
</li>
<li><p> &quot;none&quot;: no compression. This is useful for software that has issues with
byte compressed <code>.sav</code> files (e.g. SAS).
</p>
</li>
<li><p> &quot;zsav&quot;: uses zlib compression and produces a <code>.zsav</code> file. zlib
compression is supported by SPSS version 21.0 and above.
</p>
</li></ul>

<p><code>TRUE</code> and <code>FALSE</code> can be used for backwards compatibility, and correspond
to the &quot;zsav&quot; and &quot;none&quot; options respectively.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_adjust_tz">adjust_tz</code></td>
<td>
<p>Stata, SPSS and SAS do not have a concept of time zone,
and all <a href="base.html#topic+date-time">date-time</a> variables are treated as UTC. <code>adjust_tz</code> controls
how the timezone of date-time values is treated when writing.
</p>

<ul>
<li><p> If <code>TRUE</code> (the default) the timezone of date-time values is ignored, and
they will display the same in R and Stata/SPSS/SAS, e.g.
<code>"2010-01-01 09:00:00 NZDT"</code> will be written as <code>"2010-01-01 09:00:00"</code>.
Note that this changes the underlying numeric data, so use caution if
preserving between-time-point differences is critical.
</p>
</li>
<li><p> If <code>FALSE</code>, date-time values are written as the corresponding UTC value,
e.g. <code>"2010-01-01 09:00:00 NZDT"</code> will be written as
<code>"2009-12-31 20:00:00"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently haven can read and write logical, integer, numeric, character
and factors. See <code><a href="#topic+labelled_spss">labelled_spss()</a></code> for how labelled variables in
SPSS are handled in R.
</p>


<h3>Value</h3>

<p>A tibble, data frame variant with nice defaults.
</p>
<p>Variable labels are stored in the &quot;label&quot; attribute of each variable.
It is not printed on the console, but the RStudio viewer will show it.
</p>
<p><code>write_sav()</code> returns the input <code>data</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("examples", "iris.sav", package = "haven")
read_sav(path)

tmp &lt;- tempfile(fileext = ".sav")
write_sav(mtcars, tmp)
read_sav(tmp)
</code></pre>

<hr>
<h2 id='read_xpt'>Read and write SAS transport files</h2><span id='topic+read_xpt'></span><span id='topic+write_xpt'></span>

<h3>Description</h3>

<p>The SAS transport format is a open format, as is required for submission
of the data to the FDA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xpt(
  file,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)

write_xpt(
  data,
  path,
  version = 8,
  name = NULL,
  label = attr(data, "label"),
  adjust_tz = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_xpt_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_col_select">col_select</code></td>
<td>
<p>One or more selection expressions, like in
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Use <code>c()</code> or <code>list()</code> to use more than one expression.
See <code>?dplyr::select</code> for details on available selection options. Only the
specified columns will be read from <code>data_file</code>.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_data">data</code></td>
<td>
<p>Data frame to write.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_path">path</code></td>
<td>
<p>Path to a file where the data will be written.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_version">version</code></td>
<td>
<p>Version of transport file specification to use: either 5 or 8.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_name">name</code></td>
<td>
<p>Member name to record in file. Defaults to file name sans
extension. Must be &lt;= 8 characters for version 5, and &lt;= 32 characters
for version 8.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_label">label</code></td>
<td>
<p>Dataset label to use, or <code>NULL</code>. Defaults to the value stored in
the &quot;label&quot; attribute of <code>data</code>.
</p>
<p>Note that although SAS itself supports dataset labels up to 256 characters
long, dataset labels in SAS transport files must be &lt;= 40 characters.</p>
</td></tr>
<tr><td><code id="read_xpt_+3A_adjust_tz">adjust_tz</code></td>
<td>
<p>Stata, SPSS and SAS do not have a concept of time zone,
and all <a href="base.html#topic+date-time">date-time</a> variables are treated as UTC. <code>adjust_tz</code> controls
how the timezone of date-time values is treated when writing.
</p>

<ul>
<li><p> If <code>TRUE</code> (the default) the timezone of date-time values is ignored, and
they will display the same in R and Stata/SPSS/SAS, e.g.
<code>"2010-01-01 09:00:00 NZDT"</code> will be written as <code>"2010-01-01 09:00:00"</code>.
Note that this changes the underlying numeric data, so use caution if
preserving between-time-point differences is critical.
</p>
</li>
<li><p> If <code>FALSE</code>, date-time values are written as the corresponding UTC value,
e.g. <code>"2010-01-01 09:00:00 NZDT"</code> will be written as
<code>"2009-12-31 20:00:00"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, data frame variant with nice defaults.
</p>
<p>Variable labels are stored in the &quot;label&quot; attribute of each variable.
It is not printed on the console, but the RStudio viewer will show it.
</p>
<p>If a dataset label is defined, it will be stored in the &quot;label&quot; attribute
of the tibble.
</p>
<p><code>write_xpt()</code> returns the input <code>data</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile(fileext = ".xpt")
write_xpt(mtcars, tmp)
read_xpt(tmp)
</code></pre>

<hr>
<h2 id='tagged_na'>&quot;Tagged&quot; missing values</h2><span id='topic+tagged_na'></span><span id='topic+na_tag'></span><span id='topic+is_tagged_na'></span><span id='topic+format_tagged_na'></span><span id='topic+print_tagged_na'></span>

<h3>Description</h3>

<p>&quot;Tagged&quot; missing values work exactly like regular R missing values except
that they store one additional byte of information a tag, which is usually
a letter (&quot;a&quot; to &quot;z&quot;). When by loading a SAS and Stata file, the tagged
missing values always use lower case values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagged_na(...)

na_tag(x)

is_tagged_na(x, tag = NULL)

format_tagged_na(x, digits = getOption("digits"))

print_tagged_na(x, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tagged_na_+3A_...">...</code></td>
<td>
<p>Vectors containing single character. The letter will be used to
&quot;tag&quot; the missing value.</p>
</td></tr>
<tr><td><code id="tagged_na_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="tagged_na_+3A_tag">tag</code></td>
<td>
<p>If <code>NULL</code>, will only return true if the tag has this value.</p>
</td></tr>
<tr><td><code id="tagged_na_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use in string representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>format_tagged_na()</code> and <code>print_tagged_na()</code> format tagged
NA's as NA(a), NA(b), etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:5, tagged_na("a"), tagged_na("z"), NA)

# Tagged NA's work identically to regular NAs
x
is.na(x)

# To see that they're special, you need to use na_tag(),
# is_tagged_na(), or print_tagged_na():
is_tagged_na(x)
na_tag(x)
print_tagged_na(x)

# You can test for specific tagged NAs with the second argument
is_tagged_na(x, "a")

# Because the support for tagged's NAs is somewhat tagged on to R,
# the left-most NA will tend to be preserved in arithmetic operations.
na_tag(tagged_na("a") + tagged_na("z"))
</code></pre>

<hr>
<h2 id='vec_arith.haven_labelled'>Internal vctrs methods</h2><span id='topic+vec_arith.haven_labelled'></span>

<h3>Description</h3>

<p>Internal vctrs methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haven_labelled'
vec_arith(op, x, y, ...)
</code></pre>

<hr>
<h2 id='write_sas'>Write SAS files</h2><span id='topic+write_sas'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>write_sas()</code> creates sas7bdat files. Unfortunately the SAS file format is
complex and undocumented, so <code>write_sas()</code> is unreliable and in most cases
SAS will not read files that it produces.
</p>
<p><code><a href="#topic+write_xpt">write_xpt()</a></code> writes files in the open SAS transport format, which has
limitations but will be reliably read by SAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_sas(data, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_sas_+3A_data">data</code></td>
<td>
<p>Data frame to write.</p>
</td></tr>
<tr><td><code id="write_sas_+3A_path">path</code></td>
<td>
<p>Path to file where the data will be written.</p>
</td></tr>
</table>

<hr>
<h2 id='zap_empty'>Convert empty strings into missing values</h2><span id='topic+zap_empty'></span>

<h3>Description</h3>

<p>Convert empty strings into missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_empty(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_empty_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with empty strings replaced by missing values.
</p>


<h3>See Also</h3>

<p>Other zappers: 
<code><a href="#topic+zap_formats">zap_formats</a>()</code>,
<code><a href="#topic+zap_labels">zap_labels</a>()</code>,
<code><a href="#topic+zap_label">zap_label</a>()</code>,
<code><a href="#topic+zap_widths">zap_widths</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "", "c")
zap_empty(x)
</code></pre>

<hr>
<h2 id='zap_formats'>Remove format attributes</h2><span id='topic+zap_formats'></span>

<h3>Description</h3>

<p>To provide some mild support for round-tripping variables between Stata/SPSS
and R, haven stores variable formats in an attribute: <code>format.stata</code>,
<code>format.spss</code>, or <code>format.sas</code>. If this causes problems for your
code, you can get rid of them with <code>zap_formats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_formats(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_formats_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other zappers: 
<code><a href="#topic+zap_empty">zap_empty</a>()</code>,
<code><a href="#topic+zap_labels">zap_labels</a>()</code>,
<code><a href="#topic+zap_label">zap_label</a>()</code>,
<code><a href="#topic+zap_widths">zap_widths</a>()</code>
</p>

<hr>
<h2 id='zap_label'>Zap variable labels</h2><span id='topic+zap_label'></span>

<h3>Description</h3>

<p>Removes variable label, leaving unlabelled vectors as is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_label(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_label_+3A_x">x</code></td>
<td>
<p>A vector or data frame</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+zap_labels">zap_labels()</a></code> to remove value labels.
</p>
<p>Other zappers: 
<code><a href="#topic+zap_empty">zap_empty</a>()</code>,
<code><a href="#topic+zap_formats">zap_formats</a>()</code>,
<code><a href="#topic+zap_labels">zap_labels</a>()</code>,
<code><a href="#topic+zap_widths">zap_widths</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- labelled(1:5, c(good = 1, bad = 5), label = "rating")
x1
zap_label(x1)

x2 &lt;- labelled_spss(c(1:4, 9), label = "score", na_values = 9)
x2
zap_label(x2)

# zap_label also works with data frames
df &lt;- tibble::tibble(x1, x2)
str(df)
str(zap_label(df))
</code></pre>

<hr>
<h2 id='zap_labels'>Zap value labels</h2><span id='topic+zap_labels'></span><span id='topic+zap_labels.haven_labelled_spss'></span>

<h3>Description</h3>

<p>Removes value labels, leaving unlabelled vectors as is. Use this if you
want to simply drop all <code>labels</code> from a data frame.
</p>
<p>Zapping labels from <code><a href="#topic+labelled_spss">labelled_spss()</a></code> also removes user-defined missing
values by default, replacing with standard <code>NA</code>s. Use the <code>user_na</code> argument
to override this behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_labels(x, ...)

## S3 method for class 'haven_labelled_spss'
zap_labels(x, ..., user_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_labels_+3A_x">x</code></td>
<td>
<p>A vector or data frame</p>
</td></tr>
<tr><td><code id="zap_labels_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
<tr><td><code id="zap_labels_+3A_user_na">user_na</code></td>
<td>
<p>If <code>FALSE</code>, the default, <code>zap_labels()</code> will convert
<code><a href="#topic+labelled_spss">labelled_spss()</a></code> user-defined missing values to <code>NA</code>. If <code>TRUE</code> they
will be treated like normal values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+zap_label">zap_label()</a></code> to remove variable labels.
</p>
<p>Other zappers: 
<code><a href="#topic+zap_empty">zap_empty</a>()</code>,
<code><a href="#topic+zap_formats">zap_formats</a>()</code>,
<code><a href="#topic+zap_label">zap_label</a>()</code>,
<code><a href="#topic+zap_widths">zap_widths</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- labelled(1:5, c(good = 1, bad = 5))
x1
zap_labels(x1)

x2 &lt;- labelled_spss(c(1:4, 9), c(good = 1, bad = 5), na_values = 9)
x2
zap_labels(x2)

# Keep the user defined missing values
zap_labels(x2, user_na = TRUE)

# zap_labels also works with data frames
df &lt;- tibble::tibble(x1, x2)
df
zap_labels(df)
</code></pre>

<hr>
<h2 id='zap_missing'>Zap special missings to regular R missings</h2><span id='topic+zap_missing'></span>

<h3>Description</h3>

<p>This is useful if you want to convert tagged missing values from SAS or
Stata, or user-defined missings from SPSS, to regular R <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_missing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_missing_+3A_x">x</code></td>
<td>
<p>A vector or data frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- labelled(
  c(1, 5, tagged_na("a", "b")),
  c(Unknown = tagged_na("a"), Refused = tagged_na("b"))
)
x1
zap_missing(x1)

x2 &lt;- labelled_spss(
  c(1, 2, 1, 99),
  c(missing = 99),
  na_value = 99
)
x2
zap_missing(x2)

# You can also apply to data frames
df &lt;- tibble::tibble(x1, x2, y = 4:1)
df
zap_missing(df)
</code></pre>

<hr>
<h2 id='zap_widths'>Remove display width attributes</h2><span id='topic+zap_widths'></span>

<h3>Description</h3>

<p>To provide some mild support for round-tripping variables between SPSS
and R, haven stores display widths in an attribute: <code>display_width</code>. If this
causes problems for your code, you can get rid of them with <code>zap_widths</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_widths(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_widths_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other zappers: 
<code><a href="#topic+zap_empty">zap_empty</a>()</code>,
<code><a href="#topic+zap_formats">zap_formats</a>()</code>,
<code><a href="#topic+zap_labels">zap_labels</a>()</code>,
<code><a href="#topic+zap_label">zap_label</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
