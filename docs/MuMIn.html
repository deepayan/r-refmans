<!DOCTYPE html><html><head><title>Help for package MuMIn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MuMIn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MuMIn-package'><p>Multi-model inference</p></a></li>
<li><a href='#AICc'><p>Second-order Akaike Information Criterion</p></a></li>
<li><a href='#arm.glm'><p>Adaptive Regression by Mixing</p></a></li>
<li><a href='#Beetle'><p>Flour beetle mortality data</p></a></li>
<li><a href='#BGWeights'><p>Bates-Granger minimal variance model weights</p></a></li>
<li><a href='#bootWeights'><p>Bootstrap model weights</p></a></li>
<li><a href='#Cement'><p>Cement hardening data</p></a></li>
<li><a href='#coefplot'><p>Plot model coefficients</p></a></li>
<li><a href='#cos2Weights'><p>Cos-squared model weights</p></a></li>
<li><a href='#dredge'><p>Automated model selection</p></a></li>
<li><a href='#exprApply'><p>Apply a function to calls inside an expression</p></a></li>
<li><a href='#Formula+20manipulation'><p>Manipulate model formulas</p></a></li>
<li><a href='#get.models'><p>Retrieve models from selection table</p></a></li>
<li><a href='#GPA'><p>Grade Point Average data</p></a></li>
<li><a href='#Information+20criteria'><p>Various information criteria</p></a></li>
<li><a href='#jackknifeWeights'><p>Jackknifed model weights</p></a></li>
<li><a href='#loo'><p>Leave-one-out cross-validation</p></a></li>
<li><a href='#merge.model.selection'><p>Combine model selection tables</p></a></li>
<li><a href='#Model+20utilities'><p>Model utility functions</p></a></li>
<li><a href='#model.avg'><p>Model averaging</p></a></li>
<li><a href='#model.sel'><p>model selection table</p></a></li>
<li><a href='#model.selection.object'><p>Description of Model Selection Objects</p></a></li>
<li><a href='#MuMIn-models'><p>List of supported models</p></a></li>
<li><a href='#nested'><p>Identify nested models</p></a></li>
<li><a href='#par.avg'><p>Parameter averaging</p></a></li>
<li><a href='#pdredge'><p>Automated model selection using parallel computation</p></a></li>
<li><a href='#plot.model.selection'><p>Visualize model selection table</p></a></li>
<li><a href='#predict.averaging'><p>Predict method for averaged models</p></a></li>
<li><a href='#QAIC'><p>Quasi AIC or AICc</p></a></li>
<li><a href='#QIC'><p>QIC and quasi-Likelihood for GEE</p></a></li>
<li><a href='#r.squaredGLMM'><p>Pseudo-R-squared for Generalized Mixed-Effect models</p></a></li>
<li><a href='#r.squaredLR'><p>Likelihood-ratio based pseudo-R-squared</p></a></li>
<li><a href='#stackingWeights'><p>Stacking model weights</p></a></li>
<li><a href='#std.coef'><p>Standardized model coefficients</p></a></li>
<li><a href='#stdize'><p>Standardize data</p></a></li>
<li><a href='#subset.model.selection'><p>Subsetting model selection table</p></a></li>
<li><a href='#sw'><p>Per-variable sum of model weights</p></a></li>
<li><a href='#updateable'><p>Make a function return updateable result</p></a></li>
<li><a href='#Weights'><p>Akaike weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Model Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.47.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-15</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Kamil Bartoń</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kamil Bartoń &lt;kamil.barton@go2.pl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for performing model selection and model averaging. Automated
             model selection through subsetting the maximum model, with optional
             constraints for model inclusion. Model parameter and prediction
             averaging based on model weights derived from information criteria
             (AICc and alike) or custom model weighting schemes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, Matrix, stats, stats4, nlme, insight</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4 (&ge; 1.1.0), mgcv (&ge; 1.7.5), gamm4, MASS, nnet, survival
(&ge; 3.1.0), geepack</td>
</tr>
<tr>
<td>Enhances:</td>
<td>aod, aods3, betareg, caper, coxme, cplm, gee, glmmML,
logistf, MCMCglmm, ordinal, pscl, spatialreg, splm, unmarked
(&ge; 0.12.2), geeM (&ge; 0.7.5), gamlss</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 14:27:12 UTC; kb2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 16:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='MuMIn-package'>Multi-model inference</h2><span id='topic+MuMIn-package'></span><span id='topic+MuMIn'></span>

<h3>Description</h3>

<p>The package <span class="pkg">MuMIn</span> contains functions to streamline information-theoretic
model selection and carry out model averaging based on information criteria.
</p>


<h3>Details</h3>

<p>The suite of functions includes:
</p>

<dl>
<dt><code><a href="#topic+dredge">dredge</a></code></dt><dd><p>performs automated model selection by generating
subsets of the supplied &lsquo;global&rsquo; model and optional
choices of other model properties (such as different link functions).
The set of models can be generated with &lsquo;all possible&rsquo;
combinations or tailored according to specified conditions.
</p>
</dd>
<dt><code><a href="#topic+model.sel">model.sel</a></code></dt><dd><p>creates a model selection table from
selected models. </p>
</dd>
<dt><code><a href="#topic+model.avg">model.avg</a></code></dt><dd><p>calculates model-averaged parameters,
along with standard errors and confidence intervals.
The <code><a href="#topic+predict.averaging">predict</a></code> method 
produces model-averaged predictions. </p>
</dd>
<dt><code><a href="#topic+AICc">AICc</a></code></dt><dd><p>calculates the second-order Akaike information
criterion. Some other criteria are provided, see below. </p>
</dd>
<dt><code><a href="#topic+stdize">stdize</a></code>, <code><a href="#topic+stdizeFit">stdizeFit</a></code>, <code><a href="#topic+std.coef">std.coef</a></code>,
<code><a href="#topic+partial.sd">partial.sd</a></code></dt><dd><p>can be used to standardise data and
model coefficients by standard deviation or partial standard deviation.
</p>
</dd>
</dl>

<p>For a complete list of functions, use <code>library(help = "MuMIn")</code>.
</p>
<p>By default, AIC<code class="reqn">_{c}</code> is used to rank models and obtain model
weights, although any information criterion can be used. At least the 
following are currently implemented in <span class="rlang"><b>R</b></span>:
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code> in package <span class="pkg">stats</span>, and
<code><a href="#topic+QAIC">QAIC</a></code>, <code><a href="#topic+QAICc">QAICc</a></code>, <code><a href="#topic+ICOMP">ICOMP</a></code>,
<code><a href="#topic+CAICF">CAICF</a></code>, and <a href="#topic+Mallows+27+20Cp">Mallows' Cp</a> in <span class="pkg">MuMIn</span>. There is also a
<code><a href="#topic+DIC">DIC</a></code> extractor for <abbr><span class="acronym">MCMC</span></abbr> models and a <code><a href="#topic+QIC">QIC</a></code> for
<abbr><span class="acronym">GEE</span></abbr>.
</p>
<p>Many common modelling functions in <span class="rlang"><b>R</b></span> are supported. For a complete list,
see <a href="#topic+MuMIn-models">the list of supported models</a>.
</p>
<p>In addition to &ldquo;regular&rdquo; information criteria, model averaging can be 
performed using various types of model weighting algorithms:
<a href="#topic+BGWeights">Bates-Granger</a>,
<a href="#topic+BGWeights">bootstrapped</a>,
<a href="#topic+cos2Weights">cos-squared</a>,
<a href="#topic+jackknifeWeights">jackknife</a>,
<a href="#topic+stackingWeights">stacking</a>, or
<a href="#topic+armWeights">ARM</a>. 
These weighting functions are mainly applicable to <code>glm</code>s.
</p>


<h3>Author(s)</h3>

<p> Kamil Bartoń </p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+step">step</a></code> or <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code> for stepwise
model selection by AIC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
options(na.action = "na.fail") #  change the default "na.omit" to prevent models 
                               #  from being fitted to different datasets in 
                               #  case of missing values.

fm1 &lt;- lm(y ~ ., data = Cement)
ms1 &lt;- dredge(fm1)

# Visualize the model selection table:

par(mar = c(3,5,6,4))
plot(ms1, labAsExpr = TRUE)

model.avg(ms1, subset = delta &lt; 4)

confset.95p &lt;- get.models(ms1, cumsum(weight) &lt;= .95)
avgmod.95p &lt;- model.avg(confset.95p)
summary(avgmod.95p)
confint(avgmod.95p)

</code></pre>

<hr>
<h2 id='AICc'>Second-order Akaike Information Criterion</h2><span id='topic+AICc'></span>

<h3>Description</h3>

<p>Calculate Second-order Akaike Information Criterion for one or several fitted
model objects (AIC<code class="reqn">_{c}</code>, AIC for small samples). </p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(object, ..., k = 2, REML = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICc_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a <code>logLik</code>
method, or a <code>"logLik"</code> object. </p>
</td></tr>
<tr><td><code id="AICc_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects. </p>
</td></tr>
<tr><td><code id="AICc_+3A_k">k</code></td>
<td>
<p>the &lsquo;penalty&rsquo; per parameter to be used; the default
<code>k = 2</code> is the classical AIC. </p>
</td></tr>
<tr><td><code id="AICc_+3A_reml">REML</code></td>
<td>
<p> optional logical value, passed to the <code>logLik</code> method
indicating whether the restricted log-likelihood or log-likelihood should be
used. The default is to use the method used for model estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If just one object is provided, returns a numeric value with the
corresponding AIC<code class="reqn">_{c}</code>; if more than one object are provided, returns a
<code>data.frame</code> with rows corresponding to the objects and columns
representing the number of parameters in the model (<em>df</em>) and AIC<code class="reqn">_{c}</code>.
</p>


<h3>Note</h3>

<p>AIC<code class="reqn">_{c}</code> should be used instead AIC when sample size is small in
comparison to the number of estimated parameters (Burnham &amp; Anderson 2002
recommend its use when <code class="reqn">n / K &lt; 40</code>).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>
<p>Hurvich, C. M. and Tsai, C.-L. 1989 Regression and time series model selection
in small samples, <em>Biometrika</em> <b>76</b>, 297–307.
</p>


<h3>See Also</h3>

<p>Akaike's An Information Criterion: <code><a href="stats.html#topic+AIC">AIC</a></code>
</p>
<p>Some other implementations:
<code><a href="AICcmodavg.html#topic+AICc">AICc</a></code> in package <span class="pkg">AICcmodavg</span>,
<code><a href="bbmle.html#topic+BIC-methods">AICc</a></code> in package <span class="pkg">bbmle</span>,
<code><a href="glmulti.html#topic+aic">aicc</a></code> in package <span class="pkg">glmulti</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Model-averaging mixed models

options(na.action = "na.fail")

data(Orthodont, package = "nlme")

# Fit model by REML
fm2 &lt;- lme(distance ~ Sex*age, data = Orthodont,
    random = ~ 1|Subject / Sex, method = "REML")

# Model selection: ranking by AICc using ML
ms2 &lt;- dredge(fm2, trace = TRUE, rank = "AICc", REML = FALSE)

(attr(ms2, "rank.call"))

# Get the models (fitted by REML, as in the global model)
fmList &lt;- get.models(ms2, 1:4)

# Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
# the default weights in 'model.avg' are ML based:
summary(model.avg(fmList))

## Not run: 
# the same result:
model.avg(fmList, rank = "AICc", rank.args = list(REML = FALSE))

## End(Not run)

</code></pre>

<hr>
<h2 id='arm.glm'>Adaptive Regression by Mixing</h2><span id='topic+arm.glm'></span><span id='topic+armWeights'></span>

<h3>Description</h3>

<p>Combine all-subsets GLMs using the ARM algorithm.
Calculate ARM weights for a set of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arm.glm(object, R = 250, weight.by = c("aic", "loglik"), trace = FALSE)

armWeights(object, ..., data, weight.by = c("aic", "loglik"), R = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arm.glm_+3A_object">object</code></td>
<td>
<p>for <code>arm.glm</code>, a fitted &ldquo;global&rdquo; <code>glm</code> object.
For <code>armWeights</code>, a fitted <code><a href="stats.html#topic+glm">glm</a></code> object, or a
<code>list</code> of such, or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object. </p>
</td></tr>
<tr><td><code id="arm.glm_+3A_...">...</code></td>
<td>
<p>more fitted model objects. </p>
</td></tr>
<tr><td><code id="arm.glm_+3A_r">R</code></td>
<td>
<p>number of permutations. </p>
</td></tr>
<tr><td><code id="arm.glm_+3A_weight.by">weight.by</code></td>
<td>
<p>indicates whether model weights should be calculated with AIC
or log-likelihood. </p>
</td></tr>
<tr><td><code id="arm.glm_+3A_trace">trace</code></td>
<td>
<p>if <code>TRUE</code>, information is printed during the running of
<code>arm.glm</code>. </p>
</td></tr>
<tr><td><code id="arm.glm_+3A_data">data</code></td>
<td>
<p>a data frame in which to look for variables for use with 
<a href="stats.html#topic+predict">prediction</a>. If omitted, the fitted linear predictors are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of all-subsets of the &ldquo;global&rdquo; model, parameters are estimated 
using randomly sampled half of the data. Log-likelihood given the remaining half
of the data is used to calculate AIC weights. This is repeated <code>R</code> 
times and mean of the weights is used to average all-subsets parameters 
estimated using complete data.
</p>


<h3>Value</h3>

<p><code>arm.glm</code> returns an object of class <code>"averaging"</code> contaning only 
&ldquo;full&rdquo; averaged coefficients. See <code><a href="#topic+model.avg">model.avg</a></code> for object 
description.
</p>
<p><code>armWeights</code> returns a numeric vector of model weights.
</p>


<h3>Note</h3>

<p>Number of parameters is limited to <code>floor(nobs(object) / 2) - 1</code>.
All-subsets respect marginality constraints.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Yang, Y. 2001 Adaptive Regression by Mixing. 
<em>Journal of the American Statistical Association</em> <b>96</b>, 574–588.
</p>
<p>Yang, Y. 2003 Regression with multiple candidate models: selecting or mixing? 
<em>Statistica Sinica</em> <b>13</b>, 783–810.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.avg">model.avg</a></code>, <code><a href="#topic+par.avg">par.avg</a></code>
</p>
<p><code><a href="#topic+Weights">Weights</a></code> for assigning new model weights to an <code>"averaging"</code>
object.
</p>
<p>Other implementation of ARM algorithm: <code>arms</code> in (archived) package
<b>MMIX</b>.
</p>
<p>Other kinds of model weights: <code><a href="#topic+BGWeights">BGWeights</a></code>, 
<code><a href="#topic+bootWeights">bootWeights</a></code>, 
<code><a href="#topic+cos2Weights">cos2Weights</a></code>, <code><a href="#topic+jackknifeWeights">jackknifeWeights</a></code>,
<code><a href="#topic+stackingWeights">stackingWeights</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm(y ~ X1 + X2 + X3 + X4, data = Cement)

summary(am1 &lt;- arm.glm(fm, R = 15))

mst &lt;- dredge(fm)

am2 &lt;- model.avg(mst, fit = TRUE)

Weights(am2) &lt;- armWeights(am2, data = Cement, R = 15)

# differences are due to small R:
coef(am1, full = TRUE)
coef(am2, full = TRUE)


</code></pre>

<hr>
<h2 id='Beetle'>Flour beetle mortality data</h2><span id='topic+Beetle'></span>

<h3>Description</h3>

<p>Mortality of flour beetles (<em>Tribolium confusum</em>) due to exposure to gaseous
carbon disulfide CS<code class="reqn">_{2}</code>, from Bliss (1935).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beetle
</code></pre>


<h3>Format</h3>

<p><code>Beetle</code> is a data frame with 5 elements.
</p>

<dl>
<dt>Prop</dt><dd><p>a matrix with two columns named <b>nkilled</b> and <b>nsurvived</b></p>
</dd>
<dt>mortality</dt><dd><p>observed mortality rate</p>
</dd>  
<dt>dose</dt><dd><p>the dose of CS<code class="reqn">_{2}</code> in mg/L</p>
</dd>
<dt>n.tested</dt><dd><p>number of beetles tested</p>
</dd>
<dt>n.killed</dt><dd><p>number of beetles killed.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bliss, C. I. 1935 The calculation of the dosage-mortality curve.
<em>Annals of Applied Biology</em> <b>22</b>, 134&ndash;167.
</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# "Logistic regression example"
# from Burnham &amp; Anderson (2002) chapter 4.11
# Fit a global model with all the considered variables

globmod &lt;- glm(Prop ~ dose + I(dose^2) + log(dose) + I(log(dose)^2),
   data = Beetle, family = binomial, na.action = na.fail)
# A logical expression defining the subset of models to use:
# * either log(dose) or dose
# * the quadratic terms can appear only together with linear terms
msubset &lt;- expression(xor(dose, `log(dose)`) &amp;
    dc(dose, `I(dose^2)`) &amp;
    dc(`log(dose)`, `I(log(dose)^2)`))

# Table 4.6
# Use 'varying' argument to fit models with different link functions
# Note the use of 'alist' rather than 'list' in order to keep the
# 'family' objects unevaluated
varying.link &lt;- list(family = alist(
    logit = binomial("logit"),
    probit = binomial("probit"),
    cloglog = binomial("cloglog")
    ))

(ms12 &lt;- dredge(globmod, subset = msubset, varying = varying.link,
    rank = AIC))
 
# Table 4.7 "models justifiable a priori"
(ms3 &lt;- subset(ms12, has(dose, !`I(dose^2)`))) 
# The same result, but would fit the models again:
# ms3 &lt;- update(ms12, update(globmod, . ~ dose), subset =,
#    fixed = ~dose)
mod3 &lt;- get.models(ms3, 1:3) 
# Table 4.8. Predicted mortality probability at dose 40.
# calculate confidence intervals on logit scale
logit.ci &lt;- function(p, se, quantile = 2) {
    C. &lt;- exp(quantile * se / (p * (1 - p))) 
    p /(p + (1 - p) * c(C., 1/C.)) 
}

mavg3 &lt;- model.avg(mod3, revised.var = FALSE) 
# get predictions both from component and averaged models
pred &lt;- lapply(c(component = mod3, list(averaged = mavg3)), predict,
	   newdata = list(dose = 40), type = "response", se.fit = TRUE) 
# reshape predicted values
pred &lt;- t(sapply(pred, function(x) unlist(x)[1:2])) 
colnames(pred) &lt;- c("fit", "se.fit") 

# build the table
tab &lt;- cbind(
    c(Weights(ms3), NA),
    pred,
    matrix(logit.ci(pred[,"fit"], pred[,"se.fit"],
        quantile = c(rep(1.96, 3), 2)), ncol = 2) 
    ) 
colnames(tab) &lt;- c("Akaike weight", "Predicted(40)", "SE", "Lower CI",
    "Upper CI") 
rownames(tab) &lt;- c(as.character(ms3$family), "model-averaged") 
print(tab, digits = 3, na.print = "") 
# Figure 4.3
newdata &lt;- list(dose = seq(min(Beetle$dose), max(Beetle$dose), length.out = 25)) 

# add model-averaged prediction with CI, using the same method as above
avpred &lt;- predict(mavg3, newdata, se.fit = TRUE, type = "response")

avci &lt;- matrix(logit.ci(avpred$fit, avpred$se.fit, quantile = 2), ncol = 2) 


matplot(newdata$dose, sapply(mod3, predict, newdata, type = "response"),
    type = "l", xlab = quote(list("Dose of" ~ CS[2],(mg/L))),
    ylab = "Mortality", col = 2:4, lty = 3, lwd = 1
) 
matplot(newdata$dose, cbind(avpred$fit, avci), type = "l", add = TRUE,
    lwd = 1, lty = c(1, 2, 2), col = 1)  

legend("topleft", NULL, c(as.character(ms3$family), expression(`averaged`
    %+-% CI)), lty = c(3, 3, 3, 1), col = c(2:4, 1))  

</code></pre>

<hr>
<h2 id='BGWeights'>Bates-Granger minimal variance model weights</h2><span id='topic+BGWeights'></span>

<h3>Description</h3>

<p>Computes empirical weights based on out of sample forecast variances,
following Bates and Granger (1969).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGWeights(object, ..., data, force.update = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGWeights_+3A_object">object</code>, <code id="BGWeights_+3A_...">...</code></td>
<td>
<p>two or more fitted <code><a href="stats.html#topic+glm">glm</a></code> objects, or a
<code>list</code> of such, or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object.</p>
</td></tr>
<tr><td><code id="BGWeights_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="BGWeights_+3A_force.update">force.update</code></td>
<td>
<p>if <code>TRUE</code>, the much less efficient method of
updating <code>glm</code> function will be  used rather than directly <em>via</em>
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>. This only applies to <code>glm</code>s, in
case of other model types <code>update</code> is always used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bates-Granger model weights are calculated using prediction covariance. To
get the estimate of prediction covariance, the models are fitted to
randomly selected half of <code>data</code> and prediction is done on the
remaining half.
These predictions are then used to compute the variance-covariance between
models, <code class="reqn">\Sigma</code>. Model weights are then calculated as
<code class="reqn">w_BG = (1' \Sigma{^-1} 1){^-1} 1 \Sigma{^-1}
</code>,
where <code class="reqn">1</code> a vector of 1-s.
</p>
<p>Bates-Granger model weights may be outside of the <code class="reqn">[0,1]</code> range, which
may cause the averaged variances to be negative. Apparently this method
works best when data is large.
</p>


<h3>Value</h3>

<p>A numeric vector of model weights.
</p>


<h3>Note</h3>

<p>For matrix inversion, <code><a href="MASS.html#topic+ginv">MASS::ginv()</a></code> is more stable near singularities
than <code><a href="base.html#topic+solve">solve</a></code>. It will be used as a fallback if <code>solve</code> fails and
<span class="pkg">MASS</span> is available.
</p>


<h3>Author(s)</h3>

<p>Carsten Dormann, Kamil Bartoń
</p>


<h3>References</h3>

<p>Bates, J. M. and Granger, C. W. J. 1969 The combination of forecasts.
<em>Journal of the Operational Research Society</em> <strong>20</strong>, 451-468.
</p>
<p>Dormann, C. et al. (2018) Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485–504.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p>Other model weights: 
<code><a href="#topic+bootWeights">bootWeights</a>()</code>,
<code><a href="#topic+cos2Weights">cos2Weights</a>()</code>,
<code><a href="#topic+jackknifeWeights">jackknifeWeights</a>()</code>,
<code><a href="#topic+stackingWeights">stackingWeights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm(Prop ~ mortality + dose, family = binomial, Beetle, na.action = na.fail)
models &lt;- lapply(dredge(fm, evaluate = FALSE), eval)
ma &lt;- model.avg(models)

# this produces warnings because of negative variances:
set.seed(78)
Weights(ma) &lt;- BGWeights(ma, data = Beetle)
coefTable(ma, full = TRUE)

# SE for prediction is not reliable if some or none of coefficient's SE
# are available
predict(ma, data = test.data, se.fit = TRUE)
coefTable(ma, full = TRUE)

</code></pre>

<hr>
<h2 id='bootWeights'>Bootstrap model weights</h2><span id='topic+bootWeights'></span>

<h3>Description</h3>

<p>Computes model weights using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootWeights(object, ..., R, rank = c("AICc", "AIC", "BIC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootWeights_+3A_object">object</code>, <code id="bootWeights_+3A_...">...</code></td>
<td>
<p>two or more fitted <code><a href="stats.html#topic+glm">glm</a></code> objects, or a
<code>list</code> of such, or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object.</p>
</td></tr>
<tr><td><code id="bootWeights_+3A_r">R</code></td>
<td>
<p>the number of replicates.</p>
</td></tr>
<tr><td><code id="bootWeights_+3A_rank">rank</code></td>
<td>
<p>a character string, specifying the information criterion to use
for model ranking. Defaults to <code><a href="#topic+AICc">AICc</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are fitted repeatedly to a resampled data set and ranked
using AIC-type criterion. The model weights represent the proportion of
replicates when a model has the lowest IC value.
</p>


<h3>Value</h3>

<p>A numeric vector of model weights.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń, Carsten Dormann
</p>


<h3>References</h3>

<p>Dormann, C. et al. 2018 Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485–504.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p>Other model weights: 
<code><a href="#topic+BGWeights">BGWeights</a>()</code>,
<code><a href="#topic+cos2Weights">cos2Weights</a>()</code>,
<code><a href="#topic+jackknifeWeights">jackknifeWeights</a>()</code>,
<code><a href="#topic+stackingWeights">stackingWeights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To speed up the bootstrap, use 'x = TRUE' so that model matrix is included
#     in the returned object
fm &lt;- glm(Prop ~ mortality + dose, family = binomial, data = Beetle, 
   na.action = na.fail, x = TRUE)

fml &lt;- lapply(dredge(fm, eval = FALSE), eval)
am &lt;- model.avg(fml)

Weights(am) &lt;- bootWeights(am, data = Beetle, R = 25)

summary(am)

</code></pre>

<hr>
<h2 id='Cement'>Cement hardening data</h2><span id='topic+Cement'></span>

<h3>Description</h3>

<p>Cement hardening data from Woods et al (1932).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cement
</code></pre>


<h3>Format</h3>

<p><code>Cement</code> is a data frame with 5 variables. <var>x1</var>-<var>x4</var> are four predictor
variables expressed as a percentage of weight.
</p>

<dl>
<dt>y</dt><dd><p>calories of heat evolved per gram of cement after 180 days of
hardening</p>
</dd>  
<dt>X1</dt><dd><p>calcium aluminate</p>
</dd>
<dt>X2</dt><dd><p>tricalcium silicate</p>
</dd>
<dt>X3</dt><dd><p>tetracalcium alumino ferrite</p>
</dd>
<dt>X4</dt><dd><p>dicalcium silicate.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Woods H., Steinour H.H., Starke H.R. (1932) Effect of composition of Portland
cement on heat evolved during hardening. <em>Industrial &amp; Engineering
Chemistry</em> 24, 1207&ndash;1214.
</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>

<hr>
<h2 id='coefplot'>Plot model coefficients</h2><span id='topic+coefplot'></span><span id='topic+plot.averaging'></span>

<h3>Description</h3>

<p>Produce dot-and-whisker plot of the model(-averaged) coefficients,
with confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefplot(
  x, lci, uci,
  labels = NULL, width = 0.15,
  shift = 0, horizontal = TRUE,
  main = NULL, xlab = NULL, ylab = NULL,
  xlim = NULL, ylim = NULL,
  labAsExpr = TRUE, mar.adj = TRUE, lab.line = 0.5, 
  lty = par("lty"), lwd = par("lwd"), pch = 21,
  col = par("col"), bg = par("bg"),
  dotcex = par("cex"), dotcol = col,
  staplelty = lty, staplelwd = lwd, staplecol = col,
  zerolty = "dotted", zerolwd = lwd, zerocol = "gray",
  las = 2, ann = TRUE, axes = TRUE, add = FALSE,
  type = "p",
  ...
)

## S3 method for class 'averaging'
plot(
  x,
  full = TRUE, level = 0.95, intercept = TRUE,
  parm = NULL, labels = NULL, width = 0.1,
  shift = max(0.2, width * 2.1 + 0.05),
  horizontal = TRUE, 
  xlim = NULL, ylim = NULL,
  main = "Model-averaged coefficients",
  xlab = NULL, ylab = NULL, 
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefplot_+3A_x">x</code></td>
<td>
<p>either a (possibly named) vector of coefficients (for <code>coefplot</code>),
or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lci">lci</code>, <code id="coefplot_+3A_uci">uci</code></td>
<td>
<p>vectors of lower and upper confidence intervals. Alternatively
a two-column matrix with columns containing confidence intervals, in
which case <code>uci</code> is ignored.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_labels">labels</code></td>
<td>
<p>optional vector of coefficient names. By default, names of <code>x</code>
are used for labels.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_width">width</code></td>
<td>
<p>width of the staples (= end of whisker).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_shift">shift</code></td>
<td>
<p>the amount of perpendicular shift for the dots and whiskers.
Useful when adding to an existing plot.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_horizontal">horizontal</code></td>
<td>
<p>logical indicating if the plots should be horizontal;
defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code>title</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlab">xlab</code>, <code id="coefplot_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis annotation. Can be suppressed by <code>ann=FALSE</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlim">xlim</code>, <code id="coefplot_+3A_ylim">ylim</code></td>
<td>
<p>optional, the <em>x</em> and <em>y</em> limits of the plot.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_labasexpr">labAsExpr</code></td>
<td>
<p>logical indicating whether the coefficient names should
be transformed to expressions to create prettier labels (see
<code><a href="grDevices.html#topic+plotmath">plotmath</a></code>)</p>
</td></tr>
<tr><td><code id="coefplot_+3A_mar.adj">mar.adj</code></td>
<td>
<p>logical indicating whether the (left or lower) margin should be
expanded to fit the labels</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lab.line">lab.line</code></td>
<td>
<p>margin line for the labels</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lty">lty</code>, <code id="coefplot_+3A_lwd">lwd</code>, <code id="coefplot_+3A_pch">pch</code>, <code id="coefplot_+3A_col">col</code>, <code id="coefplot_+3A_bg">bg</code></td>
<td>
<p>default line type, line width, point character,
foreground colour for all elements, and background colour for open symbols.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_dotcex">dotcex</code>, <code id="coefplot_+3A_dotcol">dotcol</code></td>
<td>
<p>dots point size expansion and colour.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_staplelty">staplelty</code>, <code id="coefplot_+3A_staplelwd">staplelwd</code>, <code id="coefplot_+3A_staplecol">staplecol</code></td>
<td>
<p>staple line type, width, and colour.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_zerolty">zerolty</code>, <code id="coefplot_+3A_zerolwd">zerolwd</code>, <code id="coefplot_+3A_zerocol">zerocol</code></td>
<td>
<p>zero-line type, line width, colour.
Setting <code>zerolty</code>    to <code>NA</code> suppresses the line.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_las">las</code></td>
<td>
<p>the style of labels for coefficient names. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ann">ann</code></td>
<td>
<p><code>logical</code> indicating if axes should be annotated (by <code>xlab</code> and <code>ylab</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_axes">axes</code></td>
<td>
<p>a logical value indicating whether both axes should be drawn on
the plot.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_add">add</code></td>
<td>
<p>logical, if true <em>add</em> to current plot.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_type">type</code></td>
<td>
<p>if <code>"n"</code>, the plot region is left empty, any other value causes
the plot being drawn.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>coefplot</code> or more
<a href="graphics.html#topic+par">graphical parameters</a>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_full">full</code></td>
<td>
<p>a logical value specifying whether the &ldquo;full&rdquo;
model-averaged coefficients are plotted. If <code>FALSE</code>, the
&ldquo;subset&rdquo;-averaged coefficients are plotted, and both types if
<code>NA</code>. See <code><a href="#topic+model.avg">model.avg</a></code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_intercept">intercept</code></td>
<td>
<p>logical indicating if intercept should be included in the
plot</p>
</td></tr>
<tr><td><code id="coefplot_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be plotted, either a
vector of numbers or a vector of names. If missing, all parameters are
considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot model(-averaged) coefficients with confidence intervals.
</p>


<h3>Value</h3>

<p>An invisible <code>matrix</code> containing coordinates of points and whiskers, or,
a two-element list of such, one for each coefficient type in
<code>plot.averaging</code> when <code>full</code> is <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm(Prop ~ dose + I(dose^2) + log(dose) + I(log(dose)^2),
  data = Beetle, family = binomial, na.action = na.fail)
ma &lt;- model.avg(dredge(fm))

# default coefficient plot:
plot(ma, full = NA, intercept = FALSE)

# Add colours per coefficient type
# Replicate each colour n(=number of coefficients) times
clr &lt;- c("black", "red2")
i &lt;- rep(1:2, each = length(coef(ma)) - 1)
plot(ma, full = NA, intercept = FALSE,
   pch = 22, dotcex = 1.5,
   col = clr[i], bg = clr[i],
   lwd = 6, lend = 1, width = 0, horizontal = 0)

# Use `type = "n"` and `add` argument to e.g. add grid beneath the figure
plot(ma, full = NA, intercept = FALSE,
   width = 0, horizontal = FALSE, zerolty = NA, type = "n")
grid()
plot(ma, full = NA, intercept = FALSE,
   pch = 22, dotcex = 1.5,
   col = clr[i], bg = clr[i],
   lwd = 6, lend = 1, width = 0, horizontal = FALSE, add = TRUE)

</code></pre>

<hr>
<h2 id='cos2Weights'>Cos-squared model weights</h2><span id='topic+cos2Weights'></span>

<h3>Description</h3>

<p>Calculates cos-squared model weights, following the algorithm
outlined in the appendix of Garthwaite &amp; Mubwandarikwa (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cos2Weights(object, ..., data, eps = 1e-06, maxit = 100, predict.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cos2Weights_+3A_object">object</code>, <code id="cos2Weights_+3A_...">...</code></td>
<td>
<p>two or more fitted <code><a href="stats.html#topic+glm">glm</a></code> objects, or a
<code>list</code> of such, or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object.
Currently only <code>lm</code> and <code>glm</code> objects are accepted.</p>
</td></tr>
<tr><td><code id="cos2Weights_+3A_data">data</code></td>
<td>
<p>a test data frame in which to look for variables
for use with <a href="stats.html#topic+predict">prediction</a>. If omitted, the fitted linear
predictors are used.</p>
</td></tr>
<tr><td><code id="cos2Weights_+3A_eps">eps</code></td>
<td>
<p>tolerance for determining convergence.</p>
</td></tr>
<tr><td><code id="cos2Weights_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="cos2Weights_+3A_predict.args">predict.args</code></td>
<td>
<p>optionally, a <code>list</code> of additional arguments to be
passed to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of model weights.
</p>


<h3>Author(s)</h3>

<p>Carsten Dormann, adapted by Kamil Bartoń
</p>


<h3>References</h3>

<p>Garthwaite, P. H. and Mubwandarikwa, E. 2010 Selection of weights for
weighted model averaging. <em>Australian &amp; New Zealand Journal of
Statistics</em> <strong>52</strong>, 363–382.
</p>
<p>Dormann, C. et al. 2018 Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485–504.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p>Other model weights: 
<code><a href="#topic+BGWeights">BGWeights</a>()</code>,
<code><a href="#topic+bootWeights">bootWeights</a>()</code>,
<code><a href="#topic+jackknifeWeights">jackknifeWeights</a>()</code>,
<code><a href="#topic+stackingWeights">stackingWeights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm &lt;- lm(y ~ X1 + X2 + X3 + X4, Cement, na.action = na.fail)
# most efficient way to produce a list of all-subsets models
models &lt;- lapply(dredge(fm, evaluate = FALSE), eval)
ma &lt;- model.avg(models)

test.data &lt;- Cement
Weights(ma) &lt;- cos2Weights(models, data = test.data)
predict(ma, data = test.data)

</code></pre>

<hr>
<h2 id='dredge'>Automated model selection</h2><span id='topic+dredge'></span><span id='topic+dc'></span><span id='topic+V'></span><span id='topic+print.model.selection'></span>

<h3>Description</h3>

<p>Generate a model selection table of models with combinations (subsets) of fixed 
effect terms in the global model, with optional model inclusion rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dredge(global.model, beta = c("none", "sd", "partial.sd"), evaluate = TRUE,
  rank = "AICc", fixed = NULL, m.lim = NULL, m.min, m.max, subset,
  trace = FALSE, varying, extra, ct.args = NULL, deps = attr(allTerms0, "deps"),
  cluster = NULL,
  ...)

## S3 method for class 'model.selection'
print(x, abbrev.names = TRUE, warnings = getOption("warn") != -1L, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dredge_+3A_global.model">global.model</code></td>
<td>
<p>a fitted &lsquo;global&rsquo; model object. See
&lsquo;Details&rsquo; for a list of supported types. </p>
</td></tr>
<tr><td><code id="dredge_+3A_beta">beta</code></td>
<td>
<p>indicates whether and how the coefficients are standardized, and 
must be one of <code>"none"</code>, <code>"sd"</code> or <code>"partial.sd"</code>. You can 
specify just the initial letter. <code>"none"</code> corresponds to unstandardized
coefficients, <code>"sd"</code> and <code>"partial.sd"</code> to coefficients 
standardized by <abbr><span class="acronym">SD</span></abbr> and Partial <abbr><span class="acronym">SD</span></abbr>, respectively. For 
backwards compatibility, logical value is also accepted, <code>TRUE</code> is 
equivalent to <code>"sd"</code> and <code>FALSE</code> to <code>"none"</code>. 
See <code><a href="#topic+std.coef">std.coef</a></code>.	</p>
</td></tr>
<tr><td><code id="dredge_+3A_evaluate">evaluate</code></td>
<td>
<p>whether to evaluate and rank the models. If <code>FALSE</code>, a
list of unevaluated <code>call</code>s is returned. </p>
</td></tr>
<tr><td><code id="dredge_+3A_rank">rank</code></td>
<td>
<p>optionally, the rank function returning a sort of an information
criterion, to be used instead <code>AICc</code>, e.g. <code>AIC</code>, <code>QAIC</code> or
<code>BIC</code>.
See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="dredge_+3A_fixed">fixed</code></td>
<td>
<p>optional, either a single-sided formula or a character vector
giving names of terms to be included in all models. See &lsquo;Subsetting&rsquo;. </p>
</td></tr>
<tr><td><code id="dredge_+3A_m.lim">m.lim</code>, <code id="dredge_+3A_m.max">m.max</code>, <code id="dredge_+3A_m.min">m.min</code></td>
<td>
<p>optionally, the limits <code>c(lower, upper)</code>
for the number of terms in a single model (excluding the intercept). An
<code>NA</code> means no limit. See &lsquo;Subsetting&rsquo;.
Specifying limits as <code>m.min</code> and <code>m.max</code> is allowed for backward
compatibility. </p>
</td></tr>
<tr><td><code id="dredge_+3A_subset">subset</code></td>
<td>
<p> logical expression describing models to keep in the resulting
set. See &lsquo;Subsetting&rsquo;. </p>
</td></tr>
<tr><td><code id="dredge_+3A_trace">trace</code></td>
<td>
<p>if <code>TRUE</code> or <code>1</code>, all calls to the fitting function
are printed before actual fitting takes place. If <code>trace &gt; 1</code>, a progress bar
is displayed. </p>
</td></tr>
<tr><td><code id="dredge_+3A_varying">varying</code></td>
<td>
<p> optionally, a named list describing the additional arguments
to vary between the generated models. Item names correspond to the
arguments, and each item provides a list of choices (i.e. <code>list(arg1 =
	list(choice1, choice2, ...), ...)</code>). Complex elements in the choice list
(such as <code>family</code> objects) should be either named (uniquely) or quoted
(unevaluated, e.g. using <code><a href="base.html#topic+alist">alist</a></code>, see <code><a href="base.html#topic+quote">quote</a></code>),
otherwise the result may be visually unpleasant. See example in
<code><a href="#topic+Beetle">Beetle</a></code>. </p>
</td></tr>
<tr><td><code id="dredge_+3A_extra">extra</code></td>
<td>
<p> optional additional statistics to be included in the result,
provided as functions, function names or a list of such (preferably named
or quoted). As with the <code>rank</code> argument, each function must accept as 
an argument a fitted model object and return (a value coercible to) a
numeric vector.
This could be, for instance, additional information criteria or goodness-of-fit
statistics. The character strings <code>"R^2"</code> and <code>"adjR^2"</code> are
treated in a special way and add a likelihood-ratio based R² and
modified-R² to the result, respectively (this is more efficient than using
<code><a href="#topic+r.squaredLR">r.squaredLR</a></code> directly). </p>
</td></tr>
<tr><td><code id="dredge_+3A_x">x</code></td>
<td>
<p> a <code>model.selection</code> object, returned by <code>dredge</code>. </p>
</td></tr>
<tr><td><code id="dredge_+3A_abbrev.names">abbrev.names</code></td>
<td>
<p> should printed term names be abbreviated?
(useful with complex models). </p>
</td></tr>
<tr><td><code id="dredge_+3A_warnings">warnings</code></td>
<td>
<p> if <code>TRUE</code>, errors and warnings issued during the model
fitting are printed below the table (only with <code>pdredge</code>).
To permanently remove the warnings, set the object's attribute
<code>"warnings"</code> to <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="dredge_+3A_ct.args">ct.args</code></td>
<td>
<p> optional list of arguments to be passed to
<code><a href="#topic+coefTable">coefTable</a></code> (e.g. <code>dispersion</code> parameter for <code>glm</code>
affecting standard errors used in subsequent
<code><a href="#topic+model.avg">model averaging</a></code>).</p>
</td></tr>
<tr><td><code id="dredge_+3A_deps">deps</code></td>
<td>
<p>a &ldquo;dependency matrix&rdquo; as returned by <code>getAllTerms</code>, 
attribute <code>"deps"</code>. Can be used to fine-tune marginality 
exceptions. </p>
</td></tr>
<tr><td><code id="dredge_+3A_cluster">cluster</code></td>
<td>
<p> if a valid <code>"cluster"</code> object is provided it is used for
parallel execution of the fitting function. If <code>NULL</code> or omitted 
single threaded execution is performed.
</p>
<p>With parallel calculation, an extra argument <code>check</code> is accepted.
</p>
<p>See <code><a href="#topic+pdredge">pdredge</a></code> for details and examples.
</p>
</td></tr>
<tr><td><code id="dredge_+3A_...">...</code></td>
<td>
<p> optional arguments for the <code>rank</code> function. Any can be
an unevaluated expression, in which case any <code>x</code> within it will be 
substituted with the current model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models are fitted through repeated evaluation of the modified call extracted from
the <code>global.model</code> (in a similar fashion to <code>update</code>). This
approach, while having the advantage that it can be applied to most model types through the
usual formula interface, can have a considerable computational overhead.
</p>
<p>Note that the number of combinations grows exponentially with the number of
predictors (<code class="reqn">2^{N}</code>, less when
interactions are present, see below).
</p>
<p>The fitted model objects are not stored in the result. To get (a subset of)
the models, use <code><a href="#topic+get.models">get.models</a></code> on the object returned by <code>dredge</code>.
Another way to get all the models is to run 
<code>lapply(dredge(..., evaluate = FALSE), eval)</code>, 
which avoids fitting models twice.
</p>
<p>For a list of model types that can be used as a <code>global.model</code> see
<a href="#topic+MuMIn-models">the list of supported models</a>. Modelling functions that 
do not store a <code>call</code> in their result should be evaluated <em>via</em> a wrapper function
created by <code><a href="#topic+updateable">updateable</a></code>.
</p>


<h4>Information criterion</h4>

<p><code>rank</code> is found by a call to <code>match.fun</code> and may be specified as a
function, a symbol, or as a character string specifying a function to be searched 
for from the environment of the call to <code>dredge</code>. It can be also a 
one-element named list, where the first element is taken as the rank function.
The function <code>rank</code> must accept a model object as its first argument and
always return a scalar.
</p>



<h4>Interactions</h4>

<p>By default, marginality constraints are respected, so &ldquo;all possible
combinations&rdquo; include only those containing interactions with their
respective main effects and all lower-order terms.
However, if <code>global.model</code> makes an exception to this principle (e.g. due
to a nested design such as <code>a / (b + d)</code>), this will be reflected in the
subset models.
</p>



<h4>Subsetting</h4>

<p>There are three ways to constrain the resulting set of models: setting limits to
the number of terms in a model with <code>m.lim</code>, binding 
term(s) to all models using <code>fixed</code>, and the <code>subset</code> argument can be 
used for more complex rules. For a model to be included in the selection table, its 
formulation must satisfy all these conditions.
</p>
<p><code>subset</code> may be an <em>expression</em> or a <em>matrix</em>.
The latter should be a lower triangular matrix with logical values, where the 
columns and rows correspond to <code>global.model</code> terms. Value
<code>subset["a", "b"] == FALSE</code> will exclude any model containing both 
<var>a</var> and <var>b</var> terms. <br />
<code>demo(dredge.subset)</code> has examples of using the <code>subset</code> matrix in 
conjunction with correlation matrices to exclude models containing collinear 
predictors.
</p>
<p>In the form of <code>expression</code>, the argument <code>subset</code> acts in a similar
fashion to that in the function <code>subset</code> for <code>data.frames</code>: model
terms can be referred to by name as variables in the expression, with the
difference being that are interpreted as logical values (i.e. equal to
<code>TRUE</code> if the term exists in the model).
</p>
<p>The expression can contain any of the <code>global.model</code> term names, as well as
names of the <code>varying</code> list items. <code>global.model</code> term names take
precedence when identical to names of <code>varying</code>, so to avoid ambiguity
<code>varying</code> variables in <code>subset</code> expression should be enclosed in
<code>V()</code> (e.g. <code>V(family) == "Gamma"</code>) assuming that
<code>varying</code> is something like <code>list(family =</code> <code>c("Gamma", ...))</code>).
</p>
<p>If item names in <code>varying</code> are missing, the items themselves are coerced to
names. Call and symbol elements are represented as character values (<em>via</em>
<code>deparse</code>), and anything other than numeric, logical, character and
<code>NULL</code> values is replaced by item numbers (e.g. <code>varying =</code>
<code>list(family =</code> <code>list(gaussian, Gamma)</code> should be referred to as
<code>subset = V(family) == 2</code>. This can quickly become confusing, so it
is recommended to use named lists. Examples can be found in <code>demo(dredge.varying)</code>.
</p>
<p>Term names appearing in <code>fixed</code> and <code>subset</code> must be given exactly 
as they are returned by <code>getAllTerms(global.model)</code>, which may differ
from the original term names (e.g. the interaction term components are ordered
alphabetically).
</p>
<p>The <code>with(x)</code> and <code>with(+x)</code> notation indicates, respectively, any and
all interactions including the main effect term <code>x</code>. This is only effective
with marginality exceptions. The extended form <code>with(x, order)</code> allows to
specify the order of interaction of terms of which <code>x</code> is a part. For
instance, <code>with(b, 2:3)</code> selects models with at least one second- or
third-order interaction of variable <code>b</code>. The second (positional)
argument is coerced to an integer vector. The &ldquo;dot&rdquo; notation <code>.(x)</code> is
an alias for <code>with</code>.
</p>
<p>The special variable <code>`*nvar*`</code> 
(backtick-quoted), in the <code>subset</code> expression is equal to the number of 
terms in the model (<b>not</b> the number of estimated parameters).
</p>
<p>To make the inclusion of a model term conditional on the presence of another one,
the function <code>dc</code> (&ldquo;<b>d</b>ependency <b>c</b>hain&rdquo;) can be used in
the <code>subset</code> expression. <code>dc</code> takes any number of term names as
arguments, and allows a term to be included only if all preceding ones
are also present (e.g. <code>subset = dc(a, b, c)</code> allows for models <code>a</code>,
<code>a+b</code> and <code>a+b+c</code> but not <code>b</code>, <code>c</code>, <code>b+c</code> or
<code>a+c</code>).
</p>
<p><code>subset</code> expression can have a form of an unevaluated <code>call</code>,
<code>expression</code> object, or a one-sided <code>formula</code>. See &lsquo;Examples&rsquo;.
</p>
<p>Compound model terms (such as interactions, &lsquo;as-is&rsquo; expressions within
<code>I()</code> or smooths in <code>gam</code>) should be enclosed within curly brackets
(e.g. <code>{s(x,k=2)}</code>), or <a href="base.html#topic+Quotes">backticks</a> (like non-syntactic
names, e.g. 
<code>`s(x, k = 2)`</code>
), except when they are arguments to <code>with</code> or <code>dc</code>.
Backticks-quoted names must match exactly (including whitespace) the term names
as returned by <code>getAllTerms</code>.
</p>


<h5><code>subset</code> expression syntax summary</h5>


<dl>
<dt><code>a &amp; b</code></dt><dd><p> indicates that model terms <var>a</var> and <var>b</var> must be
present (see <a href="base.html#topic+Logic">Logical Operators</a>) </p>
</dd>
<dt><code>{log(x,2)}</code> or <code style="white-space: pre;">&#8288;`&#8288;</code><code>log(x, 2)</code><code style="white-space: pre;">&#8288;`&#8288;</code></dt><dd><p> represent a complex
model term <code>log(x, 2)</code></p>
</dd>
<dt><code>V(x)</code></dt><dd><p> represents a <code>varying</code> item <var>x</var> </p>
</dd>
<dt><code>with(x)</code></dt><dd><p> indicates that at least one term containing the main 
effect term <var>x</var> must be present </p>
</dd>
<dt><code>with(+x)</code></dt><dd><p> indicates that all the terms containing the main 
effect term <var>x</var> must be present </p>
</dd>
<dt><code>with(x, n:m)</code></dt><dd><p> indicates that at least one term containing an 
<var>n</var>-th to <var>m</var>-th order interaction term of <var>x</var> must be present </p>
</dd>
<dt><code>dc(a, b, c,...)</code></dt><dd> <p>&lsquo;dependency chain&rsquo;: <var>b</var> is allowed only
if <var>a</var> is present, and <var>c</var> only if both <var>a</var> and <var>b</var> are
present, etc. </p>
</dd>
<dt><code>`*nvar*`</code></dt><dd><p> the number of terms in the model. </p>
</dd>
</dl>


<p>To simply keep certain terms in all models, use of argument <code>fixed</code> is much
more efficient. The <code>fixed</code> formula is interpreted in the same manner
as model formula and so the terms must not be quoted.
</p>



<h4>Missing values</h4>

<p>Use of <code>na.action = "na.omit"</code> (<span class="rlang"><b>R</b></span>'s default) or <code>"na.exclude"</code>  in
<code>global.model</code> must be avoided, as it results with sub-models fitted to
different data sets if there are missing values. An error is thrown if it is
detected.
</p>
<p>It is a common mistake to give <code>na.action</code> as an argument in the call
to <code>dredge</code> (typically resulting in an error from the <code>rank</code>
function to which the argument is passed through &lsquo;...&rsquo;), while the 
correct way
is either to pass <code>na.action</code> in the call to the global model or to set
it as a <a href="base.html#topic+options">global option</a>.
</p>



<h4>Intercept</h4>

 
<p>If present in the <code>global.model</code>, the intercept will be included in all 
sub-models.
</p>



<h4>Methods</h4>

<p>There are <code><a href="#topic+subset.model.selection">subset</a></code> and
<code><a href="#topic+plot.model.selection">plot</a></code> methods, the latter creates a
graphical representation of model weights and per-model term sum of weights.
Coefficients can be extracted with <code>coef</code> or <code><a href="#topic+coefTable">coefTable</a></code>.
</p>



<h3>Value</h3>

<p>An object of class <code>c("model.selection", "data.frame")</code>, being a
<code>data.frame</code>, where each row represents one model.
See <code><a href="#topic+model.selection.object">model.selection.object</a></code> for its structure.
</p>


<h3>Note</h3>

<p>Users should keep in mind the hazards that a &ldquo;thoughtless approach&rdquo;
of evaluating all possible models poses. Although this procedure is in certain
cases useful and justified, it may result in selecting a spurious &ldquo;best&rdquo;
model, due to the model selection bias.
</p>
<p><em>&ldquo;Let the computer find out&rdquo; is a poor strategy and usually reflects
the fact that the researcher did not bother to think clearly about the problem
of interest and its scientific setting</em> (Burnham and Anderson, 2002).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdredge">pdredge</a></code> is a parallelized version of this function (uses a
cluster).
</p>
<p><code><a href="#topic+get.models">get.models</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>. <code><a href="#topic+model.sel">model.sel</a></code> for
manual model selection tables.
</p>
<p>Possible alternatives: <code><a href="glmulti.html#topic+glmulti">glmulti</a></code> in package <span class="pkg">glmulti</span>
and <code><a href="bestglm.html#topic+bestglm">bestglm</a></code> (<span class="pkg">bestglm</span>).
<code><a href="leaps.html#topic+regsubsets">regsubsets</a></code> in package <span class="pkg">leaps</span> also performs all-subsets
regression.
</p>
<p>Variable selection through regularization provided by various packages, e.g. <span class="pkg">glmnet</span>,
<span class="pkg">lars</span> or <span class="pkg">glmmLasso</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Burnham and Anderson (2002), page 100:

#  prevent fitting sub-models to different datasets

options(na.action = "na.fail")

fm1 &lt;- lm(y ~ ., data = Cement)
dd &lt;- dredge(fm1)
subset(dd, delta &lt; 4)

# Visualize the model selection table:

par(mar = c(3,5,6,4))
plot(dd, labAsExpr = TRUE)


# Model average models with delta AICc &lt; 4
model.avg(dd, subset = delta &lt; 4)

#or as a 95% confidence set:
model.avg(dd, subset = cumsum(weight) &lt;= .95) # get averaged coefficients

#'Best' model
summary(get.models(dd, 1)[[1]])

## Not run: 
# Examples of using 'subset':
# keep only models containing X3
dredge(fm1, subset = ~ X3) # subset as a formula
dredge(fm1, subset = expression(X3)) # subset as expression object
# the same, but more effective:
dredge(fm1, fixed = "X3")
# exclude models containing both X1 and X2 at the same time
dredge(fm1, subset = !(X1 &amp;&amp; X2))
# Fit only models containing either X3 or X4 (but not both);
# include X3 only if X2 is present, and X2 only if X1 is present.
dredge(fm1, subset = dc(X1, X2, X3) &amp;&amp; xor(X3, X4))
# the same as above, without "dc"
dredge(fm1, subset = (X1 | !X2) &amp;&amp; (X2 | !X3) &amp;&amp; xor(X3, X4))

# Include only models with up to 2 terms (and intercept)
dredge(fm1, m.lim = c(0, 2))

## End(Not run)

# Add R^2 and F-statistics, use the 'extra' argument
dredge(fm1, m.lim = c(NA, 1), extra = c("R^2", F = function(x)
    summary(x)$fstatistic[[1]]))

# with summary statistics:
dredge(fm1, m.lim = c(NA, 1), extra = list(
    "R^2", "*" = function(x) {
        s &lt;- summary(x)
        c(Rsq = s$r.squared, adjRsq = s$adj.r.squared,
            F = s$fstatistic[[1]])
    })
)

# Add other information criteria (but rank with AICc):
dredge(fm1, m.lim = c(NA, 1), extra = alist(AIC, BIC, ICOMP, Cp))

</code></pre>

<hr>
<h2 id='exprApply'>Apply a function to calls inside an expression</h2><span id='topic+exprApply'></span>

<h3>Description</h3>

<p>Apply function <code>FUN</code> to each occurence of a call to <code>what()</code> (or 
a symbol <code>what</code>) in an unevaluated expression. It can be used for advanced 
manipulation of expressions.
Intended primarily for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exprApply(expr, what, FUN, ..., symbols = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exprApply_+3A_expr">expr</code></td>
<td>
<p>an unevaluated expression. </p>
</td></tr>
<tr><td><code id="exprApply_+3A_what">what</code></td>
<td>
<p>character string giving the name of a function. Each call to
<code>what</code> inside <code>expr</code> will be passed to <code>FUN</code>. <code>what</code> 
can be also a character representation of an operator or parenthesis
(including <a href="base.html#topic+Paren">curly</a> and <a href="base.html#topic+Extract">square</a> brackets) as 
these are primitive functions in <span class="rlang"><b>R</b></span>.
Set <code>what</code> to <code>NA</code> to match all names.
</p>
</td></tr>
<tr><td><code id="exprApply_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied. </p>
</td></tr>
<tr><td><code id="exprApply_+3A_symbols">symbols</code></td>
<td>
<p>logical value controlling whether <code>FUN</code> should be applied
to symbols as well as calls.</p>
</td></tr>
<tr><td><code id="exprApply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> is found by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code> and can be either
a function or a symbol (e.g., a backquoted name) or a character string
specifying a function to be searched for from the environment of the call to
<code>exprApply</code>. 
</p>


<h3>Value</h3>

<p>A (modified) expression.
</p>


<h3>Note</h3>

<p>If <code>expr</code> has a <a href="base.html#topic+srcfile">source reference</a> information
(<code>"srcref"</code> attribute), modifications done by <code>exprApply</code> will not be
visible when printed unless <code>srcref</code> is removed. However, <code>exprApply</code>
does remove source reference from any <code>function</code> expression inside
<code>expr</code>.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p>Expression-related functions: <code><a href="base.html#topic+substitute">substitute</a></code>, 
<code><a href="base.html#topic+expression">expression</a></code>, <code><a href="base.html#topic+quote">quote</a></code> and <code><a href="base.html#topic+bquote">bquote</a></code>.
</p>
<p>Similar function <code><a href="codetools.html#topic+codetools">walkCode</a></code> exists in package 
<span class="pkg">codetools</span>. 
</p>
<p>Functions useful inside <code>FUN</code>: <code><a href="base.html#topic+as.name">as.name</a></code>, <code><a href="base.html#topic+as.call">as.call</a></code>,
<code><a href="base.html#topic+call">call</a></code>, <code><a href="base.html#topic+match.call">match.call</a></code> etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple usage:
# print all Y(...) terms in a formula (note that symbol "Y" is omitted):
exprApply(~ X(1) + Y(2 + Y(4)) + N(Y + Y(3)), "Y", print)

# replace X() with log(X, base = n)
exprApply(expression(A() + B() + C()), c("A", "B", "C"), function(expr, base) {
    expr[[2]] &lt;- expr[[1]]
    expr[[1]] &lt;- as.name("log")
    expr$base &lt;- base
    expr
}, base = 10)

###
# TASK: fit lm with two poly terms, varying the degree from 1 to 3 in each.
# lm(y ~ poly(X1, degree = a) + poly(X2, degree = b), data = Cement)
# for a = {1,2,3} and b = {1,2,3}

# First we create a wrapper function for lm. Within it, use "exprApply" to add
# "degree" argument to all occurences of "poly()" having "X1" or "X2" as the
# first argument. Values for "degree" are taken from arguments "d1" and "d2"

lmpolywrap &lt;- function(formula, d1 = NA, d2 = NA, ...) { 
    cl &lt;- origCall &lt;- match.call()
    cl[[1]] &lt;- as.name("lm")
    cl$formula &lt;- exprApply(formula, "poly", function(e, degree, x) {
        i &lt;- which(e[[2]] == x)[1]
        if(!is.na(i) &amp;&amp; !is.na(degree[i])) e$degree &lt;- degree[i]
        e
    }, degree = c(d1, d2), x = c("X1", "X2"))
    cl$d1 &lt;- cl$d2 &lt;- NULL
    fit &lt;- eval(cl, parent.frame())
    fit$call &lt;- origCall # replace the stored call
    fit
}

# global model:
fm &lt;- lmpolywrap(y ~ poly(X1) + poly(X2), data = Cement)

# Use "dredge" with argument "varying" to generate calls of all combinations of
# degrees for poly(X1) and poly(X2). Use "fixed = TRUE" to keep all global model
# terms in all models.
# Since "dredge" expects that global model has all the coefficients the 
# submodels can have, which is not the case here, we first generate model calls,
# evaluate them and feed to "model.sel"

modCalls &lt;- dredge(fm, 
    varying = list(d1 = 1:3, d2 = 1:3), 
    fixed = TRUE,
    evaluate = FALSE
)

model.sel(models &lt;- lapply(modCalls, eval))

# Note: to fit *all* submodels replace "fixed = TRUE" with: 
# "subset = (d1==1 || {poly(X1)}) &amp;&amp; (d2==1 || {poly(X2)})"
# This is to avoid fitting 3 identical models when the matching "poly()" term is
# absent.
</code></pre>

<hr>
<h2 id='Formula+20manipulation'>Manipulate model formulas</h2><span id='topic+simplify.formula'></span><span id='topic+expand.formula'></span>

<h3>Description</h3>

<p><code>simplify.formula</code> rewrites a <code>formula</code> into shorthand notation.
Currently only the factor crossing operator <code>*</code> is applied, so an
expanded expression such as <code>a+b+a:b</code> becomes <code>a*b</code>.
<code>expand.formula</code> does the opposite, additionally expanding other
expressions, i.e. all nesting (<code>/</code>), grouping and <code>^</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify.formula(x)
expand.formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Formula+2B20manipulation_+3A_x">x</code></td>
<td>
<p>a <code>formula</code> or an object from which it can be extracted (such as
a fitted model object). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>
</p>
<p><code><a href="stats.html#topic+delete.response">delete.response</a></code>, <code><a href="stats.html#topic+drop.terms">drop.terms</a></code>, and 
<code><a href="stats.html#topic+reformulate">reformulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simplify.formula(y ~ a + b + a:b + (c + b)^2)
simplify.formula(y ~ a + b + a:b + 0)

expand.formula(~ a * b)

</code></pre>

<hr>
<h2 id='get.models'>Retrieve models from selection table</h2><span id='topic+get.models'></span><span id='topic+pget.models'></span>

<h3>Description</h3>

<p>Generate or extract a list of fitted model objects from a 
<code>"model.selection"</code> table, optionally using parallel computation in a 
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.models(object, subset, cluster = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.models_+3A_object">object</code></td>
<td>
<p> object returned by <code><a href="#topic+dredge">dredge</a></code>. </p>
</td></tr>
<tr><td><code id="get.models_+3A_subset">subset</code></td>
<td>
<p>subset of models, an expression evaluated within the model
selection table (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="get.models_+3A_cluster">cluster</code></td>
<td>
<p> optionally, a <code>"cluster"</code> object. If it is a valid 
cluster, models are evaluated using parallel computation. </p>
</td></tr>
<tr><td><code id="get.models_+3A_...">...</code></td>
<td>
<p>additional arguments to update the models. For example, in
<code>lme</code> one may want to use <code>method = "REML"</code> while using <code>"ML"</code>
for model selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>subset</code> must be explicitely provided. This is to assure that 
a potentially long list of models is not fitted unintentionally. To evaluate all
models, set <code>subset</code> to <code>NA</code> or <code>TRUE</code>. 
</p>
<p>If <code>subset</code> is a character vector, it is interpreted as names of rows to be
selected.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+list">list</a></code> of fitted model objects.
</p>


<h3>Note</h3>

<p>Alternatively, <code>getCall</code> and <code>eval</code> can be used to compute a model out of the 
<code>"model.selection"</code> table (e.g. <code>eval(getCall(&lt;model.selection&gt;, i))</code>, where 
<code>i</code> is the model index or name). 
</p>
<p>Using <code>get.models</code> following <code>dredge</code> is not efficient as the requested models 
have to be fitted again. If the number of generated models is reasonable, consider using <br />
<code>lapply(dredge(..., evaluate = FALSE), eval)</code>, which generates a list of all model 
calls and evaluates them into a list of model objects. This avoids fitting the 
models twice.
</p>
<p><code>pget.models</code> is still available, but is deprecated.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code> and <code><a href="#topic+pdredge">pdredge</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p><code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> in packages <span class="pkg">parallel</span> and <span class="pkg">snow</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mixed models:


fm2 &lt;- lme(distance ~ age + Sex, data = Orthodont,
    random = ~ 1 | Subject, method = "ML")
ms2 &lt;- dredge(fm2)

# Get top-most models, but fitted by REML:
(confset.d4 &lt;- get.models(ms2, subset = delta &lt; 4, method = "REML"))

## Not run: 
# Get the top model:
get.models(ms2, subset = 1)[[1]]

## End(Not run)


</code></pre>

<hr>
<h2 id='GPA'>Grade Point Average data</h2><span id='topic+GPA'></span>

<h3>Description</h3>

<p>First-year college Grade Point Average (<abbr><span class="acronym">GPA</span></abbr>) from Graybill and Iyer (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPA
</code></pre>


<h3>Format</h3>

<p><code>GPA</code> is a data frame with 5 variables. <var>y</var> is the first-year college
Grade Point Average (<abbr><span class="acronym">GPA</span></abbr>) and <var>x1</var>-<var>x4</var> are four predictor variables
from standardized tests (<abbr><span class="acronym">SAT</span></abbr>) administered before matriculation.
</p>

<dl>
<dt>y</dt><dd><p><abbr><span class="acronym">GPA</span></abbr></p>
</dd>
<dt>x1</dt><dd><p>math score on the <abbr><span class="acronym">SAT</span></abbr></p>
</dd>
<dt>x2</dt><dd><p>verbal score on the <abbr><span class="acronym">SAT</span></abbr></p>
</dd>
<dt>x3</dt><dd><p>high school math</p>
</dd>
<dt>x4</dt><dd><p>high school English</p>
</dd>
</dl>


<h3>Source</h3>

<p>Graybill, F.A. and Iyer, H.K. (1994). <em>Regression analysis: concepts and
applications</em>. Duxbury Press, Belmont, CA.
</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>

<hr>
<h2 id='Information+20criteria'>Various information criteria</h2><span id='topic+IC'></span><span id='topic+Mallows+27+20Cp'></span><span id='topic+Cp'></span><span id='topic+ICOMP'></span><span id='topic+CAICF'></span><span id='topic+DIC'></span>

<h3>Description</h3>

<p>Calculate Mallows' <em>Cp</em> and Bozdogan's ICOMP and CAIFC information criteria.
</p>
<p>Extract or calculate Deviance Information Criterion from <code>MCMCglmm</code> and 
<code>merMod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cp(object, ..., dispersion = NULL)
ICOMP(object, ..., REML = NULL)
CAICF(object, ..., REML = NULL)
DIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Information+2B20criteria_+3A_object">object</code></td>
<td>
<p>a fitted model object (in case of ICOMP and CAICF, <code>logLik</code>
and <code>vcov</code> methods must exist for the object). For <code>DIC</code>, an 
object of class <code>"MCMCglmm"</code> or <code>"merMod"</code>.
</p>
</td></tr>
<tr><td><code id="Information+2B20criteria_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects. </p>
</td></tr>
<tr><td><code id="Information+2B20criteria_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion parameter. If <code>NULL</code>, it is inferred
from object. </p>
</td></tr>
<tr><td><code id="Information+2B20criteria_+3A_reml">REML</code></td>
<td>
<p> optional logical value, passed to the <code>logLik</code> method
indicating whether the restricted log-likelihood or log-likelihood should be
used. The default is to use the method used for model estimation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mallows' <em>Cp</em> statistic is the residual deviance plus twice the estimate of
<code class="reqn">\sigma^{2}</code> times the residual degrees of freedom. It is closely
related to AIC (and a multiple of it if the dispersion is known).
</p>
<p>ICOMP (I for informational and COMP for complexity) penalizes the covariance
complexity of the model, rather than the number of parameters directly.
</p>
<p>CAICF (C is for &lsquo;consistent&rsquo; and F denotes the use of the Fisher
information matrix) includes with penalty the natural logarithm of the
determinant of the estimated Fisher information matrix.
</p>


<h3>Value</h3>

<p>If just one object is provided, the functions return a numeric value with
the corresponding IC; otherwise a <code>data.frame</code> with rows corresponding
to the objects is returned.
</p>


<h3>References</h3>

<p>Mallows, C. L. 1973 Some comments on <em>Cp</em>. <em>Technometrics</em> <b>15</b>,
661–675.
</p>
<p>Bozdogan, H. and Haughton, D. M. A. (1998) Information complexity criteria for
regression models. <em>Comp. Stat. &amp; Data Analysis</em> <b>28</b>, 51&ndash;76.
</p>
<p>Anderson, D. R. and Burnham, K. P. 1999 Understanding information criteria for selection among 
capture-recapture or ring recovery models. <em>Bird Study</em> <b>46</b>, 14&ndash;21.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. R., van der Linde, A. 2002 Bayesian measures of model 
complexity and fit. <em>Journal of the Royal Statistical Society Series B-Statistical Methodology</em>
<b>64</b>, 583&ndash;616.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code> in <span class="pkg">stats</span>, <code><a href="#topic+AICc">AICc</a></code>.
<code><a href="#topic+QIC">QIC</a></code> for GEE model selection.
<code><a href="arm.html#topic+extractDIC">extractDIC</a></code> in package <span class="pkg">arm</span>, on which the (non-visible) 
method <code>extractDIC.merMod</code> used by <code>DIC</code> is based.
</p>

<hr>
<h2 id='jackknifeWeights'>Jackknifed model weights</h2><span id='topic+jackknifeWeights'></span>

<h3>Description</h3>

<p>Computes model weights optimized for jackknifed model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknifeWeights(
  object, ..., data, type = c("loglik", "rmse"),
  family = NULL, weights = NULL,
  optim.method = "BFGS", maxit = 1000, optim.args = list(),
  start = NULL, force.update = FALSE, py.matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackknifeWeights_+3A_object">object</code>, <code id="jackknifeWeights_+3A_...">...</code></td>
<td>
<p>two or more fitted <code><a href="stats.html#topic+glm">glm</a></code> objects, or a
<code>list</code> of such, or an <a href="#topic+model.avg">&quot;averaging&quot;</a> object.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model. It is
optional if all models are <code>glm</code>.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_type">type</code></td>
<td>
<p>a character string specifying the function to minimize. Either
<code>"rmse"</code> or <code>"loglik"</code>.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_family">family</code></td>
<td>
<p>used only if <code>type = "loglik"</code>, a <code><a href="stats.html#topic+family">family</a></code> object to be
used for likelihood calculation. Not needed if all models share the same
<code>family</code> and link function.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;<a href="stats.html#topic+weights.glm">prior weights</a>&rsquo;
to be used in the model fitting process. Should be <code>NULL</code> or
a numeric vector.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_optim.method">optim.method</code></td>
<td>
<p>optional, optimisation method, passed to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_maxit">maxit</code></td>
<td>
<p>optional, the maximum number of iterations, passed to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_optim.args">optim.args</code></td>
<td>
<p>optional list of other arguments passed to
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_start">start</code></td>
<td>
<p>starting values for model weights. Numeric of length equal the
number of models.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_force.update">force.update</code></td>
<td>
<p>for <code>glm</code>, the <code>glm.fit</code> function is used for
fitting models to the train data, which is much more efficient. Set to
<code>TRUE</code> to use <code>update</code> instead.</p>
</td></tr>
<tr><td><code id="jackknifeWeights_+3A_py.matrix">py.matrix</code></td>
<td>
<p>either a boolean value, then if <code>TRUE</code> a jackknifed prediction
matrix is returned and if <code>FALSE</code> a vector of jackknifed model weights, or
a <var>N</var>×<var>M</var> matrix (<em>number of cases</em> × <em>number of models</em>)
that is interpreted as a jackknifed prediction matrix and it is used for
optimisation (i.e. the jackknife procedure is skipped).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model weights are chosen (using <code><a href="stats.html#topic+optim">optim</a></code>) to minimise
<abbr><span class="acronym">RMSE</span></abbr> or log-likelihood of
the prediction for data point <var>i</var>, of a model fitted omitting that
data point <var>i</var>. The jackknife procedure is therefore run for all
provided models and for all data points.
</p>


<h3>Value</h3>

<p>The function returns a numeric vector of model weights.
</p>


<h3>Note</h3>

<p>This procedure can give variable results depending on the
<a href="stats.html#topic+optim">optimisation method</a> and starting values. It is therefore
advisable to make several replicates using different <code>optim.method</code>s.
See <code><a href="stats.html#topic+optim">optim</a></code> for possible values for this argument.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń. Carsten Dormann
</p>


<h3>References</h3>

<p>Hansen, B. E. and Racine, J. S. 2012 Jackknife model averaging.
<em>Journal of Econometrics</em> <strong>979</strong>, 38–46
</p>
<p>Dormann, C. et al. 2018 Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485–504.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p>Other model weights: 
<code><a href="#topic+BGWeights">BGWeights</a>()</code>,
<code><a href="#topic+bootWeights">bootWeights</a>()</code>,
<code><a href="#topic+cos2Weights">cos2Weights</a>()</code>,
<code><a href="#topic+stackingWeights">stackingWeights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm(Prop ~ mortality * dose, binomial(), Beetle, na.action = na.fail)

fits &lt;- lapply(dredge(fm, eval = FALSE), eval)

amJk &lt;- amAICc &lt;- model.avg(fits)
set.seed(666)
Weights(amJk) &lt;- jackknifeWeights(fits, data = Beetle)

coef(amJk)
coef(amAICc)

</code></pre>

<hr>
<h2 id='loo'>Leave-one-out cross-validation</h2><span id='topic+loo'></span><span id='topic+loo.default'></span><span id='topic+loo.lm'></span>

<h3>Description</h3>

<p>Computes the <abbr><span class="acronym">RMSE</span></abbr>/log-likelihood based on leave-one-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo(object, type = c("loglik", "rmse"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_+3A_object">object</code></td>
<td>
<p>a fitted object model, currently only <code>lm</code>/<code>glm</code> is
accepted.</p>
</td></tr>
<tr><td><code id="loo_+3A_type">type</code></td>
<td>
<p>the criterion to use, given as a character string,
either <code>"rmse"</code> for Root-Mean-Square Error or <code>"loglik"</code>
for log-likelihood.</p>
</td></tr>
<tr><td><code id="loo_+3A_...">...</code></td>
<td>
<p>other arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leave-one-out cross validation is a <var>K</var>-fold cross validation, with
<var>K</var> equal to the number of data points in the set <var>N</var>. For all
<var>i</var> from 1 to <var>N</var>, the model is fitted to all the data except for
<var>i</var>-th row and a prediction is made for that value. The average error is
computed and used to evaluate the model.
</p>


<h3>Value</h3>

<p>A single numeric value of <abbr><span class="acronym">RMSE</span></abbr> or
mean log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń, based on code by Carsten Dormann
</p>


<h3>References</h3>

<p>Dormann, C. et al. 2018 Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485–504.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- lm(y ~ X1 + X2 + X3 + X4, Cement)
loo(fm, type = "l")
loo(fm, type = "r")

## Compare LOO_RMSE and AIC/c
options(na.action = na.fail)
dd &lt;- dredge(fm, rank = loo, extra = list(AIC, AICc), type = "rmse")
plot(loo ~ AIC, dd, ylab = expression(LOO[RMSE]), xlab = "AIC/c")
points(loo ~ AICc, data = dd, pch = 19)
legend("topleft", legend = c("AIC", "AICc"), pch = c(1, 19))

</code></pre>

<hr>
<h2 id='merge.model.selection'>Combine model selection tables</h2><span id='topic+merge.model.selection'></span><span id='topic+rbind.model.selection'></span><span id='topic+append.model.selection'></span>

<h3>Description</h3>

<p>Combine two or more model selection tables. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.selection'
merge(x, y, suffixes = c(".x", ".y"), ...)

## S3 method for class 'model.selection'
rbind(..., deparse.level = 1, make.row.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.model.selection_+3A_x">x</code>, <code id="merge.model.selection_+3A_y">y</code>, <code id="merge.model.selection_+3A_...">...</code></td>
<td>
<p><code>model.selection</code> objects to be combined.
(... ignored in  <code>merge</code>)</p>
</td></tr>
<tr><td><code id="merge.model.selection_+3A_suffixes">suffixes</code></td>
<td>
<p>a character vector with two elements that are appended
respectively to row names of the combined tables.</p>
</td></tr>
<tr><td><code id="merge.model.selection_+3A_make.row.names">make.row.names</code></td>
<td>
<p>logical indicating if unique and valid <code>row.names</code> should
be constructed from the arguments. </p>
</td></tr>
<tr><td><code id="merge.model.selection_+3A_deparse.level">deparse.level</code></td>
<td>
<p>ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+model.selection.object">&quot;model.selection&quot; object</a></code> containing 
models (rows) from all provided tables.
</p>


<h3>Note</h3>

<p>Both Δ_IC values and 
<em>Akaike weights</em> are recalculated in the resulting tables.
</p>
<p>Models in the combined model selection tables must be comparable, i.e. fitted to
the same data, however only very basic checking is done to verify that. The 
models must also be ranked by the same information criterion.
</p>
<p>Unlike the <code>merge</code> method for <code>data.frame</code>, this method appends
second table to the first (similarly to <code>rbind</code>).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+model.sel">model.sel</a></code>, <code><a href="base.html#topic+merge">merge</a></code>, 
<code><a href="base.html#topic+rbind">rbind</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(mgcv)

ms1 &lt;- dredge(glm(Prop ~ dose + I(dose^2) + log(dose) + I(log(dose)^2),
    data = Beetle, family = binomial, na.action = na.fail))
	
fm2 &lt;- gam(Prop ~ s(dose, k = 3), data = Beetle, family = binomial)

merge(ms1, model.sel(fm2))

## End(Not run)
</code></pre>

<hr>
<h2 id='Model+20utilities'>Model utility functions</h2><span id='topic+MuMIn-model-utils'></span><span id='topic+coeffs'></span><span id='topic+model.names'></span><span id='topic+tTable'></span><span id='topic+coefTable'></span><span id='topic+coefTable.default'></span><span id='topic+coefTable.lme'></span><span id='topic+coefTable.gee'></span><span id='topic+coefTable.averaging'></span><span id='topic+getAllTerms'></span><span id='topic+getAllTerms.terms'></span><span id='topic+get.response'></span>

<h3>Description</h3>

<p>These functions extract or calculate various values from provided fitted model
objects(s). They are mainly meant for internal use.
</p>
<p><code>coeffs</code> extracts model coefficients;
</p>
<p><code>getAllTerms</code> extracts independent variable names from a model object;
</p>
<p><code>coefTable</code> extracts a table of coefficients, standard errors and
associated degrees of freedom when possible;
</p>
<p><code>get.response</code> extracts response variable from fitted model object;
</p>
<p><code>model.names</code> generates shorthand (alpha)numeric names for one or several
fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffs(model)

getAllTerms(x, ...)
## S3 method for class 'terms'
getAllTerms(x, intercept = FALSE, offset = TRUE, ...)

coefTable(model, ...)
## S3 method for class 'averaging'
coefTable(model, full = FALSE, adjust.se = TRUE, ...)
## S3 method for class 'lme'
coefTable(model, adjustSigma, ...)
## S3 method for class 'gee'
coefTable(model, ..., type = c("naive", "robust"))

get.response(x, data = NULL, ...)

model.names(object, ..., labels = NULL, use.letters = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model+2B20utilities_+3A_model">model</code></td>
<td>
<p>a fitted model object. </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_object">object</code></td>
<td>
<p>a fitted model object or a list of such objects. </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_x">x</code></td>
<td>
<p>a fitted model object or a <code>formula</code>. </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_offset">offset</code></td>
<td>
<p>should &lsquo;offset&rsquo; terms be included? </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_intercept">intercept</code></td>
<td>
<p>should terms names include the intercept?</p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_full">full</code>, <code id="Model+2B20utilities_+3A_adjust.se">adjust.se</code></td>
<td>
<p>logical, apply to <code>"averaging"</code> objects. If <code>full</code> is 
<code>TRUE</code>, the full model-averaged coefficients are returned, and 
subset-averaged ones otherwise.
If <code>adjust.se</code> is <code>TRUE</code>, inflated standard errors are returned. 
See &lsquo;Details&rsquo; in <code><a href="#topic+par.avg">par.avg</a></code>.
</p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p> See <code><a href="nlme.html#topic+summary.lme">summary.lme</a></code>. </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_type">type</code></td>
<td>
<p> for <abbr><span class="acronym">GEE</span></abbr> models, the type of covariance estimator to calculate
returned standard errors on. Either <code>"naive"</code> or <code>"robust"</code>
(&lsquo;sandwich&rsquo;). </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_labels">labels</code></td>
<td>
<p>optionally, a character vector with names of all the terms,
e.g. from a global model. <code>model.names</code> enumerates the model terms in
order of their appearance in the list and in the models. Therefore changing the
order of the models leads to different names. Providing <code>labels</code>
prevents that. </p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_...">...</code></td>
<td>
<p>in <code>model.names</code>, more fitted model objects.
In <code>coefTable</code> arguments that are passed to appropriate <code><a href="stats.html#topic+vcov">vcov</a></code>
or <code>summary</code> method (e.g. <code>dispersion</code> parameter for <code>glm</code> may
be used here).
In <code>get.response</code>, if <code>data</code> is given, arguments to be passed to
<code><a href="stats.html#topic+model.frame">model.frame</a></code>.
In other functions may be silently ignored.
</p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>, <code>list</code> or <code>environment</code> (or object
coercible to a <code>data.frame</code>), containing the variables in <code>x</code>.
Required only if <code>x</code> is a <code>formula</code>, otherwise it can be used to
get the response variable for a different data set.
</p>
</td></tr>
<tr><td><code id="Model+2B20utilities_+3A_use.letters">use.letters</code></td>
<td>
<p>logical, whether letters should be used instead of numeric
codes. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>coeffs</code>, <code>getAllTerms</code> and <code>coefTable</code> provide
interface between the model object and <code>model.avg</code> (and
<code>dredge</code>). Custom methods can be written to provide support for
additional classes of models.
</p>


<h3>Note</h3>

<p><code>coeffs</code>'s value is in most cases identical to that returned by
<code><a href="stats.html#topic+coef">coef</a></code>, the only difference being it returns fixed effects'
coefficients for mixed models, and the value is always a named numeric vector.
</p>
<p>Use of <code>tTable</code> is deprecated in favour of <code>coefTable</code>.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>

<hr>
<h2 id='model.avg'>Model averaging</h2><span id='topic+model.avg'></span><span id='topic+model.avg.default'></span><span id='topic+model.avg.model.selection'></span><span id='topic+print.averaging'></span>

<h3>Description</h3>

<p>Model averaging based on an information criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
model.avg(object, ..., revised.var = TRUE)

## Default S3 method:
model.avg(object, ..., beta = c("none", "sd", "partial.sd"),
  rank = NULL, rank.args = NULL, revised.var = TRUE,
  dispersion = NULL, ct.args = NULL)

## S3 method for class 'model.selection'
model.avg(object, subset, fit = FALSE, ..., revised.var = TRUE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.avg_+3A_object">object</code></td>
<td>
<p> a fitted model object or a list of such objects, or a
<code>"model.selection"</code> object. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_...">...</code></td>
<td>
<p> for default method, more fitted model objects. Otherwise,
arguments that are passed to the default method. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_beta">beta</code></td>
<td>
<p> indicates whether and how the component models' coefficients 
should be standardized. See the argument's description in 
<code><a href="#topic+dredge">dredge</a></code>. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_rank">rank</code></td>
<td>
<p> optionally, a rank function (returning an information criterion) to
use instead of <code>AICc</code>, e.g. <code>BIC</code> or <code>QAIC</code>, may be
omitted if <code>object</code> is a model list returned by <code>get.models</code>
or a <code>"model.selection"</code> object. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_rank.args">rank.args</code></td>
<td>
<p> optional <code>list</code> of arguments for the <code>rank</code>
function. If one is an expression, an <code>x</code> within it is substituted
with a current model. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_revised.var">revised.var</code></td>
<td>
<p> logical, indicating whether to use the revised formula for
standard errors. See <code><a href="#topic+par.avg">par.avg</a></code>. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_dispersion">dispersion</code></td>
<td>
<p> the dispersion parameter for the family used. See
<code><a href="stats.html#topic+summary.glm">summary.glm</a></code>. This is used currently only with <code>glm</code>,
is silently ignored otherwise. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_ct.args">ct.args</code></td>
<td>
<p> optional list of arguments to be passed to
<code><a href="#topic+coefTable">coefTable</a></code> (besides <code>dispersion</code>). </p>
</td></tr>
<tr><td><code id="model.avg_+3A_subset">subset</code></td>
<td>
<p> see <code><a href="#topic+subset.model.selection">subset</a></code> method for
<code>"model.selection"</code> object. </p>
</td></tr>
<tr><td><code id="model.avg_+3A_fit">fit</code></td>
<td>
<p> if <code>TRUE</code>, the component models are fitted using
<code>get.models</code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.avg</code> may be used either with a list of models or directly with a
<code>model.selection</code> object (e.g. returned by <code>dredge</code>). In the
latter case, the models from the model selection table are not evaluated
unless the argument <code>fit</code> is set to <code>TRUE</code> or some additional
arguments are present (such as <code>rank</code> or <code>dispersion</code>). This
results in a much faster calculation, but has certain drawbacks, because the
fitted component model objects are not stored, and some methods (e.g.
<code>predict</code>, <code>fitted</code>, <code>model.matrix</code> or <code>vcov</code>) would not
be available with the returned object. Otherwise, <code>get.models</code> is
called prior to averaging, and ... are passed to it.
</p>
<p>For a list of model types that are accepted see <a href="#topic+MuMIn-models">list of
supported models</a>.
</p>
<p><code>rank</code> is found by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code> and typically is
specified as a function or a symbol or a character string specifying a 
function to be searched for from the environment of the call to lapply. 
<code>rank</code> must be a function able to accept model as a first argument and 
must always return a numeric scalar.
</p>
<p>Several standard methods for fitted model objects exist for class
<code>averaging</code>, including <code>summary</code>,
<code><a href="#topic+predict.averaging">predict</a></code>, <code>coef</code>, <code>confint</code>,
<code><a href="stats.html#topic+formula">formula</a></code>, and <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code>coef</code>, <code>vcov</code>, <code>confint</code> and <code>coefTable</code> accept argument
<code>full</code> that if set to <code>TRUE</code>, the full model-averaged coefficients
are returned, rather than subset-averaged ones (when <code>full = FALSE</code>,
being the default).
</p>
<p><code>logLik</code> returns a list of <code><a href="stats.html#topic+logLik">logLik</a></code> objects
for the component models.
</p>


<h3>Value</h3>

<p>An object of class <code>"averaging"</code> is a list with components:
</p>
<table>
<tr><td><code>msTable</code></td>
<td>
<p> a <code>data.frame</code> with log-likelihood, <em>IC</em>, 
Δ_IC and
&lsquo;Akaike weights&rsquo; for the component models.
Its attribute <code>"term.codes"</code> is a named vector with numerical 
representation of the terms in the row names of <code>msTable</code>. 
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code>matrix</code> of model-averaged coefficients. 
&ldquo;full&rdquo;  coefficients in the first row, &ldquo;subset&rdquo; coefficients in
the second row. See &lsquo;Note&rsquo; </p>
</td></tr>
<tr><td><code>coefArray</code></td>
<td>
<p> a 3-dimensional <code>array</code> of component models' coefficients,
their standard errors and degrees of freedom. </p>
</td></tr>
<tr><td><code>sw</code></td>
<td>
<p> object of class <code>sw</code> containing per-model term 
sum of model weights over all of the models in which the term appears.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> a formula corresponding to the one that would be used in a 
single model. The formula contains only the averaged (fixed) coefficients.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>
<p>The object has the following attributes:
</p>
<table>
<tr><td><code>rank</code></td>
<td>
<p>the rank function used. </p>
</td></tr>
<tr><td><code>modelList</code></td>
<td>
<p> optionally, a list of all component model objects. Only if
the object was created with model objects (and not model selection table).</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p> Corresponds to the function argument. </p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations. </p>
</td></tr>
<tr><td><code>revised.var</code></td>
<td>
<p> Corresponds to the function argument. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The &lsquo;subset&rsquo; (or &lsquo;conditional&rsquo;) average only averages over the
models where the parameter appears. An alternative, the &lsquo;full&rsquo;
average assumes that a variable is included in every model, but in some
models the corresponding coefficient (and its respective variance) is set to
zero.
Unlike the &lsquo;subset average&rsquo;, it does not have a tendency of
biasing the value away from zero. The &lsquo;full&rsquo; average is a type of
shrinkage estimator, and for variables with a weak relationship to the
response it is smaller than &lsquo;subset&rsquo; estimators.
</p>
<p>Averaging models with different contrasts for the same factor would yield
nonsense results. Currently, no checking for contrast consistency is done.
</p>
<p><code>print</code> method provides a concise output (similarly as for <code>lm</code>). 
To print more details use <code>summary</code> function, and <code><a href="stats.html#topic+confint">confint</a></code>
to get confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>
<p>Lukacs, P. M., Burnham K. P. and Anderson, D. R. 2009 Model selection
bias and Freedman’s paradox. <em>Annals of the Institute of 
Statistical Mathematics</em> <b>62</b>, 117–125.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+par.avg">par.avg</a></code> for more details of model-averaged parameter
calculation.
</p>
<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+get.models">get.models</a></code> <br />
<code><a href="#topic+AICc">AICc</a></code> has examples of averaging models fitted by REML.
</p>
<p><code><a href="AICcmodavg.html#topic+modavg">modavg</a></code> in package <span class="pkg">AICcmodavg</span>, and
<code><a href="glmulti.html#topic+coef.glmulti">coef.glmulti</a></code> in package <span class="pkg">glmulti</span> also perform model
averaging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example from Burnham and Anderson (2002), page 100:
fm1 &lt;- lm(y ~ ., data = Cement, na.action = na.fail)
(ms1 &lt;- dredge(fm1))

#models with delta.aicc &lt; 4
summary(model.avg(ms1, subset = delta &lt; 4))

#or as a 95% confidence set:
avgmod.95p &lt;- model.avg(ms1, cumsum(weight) &lt;= .95)
confint(avgmod.95p)

## Not run: 
# The same result, but re-fitting the models via 'get.models'
confset.95p &lt;- get.models(ms1, cumsum(weight) &lt;= .95)
model.avg(confset.95p)

# Force re-fitting the component models
model.avg(ms1, cumsum(weight) &lt;= .95, fit = TRUE)
# Models are also fitted if additional arguments are given
model.avg(ms1, cumsum(weight) &lt;= .95, rank = "AIC")

## End(Not run)

## Not run: 
# using BIC (Schwarz's Bayesian criterion) to rank the models
BIC &lt;- function(x) AIC(x, k = log(length(residuals(x))))
model.avg(confset.95p, rank = BIC)
# the same result, using AIC directly, with argument k
# 'x' in a quoted 'rank' argument is substituted with a model object
# (in this case it does not make much sense as the number of observations is
# common to all models)
model.avg(confset.95p, rank = AIC, rank.args = alist(k = log(length(residuals(x)))))

## End(Not run)

</code></pre>

<hr>
<h2 id='model.sel'>model selection table</h2><span id='topic+mod.sel'></span><span id='topic+model.sel'></span><span id='topic+model.sel.default'></span><span id='topic+model.sel.model.selection'></span><span id='topic+model.sel'></span>

<h3>Description</h3>

<p>Build a model selection table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
model.sel(object, ...)

## Default S3 method:
model.sel(object, ..., rank = NULL, rank.args = NULL,
  beta = c("none", "sd", "partial.sd"), extra)
## S3 method for class 'model.selection'
model.sel(object, rank = NULL, rank.args = NULL, fit = NA,
  ..., beta = c("none", "sd", "partial.sd"), extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.sel_+3A_object">object</code></td>
<td>
<p>a fitted model object, a list of such objects, or a
<code>"model.selection"</code> object.</p>
</td></tr>
<tr><td><code id="model.sel_+3A_...">...</code></td>
<td>
<p>more fitted model objects. </p>
</td></tr>
<tr><td><code id="model.sel_+3A_rank">rank</code></td>
<td>
<p>optional, custom rank function (returning an information 
criterion) to use instead of the default <code>AICc</code>, e.g. <code>QAIC</code> or <code>BIC</code>, may be omitted
if <code>object</code> is a model list returned by <code>get.models</code>. </p>
</td></tr>
<tr><td><code id="model.sel_+3A_rank.args">rank.args</code></td>
<td>
<p>optional <code>list</code> of arguments for the <code>rank</code>
function. If one is an expression, an <code>x</code> within it is substituted
with a current model. </p>
</td></tr>
<tr><td><code id="model.sel_+3A_fit">fit</code></td>
<td>
<p>logical, stating whether the model objects should be re-fitted if
they are not stored in the <code>"model.selection"</code> object. Set to
<code>NA</code> to re-fit the models only if this is needed.
See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="model.sel_+3A_beta">beta</code></td>
<td>
<p>indicates whether and how the component models' coefficients 
should be standardized. See the argument's description in 
<code><a href="#topic+dredge">dredge</a></code>. </p>
</td></tr>
<tr><td><code id="model.sel_+3A_extra">extra</code></td>
<td>
<p>optional additional statistics to include in the result,
provided as functions, function names or a list of such (best if named
or quoted). See <code><a href="#topic+dredge">dredge</a></code> for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.sel</code> used with <code>"model.selection"</code> object will re-fit model
objects, unless they are stored in <code>object</code> (in attribute <code>"modelList"</code>),
if argument <code>extra</code> is provided, or the requested <code>beta</code> is different
than object's <code>"beta"</code> attribute, or the new <code>rank</code> function
cannot be applied directly to <code>logLik</code> objects, or new <code>rank.args</code>
are given (unless argument <code>fit = FALSE</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>c("model.selection", "data.frame")</code>, being a 
<code>data.frame</code>, where each row represents one model and columns contain 
useful information about each model: the coefficients, <em>df</em>, log-likelihood, the
value of the information criterion used,  
Δ_IC and &lsquo;Akaike 
weight&rsquo;.
If any arguments differ between the modelling function calls, the 
result will include additional columns showing them (except for formulas and 
some other arguments).
</p>
<p>See <code><a href="#topic+model.selection.object">model.selection.object</a></code> for its structure. 
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+AICc">AICc</a></code>, <a href="#topic+MuMIn-models">list of supported
models</a>.
</p>
<p>Possible alternatives: <code><a href="bbmle.html#topic+ICtab">ICtab</a></code> (in package <span class="pkg">bbmle</span>), or
<code><a href="AICcmodavg.html#topic+aictab">aictab</a></code> (<span class="pkg">AICcmodavg</span>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Cement$X1 &lt;- cut(Cement$X1, 3)
Cement$X2 &lt;- cut(Cement$X2, 2)

fm1 &lt;- glm(formula = y ~ X1 + X2 * X3, data = Cement)
fm2 &lt;- update(fm1, . ~ . - X1 - X2)
fm3 &lt;- update(fm1, . ~ . - X2 - X3)

## ranked with AICc by default
(msAICc &lt;- model.sel(fm1, fm2, fm3))

## ranked with BIC
model.sel(fm1, fm2, fm3, rank = AIC, rank.args = alist(k = log(nobs(x))))
# or
# model.sel(msAICc, rank = AIC, rank.args = alist(k = log(nobs(x))))
# or
# update(msAICc, rank = AIC, rank.args = alist(k = log(nobs(x))))


</code></pre>

<hr>
<h2 id='model.selection.object'>Description of Model Selection Objects</h2><span id='topic+model.selection.object'></span>

<h3>Description</h3>

<p>An object of class <code>"model.selection"</code> holds a table of model 
coefficients and ranking statistics. It is produced by <code><a href="#topic+dredge">dredge</a></code> 
or <code><a href="#topic+model.sel">model.sel</a></code>.
</p>


<h3>Value</h3>

<p>The object is a <code>data.frame</code> with additional attributes. Each row 
represents one model. The models are ordered by the information criterion 
value specified by <code>rank</code> (lowest on top).
</p>
<p>Data frame columns:
</p>
<table>
<tr><td><code>model terms</code></td>
<td>
<p>For numeric covariates these columns hold coefficent value,
for factors their presence in the model. If the term is not present in a 
model, value is <code>NA</code>. </p>
</td></tr>
<tr><td><code>\sQuote{varying} arguments</code></td>
<td>
<p>optional. If any arguments differ between the 
modelling function calls (except for formulas and some other arguments), 
these will be held in additional columns (of class <code>"factor"</code>).</p>
</td></tr>
<tr><td><code>"df"</code></td>
<td>
<p>Number of model parameters</p>
</td></tr>
<tr><td><code>"logLik"</code></td>
<td>
<p>Log-likelihood (or quasi-likelihood for <abbr><span class="acronym">GEE</span></abbr>)</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Information criterion value</p>
</td></tr>
<tr><td><code>"delta"</code></td>
<td>
<p>Δ_IC</p>
</td></tr>
<tr><td><code>"weight"</code></td>
<td>
<p>&lsquo;Akaike weights&rsquo;.</p>
</td></tr>
</table>
<p>Attributes:
</p>
<table>
<tr><td><code>model.calls</code></td>
<td>
<p>A list containing model calls (arranged in 
the same order as in the table). A model call can be retrieved with
<code>getCall(*, i)</code> where <var>i</var> is a vector of model index or name 
(if given as character string). </p>
</td></tr>
<tr><td><code>global</code></td>
<td>
<p>The <code>global.model</code> object </p>
</td></tr>
<tr><td><code>global.call</code></td>
<td>
<p>Call to the <code>global.model</code> </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>A character string holding all term names. Attribute 
<code>"interceptLabel"</code> gives the name of the intercept term. </p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>The <code>rank</code> function used </p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A character string, representing the coefficient standardizing 
method used. Either <code>"none"</code>, <code>"sd"</code> or <code>"partial.sd"</code>
</p>
</td></tr>
<tr><td><code>coefTables</code></td>
<td>
<p>List of matrices of class <code>"coefTable"</code> containing 
each model's coefficients with std. errors and associated <var>df</var>s </p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations </p>
</td></tr>
<tr><td><code>warnings</code></td>
<td>
<p>optional (<code>pdredge</code> only). A list of errors and 
warnings issued by the modelling function during the fitting, with a model
number appended to each. </p>
</td></tr>
</table>
<p>Most attributes does not need (and should not) be accessed directly, use of extractor
functions is preferred. These functions include <code>getCall</code> for 
retrieving model calls, <code>coefTable</code> and <code>coef</code> for coefficients, 
and <code>nobs</code>. <code>logLik</code> extracts list of model log-likelihoods (as 
<code>"logLik"</code> objects), and <code>Weights</code> extracts &lsquo;Akaike 
weights&rsquo;.
</p>
<p>The object has class <code>c("model.selection", "data.frame")</code>.    
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+model.sel">model.sel</a></code>.
</p>

<hr>
<h2 id='MuMIn-models'>List of supported models</h2><span id='topic+MuMIn-models'></span>

<h3>Description</h3>

<p>List of model classes accepted by <code>model.avg</code>, <code>model.sel</code>,
and <code>dredge</code>.
</p>


<h3>Details</h3>

<p>Fitted model objects that can be used with model selection and model averaging
functions include those produced by:
</p>

<ul>
<li> <p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> (package <span class="pkg">stats</span>);
</p>
</li>
<li> <p><code><a href="MASS.html#topic+rlm">rlm</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> and <code><a href="MASS.html#topic+polr">polr</a></code> (<a href="https://cran.r-project.org/package=MASS"><span class="pkg">MASS</span></a>);
</p>
</li>
<li> <p><code><a href="nnet.html#topic+multinom">multinom</a></code> (<a href="https://cran.r-project.org/package=nnet"><span class="pkg">nnet</span></a>);
</p>
</li>
<li> <p><code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="nlme.html#topic+gls">gls</a></code> (<a href="https://cran.r-project.org/package=nlme"><span class="pkg">nlme</span></a>);
</p>
</li>
<li> <p><code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code> (<a href="https://cran.r-project.org/package=lme4"><span class="pkg">lme4</span></a>);
</p>
</li>
<li> <p><code><a href="cplm.html#topic+cpglm">cpglm</a></code>, <code><a href="cplm.html#topic+cpglmm">cpglmm</a></code> (<a href="https://cran.r-project.org/package=cplm"><span class="pkg">cplm</span></a>);
</p>
</li>
<li> <p><code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+gamm">gamm</a></code>* (<a href="https://cran.r-project.org/package=mgcv"><span class="pkg">mgcv</span></a>);
</p>
</li>
<li> <p><code><a href="gamm4.html#topic+gamm4">gamm4</a></code>* (<a href="https://cran.r-project.org/package=gamm4"><span class="pkg">gamm4</span></a>);
</p>
</li>
<li> <p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code> (<a href="https://cran.r-project.org/package=gamlss"><span class="pkg">gamlss</span></a>);
</p>
</li>
<li> <p><code><a href="glmmML.html#topic+glmmML">glmmML</a></code> (<a href="https://cran.r-project.org/package=glmmML"><span class="pkg">glmmML</span></a>);
</p>
</li>
<li> <p><code>glmmadmb</code> (<a href="http://glmmadmb.r-forge.r-project.org/"><span class="pkg">glmmADMB</span></a>
from R-Forge);
</p>
</li>
<li> <p><code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code> (<a href="https://cran.r-project.org/package=glmmTMB"><span class="pkg">glmmTMB</span></a>);
</p>
</li>
<li> <p><code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm</a></code>* (<a href="https://cran.r-project.org/package=MCMCglmm"><span class="pkg">MCMCglmm</span></a>);
</p>
</li>
<li> <p><code>asreml</code> (non-free commercial package <span class="pkg">asreml</span>; allows only for 
<abbr><span class="acronym">REML</span></abbr> comparisons);
</p>
</li>
<li> <p><code><a href="pscl.html#topic+hurdle">hurdle</a></code>, <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a></code> (<a href="https://cran.r-project.org/package=pscl"><span class="pkg">pscl</span></a>);
</p>
</li>
<li> <p><code><a href="aod.html#topic+negbin">negbin</a></code>, <code><a href="aod.html#topic+betabin">betabin</a></code> (class <code>"glimML"</code>), 
package <a href="https://cran.r-project.org/package=aod"><span class="pkg">aod</span></a>);
</p>
</li>
<li> <p><code><a href="aods3.html#topic+aodml">aodml</a></code>, <code><a href="aods3.html#topic+aodql">aodql</a></code> (<a href="https://cran.r-project.org/package=aods3"><span class="pkg">aods3</span></a>);
</p>
</li>
<li> <p><code><a href="betareg.html#topic+betareg">betareg</a></code> (<a href="https://cran.r-project.org/package=betareg"><span class="pkg">betareg</span></a>);
</p>
</li>
<li> <p><code><a href="brglm.html#topic+brglm">brglm</a></code> (<a href="https://cran.r-project.org/package=brglm"><span class="pkg">brglm</span></a>);
</p>
</li>
<li> <p><code>*sarlm</code> models, <code><a href="spatialreg.html#topic+spautolm">spautolm</a></code> (<a href="https://cran.r-project.org/package=spatialreg"><span class="pkg">spatialreg</span></a>);
</p>
</li>
<li> <p><code><a href="splm.html#topic+spml">spml</a></code>* (if fitted by <abbr><span class="acronym">ML</span></abbr>, <a href="https://cran.r-project.org/package=splm"><span class="pkg">splm</span></a>);
</p>
</li>
<li> <p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="survival.html#topic+survreg">survreg</a></code> (<a href="https://cran.r-project.org/package=survival"><span class="pkg">survival</span></a>);
</p>
</li>
<li> <p><code><a href="coxme.html#topic+coxme">coxme</a></code>, <code><a href="coxme.html#topic+lmekin">lmekin</a></code> (<a href="https://cran.r-project.org/package=coxme"><span class="pkg">coxme</span></a>);
</p>
</li>
<li> <p><code><a href="quantreg.html#topic+rq">rq</a></code> (<a href="https://cran.r-project.org/package=quantreg"><span class="pkg">quantreg</span></a>);
</p>
</li>
<li> <p><code><a href="ordinal.html#topic+clm">clm</a></code> and <code><a href="ordinal.html#topic+clmm">clmm</a></code> (<a href="https://cran.r-project.org/package=ordinal"><span class="pkg">ordinal</span></a>);
</p>
</li>
<li> <p><code><a href="logistf.html#topic+logistf">logistf</a></code> (<a href="https://cran.r-project.org/package=logistf"><span class="pkg">logistf</span></a>); 
</p>
</li>
<li> <p><code><a href="caper.html#topic+crunch">crunch</a></code>*, <code><a href="caper.html#topic+pgls">pgls</a></code> (<a href="https://cran.r-project.org/package=caper"><span class="pkg">caper</span></a>);
</p>
</li>
<li> <p><code><a href="maxlike.html#topic+maxlike">maxlike</a></code> (<a href="https://cran.r-project.org/package=maxlike"><span class="pkg">maxlike</span></a>);
</p>
</li>
<li><p> functions from package <a href="https://cran.r-project.org/package=unmarked"><span class="pkg">unmarked</span></a> (within the class 
<code>"unmarkedFit"</code>);
</p>
</li>
<li> <p><code><a href="RMark.html#topic+mark">mark</a></code> and related functions (class <code>mark</code> from package
<a href="https://cran.r-project.org/package=RMark"><span class="pkg">RMark</span></a>). Currently <code>dredge</code> can only manipulate <code>formula</code>
element of the argument <code>model.parameters</code>, keeping its other elements
intact.
</p>
</li></ul>

<p>Generalized Estimation Equation model implementations: 
<code><a href="geepack.html#topic+geeglm">geeglm</a></code> from package <a href="https://cran.r-project.org/package=geepack"><span class="pkg">geepack</span></a>, 
<code><a href="gee.html#topic+gee">gee</a></code> from <a href="https://cran.r-project.org/package=gee"><span class="pkg">gee</span></a>, 
<code><a href="geeM.html#topic+geem">geem</a></code> from <a href="https://cran.r-project.org/package=geeM"><span class="pkg">geeM</span></a>, 
<code><a href="wgeesel.html#topic+wgee">wgee</a></code> from <a href="https://cran.r-project.org/package=wgeesel"><span class="pkg">wgeesel</span></a>, 
and <code>yags</code> from  <a href="http://yags.r-forge.r-project.org/"><span class="pkg">yags</span></a> (on 
R-Forge) can be used with <code><a href="#topic+QIC">QIC</a></code> as the selection criterion.
</p>
<p>Other classes are also likely to be supported, in particular if they inherit
from one of the above classes. In general, the models averaged with
<code>model.avg</code> may belong to different types (e.g. <code>glm</code> and <code>gam</code>), 
provided they use the same data and response, and if it is valid to do so. 
This applies also to constructing model selection tables with <code>model.sel</code>.
</p>


<h3>Note</h3>

<p>* In order to use <code>gamm</code>, <code>gamm4</code>, <code>spml (&gt; 1.0.0)</code>,
<code>crunch</code> or <code>MCMCglmm</code> with <code>dredge</code>, an
<code><a href="#topic+updateable">updateable</a></code> wrapper for these functions should be created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.avg">model.avg</a></code>, <code><a href="#topic+model.sel">model.sel</a></code> and <code><a href="#topic+dredge">dredge</a></code>.
</p>

<hr>
<h2 id='nested'>Identify nested models</h2><span id='topic+nested'></span>

<h3>Description</h3>

<p>Find models that are &lsquo;nested&rsquo; within each model in the model 
selection table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested(x, indices = c("none", "numeric", "rownames"), rank = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_+3A_x">x</code></td>
<td>
<p>a <code>"model.selection"</code> object (result of <code>dredge</code> or 
<code>model.sel</code>). </p>
</td></tr>
<tr><td><code id="nested_+3A_indices">indices</code></td>
<td>
<p>if omitted or <code>"none"</code> then the function checks if, for 
each model, there are any higher ranked models nested within it.
If <code>"numeric"</code> or <code>"rownames"</code>, indices or names of all nested
models are returned. See &ldquo;Value&rdquo;.
</p>
</td></tr>
<tr><td><code id="nested_+3A_rank">rank</code></td>
<td>
<p>the name of the column with the ranking values (defaults to 
the one before &ldquo;delta&rdquo;). Only used if <code>indices</code> is 
<code>"none"</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In model comparison, a model is said to be &ldquo;nested&rdquo; within another 
model if it contains a subset of parameters of the latter model, but does not
include other parameters (e.g. model &lsquo;A+B&rsquo; is nested within 
&lsquo;A+B+C&rsquo; but not &lsquo;A+C+D&rsquo;). 
</p>
<p>This function can be useful in a model selection approach suggested by 
Richards (2008), in which more complex variants of any model with a lower 
IC value are excluded from the candidate set. 
</p>


<h3>Value</h3>

<p>A vector of length equal to the number of models (table rows).
</p>
<p>If <code>indices = "none"</code> (the default), it is a vector of logical 
values where <em>i</em>-th element is <code>TRUE</code> if any model(s) higher up in
the table are nested within it (i.e. if simpler models have lower IC pointed
by <code>rank</code>).
</p>
<p>For <code>indices</code> other than <code>"none"</code>, the function returns a list of 
vectors of numeric indices or names of models nested within each 
<em>i</em>-th model.
</p>


<h3>Note</h3>

<p>This function determines nesting based only on fixed model terms, within groups of 
models sharing the same &lsquo;varying&rsquo; parameters (see <code>dredge</code> and 
example in <code>Beetle</code>).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Richards, S. A., Whittingham, M. J., Stephens, P. A. 2011 Model selection and 
model averaging in behavioural ecology: the utility of the IT-AIC framework. 
<em>Behavioral Ecology and Sociobiology</em> <b>65</b>, 77&ndash;89.
</p>
<p>Richards, S. A. 2008 Dealing with overdispersed count data in applied
ecology. <em>Journal of Applied Ecology</em> <b>45</b>, 218&ndash;227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+model.sel">model.sel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm &lt;- lm(y ~ X1 + X2 + X3 + X4, data = Cement, na.action = na.fail)
ms &lt;- dredge(fm)

# filter out overly complex models according to the 
# "nesting selection rule":
subset(ms, !nested(.)) # dot represents the ms table object

# print model "4" and all models nested within it
nst &lt;- nested(ms, indices = "row")
ms[c("4", nst[["4"]])]

ms$nested &lt;- sapply(nst, paste, collapse = ",")

ms

</code></pre>

<hr>
<h2 id='par.avg'>Parameter averaging</h2><span id='topic+par.avg'></span>

<h3>Description</h3>

<p>Average a coefficient with standard errors based on provided weights. 
This function is intended chiefly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.avg(x, se, weight, df = NULL, level = 1 - alpha, alpha = 0.05,
  revised.var = TRUE, adjusted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.avg_+3A_x">x</code></td>
<td>
<p>vector of parameters. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_se">se</code></td>
<td>
<p>vector of standard errors. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_weight">weight</code></td>
<td>
<p>vector of weights. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_df">df</code></td>
<td>
<p>optional vector of degrees of freedom. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_alpha">alpha</code>, <code id="par.avg_+3A_level">level</code></td>
<td>
<p>significance level for calculating confidence intervals. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_revised.var">revised.var</code></td>
<td>
<p>logical, should the revised formula for standard errors be
used? See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="par.avg_+3A_adjusted">adjusted</code></td>
<td>
<p>logical, should the inflated standard errors be calculated? See
&lsquo;Details&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unconditional standard errors are square root of the variance estimator,
calculated either according to the original equation in Burnham and Anderson
(2002, equation 4.7),
or a newer, revised formula from Burnham and Anderson (2004, equation 4)
(if <code>revised.var = TRUE</code>, this is the default).
If <code>adjusted = TRUE</code> (the default) and degrees of freedom are given, the
adjusted standard error estimator and confidence intervals with improved 
coverage are returned (see Burnham and Anderson 2002, section 4.3.3).
</p>


<h3>Value</h3>

<p><code>par.avg</code> returns a vector with named elements:
</p>
<table>
<tr><td><code>Coefficient</code></td>
<td>
<p>model coefficients</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>unconditional standard error</p>
</td></tr>
<tr><td><code>Adjusted SE</code></td>
<td>
<p>adjusted standard error</p>
</td></tr>
<tr><td><code>Lower CI</code>, <code>Upper CI</code></td>
<td>
<p>unconditional confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed.
</p>
<p>Burnham, K. P. and Anderson, D. R. 2004 Multimodel inference -
understanding AIC and BIC in model selection. <em>Sociological Methods &amp; Research</em>
<b>33</b>, 261&ndash;304.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.avg">model.avg</a></code> for model averaging.
</p>

<hr>
<h2 id='pdredge'>Automated model selection using parallel computation</h2><span id='topic+pdredge'></span>

<h3>Description</h3>

<p>Parallelized version of <code>dredge</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdredge(global.model, cluster = NULL, 
  beta = c("none", "sd", "partial.sd"), evaluate = TRUE, rank = "AICc", 
  fixed = NULL, m.lim = NULL, m.min, m.max, subset, trace = FALSE, 
  varying, extra, ct.args = NULL, deps = attr(allTerms0, "deps"),
  check = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdredge_+3A_global.model">global.model</code>, <code id="pdredge_+3A_beta">beta</code>, <code id="pdredge_+3A_rank">rank</code>, <code id="pdredge_+3A_fixed">fixed</code>, <code id="pdredge_+3A_m.lim">m.lim</code>, <code id="pdredge_+3A_m.max">m.max</code>, <code id="pdredge_+3A_m.min">m.min</code>, <code id="pdredge_+3A_subset">subset</code>, <code id="pdredge_+3A_varying">varying</code>, <code id="pdredge_+3A_extra">extra</code>, <code id="pdredge_+3A_ct.args">ct.args</code>, <code id="pdredge_+3A_deps">deps</code>, <code id="pdredge_+3A_...">...</code></td>
<td>

<p>see <code><a href="#topic+dredge">dredge</a></code>. </p>
</td></tr>
<tr><td><code id="pdredge_+3A_evaluate">evaluate</code></td>
<td>
<p>whether to evaluate and rank the models. If <code>FALSE</code>, a
list of unevaluated <code>call</code>s is returned and <code>cluster</code> is 
not used. 
</p>
</td></tr>
<tr><td><code id="pdredge_+3A_trace">trace</code></td>
<td>
<p> displays the generated calls, but may not work as expected
since the models are evaluated in batches rather than one by one. </p>
</td></tr>
<tr><td><code id="pdredge_+3A_cluster">cluster</code></td>
<td>
<p> either a valid <code>"cluster"</code> object, or <code>NULL</code> for a
single threaded execution. </p>
</td></tr>
<tr><td><code id="pdredge_+3A_check">check</code></td>
<td>
<p> either integer or logical value controlling how much checking
for existence and correctness of dependencies is done on the cluster
nodes. See &lsquo;Details&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the dependencies for fitting the <code>global.model</code>, including the data
and any objects that the modelling function will use must be exported
to the cluster worker nodes (e.g. <em>via</em> <code>clusterExport</code>). 
The required packages must be also loaded thereinto (e.g. <em>via</em>
<code>clusterEvalQ(..., library(package))</code>, before the cluster is used by
<code>pdredge</code>.
</p>
<p>If <code>check</code> is <code>TRUE</code> or positive, <code>pdredge</code> tries to check whether
all the variables and functions used in the call to <code>global.model</code> are
present in the cluster nodes' <code>.GlobalEnv</code> before proceeding further.
This will cause false errors if some arguments of the model call (other than
<code>subset</code>) would be evaluated in the <code>data</code> environment. In that 
case is desirable to use <code>check = FALSE</code> (the default).
</p>
<p>If <code>check</code> is <code>TRUE</code> or greater than one, <code>pdredge</code> will
compare the <code>global.model</code> updated on the cluster nodes with the one
given as an argument.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+dredge">dredge</a></code>.
</p>


<h3>Note</h3>

<p>As of version 1.45.0, using <code>pdredge</code> directly is deprecated. Use 
<code>dredge</code> instead and provide <code>cluster</code> argument. 
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code>makeCluster</code> and other cluster related functions in packages
<span class="pkg">parallel</span> or <span class="pkg">snow</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# One of these packages is required:
## Not run: require(parallel) || require(snow)

# From example(Beetle)

Beetle100 &lt;- Beetle[sample(nrow(Beetle), 100, replace = TRUE),]

fm1 &lt;- glm(Prop ~ dose + I(dose^2) + log(dose) + I(log(dose)^2),
    data = Beetle100, family = binomial, na.action = na.fail)

msubset &lt;- expression(xor(dose, `log(dose)`) &amp; (dose | !`I(dose^2)`)
    &amp; (`log(dose)` | !`I(log(dose)^2)`))
varying.link &lt;- list(family = alist(logit = binomial("logit"),
    probit = binomial("probit"), cloglog = binomial("cloglog") ))

# Set up the cluster
clusterType &lt;- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
clust &lt;- try(makeCluster(getOption("cl.cores", 2), type = clusterType))

clusterExport(clust, "Beetle100")

# noticeable gain only when data has about 3000 rows (Windows 2-core machine)
print(system.time(dredge(fm1, subset = msubset, varying = varying.link)))
print(system.time(dredge(fm1, cluster = FALSE, subset = msubset,
    varying = varying.link)))
print(system.time(pdd &lt;- dredge(fm1, cluster = clust, subset = msubset,
    varying = varying.link)))

print(pdd)

## Not run: 
# Time consuming example with 'unmarked' model, based on example(pcount).
# Having enough patience you can run this with 'demo(pdredge.pcount)'.
library(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
    obsCovs = mallard.obs)
(ufm.mallard &lt;- pcount(~ ivel + date + I(date^2) ~ length + elev + forest,
    mallardUMF, K = 30))
clusterEvalQ(clust, library(unmarked))
clusterExport(clust, "mallardUMF")

# 'stats4' is needed for AIC to work with unmarkedFit objects but is not
# loaded automatically with 'unmarked'.
require(stats4)
invisible(clusterCall(clust, "library", "stats4", character.only = TRUE))

#system.time(print(pdd1 &lt;- dredge(ufm.mallard,
#   subset = `p(date)` | !`p(I(date^2))`, rank = AIC)))

system.time(print(pdd2 &lt;- dredge(ufm.mallard, cluster = clust,
    subset = `p(date)` | !`p(I(date^2))`, rank = AIC, extra = "adjR^2")))


# best models and null model
subset(pdd2, delta &lt; 2 | df == min(df))

# Compare with the model selection table from unmarked
# the statistics should be identical:
models &lt;- get.models(pdd2, delta &lt; 2 | df == min(df), cluster = clust)

modSel(fitList(fits = structure(models, names = model.names(models,
    labels = getAllTerms(ufm.mallard)))), nullmod = "(Null)")

## End(Not run)

stopCluster(clust)


</code></pre>

<hr>
<h2 id='plot.model.selection'>Visualize model selection table</h2><span id='topic+plot.model.selection'></span>

<h3>Description</h3>

<p>Produces a graphical representation of model weights and terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.selection'
plot(
  x,
  ylab = NULL, xlab = NULL, main = "Model selection table",
  labels = NULL, terms = NULL, labAsExpr = TRUE,
  vlabels = rownames(x), mar.adj = TRUE,
  col = NULL, col.mode = 2,
  bg = "white", border = par("col"),
  par.lab = NULL, par.vlab = NULL,
  axes = TRUE, ann = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.model.selection_+3A_x">x</code></td>
<td>
<p>a <code>"model.selection"</code> object.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_xlab">xlab</code>, <code id="plot.model.selection_+3A_ylab">ylab</code>, <code id="plot.model.selection_+3A_main">main</code></td>
<td>
<p>labels for the <em>x</em> and <em>y</em> axes, and the
main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_labels">labels</code></td>
<td>
<p>optional, a character vector or an expression containing model
term labels (to appear on top side of the plot).
Its length must be equal to number of displayed model terms. Defaults
to the model term names.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_terms">terms</code></td>
<td>
<p>which terms to include (default <code>NULL</code> means all terms).</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_labasexpr">labAsExpr</code></td>
<td>
<p>logical, indicating whether the term names should be
interpreted (<code><a href="base.html#topic+parse">parse</a></code>d) as <span class="rlang"><b>R</b></span> expressions for prettier labels.
See also <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_vlabels">vlabels</code></td>
<td>
<p>alternative labels for the table rows (i.e. model names)</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_mar.adj">mar.adj</code></td>
<td>
<p>logical indicating whether the top and right margin should be
enlarged if necessary to fit the labels.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_col">col</code></td>
<td>
<p>vector or a <code>matrix</code> of colours for the non-empty grid cells.
See 'Details'.
If <code>col</code> is given as a matrix, the colours are applied to rows and columns. How it
is done is governed by the argument <code>col.mode</code>.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_col.mode">col.mode</code></td>
<td>
<p>either numeric or <code>"value"</code>, specifies cell colouring mode.
See 'Details'.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_bg">bg</code></td>
<td>
<p>background colour for the empty cells.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_border">border</code></td>
<td>
<p>border colour for cells and axes.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_par.lab">par.lab</code>, <code id="plot.model.selection_+3A_par.vlab">par.vlab</code></td>
<td>
<p>optional lists of arguments and
<a href="graphics.html#topic+par">graphical parameters</a> for drawing
term labels (top axis) and model names (right axis), respectively.
Items of <code>par.lab</code> are passed as arguments to <code><a href="graphics.html#topic+mtext">mtext</a></code>, and those of
<code>par.vlab</code> are passed to <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_axes">axes</code>, <code id="plot.model.selection_+3A_ann">ann</code></td>
<td>
<p>logical values indicating whether the axis and annotation
should appear on the plot.</p>
</td></tr>
<tr><td><code id="plot.model.selection_+3A_...">...</code></td>
<td>
<p>further <a href="graphics.html#topic+par">graphical parameters</a> to be set for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Colours</h4>

<p>If <code>col.mode = 0</code>, the colours are recycled: if <code>col</code> is a matrix,
recycling takes place both per row and per column. If <code>col.mode &gt; 0</code>, the
colour values in the columns are interpolated and assigned according to
the model weights. Higher values shift the colours for models with lower
model weights more forward. See also <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>. If <code>col.mode &lt; 0</code> or
<code>"value"</code> (partially matched, case-insensitive) and <code>col</code> has two or more
elements, colours are used to represent coefficient values: the first
element in <code>col</code> is used for categorical predictors, the rest for
continuous values. The default is <code>grey</code> for factors and
<a href="grDevices.html#topic+hcl.colors">HCL palette</a> <code>"Blue-Red 3"</code> otherwise, ranging from blue
for negative values to red for positive ones.
</p>

<p>The following arguments are useful for adjusting label size and
position in <code>par.lab</code> and <code>par.vlab</code> : <code>cex</code>, <code>las</code> (see <code><a href="graphics.html#topic+par">par</a></code>),
<code>line</code> and <code>hadj</code> (see <code><a href="graphics.html#topic+mtext">mtext</a></code> and <code><a href="graphics.html#topic+axis">axis</a></code>).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+par">par</a></code>, <code><a href="#topic+MuMIn-package">MuMIn-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dd &lt;- dredge(lm(formula = y ~ ., data = Cement, na.action = na.fail))
plot(dd,
    # colours by coefficient value:
    col.mode = "value",
    par.lab = list(las = 2, line = 1.2, cex = 1),
    bg = "gray30",
    # change labels for the models to Akaike weights:
    vlabels = parse(text = paste("omega ==", round(Weights(dd), 2)))
    )
plot(dd, col = 2:3, col.mode = 0) # colour recycled by row
plot(dd, col = cbind(2:3, 4:5), col.mode = 0) # colour recycled by row and column
plot(dd, col = 2:3, col.mode = 1) # colour gradient by model weight

</code></pre>

<hr>
<h2 id='predict.averaging'>Predict method for averaged models</h2><span id='topic+predict.averaging'></span>

<h3>Description</h3>

<p>Model-averaged predictions, optionally with standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'averaging'
predict(object, newdata = NULL, se.fit = FALSE,
  interval = NULL, type = NA, backtransform = FALSE, full = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.averaging_+3A_object">object</code></td>
<td>
<p>an object returned by <code>model.avg</code>. </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_newdata">newdata</code></td>
<td>
<p> optional <code>data.frame</code> in which to look for variables 
with which to predict. If omitted, the fitted values are used. </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_se.fit">se.fit</code></td>
<td>
<p>logical, indicates if standard errors should be returned.
This has any effect only if the <code>predict</code> methods for each of the
component models support it. </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_interval">interval</code></td>
<td>
<p>currently not used. </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_type">type</code></td>
<td>
<p>the type of predictions to return (see documentation for
<code>predict</code> appropriate for the class of used component models). If
omitted, the default type is used. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_backtransform">backtransform</code></td>
<td>
<p>if <code>TRUE</code>, the averaged predictions are
back-transformed from link scale to response scale. This makes sense
provided that all component models use the same <code>family</code>, and the
prediction from each of the component models is calculated on the link 
scale (as specified by <code>type</code>. For <code>glm</code>, use <code>type = 
		"link"</code>).
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_full">full</code></td>
<td>
<p> if <code>TRUE</code>, the full model-averaged coefficients are used
(only if <code>se.fit = FALSE</code> and the component objects are a result of
<code>lm</code>). </p>
</td></tr>
<tr><td><code id="predict.averaging_+3A_...">...</code></td>
<td>
<p>arguments to be passed to respective <code>predict</code>
method (e.g. <code>level</code> for <code><a href="nlme.html#topic+lme">lme</a></code> model). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict</code>ing is possible only with <code>averaging</code> objects with
<code>"modelList"</code> attribute, i.e. those created <em>via</em> <code>model.avg</code>
from a model list, or from <code>model.selection</code> object with argument <code>fit
= TRUE</code> (which will recreate the model objects, see <code><a href="#topic+model.avg">model.avg</a></code>).
</p>
<p>If all the component models are ordinary linear models, the prediction can be
made either with the full averaged coefficients (the argument <code>full =
TRUE</code> this is the default) or subset-averaged coefficients. Otherwise the
prediction is obtained by calling <code>predict</code> on each component model and
weighted averaging the results, which corresponds to the assumption that all
predictors are present in all models, but those not estimated are equal zero 
(see &lsquo;Note&rsquo; in <code><a href="#topic+model.avg">model.avg</a></code>). Predictions from component models
with standard errors are passed to <code>par.avg</code> and averaged in the same way
as the coefficients are.
</p>
<p>Predictions on the response scale from generalized models can be calculated by
averaging predictions of each model on the link scale, followed by inverse
transformation (this is achieved with <code>type = "link"</code> and
<code>backtransform = TRUE</code>). This is only possible if all component models use
the same family and link function. Alternatively, predictions from each model on
response scale may be averaged (with <code>type = "response"</code> and
<code>backtransform = FALSE</code>). Note that this leads to results differing from
those calculated with the former method. See also
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector of predictions, otherwise a list
with components: <code>fit</code> containing the predictions, and <code>se.fit</code> with
the estimated standard errors.
</p>


<h3>Note</h3>

<p>This method relies on availability of the <code>predict</code> methods for the
component model classes (except when all component models are of class
<code>lm</code>).
</p>
<p>The package <span class="pkg">MuMIn</span> includes <code>predict</code> methods for <code>lme</code>,
and <code>gls</code> that calculate standard errors of the predictions
(with <code>se.fit = TRUE</code>). They enhance the original predict methods from
package <span class="pkg">nlme</span>, and with <code>se.fit = FALSE</code> they return identical result.
<span class="pkg">MuMIn</span>'s versions are always used in averaged model predictions (so it is
possible to predict with standard errors), but from within global environment
they will be found only if <span class="pkg">MuMIn</span> is before <span class="pkg">nlme</span> on the
<a href="base.html#topic+search">search list</a> (or directly extracted from namespace as
<code>MuMIn:::predict.lme</code>).
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.avg">model.avg</a></code>, and <code><a href="#topic+par.avg">par.avg</a></code> for details of model-averaged
parameter calculation.
</p>
<p><code><a href="nlme.html#topic+predict.lme">predict.lme</a></code>, <code><a href="nlme.html#topic+predict.gls">predict.gls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Example from Burnham and Anderson (2002), page 100:
fm1 &lt;- lm(y ~ X1 + X2 + X3 + X4, data = Cement)

ms1 &lt;- dredge(fm1)
confset.95p &lt;- get.models(ms1, subset = cumsum(weight) &lt;= .95)
avgm &lt;- model.avg(confset.95p)

nseq &lt;- function(x, len = length(x)) seq(min(x, na.rm = TRUE),
    max(x, na.rm=TRUE), length = len)

# New predictors: X1 along the range of original data, other
# variables held constant at their means
newdata &lt;- as.data.frame(lapply(lapply(Cement[, -1], mean), rep, 25))
newdata$X1 &lt;- nseq(Cement$X1, nrow(newdata))

n &lt;- length(confset.95p)

# Predictions from each of the models in a set, and with averaged coefficients
pred &lt;- data.frame(
	model = sapply(confset.95p, predict, newdata = newdata),
	averaged.subset = predict(avgm, newdata, full = FALSE),
    averaged.full = predict(avgm, newdata, full = TRUE)
	)

opal &lt;- palette(c(topo.colors(n), "black", "red", "orange"))
matplot(newdata$X1, pred, type = "l",
	lwd = c(rep(2,n),3,3), lty = 1,
    xlab = "X1", ylab = "y", col=1:7)

# For comparison, prediction obtained by averaging predictions of the component
# models
pred.se &lt;- predict(avgm, newdata, se.fit = TRUE)
y &lt;- pred.se$fit
ci &lt;- pred.se$se.fit  * 2
matplot(newdata$X1, cbind(y, y - ci, y + ci), add = TRUE, type="l",
	lty = 2, col = n + 3, lwd = 3)

legend("topleft",
    legend=c(lapply(confset.95p, formula),
        paste(c("subset", "full"), "averaged"), "averaged predictions + CI"),
    lty = 1, lwd = c(rep(2,n),3,3,3),  cex = .75, col=1:8)

palette(opal)

</code></pre>

<hr>
<h2 id='QAIC'>Quasi AIC or AICc</h2><span id='topic+QAIC'></span><span id='topic+QAICc'></span>

<h3>Description</h3>

<p>Calculate a modification of Akaike's Information Criterion for overdispersed
count data (or its version corrected for small sample,
&ldquo;quasi-AIC<code class="reqn">_{c}</code>&rdquo;), for one or several fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QAIC(object, ..., chat, k = 2, REML = NULL)
QAICc(object, ..., chat, k = 2, REML = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QAIC_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="QAIC_+3A_...">...</code></td>
<td>
<p> optionally, more fitted model objects.</p>
</td></tr>
<tr><td><code id="QAIC_+3A_chat">chat</code></td>
<td>
 <p><code class="reqn">\hat{c}</code>, the variance inflation factor. </p>
</td></tr>
<tr><td><code id="QAIC_+3A_k">k</code></td>
<td>
<p>the &lsquo;penalty&rsquo; per parameter. </p>
</td></tr>
<tr><td><code id="QAIC_+3A_reml">REML</code></td>
<td>
<p> optional logical value, passed to the <code>logLik</code> method
indicating whether the restricted log-likelihood or log-likelihood should be
used. The default is to use the method used for model estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only one object is provided, returns a numeric value with the
corresponding QAIC or QAIC<code class="reqn">_{c}</code>; otherwise returns a
<code>data.frame</code> with rows corresponding to the objects.
</p>


<h3>Note</h3>

<p><code class="reqn">\hat{c}</code> is the dispersion parameter estimated from the global
model, and can be calculated by dividing model's deviance by the number of
residual degrees of freedom.
</p>
<p>In calculation of QAIC, the number of model parameters is increased by 1 to
account for estimating the overdispersion parameter. Without overdispersion,
<code class="reqn">\hat{c} = 1</code> and QAIC is equal to AIC.
</p>
<p>Note that <code>glm</code> does not compute maximum-likelihood estimates in models
within the <em>quasi-</em> family. In case it is justified, it can be worked 
around by &lsquo;borrowing&rsquo; the <code>aic</code> element from the corresponding
&lsquo;non-quasi&rsquo; family (see &lsquo;Example&rsquo;).
</p>
<p>Consider using negative binomial family with overdispersed count data.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc">AICc</a></code>, <code><a href="stats.html#topic+family">quasi</a></code> family used for models with
over-dispersion.
</p>
<p>Tests for overdispersion in GLM[M]: <code><a href="performance.html#topic+check_overdispersion">check_overdispersion</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
options(na.action = "na.fail")

# Based on "example(predict.glm)", with one number changed to create
# overdispersion
budworm &lt;- data.frame(
    ldose = rep(0:5, 2), sex = factor(rep(c("M", "F"), c(6, 6))),
    numdead = c(10, 4, 9, 12, 18, 20, 0, 2, 6, 10, 12, 16))
budworm$SF = cbind(numdead = budworm$numdead,
    numalive = 20 - budworm$numdead)

budworm.lg &lt;- glm(SF ~ sex*ldose, data = budworm, family = binomial)
(chat &lt;- deviance(budworm.lg) / df.residual(budworm.lg))

dredge(budworm.lg, rank = "QAIC", chat = chat)
dredge(budworm.lg, rank = "AIC")


## Not run: 
# A 'hacked' constructor for quasibinomial family object that allows for
# ML estimation
hacked.quasibinomial &lt;- function(...) {
    res &lt;- quasibinomial(...)
    res$aic &lt;- binomial(...)$aic
    res
}
QAIC(update(budworm.lg, family = hacked.quasibinomial), chat = chat)

## End(Not run)

</code></pre>

<hr>
<h2 id='QIC'>QIC and quasi-Likelihood for GEE</h2><span id='topic+QIC'></span><span id='topic+QICu'></span><span id='topic+quasiLik'></span>

<h3>Description</h3>

<p>Calculate quasi-likelihood under the independence model criterion (QIC)
for Generalized Estimating Equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QIC(object, ..., typeR = FALSE)
QICu(object, ..., typeR = FALSE)
quasiLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QIC_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>"gee"</code>, <code>"geepack"</code>, 
<code>"geem"</code>, <code>"wgee"</code>,  or <code>"yags"</code>.</p>
</td></tr>
<tr><td><code id="QIC_+3A_...">...</code></td>
<td>
<p> for QIC and QIC<code class="reqn">_{u}</code>, optionally more fitted model objects. </p>
</td></tr>  
<tr><td><code id="QIC_+3A_typer">typeR</code></td>
<td>
<p> logical, whether to calculate QIC(R). QIC(R) is
based on quasi-likelihood of a working correlation <code class="reqn">R</code> model. Defaults
to <code>FALSE</code>, and QIC(I) based on independence model is returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If just one object is provided, returns a numeric value with the
corresponding QIC; if more than one object are provided, returns a
<code>data.frame</code> with rows corresponding to the objects and one column
representing QIC or QIC<code class="reqn">_{u}</code>.
</p>


<h3>Note</h3>

<p>This implementation is based partly on (revised) code from packages <span class="pkg">yags</span>
(R-Forge) and <span class="pkg">ape</span>.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Pan, W. 2001 Akaike's Information Criterion in Generalized Estimating Equations.
<em>Biometrics</em> <b>57</b>, 120&ndash;125
</p>
<p>Hardin J. W., Hilbe, J. M. 2003 <em>Generalized Estimating Equations</em>.
Chapman &amp; Hall/CRC
</p>


<h3>See Also</h3>

<p>Methods exist for 
<code><a href="gee.html#topic+gee">gee</a></code> (package <span class="pkg">gee</span>),
<code><a href="geepack.html#topic+geeglm">geeglm</a></code> (<span class="pkg">geepack</span>), 
<code><a href="geeM.html#topic+geem">geem</a></code> (<span class="pkg">geeM</span>), 
<code><a href="wgeesel.html#topic+wgee">wgee</a></code> (<span class="pkg">wgeesel</span>, the package's <code>QIC.gee</code> function is used), 
and
<code>yags</code> (<span class="pkg">yags</span> on R-Forge).
There is also a <code>QIC</code> function in packages <span class="pkg">MESS</span> and <span class="pkg">geepack</span>, 
returning some extra information (such as CIC and QICc). <code>yags</code> and 
<code><a href="ape.html#topic+compar.gee">compar.gee</a></code> from package <span class="pkg">ape</span> both provide QIC values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(ohio)

fm1 &lt;- geeglm(resp ~ age * smoke, id = id, data = ohio,
    family = binomial, corstr = "exchangeable", scale.fix = TRUE)
fm2 &lt;- update(fm1, corstr = "ar1")
fm3 &lt;- update(fm1, corstr = "unstructured")

# QIC function is also defined in 'geepack' but is returns a vector[6], so
# cannot be used as 'rank'. Either use `MuMIn::QIC` syntax or make a wrapper
# around `geepack::QIC`

QIC &lt;- MuMIn::QIC
## Not run: 
QIC &lt;- function(x) geepack::QIC(x)[1]

## End(Not run)

model.sel(fm1, fm2, fm3, rank = QIC)

#####
library(geepack)
library(MuMIn)

## Not run: 
# same result:
    dredge(fm1, m.lim = c(3, NA), rank = QIC, varying = list(
    corstr = list("exchangeable", "unstructured", "ar1")
    ))      

## End(Not run)


</code></pre>

<hr>
<h2 id='r.squaredGLMM'>Pseudo-R-squared for Generalized Mixed-Effect models</h2><span id='topic+r.squaredGLMM'></span><span id='topic+r.squaredGLMM.merMod'></span>

<h3>Description</h3>

<p>Calculate conditional and marginal coefficient of determination for 
Generalized mixed-effect models (<code class="reqn">R_{GLMM}^{2}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.squaredGLMM(object, null, ...)
## S3 method for class 'merMod'
r.squaredGLMM(object, null, envir = parent.frame(), pj2014 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r.squaredGLMM_+3A_object">object</code></td>
<td>
<p>a fitted linear model object. </p>
</td></tr>
<tr><td><code id="r.squaredGLMM_+3A_null">null</code></td>
<td>
<p>optionally, a null model, including only random effects. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="r.squaredGLMM_+3A_envir">envir</code></td>
<td>
<p>optionally, the <code>environment</code> in which the null model is to be evaluated.
Defaults to the current frame. See <code><a href="base.html#topic+eval">eval</a></code>. </p>
</td></tr>
<tr><td><code id="r.squaredGLMM_+3A_pj2014">pj2014</code></td>
<td>
<p>logical, if <code>TRUE</code> and <code>object</code> is of <code>poisson</code> 
family, the result will include <code class="reqn">R_{GLMM}^{2}</code> using original formulation of 
Johnson (2014). This requires fitting <code>object</code> with an observation-level
random effect term added. </p>
</td></tr>
<tr><td><code id="r.squaredGLMM_+3A_...">...</code></td>
<td>
<p>additional arguments, ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mixed-effects models, <code class="reqn">R_{GLMM}^{2}</code> comes in two types: marginal and conditional.
</p>
<p><em>Marginal <code class="reqn">R_{GLMM}^{2}</code></em> represents the variance explained by the fixed 
effects, and is defined as:
</p>
<p style="text-align: center;"><code class="reqn">R_{GLMM(m)}^{2}= \frac{\sigma_f^2}{\sigma_f^2 + \sigma_{\alpha}^2 + \sigma_{\varepsilon }^2}
</code>
</p>

<p><em>Conditional <code class="reqn">R_{GLMM}^{2}</code></em> is interpreted as a variance explained by the
entire model, including both fixed and random effects, and is calculated
according to the equation:
</p>
<p style="text-align: center;"><code class="reqn">R_{GLMM(c)}^{2}= \frac{\sigma_f^2 + \sigma_{\alpha}^2}{\sigma_f^2 + \sigma_{\alpha}^2 + \sigma_{\varepsilon }^2}
</code>
</p>

<p>where <code class="reqn">\sigma_f^2</code>
is the variance of the fixed effect components,
<code class="reqn">\sigma_{\alpha}</code> 
is the variance of the random effects, and  
<code class="reqn">\sigma_\epsilon^2</code>
is the &ldquo;observation-level&rdquo; variance.
</p>
<p>Three different methods are available for deriving the observation-level variance
<code class="reqn">\sigma_\varepsilon</code>: the delta method, lognormal approximation and using the
trigamma function.
The delta method can be used with for all distributions and link functions,
while lognormal approximation and trigamma function are limited to distributions
with logarithmic link. Trigamma-estimate is recommended whenever available.
Additionally, for binomial distributions, theoretical variances exist
specific for each link function distribution.
</p>
<p><em>Null model</em>. Calculation of the observation-level variance involves in 
some cases fitting a <em>null</em> model containing no fixed effects other than 
intercept, otherwise identical to the original model (including all the random 
effects). When using <code>r.squaredGLMM</code> for several models differing only in 
their fixed effects, in order to avoid redundant calculations, the null model 
object can be passed as the argument <code>null</code>.
Otherwise, a null model will be fitted <em>via</em> updating the original model.
This assumes that all the variables used in the original model call have the 
same values as when the model was fitted. The function warns about this when 
fitting the null model is required. This warnings can be disabled by setting  
<code>options(MuMIn.noUpdateWarning = TRUE)</code>. 
</p>


<h3>Value</h3>

<p><code>r.squaredGLMM</code> returns a two-column numeric <code>matrix</code>, each (possibly
named) row holding values for marginal and conditional <code class="reqn">R_{GLMM}^{2}</code>
calculated with different methods, such as &ldquo;delta&rdquo;,
&ldquo;log-normal&rdquo;, &ldquo;trigamma&rdquo;, or &ldquo;theoretical&rdquo; for models
of <code>binomial</code> family. 	
</p>


<h3>Note</h3>

<p><strong>Important</strong>: as of <span class="pkg">MuMIn</span> version 1.41.0, 
<code>r.squaredGLMM</code> returns a revised statistics based on Nakagawa et 
al. (2017) paper. The returned value's format also has changed (it is a 
<code>matrix</code> rather than a numeric vector as before). Pre-1.41.0 version of the
function calculated the &ldquo;theoretical&rdquo; <code class="reqn">R_{GLMM}^{2}</code> for <code>binomial</code>
models.
</p>
<p><code class="reqn">R_{GLMM}^{2}</code> can be calculated also for fixed-effect models. In
the simpliest case of <abbr><span class="acronym">OLS</span></abbr> it reduces to <code>var(fitted) /
(var(fitted) + deviance / 2)</code>. Unlike likelihood-ratio based <code class="reqn">R^{2}</code> for 
<abbr><span class="acronym">OLS</span></abbr>, value of this statistic differs from that of
the classical <code class="reqn">R^{2}</code>.
</p>
<p>Currently methods exist for classes: <code>merMod</code>, <code>lme</code>,
<code>glmmTMB</code>, <code>glmmADMB</code>, <code>glmmPQL</code>, <code>cpglm</code>(<code>m</code>) and
(<code>g</code>)<code>lm</code>.
</p>
<p>For families other than gaussian, Gamma, poisson, binomial and negative binomial,
the residual variance is obtained using <code><a href="insight.html#topic+get_variance">get_variance</a></code> 
from package <a href="https://cran.r-project.org/package=insight"><span class="pkg">insight</span></a>.
</p>
<p>See note in <code><a href="#topic+r.squaredLR">r.squaredLR</a></code> help page for comment on using <code class="reqn">R^{2}</code> in 
model selection.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń. This implementation is based on <span class="rlang"><b>R</b></span> code from 
&lsquo;Supporting Information&rsquo; for Nakagawa et al. (2014), 
(the extension for random-slopes) Johnson (2014), and includes developments from
Nakagawa et al. (2017).
</p>


<h3>References</h3>

<p>Nakagawa, S., Schielzeth, H. 2013 A general and simple method for obtaining
<code class="reqn">R^{2}</code> from Generalized Linear Mixed-effects Models. <em>Methods in
Ecology and Evolution</em> <b>4</b>, 133&ndash;142.
</p>
<p>Johnson, P. C. D. 2014 Extension of Nakagawa &amp; Schielzeth’s <code class="reqn">R_{GLMM}^{2}</code> to random 
slopes models. <em>Methods in Ecology and Evolution</em> <b>5</b>, 44&ndash;946.
</p>
<p>Nakagawa, S., Johnson, P. C. D., Schielzeth, H. 2017 The coefficient of
determination <code class="reqn">R^{2}</code> and intra-class correlation coefficient from generalized
linear mixed-effects models revisited and expanded.
<em>J. R. Soc. Interface</em> <b>14</b>, 20170213.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+summary.lm">summary.lm</a></code>, <code><a href="#topic+r.squaredLR">r.squaredLR</a></code>
</p>
<p><code><a href="performance.html#topic+r2">r2</a></code> from package <a href="https://cran.r-project.org/package=performance"><span class="pkg">performance</span></a> calculates
<code class="reqn">R_{GLMM}^{2}</code> also for variance at different levels, with optional confidence 
intervals. <a href="https://cran.r-project.org/package=r2glmm"><span class="pkg">r2glmm</span></a> has functions for <code class="reqn">R^{2}</code> and partial <code class="reqn">R^{2}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Orthodont, package = "nlme")

fm1 &lt;- lme(distance ~ Sex * age, ~ 1 | Subject, data = Orthodont)

fmnull &lt;- lme(distance ~ 1, ~ 1 | Subject, data = Orthodont)

r.squaredGLMM(fm1)
r.squaredGLMM(fm1, fmnull)
r.squaredGLMM(update(fm1, . ~ Sex), fmnull)

r.squaredLR(fm1)
r.squaredLR(fm1, null.RE = TRUE)
r.squaredLR(fm1, fmnull) # same result

## Not run: 
if(require(MASS)) {
    fm &lt;- glmmPQL(y ~ trt + I(week &gt; 2), random = ~ 1 | ID, 
        family = binomial, data = bacteria, verbose = FALSE)
    fmnull &lt;- update(fm, . ~ 1)
    r.squaredGLMM(fm)

    # Include R2GLMM (delta method estimates) in a model selection table:
    # Note the use of a common null model
    dredge(fm, extra = list(R2 = function(x) r.squaredGLMM(x, fmnull)["delta", ]))
    
}

## End(Not run)

</code></pre>

<hr>
<h2 id='r.squaredLR'>Likelihood-ratio based pseudo-R-squared</h2><span id='topic+r.squaredLR'></span><span id='topic+null.fit'></span>

<h3>Description</h3>

<p>Calculate a coefficient of determination based on the likelihood-ratio test
(<code class="reqn">R_{LR}^{2}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.squaredLR(object, null = NULL, null.RE = FALSE, ...)

null.fit(object, evaluate = FALSE, RE.keep = FALSE, envir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r.squaredLR_+3A_object">object</code></td>
<td>
<p>a fitted model object. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_null">null</code></td>
<td>
<p>a fitted <em>null</em> model. If not provided, <code>null.fit</code> will
be used to construct it. <code>null.fit</code>'s capabilities are limited to only 
a few model classes, for others the <em>null</em> model has to be specified
manually. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_null.re">null.RE</code></td>
<td>
<p> logical, should the null model contain random factors?  Only 
used if no <em>null</em> model is given, otherwise omitted, with a warning. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_evaluate">evaluate</code></td>
<td>
<p>if <code>TRUE</code> evaluate the fitted model object else return
the call. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_re.keep">RE.keep</code></td>
<td>
<p>if <code>TRUE</code>, the random effects of the original model are 
included. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_envir">envir</code></td>
<td>
<p>the environment in which the <em>null</em> model is to be
evaluated, defaults to the environment of the original model's formula. </p>
</td></tr>
<tr><td><code id="r.squaredLR_+3A_...">...</code></td>
<td>
<p>further arguments, of which only <code>x</code> would be used, to 
maintain compatibility with older versions (<code>x</code> has been replaced 
with <code>object</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic is is one of the several proposed pseudo-<code class="reqn">R^{2}</code>'s for
nonlinear regression models. It is based on an improvement from <em>null</em>
(intercept only) model to the fitted model, and calculated as
</p>
<p style="text-align: center;"><code class="reqn">
  R_{LR}^{2}=1-\exp(-\frac{2}{n}(\log\mathcal{L}(x)-\log\mathcal{L}(0)))
</code>
</p>

<p>where <code class="reqn">\log\mathcal{L}(x)</code> and <code class="reqn">\log\mathcal{L}(0)</code> are the log-likelihoods of the
fitted and the <em>null</em> model respectively.
<abbr><span class="acronym">ML</span></abbr> estimates are used if models have been 
fitted by <abbr><span class="acronym">RE</span></abbr>stricted <abbr><span class="acronym">ML</span></abbr> (by calling <code>logLik</code> with argument 
<code>REML = FALSE</code>). Note that the <em>null</em> model can include the random 
factors of the original model, in which case the statistic represents the 
&lsquo;variance explained&rsquo; by fixed effects.
</p>
<p>For <abbr><span class="acronym">OLS</span></abbr> models the value is consistent with classical <code class="reqn">R^{2}</code>. In some 
cases (e.g. in logistic regression), the maximum <code class="reqn">R_{LR}^{2}</code> is less than one. 
The modification proposed by Nagelkerke (1991) adjusts the <code class="reqn">R_{LR}^{2}</code> to achieve 
1 at its maximum:
<code class="reqn">\bar{R}^{2} = R_{LR}^{2} / \max(R_{LR}^{2})
</code>
where
<code class="reqn">\max(R_{LR}^{2}) = 1 - \exp(\frac{2}{n}\log\mathcal{L}(\textrm{0}))
</code>.
</p>
<p><code>null.fit</code> tries to guess the <em>null</em> model call, given the provided
fitted model object. This would be usually a <code>glm</code>. The function will give
an error for an unrecognised class.
</p>


<h3>Value</h3>

<p><code>r.squaredLR</code> returns a value of <code class="reqn">R_{LR}^{2}</code>, and the
attribute <code>"adj.r.squared"</code> gives the Nagelkerke's modified statistic.
Note that this is not the same as nor equivalent to the classical 
&lsquo;adjusted R squared&rsquo;.
</p>
<p><code>null.fit</code> returns the fitted <em>null</em> model object (if
<code>evaluate = TRUE</code>) or an unevaluated call to fit a <em>null</em> model.
</p>


<h3>Note</h3>

<p><code class="reqn">R^{2}</code> is a useful goodness-of-fit measure as it has the interpretation
of the proportion of the variance &lsquo;explained&rsquo;, but it performs poorly in
model selection, and is not suitable for use in the same way as the information
criteria.
</p>


<h3>References</h3>

<p>Cox, D. R. and Snell, E. J. 1989 <em>The analysis of binary data</em>, 2nd ed.
London, Chapman and Hall.
</p>
<p>Magee, L. 1990 <code class="reqn">R^{2}</code> measures based on Wald and likelihood ratio joint
significance tests. <em>Amer. Stat.</em> <b>44</b>, 250&ndash;253.
</p>
<p>Nagelkerke, N. J. D. 1991 A note on a general definition of the coefficient of
determination. <em>Biometrika</em> <b>78</b>, 691&ndash;692.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+summary.lm">summary.lm</a></code>, <code><a href="#topic+r.squaredGLMM">r.squaredGLMM</a></code>
</p>
<p><code><a href="performance.html#topic+r2">r2</a></code> from package <a href="https://CRAN.R-project.org/package=performance"><span class="pkg">performance</span></a> calculates
many different types of <code class="reqn">R^{2}</code>.
</p>

<hr>
<h2 id='stackingWeights'>Stacking model weights</h2><span id='topic+stackingWeights'></span>

<h3>Description</h3>

<p>Computes model weights based on a cross-validation-like procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackingWeights(object, ..., data, R, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackingWeights_+3A_object">object</code>, <code id="stackingWeights_+3A_...">...</code></td>
<td>
<p>two or more fitted <code><a href="stats.html#topic+glm">glm</a></code> objects, or a
<code>list</code> of such, or an <code><a href="#topic+model.avg">&quot;averaging&quot;</a></code> object.</p>
</td></tr>
<tr><td><code id="stackingWeights_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model, used for
fitting and prediction.</p>
</td></tr>
<tr><td><code id="stackingWeights_+3A_r">R</code></td>
<td>
<p>the number of replicates.</p>
</td></tr>
<tr><td><code id="stackingWeights_+3A_p">p</code></td>
<td>
<p>the proportion of the <code>data</code> to be used as training set.
Defaults to 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each model in a set is fitted to the training data: a subset of <code>p * N</code>
observations in <code>data</code>. From these models a prediction is produced on
the remaining part of <code>data</code> (the test
or hold-out data). These hold-out predictions are fitted to the hold-out
observations, by optimising the weights by which the models are combined. This
process is repeated <code>R</code> times, yielding a distribution of weights for each
model (which Smyth &amp; Wolpert (1998) referred to as an &lsquo;empirical Bayesian
estimate of posterior model probability&rsquo;). A mean or median of model weights for
each model is taken and re-scaled to sum to one.
</p>


<h3>Value</h3>

<p>A matrix with two rows, containing model weights
calculated using <code>mean</code> and <code>median</code>.
</p>


<h3>Note</h3>

<p>This approach requires a sample size of at least <code class="reqn">2\times</code> the number
of models.
</p>


<h3>Author(s)</h3>

<p>Carsten Dormann, Kamil Bartoń
</p>


<h3>References</h3>

<p>Wolpert, D. H. 1992 Stacked generalization. <em>Neural Networks</em> <strong>5</strong>, 241&ndash;259.
</p>
<p>Smyth, P. and Wolpert, D. 1998 <em>An Evaluation of Linearly Combining
Density Estimators via Stacking. Technical Report No. 98&ndash;25.</em> Information
and Computer Science Department, University of California, Irvine, CA.
</p>
<p>Dormann, C. et al. 2018 Model averaging in ecology: a review of Bayesian,
information-theoretic, and tactical approaches for predictive inference.
<em>Ecological Monographs</em> <strong>88</strong>, 485&ndash;504.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>
</p>
<p>Other model weights: 
<code><a href="#topic+BGWeights">BGWeights</a>()</code>,
<code><a href="#topic+bootWeights">bootWeights</a>()</code>,
<code><a href="#topic+cos2Weights">cos2Weights</a>()</code>,
<code><a href="#topic+jackknifeWeights">jackknifeWeights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulated Cement dataset to increase sample size for the training data 
fm0 &lt;- glm(y ~ X1 + X2 + X3 + X4, data = Cement, na.action = na.fail)
dat &lt;- as.data.frame(apply(Cement[, -1], 2, sample, 50, replace = TRUE))
dat$y &lt;- rnorm(nrow(dat), predict(fm0), sigma(fm0))

# global model fitted to training data:
fm &lt;- glm(y ~ X1 + X2 + X3 + X4, data = dat, na.action = na.fail)

# generate a list of *some* subsets of the global model
models &lt;- lapply(dredge(fm, evaluate = FALSE, fixed = "X1", m.lim = c(1, 3)), eval)

wts &lt;- stackingWeights(models, data = dat, R = 10)

ma &lt;- model.avg(models)
Weights(ma) &lt;- wts["mean", ]

predict(ma)

</code></pre>

<hr>
<h2 id='std.coef'>Standardized model coefficients</h2><span id='topic+std.coef'></span><span id='topic+beta.weights'></span><span id='topic+partial.sd'></span>

<h3>Description</h3>

<p>Standardize model coefficients by Standard Deviation or Partial Standard Deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
std.coef(x, partial.sd, ...)

partial.sd(x)

# Deprecated:
beta.weights(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std.coef_+3A_x">x</code>, <code id="std.coef_+3A_model">model</code></td>
<td>
<p>a fitted model object. </p>
</td></tr>
<tr><td><code id="std.coef_+3A_partial.sd">partial.sd</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, model coefficients are
multiplied by partial <abbr><span class="acronym">SD</span></abbr>, otherwise they are multiplied by the
ratio of the standard deviations of the independent variable and dependent
variable. </p>
</td></tr>
<tr><td><code id="std.coef_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+coefTable">coefTable</a></code>, e.g.
<code>dispersion</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardizing model coefficients has the same effect as centring and
scaling the input variables. &ldquo;Classical&rdquo; standardized coefficients
are calculated as 
<code class="reqn">\beta^{*}_i = \beta_i\frac{s_{X_{i}}}{s_{y}}
        </code>
, where
<code class="reqn">\beta</code> is the unstandardized coefficient, 
<code class="reqn">s_{X_{i}}</code>    
is the standard deviation of associated dependent variable 
<code class="reqn">X_i</code>  and
<code class="reqn">s_{y}</code>
is <abbr><span class="acronym">SD</span></abbr> of the response variable.
</p>
<p>If variables are intercorrelated, the standard deviation of
<code class="reqn">X_i</code>
used in computing the standardized coefficients 
<code class="reqn">\beta_i^{*}</code> should be
replaced by the partial standard deviation of 
<code class="reqn">X_i</code> which is adjusted for
the multiple correlation of 
<code class="reqn">X_i</code> with the other <code class="reqn">X</code> variables
included in the regression equation. The partial standard deviation is
calculated as 
<code class="reqn">s_{X_{i}}^{*}=s_{X_{i}} VIF(X_i)^{-0.5} (\frac{n-1}{n-p} )^{0.5}
        </code>, 
where <var>VIF</var> is the variance inflation factor,
<var>n</var> is the number of observations and <var>p</var>, the number of predictors in
the model. The coefficient is then transformed as 
<code class="reqn">\beta^{*}_i = \beta_i s_{X_{i}}^{*}
        </code>.
</p>


<h3>Value</h3>

<p>A matrix with at least two columns for the standardized coefficient estimate
and its standard error. Optionally, the third column holds degrees of freedom
associated with the coefficients.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń. Variance inflation factors calculation is based
on function <code>vif</code> from package <span class="pkg">car</span> written by Henric Nilsson and John
Fox.
</p>


<h3>References</h3>

<p>Cade, B.S. 2015 Model averaging and muddled multimodel inferences. 
<em>Ecology</em> <b>96</b>, 2370-2382.
</p>
<p>Afifi, A., May, S., Clark, V.A. 2011 <em>Practical Multivariate Analysis</em>,
Fifth Edition. CRC Press.
</p>
<p>Bring, J. 1994 How to standardize regression coefficients. <em>The American
Statistician</em> <b>48</b>, 209&ndash;213.
</p>


<h3>See Also</h3>

<p><code>partial.sd</code> can be used with <code><a href="#topic+stdize">stdize</a></code>.
</p>
<p><code><a href="stats.html#topic+coef">coef</a></code> or <code><a href="#topic+coeffs">coeffs</a></code> and <code><a href="#topic+coefTable">coefTable</a></code> for
unstandardized coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit model to original data:
fm  &lt;- lm(y ~ x1 + x2 + x3 + x4, data = GPA)

# Partial SD for the default formula:   y ~ x1 + x2 + x3 + x4
psd &lt;- partial.sd(lm(data = GPA))[-1] # remove first element for intercept

# Standardize data:
zGPA &lt;- stdize(GPA, scale = c(NA, psd), center = TRUE)
# Note: first element of 'scale' is set to NA to ignore the first column 'y'

# Coefficients of a model fitted to standardized data:
zapsmall(coefTable(stdizeFit(fm, newdata = zGPA)))
# Standardized coefficients of a model fitted to original data:
zapsmall(std.coef(fm, partial = TRUE))


# Standardizing nonlinear models:
fam &lt;- Gamma("inverse")
fmg &lt;- glm(log(y) ~ x1 + x2 + x3 + x4, data = GPA, family = fam)

psdg &lt;- partial.sd(fmg)
zGPA &lt;- stdize(GPA, scale = c(NA, psdg[-1]), center = FALSE)
fmgz &lt;- glm(log(y) ~ z.x1 + z.x2 + z.x3 + z.x4, zGPA, family = fam)

# Coefficients using standardized data:
coef(fmgz) # (intercept is unchanged because the variables haven't been
           #  centred)
# Standardized coefficients:
coef(fmg) * psdg

</code></pre>

<hr>
<h2 id='stdize'>Standardize data</h2><span id='topic+stdize'></span><span id='topic+stdize.default'></span><span id='topic+stdize.logical'></span><span id='topic+stdize.formula'></span><span id='topic+stdize.data.frame'></span><span id='topic+stdizeFit'></span>

<h3>Description</h3>

<p><code>stdize</code> standardizes variables by centring and scaling.
</p>
<p><code>stdizeFit</code> modifies a model call or existing model to use standardized 
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
stdize(x, center = TRUE, scale = TRUE, ...)

## S3 method for class 'logical'
stdize(x, binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = FALSE, ...)
## also for two-level factors

## S3 method for class 'data.frame'
stdize(x, binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = TRUE, omit.cols = NULL, source = NULL,
  prefix = TRUE, append = FALSE, ...)

## S3 method for class 'formula'
stdize(x, data = NULL, response = FALSE,
  binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = TRUE, omit.cols = NULL, prefix = TRUE,
  append = FALSE, ...)

stdizeFit(object, newdata, which = c("formula", "subset", "offset", "weights",
	"fixed", "random", "model"), evaluate = TRUE, quote = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdize_+3A_x">x</code></td>
<td>
<p>a numeric or logical vector, factor, numeric matrix, 
<code>data.frame</code> or a formula. </p>
</td></tr>
<tr><td><code id="stdize_+3A_center">center</code>, <code id="stdize_+3A_scale">scale</code></td>
<td>
<p> either a logical value or a logical or numeric vector
of length equal to the number of columns of <code>x</code> (see
&lsquo;Details&rsquo;). <code>scale</code> can be also a function to use for
scaling. 
</p>
</td></tr>
<tr><td><code id="stdize_+3A_binary">binary</code></td>
<td>
<p>specifies how binary variables (logical or two-level factors)
are scaled. Default is to <code>"center"</code> by subtracting the mean
assuming levels are equal to 0 and 1; use <code>"scale"</code> to
both centre and scale by <abbr><span class="acronym">SD</span></abbr>, <code>"binary"</code> to centre to 0 /
1, <code>"half"</code> to centre to -0.5 / 0.5, and <code>"omit"</code> to leave
binary variables unmodified.
This argument has precedence over <code>center</code> and <code>scale</code>, unless
it is set to <code>NA</code> (in which case binary variables are treated like
numeric variables).
</p>
</td></tr>
<tr><td><code id="stdize_+3A_source">source</code></td>
<td>
<p>a reference <code>data.frame</code>, being a result of previous  
<code>stdize</code>, from which <code>scale</code> and <code>center</code> values are 
taken. Column names are matched. This can be used for scaling new data 
using statistics of another data.  
</p>
</td></tr>
<tr><td><code id="stdize_+3A_omit.cols">omit.cols</code></td>
<td>
<p> column names or numeric indices of columns that should 
be left unaltered. </p>
</td></tr>
<tr><td><code id="stdize_+3A_prefix">prefix</code></td>
<td>
<p> either a logical value specifying whether the names of
transformed columns should be prefixed, or a two-element character vector
giving the prefixes. The prefixes default to &ldquo;z.&rdquo; for scaled and
&ldquo;c.&rdquo; for centred variables. </p>
</td></tr>
<tr><td><code id="stdize_+3A_append">append</code></td>
<td>
<p> logical, if <code>TRUE</code>, modified columns are appended to the
original data frame. </p>
</td></tr>
<tr><td><code id="stdize_+3A_response">response</code></td>
<td>
<p>logical, stating whether the response should be standardized. By
default, only variables on the right-hand side of the formula are standardized. </p>
</td></tr>
<tr><td><code id="stdize_+3A_data">data</code></td>
<td>
<p> an object coercible to <code>data.frame</code>, containing the
variables in <code>formula</code>. Passed to, and used by <code><a href="stats.html#topic+model.frame">model.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="stdize_+3A_newdata">newdata</code></td>
<td>
<p>a <code>data.frame</code> returned by <code>stdize</code>, to be used 
by the modified model.</p>
</td></tr>
<tr><td><code id="stdize_+3A_...">...</code></td>
<td>
<p> for the <code>formula</code> method, additional arguments passed to
<code><a href="stats.html#topic+model.frame">model.frame</a></code>. For other methods, it is silently ignored. </p>
</td></tr>
<tr><td><code id="stdize_+3A_object">object</code></td>
<td>
<p>a fitted model object or an expression being a <code>call</code> to
the modelling function. </p>
</td></tr>
<tr><td><code id="stdize_+3A_which">which</code></td>
<td>
<p> a character string naming arguments which should be modified.
This should be all arguments which are evaluated in the <code>data</code>
environment. Can be also <code>TRUE</code> to modify the expression as a
whole. The <code>data</code> argument is additionally replaced with that
passed to <code>stdizeFit</code>.
</p>
</td></tr>
<tr><td><code id="stdize_+3A_evaluate">evaluate</code></td>
<td>
<p> if <code>TRUE</code>, the modified call is evaluated and the
fitted model object is returned. </p>
</td></tr>
<tr><td><code id="stdize_+3A_quote">quote</code></td>
<td>
<p> if <code>TRUE</code>, avoids evaluating <code>object</code>. Equivalent to
<code>stdizeFit(quote(expr), ...)</code>. Defaults to <code>NA</code> in which case
<code>object</code> being a call to non-primitive function is quoted. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdize</code> resembles <code><a href="base.html#topic+scale">scale</a></code>, but uses special rules
for factors, similarly to <code><a href="arm.html#topic+standardize">standardize</a></code> in package <span class="pkg">arm</span>.
</p>
<p><code>stdize</code> differs from <code><a href="arm.html#topic+standardize">standardize</a></code> in that it is used on
data rather than on the fitted model object. The scaled data should afterwards
be passed to the modelling function, instead of the original data.
</p>
<p>Unlike <code>standardize</code>, it applies special &lsquo;binary&rsquo; scaling only to
two-level <code>factor</code>s and logical variables, rather than to any variable with
two unique values.
</p>
<p>Variables of only one unique value are unchanged.
</p>
<p>By default, <code>stdize</code> scales by dividing by standard deviation rather than twice
the <abbr><span class="acronym">SD</span></abbr> as <code>standardize</code> does. Scaling by <abbr><span class="acronym">SD</span></abbr> is used 
also on uncentred values, which is different from <code><a href="base.html#topic+scale">scale</a></code> where
root-mean-square is used.
</p>
<p>If <code>center</code> or <code>scale</code> are logical scalars or vectors of length equal
to the number of columns of <code>x</code>, the centring is done by subtracting the
mean (if <code>center</code> corresponding to the column is <code>TRUE</code>), and scaling
is done by dividing the (centred) value by standard deviation (if corresponding
<code>scale</code> is <code>TRUE</code>). 
If <code>center</code> or <code>scale</code> are numeric vectors with length equal 
to the number of columns of <code>x</code> (or numeric scalars for vector methods),
then these are used instead. Any <code>NA</code>s in the numeric vector result in no
centring or scaling on the corresponding column.
</p>
<p>Note that <code>scale = 0</code> is equivalent to no scaling (i.e. <code>scale = 1</code>).
</p>
<p>Binary variables, logical or factors with two levels, are converted to
numeric variables and transformed according to the argument <code>binary</code>,
unless <code>center</code> or <code>scale</code> are explicitly given.
</p>


<h3>Value</h3>

<p><code>stdize</code> returns a vector or object of the same dimensions as <code>x</code>,
where the values are centred and/or scaled. Transformation is carried out
column-wise in <code>data.frame</code>s and matrices. 
</p>
<p>The returned value is compatible with that of <code><a href="base.html#topic+scale">scale</a></code> in that the
numeric centring and scalings used are stored in attributes
<code>"scaled:center"</code> and <code>"scaled:scale"</code> (these can be <code>NA</code> if no
centring or scaling has been done).
</p>
<p><code>stdizeFit</code> returns a modified, fitted model object that uses transformed 
variables from <code>newdata</code>, or, if <code>evaluate</code> is <code>FALSE</code>, an 
unevaluated call where the variable names are replaced to point the transformed 
variables.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Gelman, A. 2008 Scaling regression inputs by dividing by two standard 
deviations. <em>Statistics in medicine</em> <b>27</b>, 2865&ndash;2873.
</p>


<h3>See Also</h3>

<p>Compare with <code><a href="base.html#topic+scale">scale</a></code> and <code><a href="arm.html#topic+standardize">standardize</a></code> or
<code><a href="arm.html#topic+rescale">rescale</a></code> (the latter two in package <span class="pkg">arm</span>).
</p>
<p>For typical standardizing, model coefficients transformation may be
easier, see <code><a href="#topic+std.coef">std.coef</a></code>.
</p>
<p><code><a href="base.html#topic+apply">apply</a></code> and <code><a href="base.html#topic+sweep">sweep</a></code> for arbitrary transformations of 
columns in a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare "stdize" and "scale"
nmat &lt;- matrix(runif(15, 0, 10), ncol = 3)

stdize(nmat)
scale(nmat)

rootmeansq &lt;- function(v) {
    v &lt;- v[!is.na(v)]
    sqrt(sum(v^2) / max(1, length(v) - 1L))
}

scale(nmat, center = FALSE)
stdize(nmat, center = FALSE, scale = rootmeansq)

if(require(lme4)) {
# define scale function as twice the SD to reproduce "arm::standardize"
twosd &lt;- function(v) 2 * sd(v, na.rm = TRUE)

# standardize data (scaled variables are prefixed with "z.")
z.CO2 &lt;- stdize(uptake ~ conc + Plant, data = CO2, omit = "Plant", scale = twosd)
summary(z.CO2)


fmz &lt;- stdizeFit(lmer(uptake ~ conc + I(conc^2) + (1 | Plant)), newdata = z.CO2)
# produces:
# lmer(uptake ~ z.conc + I(z.conc^2) + (1 | Plant), data = z.CO2)


## standardize using scale and center from "z.CO2", keeping the original data:
z.CO2a &lt;- stdize(CO2, source = z.CO2, append = TRUE)
# Here, the "subset" expression uses untransformed variable, so we modify only
# "formula" argument, keeping "subset" as-is. For that reason we needed the
# untransformed variables in "newdata".
stdizeFit(lmer(uptake ~ conc + I(conc^2) + (1 | Plant),
    subset = conc &gt; 100,
    ), newdata = z.CO2a, which = "formula", evaluate = FALSE)


# create new data as a sequence along "conc"
newdata &lt;-  data.frame(conc = seq(min(CO2$conc), max(CO2$conc), length = 10))

# scale new data using scale and center of the original scaled data: 
z.newdata &lt;- stdize(newdata, source = z.CO2)


# plot predictions against "conc" on real scale:
plot(newdata$conc, predict(fmz, z.newdata, re.form = NA))


# compare with "arm::standardize"
## Not run: 
library(arm)
fms &lt;- standardize(lmer(uptake ~ conc + I(conc^2) + (1 | Plant), data = CO2))
plot(newdata$conc, predict(fms, z.newdata, re.form = NA))

## End(Not run)
}

</code></pre>

<hr>
<h2 id='subset.model.selection'>Subsetting model selection table</h2><span id='topic+subset.model.selection'></span><span id='topic++5B.model.selection'></span><span id='topic++5B+5B.model.selection'></span><span id='topic+has'></span>

<h3>Description</h3>

<p>Extract a subset of a model selection table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.selection'
subset(x, subset, select, recalc.weights = TRUE, recalc.delta = FALSE, ...)
## S3 method for class 'model.selection'
x[i, j, recalc.weights = TRUE, recalc.delta = FALSE, ...]
## S3 method for class 'model.selection'
x[[..., exact = TRUE]] 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.model.selection_+3A_x">x</code></td>
<td>
<p>a <code>model.selection</code> object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_subset">subset</code>, <code id="subset.model.selection_+3A_select">select</code></td>
<td>
<p>logical expressions indicating columns and rows to keep.
See <code><a href="base.html#topic+subset">subset</a></code>. </p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_i">i</code>, <code id="subset.model.selection_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract. </p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_recalc.weights">recalc.weights</code></td>
<td>
<p>logical value specyfying whether Akaike weights
should be normalized across the new set of models to sum to one.
</p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_recalc.delta">recalc.delta</code></td>
<td>
<p>logical value specyfying whether 
Δ_IC
should be calculated for the new set of models (not done by default).
</p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_exact">exact</code></td>
<td>
<p>logical, see <code><a href="base.html#topic+Extract">[</a></code>.</p>
</td></tr>
<tr><td><code id="subset.model.selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> 
(<code>drop</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the method for <code>data.frame</code>, single bracket extraction with only 
one index <code>x[i]</code> selects rows (models) rather than columns.
</p>
<p>To select rows according to presence or absence of the variables (rather than
their value), a pseudo-function <code>has</code> may be used with <code>subset</code>, e.g.
<code>subset(x, has(a, !b))</code>
will select rows  with <em>a</em> <b>and</b> without <em>b</em> (this is
equivalent to <code>!is.na(a) &amp; is.na(b)</code>). <code>has</code> can take any number of
arguments.
</p>
<p>Complex model terms need to be enclosed within curly brackets 
(e.g <code>{s(a,k=2)}</code>), except for within <code>has</code>. Backticks-quoting is 
also possible, but then the name must match exactly (including whitespace) 
the term name as returned by <code>getAllTerms</code>.
</p>
<p>Enclosing in <code>I</code> prevents the name from being interpreted as a column name.
</p>
<p>To select rows where one variable can be present conditional on the presence of 
other variables, the function <code>dc</code> (<b>d</b>ependency <b>c</b>hain) can 
be used. 
<code>dc</code> takes any number of variables as arguments, and allows a variable to be 
included only if all the preceding arguments are also included (e.g. <code>subset = 
dc(a, b, c)</code> allows for models of form <code>a</code>, <code>a+b</code> and <code>a+b+c</code> but not 
<code>b</code>, <code>c</code>, <code>b+c</code> or <code>a+c</code>).
</p>


<h3>Value</h3>

<p>A <code>model.selection</code> object containing only the selected models (rows).
If columns are selected (<em>via</em> argument <code>select</code> or the second index 
<code>x[, j]</code>) and not all essential columns (i.e. all except 
&quot;varying&quot; and &quot;extra&quot;) are present in the result, a plain <code>data.frame</code> is 
returned. Similarly, modifying values in the essential columns with <code>[&lt;-</code>, 
<code>[[&lt;-</code> or <code>$&lt;-</code> produces a regular data frame. 
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="base.html#topic+subset">subset</a></code> and <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> for
subsetting and extracting from <code>data.frame</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lm(formula = y ~ X1 + X2 + X3 + X4, data = Cement, na.action = na.fail)

# generate models where each variable is included only if the previous
# are included too, e.g. X2 only if X1 is there, and X3 only if X2 and X1
dredge(fm1, subset = dc(X1, X2, X3, X4))

# which is equivalent to
# dredge(fm1, subset = (!X2 | X1) &amp; (!X3 | X2) &amp; (!X4 | X3))

# alternatively, generate "all possible" combinations
ms0 &lt;- dredge(fm1)
# ...and afterwards select the subset of models
subset(ms0, dc(X1, X2, X3, X4))
# which is equivalent to
# subset(ms0, (has(!X2) | has(X1)) &amp; (has(!X3) | has(X2)) &amp; (has(!X4) | has(X3)))

# Different ways of finding a confidence set of models:
# delta(AIC) cutoff
subset(ms0, delta &lt;= 4, recalc.weights = FALSE)
# cumulative sum of Akaike weights
subset(ms0, cumsum(weight) &lt;= .95, recalc.weights = FALSE)
# relative likelihood
subset(ms0, (weight / weight[1]) &gt; (1/8), recalc.weights = FALSE)
</code></pre>

<hr>
<h2 id='sw'>Per-variable sum of model weights</h2><span id='topic+importance'></span><span id='topic+sum.of.weights'></span><span id='topic+sw'></span>

<h3>Description</h3>

<p>Sum of model weights over all models including each explanatory variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sw(x)
importance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sw_+3A_x">x</code></td>
<td>
<p>either a list of fitted model objects, or a <code>"model.selection"</code>
or <code>"averaging"</code> object. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector of so called relative importance values, for each 
predictor variable.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+Weights">Weights</a></code>
</p>
<p><code><a href="#topic+dredge">dredge</a></code>, <code><a href="#topic+model.avg">model.avg</a></code>, <code><a href="#topic+model.sel">model.sel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some models
fm1 &lt;- lm(y ~ ., data = Cement, na.action = na.fail)
ms1 &lt;- dredge(fm1)

# Sum of weights can be calculated/extracted from various objects:
sw(ms1)
## Not run: 
sw(subset(model.sel(ms1), delta &lt;= 4))
sw(model.avg(ms1, subset = delta &lt;= 4))
sw(subset(ms1, delta &lt;= 4))
sw(get.models(ms1, delta &lt;= 4))

## End(Not run)

# Re-evaluate SW according to BIC
# note that re-ranking involves fitting the models again

# 'nobs' is not used here for backwards compatibility
lognobs &lt;- log(length(resid(fm1)))

sw(subset(model.sel(ms1, rank = AIC, rank.args = list(k = lognobs)),
    cumsum(weight) &lt;= .95))

# This gives a different result than previous command, because 'subset' is
# applied to the original selection table that is ranked with 'AICc'
sw(model.avg(ms1, rank = AIC, rank.args = list(k = lognobs),
    subset = cumsum(weight) &lt;= .95))

</code></pre>

<hr>
<h2 id='updateable'>Make a function return updateable result</h2><span id='topic+updateable'></span><span id='topic+updateable2'></span><span id='topic+get_call'></span><span id='topic+uGamm'></span><span id='topic+MuMIn-gamm'></span><span id='topic+gamm-wrapper'></span>

<h3>Description</h3>

<p>Creates a function wrapper that stores a call in the object returned by its
argument <code>FUN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateable(FUN, eval.args = NULL, Class)

get_call(x)

## updateable wrapper for mgcv::gamm and gamm4::gamm4
uGamm(formula, random = NULL, ..., lme4 = inherits(random, "formula"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateable_+3A_fun">FUN</code></td>
<td>
<p>function to be modified, found <em>via</em> <code><a href="base.html#topic+match.fun">match.fun</a></code>. </p>
</td></tr>
<tr><td><code id="updateable_+3A_eval.args">eval.args</code></td>
<td>
<p>optionally a character vector of function arguments' names
to be evaluated in the stored call. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="updateable_+3A_class">Class</code></td>
<td>
<p>optional character vector naming class(es) to be set onto the
result of <code>FUN</code> (not possible with formal S4 objects). </p>
</td></tr>
<tr><td><code id="updateable_+3A_x">x</code></td>
<td>
<p>an object from which the call should be extracted. </p>
</td></tr>
<tr><td><code id="updateable_+3A_formula">formula</code>, <code id="updateable_+3A_random">random</code>, <code id="updateable_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>gamm</code> or <code>gamm4</code></p>
</td></tr>
<tr><td><code id="updateable_+3A_lme4">lme4</code></td>
<td>
<p>if <code>TRUE</code>, <code>gamm4</code> is called, <code>gamm</code> otherwise. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most model fitting functions in <span class="rlang"><b>R</b></span> return an object that can be updated or
re-fitted <em>via</em> <code><a href="stats.html#topic+update">update</a></code>. This is thanks to the <code>call</code>
stored in the object, which can be used (possibly modified) later on. It is
also utilised by <code>dredge</code> to generate sub-models. Some functions (such
as <code>gamm</code> or <code>MCMCglmm</code>) do not provide their result with the
<code>call</code> element. To work that around, <code>updateable</code> can be used on
that function to store the call. The resulting &ldquo;wrapper&rdquo; should be
used in exactly the same way as the original function.
</p>
<p><code>updateable</code> can also be used to repair an existing <code>call</code> element,
e.g. if it contains <a href="base.html#topic+dots">dotted names</a> that prevent re-evaluation
of such a call.
</p>
<p>Argument <code>eval.args</code> specifies names of function arguments that should
be evaluated in the stored call. This is useful when, for example, the model
object does not have <code>formula</code> element. The default <code>formula</code> 
method tries to retrieve formula from the stored <code>call</code>,
which works unless the formula has been given as a variable and value of
that variable changed since the model was fitted (the last &lsquo;example&rsquo;
demonstrates this).
</p>


<h3>Value</h3>

<p><code>updateable</code> returns a function with the same arguments as <code>FUN</code>, 
wrapping a call to  <code>FUN</code> and adding an element named <code>call</code> to its
result if possible, otherwise an attribute <code>"call"</code> (if the returned 
value is atomic or a formal S4 object).
</p>


<h3>Note</h3>

<p><code>get_call</code> is similar to <code><a href="stats.html#topic+getCall">getCall</a></code> (defined in package 
<span class="pkg">stats</span>), but it can also extract the <code>call</code> when it is an 
<code><a href="base.html#topic+attr">attribute</a></code> (and not an element of the object). Because the
default <code>getCall</code> method cannot do that, the default <code>update</code> method
will not work with atomic or S4 objects resulting from <code>updateable</code> 
wrappers.
</p>
<p><code>uGamm</code> sets also an appropriate class onto the result (<code>"gamm4"</code>
and/or <code>"gamm"</code>), which is needed for some generics defined in <span class="pkg">MuMIn</span>
to work (note that unlike the functions created by <code>updateable</code> it has no
formal arguments of the original function). As of version 1.9.2,
<code>MuMIn::gamm</code> is no longer available.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update">update</a></code>, <code><a href="stats.html#topic+getCall">getCall</a></code>, <code><a href="base.html#topic+getElement">getElement</a></code>,
<code><a href="base.html#topic+attributes">attributes</a></code>
</p>
<p><code><a href="mgcv.html#topic+gamm">gamm</a></code>, <code><a href="gamm4.html#topic+gamm4">gamm4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple example with cor.test:

# From example(cor.test)
x &lt;- c(44.4, 45.9, 41.9, 53.3, 44.7, 44.1, 50.7, 45.2, 60.1)
y &lt;- c( 2.6,  3.1,  2.5,  5.0,  3.6,  4.0,  5.2,  2.8,  3.8)

ct1 &lt;- cor.test(x, y, method = "kendall", alternative = "greater")

uCor.test &lt;- updateable(cor.test)

ct2 &lt;- uCor.test(x, y, method = "kendall", alternative = "greater")

getCall(ct1) # --&gt; NULL
getCall(ct2)

#update(ct1, method = "pearson") --&gt; Error
update(ct2, method = "pearson")
update(ct2, alternative = "two.sided")


## predefined wrapper for 'gamm':

set.seed(0)
dat &lt;- gamSim(6, n = 100, scale = 5, dist = "normal")

fmm1 &lt;- uGamm(y ~s(x0)+ s(x3) + s(x2), family = gaussian, data = dat, 
    random = list(fac = ~1))

getCall(fmm1)
class(fmm1)

###

## Not run: 
library(caper)
data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species)

fm1 &lt;- crunch(Egg.Mass ~ F.Mass * M.Mass, data = shorebird)

uCrunch &lt;- updateable(crunch)

fm2 &lt;- uCrunch(Egg.Mass ~ F.Mass * M.Mass, data = shorebird)

getCall(fm1)
getCall(fm2)
update(fm2) # Error with 'fm1'
dredge(fm2)

## End(Not run)

###
## Not run: 
# "lmekin" does not store "formula" element 
library(coxme)
uLmekin &lt;- updateable(lmekin, eval.args = "formula")

f &lt;- effort ~ Type + (1|Subject)
fm1 &lt;- lmekin(f, data = ergoStool)
fm2 &lt;- uLmekin(f, data = ergoStool)

f &lt;- wrong ~ formula # reassigning "f"

getCall(fm1) # formula is "f"
getCall(fm2) 

formula(fm1) # returns the current value of "f" 
formula(fm2)

## End(Not run)
</code></pre>

<hr>
<h2 id='Weights'>Akaike weights</h2><span id='topic+Weights'></span><span id='topic+Weights+3C-'></span>

<h3>Description</h3>

<p>Calculate, extract or set normalized model likelihoods (&lsquo;Akaike weights&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Weights(x)
Weights(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Weights_+3A_x">x</code></td>
<td>
<p>a numeric vector of information criterion values such as AIC, or
objects returned by functions like <code>AIC</code>. There are also methods for
extracting &lsquo;Akaike weights&rsquo; from <code>"model.selection"</code> or 
<code>"averaging"</code> objects. </p>
</td></tr>
<tr><td><code id="Weights_+3A_value">value</code></td>
<td>
<p>numeric, the new weights for the <code>"averaging"</code> object or
<code>NULL</code> to reset the weights based on the original IC used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The replacement function can assign new weights to an <code>"averaging"</code>
object, affecting coefficient values and order of component models.
</p>


<h3>Value</h3>

<p>For the extractor, a numeric vector of normalized likelihoods.
</p>


<h3>Note</h3>

<p>On assigning new weights, the model order changes accordingly, so assigning
the same weights again will cause incorrect re-calculation of averaged
coefficients. To avoid that, either re-set model weights by assigning <code>NULL</code>,
or use ordered weights.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code><a href="#topic+sw">sw</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>
</p>
<p><code><a href="#topic+armWeights">armWeights</a></code>, 
<code><a href="#topic+bootWeights">bootWeights</a></code>, <code><a href="#topic+BGWeights">BGWeights</a></code>, <code><a href="#topic+cos2Weights">cos2Weights</a></code>,
<code><a href="#topic+jackknifeWeights">jackknifeWeights</a></code> and <code><a href="#topic+stackingWeights">stackingWeights</a></code> can be used to
produce model weights.
</p>
<p><code><a href="stats.html#topic+weights">weights</a></code>, which extracts fitting weights from model objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- glm(Prop ~ dose, data = Beetle, family = binomial)
fm2 &lt;- update(fm1, . ~ . + I(dose^2))
fm3 &lt;- update(fm1, . ~ log(dose))
fm4 &lt;- update(fm3, . ~ . + I(log(dose)^2))

round(Weights(AICc(fm1, fm2, fm3, fm4)), 3)


am &lt;- model.avg(fm1, fm2, fm3, fm4, rank = AICc)

coef(am)

# Assign equal weights to all models:
Weights(am) &lt;- rep(1, 4) # assigned weights are rescaled to sum to 1
Weights(am)
coef(am)

# Assign dummy weights:
wts &lt;- c(2,1,4,3)
Weights(am) &lt;- wts
coef(am)
# Component models are now sorted according to the new weights.
# The same weights assigned again produce incorrect results!
Weights(am) &lt;- wts
coef(am) # wrong!
#
Weights(am) &lt;- NULL # reset to original model weights
Weights(am) &lt;- wts 
coef(am) # correct

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
