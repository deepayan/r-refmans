<!DOCTYPE html><html><head><title>Help for package RestoreNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RestoreNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BhattDist'><p>Bhattacharyya distance</p></a></li>
<li><a href='#compile.h'><p>Generate hazard function</p></a></li>
<li><a href='#condAIC'><p>Conditional AIC (cAIC)</p></a></li>
<li><a href='#dBu'><p>Gradient of <code class="reqn">E[u \vert \theta]</code></p></a></li>
<li><a href='#dD2'><p>Gradient of <code class="reqn">V[u \vert \theta]</code></p></a></li>
<li><a href='#dmvNorm'><p>Multivariate Normal density function</p></a></li>
<li><a href='#fit.null'><p>Fit the base (null) model</p></a></li>
<li><a href='#fit.re'><p>Fit the random-effects model</p></a></li>
<li><a href='#get.boxplots'><p>Clonal boxplots</p></a></li>
<li><a href='#get.dx'><p>Time-adjacent increments of the cell counts</p></a></li>
<li><a href='#get.gnl'><p>Gradient of the negative log-likelihood of the base (null) model</p></a></li>
<li><a href='#get.M'><p>Design matrix M</p></a></li>
<li><a href='#get.nl'><p>Negative log-likelihood of the base (null) model</p></a></li>
<li><a href='#get.rescaled'><p>Rescaling a clonal tracking dataset</p></a></li>
<li><a href='#get.scatterpie'><p>Clonal pie-chart</p></a></li>
<li><a href='#get.sim.tl'><p><code class="reqn">\tau</code>-leaping simulation algorithm</p></a></li>
<li><a href='#get.V'><p>Net-effect matrix</p></a></li>
<li><a href='#get.W'><p>Stochastic covariance matrix W</p></a></li>
<li><a href='#KLDiv'><p>Kullback-Leibler divergence</p></a></li>
<li><a href='#ldet'><p>Matrix determinant</p></a></li>
<li><a href='#ngQ'><p>Gradient of the E-step function Q</p></a></li>
<li><a href='#norm2'><p>Euclidean 2-norm</p></a></li>
<li><a href='#nQ'><p>E-step function Q</p></a></li>
<li><a href='#nullModelFitting'><p>Fit base model</p></a></li>
<li><a href='#ny_u'><p>Conditional negative log-likelihood</p></a></li>
<li><a href='#relErr'><p>Multivariate relative error</p></a></li>
<li><a href='#rmvNorm'><p>Random generator from a Multivariate Normal distribution</p></a></li>
<li><a href='#rndEffModelFitting'><p>Fit random-effects model</p></a></li>
<li><a href='#rndEffModelStats'><p>Base and random-effects model statistics</p></a></li>
<li><a href='#tr'><p>Matrix trace</p></a></li>
<li><a href='#VEuy'><p><code class="reqn">E[u \vert y]</code> and <code class="reqn">V[u \vert y]</code></p></a></li>
<li><a href='#Y_RM'><p>Rhesus Macaque clonal tracking dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Random-Effects Stochastic Reaction Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A random-effects stochastic model that allows quick detection of 
  clonal dominance events from clonal tracking data collected in gene therapy studies. Starting from the Ito-type equation describing the dynamics of cells duplication, death and differentiation at clonal level, we first considered its local linear approximation as the base model. 
  The parameters of the base model, which are inferred using a maximum likelihood approach, 
  are assumed to be shared across the clones. Although this assumption makes inference easier, 
  in some cases it can be too restrictive and does not take into account possible scenarios of clonal dominance. 
  Therefore we extended the base model by introducing random effects for the clones. 
  In this extended formulation the dynamic parameters are estimated using a tailor-made 
  expectation maximization algorithm. Further details on the methods can be found in L. Del Core et al., (2022) &lt;<a href="https://doi.org/10.1101%2F2022.05.31.494100">doi:10.1101/2022.05.31.494100</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3.9000</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, xtable, scales, stringr, ggplot2, scatterpie,
RColorBrewer</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 10:41:07 UTC; pmzld</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Del Core <a href="https://orcid.org/0000-0002-1672-6995"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Marco Grzegorczyk <a href="https://orcid.org/0000-0002-2604-9270"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths],
  Ernst Wit <a href="https://orcid.org/0000-0002-3671-9610"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Del Core &lt;l.del.core@rug.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BhattDist'>Bhattacharyya distance</h2><span id='topic+BhattDist'></span>

<h3>Description</h3>

<p>Bhattacharyya distance between P and Q for multivariate normal distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BhattDist(mu1, S1, mu2, S2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BhattDist_+3A_mu1">mu1</code></td>
<td>
<p>mean vector of P.</p>
</td></tr>
<tr><td><code id="BhattDist_+3A_s1">S1</code></td>
<td>
<p>covariance matrix of P.</p>
</td></tr>
<tr><td><code id="BhattDist_+3A_mu2">mu2</code></td>
<td>
<p>mean vector of Q.</p>
</td></tr>
<tr><td><code id="BhattDist_+3A_s2">S2</code></td>
<td>
<p>covariance matrix of Q.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bhattacharyya distance between P and Q.
</p>

<hr>
<h2 id='compile.h'>Generate hazard function</h2><span id='topic+compile.h'></span>

<h3>Description</h3>

<p>This function dynamically builds the function get.h() that will be used to get the hazard vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile.h(rct.lst, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile.h_+3A_rct.lst">rct.lst</code></td>
<td>
<p>list of biochemical reactions.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='condAIC'>Conditional AIC (cAIC)</h2><span id='topic+condAIC'></span>

<h3>Description</h3>

<p>Conditional AIC (cAIC) of the conditional log-likelihood <code class="reqn">l(y \vert u)</code> of y given the random effects u
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condAIC(X, Z, y, theta, Delta, V, VCNs, nObs, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condAIC_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="condAIC_+3A_z">Z</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="condAIC_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="condAIC_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="condAIC_+3A_delta">Delta</code></td>
<td>
<p>covariance matrix of the random effects u</p>
</td></tr>
<tr><td><code id="condAIC_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="condAIC_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="condAIC_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="condAIC_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of
the algorithm are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional AIC (cAIC) of the conditional log-likelihood <code class="reqn">l(y \vert u)</code> of y given the random effects u.
</p>

<hr>
<h2 id='dBu'>Gradient of <code class="reqn">E[u \vert \theta]</code></h2><span id='topic+dBu'></span>

<h3>Description</h3>

<p>Gradient of the expected values of the random effects u w.r.t. the free parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBu(K, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dBu_+3A_k">K</code></td>
<td>
<p>number of clones being analyzed.</p>
</td></tr>
<tr><td><code id="dBu_+3A_p">p</code></td>
<td>
<p>number of free parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-dimensional gradient of u.
</p>

<hr>
<h2 id='dD2'>Gradient of <code class="reqn">V[u \vert \theta]</code></h2><span id='topic+dD2'></span>

<h3>Description</h3>

<p>Gradient of the covariance matrix of the random effects u w.r.t. the free parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dD2(K, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dD2_+3A_k">K</code></td>
<td>
<p>number of clones being analyzed.</p>
</td></tr>
<tr><td><code id="dD2_+3A_p">p</code></td>
<td>
<p>number of free parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the gradient of the covariance matrix of u.
</p>

<hr>
<h2 id='dmvNorm'>Multivariate Normal density function</h2><span id='topic+dmvNorm'></span>

<h3>Description</h3>

<p>Proability density function of a n-variate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvNorm(x, Mu, Sigma, SigmaInv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvNorm_+3A_x">x</code></td>
<td>
<p>n-dimensional vector.</p>
</td></tr>
<tr><td><code id="dmvNorm_+3A_mu">Mu</code></td>
<td>
<p>n-dimensional mean vector.</p>
</td></tr>
<tr><td><code id="dmvNorm_+3A_sigma">Sigma</code></td>
<td>
<p>n-dimensional covariance matrix.</p>
</td></tr>
<tr><td><code id="dmvNorm_+3A_sigmainv">SigmaInv</code></td>
<td>
<p>n-dimensional precision matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability density of a n-variate normal distribution with mean vector Mu and covariance Sigma evaluated at x.
</p>

<hr>
<h2 id='fit.null'>Fit the base (null) model</h2><span id='topic+fit.null'></span>

<h3>Description</h3>

<p>This function builds the design matrix of the null model and returns the fitted values and the corresponding statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.null(
  Y,
  rct.lst,
  maxit = 10000,
  factr = 1e+07,
  pgtol = 1e-08,
  lmm = 100,
  trace = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.null_+3A_y">Y</code></td>
<td>
<p>A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
<tr><td><code id="fit.null_+3A_rct.lst">rct.lst</code></td>
<td>
<p>list of biochemical reactions.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;</p>
</td></tr>
<tr><td><code id="fit.null_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the optimization step.
This argument is passed to optim() function. Details on &quot;maxit&quot; can be found in &quot;optim()&quot; documentation page.</p>
</td></tr>
<tr><td><code id="fit.null_+3A_factr">factr</code></td>
<td>
<p>controls the convergence of the &quot;L-BFGS-B&quot; method.
Convergence occurs when the reduction in the objective is within this factor of the machine tolerance.
Default is 1e7, that is a tolerance of about 1e-8.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.null_+3A_pgtol">pgtol</code></td>
<td>
<p>helps control the convergence of the &quot;L-BFGS-B&quot; method.
It is a tolerance on the projected gradient in the current search direction.
This defaults to zero, when the check is suppressed.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.null_+3A_lmm">lmm</code></td>
<td>
<p>is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method, It defaults to 5.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.null_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is also passed to the optim() function.
Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)</p>
</td></tr>
<tr><td><code id="fit.null_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of
the algorithm are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-length list. First element is the output returned by &quot;optim()&quot; function (see &quot;optim()&quot; documentation for details).
Second element is a vector of statistics associated to the fitted null model:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>nPar</code> </td><td style="text-align: left;"> number of parameters of the base(null) model </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cll</code> </td><td style="text-align: left;"> value of the conditional log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mll</code> </td><td style="text-align: left;"> value of the marginal log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cAIC</code> </td><td style="text-align: left;"> conditional Akaike Information Criterion (cAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mAIC</code> </td><td style="text-align: left;"> marginal Akaike Information Criterion (mAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Chi2</code> </td><td style="text-align: left;"> value of the <code class="reqn">\chi^2</code> statistic <code class="reqn">(y - M\theta)'S^{-1}(y - M\theta)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p-value</code> </td><td style="text-align: left;"> p-value of the <code class="reqn">\chi^2</code> test for the null hypothesis that Chi2 follows a <code class="reqn">\chi^2</code> distribution with n - nPar degrees of freedom. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The third element, called &quot;design&quot;, is a list including:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>M</code> </td><td style="text-align: left;"> A <code class="reqn">n \times K</code> dimensional (design) matrix.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>V</code> </td><td style="text-align: left;"> A <code class="reqn">p \times K</code> dimensional net-effect matrix.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
null.res &lt;- fit.null(Y = Y,
                     rct.lst = rcts,
                     maxit = 0, ## needs to be increased (&gt;=100) for real applications
                     lmm = 0, ## needs to be increased (&gt;=5) for real applications
) ## null model fitting
</code></pre>

<hr>
<h2 id='fit.re'>Fit the random-effects model</h2><span id='topic+fit.re'></span>

<h3>Description</h3>

<p>This function builds the design matrix of the random-effects model and returns the fitted values and the corresponding statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.re(
  theta_0,
  Y,
  rct.lst,
  maxit = 10000,
  factr = 1e+07,
  pgtol = 1e-08,
  lmm = 100,
  maxemit = 100,
  eps = 1e-05,
  trace = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.re_+3A_theta_0">theta_0</code></td>
<td>
<p>A p-dimensional vector parameter as the initial guess for the inference.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_y">Y</code></td>
<td>
<p>A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_rct.lst">rct.lst</code></td>
<td>
<p>list of biochemical reactions.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;</p>
</td></tr>
<tr><td><code id="fit.re_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the optimization step.
This argument is passed to optim() function. Details on &quot;maxit&quot; can be found in &quot;optim()&quot; documentation page.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_factr">factr</code></td>
<td>
<p>controls the convergence of the &quot;L-BFGS-B&quot; method.
Convergence occurs when the reduction in the objective is within this factor of the machine tolerance.
Default is 1e7, that is a tolerance of about 1e-8.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_pgtol">pgtol</code></td>
<td>
<p>helps control the convergence of the &quot;L-BFGS-B&quot; method.
It is a tolerance on the projected gradient in the current search direction.
This defaults to zero, when the check is suppressed.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_lmm">lmm</code></td>
<td>
<p>is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method, It defaults to 5.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_maxemit">maxemit</code></td>
<td>
<p>maximum number of iterations for the expectation-maximization algorithm.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_eps">eps</code></td>
<td>
<p>relative error for the value x and the objective function f(x) that has to be optimized
in the expectation-maximization algorithm.</p>
</td></tr>
<tr><td><code id="fit.re_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is also passed to the optim() function.
Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)</p>
</td></tr>
<tr><td><code id="fit.re_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of the
algorithm are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-length list. First element is the output returned by &quot;optim()&quot; function (see &quot;optim()&quot; documentation for details)
along with the conditional expectation <code class="reqn">E[u \vert y]</code> and variance <code class="reqn">V[u \vert y]</code>
of the latent states u given the observed states y from the last step of the expectation-maximization algorithm.
Second element is a vector of statistics associated to the fitted random-effects model:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>nPar</code> </td><td style="text-align: left;"> number of parameters of the base(null) model </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cll</code> </td><td style="text-align: left;"> value of the conditional log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mll</code> </td><td style="text-align: left;"> value of the marginal log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cAIC</code> </td><td style="text-align: left;"> conditional Akaike Information Criterion (cAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mAIC</code> </td><td style="text-align: left;"> marginal Akaike Information Criterion (mAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Chi2</code> </td><td style="text-align: left;"> value of the <code class="reqn">\chi^2</code> statistic <code class="reqn">(y - M\theta)'S^{-1}(y - M\theta)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p-value</code> </td><td style="text-align: left;"> p-value of the <code class="reqn">\chi^2</code> test for the null hypothesis that Chi2 follows a <code class="reqn">\chi^2</code> distribution with n - nPar degrees of freedom. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>KLdiv</code> </td><td style="text-align: left;"> Kullback-Leibler divergence of the random-effects model from the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>KLdiv/N</code> </td><td style="text-align: left;"> Rescaled Kullback-Leibler divergence of the random-effects model from the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BhattDist_nullCond</code> </td><td style="text-align: left;"> Bhattacharyya distance between the random-effects model and the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BhattDist_nullCond/N</code> </td><td style="text-align: left;"> Rescaled Bhattacharyya distance between the random-effects model and the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The third element, called &quot;design&quot;, is a list including:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>M</code> </td><td style="text-align: left;"> A <code class="reqn">n \times K</code> dimensional (design) matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>M_bdiag</code> </td><td style="text-align: left;">  A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>V</code> </td><td style="text-align: left;"> A <code class="reqn">p \times K</code> dimensional net-effect matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
null.res &lt;- fit.null(Y = Y,
                     rct.lst = rcts,
                     maxit = 0, ## needs to be increased (&gt;=100) for real applications
                     lmm = 0, ## needs to be increased (&gt;=5) for real applications
) ## null model fitting

re.res &lt;- fit.re(theta_0 = null.res$fit$par,
                 Y = Y,
                 rct.lst = rcts,
                 maxit = 0, ## needs to be increased (&gt;=100) for real applications
                 lmm = 0, ## needs to be increased (&gt;=5) for real applications
                 maxemit = 1 ## needs to be increased (&gt;= 100) for real applications
) ## random-effects model fitting
</code></pre>

<hr>
<h2 id='get.boxplots'>Clonal boxplots</h2><span id='topic+get.boxplots'></span>

<h3>Description</h3>

<p>Draw clonal boxplots of a random-effects reaction network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.boxplots(re.res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.boxplots_+3A_re.res">re.res</code></td>
<td>
<p>output list returned by fit.re().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates the boxplots of the conditional expectations
</p>
<p style="text-align: center;"><code class="reqn">w_k = E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\alpha_{l}}] - E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\delta_{l}}]</code>
</p>
<p>,
computed from the estimated parameters <code class="reqn">\hat{\psi}</code> for the clone-specific net-duplication in each cell lineage l (different colors).
The whiskers extend to the data extremes.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
null.res &lt;- fit.null(Y = Y,
                     rct.lst = rcts,
                     maxit = 0, ## needs to be increased (&gt;=100) for real applications
                     lmm = 0, ## needs to be increased (&gt;=5) for real applications
) ## null model fitting

re.res &lt;- fit.re(theta_0 = null.res$fit$par,
                 Y = Y,
                 rct.lst = rcts,
                 maxit = 0, ## needs to be increased (&gt;=100) for real applications
                 lmm = 0, ## needs to be increased (&gt;=5) for real applications
                 maxemit = 1 ## needs to be increased (&gt;= 100) for real applications
) ## random-effects model fitting

get.boxplots(re.res)
</code></pre>

<hr>
<h2 id='get.dx'>Time-adjacent increments of the cell counts</h2><span id='topic+get.dx'></span>

<h3>Description</h3>

<p>This function generates time-adjacent increments from a cell counts matrix y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dx(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dx_+3A_y">y</code></td>
<td>
<p>clone-specific <code class="reqn">t \times p</code> cell count matrix, where t is the number of time-points and p the number of cell types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(t-1) \times p</code> dimensional vector containing the time-adjacent increments.
</p>

<hr>
<h2 id='get.gnl'>Gradient of the negative log-likelihood of the base (null) model</h2><span id='topic+get.gnl'></span>

<h3>Description</h3>

<p>Compute the gradient of the negative log-likelihood of the null model,
namely the linear model without rondom effects at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.gnl(theta, M, y, V, VCNs, nObs, dW)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.gnl_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="get.gnl_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="get.gnl_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="get.gnl_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="get.gnl_+3A_dw">dW</code></td>
<td>
<p>p-dimensional list of the partial derivatives of W w.r.t. theta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-dimensional vector of the gradient of the negative log-likelihood.
</p>

<hr>
<h2 id='get.M'>Design matrix M</h2><span id='topic+get.M'></span>

<h3>Description</h3>

<p>This function generates time-adjacent increments from a cell counts matrix y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.M(y, V, dT, get.h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.M_+3A_y">y</code></td>
<td>
<p>clone-specific <code class="reqn">t \times p</code> cell count matrix, where t is the number of time-points and p the number of cell types.</p>
</td></tr>
<tr><td><code id="get.M_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="get.M_+3A_dt">dT</code></td>
<td>
<p>A (t-1)-dimensional vector of the time-increments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">tp \times K</code> dimensional (design) matrix.
</p>

<hr>
<h2 id='get.nl'>Negative log-likelihood of the base (null) model</h2><span id='topic+get.nl'></span>

<h3>Description</h3>

<p>Compute the negative log-likelihood of the null model,
namely the linear model without rondom effects at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.nl(theta, M, y, V, VCNs, nObs, dW)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.nl_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="get.nl_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="get.nl_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="get.nl_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="get.nl_+3A_dw">dW</code></td>
<td>
<p>p-dimensional list of the partial derivatives of W w.r.t. theta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the negative log-likelihood.
</p>

<hr>
<h2 id='get.rescaled'>Rescaling a clonal tracking dataset</h2><span id='topic+get.rescaled'></span>

<h3>Description</h3>

<p>Rescales a clonal tracking dataset based on the sequencing depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rescaled(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rescaled_+3A_y">Y</code></td>
<td>
<p>A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rescales a clonal tracking dataset Y according to the formula
</p>
<p style="text-align: center;"><code class="reqn">Y_{ijk} \leftarrow Y_{ijk} \cdot \frac{min_{ij}\sum_cY_{ijc}}{\sum_cY_{ijc}}</code>
</p>



<h3>Value</h3>

<p>A rescaled clonal tracking dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.rescaled(Y_RM[["ZH33"]])
</code></pre>

<hr>
<h2 id='get.scatterpie'>Clonal pie-chart</h2><span id='topic+get.scatterpie'></span>

<h3>Description</h3>

<p>Draw a clonal pie-chart of a random-effects reaction network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.scatterpie(re.res, txt = FALSE, legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.scatterpie_+3A_re.res">re.res</code></td>
<td>
<p>output list returned by fit.re().</p>
</td></tr>
<tr><td><code id="get.scatterpie_+3A_txt">txt</code></td>
<td>
<p>logical (defaults to FALSE). If TRUE, barcode names will be printed on the pies.</p>
</td></tr>
<tr><td><code id="get.scatterpie_+3A_legend">legend</code></td>
<td>
<p>logical (defaults to FALSE). If TRUE, the legend of the pie-chart will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a clonal pie-chart given a previously fitted random-effects model.
In this representation each clone <code class="reqn">k</code> is identified with a pie whose slices are
lineage-specific and weighted with <code class="reqn">w_k</code>, defined as the difference between the
conditional expectations of the random-effects on duplication and death parameters, that is
</p>
<p style="text-align: center;"><code class="reqn">w_k = E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\alpha_{lin}}] - E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\delta_{lin}}]</code>
</p>
<p>,
where <code class="reqn">\texttt{lin}</code> is a cell lineage.
The diameter of the <code class="reqn">k</code>-th pie is proportional to the euclidean 2-norm of <code class="reqn">w_k</code>.
Therefore, the larger the diameter, the more the corresponding clone is expanding
into the lineage associated to the largest slice.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
null.res &lt;- fit.null(Y = Y,
                     rct.lst = rcts,
                     maxit = 0, ## needs to be increased (&gt;=100) for real applications
                     lmm = 0, ## needs to be increased (&gt;=5) for real applications
) ## null model fitting

re.res &lt;- fit.re(theta_0 = null.res$fit$par,
                 Y = Y,
                 rct.lst = rcts,
                 maxit = 0, ## needs to be increased (&gt;=100) for real applications
                 lmm = 0, ## needs to be increased (&gt;=5) for real applications
                 maxemit = 1 ## needs to be increased (&gt;= 100) for real applications
) ## random-effects model fitting

get.scatterpie(re.res, txt = TRUE)
</code></pre>

<hr>
<h2 id='get.sim.tl'><code class="reqn">\tau</code>-leaping simulation algorithm</h2><span id='topic+get.sim.tl'></span>

<h3>Description</h3>

<p>Simulate a trajectory of length S for a stochastic reaction network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sim.tl(Yt, theta, S, s2 = 0, tau = 1, rct.lst, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sim.tl_+3A_yt">Yt</code></td>
<td>
<p>starting point of the trajectory</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_theta">theta</code></td>
<td>
<p>vector parameter for the reactions.</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_s">S</code></td>
<td>
<p>length of the simulated trajectory.</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_s2">s2</code></td>
<td>
<p>noise variance (defaults to 0).</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_tau">tau</code></td>
<td>
<p>time interval length (defaults to 1).</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_rct.lst">rct.lst</code></td>
<td>
<p>list of biochemical reactions.</p>
</td></tr>
<tr><td><code id="get.sim.tl_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages
on the simulation progress are printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to simulate a trajectory of a single clone given an
initial conditions <code class="reqn">Y_0</code> for the cell counts, and obeying to a particular cell differentiation network
defined by a net-effect (stoichiometric) matrix <code class="reqn">V</code> and an hazard function <code class="reqn">h()</code>.
The function allows to consider only three cellular events, such as
cell duplication (<code class="reqn">Y_{it} \rightarrow 1</code>), cell death (<code class="reqn">Y_{it} \rightarrow \emptyset</code>)
and cell differentiation (<code class="reqn">Y_{it} \rightarrow Y_{jt}</code>) for a clone-specific time counting process
</p>
<p style="text-align: center;"><code class="reqn">Y_t = (Y_{1t},\dots,Y_{Nt})</code>
</p>

<p>observed in $N$ distinct cell lineages.
In particular,  the cellular events of duplication, death and differentiation are
respectively coded with the character labels <code class="reqn">\texttt{"A-&gt;1"}</code>, <code class="reqn">\texttt{"A-&gt;0"}</code>,
and <code class="reqn">\texttt{"A-&gt;B"}</code>, where  <code class="reqn">\texttt{A}</code> and  <code class="reqn">\texttt{B}</code> are two distinct cell types.
The output is a <code class="reqn">3</code>-dimensional array <code class="reqn">Y</code> whose <code class="reqn">ijk</code>-entry <code class="reqn">Y_{ijk}</code>
is the number of cells of clone <code class="reqn">k</code> for cell type <code class="reqn">j</code> collected at time <code class="reqn">i</code>.
More mathematical details can be found in the vignette of this package.
</p>


<h3>Value</h3>

<p>A <code class="reqn">S \times p</code> dimensional matrix of the simulated trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
Y
</code></pre>

<hr>
<h2 id='get.V'>Net-effect matrix</h2><span id='topic+get.V'></span>

<h3>Description</h3>

<p>This function builds the net-effect matrix V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.V(rct.lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.V_+3A_rct.lst">rct.lst</code></td>
<td>
<p>list of biochemical reactions.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The net-effect matrix V
</p>

<hr>
<h2 id='get.W'>Stochastic covariance matrix W</h2><span id='topic+get.W'></span>

<h3>Description</h3>

<p>This function returns the stochastic covariance matrix W associated to a design matrix M, a net-effect matrix V, and a vector parameter theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.W(M, V, VCNs, theta, nObs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.W_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="get.W_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="get.W_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times n</code> dimensional stochastic covariance matrix.
</p>

<hr>
<h2 id='KLDiv'>Kullback-Leibler divergence</h2><span id='topic+KLDiv'></span>

<h3>Description</h3>

<p>Kullback-Leibler divergence <code class="reqn">KL(P \Vert Q)</code> of Q from P for multivariate normal distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KLDiv(mu1, S1, mu2, S2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KLDiv_+3A_mu1">mu1</code></td>
<td>
<p>mean vector of P.</p>
</td></tr>
<tr><td><code id="KLDiv_+3A_s1">S1</code></td>
<td>
<p>covariance matrix of P.</p>
</td></tr>
<tr><td><code id="KLDiv_+3A_mu2">mu2</code></td>
<td>
<p>mean vector of Q.</p>
</td></tr>
<tr><td><code id="KLDiv_+3A_s2">S2</code></td>
<td>
<p>covariance matrix of Q.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kullback-Leibler divergence <code class="reqn">KL(P \Vert Q)</code> of Q from P.
</p>

<hr>
<h2 id='ldet'>Matrix determinant</h2><span id='topic+ldet'></span>

<h3>Description</h3>

<p>Compute the determinant of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldet(A, logarithm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldet_+3A_a">A</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="ldet_+3A_logarithm">logarithm</code></td>
<td>
<p>logical; if TRUE (default) return the logarithm of the modulus of the determinant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the determinant of A.
</p>

<hr>
<h2 id='ngQ'>Gradient of the E-step function Q</h2><span id='topic+ngQ'></span>

<h3>Description</h3>

<p>Gradient -<code class="reqn">\nabla Q</code> of the negative E-step function -Q of the expectation-maximization algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngQ(theta, euy_curr, vuy_curr, M, M_bdiag, y, V, VCNs, nObs, dW)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngQ_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_euy_curr">euy_curr</code></td>
<td>
<p>current value of the conditional expectation <code class="reqn">E[u \vert y]</code> of u given y,
where u and y are the latent and observed states respectively.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_vuy_curr">vuy_curr</code></td>
<td>
<p>current value of the conditional variance <code class="reqn">V[u \vert y]</code> of u given y,
where u and y are the latent and observed states respectively.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_m_bdiag">M_bdiag</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="ngQ_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="ngQ_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="ngQ_+3A_dw">dW</code></td>
<td>
<p>p-dimensional list of the partial derivatives of W w.r.t. theta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-dimensional vector of the gradient -<code class="reqn">\nabla Q</code> of the negative E-step function -Q.
</p>

<hr>
<h2 id='norm2'>Euclidean 2-norm</h2><span id='topic+norm2'></span>

<h3>Description</h3>

<p>Compute the euclidean 2-norm of a vector x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm2_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the euclidean 2-norm of x.
</p>

<hr>
<h2 id='nQ'>E-step function Q</h2><span id='topic+nQ'></span>

<h3>Description</h3>

<p>Negative E-step function -Q of the expectation-maximization algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nQ(theta, euy_curr, vuy_curr, M, M_bdiag, y, V, VCNs, nObs, dW)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nQ_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="nQ_+3A_euy_curr">euy_curr</code></td>
<td>
<p>current value of the conditional expectation <code class="reqn">E[u \vert y]</code> of u given y,
where u and y are the latent and observed states respectively.</p>
</td></tr>
<tr><td><code id="nQ_+3A_vuy_curr">vuy_curr</code></td>
<td>
<p>current value of the conditional variance <code class="reqn">V[u \vert y]</code> of u given y,
where u and y are the latent and observed states respectively.</p>
</td></tr>
<tr><td><code id="nQ_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="nQ_+3A_m_bdiag">M_bdiag</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="nQ_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="nQ_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="nQ_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="nQ_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="nQ_+3A_dw">dW</code></td>
<td>
<p>p-dimensional list of the partial derivatives of W w.r.t. theta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current value of the negative E-step function -Q.
</p>

<hr>
<h2 id='nullModelFitting'>Fit base model</h2><span id='topic+nullModelFitting'></span>

<h3>Description</h3>

<p>Fit the base (null) model to the given data using a maximum likelihood approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullModelFitting(
  theta_start,
  M,
  y,
  V,
  psiLB,
  psiUB,
  maxit,
  factr,
  pgtol,
  lmm,
  VCNs,
  nObs,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nullModelFitting_+3A_theta_start">theta_start</code></td>
<td>
<p>p-dimensional vector parameter used as initial guess in the inference procedure.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_psilb">psiLB</code></td>
<td>
<p>p-dimensional vector of lower bound values for theta.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_psiub">psiUB</code></td>
<td>
<p>p-dimensional vector of upper bound values for theta.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the optimization step.
This argument is passed to optim() function. Details on &quot;maxit&quot; can be found in &quot;optim()&quot; documentation page.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_factr">factr</code></td>
<td>
<p>controls the convergence of the &quot;L-BFGS-B&quot; method.
Convergence occurs when the reduction in the objective is within this factor of the machine tolerance.
Default is 1e7, that is a tolerance of about 1e-8.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_pgtol">pgtol</code></td>
<td>
<p>helps control the convergence of the &quot;L-BFGS-B&quot; method.
It is a tolerance on the projected gradient in the current search direction.
This defaults to zero, when the check is suppressed.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_lmm">lmm</code></td>
<td>
<p>is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method, It defaults to 5.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="nullModelFitting_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is also passed to the optim() function.
Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-length list. First element is the output returned by optim() function (see optim() documentation for details).
Second element is a vector of statistics associated to the fitted null model:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>nPar</code> </td><td style="text-align: left;"> number of parameters of the base(null) model </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cll</code> </td><td style="text-align: left;"> value of the conditional log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mll</code> </td><td style="text-align: left;"> value of the marginal log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cAIC</code> </td><td style="text-align: left;"> conditional Akaike Information Criterion (cAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mAIC</code> </td><td style="text-align: left;"> marginal Akaike Information Criterion (mAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Chi2</code> </td><td style="text-align: left;"> value of the <code class="reqn">\chi^2</code> statistic <code class="reqn">(y - M\theta)'S^{-1}(y - M\theta)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p-value</code> </td><td style="text-align: left;"> p-value of the <code class="reqn">\chi^2</code> test for the null hypothesis that Chi2 follows a <code class="reqn">\chi^2</code> distribution with n - nPar degrees of freedom. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The third element, called design, is a list including:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>M</code> </td><td style="text-align: left;"> A <code class="reqn">n \times K</code> dimensional (design) matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>V</code> </td><td style="text-align: left;"> A <code class="reqn">p \times K</code> dimensional net-effect matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='ny_u'>Conditional negative log-likelihood</h2><span id='topic+ny_u'></span>

<h3>Description</h3>

<p>Conditional negative log-likelihood <code class="reqn">-l(y \vert u)</code> of y given the random effects u
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ny_u(theta, Z, X, y, V, VCNs, nObs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ny_u_+3A_theta">theta</code></td>
<td>
<p>p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="ny_u_+3A_z">Z</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.</p>
</td></tr>
<tr><td><code id="ny_u_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="ny_u_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="ny_u_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="ny_u_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="ny_u_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional negative log-likelihood <code class="reqn">-l(y \vert u)</code> of y given the random effects u.
</p>

<hr>
<h2 id='relErr'>Multivariate relative error</h2><span id='topic+relErr'></span>

<h3>Description</h3>

<p>Compute the multivariate relative error between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relErr(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relErr_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="relErr_+3A_y">y</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the multivariate relative error between x and y.
</p>

<hr>
<h2 id='rmvNorm'>Random generator from a Multivariate Normal distribution</h2><span id='topic+rmvNorm'></span>

<h3>Description</h3>

<p>This function generate a random vector from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvNorm(d, p, Mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvNorm_+3A_d">d</code></td>
<td>
<p>sample d.</p>
</td></tr>
<tr><td><code id="rmvNorm_+3A_p">p</code></td>
<td>
<p>vector dimension.</p>
</td></tr>
<tr><td><code id="rmvNorm_+3A_mu">Mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="rmvNorm_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">p \times d</code> matrix. Each column is a p-variate random vector from
a multivariate normal with mean vector Mu and covariance matrix Sigma.
</p>

<hr>
<h2 id='rndEffModelFitting'>Fit random-effects model</h2><span id='topic+rndEffModelFitting'></span>

<h3>Description</h3>

<p>Fit the random-effects model to the given data using an expectation-maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndEffModelFitting(
  theta_0,
  V,
  M,
  M_bdiag,
  y,
  VCNs,
  nObs,
  maxit,
  maxemit,
  eps = 1e-05,
  thetaLB,
  thetaUB,
  factr,
  pgtol,
  lmm,
  trace = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rndEffModelFitting_+3A_theta_0">theta_0</code></td>
<td>
<p>p-dimensional vector parameter used as initial guess in the inference procedure.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_m_bdiag">M_bdiag</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the optimization step.
This argument is passed to optim() function. Details on &quot;maxit&quot; can be found in &quot;optim()&quot; documentation page.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_maxemit">maxemit</code></td>
<td>
<p>maximum number of iterations for the expectation-maximization algorithm.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_eps">eps</code></td>
<td>
<p>relative error for the value x and the objective function f(x) that has to be optimized
in the expectation-maximization algorithm.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_thetalb">thetaLB</code></td>
<td>
<p>p-dimensional vector of lower bound values for theta.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_thetaub">thetaUB</code></td>
<td>
<p>p-dimensional vector of upper bound values for theta.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_factr">factr</code></td>
<td>
<p>controls the convergence of the &quot;L-BFGS-B&quot; method.
Convergence occurs when the reduction in the objective is within this factor of the machine tolerance.
Default is 1e7, that is a tolerance of about 1e-8.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_pgtol">pgtol</code></td>
<td>
<p>helps control the convergence of the &quot;L-BFGS-B&quot; method.
It is a tolerance on the projected gradient in the current search direction.
This defaults to zero, when the check is suppressed.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_lmm">lmm</code></td>
<td>
<p>is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method, It defaults to 5.
This argument is passed to optim() function.</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is passed to the optim() function.
Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)</p>
</td></tr>
<tr><td><code id="rndEffModelFitting_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of the
algorithm are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output returned by &quot;optim()&quot; function (see &quot;optim()&quot; documentation for details) along with
the conditional expectation <code class="reqn">E[u \vert y]</code> and variance <code class="reqn">V[u \vert y]</code>
of the latent states u given the observed states y from the last step of the expectation-maximization algorithm.
</p>

<hr>
<h2 id='rndEffModelStats'>Base and random-effects model statistics</h2><span id='topic+rndEffModelStats'></span>

<h3>Description</h3>

<p>Main statistics from the fitted base and random-effects models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndEffModelStats(
  theta_null,
  theta_rndEff,
  V,
  M,
  M_bdiag,
  y,
  VCNs,
  nObs,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rndEffModelStats_+3A_theta_null">theta_null</code></td>
<td>
<p>the estimated p-dimensional vector parameter for the base (null) model.</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_theta_rndeff">theta_rndEff</code></td>
<td>
<p>the estimated p-dimensional vector parameter for the random-effects model.</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_m_bdiag">M_bdiag</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
<tr><td><code id="rndEffModelStats_+3A_verbose">verbose</code></td>
<td>
<p>(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of the
algorithm are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of statistics associated to the fitted base and random-effects models:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>nPar</code> </td><td style="text-align: left;"> number of parameters of the base(null) model </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cll</code> </td><td style="text-align: left;"> value of the conditional log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mll</code> </td><td style="text-align: left;"> value of the marginal log-likelihood, in this case just the log-likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cAIC</code> </td><td style="text-align: left;"> conditional Akaike Information Criterion (cAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mAIC</code> </td><td style="text-align: left;"> marginal Akaike Information Criterion (mAIC), in this case simply the AIC. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Chi2</code> </td><td style="text-align: left;"> value of the <code class="reqn">\chi^2</code> statistic <code class="reqn">(y - M\theta)'S^{-1}(y - M\theta)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p-value</code> </td><td style="text-align: left;"> p-value of the <code class="reqn">\chi^2</code> test for the null hypothesis that Chi2 follows a <code class="reqn">\chi^2</code> distribution with n - nPar degrees of freedom. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>KLdiv</code> </td><td style="text-align: left;"> Kullback-Leibler divergence of the random-effects model from the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>KLdiv/N</code> </td><td style="text-align: left;"> Rescaled Kullback-Leibler divergence of the random-effects model from the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BhattDist_nullCond</code> </td><td style="text-align: left;"> Bhattacharyya distance between the random-effects model and the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BhattDist_nullCond/N</code> </td><td style="text-align: left;"> Rescaled Bhattacharyya distance between the random-effects model and the null model. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='tr'>Matrix trace</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Trace of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_m">M</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the trace of M.
</p>

<hr>
<h2 id='VEuy'><code class="reqn">E[u \vert y]</code> and <code class="reqn">V[u \vert y]</code></h2><span id='topic+VEuy'></span>

<h3>Description</h3>

<p>Conditional expectation <code class="reqn">E[u \vert y]</code> and variance <code class="reqn">V[u \vert y]</code> of the latent states u given the observed states y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VEuy(theta_curr, M, M_bdiag, y, V, VCNs, nObs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VEuy_+3A_theta_curr">theta_curr</code></td>
<td>
<p>current p-dimensional vector parameter.</p>
</td></tr>
<tr><td><code id="VEuy_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">n \times K</code> dimensional (design) matrix.</p>
</td></tr>
<tr><td><code id="VEuy_+3A_m_bdiag">M_bdiag</code></td>
<td>
<p>A<code class="reqn">n \times Jp</code> dimensional block-diagonal design matrix.
Each j-th block (<code class="reqn">j = 1,\dots,J</code>) is a <code class="reqn">n_j \times p</code> dimensional design matrix for the j-th clone.</p>
</td></tr>
<tr><td><code id="VEuy_+3A_y">y</code></td>
<td>
<p>n-dimensional vector of the time-adjacent cellular increments</p>
</td></tr>
<tr><td><code id="VEuy_+3A_v">V</code></td>
<td>
<p>A <code class="reqn">p \times K</code> dimensional net-effect matrix.</p>
</td></tr>
<tr><td><code id="VEuy_+3A_vcns">VCNs</code></td>
<td>
<p>A n-dimensional vector including values of the vector copy number corresponding to the cell counts of y.</p>
</td></tr>
<tr><td><code id="VEuy_+3A_nobs">nObs</code></td>
<td>
<p>A K-dimensional vector including the frequencies of each clone k (<code class="reqn">k = 1,\dots,K</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the conditional expectation <code class="reqn">E[u \vert y]</code> and variance <code class="reqn">V[u \vert y]</code> of the latent states u given the observed states y.
</p>

<hr>
<h2 id='Y_RM'>Rhesus Macaque clonal tracking dataset</h2><span id='topic+Y_RM'></span>

<h3>Description</h3>

<p>A dataset containing clonal tracking cell counts from a Rhesus Macaque study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_RM
</code></pre>


<h3>Format</h3>

<p>A list containing clonal tracking data for each animal (ZH33, ZH17, ZG66).
Each clonal tracking dataset is a 3-dimensional array whose dimensions identify
</p>

<dl>
<dt>1</dt><dd><p>time, in months</p>
</dd>
<dt>2</dt><dd><p>cell types: T, B, NK, Macrophages(M) and Granulocytes(G)</p>
</dd>
<dt>3</dt><dd><p>unique barcodes (clones)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3979461/bin/NIHMS567927-supplement-02.xlsx">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3979461/bin/NIHMS567927-supplement-02.xlsx</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
