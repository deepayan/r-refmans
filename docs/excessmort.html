<!DOCTYPE html><html lang="en"><head><title>Help for package excessmort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {excessmort}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approx_demographics'><p>Interpolate demographic data</p></a></li>
<li><a href='#cdc_state_counts'><p>Weekly death counts for each USA state</p></a></li>
<li><a href='#collapse_age_dist'><p>Callapse age groups into broader ones</p></a></li>
<li><a href='#compute_counts'><p>Compute counts</p></a></li>
<li><a href='#compute_expected'><p>Compute expected counts for each day</p></a></li>
<li><a href='#cook_records'><p>Cook County Medical Examiner Records</p></a></li>
<li><a href='#excess_cumulative'><p>Compute cumulative excess deaths</p></a></li>
<li><a href='#excess_model'><p>Fit excess count model</p></a></li>
<li><a href='#excess_plot'><p>Plot results from fitted excess count model</p></a></li>
<li><a href='#excess_stats'><p>Excess counts in an interval</p></a></li>
<li><a href='#expected_diagnostic'><p>Diagnostic Plots for Model Fit</p></a></li>
<li><a href='#expected_plot'><p>Plot Expected Counts</p></a></li>
<li><a href='#fit_ar'><p>Fit an ar model to residuals from expected counts</p></a></li>
<li><a href='#get_demographics'><p>Get demographic data from Census</p></a></li>
<li><a href='#group_age'><p>Assign age to group</p></a></li>
<li><a href='#louisiana_counts'><p>Louisiana daily mortality</p></a></li>
<li><a href='#new_jersey_counts'><p>New Jersey daily mortality</p></a></li>
<li><a href='#noleap_yday'><p>Compute year of the day ingoring Feb 29</p></a></li>
<li><a href='#puerto_rico_counts'><p>Puerto Rico daily mortality</p></a></li>
<li><a href='#puerto_rico_icd'><p>Puerto Rico daily mortality by cause of death</p></a></li>
<li><a href='#world_counts'><p>Weekly death counts for several countries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Excess Mortality</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, datasets, dplyr, tidyr, rlang, lubridate, splines,
ggplot2, scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidycensus, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of method for estimating excess mortality and other health related outcomes from weekly or daily count data described in Acosta and Irizarry (2021) "A Flexible Statistical Framework for Estimating Excess Mortality".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-12 18:51:04 UTC; rafa</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael A. Irizarry [aut, cre],
  Rolando Acosta [aut],
  Mónica Robles-Fontán [aut],
  Ferenci Tamás [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rafael A. Irizarry &lt;rafael_irizarry@dfci.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-14 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='approx_demographics'>Interpolate demographic data</h2><span id='topic+approx_demographics'></span>

<h3>Description</h3>

<p>Interpolate yearly population estimates so that a population estimate is provided for 
each day of the year. The function 'approx' is used with 'rule = 2' for extrapolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_demographics(
  demo,
  first_day,
  last_day,
  by,
  extrapolation.type = c("linear", "constant", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approx_demographics_+3A_demo">demo</code></td>
<td>
<p>A data frame with the yearly population estimates. Must have a numeric column named year and a numeric column named population.</p>
</td></tr>
<tr><td><code id="approx_demographics_+3A_first_day">first_day</code></td>
<td>
<p>First day to interpolate. If missing the first day of the first year in demo is used.</p>
</td></tr>
<tr><td><code id="approx_demographics_+3A_last_day">last_day</code></td>
<td>
<p>Last day to interpolate. If missing the last day of the last year in demo is used.</p>
</td></tr>
<tr><td><code id="approx_demographics_+3A_by">by</code></td>
<td>
<p>Vector of column names to group by, for example different demographic strata. If missing it will extrapolate within each strata. To collapse all strata, define as by = NULL.</p>
</td></tr>
<tr><td><code id="approx_demographics_+3A_extrapolation.type">extrapolation.type</code></td>
<td>
<p>Type of extrapolation. Either linear, constant, or none. If none is selected the NAs are returned.</p>
</td></tr>
<tr><td><code id="approx_demographics_+3A_...">...</code></td>
<td>
<p>additional parameters sent to the function 'approx'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with dates and population estimates.
</p>

<hr>
<h2 id='cdc_state_counts'>Weekly death counts for each USA state</h2><span id='topic+cdc_state_counts'></span>

<h3>Description</h3>

<p>The Center for Disease Control (CDC) provides weekly estimated death counts for each state in the USA. 
This data frame includes these estimates for each state along with population sizes.
</p>

<ul>
<li><p> state Name of USA state
</p>
</li>
<li><p> date Corresponding date of observation
</p>
</li>
<li><p> outcome Estimated number of deaths
</p>
</li>
<li><p> population Population estimate (from the Census)</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(cdc_state_counts)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>

<hr>
<h2 id='collapse_age_dist'>Callapse age groups into broader ones</h2><span id='topic+collapse_age_dist'></span><span id='topic+collapse_counts_by_age'></span>

<h3>Description</h3>

<p>Collapse a count or demographic data frame into a broader age strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_age_dist(demo, breaks)

collapse_counts_by_age(counts, breaks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_age_dist_+3A_demo">demo</code></td>
<td>
<p>A data frame with population sizes for different groups that will be collapsed.</p>
</td></tr>
<tr><td><code id="collapse_age_dist_+3A_breaks">breaks</code></td>
<td>
<p>The new age breaks for the new, broader, age strata.</p>
</td></tr>
<tr><td><code id="collapse_age_dist_+3A_counts">counts</code></td>
<td>
<p>A data frame with counts and population sizes for different groups that will be collapsed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A age groups represented in 'demo' or 'counts' are grouped using the new age breaks
defined by breaks but containing the populations and counts, if applicable,
for age groups defined by 'breaks'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lubridate)
data(cook_records)
## define smaller subset for example
cook_demographics_subset &lt;- cook_demographics[year(cook_demographics$date)==2021, ]
demo &lt;- collapse_age_dist(cook_demographics_subset, 
                          breaks = c(0, 20, 40, 60, 80, Inf))
</code></pre>

<hr>
<h2 id='compute_counts'>Compute counts</h2><span id='topic+compute_counts'></span>

<h3>Description</h3>

<p>Compute counts for groups from individual records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_counts(
  dat,
  by = NULL,
  demo = NULL,
  date = "date",
  age = "age",
  agegroup = "agegroup",
  breaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_counts_+3A_dat">dat</code></td>
<td>
<p>The data frame with the individual records</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_by">by</code></td>
<td>
<p>A character vector with the column names the define the groups for which we will compute counts</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_demo">demo</code></td>
<td>
<p>A data frame with population sizes for each time point for each of the groups for which we will compute counts</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_date">date</code></td>
<td>
<p>The column name of the column that contains dates</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_age">age</code></td>
<td>
<p>The column name of the column that contains age</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_agegroup">agegroup</code></td>
<td>
<p>The column name of the column that contains agegroup</p>
</td></tr>
<tr><td><code id="compute_counts_+3A_breaks">breaks</code></td>
<td>
<p>The ages that define the agegroups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is helper function that helps convert individual records data, in which each death is a row, 
to a count data frame where each row is a date. It is particulalry helpful for defining agegroups. If you
provide the 'breaks' argument it will automaticall divided the data and provide the counts for each age strata. 
You can also select variables to group by using the 'by' argument. 
One can provide a data frame with demogrpahic inform through the 'demo' argument. This tabe must have the 
population size for each group for each data.
</p>


<h3>Value</h3>

<p>A data frame with counts for each group for each date with population sizes, if demo was provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
data("cook_records")
the_breaks &lt;- c(0, 20, 40, 60, 75, Inf)

## take subset for example
cook_records_subset &lt;- cook_records[year(cook_records$date)==2021, ]
cook_demographics_subset &lt;- cook_demographics[year(cook_demographics$date)==2021, ]

cook_counts &lt;- compute_counts(cook_records_subset, 
                       demo = cook_demographics_subset, 
                       by = c("agegroup", "race", "sex"), 
                       breaks = the_breaks)
</code></pre>

<hr>
<h2 id='compute_expected'>Compute expected counts for each day</h2><span id='topic+compute_expected'></span>

<h3>Description</h3>

<p>Compute the expected death count for each unit of time. 
We assume counts are over-dispersed Poisson distributed with a 
trend that accounts for slow, year-to-year, changes in death rate across time and a seasonal effect. 
The function takes a data frame with 
dates and counts and returns the data frame with the expected counts as a new 
column. It also returns a logical column that is 'TRUE' if that entry was 
used in the estimation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_expected(
  counts,
  exclude = NULL,
  include.trend = TRUE,
  trend.knots.per.year = 1/7,
  extrapolate = TRUE,
  harmonics = 2,
  frequency = NULL,
  weekday.effect = FALSE,
  keep.components = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_expected_+3A_counts">counts</code></td>
<td>
<p>A data frame with dates, counts, and population size.</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_exclude">exclude</code></td>
<td>
<p>A list of dates to exclude when fitting the model. This is typically the period for which you will later estimate excess counts.</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_include.trend">include.trend</code></td>
<td>
<p>Logical that determines if a slow trend is included in the model.</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_trend.knots.per.year">trend.knots.per.year</code></td>
<td>
<p>Number of knots per year used for the time trend</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Logical that determines if the slow trend is extrapolated past the range of data used to fit. This</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_harmonics">harmonics</code></td>
<td>
<p>Number of harmonics to include in the seasonal effect</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_frequency">frequency</code></td>
<td>
<p>Number of data points per year. If not provided, the function attempts to estimate it</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_weekday.effect">weekday.effect</code></td>
<td>
<p>A logical that determines if a day of the week effect is included in the model</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_keep.components">keep.components</code></td>
<td>
<p>A logical that if 'TRUE' forces the function to return the estimated trend, seasonal model, and weekday effect, if included in the model.</p>
</td></tr>
<tr><td><code id="compute_expected_+3A_verbose">verbose</code></td>
<td>
<p>A logical that if 'TRUE' makes function prints out updates on the estimation procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Periods for which excess deaths will be estimated should be excluded when estimating expected counts. These can be supplied via the 'exclude' argument. 
Note that If 'extrapolate' is 'TRUE', the default, the time trend will be extrapolated following the estimated trend. 
If 'extrapolate' is 'FALSE' the trend is assumed to be a constant equal to the estimate on the last day before extrapolation.
If the period for which excess deaths are estimated is long, extrapolation should be used with caution. 
We highly recommend exploring the estimated expected counts with the 'expected_diagnostics' function.
</p>


<h3>Value</h3>

<p>The 'counts' data.frame with two columns added: 'expected' and 'excluded'. 
The 'expected' column is the estimated expected value of the counts for that date.
The 'excluded' column is a logical vector denoting if that date was excluded when
estimating the expected value.
</p>
<p>If the argument 'keep.components' is 'TRUE' a list is returned with 'counts'
data.frame in the first component, the estimated trend in the second, the 
estimated seasonal effect in the third and the estimated weekday effects in the fourth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(new_jersey_counts)
exclude_dates &lt;- as.Date("2012-10-29") + 0:180
counts &lt;- compute_expected(new_jersey_counts, exclude = exclude_dates, weekday.effect = TRUE)
library(ggplot2)
expected_plot(counts)

</code></pre>

<hr>
<h2 id='cook_records'>Cook County Medical Examiner Records</h2><span id='topic+cook_records'></span><span id='topic+cook_demographics'></span>

<h3>Description</h3>

<p>A data frame with each row represening a death. The data includes 
death date and demographic information. When you load this dataset you also 
load 'cook_demographics' which includes the population size for each demographice
group by date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cook_records")
</code></pre>


<h3>Format</h3>

<p>A data frame with these columns
</p>

<dl>
<dt>sex</dt><dd><p>Sex of the deceased</p>
</dd>
<dt>age</dt><dd><p>Age of the deceased</p>
</dd>
<dt>race</dt><dd><p>Race of the deceased</p>
</dd>
<dt>residenceplace</dt><dd><p>Residence placed of the deceased</p>
</dd>
<dt>date</dt><dd><p>Date of the death</p>
</dd>
<dt>cause_1</dt><dd><p>Reported cause of death</p>
</dd>
<dt>type_of_death</dt><dd><p>Type of death</p>
</dd>
</dl>


<hr>
<h2 id='excess_cumulative'>Compute cumulative excess deaths</h2><span id='topic+excess_cumulative'></span>

<h3>Description</h3>

<p>This function takes the output of the 'excess_model' function, a start date, and 
end date and calculates excess mortality and standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excess_cumulative(fit, start, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excess_cumulative_+3A_fit">fit</code></td>
<td>
<p>The output of 'excess_model'</p>
</td></tr>
<tr><td><code id="excess_cumulative_+3A_start">start</code></td>
<td>
<p>The start date</p>
</td></tr>
<tr><td><code id="excess_cumulative_+3A_end">end</code></td>
<td>
<p>The end date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns
</p>

<dl>
<dt>date</dt><dd><p>The date</p>
</dd>
<dt>observed</dt><dd><p>The observed excess mortality,which is the sum of observed minus expected until that date</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation for excess mortality for that date if year is typical</p>
</dd>
<dt>fitted</dt><dd><p>The estimated of excess mortality based on the estimated smooth event effect curve</p>
</dd>
<dt>se</dt><dd><p>The standard error for 'fitted'</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(new_jersey_counts)
exclude_dates &lt;- as.Date("2012-10-29") + 0:180
control_dates &lt;- seq(min(new_jersey_counts$date), min(exclude_dates) - 1, by = "day")
f &lt;- excess_model(new_jersey_counts, 
start = as.Date("2012-09-01"), 
end = as.Date("2013-09-01"),
exclude = exclude_dates,
model = "correlated",
weekday.effect = TRUE,
control.dates = control_dates)

excess_cumulative(f, 
start = as.Date("2017-12-15"), 
end = as.Date("2017-12-21") )

</code></pre>

<hr>
<h2 id='excess_model'>Fit excess count model</h2><span id='topic+excess_model'></span>

<h3>Description</h3>

<p>This function estimates the increase in the rate for a count time series relative to 
the rate for a typical year. Two options are available: 1 - model the rate increase as a 
smooth function and estimate this function or 2 - estimate the total excess in intervals. 
For 1 an 'event' date can be provided and a discontinuity included in the model.
You can do either 1 or 2 or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excess_model(
  counts,
  start = NULL,
  end = NULL,
  knots.per.year = 12,
  event = NULL,
  intervals = NULL,
  discontinuity = TRUE,
  model = c("quasipoisson", "poisson", "correlated"),
  exclude = NULL,
  include.trend = TRUE,
  trend.knots.per.year = 1/7,
  harmonics = 2,
  frequency = NULL,
  weekday.effect = FALSE,
  control.dates = NULL,
  max.control = 5000,
  order.max = 14,
  aic = TRUE,
  maxit = 25,
  epsilon = 1e-08,
  alpha = 0.05,
  min.rate = 1e-04,
  keep.counts = FALSE,
  keep.components = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excess_model_+3A_counts">counts</code></td>
<td>
<p>A data frame with date, count and population columns.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_start">start</code></td>
<td>
<p>First day of interval to which model will be fit</p>
</td></tr>
<tr><td><code id="excess_model_+3A_end">end</code></td>
<td>
<p>Last day of interval to which model will be fit</p>
</td></tr>
<tr><td><code id="excess_model_+3A_knots.per.year">knots.per.year</code></td>
<td>
<p>Number of knots per year used for the fitted smooth function</p>
</td></tr>
<tr><td><code id="excess_model_+3A_event">event</code></td>
<td>
<p>If modeling a discontinuity is desired, this is the day in which it happens</p>
</td></tr>
<tr><td><code id="excess_model_+3A_intervals">intervals</code></td>
<td>
<p>Instead of 'start' and 'end' a list of time intervals can be provided and excess is computed in each one</p>
</td></tr>
<tr><td><code id="excess_model_+3A_discontinuity">discontinuity</code></td>
<td>
<p>Logical that determines if discontinuity is allowed at 'event'</p>
</td></tr>
<tr><td><code id="excess_model_+3A_model">model</code></td>
<td>
<p>Which version of the model to fit</p>
</td></tr>
<tr><td><code id="excess_model_+3A_exclude">exclude</code></td>
<td>
<p>Dates to exclude when computing expected counts</p>
</td></tr>
<tr><td><code id="excess_model_+3A_include.trend">include.trend</code></td>
<td>
<p>Logical that determines if a slow trend is included in the model.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_trend.knots.per.year">trend.knots.per.year</code></td>
<td>
<p>Number of knots per year used by 'compute_expected' to estimate the trend for the expected counts</p>
</td></tr>
<tr><td><code id="excess_model_+3A_harmonics">harmonics</code></td>
<td>
<p>Number of harmonics used by 'compute_expected' to estimate seasonal trend</p>
</td></tr>
<tr><td><code id="excess_model_+3A_frequency">frequency</code></td>
<td>
<p>Number of observations per year. If not provided an attempt is made to calculate it</p>
</td></tr>
<tr><td><code id="excess_model_+3A_weekday.effect">weekday.effect</code></td>
<td>
<p>Logical that determins if a day of the week effects is included in the model. Should be 'FALSE' for weekly or monthly data.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_control.dates">control.dates</code></td>
<td>
<p>When 'model' is set to 'correlated', these dates are used to estimate the covariance matrix. The larger this is the slower the function runs.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_max.control">max.control</code></td>
<td>
<p>If the length of 'control.dates' is larger than 'max.control' the function stops.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_order.max">order.max</code></td>
<td>
<p>Larges order for the Autoregressive process used to model the covariance structure</p>
</td></tr>
<tr><td><code id="excess_model_+3A_aic">aic</code></td>
<td>
<p>A logical that determines if the AIC criterion is used to selected the order of the AR process</p>
</td></tr>
<tr><td><code id="excess_model_+3A_maxit">maxit</code></td>
<td>
<p>Maxium number of iterations for the IRLS algorithm used when 'model' is 'correlated'</p>
</td></tr>
<tr><td><code id="excess_model_+3A_epsilon">epsilon</code></td>
<td>
<p>Difference in deviance requried to declare covergenace of IRLS</p>
</td></tr>
<tr><td><code id="excess_model_+3A_alpha">alpha</code></td>
<td>
<p>Percentile used to define what is outside the normal range</p>
</td></tr>
<tr><td><code id="excess_model_+3A_min.rate">min.rate</code></td>
<td>
<p>The estimated expected rate is not permited to go below this value</p>
</td></tr>
<tr><td><code id="excess_model_+3A_keep.counts">keep.counts</code></td>
<td>
<p>A logical that if 'TRUE' forces the function to include the data used to fit the expected count model.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_keep.components">keep.components</code></td>
<td>
<p>A logical that if 'TRUE' forces the function to return the estimated trend, seasonal model, and weekday effect, if included in the model. Ignored if expected counts already provided or 'keep.counts' is 'FALSE'.</p>
</td></tr>
<tr><td><code id="excess_model_+3A_verbose">verbose</code></td>
<td>
<p>Logical that determines if messages are displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three versions of the model are available: 1 - Assume counts are Poisson distributed, 
2 - assume counts are overdispersed Poisson, or 3 - assume a mixed model with 
correlated errors. The second is the default and recommended for weekly count data. For daily counts we often find 
evidence of correlation and recommend the third along with setting 'weekday.effect = TRUE'.
</p>
<p>If the 'counts' object includes a 'expected' column produced by 'compute_expected' these are used
as the expected counts. If not, then these are computed.
</p>


<h3>Value</h3>

<p>If only 'intervals' are provided a data frame with excess estimates described below for 'excess'. 
if 'start' and 'end' are provided the a list with the following components are included:
</p>

<dl>
<dt>date</dt><dd><p>The dates for which the estimate was computed</p>
</dd>
<dt>observed</dt><dd><p>The observed counts</p>
</dd>
<dt>expected</dt><dd><p>The expected counts</p>
</dd>
<dt>fitted</dt><dd><p>The fitted curve for excess counts</p>
</dd>
<dt>se</dt><dd><p>The point-wise standard error for the fitted curve</p>
</dd>
<dt>population</dt><dd><p>The population size</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation for observed counts on a typical year</p>
</dd>
<dt>cov</dt><dd><p>The estimated covariance matrix for the observed counts</p>
</dd>
<dt>x</dt><dd><p>The design matrix used for the fit</p>
</dd>
<dt>betacov</dt><dd><p>The covariance matrix for the estimated coefficients</p>
</dd>
<dt>dispersion</dt><dd><p>The estimated overdispersion parameter</p>
</dd>
<dt>detected_intervals</dt><dd><p>Time intervals for which the 1 - 'alpha' confidence interval does not include 0</p>
</dd>
<dt>ar</dt><dd><p>The estimated coefficients for the autoregressive process</p>
</dd>
<dt>excess</dt><dd><p>A data frame with information for the time intervals provided in 'itervals'. This includes start, end, observed death rate (per 1,000 per year), expected death rate, standard deviation for the death rate, observed counts, expected counts, excess counts, standard deviation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(cdc_state_counts)
counts &lt;- cdc_state_counts[cdc_state_counts$state == "Massachusetts", ]
exclude_dates &lt;- c(seq(as.Date("2017-12-16"), as.Date("2018-01-16"), by = "day"),
seq(as.Date("2020-01-01"), max(cdc_state_counts$date), by = "day"))
f &lt;- excess_model(counts, 
exclude = exclude_dates,
start = min(counts$date),
end = max(counts$date),
knots.per.year = 12)
data(new_jersey_counts)
exclude_dates &lt;- as.Date("2012-10-29") + 0:180
control_dates &lt;- seq(min(new_jersey_counts$date), min(exclude_dates) - 1, by = "day")
f &lt;- excess_model(new_jersey_counts,
start = as.Date("2012-09-01"), 
end = as.Date("2013-09-01"), 
exclude = exclude_dates,
model = "correlated",
weekday.effect = TRUE,
control.dates = control_dates)

</code></pre>

<hr>
<h2 id='excess_plot'>Plot results from fitted excess count model</h2><span id='topic+excess_plot'></span>

<h3>Description</h3>

<p>Plot results from fitted excess count model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excess_plot(fit, title = "", ylim = NULL, show.data = TRUE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excess_plot_+3A_fit">fit</code></td>
<td>
<p>The output from 'excess_model'</p>
</td></tr>
<tr><td><code id="excess_plot_+3A_title">title</code></td>
<td>
<p>A title to add to plot</p>
</td></tr>
<tr><td><code id="excess_plot_+3A_ylim">ylim</code></td>
<td>
<p>A vector with two numbers that determines the kimits for the y-axis</p>
</td></tr>
<tr><td><code id="excess_plot_+3A_show.data">show.data</code></td>
<td>
<p>A logical that determines if the observed percent changes are shown</p>
</td></tr>
<tr><td><code id="excess_plot_+3A_alpha">alpha</code></td>
<td>
<p>1 - 'alpha' confidence intervals are shown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ggplot object containing the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(new_jersey_counts)
exclude_dates &lt;- as.Date("2012-10-29") + 0:180
control_dates &lt;- seq(min(new_jersey_counts$date), min(exclude_dates) - 1, by = "day")
f &lt;- excess_model(new_jersey_counts,
start = as.Date("2012-09-01"), 
end = as.Date("2013-09-01"), 
exclude = exclude_dates,
model = "correlated",
weekday.effect = TRUE,
control.dates = control_dates)

library(ggplot2)
excess_plot(f)

</code></pre>

<hr>
<h2 id='excess_stats'>Excess counts in an interval</h2><span id='topic+excess_stats'></span>

<h3>Description</h3>

<p>Helper function to compute excess deaths statistics for a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excess_stats(
  start,
  end,
  obs,
  mu,
  cov,
  pop,
  frequency,
  fhat = NULL,
  X = NULL,
  betacov = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excess_stats_+3A_start">start</code></td>
<td>
<p>First day of interval</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_end">end</code></td>
<td>
<p>Last day of interval</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_obs">obs</code></td>
<td>
<p>Observed counts</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_mu">mu</code></td>
<td>
<p>Expected counts</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_cov">cov</code></td>
<td>
<p>Covariance matrix for percent change</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_pop">pop</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_frequency">frequency</code></td>
<td>
<p>Observations per year</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_fhat">fhat</code></td>
<td>
<p>Estimated percent increase</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_x">X</code></td>
<td>
<p>Design matrix used to estimate fhat</p>
</td></tr>
<tr><td><code id="excess_stats_+3A_betacov">betacov</code></td>
<td>
<p>Covariance matrix for parameter estimates used to estimate fhat</p>
</td></tr>
</table>

<hr>
<h2 id='expected_diagnostic'>Diagnostic Plots for Model Fit</h2><span id='topic+expected_diagnostic'></span>

<h3>Description</h3>

<p>Check mean model fit via diagnostic figures of the model components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_diagnostic(
  expected,
  start = NULL,
  end = NULL,
  color = "#D22B2B",
  alpha = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_diagnostic_+3A_expected">expected</code></td>
<td>
<p>The output from 'compute_expected' with 'keep.components = TRUE'</p>
</td></tr>
<tr><td><code id="expected_diagnostic_+3A_start">start</code></td>
<td>
<p>First day to show</p>
</td></tr>
<tr><td><code id="expected_diagnostic_+3A_end">end</code></td>
<td>
<p>Last day to show</p>
</td></tr>
<tr><td><code id="expected_diagnostic_+3A_color">color</code></td>
<td>
<p>Color for the expected curve</p>
</td></tr>
<tr><td><code id="expected_diagnostic_+3A_alpha">alpha</code></td>
<td>
<p>alpha blending for points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six ggplot objects: 
'population' is a time series plot of the population.
'seasonal' is a plot showing the estimated seasonal effect.
'trend' is a time series plot showing the estimated trend.
'weekday' is a plot of the estimated weekday effects if they were estimated.
'expected'is a time series plot of the expected values.
'residual' is a time series plot of the residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(lubridate)
library(ggplot2)

flu_season &lt;- seq(make_date(2017, 12, 16), make_date(2018, 1, 16), by = "day")

exclude_dates &lt;- c(flu_season, seq(make_date(2020, 1, 1), today(), by = "day"))

res  &lt;- cdc_state_counts %&gt;%
 filter(state == "Massachusetts") %&gt;%
 compute_expected(exclude = exclude_dates,
                  keep.components = TRUE)
                  
p &lt;- expected_diagnostic(expected = res, alpha = 0.50)

p$population
p$seasonal
p$trend
p$expected
p$residual
</code></pre>

<hr>
<h2 id='expected_plot'>Plot Expected Counts</h2><span id='topic+expected_plot'></span>

<h3>Description</h3>

<p>Check if expected counts fit data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_plot(
  expected,
  title = "",
  start = NULL,
  end = NULL,
  ylim = NULL,
  weekly = FALSE,
  color = "#3366FF",
  alpha = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_plot_+3A_expected">expected</code></td>
<td>
<p>The output from 'compute_expected'</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_title">title</code></td>
<td>
<p>A title to add to plot</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_start">start</code></td>
<td>
<p>First day to show</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_end">end</code></td>
<td>
<p>Last day to show</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_ylim">ylim</code></td>
<td>
<p>A vector with two numbers that determines the kimits for the y-axis</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_weekly">weekly</code></td>
<td>
<p>Logical that determines if data should be summarized into weekly counts</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_color">color</code></td>
<td>
<p>Color for the expected curve</p>
</td></tr>
<tr><td><code id="expected_plot_+3A_alpha">alpha</code></td>
<td>
<p>alpha blending for points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object containing a plot of the original counts and the 
estimated expected values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(new_jersey_counts)
exclude_dates &lt;- as.Date("2012-10-29") + 0:180
e &lt;- compute_expected(new_jersey_counts, exclude = exclude_dates, weekday.effect = TRUE)

library(ggplot2)
expected_plot(e, start = as.Date("2012-09-01"), end = as.Date("2013-09-01"))

</code></pre>

<hr>
<h2 id='fit_ar'>Fit an ar model to residuals from expected counts</h2><span id='topic+fit_ar'></span>

<h3>Description</h3>

<p>Helper function to estimate autoregressive mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ar(counts, control.dates = NULL, order.max = 5, aic = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_ar_+3A_counts">counts</code></td>
<td>
<p>Output from 'compute_excpected'</p>
</td></tr>
<tr><td><code id="fit_ar_+3A_control.dates">control.dates</code></td>
<td>
<p>Dates to use to estimate covariance</p>
</td></tr>
<tr><td><code id="fit_ar_+3A_order.max">order.max</code></td>
<td>
<p>Maximum order of autoregressive process</p>
</td></tr>
<tr><td><code id="fit_ar_+3A_aic">aic</code></td>
<td>
<p>Logical that determines if AIC is used</p>
</td></tr>
<tr><td><code id="fit_ar_+3A_plot">plot</code></td>
<td>
<p>logical that determines if an autocorrelation plot is generated for exploration purposes</p>
</td></tr>
</table>

<hr>
<h2 id='get_demographics'>Get demographic data from Census</h2><span id='topic+get_demographics'></span>

<h3>Description</h3>

<p>Get demographic data from Census
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_demographics(
  geography = "state",
  state,
  county = NULL,
  years = 2018,
  vars = c("SEX", "AGEGROUP", "RACE", "HISP")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_demographics_+3A_geography">geography</code></td>
<td>
<p>state or county</p>
</td></tr>
<tr><td><code id="get_demographics_+3A_state">state</code></td>
<td>
<p>name of the state</p>
</td></tr>
<tr><td><code id="get_demographics_+3A_county">county</code></td>
<td>
<p>name of the county</p>
</td></tr>
<tr><td><code id="get_demographics_+3A_years">years</code></td>
<td>
<p>vector of years for which we obtain data</p>
</td></tr>
<tr><td><code id="get_demographics_+3A_vars">vars</code></td>
<td>
<p>names of variables that define strat of which we want population estimates</p>
</td></tr>
</table>

<hr>
<h2 id='group_age'>Assign age to group</h2><span id='topic+group_age'></span>

<h3>Description</h3>

<p>Assign age to group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_age(age, breaks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_age_+3A_age">age</code></td>
<td>
<p>Vector of ages</p>
</td></tr>
<tr><td><code id="group_age_+3A_breaks">breaks</code></td>
<td>
<p>Ages that define strata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor that groups the ages into the age groups defined by 'breaks'.
</p>

<hr>
<h2 id='louisiana_counts'>Louisiana daily mortality</h2><span id='topic+louisiana_counts'></span>

<h3>Description</h3>

<p>A data frame with  Louisiana daily mortality counts from 2003-01-01 to 2016-12-31, 
which includes the day Katrina made landfall on 2015-08-29.
The outcome column includes the number of deaths for that day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("louisiana_counts")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1461 rows and 3 columns.
</p>

<hr>
<h2 id='new_jersey_counts'>New Jersey daily mortality</h2><span id='topic+new_jersey_counts'></span>

<h3>Description</h3>

<p>A data frame with  Louisiana daily mortality counts from 2007-01-01 to 2015-12-31
which includes the day Sandy made landfall on 2012-10-29.
The outcome column includes the number of deaths for that day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("new_jersey_counts")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3287 rows and 3 columns.
</p>

<hr>
<h2 id='noleap_yday'>Compute year of the day ingoring Feb 29</h2><span id='topic+noleap_yday'></span>

<h3>Description</h3>

<p>Compute year of the day ingoring Feb 29
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noleap_yday(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noleap_yday_+3A_x">x</code></td>
<td>
<p>date</p>
</td></tr>
</table>

<hr>
<h2 id='puerto_rico_counts'>Puerto Rico daily mortality</h2><span id='topic+puerto_rico_counts'></span>

<h3>Description</h3>

<p>A data frame with Puerto Rico daily mortality counts, stratified by agegroup,
from 1985 to 2020.
which includes the days hurricanes Hugo, Georges, and Maria made
landfall on 1989-09-18, 1998-09-21, and 2017-09-20, respectively.
The outcome column includes the number of deaths for that day. This data frame
also includes population counts and estimates for the period. Population counts 
for 1985 to 2000 are interpolations of decennial census products since 1980 to 2000. 
For 2000 onward, we use interpolated population estimates (PEP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("puerto_rico_counts")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 499644 rows and 5 columns.
</p>

<hr>
<h2 id='puerto_rico_icd'>Puerto Rico daily mortality by cause of death</h2><span id='topic+puerto_rico_icd'></span><span id='topic+icd'></span>

<h3>Description</h3>

<p>A data frame with Puerto Rico daily mortality counts, stratified by cause of death
from 1999 to 2020.
which includes the day hurricanes Maria made
landfall on 2017-09-20.
The outcome column includes the number of deaths for that day for that ICD-10 code.
The object 'icd' is included to show the description of each ICD-10 code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("puerto_rico_icd")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 262980 rows and 4 columns.
</p>

<hr>
<h2 id='world_counts'>Weekly death counts for several countries</h2><span id='topic+world_counts'></span>

<h3>Description</h3>

<p>A data frame with weekly death counts from multiple countries that includes the year 2020. 
Each country has a different range of data and most countries have at least 5 years of pre-2020 data.
The original data was collated by the Financial Times .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(world_counts)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>


<h3>Details</h3>


<ul>
<li><p> country Name of the country
</p>
</li>
<li><p> date Corresponding date of observation
</p>
</li>
<li><p> outcome Estimated number of deaths
</p>
</li>
<li><p> population Population estimate (from the Census)</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
