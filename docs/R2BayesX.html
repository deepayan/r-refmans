<!DOCTYPE html><html><head><title>Help for package R2BayesX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {R2BayesX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.neighbor'><p>Add Neighborhood Relations</p></a></li>
<li><a href='#bayesx'>
<p>Estimate STAR Models with BayesX</p></a></li>
<li><a href='#bayesx_logfile'>
<p>BayesX Log-Files</p></a></li>
<li><a href='#bayesx_prgfile'>
<p>BayesX Program-Files</p></a></li>
<li><a href='#bayesx_runtime'>
<p>BayesX Program-Runtimes</p></a></li>
<li><a href='#bayesx.construct'>
<p>Construct BayesX Model Term Objects</p></a></li>
<li><a href='#bayesx.control'>
<p>Control Parameters for BayesX</p></a></li>
<li><a href='#bayesx.term.options'><p>Show BayesX Term Options</p></a></li>
<li><a href='#BeechBnd'><p>Beech Location Map</p></a></li>
<li><a href='#BeechGra'><p>Beech Neighborhood Information</p></a></li>
<li><a href='#bnd2gra'><p>Convert Boundary Format to Graph Format</p></a></li>
<li><a href='#colorlegend'>
<p>Plot a Color Legend</p></a></li>
<li><a href='#cprob'>
<p>Extract Contour Probabilities</p></a></li>
<li><a href='#delete.neighbor'><p>Delete Neighborhood Relations</p></a></li>
<li><a href='#DIC'>
<p>Deviance Information Criterion</p></a></li>
<li><a href='#FantasyBnd'><p>Fantasy Map</p></a></li>
<li><a href='#fitted.bayesx'>
<p>Extract BayesX Fitted Values and Residuals</p></a></li>
<li><a href='#ForestHealth'><p>Forest Health Data</p></a></li>
<li><a href='#GAMart'><p>GAM Artificial Data Set</p></a></li>
<li><a href='#GCV'>
<p>Gerneralized Cross Validation Criterion</p></a></li>
<li><a href='#GermanyBnd'><p>Germany Map</p></a></li>
<li><a href='#get.neighbor'><p>Obtain Neighbors of Given Regions</p></a></li>
<li><a href='#getscript'>
<p>Generate an executable R fitted model script</p></a></li>
<li><a href='#GRstats'>
<p>Compute Gelman and Rubin's convergence diagnostics from multicore BayesX models.</p></a></li>
<li><a href='#Interface between nb and gra format'><p>Convert nb and gra format into each other</p></a></li>
<li><a href='#Interface between sp and bnd format'><p>Convert sp and bnd format into each other</p></a></li>
<li><a href='#MunichBnd'><p>Munich Map</p></a></li>
<li><a href='#parse.bayesx.input'>
<p>Parse BayesX Input</p></a></li>
<li><a href='#plot.bayesx'>
<p>Default BayesX Plotting</p></a></li>
<li><a href='#plot2d'>
<p>2D Effect Plot</p></a></li>
<li><a href='#plot3d'>
<p>3D Effect Plot</p></a></li>
<li><a href='#plotblock'>
<p>Factor Variable and Random Effects Plots</p></a></li>
<li><a href='#plotmap'>
<p>Plot Maps</p></a></li>
<li><a href='#plotsamples'>
<p>Plot Sampling Path(s) of Coefficient(s) and Variance(s)</p></a></li>
<li><a href='#predict.bayesx'>
<p>Prediction from fitted BayesX objects</p></a></li>
<li><a href='#R2BayesX-package'>
<p>Estimate STAR Models with BayesX</p></a></li>
<li><a href='#read.bayesx.output'>
<p>Read BayesX Output from Directories</p></a></li>
<li><a href='#read.bnd'><p>Read Geographical Information in Boundary Format</p></a></li>
<li><a href='#read.gra'><p>Read Geographical Information in Graph Format</p></a></li>
<li><a href='#samples'>
<p>Extract Samples of Coefficients and Variances</p></a></li>
<li><a href='#shp2bnd'><p>convert a shape-file into a boundary object</p></a></li>
<li><a href='#sliceplot'>
<p>Plot Slices of Bivariate Functions</p></a></li>
<li><a href='#summary.bayesx'>
<p>Bayesx Summary Statistics</p></a></li>
<li><a href='#sx'>
<p>Construct BayesX Model Terms in A Formula</p></a></li>
<li><a href='#term.freqs'>
<p>Extract model term selection frequencies.</p></a></li>
<li><a href='#write.bayesx.input'>
<p>Write the BayesX Program</p></a></li>
<li><a href='#write.bnd'><p>Saving Maps in Boundary Format</p></a></li>
<li><a href='#write.gra'><p>Saving Maps in Graph Format</p></a></li>
<li><a href='#ZambiaBnd'><p>Zambia Map</p></a></li>
<li><a href='#ZambiaNutrition'><p>Determinants of Childhood Malnutrition in Zambia</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Structured Additive Regression Models with 'BayesX'</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to estimate structured additive regression (STAR) models with 'BayesX'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), BayesXsrc, colorspace, mgcv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>interp, coda, maps, MBA, parallel, sf, shapefiles, sp, spdep,
splines, spData, fields</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 06:10:31 UTC; nik</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaus Umlauf <a href="https://orcid.org/0000-0003-2160-9803"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Kneib [aut],
  Stefan Lang [aut],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolaus Umlauf &lt;Nikolaus.Umlauf@uibk.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.neighbor'>Add Neighborhood Relations</h2><span id='topic+add.neighbor'></span>

<h3>Description</h3>

<p>Adds a neighborhhod relationship between two given regions to a map object in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  add.neighbor(map, region1, region2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.neighbor_+3A_map">map</code></td>
<td>
<p>map object in graph format that should be modified.</p>
</td></tr>
<tr><td><code id="add.neighbor_+3A_region1">region1</code>, <code id="add.neighbor_+3A_region2">region2</code></td>
<td>
<p>character, names of the regions that should be connected as
neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of <code>map</code> plus the new
neighborhood relation in graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighbor">get.neighbor</a></code>, <code><a href="#topic+delete.neighbor">delete.neighbor</a></code>, <code><a href="#topic+read.gra">read.gra</a></code>,
<code><a href="#topic+write.gra">write.gra</a></code>, <code><a href="#topic+bnd2gra">bnd2gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the graph file
file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.gra")
germany &lt;- read.gra(file)

## add some neighbors
get.neighbor(germany, c("1001", "7339"))
germany &lt;- add.neighbor(germany, "7339", "1001")
get.neighbor(germany, c("1001", "7339"))
</code></pre>

<hr>
<h2 id='bayesx'>
Estimate STAR Models with BayesX
</h2><span id='topic+bayesx'></span>

<h3>Description</h3>

<p>This is the documentation of the main model fitting function of the interface. Within function
<code>bayesx</code>, three inferential concepts are available for estimation: Markov chain Monte Carlo 
simulation (MCMC), estimation based on mixed model technology and restricted maximum likelihood 
(REML), and a penalized least squares (respectively penalized likelihood) approach for 
estimating models using model selection tools (STEP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
bayesx(formula, data, weights = NULL, subset = NULL, 
  offset = NULL, na.action = NULL, contrasts = NULL, 
  control = bayesx.control(...), model = TRUE,
  chains = NULL, cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>), also see 
<code><a href="#topic+sx">sx</a></code>, <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and <code><a href="mgcv.html#topic+s">s</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_data">data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model response 
variable and covariates required by the formula. By default the variables are taken from 
<code>environment(formula)</code>: typically the environment from which <code>bayesx</code> is called. 
Argument <code>data</code> may also be a character string defining the directory the data is stored, 
where the first row in the data set must contain the variable names and columns should be tab
separated. Using this option will avoid loading the complete data into <span class="rlang"><b>R</b></span>, only the <span class="pkg">BayesX</span>
output files will be imported, which might be helpful using large datasets.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_weights">weights</code></td>
<td>
<p>prior weights on the data.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting 
process.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_offset">offset</code></td>
<td>
<p>can be used to supply a model offset for use in fitting.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>'s.
The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.omit">na.omit</a></code> if set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of 
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_control">control</code></td>
<td>
<p>specify several global control parameters for <code>bayesx</code>, see 
<code><a href="#topic+bayesx.control">bayesx.control</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <code><a href="stats.html#topic+model.frame">model.frame</a></code> should be
included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_chains">chains</code></td>
<td>
<p>integer. The number of sequential chains that should be run, the default is one
chain if <code>chains = NULL</code>. For each chain a separate seed for the random number generator is
used. The return value of <code>bayesx</code> is a list of class <code>"bayesx"</code>, i.e. each list
element represents a seperate model, for which the user can e.g. apply all plotting methods or
extractor functions. Convergence diagnostics can then be computed using function
<code><a href="#topic+GRstats">GRstats</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_cores">cores</code></td>
<td>
<p>integer. How many cores should be used? The default is one core if
<code>cores = NULL</code>. The return value is again a list of class <code>"bayesx"</code>, for which all
plotting and extractor functions can be applied, see argument <code>chains</code>. Note that this
option is not available on Windows systems, see the documentation of function
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+bayesx.control">bayesx.control</a></code>, e.g. <code>family</code> and 
<code>method</code>, defaults are <code>family = "gaussian"</code>, <code>method = "MCMC"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>In <span class="pkg">BayesX</span>, estimation of regression parameters is based on three inferential concepts: 
</p>
<p><b>Full Bayesian inference via MCMC</b>: 
A fully Bayesian interpretation of structured additive regression models is obtained by specifying 
prior distributions for all unknown parameters. Estimation can be facilitated using Markov chain 
Monte Carlo simulation techniques. <span class="pkg">BayesX</span> provides numerically efficient implementations of MCMC 
schemes for structured additive regression models. Suitable proposal densities have been developed 
to obtain rapidly mixing, well-behaved sampling schemes without the need for manual tuning. 
</p>
<p><b>Inference via a mixed model representation</b>:
The other concept used for estimation is based on mixed model methodology. Within <span class="pkg">BayesX</span>
this concept has been extended to structured additive regression models and several types of 
non-standard regression situations. The general idea is to take advantage of the close connection 
between penalty concepts and corresponding random effects distributions. The smoothing parameters 
of the penalties then transform to variance components in the random effects (mixed) model. While 
the selection of smoothing parameters has been a difficult task for a long time, several 
estimation procedures for variance components in mixed models are already available since the 
1970's. The most popular one is restricted maximum likelihood in Gaussian mixed models with 
marginal likelihood as the non-Gaussian counterpart. While regression coefficients are estimated 
based on penalized likelihood, restricted maximum likelihood or marginal likelihood estimation 
forms the basis for the determination of smoothing parameters. From a Bayesian perspective, this 
yields empirical Bayes/posterior mode estimates for the structured additive regression models. 
However, estimates can also merely be interpreted as penalized likelihood estimates from a 
frequentist perspective. 
</p>
<p><b>Penalized likelihood including variable selection</b>:
As a third alternative <span class="pkg">BayesX</span> provides a penalized least squares (respectively penalized 
likelihood) approach for estimating structured additive regression models. In addition, a powerful 
variable and model selection tool is included. Model choice and estimation of the parameters is 
done simultaneously. The algorithms are able to
</p>

<ul>
<li><p> decide whether a particular covariate enters the model,
</p>
</li>
<li><p> decide whether a continuous covariate enters the model linearly or nonlinearly,
</p>
</li>
<li><p> decide whether a spatial effect enters the model,
</p>
</li>
<li><p> decide whether a unit- or cluster specific heterogeneity effect enters the model
</p>
</li>
<li><p> select complex interaction effects (two dimensional surfaces, varying coefficient terms)
</p>
</li>
<li><p> select the degree of smoothness of nonlinear covariate, spatial or cluster specific
heterogeneity effects.
</p>
</li></ul>

<p>Inference is based on penalized likelihood in combination with fast algorithms for selecting 
relevant covariates and model terms. Different models are compared via various goodness of fit 
criteria, e.g. AIC, BIC, GCV and 5 or 10 fold cross validation. 
</p>
<p>Within the model fitting function <code>bayesx</code>, the different inferential concepts may be chosen 
by argument <code>method</code> of function <code><a href="#topic+bayesx.control">bayesx.control</a></code>. Options are <code>"MCMC"</code>, 
<code>"REML"</code> and <code>"STEP"</code>.
</p>
<p>The wrapper function <code>bayesx</code> basically starts by setting up the necessary <span class="pkg">BayesX</span>
program file using function <code><a href="#topic+bayesx.construct">bayesx.construct</a></code>, <code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code> and 
<code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code>. Afterwards the generated program file is send to the 
command-line binary executable version of <span class="pkg">BayesX</span> with <code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>.
As a last step, function <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code> will read the estimated model object
returned from <span class="pkg">BayesX</span> back into <span class="rlang"><b>R</b></span>.
</p>
<p>For estimation of STAR models, function <code>bayesx</code> uses formula syntax as provided in package 
<code><a href="mgcv.html#topic+mgcv">mgcv</a></code> (see <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>), i.e., models may be specified using
the <code><a href="#topic+R2BayesX">R2BayesX</a></code> main model term constructor functions <code><a href="#topic+sx">sx</a></code> or the
<code><a href="mgcv.html#topic+mgcv">mgcv</a></code> constructor functions <code><a href="mgcv.html#topic+s">s</a></code>. For a detailed description
of the model formula syntax used within <code>bayesx</code> models see also
<code><a href="#topic+bayesx.construct">bayesx.construct</a></code> and <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code>.
</p>
<p>After the <span class="pkg">BayesX</span> binary has successfully finished processing an object of class <code>"bayesx"</code> is
returned, wherefore a set of standard extractor functions and methods is available, including 
methods to the generic functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code> and <code><a href="stats.html#topic+fitted">fitted</a></code>.
</p>
<p>See <code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, <code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, and <code><a href="#topic+summary.bayesx">summary.bayesx</a></code> for 
more details on these methods.
</p>


<h3>Value</h3>

 
<p>A list of class <code>"bayesx"</code>, see function <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>WARNINGS</h3>

<p>For geographical effects, note that <span class="pkg">BayesX</span> may crash if the region identification covariate
is a <code><a href="base.html#topic+factor">factor</a></code>, it is recommended to code these variables as <code><a href="base.html#topic+integer">integer</a></code>,
please see the example below.
</p>


<h3>Note</h3>

<p>If a model is specified with a structured and an unstructured spatial effect, e.g. the model 
formula is something like <code>y ~ sx(id, bs = "mrf", map = MapBnd) + sx(id, bs = "re")</code>, the
model output contains of one additional total spatial effect, named with <code>"sx(id):total"</code>.
Also see the last example.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>References</h3>

<p>Belitz C, Brezger A, Kneib T, Lang S (2011). <span class="pkg">BayesX</span> - Software for Bayesian Inference in 
Structured Additive Regression Models. Version 2.0.1. 
URL <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>
<p>Belitz C, Lang S (2008). Simultaneous selection of variables and smoothing parameters in 
structured additive regression models. <em>Computational Statistics &amp; Data Analysis</em>, 
<b>53</b>, 61&ndash;81.
</p>
<p>Brezger A, Kneib T, Lang S (2005). <span class="pkg">BayesX</span>: Analyzing Bayesian Structured Additive Regression 
Models. <em>Journal of Statistical Software</em>, <b>14</b>(11), 1&ndash;22. 
URL <a href="https://www.jstatsoft.org/v14/i11/">https://www.jstatsoft.org/v14/i11/</a>.
</p>
<p>Brezger A, Lang S (2006). Generalized Structured Additive Regression Based on Bayesian P-Splines.
<em>Computational Statistics &amp; Data Analysis</em>, <b>50</b>, 947&ndash;991.
</p>
<p>Fahrmeir L, Kneib T, Lang S (2004). Penalized Structured Additive Regression for Space Time Data: 
A Bayesian Perspective. <em>Statistica Sinica</em>, <b>14</b>, 731&ndash;761.
</p>
<p>Umlauf N, Adler D, Kneib T, Lang S, Zeileis A (2015).
Structured Additive Regression Models: An R Interface to BayesX.
<em>Journal of Statistical Software</em>, <b>63</b>(21), 1&ndash;46.
<a href="https://www.jstatsoft.org/v63/i21/">https://www.jstatsoft.org/v63/i21/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code>, <code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code>,
<code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>,
<code><a href="#topic+summary.bayesx">summary.bayesx</a></code>, <code><a href="#topic+plot.bayesx">plot.bayesx</a></code>,
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, <code><a href="#topic+bayesx.construct">bayesx.construct</a></code>, <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code>,
<code><a href="#topic+sx">sx</a></code>, <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>, <code><a href="mgcv.html#topic+s">s</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 200

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate models with
## bayesx REML and MCMC
b1 &lt;- bayesx(y ~ sx(x), method = "REML", data = dat)

## same using mgcv syntax
b1 &lt;- bayesx(y ~ s(x, bs = "ps", k = 20), method = "REML", data = dat)

## now with MCMC
b2 &lt;- bayesx(y ~ sx(x), method = "MCMC", 
  iter = 1200, burnin = 200, data = dat)

## compare reported output
summary(c(b1, b2))

## plot the effect for both models
plot(c(b1, b2), residuals = TRUE)

## use confint
confint(b1, level = 0.99)
confint(b2, level = 0.99)

## Not run: 
## more examples
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
  w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
  c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate models with
## bayesx MCMC and REML
## and compare with
## mgcv gam()
b1 &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
  data = dat, method = "MCMC")
b2 &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
  data = dat, method = "REML")
b3 &lt;- gam(y ~ s(x, bs = "ps") + te(z, w, bs = "ps") + fac, 
  data = dat)

## summary statistics
summary(b1)
summary(b2)
summary(b3)

## plot the effects
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(3, 2))
plot(b1, term = "sx(x)")
plot(b1, term = "sx(z,w)")
plot(b2, term = "sx(x)")
plot(b2, term = "sx(z,w)")
plot(b3, select = 1)
vis.gam(b3, c("z","w"), theta = 40, phi = 40)
par(op)

## combine models b1 and b2
b &lt;- c(b1, b2)

## summary
summary(b)

## only plot effect 2 of both models
plot(b, term = "sx(z,w)") 

## with residuals
plot(b, term = "sx(z,w)", residuals = TRUE) 

## same model with kriging
b &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "kr") + fac, 
  method = "REML", data = dat)
plot(b)


## now a mrf example
## note: the regional identification
## covariate and the map regionnames
## should be coded as integer
set.seed(333)
     
## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); n &lt;- N*5
     
## regressors
dat &lt;- data.frame(x1 = runif(n, -3, 3),
  id = as.factor(rep(names(MunichBnd), length.out = n)))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])
     
## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + sp + rnorm(n, sd = 1.2))

## estimate models with
## bayesx MCMC and REML
b1 &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "mrf", map = MunichBnd), 
  method = "MCMC", data = dat)
b2 &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "mrf", map = MunichBnd), 
  method = "REML", data = dat)

## summary statistics
summary(b1)
summary(b2)

## plot the spatial effects
plot(b1, term = "sx(id)", map = MunichBnd, 
  main = "bayesx() MCMC estimate")
plot(b2, term = "sx(id)", map = MunichBnd, 
  main = "bayesx() REML estimate")
plotmap(MunichBnd, x = dat$sp, id = dat$id, 
  main = "Truth")

## try geosplines instead
b &lt;- bayesx(y ~ sx(id, bs = "gs", map = MunichBnd) + sx(x1), data = dat)
summary(b)
plot(b, term = "sx(id)", map = MunichBnd)

## geokriging
b &lt;- bayesx(y ~ sx(id, bs = "gk", map = MunichBnd) + sx(x1), 
  method = "REML", data = dat)
summary(b)
plot(b, term = "sx(id)", map = MunichBnd)

## perspective plot of the effect
plot(b, term = "sx(id)")

## image and contour plot 
plot(b, term = "sx(id)", image = TRUE, 
  contour = TRUE, grid = 200)


## model with random effects
set.seed(333)
N &lt;- 30
n &lt;- N*10

## regressors
dat &lt;- data.frame(id = sort(rep(1:N, n/N)), x1 = runif(n, -3, 3))
dat$re &lt;- with(dat, rnorm(N, sd = 0.6)[id])

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + re + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "re"), data = dat)
summary(b)
plot(b)

## extract estimated random effects
## and compare with true effects
plot(fitted(b, term = "sx(id)")$Mean ~ unique(dat$re))


## now a spatial example
## with structured and
## unstructered spatial 
## effect
set.seed(333)

## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); names(MunichBnd) &lt;- 1:N
n &lt;- N*5

## regressors
dat &lt;- data.frame(id = rep(1:N, n/N), x1 = runif(n, -3, 3))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])
dat$re &lt;- with(dat, rnorm(N, sd = 0.6)[id])

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + sp + re + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x1) + 
  sx(id, bs = "mrf", map = MunichBnd) +
  sx(id, bs = "re"), method = "MCMC", data = dat)
summary(b)

## plot all spatial effects
plot(b, term = "sx(id):mrf", map = MunichBnd, 
  main = "Structured spatial effect")
plot(b, term = "sx(id):re", map = MunichBnd, 
  main = "Unstructured spatial effect")
plot(b, term = "sx(id):total", map = MunichBnd, 
  main = "Total spatial effect", digits = 4)


## some experiments with the
## stepwise algorithm
## generate some data
set.seed(321)
n &lt;- 1000

## regressors
dat &lt;- data.frame(x1 = runif(n, -3, 3), x2 = runif(n),
  x3 = runif(n, 3, 6), x4 = runif(n, 0, 1))

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + 0.6 * x2 + rnorm(n, sd = 0.6))

## estimate model with STEP
b &lt;- bayesx(y ~ sx(x1) + sx(x2) + sx(x3) + sx(x4), 
  method = "STEP", algorithm = "cdescent1", CI = "MCMCselect", 
  iter = 10000, step = 10, data = dat)
summary(b)
plot(b)


## a probit example
set.seed(111)
n &lt;- 1000
dat &lt;- data.frame(x &lt;- runif(n, -3, 3))

dat$z &lt;- with(dat, sin(x) + rnorm(n))
dat$y &lt;- rep(0, n)
dat$y[dat$z &gt; 0] &lt;- 1

b &lt;- bayesx(y ~ sx(x), family = "binomialprobit", data = dat)
summary(b)
plot(b)


## estimate varying coefficient models
set.seed(333)
n &lt;- 1000
dat &lt;- data.frame(x = runif(n, -3, 3), id = factor(rep(1:4, n/4)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) * c(-1, 0.2, 1, 5)[id] + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x, by = id, center = TRUE),
  method = "REML", data = dat)
summary(b)
plot(b, resid = TRUE, cex.resid = 0.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesx_logfile'>
BayesX Log-Files 
</h2><span id='topic+bayesx_logfile'></span><span id='topic+logfile'></span>

<h3>Description</h3>

<p>Function to show the internal <span class="pkg">BayesX</span> log-files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx_logfile(x, model = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx_logfile_+3A_x">x</code></td>
<td>
<p>a fitted <code>"bayesx"</code> object.</p>
</td></tr>
<tr><td><code id="bayesx_logfile_+3A_model">model</code></td>
<td>
<p>integer, for which model the log-file should be printed, i.e. if <code>x</code>
contains more that one estimated model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-file returned from <span class="pkg">BayesX</span>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)

## now see the log-file
bayesx_logfile(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesx_prgfile'>
BayesX Program-Files 
</h2><span id='topic+bayesx_prgfile'></span><span id='topic+prgfile'></span>

<h3>Description</h3>

<p>Function to show the internal <span class="pkg">BayesX</span> program-files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx_prgfile(x, model = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx_prgfile_+3A_x">x</code></td>
<td>
<p>a fitted <code>"bayesx"</code> object.</p>
</td></tr>
<tr><td><code id="bayesx_prgfile_+3A_model">model</code></td>
<td>
<p>integer, for which model the program-file should be printed, i.e. if <code>x</code>
contains more that one estimated model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The program file used for estimation with <span class="pkg">BayesX</span>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)

## now see the prg-file
bayesx_prgfile(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesx_runtime'>
BayesX Program-Runtimes
</h2><span id='topic+bayesx_runtime'></span><span id='topic+runtime'></span>

<h3>Description</h3>

<p>Function to extract running times of the <span class="pkg">BayesX</span> binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx_runtime(x, model = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx_runtime_+3A_x">x</code></td>
<td>
<p>a fitted <code>"bayesx"</code> object.</p>
</td></tr>
<tr><td><code id="bayesx_runtime_+3A_model">model</code></td>
<td>
<p>integer, for which model the program-file should be printed, i.e. if <code>x</code>
contains more that one estimated model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The runtime of the <span class="pkg">BayesX</span> binary returned form <code><a href="base.html#topic+system.time">system.time</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)

## now see the prg-file
bayesx_runtime(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesx.construct'>
Construct BayesX Model Term Objects
</h2><span id='topic+bayesx.construct'></span><span id='topic+bayesx.construct.bl.smooth.construct'></span><span id='topic+bayesx.construct.gk.smooth.construct'></span><span id='topic+bayesx.construct.gs.smooth.construct'></span><span id='topic+bayesx.construct.mrf.smooth.construct'></span><span id='topic+bayesx.construct.ps.smooth.construct'></span><span id='topic+bayesx.construct.ra.smooth.construct'></span><span id='topic+bayesx.construct.re.smooth.construct'></span><span id='topic+bayesx.construct.rw1.smooth.construct'></span><span id='topic+bayesx.construct.rw2.smooth.construct'></span><span id='topic+bayesx.construct.tensor.smooth.construct'></span><span id='topic+bayesx.construct.t2.smooth.construct'></span><span id='topic+bayesx.construct.te.smooth.construct'></span><span id='topic+bayesx.construct.lasso.smooth.construct'></span><span id='topic+bayesx.construct.ridge.smooth.construct'></span><span id='topic+bayesx.construct.nigmix.smooth.construct'></span><span id='topic+bayesx.construct.kr.smooth.construct'></span><span id='topic+bayesx.construct.season.smooth.construct'></span><span id='topic+bayesx.construct.factor.smooth.construct'></span>

<h3>Description</h3>

<p>The function <code>bayesx.construct</code> is used to provide a flexible framework to implement 
new model term objects in <code><a href="#topic+bayesx">bayesx</a></code> within the <span class="pkg">BayesX</span> syntax. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx.construct(object, dir, prg, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx.construct_+3A_object">object</code></td>
<td>
<p>is a smooth, shrinkage or random specification object in a STAR <code>formula</code>,
generated by the <code><a href="#topic+R2BayesX">R2BayesX</a></code> model term constructor functions <code><a href="#topic+sx">sx</a></code>
(or using the constructor functions <code><a href="mgcv.html#topic+s">s</a></code> and
<code><a href="mgcv.html#topic+te">te</a></code> of the <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> package). Objects generated by
these functions have class <code>"xx.smooth.spec"</code> where <code>"xx"</code> is determined by the
<code>"bs"</code> argument of <code><a href="#topic+sx">sx</a></code> (and <code><a href="mgcv.html#topic+s">s</a></code>).</p>
</td></tr>
<tr><td><code id="bayesx.construct_+3A_dir">dir</code></td>
<td>
<p><code>character</code>, a directory where possible data should be stored, e.g. in
<code><a href="#topic+bayesx">bayesx</a></code> models, if <code>bs = "gk"</code>, <code>bs = "gs"</code> or <code>bs = "mrf"</code> is
choosen, the corresponding map will be  written as a <code>"bnd"</code> or <code>"gra"</code> file (see
<code><a href="#topic+read.bnd">read.bnd</a></code> and <code><a href="#topic+read.gra">read.gra</a></code>) to this directory, so <span class="pkg">BayesX</span> can use
this spatial object for estimation.</p>
</td></tr> 
<tr><td><code id="bayesx.construct_+3A_prg">prg</code></td>
<td>
<p>if additional data handling must be applied, e.g. storing maps (<code>"bnd"</code>) objects
in the directory specified in <code>dir</code>, <code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code> needs to write the
extra commands in a program file provided with argument <code>prg</code>, i.e. this may all be handled 
within a <code>bayesx.construct</code> constructor function.</p>
</td></tr>
<tr><td><code id="bayesx.construct_+3A_data">data</code></td>
<td>
<p>if additional data is needed to setup the <span class="pkg">BayesX</span> term it is found here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea of these constructor functions is to provide a flexible framework to implement new 
model term objects in the <span class="pkg">BayesX</span> syntax within <code><a href="#topic+bayesx">bayesx</a></code>, i.e. for any smooth or 
random term in <span class="pkg">R2BayesX</span> a constructor function like 
<code>bayesx.construct.ps.smooth.construct</code> may be provided to translate <span class="rlang"><b>R</b></span> specific syntax into 
<span class="pkg">BayesX</span> readable commands. During processing with <code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code> each model
term is constructed with <code>bayesx.construct</code> after another, wrapped into a full formula, which 
may then be send to the <span class="pkg">BayesX</span> binary with function <code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>.
</p>
<p>At the moment the following model terms are implemented:
</p>

<ul>
<li> <p><code>"rw1"</code>, <code>"rw2"</code>: Zero degree P-splines: Defines a zero degree P-spline with first or
second order difference penalty. A zero degree P-spline typically
estimates for every distinct covariate value in the dataset a separate
parameter. Usually there is no reason to prefer zero degree P-splines
over higher order P-splines. An exception are ordinal covariates or
continuous covariates with only a small number of different values.
For ordinal covariates higher order P-splines are not meaningful while
zero degree P-splines might be an alternative to modeling nonlinear
relationships via a dummy approach with completely unrestricted
regression parameters.
</p>
</li>
<li> <p><code>"season"</code>: Seasonal effect of a time scale. 
</p>
</li>
<li> <p><code>"ps"</code>, <code>"psplinerw1"</code>, <code>"psplinerw2"</code>: P-spline with first or second order 
difference penalty. 
</p>
</li>
<li> <p><code>"te"</code>, <code>"pspline2dimrw1"</code>: Defines a two-dimensional P-spline based on the tensor
product of one-dimensional P-splines with a two-dimensional first order random walk
penalty for the parameters of the spline. 
</p>
</li>
<li> <p><code>"kr"</code>, <code>"kriging"</code>: Kriging with stationary Gaussian random fields.  
</p>
</li>
<li> <p><code>"gk"</code>, <code>"geokriging"</code>: Geokriging with stationary Gaussian random fields: Estimation
is based on the centroids of a map object provided in
boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and <code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional
argument named <code>map</code> within function <code><a href="#topic+sx">sx</a></code>, or supplied within argument
<code>xt</code> when using function <code><a href="mgcv.html#topic+s">s</a></code>, e.g., <code>xt = list(map = MapBnd)</code>. 
</p>
</li>
<li> <p><code>"gs"</code>, <code>"geospline"</code>: Geosplines based on two-dimensional P-splines with a
two-dimensional first order random walk penalty for the parameters of the spline.	
Estimation is based on the coordinates of the centroids of the regions
of a map object provided in boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional argument named <code>map</code> (see above). 
</p>
</li>
<li> <p><code>"mrf"</code>, <code>"spatial"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+read.gra">read.gra</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>), as an additional argument named <code>map</code> (see above).
</p>
</li>
<li> <p><code>"bl"</code>, <code>"baseline"</code>: Nonlinear baseline effect in hazard regression or multi-state
models: Defines a P-spline with second order random walk penalty for the parameters of
the spline for the log-baseline effect <code class="reqn">log(\lambda(time))</code>. 
</p>
</li>
<li> <p><code>"factor"</code>: Special <span class="pkg">BayesX</span> specifier for factors, especially meaningful if
<code>method = "STEP"</code>, since the factor term is then treated as a full term,
which is either included or removed from the model. 
</p>
</li>
<li> <p><code>"ridge"</code>, <code>"lasso"</code>, <code>"nigmix"</code>: Shrinkage of fixed effects: defines a
shrinkage-prior for the corresponding parameters
<code class="reqn">\gamma_j</code>, <code class="reqn">j = 1, \ldots, q</code>, <code class="reqn">q \geq 1</code> of the
linear effects <code class="reqn">x_1, \ldots, x_q</code>. There are three
priors possible: ridge-, lasso- and Normal Mixture
of inverse Gamma prior.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d.\ Random effects of a unit or cluster identification covariate.
</p>
</li></ul>

<p>See function <code><a href="#topic+sx">sx</a></code> for a description of the main
<code><a href="#topic+R2BayesX">R2BayesX</a></code> model term constructor functions.
</p>


<h3>Value</h3>

<p>The model term syntax used within <span class="pkg">BayesX</span> as a character string.
</p>


<h3>WARNINGS</h3>

<p>If new <code>bayesx.construct</code> functions are implemented in future work, there may occur problems 
with reading the corresponding <span class="pkg">BayesX</span> output files with <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>,
e.g., if the new objects do not have the structure as implemented with <code>bs = "ps"</code> etc.,
i.e. function <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code> must also be adapted in such cases.
</p>


<h3>Note</h3>

<p>Using <code><a href="#topic+sx">sx</a></code> additional controlling arguments may be supplied within the dot dot dot 
&ldquo;<code>...</code>&rdquo; argument. Please see the help site for function <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code>
for a detailed description of possible optional parameters.
</p>
<p>Within the <code>xt</code> argument in function <code><a href="mgcv.html#topic+s">s</a></code>, additional
<span class="pkg">BayesX</span> specific parameters may be also supplied, see the examples below.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sx">sx</a></code>, <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code>, <code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>,
<code><a href="#topic+read.gra">read.gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bayesx.construct(sx(x1, bs = "ps"))
bayesx.construct(sx(x1, x2, bs = "te"))

## now create BayesX syntax for smooth terms
## using mgcv constructor functions
bayesx.construct(s(x1, bs = "ps"))

## for tensor product P-splines,
bayesx.construct(s(x1, x2, bs = "te"))

## increase number of knots
## for a P-spline
bayesx.construct(sx(x1, bs = "ps", nrknots = 40))

## now with degree 2 and
## penalty order 1
bayesx.construct(sx(x1, bs = "ps", knots = 40, degree = 2, order = 1))
bayesx.construct(s(x1, bs = "ps", k = 41, m = c(0, 1)))

## random walks
bayesx.construct(sx(x1, bs = "rw1"))
bayesx.construct(sx(x1, bs = "rw2"))

## shrinkage priors
bayesx.construct(sx(x1, bs = "lasso"))
bayesx.construct(sx(x1, bs = "ridge"))
bayesx.construct(sx(x1, bs = "nigmix"))

## for cox models, baseline
bayesx.construct(sx(time, bs = "bl"))

## kriging
bayesx.construct(sx(x, z, bs = "kr"))

## seasonal
bayesx.construct(sx(x, bs = "season"))

## factors
bayesx.construct(sx(id, bs = "factor"))

## now with some geographical information
## note: maps must be either supplied in
## 'bnd' or 'gra' format, also see function
## read.bnd() or read.gra()
data("MunichBnd")
bayesx.construct(sx(id, bs = "mrf", map = MunichBnd))

## same with
bayesx.construct(s(id, bs = "mrf", xt = list(map = MunichBnd)))

bayesx.construct(sx(id, bs = "gk", map = MunichBnd))
bayesx.construct(sx(id, bs = "gs", map = MunichBnd))

## also vary number of knots
bayesx.construct(sx(id, bs = "gs", knots = 10, map = MunichBnd))
bayesx.construct(s(id, bs = "gs", k = 12, m = c(1, 1), xt = list(map = MunichBnd)))

## random effects
bayesx.construct(sx(id, bs = "re"))
bayesx.construct(sx(id, bs = "re", by = x1))
bayesx.construct(sx(id, bs = "re", by = x1, xt = list(nofixed=TRUE)))

## generic
## specifies some model term
## and sets all additional arguments 
## within argument xt
## only for experimental use
bayesx.construct(sx(x, bs = "generic", dosomething = TRUE, a = 1, b = 2))
</code></pre>

<hr>
<h2 id='bayesx.control'>
Control Parameters for BayesX
</h2><span id='topic+bayesx.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of regression models
using <code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx.control(model.name = "bayesx.estim", 
  family = "gaussian", method = "MCMC", verbose = FALSE, 
  dir.rm = TRUE, outfile = NULL, replace = FALSE, iterations = 12000L,
  burnin = 2000L, maxint = NULL, step = 10L, predict = TRUE,
  seed = NULL, hyp.prior = NULL, distopt = NULL, reference = NULL,
  zipdistopt = NULL, begin = NULL, level = NULL, eps = 1e-05,
  lowerlim = 0.001, maxit = 400L, maxchange = 1e+06, leftint = NULL,
  lefttrunc = NULL, state = NULL, algorithm = NULL, criterion = NULL, 
  proportion = NULL, startmodel = NULL, trace = NULL, 
  steps = NULL, CI = NULL, bootstrapsamples = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx.control_+3A_model.name">model.name</code></td>
<td>
<p>character, specify a base name model output files are named 
with in <code>outfile</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_family">family</code></td>
<td>
<p>character, specify the distribution used for the model, options 
for all methods, <code>"MCMC"</code>, <code>"REML"</code> and <code>"STEP"</code> are: <code>"binomial"</code>,
<code>"binomialprobit"</code>, <code>"gamma"</code>, <code>"gaussian"</code>, <code>"multinomial"</code>,
<code>"poisson"</code>. For <code>"MCMC"</code> and <code>"REML"</code> only: <code>"cox"</code>, <code>"cumprobit"</code> and
<code>"multistate"</code>. For <code>"REML"</code> only use:
<code>"binomialcomploglog"</code>, <code>"cumlogit"</code>, <code>"multinomialcatsp"</code>,
<code>"multinomialprobit"</code>, <code>"seqlogit"</code>, <code>"seqprobit"</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_method">method</code></td>
<td>
<p>character, which method should be used for estimation, options 
are <code>"MCMC"</code>, <code>"HMCMC"</code> (hierarchical MCMC), <code>"REML"</code> and <code>"STEP"</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_verbose">verbose</code></td>
<td>
<p>logical, should output be printed to the <code>R</code> console 
during runtime of <code><a href="#topic+bayesx">bayesx</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_dir.rm">dir.rm</code></td>
<td>
<p>logical, should the the <code>output</code> files and directory 
removed after estimation?</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_outfile">outfile</code></td>
<td>
<p>character, specify a directory where <code><a href="#topic+bayesx">bayesx</a></code> 
should store all output files, all output files will be named with <code>model.name</code> as the 
base name.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_replace">replace</code></td>
<td>
<p>if set to <code>TRUE</code>, the files in the output directory specified in argument
<code>outfile</code> will be replaced.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_iterations">iterations</code></td>
<td>
<p>integer, sets the number of iterations for the sampler.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_burnin">burnin</code></td>
<td>
<p>integer, sets the burn-in period of the sampler.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_maxint">maxint</code></td>
<td>
<p>integer, if first or second order random walk priors are 
specified, in some cases the data will be slightly grouped: The range between the minimal and 
maximal observed covariate values will be divided into (small) intervals, and for each interval 
one parameter will be estimated. The grouping has almost no effect on estimation results as long 
as the number of intervals is large enough. With the <code>maxint</code> option the amount of grouping 
can be determined by the user. integer is the maximum number of intervals allowed. for 
equidistant data, the default <code>maxint = 150</code> for example, means that no grouping will be 
done as long as the number of different observations is equal to or below 150. for non 
equidistant data some grouping may be done even if the number of different observations is below 
150.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_step">step</code></td>
<td>
<p>integer, defines the thinning parameter for MCMC simulation.  
E.g., <code>step = 50</code> means, that only every 50th sampled parameter will be stored and used to 
compute characteristics of the posterior distribution as means, standard deviations or 
quantiles. The aim of thinning is to reach a considerable reduction of disk storing and 
autocorrelations between sampled parameters.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_predict">predict</code></td>
<td>
<p>logical, option <code>predict</code> may be specified to compute 
samples of the deviance <code>D</code>, the effective number of parameters <code>pD</code> and the deviance 
information criterion <code>DIC</code> of the model. In addition, if <code>predict = FALSE</code>, only
output files of estimated effects will be returned, otherwise an expanded dataset using all
observations would be written in the output directory, also containing the data used for
estimation. Hence, this option is useful when dealing with large data sets, that might cause
memory problems if <code>predict</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_seed">seed</code></td>
<td>
<p>integer, set the seed of the random number generator in 
<span class="pkg">BayesX</span>, usually set using function <code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_hyp.prior">hyp.prior</code></td>
<td>
<p>numeric, defines the value of the hyper-parameters <code>a</code> 
and <code>b</code> for the inverse gamma prior of the overall variance parameter <code class="reqn">\sigma^2</code>, if 
the response distribution is Gaussian. <code>numeric</code>, must be a positive real valued number.
The default is <code>hyp.prior = c(1, 0.005)</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_distopt">distopt</code></td>
<td>
<p>character, defines the implemented formulation for the negative 
binomial model if the response distribution is negative binomial. The two possibilities are to 
work with a negative binomial likelihood (<code>distopt = "nb"</code>) or to work with the Poisson 
likelihood and the multiplicative random effects (<code>distopt = "poga"</code>).</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_reference">reference</code></td>
<td>
<p>character, option <code>reference</code> is meaningful only if 
either <code>family = "multinomial"</code> or <code>family = "multinomialprobit"</code> is specified as the 
response distribution. In this case <code>reference</code> defines the <code>reference</code> category to be 
chosen. Suppose, for instance, that the response is three categorical with categories 1, 2 and 
3. Then <code>reference = 2</code> defines the value 2 to be the <code>reference</code> category.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_zipdistopt">zipdistopt</code></td>
<td>
<p>character, defines the zero inflated distribution for the 
regression analysis. The two possibilities are to work with a zero infated Poisson distribution 
(<code>zipdistopt = "zip"</code>) or to work with the zero inflated negative binomial likelihood 
(<code>zipdistopt = "zinb"</code>).</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_begin">begin</code></td>
<td>
<p>character, option <code>begin</code> is meaningful only if 
<code>family = "cox"</code> is specified as the response distribution. In this case begin specifies 
the variable that records when the observation became at risk. This option can be used to handle 
left truncation and time-varying covariates. If <code>begin</code> is not specified, all observations 
are assumed to have become at risk at time 0.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_level">level</code></td>
<td>
<p>integer, besides the posterior means and medians, <span class="pkg">BayesX</span> 
provides point-wise posterior credible intervals for every effect in the model. In a Bayesian 
approach based on MCMC simulation techniques credible intervals are estimated by computing the 
respective quantiles of the sampled effects. By default, <span class="pkg">BayesX</span> computes (point-wise) 
credible intervals for nominal levels of 80<code class="reqn">\%</code> and 95<code class="reqn">\%</code>. The option <code>level[1]</code> 
allows to redefine one of the nominal levels (95<code class="reqn">\%</code>). Adding, for instance, 
<code>level[1] = 99</code> to the options list computes credible intervals for a nominal level of 
99<code class="reqn">\%</code> rather than 95<code class="reqn">\%</code>. Similar to argument <code>level[1]</code> the option 
<code>level[2]</code> allows to redefine one of the nominal levels (80<code class="reqn">\%</code>). Adding, for instance, 
<code>level[2] = 70</code> to the options list computes credible intervals for a nominal level of 
70<code class="reqn">\%</code> rather than 80<code class="reqn">\%</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_eps">eps</code></td>
<td>
<p>numeric, defines the termination criterion of the estimation 
process. If both the relative changes in the regression coefficients and the variance parameters 
are less than <code>eps</code>, the estimation process is assumed to have converged.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_lowerlim">lowerlim</code></td>
<td>
<p>numeric, since small variances are close to the boundary of 
their parameter space, the usual fisher-scoring algorithm for their determination has to be 
modified. If the fraction of the penalized part of an effect relative to the total effect is 
less than <code>lowerlim</code>, the estimation of the corresponding variance is stopped and the 
estimator is defined to be the current value of the variance (see section 6.2 of the BayesX 
methodology manual for details).</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_maxit">maxit</code></td>
<td>
<p>integer, defines the maximum number of iterations to be used in 
estimation. Since the estimation process will not necessarily converge, it may be useful to 
define an upper bound for the number of iterations. Note, that <span class="pkg">BayesX</span> returns results 
based on the current values of all parameters even if no convergence could be achieved within 
<code>maxit</code> iterations, but a warning message will be printed in the output window.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_maxchange">maxchange</code></td>
<td>
<p>numeric, defines the maximum value that is allowed for 
relative changes in parameters in one iteration to prevent the program from crashing because of 
numerical problems. Note, that <span class="pkg">BayesX</span> produces results based on the current values of all 
parameters even if the estimation procedure is stopped due to numerical problems, but an error 
message will be printed in the output window.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_leftint">leftint</code></td>
<td>
<p>character, gives the name of the variable that contains the 
lower (left) boundary <code class="reqn">T_{lo}</code> of the interval <code class="reqn">[T_{lo}, T_{up}]</code> for an interval 
censored observation. for right censored or uncensored observations we have to specify 
<code class="reqn">T_{lo} = T_{up}</code> . If leftint is missing, all observations are assumed to be right censored 
or uncensored, depending on the corresponding value of the censoring indicator.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_lefttrunc">lefttrunc</code></td>
<td>
<p>character, option <code>lefttrunc</code> specifies the name of the 
variable containing the left truncation time <code class="reqn">T_{tr}</code>. For observations that are not 
truncated, we have to specify <code class="reqn">T_{tr} = 0</code>. If <code>lefttrunc</code> is missing, all observations 
are assumed to be not truncated. for multi-state models variable <code>lefttrunc</code> specifies the 
left endpoint of the corresponding time interval.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_state">state</code></td>
<td>
<p>character, for multi-state models, <code>state</code> specifies the 
current state variable of the process.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_algorithm">algorithm</code></td>
<td>
<p>character, specifies the selection algorithm. Possible values 
are <code>"cdescent1"</code> (adaptive algorithms in the methodology manual, see subsection 6.3), 
<code>"cdescent2"</code> (adaptive algorithms 1 and 2 with backfitting, see remarks 1 and 2 of section 
3 in Belitz and Lang (2008)), <code>"cdescent3"</code> (search according to cdescent1 followed by 
cdescent2 using the selected model in the first step as the start model) and <code>"stepwise"</code> 
(stepwise algorithm implemented in the <code>gam</code> routine of S-plus, see Chambers and 
Hastie, 1992). This option will rarely be specified by the user.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_criterion">criterion</code></td>
<td>
<p>character, specifies the goodness of fit criterion. If 
<code>criterion = "MSEP"</code> is specified the data are randomly divided into a test- and validation 
data set. The test data set is used to estimate the models and the validation data set is used 
to estimate the mean squared prediction error (MSEP) which serves as the goodness of fit 
criterion to compare different models. The proportion of data used for the test and validation 
sample can be specified using option proportion, see below. The default is to use 75<em>%</em> of 
the data for the training sample.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_proportion">proportion</code></td>
<td>
<p>numeric, this option may be used in combination with option 
<code>criterion = "MSEP"</code>, see above. In this case the data are randomly divided into a training 
and a validation sample. proportion defines the fraction (between 0 and 1) of the original data 
used as training sample.</p>
</td></tr> 
<tr><td><code id="bayesx.control_+3A_startmodel">startmodel</code></td>
<td>
<p>character, defines the start model for variable selection. 
Options are <code>"linear"</code>, <code>"empty"</code>, <code>"full"</code> and <code>"userdefined"</code>.</p>
</td></tr> 
<tr><td><code id="bayesx.control_+3A_trace">trace</code></td>
<td>
<p>character, specifies how detailed the output in the output window 
will be. Options are <code>"trace_on"</code>, <code>"trace_half"</code> and <code>"trace_off"</code>.</p>
</td></tr> 
<tr><td><code id="bayesx.control_+3A_steps">steps</code></td>
<td>
<p>integer, defines the maximum number of iterations. If the 
selection process has not converged after <code>steps</code> iterations the algorithm terminates and a 
warning is raised. Setting <code>steps = 0</code> allows the user to estimate a certain model without 
any model choice. This option will rarely be specified by the user.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_ci">CI</code></td>
<td>
<p>character, compute confidence intervals for linear and nonlinear 
terms. Option <code>CI</code> allows to compute confidence intervals. Options are <code>CI = "none"</code>, 
confidence intervals conditional on the selected model <code>CI = "MCMCselect"</code> and 
unconditional confidence intervals where model uncertainty is taken into account 
<code>CI = "MCMCbootstrap"</code>. Both alternatives are computer intensive. Conditional confidence 
intervals take much less computing time than unconditional intervals. The advantage of 
unconditional confidence intervals is that sampling distributions for the degrees of freedom or 
smoothing parameters are obtained.</p>
</td></tr> 
<tr><td><code id="bayesx.control_+3A_bootstrapsamples">bootstrapsamples</code></td>
<td>
<p>integer, defines the number of bootstrap samples used 
for <code>"CI = MCMCbootstrap"</code>.</p>
</td></tr>
<tr><td><code id="bayesx.control_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>



</table>


<h3>Value</h3>

<p>A list with the arguments specified is returned.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>References</h3>

<p>For methodological and reference details see the <span class="pkg">BayesX</span> manuals available at:  
<a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>
<p>Belitz C, Lang S (2008). Simultaneous selection of variables and smoothing parameters in 
structured additive regression models. <em>Computational Statistics &amp; Data Analysis</em>, 
<b>53</b>, 61&ndash;81.
</p>
<p>Chambers JM, Hastie TJ (eds.) (1992). <em>Statistical Models in S</em>. Chapman &amp; Hall, 
London.
</p>
<p>Umlauf N, Adler D, Kneib T, Lang S, Zeileis A (2015).
Structured Additive Regression Models: An R Interface to BayesX.
<em>Journal of Statistical Software</em>, <b>63</b>(21), 1&ndash;46.
<a href="https://www.jstatsoft.org/v63/i21/">https://www.jstatsoft.org/v63/i21/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bayesx.control()

## Not run: 
set.seed(111)
n &lt;- 500
## regressors
dat &lt;- data.frame(x = runif(n, -3, 3))
## response
dat$y &lt;- with(dat, 10 + sin(x) + rnorm(n, sd = 0.6))

## estimate models with
## bayesx MCMC and REML
b1 &lt;- bayesx(y ~ sx(x), method = "MCMC", data = dat)
b2 &lt;- bayesx(y ~ sx(x), method = "REML", data = dat)

## compare reported output
summary(b1)
summary(b2)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesx.term.options'>Show BayesX Term Options</h2><span id='topic+bayesx.term.options'></span><span id='topic+bxopts'></span>

<h3>Description</h3>

<p><span class="pkg">BayesX</span> model terms specified using functions <code><a href="#topic+sx">sx</a></code> may have 
additional optional control arguments. Therefore function 
<code>bayesx.term.options</code> displays the possible additional controlling parameters for a 
particular model term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesx.term.options(bs = "ps", method = "MCMC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesx.term.options_+3A_bs">bs</code></td>
<td>
<p>character, the term specification for which controlling parameters should be shown.</p>
</td></tr>
<tr><td><code id="bayesx.term.options_+3A_method">method</code></td>
<td>
<p>character, for which method should additional arguments be shown, options are
<code>"MCMC"</code>, <code>"REML"</code> and <code>"STEP"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At the moment the following model terms are implemented, for which additional controlling 
parameters may be specified:
</p>

<ul>
<li> <p><code>"rw1"</code>, <code>"rw2"</code>: Zero degree P-splines: Defines a zero degree P-spline with first or
second order difference penalty. A zero degree P-spline typically
estimates for every distinct covariate value in the dataset a separate
parameter. Usually there is no reason to prefer zero degree P-splines
over higher order P-splines. An exception are ordinal covariates or
continuous covariates with only a small number of different values.
For ordinal covariates higher order P-splines are not meaningful while
zero degree P-splines might be an alternative to modeling nonlinear
relationships via a dummy approach with completely unrestricted
regression parameters.
</p>
</li>
<li> <p><code>"season"</code>: Seasonal effect of a time scale. 
</p>
</li>
<li> <p><code>"ps"</code>, <code>"psplinerw1"</code>, <code>"psplinerw2"</code>: P-spline with first or second order 
difference penalty. 
</p>
</li>
<li> <p><code>"te"</code>, <code>"pspline2dimrw1"</code>: Defines a two-dimensional P-spline based on the tensor
product of one-dimensional P-splines with a two-dimensional first order random walk
penalty for the parameters of the spline. 
</p>
</li>
<li> <p><code>"kr"</code>, <code>"kriging"</code>: Kriging with stationary Gaussian random fields.  
</p>
</li>
<li> <p><code>"gk"</code>, <code>"geokriging"</code>: Geokriging with stationary Gaussian random fields: Estimation
is based on the centroids of a map object provided in
boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and <code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional
argument named <code>map</code> within function <code><a href="#topic+sx">sx</a></code>, or supplied within argument
<code>xt</code> when using function <code><a href="mgcv.html#topic+s">s</a></code>, e.g., <code>xt = list(map = MapBnd)</code>. 
</p>
</li>
<li> <p><code>"gs"</code>, <code>"geospline"</code>: Geosplines based on two-dimensional P-splines with a
two-dimensional first order random walk penalty for the parameters of the spline.	
Estimation is based on the coordinates of the centroids of the regions
of a map object provided in boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional argument named <code>map</code> (see above). 
</p>
</li>
<li> <p><code>"mrf"</code>, <code>"spatial"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+read.gra">read.gra</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>), as an additional argument named <code>map</code> (see above).
</p>
</li>
<li> <p><code>"bl"</code>, <code>"baseline"</code>: Nonlinear baseline effect in hazard regression or multi-state
models: Defines a P-spline with second order random walk penalty for the parameters of
the spline for the log-baseline effect <code class="reqn">log(\lambda(time))</code>. 
</p>
</li>
<li> <p><code>"factor"</code>: Special <span class="pkg">BayesX</span> specifier for factors, especially meaningful if
<code>method = "STEP"</code>, since the factor term is then treated as a full term,
which is either included or removed from the model. 
</p>
</li>
<li> <p><code>"ridge"</code>, <code>"lasso"</code>, <code>"nigmix"</code>: Shrinkage of fixed effects: defines a
shrinkage-prior for the corresponding parameters
<code class="reqn">\gamma_j</code>, <code class="reqn">j = 1, \ldots, q</code>, <code class="reqn">q \geq 1</code> of the
linear effects <code class="reqn">x_1, \ldots, x_q</code>. There are three
priors possible: ridge-, lasso- and Normal Mixture
of inverse Gamma prior.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d. Random effects of a unit or cluster identification covariate.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show arguments for P-splines
bayesx.term.options(bs = "ps")
bayesx.term.options(bs = "ps", method = "REML")

## Markov random fields
bayesx.term.options(bs = "mrf")
</code></pre>

<hr>
<h2 id='BeechBnd'>Beech Location Map</h2><span id='topic+BeechBnd'></span>

<h3>Description</h3>

<p>This database produces a location map of beeches around Rothenbuch, Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BeechBnd")</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of class <code>"bnd"</code> containing 83 polygon matrices with 
x-coordinates in the first and y-coordinates in the second column each. 
</p>


<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load BeechBnd and plot it
data("BeechBnd")
plotmap(BeechBnd)
</code></pre>

<hr>
<h2 id='BeechGra'>Beech Neighborhood Information</h2><span id='topic+BeechGra'></span>

<h3>Description</h3>

<p>This database produces a graph file including neighborhood information of the beech trees around 
Rothenbuch, Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BeechGra")</code></pre>


<h3>Format</h3>

<p>An adjacency matrix that represents the neighborhood structure defined in the graph file. 
</p>


<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+bnd2gra">bnd2gra</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load BeechGra adjacency matrix
data("BeechGra")
print(BeechGra)
</code></pre>

<hr>
<h2 id='bnd2gra'>Convert Boundary Format to Graph Format</h2><span id='topic+bnd2gra'></span>

<h3>Description</h3>

<p>Converts a map in boundary format to a map in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnd2gra(map, npoints = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bnd2gra_+3A_map">map</code></td>
<td>
<p>map in boundary format that should be converted.</p>
</td></tr>
<tr><td><code id="bnd2gra_+3A_npoints">npoints</code></td>
<td>
<p>integer. How many points must be shared by two polygons to be a neighbor?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of the map object in
graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code>, <code><a href="#topic+write.gra">write.gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("FantasyBnd")
plotmap(FantasyBnd, names = TRUE)
adjmat &lt;- bnd2gra(FantasyBnd)
adjmat
</code></pre>

<hr>
<h2 id='colorlegend'>
Plot a Color Legend
</h2><span id='topic+colorlegend'></span>

<h3>Description</h3>

<p>Function to generate a color legend, the legend may be added to an existing plot or drawn in a
separate plotting window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorlegend (color = NULL, ncol = NULL, x = NULL, 
  breaks = NULL, pos = "center", shift = 0.02, side.legend = 1L, 
  side.ticks = 1L, range = NULL, lrange = NULL, 
  width = 0.4, height = 0.06, scale = TRUE, xlim = NULL, 
  ylim = NULL, plot = NULL, full = FALSE, add = FALSE, 
  col.border = "black", lty.border = 1L, lwd.border = 1L, 
  ticks = TRUE, at = NULL, col.ticks = "black", lwd.ticks = 1L, 
  lty.ticks = 1L, length.ticks = 0.3, labels = NULL, 
  distance.labels = 0.8, col.labels = "black", cex.labels = 1L, 
  digits = 2L, swap = FALSE, symmetric = TRUE, xpd = NULL,
  title = NULL, side.title = 2, shift.title = c(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorlegend_+3A_color">color</code></td>
<td>
<p>character, integer. The colors for the legend, may also be a function, e.g.
<code>colors = heat.colors</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ncol">ncol</code></td>
<td>
<p>integer, the number of different colors that should be generated if <code>color</code> is a 
function.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_x">x</code></td>
<td>
<p>numeric, values for which the color legend should be drawn.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_breaks">breaks</code></td>
<td>
<p>numeric, a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_pos">pos</code></td>
<td>
<p>character, numeric. The position of the legend. Either a numeric vector, e.g.
<code>pos = c(0.1, 0.2)</code> will add the legend at the 10<code class="reqn">\%</code> point in the x-direction and at
the 20<code class="reqn">\%</code> point in the y-direction of the plotting window, may also be negative, or one of
the following: <code>"bottomleft"</code>, <code>"topleft"</code>, <code>"topright"</code>, <code>"bottomright"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code> and <code>"center"</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_shift">shift</code></td>
<td>
<p>numeric, if argument <code>pos</code> is a character, <code>shift</code> determines the distance
of the legend from the plotting box.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.legend">side.legend</code></td>
<td>
<p>integer, if set to <code>2</code> the legend will be flipped by 90 degrees.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.ticks">side.ticks</code></td>
<td>
<p>integer, if set to <code>2</code>, the ticks and labels will be on the opposite site
of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_range">range</code></td>
<td>
<p>numeric, specifies a range for <code>x</code> values for which the legend should be drawn.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lrange">lrange</code></td>
<td>
<p>numeric, specifies the range of legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_width">width</code></td>
<td>
<p>numeric, the width of the legend, if <code>scale = TRUE</code> the width is proportional to
the x-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_height">height</code></td>
<td>
<p>numeric, the height of the legend, if <code>scale = TRUE</code> the height is proportional
to the y-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_scale">scale</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, the <code>width</code> and <code>height</code> of the legend will
be calculated proportional to the x- and y-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_xlim">xlim</code></td>
<td>
<p>numeric, the x-limits of the plotting window the legend should be added for, numeric
vector, e.g., returned from function <code><a href="base.html#topic+range">range</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ylim">ylim</code></td>
<td>
<p>numeric, the y-limits of the plotting window the legend should be added for, numeric
vector, e.g., returned from function <code><a href="base.html#topic+range">range</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_plot">plot</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, the legend will be drawn in a separate plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_full">full</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, the legend will be drawn using the full window range.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_add">add</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, the legend will be added to an existing plot.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.border">col.border</code></td>
<td>
<p>the color of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lty.border">lty.border</code></td>
<td>
<p>the line type of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lwd.border">lwd.border</code></td>
<td>
<p>the line width of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ticks">ticks</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, ticks will be added to the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_at">at</code></td>
<td>
<p>numeric, specifies at which locations ticks and labels should be added.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.ticks">col.ticks</code></td>
<td>
<p>the colors of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lwd.ticks">lwd.ticks</code></td>
<td>
<p>the line width of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lty.ticks">lty.ticks</code></td>
<td>
<p>the line type of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_length.ticks">length.ticks</code></td>
<td>
<p>numeric, the length of the ticks as percentage of the <code>height</code> or
<code>width</code> of the colorlegend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_labels">labels</code></td>
<td>
<p>character, specifies labels that should be added to the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_distance.labels">distance.labels</code></td>
<td>
<p>numeric, the distance of the labels to the ticks, proportional to the
length of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.labels">col.labels</code></td>
<td>
<p>the colors of the labels.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_cex.labels">cex.labels</code></td>
<td>
<p>text size of the labels.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_digits">digits</code></td>
<td>
<p>integer, the decimal places if labels are numerical.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_swap">swap</code></td>
<td>
<p>logical, if set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_symmetric">symmetric</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, a symmetric legend will be drawn corresponding to
the <code>+- max(abs(x))</code> value.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_xpd">xpd</code></td>
<td>
<p>sets the <code>xpd</code> parameter in function <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_title">title</code></td>
<td>
<p>character, a title for the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.title">side.title</code></td>
<td>
<p>integer, <code>1</code> or <code>2</code>. Specifies where the legend is placed, either on
top if <code>side.title = 1</code> or at the bottom if <code>side.title = 2</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_shift.title">shift.title</code></td>
<td>
<p>numeric vector of length 2. Specifies a possible shift of the title in either
x- or y-direction.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_...">...</code></td>
<td>
<p>other graphical parameters to be passed to function <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> with the colors generated, the breaks and the function <code>map</code>, which may 
be used for mapping of <code>x</code> values to the colors specified in argument <code>colors</code>, please 
see the examples below.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## play with colorlegend
colorlegend()
colorlegend(side.legend = 2)
colorlegend(side.legend = 2, side.ticks = 2)
colorlegend(height = 2)
colorlegend(width = 1, height = 0.8, scale = FALSE, 
  pos = c(0, 0.2), length.ticks = 0.5)
colorlegend(color = heat.colors, ncol = 9)
colorlegend(color = heat.colors, ncol = 9, swap = TRUE)
colorlegend(pos = "bottomleft")
colorlegend(pos = "topleft")
colorlegend(pos = "topright")
colorlegend(pos = "bottomright")


## take x values for the color legend
x &lt;- runif(100, -2, 2)
colorlegend(color = diverge_hcl, x = x)
colorlegend(color = diverge_hcl, x = x, at = c(-1.5, 0, 1.5))
colorlegend(color = diverge_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"))
colorlegend(color = rainbow_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5)
colorlegend(color = heat_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2)
colorlegend(color = topo.colors, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3))
colorlegend(color = diverge_hsv, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2))
colorlegend(color = diverge_hsv, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2),
  ncol = 3)
colorlegend(color = c("red", "white", "red"), x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2),
  ncol = 3, breaks = c(-2, -1, 1, 2))
colorlegend(color = diverge_hcl, x = x, range = c(-3, 3))
colorlegend(color = diverge_hcl, x = x, range = c(-3, 3), lrange = c(-6, 6))


## combine plot with color legend
n &lt;- 100
x &lt;- y &lt;- seq(-3, 3, length.out = n)
z &lt;- outer(sin(x), cos(x)) 
pal &lt;- colorlegend(color = diverge_hcl, x = z, plot = FALSE)
op &lt;- par(no.readonly = TRUE)
par(mar = c(4.1, 4.1, 1.1, 1.1))
layout(matrix(c(1, 2), nrow = 1), widths = c(1, 0.3))
image(x = x, y = y, z = z, col = pal$colors, breaks = pal$breaks)
par(mar = c(4.1, 0.1, 1.1, 3.1))
colorlegend(color = diverge_hcl, x = z, plot = TRUE, full = TRUE,
  side.legend = 2, side.ticks = 2)
par(op)


## another example with different plot
n &lt;- 50
x &lt;- sin(seq(-3, 3, length.out = n)) 
pal &lt;- colorlegend(color = diverge_hcl, x = x, plot = FALSE)
op &lt;- par(no.readonly = TRUE)
par(mar = c(7.1, 4.1, 1.1, 1.1))
barplot(x, border = "transparent", col = pal$map(x))
colorlegend(color = diverge_hcl, x = x, plot = FALSE, add = TRUE,
  xlim = c(0, 60), ylim = c(-1, 1), pos = c(0, -0.15), xpd = TRUE,
  scale = FALSE, width = 60, height = 0.15,
  at = seq(min(x), max(x), length.out = 9))
par(op)
</code></pre>

<hr>
<h2 id='cprob'>
Extract Contour Probabilities  
</h2><span id='topic+cprob'></span>

<h3>Description</h3>

<p>Function to extract estimated contour probabilities of a particular effect estimated with 
P-splines using Markov chain Monte Carlo (MCMC) estimation techniques. Note that, the contour
probability option must be specified within function <code><a href="#topic+sx">sx</a></code>, see the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cprob(object, model = NULL, term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cprob_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="cprob_+3A_model">model</code></td>
<td>
<p>for which model the contour probabilities should be provided, either an integer or a 
character, e.g. <code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="cprob_+3A_term">term</code></td>
<td>
<p>if not <code>NULL</code>, the function will search for the term contour probabilities should
be extracted for, either an integer or a character, eg <code>term = "s(x)"</code>.</p>
</td></tr>
<tr><td><code id="cprob_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>References</h3>

<p>Brezger, A., Lang, S. (2008): Simultaneous probability statements for Bayesian P-splines. 
<em>Statistical Modeling</em>, <b>8</b>, 141&ndash;186.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
## need to set the contourprob option, 
## otherwise BayesX will not calculate probabilities
## see also the reference manual of BayesX available
## at www.BayesX.org
b &lt;- bayesx(y ~ sx(x, bs = "ps", contourprob = 4), data = dat)

## extract contour probabilities
cprob(b, term = "sx(x)")

## End(Not run)
</code></pre>

<hr>
<h2 id='delete.neighbor'>Delete Neighborhood Relations</h2><span id='topic+delete.neighbor'></span>

<h3>Description</h3>

<p>Adds the neighborhhod relationship between two given regions from a map object in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.neighbor(map, region1, region2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.neighbor_+3A_map">map</code></td>
<td>
<p>map object in graph format that should be modified.</p>
</td></tr>
<tr><td><code id="delete.neighbor_+3A_region1">region1</code>, <code id="delete.neighbor_+3A_region2">region2</code></td>
<td>
<p>names of the regions that should no longer be regarded as neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure of <code>map</code> minus the
deleted neighborhood relation in graph format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighbor">get.neighbor</a></code>, <code><a href="#topic+add.neighbor">add.neighbor</a></code>, <code><a href="#topic+read.gra">read.gra</a></code>,
<code><a href="#topic+write.gra">write.gra</a></code>, <code><a href="#topic+bnd2gra">bnd2gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the graph file
file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.gra")
germany &lt;- read.gra(file)

## delete some neighbors
get.neighbor(germany, c("7339"))
germany &lt;- delete.neighbor(germany, "7339", "7141")
get.neighbor(germany, c("7339"))
</code></pre>

<hr>
<h2 id='DIC'>
Deviance Information Criterion
</h2><span id='topic+DIC'></span><span id='topic+DIC.bayesx'></span>

<h3>Description</h3>

<p>Generic function returning the deviance information criteriom of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, ...)

## S3 method for class 'bayesx'
DIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>specify for which model the criterion should be returned, e.g. type <code>model = 1</code>
to obtain the value for the first model. Only meaningful if <code>object</code> contains of more than 
one model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(121)
n &lt;- 200

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3))

## generate response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat, method = "MCMC")

## extract DIC
DIC(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='FantasyBnd'>Fantasy Map</h2><span id='topic+FantasyBnd'></span>

<h3>Description</h3>

<p>This database produces a fantasy map of 10 regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("FantasyBnd")</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of class <code>"bnd"</code> containing 10 polygon matrices with 
x-coordinates in the first and y-coordinates in the second column each. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load FantasyBnd and plot it
data("FantasyBnd")
plotmap(FantasyBnd)
</code></pre>

<hr>
<h2 id='fitted.bayesx'>
Extract BayesX Fitted Values and Residuals
</h2><span id='topic+fitted.bayesx'></span><span id='topic+residuals.bayesx'></span>

<h3>Description</h3>

<p>Extractor functions to the fitted values/model residuals of the estimated model with 
<code><a href="#topic+bayesx">bayesx</a></code> and fitted model term partial effects/residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesx'
fitted(object, model = NULL, term = NULL, ...)

## S3 method for class 'bayesx'
residuals(object, model = NULL, term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bayesx_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="fitted.bayesx_+3A_model">model</code></td>
<td>
<p>for which model the fitted values/residuals should be provided, either an integer or 
a character, e.g. <code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="fitted.bayesx_+3A_term">term</code></td>
<td>
<p>if not <code>NULL</code>, the function will search for the term fitted values/residuals 
specified here, either an integer or a character, eg <code>term = "sx(x)"</code>.</p>
</td></tr>
<tr><td><code id="fitted.bayesx_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>For <code>fitted.bayesx</code>, either the fitted linear predictor and mean or if e.g. 
<code>term = "sx(x)"</code>, an object with class <code>"xx.bayesx"</code>, where <code>"xx"</code> is depending of 
the type of the term. In principle the returned term object is simply a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
containing the covariate(s) and its effects, depending on the estimation method, e.g. for MCMC
estimated models, mean/median fitted values and other quantities are returned. Several additional
informations on the term are provided in the <code><a href="base.html#topic+attributes">attributes</a></code> of the object. For all types
of terms plotting functions are provided, see function <code><a href="#topic+plot.bayesx">plot.bayesx</a></code>.
</p>
<p>Using <code>residuals.bayesx</code> will either return the mean model residuals or the mean partial 
residuals of a term specified in argument <code>term</code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(121)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, 0, 1),
  w = runif(n, 0, 3))

## generate response 
dat$y &lt;- with(dat, 1.5 + sin(x) + z -3 * w + rnorm(n, sd = 0.6))

## estimate model
b1 &lt;- bayesx(y ~ sx(x) + z + w, data = dat)

## extract fitted values
fit &lt;- fitted(b1)
hist(fit, freq = FALSE)

## now extract 1st model term
## and plot it
fx &lt;- fitted(b1, term = "sx(x)")
plot(fx)

## extract model residuals
hist(residuals(b1))

## extract partial residuals for sx(x)
pres &lt;- residuals(b1, term = "sx(x)")
plot(fx, ylim = range(pres[, 2]))
points(pres)

## End(Not run)

## now another example with
## use of read.bayesx.output
## load example data from
## package R2BayesX
dir &lt;- file.path(find.package("R2BayesX"), "examples", "ex01")
b2 &lt;- read.bayesx.output(dir)

## extract fitted values
hist(fitted(b2))

## extract model term of x
## and plot it
fx &lt;- fitted(b2, term = "sx(x)")
plot(fx)


## have a look at the attributes
names(attributes(fx))

## extract the sampling path of the variance
spv &lt;- attr(fx, "variance.sample")
plot(spv, type = "l")


## Not run: 
## combine model objects
b &lt;- c(b1, b2)

## extract fitted terms for second model
fit &lt;- fitted(b, model = 2, term = 1:2)
names(fit)
plot(fit["sx(id)"])

## End(Not run)
</code></pre>

<hr>
<h2 id='ForestHealth'>Forest Health Data</h2><span id='topic+ForestHealth'></span><span id='topic+forest'></span>

<h3>Description</h3>

<p>The data set consists of 16 variables with 1796 observations on forest health to identify 
potential factors influencing the health status of trees and therefore the vital status of the 
forest. In addition to covariates characterizing a tree and its stand, the exact locations of the 
trees are known. The interest is on detecting temporal and spatial trends while accounting for 
further covariate effects in a flexible manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ForestHealth")</code></pre>


<h3>Format</h3>

<p>A data frame containing 1793 observations on 16 variables.
</p>

<dl>
<dt>id:</dt><dd><p>tree location identification number.</p>
</dd>
<dt>year:</dt><dd><p>year of census.</p>
</dd>
<dt>defoliation:</dt><dd><p>percentage of tree defoliation in three ordinal categories, 
&lsquo;defoliation &lt; 12.5%&rsquo;, &lsquo;12.5% &lt;= defoliation &lt; 50%&rsquo; and  &lsquo;defoliation &gt;= 50%&rsquo;</p>
</dd>
<dt>x:</dt><dd><p>x-coordinate of the tree location.</p>
</dd>
<dt>y:</dt><dd><p>y-coordinate of the tree location.</p>
</dd>
<dt>age:</dt><dd><p>age of stands in years.</p>
</dd>
<dt>canopy:</dt><dd><p>forest canopy density in percent.</p>
</dd>
<dt>inclination:</dt><dd><p>slope inclination in percent.</p>
</dd>
<dt>elevation:</dt><dd><p>elevation (meters above sea level).</p>
</dd>
<dt>soil:</dt><dd><p>soil layer depth in cm.</p>
</dd>
<dt>ph:</dt><dd><p>soil pH at 0-2cm depth.</p>
</dd>
<dt>moisture:</dt><dd><p>soil moisture level with categories &lsquo;moderately dry&rsquo;, &lsquo;moderately moist&rsquo; and
&lsquo;moist or temporarily wet&rsquo;.</p>
</dd>
<dt>alkali:</dt><dd><p>proportion of base alkali-ions with categories &lsquo;very low&rsquo;, &lsquo;low&rsquo;, &lsquo;high&rsquo; and
&lsquo;very high&rsquo;.</p>
</dd>
<dt>humus:</dt><dd><p>humus layer thickness in cm, categorical coded.</p>
</dd>
<dt>stand:</dt><dd><p>stand type with categories &lsquo;deciduous&rsquo; and &lsquo;mixed&rsquo;.</p>
</dd>
<dt>fertilized:</dt><dd><p>fertilization applied with categories &lsquo;yes&rsquo; and &lsquo;no&rsquo;.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>References</h3>

<p>Kneib, T. &amp; Fahrmeir, L. (2010): A Space-Time Study on Forest Health. In: Chandler, R. E. &amp; 
Scott, M. (eds.): Statistical Methods for Trend Detection and Analysis in the Environmental 
Sciences, Wiley.
</p>
<p>G\&quot;ottlein A, Pruscha H (1996). Der Einfuss von Bestandskenngr\&quot;ossen, Topographie, Standord und 
Witterung auf die Entwicklung des Kronenzustandes im Bereich des Forstamtes Rothenbuch. 
<em>Forstwissens. Zent.</em>, <b>114</b>, 146&ndash;162.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load zambia data and map
data("ForestHealth")
data("BeechBnd")

fm &lt;- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  sx(age) + sx(inclination) + sx(canopy) +
  sx(year) + sx(elevation),
  family = "cumlogit", method = "REML", data = ForestHealth)

summary(fm)
plot(fm, term = c("sx(age)", "sx(inclination)", 
  "sx(canopy)", "sx(year)", "sx(elevation)"))

## End(Not run)
</code></pre>

<hr>
<h2 id='GAMart'>GAM Artificial Data Set</h2><span id='topic+GAMart'></span><span id='topic+gamart'></span>

<h3>Description</h3>

<p>This is an artificial data set mainly used to test the <span class="pkg">R2BayesX</span> interfacing functions. The
data includes three different types of response variables. One numeric, one binomial and a
categorical response with 4 different levels. In addition, several numeric and factor covariates
are provided. The data set is constructed such that the observations are based upon different
locations (pixels in &lsquo;longitude&rsquo; and &lsquo;latitude&rsquo; coordinates) obtained from a regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GAMart")</code></pre>


<h3>Format</h3>

<p>A data frame containing 500 observations on 12 variables.
</p>

<dl>
<dt>num:</dt><dd><p>numeric, response variable.</p>
</dd>
<dt>bin:</dt><dd><p>factor, binomial response variable with levels <code>"no"</code> and <code>"yes"</code>.</p>
</dd>
<dt>cat:</dt><dd><p>factor, multi categorical response with levels <code>"none"</code>, <code>"low"</code>,
<code>"medium"</code> and <code>"high"</code>.</p>
</dd>
<dt>x1:</dt><dd><p>numeric covariate.</p>
</dd>
<dt>x2:</dt><dd><p>numeric covariate.</p>
</dd>
<dt>x3:</dt><dd><p>numeric covariate.</p>
</dd>
<dt>fac:</dt><dd><p>factor covariate with levels <code>"low"</code>, <code>"medium"</code> and <code>"high"</code>.</p>
</dd>
<dt>id:</dt><dd><p>factor, pixel identification index.</p>
</dd>
<dt>long:</dt><dd><p>numeric, the longitude coordinate of the pixel.</p>
</dd>
<dt>lat:</dt><dd><p>numeric, the latitude coordinate of the pixel.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("GAMart")

## normal response
b &lt;- bayesx(num ~ fac + sx(x1) + sx(x2) + sx(x3) +
  sx(long, lat, bs = "te") + sx(id, bs = "re"),
  data = GAMart)
summary(b)
plot(b)

## binomial response
b &lt;- bayesx(bin ~ fac + sx(x1) + sx(x2) + sx(x3) +
  sx(long, lat, bs = "te") + sx(id, bs = "re"),
  data = GAMart, family = "binomial", method = "REML")
summary(b)
plot(b)

## categorical response
b &lt;- bayesx(cat ~ fac + sx(x1) + sx(x2) + sx(x3) +
  sx(long, lat, bs = "te") + sx(id, bs = "re"),
  data = GAMart, family = "cumprobit", method = "REML")
summary(b)
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='GCV'>
Gerneralized Cross Validation Criterion
</h2><span id='topic+GCV'></span><span id='topic+GCV.bayesx'></span>

<h3>Description</h3>

<p>Generic function returning the generalized cross validation criterium of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GCV(object, ...)

## S3 method for class 'bayesx'
GCV(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GCV_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="GCV_+3A_...">...</code></td>
<td>
<p>specify for which model the criterion should be returned, e.g. type <code>model = 1</code>
to obtain the value for the first model. Only meaningful if <code>object</code> contains of more than 
one model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(121)
n &lt;- 200

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3))

## generate response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat, method = "REML")

## extract GCV
GCV(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='GermanyBnd'>Germany Map</h2><span id='topic+GermanyBnd'></span>

<h3>Description</h3>

<p>This database produces a map of Germany since 2001 containing 439 administrative districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GermanyBnd")</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of class <code>"bnd"</code> containing 466 polygon matrices with 
x-coordinates in the first and y-coordinates in the second column each. 
</p>


<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load GermanyBnd and plot it
data("GermanyBnd")
plotmap(GermanyBnd)
</code></pre>

<hr>
<h2 id='get.neighbor'>Obtain Neighbors of Given Regions</h2><span id='topic+get.neighbor'></span>

<h3>Description</h3>

<p>Extracts the neighbors of a number of regions from a map in graph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get.neighbor(map, regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.neighbor_+3A_map">map</code></td>
<td>
<p>map object in graph format.</p>
</td></tr>
<tr><td><code id="get.neighbor_+3A_regions">regions</code></td>
<td>
<p>vector of names of regions for which the neighbors should be axtracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors containing the neighbors of the elements in <code>regions</code>.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Thomas Kneib.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.neighbor">add.neighbor</a></code>, <code><a href="#topic+delete.neighbor">delete.neighbor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.gra")
germany &lt;- read.gra(file)
get.neighbor(germany, "1001")
get.neighbor(germany, c("1001", "7339"))
</code></pre>

<hr>
<h2 id='getscript'>
Generate an executable R fitted model script  
</h2><span id='topic+getscript'></span>

<h3>Description</h3>

<p>The function generates an executable <span class="rlang"><b>R</b></span> script for obtaining summary statistics, visualization
of model diagnostics and term effect plots of a fitted <code><a href="#topic+bayesx">bayesx</a></code> model object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getscript(object, file = NULL, device = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getscript_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="getscript_+3A_file">file</code></td>
<td>
<p>optional, an output file the script is written to.</p>
</td></tr>
<tr><td><code id="getscript_+3A_device">device</code></td>
<td>
<p>a graphical device function, e.g. <code><a href="grDevices.html#topic+pdf">pdf</a></code>, see the examples
and the help site of <code><a href="grDevices.html#topic+Devices">Devices</a></code> for all available devices. If set, the 
script will have extra calls to the specified devices that will generate graphics to the 
specified <code>file</code>. If <code>file = NULL</code>, the working directory is taken.</p>
</td></tr>
<tr><td><code id="getscript_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>devices</code>, e.g. <code>height</code> and <code>width</code> of a graphical
device.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)

## generate the R script
## and print it
script &lt;- getscript(b)
script

## with a pdf device
script &lt;- getscript(b, device = pdf, height = 5, width = 6)
script

## End(Not run)
</code></pre>

<hr>
<h2 id='GRstats'>
Compute Gelman and Rubin's convergence diagnostics from multicore BayesX models.
</h2><span id='topic+GRstats'></span>

<h3>Description</h3>

<p>This function takes a fitted <code><a href="#topic+bayesx">bayesx</a></code> object estimated with multiple chains/cores and
computes the Gelman and Rubin's convergence diagnostic of the model parameters using function
<code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code> provided in package <span class="pkg">coda</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRstats(object, term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRstats_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>, returned from the model fitting function
<code><a href="#topic+bayesx">bayesx</a></code> using the multiple chain or core option.</p>
</td></tr>
<tr><td><code id="GRstats_+3A_term">term</code></td>
<td>
<p>character or integer. The term for which the diagnostics should be computed, 
see also function <code><a href="#topic+samples">samples</a></code>.</p>
</td></tr>
<tr><td><code id="GRstats_+3A_...">...</code></td>
<td>
<p>arguments passed to function <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object returned from <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>, <code><a href="#topic+samples">samples</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
   w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
   c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
   data = dat, method = "MCMC", chains = 3)

## obtain Gelman and Rubin's convergence diagnostics
GRstats(b, term = c("sx(x)", "sx(z,w)"))
GRstats(b, term = c("linear-samples", "var-samples"))

## of all parameters
GRstats(b, term = c("sx(x)", "sx(z,w)",
  "linear-samples", "var-samples"))

## End(Not run)
</code></pre>

<hr>
<h2 id='Interface+20between+20nb+20and+20gra+20format'>Convert nb and gra format into each other</h2><span id='topic+nb2gra'></span><span id='topic+gra2nb'></span>

<h3>Description</h3>

<p>Convert neighborhood structure objects of class <code>"nb"</code> from R-package <span class="pkg">spdep</span> to graph
objects of class <code>"gra"</code> from R-package <span class="pkg">R2BayesX</span> and vice versa.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2gra(nbObject)
gra2nb(graObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interface+2B20between+2B20nb+2B20and+2B20gra+2B20format_+3A_nbobject">nbObject</code></td>
<td>
<p>neighborhood structure object of class <code>"nb"</code></p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20nb+2B20and+2B20gra+2B20format_+3A_graobject">graObject</code></td>
<td>
<p>graph object of class <code>"gra"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent object in the other format.
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp2bnd">sp2bnd</a></code>, <code><a href="#topic+bnd2sp">bnd2sp</a></code> for conversion between the geographical information
formats and <code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+write.gra">write.gra</a></code> for the interface to the
<span class="pkg">R2BayesX</span> files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## first nb to gra:
if(requireNamespace("spdep") &amp;
  requireNamespace("rgdal") &amp;
  requireNamespace("spData")) {
  library("spdep")
  library("spData")
  library("rgdal")

  columbus &lt;- readOGR(system.file("shapes/columbus.shp", package="spData")[1])

  colNb &lt;- poly2nb(columbus)

  ## ... here manual editing is possible ...
  ## then export to graph format
  colGra &lt;- nb2gra(colNb)

  ## and save in BayesX file
  graFile &lt;- tempfile()
  write.gra(colGra, file=graFile)

  ## now back from gra to nb:
  colGra &lt;- read.gra(graFile)
  newColNb &lt;- gra2nb(colGra)
  newColNb

  ## compare this with the original
  colNb

  ## only the call attribute does not match (which is OK):
  all.equal(newColNb, colNb, check.attributes = FALSE)
  attr(newColNb, "call")
  attr(colNb, "call")
}
## End(Not run)
</code></pre>

<hr>
<h2 id='Interface+20between+20sp+20and+20bnd+20format'>Convert sp and bnd format into each other</h2><span id='topic+sp2bnd'></span><span id='topic+bnd2sp'></span>

<h3>Description</h3>

<p>Convert geographical information objects of class <code>"SpatialPolygons"</code> (or specializations)
from <span class="rlang"><b>R</b></span>-package <span class="pkg">sp</span> to objects of class <code>"bnd"</code> from <span class="rlang"><b>R</b></span>-package <span class="pkg">R2BayesX</span> and vice
versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2bnd(spObject, regionNames, height2width, epsilon)
bnd2sp(bndObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_spobject">spObject</code></td>
<td>
<p>object of class <code>"SpatialPolygons"</code> (or specializations).</p>
</td></tr> 
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_regionnames">regionNames</code></td>
<td>
<p>character vector of region names (parallel to the Polygons list in spObject), 
defaults to the IDs.</p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_height2width">height2width</code></td>
<td>
<p>ratio of total height to width, defaults to the bounding box values.</p>
</td></tr>
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_epsilon">epsilon</code></td>
<td>
<p>how much can two polygons differ (in maximum squared Euclidean distance) and still
match each other?, defaults to machine precision.</p>
</td></tr> 
<tr><td><code id="Interface+2B20between+2B20sp+2B20and+2B20bnd+2B20format_+3A_bndobject">bndObject</code></td>
<td>
<p>object of class <code>"bnd"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent object in the other format.  
</p>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2gra">nb2gra</a></code>, <code><a href="#topic+gra2nb">gra2nb</a></code> for conversion between the neighborhood structure
formats and <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code> for the interface to the
<span class="pkg">R2BayesX</span> files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## bnd to sp:
file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.bnd")
germany &lt;- read.bnd(file)
spGermany &lt;- bnd2sp(germany)

## plot the result together with the neighborhood graph
if(requireNamespace("spdep")) {
  library("spdep")
  plot(spGermany)
  nbGermany &lt;- poly2nb(spGermany)
  plot(nbGermany, coords = coordinates(spGermany), add = TRUE)

  ## example with one region inside another
  spExample &lt;- spGermany[c("7231", "7235"), ]
  plot(spExample)
  plot(poly2nb(spExample), coords = coordinates(spExample), add = TRUE)

  ## now back from sp to bnd:
  bndGermany &lt;- sp2bnd(spGermany)
  plotmap(bndGermany)

  ## compare names and number of polygons
  stopifnot(
    identical(names(bndGermany), names(germany)),
    identical(length(bndGermany), length(germany))
  )
}
## End(Not run)
</code></pre>

<hr>
<h2 id='MunichBnd'>Munich Map</h2><span id='topic+MunichBnd'></span>

<h3>Description</h3>

<p>This database produces a city map of Munich containing 105 administrative districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MunichBnd")</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of class <code>"bnd"</code> containing 106 polygon matrices with 
x-coordinates in the first and y-coordinates in the second column each. 
</p>


<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load MunichBnd and plot it
data("MunichBnd")
plotmap(MunichBnd)
</code></pre>

<hr>
<h2 id='parse.bayesx.input'>
Parse BayesX Input
</h2><span id='topic+parse.bayesx.input'></span>

<h3>Description</h3>

<p>Funtion to parse <code>bayesx</code> input parameters which are then send to 
<code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.bayesx.input(formula, data, weights = NULL, 
  subset = NULL, offset = NULL, na.action = na.fail, 
  contrasts = NULL, control = bayesx.control(...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.bayesx.input_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>). For more details see 
<code><a href="#topic+bayesx">bayesx</a></code> and <code><a href="#topic+sx">sx</a></code>.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_data">data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model response 
variable and covariates required by the formula. By default the variables are taken from 
<code>environment(formula)</code>: typically the environment from which <code>bayesx</code> is called. 
Argument <code>data</code> may also be a character string defining the directory the data is stored, 
where the first row in the data set must contain the variable names and columns should be tab
separated.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_weights">weights</code></td>
<td>
<p>prior weights on the data.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting 
process.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_offset">offset</code></td>
<td>
<p>can be used to supply a model offset for use in fitting.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of 
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_control">control</code></td>
<td>
<p>specify several global control parameters for <code>bayesx</code>, see 
<code><a href="#topic+bayesx.control">bayesx.control</a></code>.</p>
</td></tr>
<tr><td><code id="parse.bayesx.input_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+bayesx.control">bayesx.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>"bayesx.input"</code> which is send to <code><a href="#topic+write.bayesx.input">write.bayesx.input</a></code> 
for processing within <code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse.bayesx.input(y ~ x1 + sx(x2), data = "")
</code></pre>

<hr>
<h2 id='plot.bayesx'>
Default BayesX Plotting
</h2><span id='topic+plot.bayesx'></span>

<h3>Description</h3>

<p>Generic functions for plotting objects of class <code>"bayesx"</code> and model term classes 
<code>"geo.bayesx"</code>, <code>"linear.bayesx"</code>, <code>"mrf.bayesx"</code>, <code>"random.bayesx"</code> and
<code>"sm.bayesx"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesx'
plot(x, model = NULL, term = NULL, which = 1L, ask = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bayesx_+3A_x">x</code></td>
<td>
<p>a fitted <code><a href="#topic+bayesx">bayesx</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.bayesx_+3A_model">model</code></td>
<td>
<p>for which model the plot should be provided, either an integer or a character, e.g. 
<code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesx_+3A_term">term</code></td>
<td>
<p>the term that should be plotted, either an integer or a character, e.g. 
<code>term = "sx(x)"</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesx_+3A_which">which</code></td>
<td>
<p>choose the type of plot that should be drawn, possible options are: <code>"effect"</code>,
<code>"coef-samples"</code>, <code>"var-samples"</code>, <code>"intcpt-samples"</code>, <code>"hist-resid"</code>, 
<code>"qq-resid"</code>, <code>"scatter-resid"</code>, <code>"scale-resid"</code>, <code>"max-acf"</code>. Argument 
<code>which</code> may also be specified as integer, e.g. <code>which = 1</code>. The first three arguments 
are all model term specific. For the residual model diagnostic plot options <code>which</code> 
may be set with <code>which = 5:8</code>.</p>
</td></tr>
<tr><td><code id="plot.bayesx_+3A_ask">ask</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="plot.bayesx_+3A_...">...</code></td>
<td>
<p>other graphical parameters passed to <code><a href="#topic+plotblock">plotblock</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>, 
<code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="stats.html#topic+acf">acf</a></code> and 
<code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the class of the term that should be plotted, function <code>plot.bayesx</code> calls one 
of the following plotting functions in the end:
</p>

<ul>
<li> <p><code><a href="#topic+plotblock">plotblock</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+plotsamples">plotsamples</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+plotmap">plotmap</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+plot2d">plot2d</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+plot3d">plot3d</a></code>,
</p>
</li>
<li> <p><code><a href="stats.html#topic+acf">acf</a></code>,
</p>
</li>
<li> <p><code><a href="stats.html#topic+density">density</a></code>,
</p>
</li></ul>

<p>For details on argument specifications, please see the help sites for the corresponding function.
</p>
<p>If argument <code>x</code> contains of more than one model and e.g. <code>term = 2</code>, the second terms
of all models will be plotted
</p>


<h3>Note</h3>

<p>If a model is specified with a structured and an unstructured spatial effect, e.g. the model 
formula is something like <code>y ~ sx(id, bs = "mrf", map = MapBnd) + sx(id, bs = "re")</code>, the
model output contains of one additional total spatial effect, named with <code>"sx(id):total"</code>.
Also see the last example. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotblock">plotblock</a></code>, <code><a href="#topic+plotsamples">plotsamples</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+plot2d">plot2d</a></code>, 
<code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
   w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
   c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate model
b1 &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
   data = dat, method = "MCMC")

## plot p-spline term
plot(b1, term = 1)
## same with
plot(b1, term = "sx(x)")

## with residuals
plot(b1, term = "sx(x)", residuals = TRUE)

## plot tensor term
plot(b1, term = "sx(z,w)")

## use other palette
plot(b1, term = "sx(z,w)", col.surface = heat.colors)

## swap colors
plot(b1, term = "sx(z,w)", col.surface = heat.colors, swap = TRUE)

## plot tensor term with residuals
plot(b1, term = "sx(z,w)", residuals = TRUE)

## plot image and contour
plot(b1, term = "sx(z,w)", image = TRUE)
plot(b1, term = "sx(z,w)", image = TRUE, contour = TRUE)

## increase the grid
plot(b1, term = "sx(z,w)", image = TRUE, contour = TRUE, grid = 100)

## plot factor term
plot(b1, term = "fac")

## plot factor term with residuals
plot(b1, term = "fac", resid = TRUE, cex = 0.5)

## plot residual dignostics
plot(b1, which = 5:8)

## plot variance sampling path of term sx(x)
plot(b1, term = 1, which = "var-samples")

## plot coefficients sampling paths of term sx(x)
plot(b1, term = 1, which = "coef-samples")

## plot the sampling path of the intercept
par(mfrow = c(1, 1))
plot(b1, which = "intcpt-samples")

## plot the autcorrelation function  
## of the sampled intercept
plot(b1, which = "intcpt-samples", 
  acf = TRUE, lag.max = 50)

## increase lags
plot(b1, which = "intcpt-samples", 
  acf = TRUE, lag.max = 200)

## plot maximum autocorrelation 
## of all sampled parameters in b1
plot(b1, which = "max-acf")

## plot maximum autocorrelation of 
## all sampled coefficients of term sx(x)
plot(b1, term = "sx(x)", which = "coef-samples", 
  max.acf = TRUE, lag.max = 100)


## now a spatial example
set.seed(333)

## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); names(MunichBnd) &lt;- 1:N
n &lt;- N*5

## regressors
dat &lt;- data.frame(id = rep(1:N, n/N), x1 = runif(n, -3, 3))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])
dat$re &lt;- with(dat, rnorm(N, sd = 0.6)[id])

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + sp + re + rnorm(n, sd = 0.6))

## estimate model
b2 &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "mrf", map = MunichBnd) +
  sx(id, bs = "re"), method = "MCMC", data = dat)

## summary statistics
summary(b2)

## plot structured spatial effect
plot(b2, term = "sx(id)", map = MunichBnd)

## plot unstructured spatial effect
plot(b2, term = "sx(id):re", map = MunichBnd)

## now without map
## generates a kernel density plot
## of the effects
plot(b2, term = "sx(id):mrf", map = FALSE)
plot(b2, term = "sx(id):re", map = FALSE)

## with approximate quantiles of the  
## kernel density estimate 
plot(b2, term = "sx(id):re", map = FALSE, 
  kde.quantiles = TRUE, probs = c(0.025, 0.5, 0.975))

## plot the total spatial effect
plot(b2, term = "sx(id):total")
plot(b2, term = "sx(id):total", map = MunichBnd)

## combine model objects
b &lt;- c(b1, b2)

## plot first term of second model
plot(b, model = 2, term = 1)
plot(b, model = "b2", term = "sx(x1)")

## plot second term of both models
plot(b, term = 2, map = MunichBnd)

## plot everything
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot2d'>
2D Effect Plot 
</h2><span id='topic+plot2d'></span><span id='topic+plotnonp'></span>

<h3>Description</h3>

<p>Function to plot simple 2D graphics for univariate effects/functions, typically used for objects 
of class <code>"linear.bayesx"</code> and <code>"sm.bayesx"</code> returned from function <code><a href="#topic+bayesx">bayesx</a></code> 
and <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2d(x, residuals = FALSE, rug = TRUE, jitter = TRUE, 
  col.residuals = NULL, col.lines = NULL, col.polygons = NULL, 
  col.rug = NULL, c.select = NULL, fill.select = NULL, 
  data = NULL, sep = "", month = NULL, year = NULL,
  step = 12, shift = NULL, trans = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2d_+3A_x">x</code></td>
<td>
<p>a matrix or data frame, containing the covariate for which the effect should be plotted 
in the first column and at least a second column containing the effect, typically the structure 
for univariate functions returned within <code><a href="#topic+bayesx">bayesx</a></code> and 
<code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code> model term objects is used, also see 
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. <code>y ~ x</code>, also see the example. <code>x</code> may also be a character file path to the
data to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_residuals">residuals</code></td>
<td>
<p>if set to <code>TRUE</code>, partial residuals may also be plotted if available.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_rug">rug</code></td>
<td>
<p>add a <code><a href="graphics.html#topic+rug">rug</a></code> to the plot.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_jitter">jitter</code></td>
<td>
<p>if set to <code>TRUE</code> a <code><a href="base.html#topic+jitter">jitter</a></code>ed 
<code><a href="graphics.html#topic+rug">rug</a></code> plot is added.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.residuals">col.residuals</code></td>
<td>
<p>the color of the partial residuals.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.lines">col.lines</code></td>
<td>
<p>the color of the lines.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.polygons">col.polygons</code></td>
<td>
<p>specify the background color of polygons, if <code>x</code> has at least 3 columns, 
i.e. column 2 and 3 can form one polygon.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.rug">col.rug</code></td>
<td>
<p>specify the color of the rug representation.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_c.select">c.select</code></td>
<td>
<p><code>integer</code> vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that
first element of <code>c.select</code> should always be the column that holds the variable for the
x-axis.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_fill.select">fill.select</code></td>
<td>
<p><code>integer</code> vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plot2d</code> is 
called. Note that <code>data</code> may also be a character file path to the data.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_sep">sep</code></td>
<td>
<p>the field separator character when <code>x</code> or <code>data</code> is a character, see function
<code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_month">month</code>, <code id="plot2d_+3A_year">year</code>, <code id="plot2d_+3A_step">step</code></td>
<td>
<p>provide specific annotation for plotting estimation results for temporal
variables. <code>month</code> and <code>year</code> define the minimum time point whereas step specifies the
type of temporal data with <code>step = 4</code>, <code>step = 2</code> and <code>step = 1</code> corresponding to
quartely, half yearly and yearly data.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_shift">shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_trans">trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_...">...</code></td>
<td>
<p>other graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 2D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: the line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: the line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: the line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: the line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: see <code><a href="graphics.html#topic+polygon">polygon</a></code>,
</p>
</li>
<li> <p><code>...</code>: other graphical parameters, see function <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>,
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500
## regressor
dat &lt;- data.frame(x = runif(n,-3,3))

##  response 
dat$y &lt;- with(dat, 10 + sin(x) + rnorm(n,sd=0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)
summary(b)

## plot estimated effect
plot(b, which = 1)
plot(b, which = 1, rug = FALSE)

## extract fitted effects
f &lt;- fitted(b, term = "sx(x)")

## now use plot2d
plot2d(f)
plot2d(f, residuals = TRUE)
plot2d(f, residuals = TRUE, pch = 2, col.resid = "green3")
plot2d(f, col.poly = NA, lwd = 1, lty = 1)
plot2d(f, col.poly = NA, lwd = 1, lty = 1, col.lines = 4)
plot2d(f, col.poly = c(2, 3), lwd = 1, col.lines = 4, lty = 1)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1, col.lines = 2:6)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1, col.lines = 2:6,
  resid = TRUE, pch = 4, col.resid = 7)

## End(Not run)

## another variation
plot2d(sin(x) ~ x, data = dat)
dat$f &lt;- with(dat, sin(dat$x))
plot2d(f ~ x, data = dat)
dat$f1 &lt;- with(dat, f + 0.1)
dat$f2 &lt;- with(dat, f - 0.1)
plot2d(f1 + f2 ~ x, data = dat)
plot2d(f1 + f2 ~ x, data = dat, fill.select = c(0, 1, 1), lty = 0)
plot2d(f1 + f2 ~ x, data = dat, fill.select = c(0, 1, 1), lty = 0,
  density = 20, poly.lty = 1, poly.lwd = 2)
plot2d(f1 + f + f2 ~ x, data = dat, fill.select = c(0, 1, 0, 1), 
  lty = c(0, 1, 0), density = 20, poly.lty = 1, poly.lwd = 2)
</code></pre>

<hr>
<h2 id='plot3d'>
3D Effect Plot 
</h2><span id='topic+plot3d'></span><span id='topic+plotsurf'></span>

<h3>Description</h3>

<p>Function to plot 3D graphics or image and/or contour plots for bivariate effects/functions, 
typically used for objects of class <code>"sm.bayesx"</code> and <code>"geo.bayesx"</code> returned from 
function <code><a href="#topic+bayesx">bayesx</a></code> and <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, residuals = FALSE, col.surface = NULL, 
  ncol = 99L, swap = FALSE, col.residuals = NULL, col.contour = NULL, 
  c.select = NULL, grid = 30L, image = FALSE, contour = FALSE, 
  legend = TRUE, cex.legend = 1, breaks = NULL, range = NULL, 
  digits = 2L, d.persp = 1L, r.persp = sqrt(3), outscale = 0,
  data = NULL, sep = "", shift = NULL, trans = NULL,
  type = "interp", linear = FALSE, extrap = FALSE,
  k = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_+3A_x">x</code></td>
<td>
<p>a matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect, typically 
the structure for bivariate functions returned within <code><a href="#topic+bayesx">bayesx</a></code> and 
<code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code> model term objects is used, also see 
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, also see the example.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_residuals">residuals</code></td>
<td>
<p>if set to <code>TRUE</code>, partial residuals may also be plotted if available.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.surface">col.surface</code></td>
<td>
<p>the color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_ncol">ncol</code></td>
<td>
<p>the number of different colors that should be generated, if <code>col.surface</code> is a 
function.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_swap">swap</code></td>
<td>
<p>if set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.residuals">col.residuals</code></td>
<td>
<p>the color of the partial residuals, or if <code>contour = TRUE</code> the color of the
contour lines.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.contour">col.contour</code></td>
<td>
<p>the color of the contour lines.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_c.select">c.select</code></td>
<td>
<p><code>integer</code> vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. 
If <code>c.select = 95</code> or <code>c.select = 80</code>, function <code>plot3d</code> will search for the
corresponding columns to plot a 95<code class="reqn">\%</code> or 80<code class="reqn">\%</code> confidence surfaces respectively. Note
that if e.g. <code>c.select = c(1, 2)</code>, <code>plot3d</code> will use columns 1 + 2 and 2 + 2 for 
plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_grid">grid</code></td>
<td>
<p>the grid size of the surface(s).</p>
</td></tr>
<tr><td><code id="plot3d_+3A_image">image</code></td>
<td>
<p>if set to <code>TRUE</code>, an <code><a href="fields.html#topic+image.plot">image.plot</a></code> is drawn.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_contour">contour</code></td>
<td>
<p>if set to <code>TRUE</code>, a <code><a href="graphics.html#topic+contour">contour</a></code> plot is drawn.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_legend">legend</code></td>
<td>
<p>if <code>image = TRUE</code> an additional legend may be added to the plot.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_cex.legend">cex.legend</code></td>
<td>
<p>the expansion factor for the legend text, see <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_breaks">breaks</code></td>
<td>
<p>a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_range">range</code></td>
<td>
<p>specifies a certain range values should be plotted for.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_digits">digits</code></td>
<td>
<p>specifies the legend decimal places.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_d.persp">d.persp</code></td>
<td>
<p>see argument <code>d</code> in function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_r.persp">r.persp</code></td>
<td>
<p>see argument <code>r</code> in function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_outscale">outscale</code></td>
<td>
<p>scales the outer ranges of <code>x</code> and <code>z</code> limits used for interpolation.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called. Note that <code>data</code> may also be a character file path to the data.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_sep">sep</code></td>
<td>
<p>the field separator character when <code>x</code> or <code>data</code> is a character, see function
<code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_shift">shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_trans">trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_type">type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code><a href="interp.html#topic+interp">interp</a></code>. The two other options are
<code>type = "mba"</code>, which calls function <code><a href="MBA.html#topic+mba.surf">mba.surf</a></code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_linear">linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code><a href="interp.html#topic+interp">interp</a></code>?</p>
</td></tr>
<tr><td><code id="plot3d_+3A_extrap">extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td></tr>
<tr><td><code id="plot3d_+3A_k">k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+colorlegend">colorlegend</a></code> if an image plot with legend is drawn,
also other graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 3D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: specify the size of partial residuals,
</p>
</li>
<li> <p><code>col</code>: it is possible to specify the color for the surfaces if <code>se &gt; 0</code>, then 
e.g. <code>col = c("green", "black", "red")</code>,
</p>
</li>
<li> <p><code>pch</code>: the plotting character of the partial residuals,
</p>
</li>
<li> <p><code>...</code>: other graphical parameters passed functions <code><a href="graphics.html#topic+persp">persp</a></code>,
<code><a href="fields.html#topic+image.plot">image.plot</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>,
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, <code><a href="#topic+colorlegend">colorlegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## response
dat$y &lt;- with(dat, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(z, w, bs = "te", knots = 5), data = dat, method = "REML")
summary(b)

## plot estimated effect
plot(b, term = "sx(z,w)")

## extract fitted effects
f &lt;- fitted(b, term = "sx(z,w)")

## now use plot3d
plot3d(f)
plot3d(f, swap = TRUE)
plot3d(f, residuals = TRUE)
plot3d(f, resid = TRUE, cex.resid = 0.1)
plot3d(f, resid = TRUE, pch = 2, col.resid = "green3")
plot3d(f, resid = TRUE, c.select = 95, cex.resid = 0.1)
plot3d(f, resid = TRUE, c.select = 80, cex.resid = 0.1)
plot3d(f, grid = 100, border = NA)
plot3d(f, c.select = 95, border = c("red", NA, "green"),
  col.surface = c(1, NA, 1), resid = TRUE, cex.resid = 0.2)

## now some image and contour
plot3d(f, image = TRUE, legend = FALSE)
plot3d(f, image = TRUE, legend = TRUE)
plot3d(f, image = TRUE, contour = TRUE)
plot3d(f, image = TRUE, contour = TRUE, swap = TRUE)
plot3d(f, image = TRUE, contour = TRUE, col.contour = "white")
plot3d(f, contour = TRUE)
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 3))
plot3d(f, image = TRUE, contour = TRUE, c.select = 3)
plot3d(f, image = TRUE, contour = TRUE, c.select = "Estimate")
plot3d(f, image = TRUE, contour = TRUE, c.select = "97.5
par(op)

## End(Not run)

## another variation
dat$f1 &lt;- with(dat, sin(z) * cos(w))
with(dat, plot3d(cbind(z, w, f1)))

## same with formula 
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = dat)
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = dat, 
  ticktype = "detailed")

## play with palettes
plot3d(sin(z) * cos(w) ~ z + w, col.surface = heat.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = topo.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = cm.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = terrain.colors, data = dat)

plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow_hcl, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = diverge_hcl, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = sequential_hcl, data = dat)

plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  data = dat)
plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  image = TRUE, grid = 200, data = dat)
</code></pre>

<hr>
<h2 id='plotblock'>
Factor Variable and Random Effects Plots
</h2><span id='topic+plotblock'></span>

<h3>Description</h3>

<p>Function to plot effects for model terms including factor, or group variables for random effects, 
typically used for objects created within <code><a href="#topic+bayesx">bayesx</a></code> or <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotblock(x, residuals = FALSE, range = c(0.3, 0.3), 
  col.residuals = "black", col.lines = "black", c.select = NULL, 
  fill.select = NULL , col.polygons = NULL, data = NULL,
  shift = NULL, trans = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotblock_+3A_x">x</code></td>
<td>
<p>either a <code>list</code> of length of the unique factors, where each <code>list</code> element 
contains the estimated effects for one factor as a matrix, see <code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, or 
one data matrix with first column as the group or factor variable. Also formulas are accepted, 
e.g it is possible to specify the plot with <code>f ~ x</code> or <code>f1 + f2 ~ x</code>. By convention, 
the covariate for which effects should be plotted, is always in the first column in the 
resulting data matrix, that is used for plotting, i.e. in the second formula example, the data 
matrix is <code>cbind(x, f1, f2)</code>, also see argument <code>c.select</code> and <code>fill.select</code>.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_residuals">residuals</code></td>
<td>
<p>if set to <code>TRUE</code>, partial residuals will be plotted if available. Partial
residuals may be set as an <code><a href="base.html#topic+attr">attr</a></code>ibute of <code>x</code> named 
<code>"partial.resids"</code>, where the partial residuals must be a matrix with first column 
specifying the covariate, and second column the partial residuals that should be plotted.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_range">range</code></td>
<td>
<p><code>numeric</code> vector, specifying the left and right bound of the block.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.residuals">col.residuals</code></td>
<td>
<p>the color of the partial residuals.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.lines">col.lines</code></td>
<td>
<p>vector of maximum length of columns of <code>x</code> minus 1, specifying the color of 
the lines.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_c.select">c.select</code></td>
<td>
<p><code>integer</code> vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5 
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that 
first element of <code>c.select</code> should always be 1, since this is the column of the covariate 
the effect is plotted for.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_fill.select">fill.select</code></td>
<td>
<p><code>integer</code> vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.polygons">col.polygons</code></td>
<td>
<p>specify the background color for the upper and lower confidence bands, e.g. 
<code>col = c("green", "red")</code>.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plotblock</code> is 
called.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_shift">shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_trans">trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_...">...</code></td>
<td>
<p>graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>plotblock</code> draws for every factor or group the effect as a &quot;block&quot; in one graphic, 
i.e. similar to boxplots, estimated fitted effects, e.g. containing quantiles for <code>MCMC</code> 
estimated models, are drawn as one block, where the upper lines represent upper quantiles, the 
middle line the mean or median, and lower lines lower quantiles, also see the examples. The 
following graphical parameters may be supplied additionally:
</p>

<ul>
<li> <p><code>cex</code>: specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: the line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: the line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: the line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: the line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: see <code><a href="graphics.html#topic+polygon">polygon</a></code>,
</p>
</li>
<li> <p><code>...</code>: other graphical parameters, see function <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>, 
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + 
  rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ fac, data = dat)
summary(b)

## plot factor term effects
plot(b, term = "fac")

## extract fitted effects
f &lt;- fitted(b, term = "fac")

## now use plotblock
plotblock(f)

## some variations
plotblock(f, col.poly = c(2, 3))
plotblock(f, col.poly = NA, lwd = c(2, 1, 1, 1, 1))
plotblock(f, col.poly = NA, lwd = 3, range = c(0.5,0.5))
plotblock(f, col.poly = NA, lwd = 3, col.lines = 1:5, lty = 1)
plotblock(f, col.poly = NA, lwd = 3, col.lines = 1:5, 
  lty = c(3, 1, 2, 2, 1))
plotblock(f, resid = TRUE)
plotblock(f, resid = TRUE, cex = 0.1)
plotblock(f, resid = TRUE, cex = 0.1, col.resid = 2)
plotblock(f, resid = TRUE, cex = 2, col.resid = 3, pch = 3)
plotblock(f, lty = 0, poly.lty = 1, density = c(5, 20))
plotblock(f, lty = 0, poly.lty = 1, density = c(5, 20), 
  poly.lwd = c(1, 2))
plotblock(f, lty = 0, poly.lty = c(1, 2), density = c(5, 20))
plotblock(f, lty = 0, poly.lty = c(1, 2), density = c(5, 20), 
  border = c("red", "green3"))
plotblock(f, lty = 0, poly.lty = c(1, 2), density = c(5, 20), 
  border = c("red", "green3"), col.poly = c("blue", "yellow"))
plotblock(f, lty = c(1,0,0,0,0), poly.lty = c(1, 2), 
  density = c(5, 20), border = c("red", "green3"), 
  col.poly = c("blue", "yellow"))
plotblock(f, lty = c(1,0,0,0,0), poly.lty = c(1, 2), 
  density = c(20, 20), border = c("red", "green3"), 
  col.poly = c("blue", "yellow"), angle = c(10, 75))

## End(Not run)

## another example
plotblock(y ~ fac, data = dat, range = c(0.45, 0.45))

dat &lt;- data.frame(fac = factor(rep(1:10, n/10)))
dat$y &lt;- with(dat, c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac])
plotblock(y ~ fac, data = dat)
plotblock(cbind(y - 0.1, y + 0.1) ~ fac, data = dat)
plotblock(cbind(y - 0.1, y + 0.1) ~ fac, data = dat, 
  fill.select = c(0, 1, 1))
plotblock(cbind(y - 0.1, y + 0.1) ~ fac, data = dat, 
  fill.select = c(0, 1, 1), poly.lty = 2, lty = 1, 
  border = "grey5")
</code></pre>

<hr>
<h2 id='plotmap'>
Plot Maps
</h2><span id='topic+plotmap'></span><span id='topic+plot.bnd'></span><span id='topic+drawmap'></span>

<h3>Description</h3>

<p>The function takes a <code><a href="base.html#topic+list">list</a></code> polygons and draws the corresponding map. Different 
colors for each polygon can be used. Typically used for objects of class <code>"mrf.bayesx"</code> and
<code>"random.bayesx"</code> returned from function <code><a href="#topic+bayesx">bayesx</a></code> and 
<code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(map, x = NULL, id = NULL, c.select = NULL, legend = TRUE,
  missing = TRUE, swap = FALSE, range = NULL, names = FALSE,
  values = FALSE, col = NULL, ncol = 100, breaks = NULL,
  cex.legend = 1, cex.names = 1, cex.values = cex.names, digits = 2L,
  mar.min = 2, add = FALSE, interp = FALSE, grid = 200,
  land.only = FALSE, extrap = FALSE, outside = FALSE, type = "interp",
  linear = FALSE, k = 40, p.pch = 15, p.cex = 1, shift = NULL,
  trans = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmap_+3A_map">map</code></td>
<td>
<p>the map to be plotted, the map object must be a <code><a href="base.html#topic+list">list</a></code> of matrices 
with first column indicating the <code>x</code> coordinate and second column the <code>y</code> coordinate
each, also see <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with two columns, first column indicates the region and 
second column the the values which will define the background colors of the polygons, e.g. 
fitted values from <code><a href="#topic+bayesx">bayesx</a></code>. More columns are possible, e.g. quantiles, which can 
accessed with argument <code>se</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_id">id</code></td>
<td>
<p>if argument <code>x</code> is a vector, argument <code>id</code> should contain a character vector 
of the same length of <code>x</code> with entries indicating the polygon the <code class="reqn">i</code>-th value of 
<code>x</code> belongs to, i.e. <code>id</code> must contain the same names as polygon names in <code>map</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_c.select">c.select</code></td>
<td>
<p>select the column of the data in <code>x</code> which should be used for plotting, may
be an integer or character with the corresponding column name.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_legend">legend</code></td>
<td>
<p>if set to <code>TRUE</code>, a legend will be shown.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_missing">missing</code></td>
<td>
<p>should polygons be plotted for which no data is available in <code>x</code>?</p>
</td></tr>
<tr><td><code id="plotmap_+3A_swap">swap</code></td>
<td>
<p>if set to <code>TRUE</code>, colors will be represented in reverse order.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_range">range</code></td>
<td>
<p>specify the range of values in <code>x</code> which should enter the plot, e.g. only 
values between -2 and 2 are of interest then <code>range = c(-2, 2)</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_names">names</code></td>
<td>
<p>if set to <code>TRUE</code> the name for each polygon will also be plotted at the centroids
of the corresponding polygons.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_values">values</code></td>
<td>
<p>if set to <code>TRUE</code> the corresponding values for each polygon will also be plotted 
at the centroids of the polygons.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_col">col</code></td>
<td>
<p>the color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_ncol">ncol</code></td>
<td>
<p>the number of different colors that should be generated if <code>col</code> is a function.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_breaks">breaks</code></td>
<td>
<p>a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_cex.legend">cex.legend</code></td>
<td>
<p>text size of the numbers in the legend.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_cex.names">cex.names</code></td>
<td>
<p>text size of the names if <code>names = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_cex.values">cex.values</code></td>
<td>
<p>text size of the names if <code>values = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_digits">digits</code></td>
<td>
<p>specifies the legend decimal places.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_mar.min">mar.min</code></td>
<td>
<p>Controls the definition of boundaries. Could be either <code>NULL</code> for individual 
settings of <code>mar</code> or a value which defines <code>mar</code> as follows: The boundaries will be 
calculated according to the height to width ratio of the map with minimal boundary 
<code>mar.min</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_add">add</code></td>
<td>
<p>if set to <code>TRUE</code>, the map will be added to an existing plot.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_interp">interp</code></td>
<td>
<p>logical. Should the values provided in argument <code>x</code> be interpolated to obtain
a smooth colored map.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_grid">grid</code></td>
<td>
<p>integer. Defines the number of grid cells to be used for interpolation.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_land.only">land.only</code></td>
<td>
<p>if set to <code>TRUE</code>, only interpoltated pixels that cover land are drawn,
see also function <code><a href="maps.html#topic+map.where">map.where</a></code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_extrap">extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td></tr>
<tr><td><code id="plotmap_+3A_outside">outside</code></td>
<td>
<p>logical. Should interpolated values outside the boundaries of the map be plotted.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_type">type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code><a href="interp.html#topic+interp">interp</a></code>. The two other options are
<code>type = "mba"</code>, which calls function <code><a href="MBA.html#topic+mba.surf">mba.surf</a></code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_linear">linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code><a href="interp.html#topic+interp">interp</a></code>?</p>
</td></tr>
<tr><td><code id="plotmap_+3A_k">k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_p.pch">p.pch</code></td>
<td>
<p>numeric. The point size of the grid cells when using interpolation.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_p.cex">p.cex</code></td>
<td>
<p>numeric. The size of the grid cell points whein using interpolation.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_shift">shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_trans">trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_...">...</code></td>
<td>
<p>parameters to be passed to <code><a href="#topic+colorlegend">colorlegend</a></code> and others, e.g. change the 
<code>border</code> of the polygons and <code>density</code>, see <code><a href="graphics.html#topic+polygon">polygon</a></code>. Please 
see the exmaples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+colorlegend">colorlegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a sample map
data("FantasyBnd")

## plot the map 
op &lt;- par(no.readonly = TRUE)
plotmap(FantasyBnd, main = "Example of a plain map")
plotmap(FantasyBnd, lwd = 1, main = "Example of a plain map")
plotmap(FantasyBnd, lwd = 1, lty = 2)
plotmap(FantasyBnd, lwd = 1, lty = 2, border = "green3")
plotmap(FantasyBnd, lwd = 1, lty = 2, border = "green3",
  density = 50)
plotmap(FantasyBnd, lwd = 1, lty = 2, 
  border = c("red", "green3"),
  density = c(10, 20), angle = c(5, 45))
plotmap(FantasyBnd, lwd = 1, lty = 2, 
  border = c("red", "green3"),
  density = c(10, 20), angle = c(5, 45),
  col = c("blue", "yellow"))
plotmap(FantasyBnd, col = gray.colors(length(FantasyBnd)))

## add some values to the corresponding polygon areas
## note that the first column in matrix val contains
## the region identification index
x &lt;- cbind(as.integer(names(FantasyBnd)), runif(length(FantasyBnd), -2, 2))
plotmap(FantasyBnd, x = x)
        
## now only plot values for some certain regions
set.seed(432)
samps &lt;- sample(x[,1], 4)
nx &lt;- x[samps,]
plotmap(FantasyBnd, x = nx, density = 20)

## play with legend
plotmap(FantasyBnd, x = x, names = TRUE, legend = FALSE)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 1))
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2, side.tick = 2)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2, side.tick = 2, cex.legend = 0.5)
plotmap(FantasyBnd, x = x, values = TRUE, 
  pos = c(-0.15, -0.12))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20)
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE)
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, range = c(-5, 5))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, lrange = c(-5, 5))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, 
  ncol = 4, breaks = seq(-2, 2, length = 5))

## more position options
plotmap(FantasyBnd, x = nx, density = 20, pos = "bottomleft")
plotmap(FantasyBnd, x = nx, density = 20, pos = "topleft")
plotmap(FantasyBnd, x = nx, density = 20, pos = "topright")
plotmap(FantasyBnd, x = nx, density = 20, pos = "bottomright")
plotmap(FantasyBnd, x = nx, density = 20, pos = "right")
par(op)

# load and plot a map from GermanyBnd
op &lt;- par(no.readonly = TRUE)
data("GermanyBnd")
plotmap(GermanyBnd, main = "Map of GermanyBnd")
n &lt;- length(GermanyBnd)

# add some colors
plotmap(GermanyBnd, col = rainbow(n))
plotmap(GermanyBnd, col = heat.colors(n))
plotmap(GermanyBnd, col = topo.colors(n))
plotmap(GermanyBnd, col = cm.colors(n))
plotmap(GermanyBnd, col = gray.colors(n))
plotmap(GermanyBnd, col = c("green", "green3"))
par(op)


## now with bayesx
set.seed(333)

## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); names(MunichBnd) &lt;- 1:N
n &lt;- N*5

## regressors
dat &lt;- data.frame(id = rep(1:N, n/N))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])

## response
dat$y &lt;- with(dat, 1.5 + sp + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(id, bs = "mrf", map = MunichBnd),
  method = "MCMC", data = dat)

## summary statistics
summary(b)

## plot spatial effect
op &lt;- par(no.readonly = TRUE)
plot(b, map = MunichBnd)
plot(b, map = MunichBnd, c.select = "97.5
plot(b, map = MunichBnd, c.select = "2.5
plot(b, map = MunichBnd, c.select = "50
plot(b, map = MunichBnd, names = TRUE, 
  cex.names = 0.5, cex.legend = 0.8)
plot(b, map = MunichBnd, range = c(-0.5, 0.5))
plot(b, map = MunichBnd, range = c(-5, 5))
plot(b, map = MunichBnd, col = heat_hcl, 
  swap = TRUE, symmetric = FALSE)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotsamples'>
Plot Sampling Path(s) of Coefficient(s) and Variance(s) 
</h2><span id='topic+plotsamples'></span>

<h3>Description</h3>

<p>This function plots the sampling paths of coefficient(s) and variance(s) stored in model term
objects typically returned from function <code><a href="#topic+bayesx">bayesx</a></code> or <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsamples(x, selected = "NA", acf = FALSE, var = FALSE,
  max.acf = FALSE, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsamples_+3A_x">x</code></td>
<td>
<p>a vector or matrix, where each column represents a different sampling path to be 
plotted.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_selected">selected</code></td>
<td>
<p>a character string containing the term name the sampling paths are plotted for.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_acf">acf</code></td>
<td>
<p>if set to <code>TRUE</code>, the autocorrelation function for each sampling path is plotted.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_var">var</code></td>
<td>
<p>indicates whether coefficient or variance sampling paths are displayed and simply 
changes the main title.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_max.acf">max.acf</code></td>
<td>
<p>if set to <code>TRUE</code>, <code>plotsamples</code> will evaluate the maximum
autocorrelation over all parameters of each sample.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_subset">subset</code></td>
<td>
<p>integer. An index which selects the coefficients for which sampling paths
should be plotted.</p>
</td></tr>
<tr><td><code id="plotsamples_+3A_...">...</code></td>
<td>
<p>other graphical parameters to be passed to <code><a href="graphics.html#topic+plot">plot</a></code> and
<code><a href="stats.html#topic+acf">acf</a></code>, e.g. argument <code>lag.max</code> if <code>acf = TRUE</code>. An argument
<code>ask</code> controls the display when more than 12 sampling paths should be plotted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)
summary(b)

## plot sampling path for
## the variance
plot(b, term = "sx(x)", which = "var-samples")

## plot sampling paths for 
## coefficients
plot(b, term = "sx(x)", which = "coef-samples")

## plot maximum autocorrelation of
## all sampled parameters of term s(x)
plot(b, term = "sx(x)", which = "coef-samples", max.acf = TRUE)

## extract samples of term sx(x)
sax &lt;- as.matrix(samples(b, term = "sx(x)"))

## now use plotsamples
plotsamples(sax, selected = "sx(x)")

## some variations
plotsamples(sax, selected = "sx(x)", acf = TRUE)
plotsamples(sax, selected = "sx(x)", acf = TRUE, lag.max = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.bayesx'>
Prediction from fitted BayesX objects
</h2><span id='topic+predict.bayesx'></span>

<h3>Description</h3>

<p>Takes a fitted <code>"bayesx"</code> object returned from <code><a href="#topic+bayesx">bayesx</a></code> and produces predictions
by refitting the initial model with weights set to zero for new observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesx'
predict(object, newdata, model = NULL,
  type = c("response", "link", "terms", "model"),
  na.action = na.pass, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bayesx_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code> or <code>"bayesx.hpc"</code>.</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_newdata">newdata</code></td>
<td>
<p>a data frame or list containing the values of the model covariates at which
predictions are required. If missing <code>newdata</code> is the <code>model.frame</code> of the provided
model.</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_model">model</code></td>
<td>
<p>for which model should predictions be calculated, either an integer or 
a character, e.g. <code>model = "mcmc.model"</code>. Note that exactly one model must be selected
within argument <code>model</code> to compute predicted values!</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_type">type</code></td>
<td>
<p>when <code>type = "response"</code>, the default, predictions on the scale of the response
are returned, <code>"link"</code> returns the linear predictor. When <code>type = "terms"</code>, each
component of the linear predictor is returned, but excludes any offset and intercept.
If <code>type = "model"</code>, the full model returned from updating the initial model with weights,
that is used for computing predictions, is returned.</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_digits">digits</code></td>
<td>
<p>predictions should usually be based on the new values provided in argument
<code>newdata</code>. However, since this prediction method uses refitting of the model with
weights, predictions for model terms need to be matched with the new observations. <span class="pkg">BayesX</span>
returns values with a lower precision than <span class="rlang"><b>R</b></span>, therefore argument <code>digits</code> is used to round
values when <code>type = "terms"</code>, to find matching <code>newdata</code> pairs in the fitted objects
returned from the refitted model and the new data. Note that this is a workaround and not 100%
bulletproof. It is recommended to compute predictions for <code>type = "response"</code> or
<code>type = "link"</code>.</p>
</td></tr>
<tr><td><code id="predict.bayesx_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>Depending on the specifications of argument <code>type</code>.
</p>


<h3>Note</h3>

<p>This prediction method is based on refitting the initial model with weights, i.e., if new
observations lie outside the domain of the respective covariate, the knot locations when using
e.g. P-splines are calculated using the old and the new data. Hence, if there are large gaps
between the old data domain and new observations, this could affect the overall fit of the
estimated spline, i.e., compared to the initial model fit there will be smaller or larger
differences depending on the <code>newdata</code> provided. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(121)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, 0, 1),
  w = runif(n, 0, 3))

## generate response 
dat$y &lt;- with(dat, 1.5 + sin(x) + z -3 * w + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + z + w, data = dat)

## create some data for which predictions are required
nd &lt;- data.frame(x = seq(2, 5, length = 100), z = 1, w = 0)

## prediction model from refitting with weights
nd$fit &lt;- predict(b, newdata = nd)
plot(fit ~ x, type = "l", data = nd)

## End(Not run)
</code></pre>

<hr>
<h2 id='R2BayesX-package'>
Estimate STAR Models with BayesX
</h2><span id='topic+R2BayesX-package'></span><span id='topic+R2BayesX'></span><span id='topic+r2bayesx'></span><span id='topic+r2bayesx-package'></span>

<h3>Description</h3>

<p>This package interfaces the <span class="pkg">BayesX</span> (<a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>)
command-line binary from <span class="rlang"><b>R</b></span>. The main model fitting function is called <code><a href="#topic+bayesx">bayesx</a></code>. 
</p>
<p>Before STAR models can be estimated, the command-line version of <span class="pkg">BayesX</span> needs to be
installed, which is done by installing the <span class="rlang"><b>R</b></span> source code package <span class="pkg">BayesXsrc</span>. Please see
function <code><a href="#topic+bayesx">bayesx</a></code> and <code><a href="#topic+bayesx.control">bayesx.control</a></code> for more details on model fitting
and controlling.
</p>
<p>The package also provides functionality for high level graphics of estimated effects, see function
<code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="#topic+plotblock">plotblock</a></code>,
<code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+plotsamples">plotsamples</a></code> and <code><a href="#topic+colorlegend">colorlegend</a></code>.
</p>
<p>More standard extractor functions and methods for the fitted model objects may be applied, e.g., 
see function <code><a href="#topic+summary.bayesx">summary.bayesx</a></code>, <code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, 
<code><a href="#topic+residuals.bayesx">residuals.bayesx</a></code>, <code><a href="#topic+samples">samples</a></code>, <code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, as well as
<code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code> etc., please see the examples of the help 
sites. Predictions for new data based on refitting with weights can be obtained by function
<code><a href="#topic+predict.bayesx">predict.bayesx</a></code>.
</p>
<p>In addition, it is possible to run arbitrary <span class="pkg">BayesX</span> program files using function 
<code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>. <span class="pkg">BayesX</span> output files that are stored in a directory may
be read into <span class="rlang"><b>R</b></span> calling function <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## to see the package demos
  demo(package = "R2BayesX") 
</code></pre>

<hr>
<h2 id='read.bayesx.output'>
Read BayesX Output from Directories
</h2><span id='topic+read.bayesx.output'></span>

<h3>Description</h3>

<p>This function automatically reads in <span class="pkg">BayesX</span> estimation output which is stored in an output 
directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bayesx.output(dir, model.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bayesx.output_+3A_dir">dir</code></td>
<td>
<p>a character string, specifies the directory file where <span class="pkg">BayesX</span> output is stored.</p>
</td></tr>
<tr><td><code id="read.bayesx.output_+3A_model.name">model.name</code></td>
<td>
<p>a character string, specifies the base name of the model that should be read in,
also see the examples. If not supplied <code>read.bayesx.output</code> tries to read in all existing
model outputs in <code>dir</code>, every model is then stored as one element in the output 
<code>list</code>. By convention, <code>read.bayesx.output</code> searches for existing <code>.tex</code> output 
files, and others, to identify different models in the <code>dir</code> folder.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for model term objects in the specified directory, which are then stored in 
a <code>list</code>. Each model term object will be of class <code>xx.bayesx</code>, so the generic functions 
described in <code><a href="#topic+plot.bayesx">plot.bayesx</a></code> may be applied for visualizing the results. In addition 
summary statistics of the models may be printed to the <span class="rlang"><b>R</b></span> console with 
<code><a href="#topic+summary.bayesx">summary.bayesx</a></code>.
</p>


<h3>Value</h3>

 
<p><code>read.bayesx.output</code> typically returns a list of class <code>"bayesx"</code> with the first element 
containing a list with the following objects:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>the STAR formula used,</p>
</td></tr>
<tr><td><code>bayesx.setup</code></td>
<td>
<p>an object of class <code>"bayesx.input"</code>, see 
<code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code>,</p>
</td></tr>
<tr><td><code>bayesx.prg</code></td>
<td>
<p>a character containing the <code>.prg</code> file used for estimation with 
<code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>,</p>
</td></tr>
<tr><td><code>bayesx.run</code></td>
<td>
<p>details on processing with <code><a href="BayesXsrc.html#topic+run.bayesx">run.bayesx</a></code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values of the estimated model,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the estimated model,</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>a <code>list</code> containing fitted effects of model terms, also see 
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code> and <code><a href="#topic+samples">samples</a></code>,</p>
</td></tr>
<tr><td><code>fixed.effects</code></td>
<td>
<p>a <code>matrix</code> with estimation results for fixed effects,</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>estimation results for the variance parameter of the model,</p>
</td></tr>
<tr><td><code>smooth.hyp</code></td>
<td>
<p>a <code>matrix</code> with estimation results smooth terms,</p>
</td></tr>
<tr><td><code>model.fit</code></td>
<td>
<p>list containing additional information to be supplied to
<code><a href="#topic+summary.bayesx">summary.bayesx</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.bayesx">summary.bayesx</a></code>, <code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+samples">samples</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data from
## package example folder
dir &lt;- file.path(find.package("R2BayesX"), "/examples/ex01")
b &lt;- read.bayesx.output(dir)

## some model summaries
print(b)
summary(b)

## now plot estimated effects
plot(b)

## 2nd example
dir &lt;- file.path(find.package("R2BayesX"), "/examples/ex02")
list.files(dir)

## dir contains of 2 different
## base names
## 01 only one nonparametric effect
b &lt;- read.bayesx.output(dir, model.name = "nonparametric")
plot(b)

## 02 only one bivariate
## nonparametric effect
b &lt;- read.bayesx.output(dir, model.name = "surface")
plot(b)
</code></pre>

<hr>
<h2 id='read.bnd'>Read Geographical Information in Boundary Format</h2><span id='topic+read.bnd'></span>

<h3>Description</h3>

<p>Reads the geographical information provided in a file in boundary format and stores it in a map
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bnd(file, sorted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bnd_+3A_file">file</code></td>
<td>
<p>name of the boundary file to be read.</p>
</td></tr>
<tr><td><code id="read.bnd_+3A_sorted">sorted</code></td>
<td>
<p>should the regions be ordered by the numbers speciying the region names
(<code>sorted = TRUE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A boundary file provides the boundary information of a geographical map in terms of closed
polygons. For each region of the map, the boundary file contains a block of lines defining the
name of the region, the number of lines the polygon consists of, and the polygons themselves.
The first line of such a block contains the region code surrounded by quotation marks and the
number of lines the polygon of the region consists of. The region code and the number of lines
must be separated by a comma. The subsequent lines contain the coordinates of the straight lines
that form the boundary of the region. The straight lines are represented by the coordinates of
their end points. Coordinates must be separated by a comma.
</p>
<p>The following is an example of a boundary file as provided in file <code>Germany.bnd</code> in the
examples folder of this package.
</p>

<table>
<tr>
 <td style="text-align: left;">
    "1001",9 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2534.64771,8409.77539 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2554.54712,8403.92285 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2576.78735,8417.96973 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2592.00439,8366.46582 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2560.39966,8320.81445 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2507.72534,8319.64453 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2496.02002,8350.07813 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2524.11304,8365.29492 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2534.64771,8409.77539 </td>
</tr>
<tr>
 <td style="text-align: left;">
    "1002",18 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2987.64697,7774.17236 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2954.87183,7789.38916 </td>
</tr>
<tr>
 <td style="text-align: left;">
    ...
  </td>
</tr>

</table>

<p>Hence, the region code of the first region is &quot;1001&quot; and contains of 9 points that form its
polygon. The second region has region code &quot;1002&quot; and contains of 18 polygon points (note that
only the first two points are shown).
</p>


<h3>Value</h3>

<p>Returns a list of polygons that form the map. Additional attributes are
</p>
<table>
<tr><td><code>surrounding</code></td>
<td>
<p>Parallel list where for each polygon, the name of a possible
surrounding region is saved.</p>
</td></tr>
<tr><td><code>height2width</code></td>
<td>
<p>Ratio between height and width of the map. Allows customised drawing and
storage in files by specifying the appropriate height and width.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Sabanes Bove, Felix Heinzl, Thomas Kneib, Andreas Brezger.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.bnd">write.bnd</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+write.gra">write.gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.bnd")
germany &lt;- read.bnd(file)
plotmap(germany)
</code></pre>

<hr>
<h2 id='read.gra'>Read Geographical Information in Graph Format</h2><span id='topic+read.gra'></span>

<h3>Description</h3>

<p>Reads the geographical information provided in a file in graph format and stores it in a map
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gra(file, sorted = FALSE, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gra_+3A_file">file</code></td>
<td>
<p>the file path of the graph file to be read.</p>
</td></tr>
<tr><td><code id="read.gra_+3A_sorted">sorted</code></td>
<td>
<p>logical. Should the regions be ordered by the numbers specifying the region names
(<code>sorted = TRUE</code>)?</p>
</td></tr>
<tr><td><code id="read.gra_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Values on each line of the file are separated by this 
character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graph file stores the nodes and the edges of a graph and is a convenient way to represent the
neighborhood structure of a geographical map. The structure of a graph file is given by:
</p>

<ul>
<li><p> The first line of the graph file specifies the total number of nodes.
</p>
</li>
<li><p> The subsequent three lines correspond to the node with the name given in line 2,
the number of neighbors in line 3 and the neighboring node identity numbers in line 4.
</p>
</li></ul>

<p>Note that the note identity numbering starts with <code>0</code>. Example taken from the package
example file <code>Germany.gra</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
    309 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1001 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1059 </td>
</tr>
<tr>
 <td style="text-align: left;">
    3 </td>
</tr>
<tr>
 <td style="text-align: left;">
    0 3 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1002 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    5 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1051 </td>
</tr>
<tr>
 <td style="text-align: left;">
    3 </td>
</tr>
<tr>
 <td style="text-align: left;">
    4 1 9 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1058 </td>
</tr>
<tr>
 <td style="text-align: left;">
    7 </td>
</tr>
<tr>
 <td style="text-align: left;">
    2 6 3 5 1 10 9 </td>
</tr>
<tr>
 <td style="text-align: left;">
    ...
  </td>
</tr>

</table>

<p>Hence, this graph file contains of 309 regions. The first region with name 1001 has 1 neighbor
with neighboring node identity number 1. The last region in this example, region 1058, has 7
neighbors with neighboring node identity numbers 2 6 3 5 1 10 9.
</p>
<p>In addition, graph files using the following format may be imported:
</p>

<ul>
<li><p> The first line of the graph file specifies the total number of nodes.
</p>
</li>
<li><p> The subsequent lines start with the node name followed by the number of neighbors and
the neighboring node identity numbers.
</p>
</li></ul>

<p>Example:
</p>

<table>
<tr>
 <td style="text-align: left;">
    309 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1001 1 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1059 3 1 4 5 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1002 2 6 5 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1051 3 5 2 10 </td>
</tr>
<tr>
 <td style="text-align: left;">
    1058 7 3 7 4 6 2 11 10 </td>
</tr>
<tr>
 <td style="text-align: left;">
    ...
  </td>
</tr>

</table>



<h3>Value</h3>

<p>Returns an adjacency matrix that represents the neighborhood structure defined in the graph file.
The diagonal elements of this matrix are the number of neighbors of each region. The off-diagonal
elements are either <code>-1</code> if regions are neighbors else <code>0</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl, rewritten by Nikolaus Umlauf.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual, Chapter 5. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.gra">write.gra</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code>,
<code><a href="#topic+get.neighbor">get.neighbor</a></code>, <code><a href="#topic+add.neighbor">add.neighbor</a></code>, <code><a href="#topic+delete.neighbor">delete.neighbor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- file.path(find.package("R2BayesX"), "examples", "Germany.gra")
germany &lt;- read.gra(file)
</code></pre>

<hr>
<h2 id='samples'>
Extract Samples of Coefficients and Variances  
</h2><span id='topic+samples'></span>

<h3>Description</h3>

<p>Function to extract the samples generated with Markov chain Monte Carlo simulation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples(object, model = NULL, term = NULL, coda = TRUE, acf = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_model">model</code></td>
<td>
<p>for which model the samples should be provided, either an integer or a character, 
e.g. <code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_term">term</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> or <code><a href="base.html#topic+integer">integer</a></code>, the term for which samples should be
extracted. Also samples of linear effects may be returned if available and
<code>term = "linear-samples"</code>, or of the variance if <code>term = "var-samples"</code>. If set to
<code>NULL</code>, the samples of the linear effects will be returned.</p>
</td></tr>
<tr><td><code id="samples_+3A_acf">acf</code></td>
<td>
<p>if set to <code>TRUE</code>, the autocorrelation function of the samples will be provided.</p>
</td></tr>
<tr><td><code id="samples_+3A_coda">coda</code></td>
<td>
<p>if set to <code>TRUE</code> the function will return objects of class <code>"mcmc"</code> or
<code>"mcmc.list"</code> as provided in the <span class="pkg">coda</span> package.</p>
</td></tr>
<tr><td><code id="samples_+3A_...">...</code></td>
<td>
<p>further arguments passed to function <code><a href="stats.html#topic+acf">acf</a></code>, e.g. argument 
<code>lag.max</code> if <code>acf = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A <code>data.frame</code> or an object of class <code>"mcmc"</code> or <code>"mcmc.list"</code>, if argument
<code>coda = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 200

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response 
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)

## extract samples for the P-spline
sax &lt;- samples(b, term = "sx(x)")
colnames(sax)

## plotting
plot(sax)

## linear effects samples
samples(b, term = "linear-samples")

## for acf, increase lag
sax &lt;- samples(b, term = c("linear-samples", "var-samples", "sx(x)"),
  acf = TRUE, lag.max = 200, coda = FALSE)
names(sax)
head(sax)


## plot maximum autocorrelation 
## of all parameters
sax &lt;- samples(b, term = c("linear-samples", "var-samples", "sx(x)"), 
  acf = TRUE, lag.max = 50, coda = FALSE)
names(sax)
matplot(y = apply(sax, 1, max), type = "h", 
  ylab = "ACF", xlab = "lag")

## example using multiple chains
b &lt;- bayesx(y ~ sx(x), data = dat, chains = 3)
sax &lt;- samples(b, term = "sx(x)")
plot(sax)

## End(Not run)
</code></pre>

<hr>
<h2 id='shp2bnd'>convert a shape-file into a boundary object</h2><span id='topic+shp2bnd'></span>

<h3>Description</h3>

<p>Converts the geographical information provided in a shape-file into a boundary object
(see Chapter 5 of the <span class="pkg">BayesX</span> Reference Manual)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shp2bnd(shpname, regionnames, check.is.in = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shp2bnd_+3A_shpname">shpname</code></td>
<td>
<p>base filename of the shape-file (including path)</p>
</td></tr>
<tr><td><code id="shp2bnd_+3A_regionnames">regionnames</code></td>
<td>
<p>either a vector of region names or the name of the variable in the
dbf-file representing these names</p>
</td></tr>
<tr><td><code id="shp2bnd_+3A_check.is.in">check.is.in</code></td>
<td>
<p>test whether some regions are surrounded by other regions (<code>FALSE</code> speeds
up the execution time but may result in a corrupted bnd-file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a boundary object, i.e. a list of polygons that form the map. See <code><a href="#topic+read.bnd">read.bnd</a></code>
for more information on the format.
</p>


<h3>Author(s)</h3>

<p>Felix Heinzl, Daniel Sabanes Bove, Thomas Kneib with contributions by Michael Hoehle and
Frank Sagerer.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.bnd">write.bnd</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read shapefile into bnd object
shpname &lt;- file.path(find.package("R2BayesX"), "examples", "Northamerica")
north &lt;- shp2bnd(shpname = shpname, regionnames = "COUNTRY")

## draw the map
plotmap(north)
</code></pre>

<hr>
<h2 id='sliceplot'>
Plot Slices of Bivariate Functions 
</h2><span id='topic+sliceplot'></span>

<h3>Description</h3>

<p>This function plots slices from user defined values of bivariate surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceplot(x, y = NULL, z = NULL, view = 1, c.select = NULL,
  values = NULL, probs = c(0.1, 0.5, 0.9), grid = 100,
  legend = TRUE, pos = "topright", digits = 2, data = NULL,
  rawdata = FALSE, type = "interp", linear = FALSE,
  extrap = FALSE, k = 40, rug = TRUE, rug.col = NULL,
  jitter = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceplot_+3A_x">x</code></td>
<td>
<p>a matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect, typically 
the structure for bivariate functions returned within <code><a href="#topic+bayesx">bayesx</a></code> and 
<code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code> model term objects is used, also see 
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, also see the example.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_y">y</code></td>
<td>
<p>if <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_z">z</code></td>
<td>
<p>if <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors, <code>z</code> defines the surface given by <code class="reqn">z = f(x, y)</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_view">view</code></td>
<td>
<p>which variable should be used for the x-axis of the plot, the other variable will be
used to compute the slices. May also be a <code>character</code> with the name of the corresponding
variable.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_c.select">c.select</code></td>
<td>
<p><code>integer</code>, selects the column that is used in the resulting matrix to be
used as the <code>z</code> argument.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_values">values</code></td>
<td>
<p>the values of the <code>x</code> or <code>y</code> variable that should be used for computing
the slices, if set to <code>NULL</code>, slices will be constructed according to the quantiles, see
also argument <code>probs</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] to be used within function
<code><a href="stats.html#topic+quantile">quantile</a></code> to compute the <code>values</code> for plotting the slices.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_grid">grid</code></td>
<td>
<p>the grid size of the surface where the slices are generated from.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_legend">legend</code></td>
<td>
<p>if set to <code>TRUE</code>, a legend with the <code>values</code> that where used for slicing
will be added.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_pos">pos</code></td>
<td>
<p>the position of the legend, see also function <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_digits">digits</code></td>
<td>
<p>the decimal place the legend values should be rounded.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rawdata">rawdata</code></td>
<td>
<p>if set to <code>TRUE</code>, the data will not be interpolated, only raw data will be
used. This is useful when displaying data on a regular grid.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_type">type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code><a href="interp.html#topic+interp">interp</a></code>. The two other options are
<code>type = "mba"</code>, which calls function <code><a href="MBA.html#topic+mba.surf">mba.surf</a></code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_linear">linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code><a href="interp.html#topic+interp">interp</a></code>?</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_extrap">extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_k">k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rug">rug</code></td>
<td>
<p>add a <code><a href="graphics.html#topic+rug">rug</a></code> to the plot.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_jitter">jitter</code></td>
<td>
<p>if set to <code>TRUE</code> a <code><a href="base.html#topic+jitter">jitter</a></code>ed 
<code><a href="graphics.html#topic+rug">rug</a></code> plot is added.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rug.col">rug.col</code></td>
<td>
<p>specify the color of the rug representation.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+matplot">matplot</a></code> and <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to function <code><a href="#topic+plot3d">plot3d</a></code>, this function first applies bivariate interpolation
on a regular <code>grid</code>, afterwards the slices are computed from the resulting surface. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bayesx">plot.bayesx</a></code>, <code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>,
<code><a href="#topic+fitted.bayesx">fitted.bayesx</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## response
dat$y &lt;- with(dat, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(z, w, bs = "te", knots = 5), data = dat, method = "REML")
summary(b)

## plot estimated effect
plot(b, term = "sx(z,w)", sliceplot = TRUE)
plot(b, term = "sx(z,w)", sliceplot = TRUE, view = 2)
plot(b, term = "sx(z,w)", sliceplot = TRUE, view = "w")
plot(b, term = "sx(z,w)", sliceplot = TRUE, c.select = 4)
plot(b, term = "sx(z,w)", sliceplot = TRUE, c.select = 6)
plot(b, term = "sx(z,w)", sliceplot = TRUE, probs = seq(0, 1, length = 10))

## End(Not run)

## another variation
dat$f1 &lt;- with(dat, sin(z) * cos(w))
sliceplot(cbind(z = dat$z, w = dat$w, f1 = dat$f1))

## same with formula 
sliceplot(sin(z) * cos(w) ~ z + w, ylab = "f(z)", data = dat)

## compare with plot3d()
plot3d(sin(z) * 1.5 * w ~ z + w, zlab = "f(z,w)", data = dat)
sliceplot(sin(z) * 1.5 * w ~ z + w, ylab = "f(z)", data = dat)
sliceplot(sin(z) * 1.5 * w ~ z + w, view = 2, ylab = "f(z)", data = dat)
</code></pre>

<hr>
<h2 id='summary.bayesx'>
Bayesx Summary Statistics
</h2><span id='topic+summary.bayesx'></span>

<h3>Description</h3>

<p>Takes an object of class <code>"bayesx"</code> and displays summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesx'
summary(object, model = NULL, 
  digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesx_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesx_+3A_model">model</code></td>
<td>
<p>for which model the plot should be provided, either an integer or a character, e.g. 
<code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesx_+3A_digits">digits</code></td>
<td>
<p>choose the decimal places of represented numbers in the summary statistics.</p>
</td></tr>
<tr><td><code id="summary.bayesx_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supplies detailed summary statistics of estimated objects with <span class="pkg">BayesX</span>, i.e. 
informations on smoothing parameters or variances are supplied, as well as random effects 
variances and parametric coefficients. Depending on the model estimated and the output provided, 
additional model specific information will be printed, e.g. if <code>method = "MCMC"</code> was 
specified in <code><a href="#topic+bayesx">bayesx</a></code>, the number of <code>iterations</code>, the <code>burnin</code> and so forth 
is shown. Also goodness of fit statistics are provided if the <code>object</code> contains such 
informations.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+read.bayesx.output">read.bayesx.output</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
   w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
   c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
   data = dat, method = "MCMC")

## now show summary statistics
summary(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='sx'>
Construct BayesX Model Terms in A Formula
</h2><span id='topic+sx'></span>

<h3>Description</h3>

<p>Function <code>sx</code> is a model term constructor function for terms used within the <code>formula</code>
argument of function <code><a href="#topic+bayesx">bayesx</a></code>. The function does not evaluate matrices etc., the 
behavior is similar to function <code><a href="mgcv.html#topic+s">s</a></code> from package <code><a href="mgcv.html#topic+mgcv">mgcv</a></code>. It 
purely exists to build a basic setup for the model term which can be processed by function 
<code><a href="#topic+bayesx.construct">bayesx.construct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sx(x, z = NULL, bs = "ps", by = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sx_+3A_x">x</code></td>
<td>
<p>the covariate the model term is a function of.</p>
</td></tr>
<tr><td><code id="sx_+3A_z">z</code></td>
<td>
<p>a second covariate.</p>
</td></tr>
<tr><td><code id="sx_+3A_bs">bs</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string, specifying the basis/type which is used for this model 
term.</p>
</td></tr>
<tr><td><code id="sx_+3A_by">by</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+factor">factor</a></code> variable of the same dimension as each 
covariate. In the <code>numeric</code> vector case the elements multiply the smooth, evaluated at the 
corresponding covariate values (a &lsquo;varying coefficient model&rsquo; results). In the <code>factor</code> 
case the term is replicated for each <code>factor</code> level. Note that centering of the term may be 
needed, please see the notes.</p>
</td></tr>
<tr><td><code id="sx_+3A_...">...</code></td>
<td>
<p>special controlling arguments or objects used for the model term, see also 
the examples and function <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code> for all possible optional 
parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following term types may be specified using argument <code>bs</code>:
</p>

<ul>
<li> <p><code>"rw1"</code>, <code>"rw2"</code>: Zero degree P-splines: Defines a zero degree P-spline with first or
second order difference penalty. A zero degree P-spline typically
estimates for every distinct covariate value in the dataset a separate
parameter. Usually there is no reason to prefer zero degree P-splines
over higher order P-splines. An exception are ordinal covariates or
continuous covariates with only a small number of different values.
For ordinal covariates higher order P-splines are not meaningful while
zero degree P-splines might be an alternative to modeling nonlinear
relationships via a dummy approach with completely unrestricted
regression parameters.
</p>
</li>
<li> <p><code>"season"</code>: Seasonal effect of a time scale. 
</p>
</li>
<li> <p><code>"ps"</code>, <code>"psplinerw1"</code>, <code>"psplinerw2"</code>: P-spline with first or second order 
difference penalty. 
</p>
</li>
<li> <p><code>"te"</code>, <code>"pspline2dimrw1"</code>: Defines a two-dimensional P-spline based on the tensor
product of one-dimensional P-splines with a two-dimensional first order random walk
penalty for the parameters of the spline. 
</p>
</li>
<li> <p><code>"kr"</code>, <code>"kriging"</code>: Kriging with stationary Gaussian random fields.  
</p>
</li>
<li> <p><code>"gk"</code>, <code>"geokriging"</code>: Geokriging with stationary Gaussian random fields: Estimation
is based on the centroids of a map object provided in
boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and <code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional
argument named <code>map</code> within function <code><a href="#topic+sx">sx</a></code>, or supplied within argument
<code>xt</code> when using function <code><a href="mgcv.html#topic+s">s</a></code>, e.g., <code>xt = list(map = MapBnd)</code>. 
</p>
</li>
<li> <p><code>"gs"</code>, <code>"geospline"</code>: Geosplines based on two-dimensional P-splines with a
two-dimensional first order random walk penalty for the parameters of the spline.	
Estimation is based on the coordinates of the centroids of the regions
of a map object provided in boundary format (see function <code><a href="#topic+read.bnd">read.bnd</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>) as an additional argument named <code>map</code> (see above). 
</p>
</li>
<li> <p><code>"mrf"</code>, <code>"spatial"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+read.gra">read.gra</a></code> and
<code><a href="#topic+shp2bnd">shp2bnd</a></code>), as an additional argument named <code>map</code> (see above).
</p>
</li>
<li> <p><code>"bl"</code>, <code>"baseline"</code>: Nonlinear baseline effect in hazard regression or multi-state
models: Defines a P-spline with second order random walk penalty for the parameters of
the spline for the log-baseline effect <code class="reqn">log(\lambda(time))</code>. 
</p>
</li>
<li> <p><code>"factor"</code>: Special <span class="pkg">BayesX</span> specifier for factors, especially meaningful if
<code>method = "STEP"</code>, since the factor term is then treated as a full term,
which is either included or removed from the model. 
</p>
</li>
<li> <p><code>"ridge"</code>, <code>"lasso"</code>, <code>"nigmix"</code>: Shrinkage of fixed effects: defines a
shrinkage-prior for the corresponding parameters
<code class="reqn">\gamma_j</code>, <code class="reqn">j = 1, \ldots, q</code>, <code class="reqn">q \geq 1</code> of the
linear effects <code class="reqn">x_1, \ldots, x_q</code>. There are three
priors possible: ridge-, lasso- and Normal Mixture
of inverse Gamma prior.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d. Random effects of a unit or cluster identification covariate.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>list</code> of class <code>"xx.smooth.spec"</code>, where <code>"xx"</code> is a basis/type identifying code
given by the <code>bs</code> argument of <code>f</code>. 
</p>


<h3>Note</h3>

<p>Some care has to be taken with the identifiability of varying coefficients terms. The standard in
<span class="pkg">BayesX</span> is to center nonlinear main effects terms around zero whereas varying coefficient terms are
not centered. This makes sense since main effects nonlinear terms are not identifiable and varying
coefficients terms are usually identifiable. However, there are situations where a varying
coefficients term is not identifiable. Then the term must be centered. Since centering is not
automatically accomplished it has to be enforced by the user by adding option
<code>center = TRUE</code> in function <code>f</code>. To give an example, the varying coefficient terms in 
<code class="reqn">\eta = \ldots + g_1(z_1)z + g_2(z_2)z + \gamma_0 + \gamma_1 z + \ldots</code> are not
identified, whereas in <code class="reqn">\eta = \ldots + g_1(z_1)z + \gamma_0 + \ldots</code>, the varying 
coefficient term is identifiable. In the first case, centering is necessary, in the second case, 
it is not.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+bayesx.term.options">bayesx.term.options</a></code>, <code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="#topic+bayesx.construct">bayesx.construct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## funktion sx() returns a list
## which is then processed by function
## bayesx.construct to build the
## BayesX model term structure
sx(x)

bayesx.construct(sx(x))
bayesx.construct(sx(x, bs = "rw1"))
bayesx.construct(sx(x, bs = "factor"))
bayesx.construct(sx(x, bs = "offset"))
bayesx.construct(sx(x, z, bs = "te"))

## varying coefficients
bayesx.construct(sx(x1, by = x2))
bayesx.construct(sx(x1, by = x2, center = TRUE))

## using a map for markov random fields
data("FantasyBnd")
plot(FantasyBnd)
bayesx.construct(sx(id, bs = "mrf", map = FantasyBnd))

## random effects
bayesx.construct(sx(id, bs = "re"))

## examples using optional controlling
## parameters and objects
bayesx.construct(sx(x, bs = "ps", knots = 20))
bayesx.construct(sx(x, bs = "ps", nrknots = 20))
bayesx.construct(sx(x, bs = "ps", knots = 20, nocenter = TRUE))

## use of bs with original 
## BayesX syntax 
bayesx.construct(sx(x, bs = "psplinerw1"))
bayesx.construct(sx(x, bs = "psplinerw2"))
bayesx.construct(sx(x, z, bs = "pspline2dimrw2"))

bayesx.construct(sx(id, bs = "spatial", map = FantasyBnd))
bayesx.construct(sx(x, z, bs = "kriging"))
bayesx.construct(sx(id, bs = "geospline", map = FantasyBnd, nrknots = 5))
bayesx.construct(sx(x, bs = "catspecific"))


## Not run: 
## generate some data
set.seed(111)
n &lt;- 200

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate models with
## bayesx REML and MCMC
b1 &lt;- bayesx(y ~ sx(x), method = "REML", data = dat)

## increase inner knots
## decrease degree of the P-spline
b2 &lt;- bayesx(y ~ sx(x, knots = 30, degree = 2), method = "REML", data = dat)


## compare reported output
summary(c(b1, b2))

## plot the effect for both models
plot(c(b1, b2), residuals = TRUE)


## more examples
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
  w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
  c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
  data = dat, method = "MCMC")

summary(b)
plot(b)


## now a mrf example
## note: the regional identification
## covariate and the map regionnames
## should be coded as integer
set.seed(333)
     
## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); n &lt;- N*5
names(MunichBnd) &lt;- 1:N
     
## regressors
dat &lt;- data.frame(x1 = runif(n, -3, 3),
  id = as.factor(rep(names(MunichBnd), length.out = n)))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])
     
## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + sp + rnorm(n, sd = 1.2))

## estimate models with
## bayesx MCMC and REML
b &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "mrf", map = MunichBnd), 
  method = "REML", data = dat)

## summary statistics
summary(b)

## plot the effects
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
plot(b, term = "sx(id)", map = MunichBnd, 
  main = "bayesx() estimate")
plotmap(MunichBnd, x = dat$sp, id = dat$id, 
  main = "Truth")
par(op)


## model with random effects
set.seed(333)
N &lt;- 30
n &lt;- N*10

## regressors
dat &lt;- data.frame(id = sort(rep(1:N, n/N)), x1 = runif(n, -3, 3))
dat$re &lt;- with(dat, rnorm(N, sd = 0.6)[id])

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + re + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x1, bs = "psplinerw1") + sx(id, bs = "re"), data = dat)
summary(b)
plot(b)

## extract estimated random effects
## and compare with true effects
plot(fitted(b, term = "sx(id)")$Mean ~ unique(dat$re))

## End(Not run)
</code></pre>

<hr>
<h2 id='term.freqs'>
Extract model term selection frequencies.
</h2><span id='topic+term.freqs'></span>

<h3>Description</h3>

<p>This function takes a fitted <code><a href="#topic+bayesx">bayesx</a></code> object and returns selection frequency tables of
model terms. These tables are only returned using the stepwise procedure in combination with
the bootstrap confidence intervals, see function <code><a href="#topic+bayesx.control">bayesx.control</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term.freqs(object, model = NULL, term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term.freqs_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bayesx"</code>.</p>
</td></tr>
<tr><td><code id="term.freqs_+3A_model">model</code></td>
<td>
<p>for which model the tables should be provided, either an integer or a character, 
e.g. <code>model = "mcmc.model"</code>.</p>
</td></tr>
<tr><td><code id="term.freqs_+3A_term">term</code></td>
<td>
<p>character or integer. The term for which the frequency table should be extracted.</p>
</td></tr>
<tr><td><code id="term.freqs_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code>, <code><a href="#topic+bayesx.control">bayesx.control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -1, 1),
   w = runif(n, 0, 1), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + sx(z) + sx(w) + sx(fac, bs = "re"),
   method = "STEP", CI = "MCMCbootstrap", bootstrapsamples = 99,
   data = dat)
summary(b)

## extract frequency tables
term.freqs(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.bayesx.input'>
Write the BayesX Program
</h2><span id='topic+write.bayesx.input'></span>

<h3>Description</h3>

<p>Function <code>write.bayesx.input</code> takes an object from <code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code> and 
translates the input to an executable program file which may be send to the <span class="pkg">BayesX</span> binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.bayesx.input(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bayesx.input_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bayesx.input"</code>, see <code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function translates the model specified in the <code>formula</code> within
<code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code> or <code><a href="#topic+bayesx">bayesx</a></code> into a <span class="pkg">BayesX</span> executable program
file, secondly the 
function writes a data file into the specified directory chosen in <code><a href="#topic+bayesx.control">bayesx.control</a></code>,
<code><a href="#topic+parse.bayesx.input">parse.bayesx.input</a></code> or <code><a href="#topic+bayesx">bayesx</a></code>, where <span class="pkg">BayesX</span> will find the 
necessary variables for estimation.
</p>


<h3>Value</h3>

<p>Function returns a <code>list</code> containing a character string with all commands used within the 
executable of <span class="pkg">BayesX</span>, the program name, model name and the file directory where the program 
file is stored.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
   w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
   c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## create BayesX .prg
pars &lt;- parse.bayesx.input(y ~ sx(x) + sx(z, w, bs = "te") + fac,
  data = dat)
prg &lt;- write.bayesx.input(pars)
print(prg)

## have a look at the generated files
## which are used within BayesX
print(list.files(paste(tempdir(), "/bayesx", sep = "")))
</code></pre>

<hr>
<h2 id='write.bnd'>Saving Maps in Boundary Format</h2><span id='topic+write.bnd'></span>

<h3>Description</h3>

<p>Writes the information of a map object to a file (in boundary format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write.bnd(map, file, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bnd_+3A_map">map</code></td>
<td>
<p>pap object ot be saved (should be in boundary format).</p>
</td></tr>
<tr><td><code id="write.bnd_+3A_file">file</code></td>
<td>
<p>name of the file to write to</p>
</td></tr>
<tr><td><code id="write.bnd_+3A_replace">replace</code></td>
<td>
<p>should an existing file be overwritten with the new version?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.gra">write.gra</a></code>, <code><a href="#topic+read.gra">read.gra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("FantasyBnd")
tfile &lt;- tempfile()
write.bnd(FantasyBnd, file = tfile)
cat(readLines(tfile), sep = "\n")
unlink(tfile)
</code></pre>

<hr>
<h2 id='write.gra'>Saving Maps in Graph Format</h2><span id='topic+write.gra'></span>

<h3>Description</h3>

<p>Writes the information of a map object to a file (in graph format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.gra(map, file, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.gra_+3A_map">map</code></td>
<td>
<p>map object ot be saved (should be in graph format, see <code><a href="#topic+bnd2gra">bnd2gra</a></code> for
the conversion of boundary format to graph format).</p>
</td></tr>
<tr><td><code id="write.gra_+3A_file">file</code></td>
<td>
<p>name of the file to write to</p>
</td></tr>
<tr><td><code id="write.gra_+3A_replace">replace</code></td>
<td>
<p>should an existing file be overwritten with the new version?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Kneib, Felix Heinzl.
</p>


<h3>References</h3>

<p><span class="pkg">BayesX</span> Reference Manual. Available at <a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gra">read.gra</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("FantasyBnd")
tfile &lt;- tempfile()
write.gra(bnd2gra(FantasyBnd), file = tfile)
cat(readLines(tfile), sep = "\n")
unlink(tfile)
</code></pre>

<hr>
<h2 id='ZambiaBnd'>Zambia Map</h2><span id='topic+ZambiaBnd'></span>

<h3>Description</h3>

<p>This database produces a map of Zambia containing 57 districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ZambiaBnd")</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of class <code>"bnd"</code> containing 57 polygon matrices with 
x-coordinates in the first and y-coordinates in the second column each. 
</p>


<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+read.bnd">read.bnd</a></code>, <code><a href="#topic+write.bnd">write.bnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load ZambiaBnd and plot it
data("ZambiaBnd")
plotmap(ZambiaBnd)
</code></pre>

<hr>
<h2 id='ZambiaNutrition'>Determinants of Childhood Malnutrition in Zambia</h2><span id='topic+ZambiaNutrition'></span><span id='topic+zambia'></span>

<h3>Description</h3>

<p>The Demographic Health Surveys (DHS) of Zambia was conducted 1992. The survey is produced jointly
by Macro International, a USAIDfunded firm specializing in demographic research, and the national
statistical agency of the country.
</p>
<p>Malnutrition among children is usually determined by assessing an anthropometric status of the
children relative to a reference standard. In our example, malnutrition is measured by stunting
or insufficient height for age, indicating chronic malnutrition. Stunting for a child <code class="reqn">i</code> 
is determined using a <code class="reqn">Z</code>-score defined as
</p>
<p style="text-align: center;"><code class="reqn">stunting_i = \frac{AI_i - MAI}{\sigma}</code>
</p>

<p>where <code class="reqn">AI</code> refers to the child's anthropometric indicator (height at a certain age in our 
example), while <code class="reqn">MAI</code> and <code class="reqn">\sigma</code> correspond to the median and the standard deviation in 
the reference population, respectively. 
</p>
<p>The main interest is on modeling the dependence of malnutrition on covariates including the
age of the child, the body mass index of the child's mother, the district the child lives in and 
some further categorial covariates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ZambiaNutrition")</code></pre>


<h3>Format</h3>

<p>A data frame containing 4847 observations on 8 variables.
</p>

<dl>
<dt>stunting:</dt><dd><p>standardised <code class="reqn">Z</code>-score for stunting.</p>
</dd>
<dt>mbmi:</dt><dd><p>body mass index of the mother.</p>
</dd>
<dt>agechild:</dt><dd><p>age of the child in months.</p>
</dd>
<dt>district:</dt><dd><p>district where the mother lives.</p>
</dd>
<dt>memployment:</dt><dd><p>mother's employment status with categories &lsquo;working&rsquo; and &lsquo;not working&rsquo;.</p>
</dd>
<dt>meducation:</dt><dd><p>mother's educational status with categories for complete primary but 
incomplete secondary &lsquo;no/incomplete&rsquo;, complete secondary or higher &lsquo;minimum primary&rsquo; and no 
education or incomplete primary &lsquo;minimum secondary&rsquo;.</p>
</dd>
<dt>urban:</dt><dd><p>locality of the domicile with categories &lsquo;yes&rsquo; and &lsquo;no&rsquo;.</p>
</dd>
<dt>gender:</dt><dd><p>gender of the child with categories &lsquo;male&rsquo; and &lsquo;female&rsquo;.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>


<h3>References</h3>

<p>Kandala, N. B., Lang, S., Klasen, S., Fahrmeir, L. (2001): Semiparametric Analysis of the 
Socio-Demographic and Spatial Determinants of Undernutrition in Two African Countries. 
<em>Research in Official Statistics</em>, <b>1</b>, 81&ndash;100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesx">bayesx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load zambia data and map
data("ZambiaNutrition")
data("ZambiaBnd")

## estimate model
zm &lt;- bayesx(stunting ~ memployment + meducation + urban + gender + 
  sx(mbmi) + sx(agechild) + sx(district, bs = "mrf", map = ZambiaBnd) +
  sx(district, bs = "re"), iter = 12000, burnin = 2000, step = 10,
  data = ZambiaNutrition)

summary(zm)

## plot smooth effects
plot(zm, term = c("sx(bmi)", "sx(agechild)", "sx(district)"), map = ZambiaBnd)

## for more examples 
demo("zambia")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
