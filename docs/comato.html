<!DOCTYPE html><html><head><title>Help for package comato</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comato}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze.graph.measures'><p>Analyze graph measures of a concept map</p></a></li>
<li><a href='#analyze.graph.measures.conceptmap'><p>Analyzing graph measures of a concept map</p></a></li>
<li><a href='#analyze.graph.measures.igraph'><p>Analyzing graph measures of an igraph object</p></a></li>
<li><a href='#analyze.similarity'><p>Analyzing graph similarity.</p></a></li>
<li><a href='#analyze.subgraphs'><p>Analyzing small subgraph patterns.</p></a></li>
<li><a href='#as.matrix.conceptmap'><p>Convert a conceptmap object to a matrix</p></a></li>
<li><a href='#as.matrix.conceptmaps'><p>Convert a conceptmaps object to a matrix</p></a></li>
<li><a href='#clustering'><p>Clustering maps of a conceptmaps object</p></a></li>
<li><a href='#concept.vector'><p>Forming the concept vector of a conceptmap object</p></a></li>
<li><a href='#conceptmap'><p>Constructing a conceptmap object</p></a></li>
<li><a href='#conceptmap.default'><p>Basic creation of a conceptmap object</p></a></li>
<li><a href='#conceptmap.igraph'><p>Creation of a conceptmap object from an existing graph</p></a></li>
<li><a href='#conceptmap.matrix'><p>Creation of a conceptmap object from matrix data</p></a></li>
<li><a href='#conceptmaps'><p>Constructing a conceptmaps object</p></a></li>
<li><a href='#conceptmaps.default'><p>Basic creation of a conceptmaps object</p></a></li>
<li><a href='#conceptmaps.list'><p>Creation of a conceptmaps object from a list</p></a></li>
<li><a href='#conceptmaps.matrix'><p>Creation of a conceptmaps object from a matrix</p></a></li>
<li><a href='#edge.vector'><p>Forming the edge vector of a conceptmap object</p></a></li>
<li><a href='#get.unified.concepts'><p>Finding all concepts used.</p></a></li>
<li><a href='#Hopkins.index'><p>Non-randomness of data</p></a></li>
<li><a href='#landscape'><p>Aggregating the maps of a conceptmaps object into a concept landscape</p></a></li>
<li><a href='#MBM.cluster'><p>MBMM clustering</p></a></li>
<li><a href='#merge.conceptmaps'><p>Unify sets of conceptmaps</p></a></li>
<li><a href='#modify.concepts'><p>Modify the concepts of concept maps</p></a></li>
<li><a href='#modify.concepts.conceptmap'><p>Adapt list of concepts of a conceptmap object</p></a></li>
<li><a href='#modify.concepts.conceptmaps'><p>Modifying the concepts of all maps of a conceptmaps object.</p></a></li>
<li><a href='#PAM.cluster'><p>Similarity based clustering</p></a></li>
<li><a href='#pathfinder'><p>Construct a Pathfinder network from a conceptmap or a concept landscape</p></a></li>
<li><a href='#pathfinder.conceptmaps'><p>Creating a Pathfinder network from a conceptmaps object</p></a></li>
<li><a href='#pathfinder.igraph'><p>Creating a Pathfinder network from an igraph object</p></a></li>
<li><a href='#pathfinder.matrix'><p>Creating a Pathfinder network from a matrix</p></a></li>
<li><a href='#plot.conceptmap'><p>Plotting a conceptmap</p></a></li>
<li><a href='#plot.conceptmaps'><p>Plotting a series of concept maps</p></a></li>
<li><a href='#print.conceptmap'><p>Display basic information of a conceptmap object</p></a></li>
<li><a href='#print.conceptmaps'><p>Display basic information of a conceptmaps object</p></a></li>
<li><a href='#read.folder.tgf'><p>Importing a set of concept maps from TGF files.</p></a></li>
<li><a href='#read.folder.yEd'><p>Importing a set of concept maps from GraphML files.</p></a></li>
<li><a href='#read.tgf'><p>Importing a concept map from a TGF file.</p></a></li>
<li><a href='#read.yEd'><p>Importing a concept map from a GraphML file.</p></a></li>
<li><a href='#splice'><p>Select a subset of a set of conceptmaps</p></a></li>
<li><a href='#summary.conceptmap'><p>Return basic information of a conceptmap object</p></a></li>
<li><a href='#summary.conceptmaps'><p>Return basic information of a conceptmaps object</p></a></li>
<li><a href='#unify.concepts'><p>Unifying the concepts of a conceptmap object.</p></a></li>
<li><a href='#write.tgf'><p>Saving a concept map to a TGF file</p></a></li>
<li><a href='#write.tgf.folder'><p>Saving a set of concept maps to TGF files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Concept Maps and Concept Landscapes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-03-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Muehling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Muehling &lt;andreas.muehling@tum.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for the import/export and automated analysis of concept maps and concept landscapes (sets of concept maps).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Matrix, lattice, gdata, XML, cluster, clusterSim,
graphics, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-02 16:25:20 UTC; Andreas MÃ¼hling</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-02 16:36:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze.graph.measures'>Analyze graph measures of a concept map</h2><span id='topic+analyze.graph.measures'></span>

<h3>Description</h3>

<p><code>analyze.graph.measures</code> analyzes several graph measures. For actual implementations
see <code><a href="#topic+analyze.graph.measures.conceptmap">analyze.graph.measures.conceptmap</a></code>, or <code><a href="#topic+analyze.graph.measures.igraph">analyze.graph.measures.igraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.graph.measures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.graph.measures_+3A_x">x</code></td>
<td>
<p>A conceptmap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of several graph measures.
</p>

<hr>
<h2 id='analyze.graph.measures.conceptmap'>Analyzing graph measures of a concept map</h2><span id='topic+analyze.graph.measures.conceptmap'></span>

<h3>Description</h3>

<p><code>analyze.graph.measures</code> analyzes several basic graph measures of a given graph in form of a conceptmap object. All measures
are derived by the appropriate functions of igraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
analyze.graph.measures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.graph.measures.conceptmap_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named components that contain the betweenness measure, the edge.connectivity, the diameter, the degree distribution and the 
communities using the Fastgreedy algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(15, 0.7, type="gnp"), "name", value=1:15)
analyze.graph.measures(conceptmap(g1))
</code></pre>

<hr>
<h2 id='analyze.graph.measures.igraph'>Analyzing graph measures of an igraph object</h2><span id='topic+analyze.graph.measures.igraph'></span>

<h3>Description</h3>

<p><code>analyze.graph.measures.igraph</code> is a convenience method that can be called directly on the result of <code><a href="#topic+landscape">landscape</a></code>.
It works just like <code><a href="#topic+analyze.graph.measures.conceptmap">analyze.graph.measures.conceptmap</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
analyze.graph.measures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.graph.measures.igraph_+3A_x">x</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named components that contain the betweenness measure, the edge.connectivity, the diameter, the degree distribution and the 
communities using the Fastgreedy algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(15, 0.7, type="gnp"), "name", value=1:15)
analyze.graph.measures(g1)
</code></pre>

<hr>
<h2 id='analyze.similarity'>Analyzing graph similarity.</h2><span id='topic+analyze.similarity'></span>

<h3>Description</h3>

<p><code>analyze.similarity</code> calculates a measure of graph similarity between two concept maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.similarity(map1, map2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.similarity_+3A_map1">map1</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="analyze.similarity_+3A_map2">map2</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 and 1 that indicated the structural similariy of the underlying graphs. The graphs need not 
share the same set of nodes.
</p>


<h3>See Also</h3>

<p>The structural similarity that is calculated is described in: 
Goldsmith, Timothy E.; Davenport, Daniel M. (1990): Assessing Structural Similarity of Graphs. In: Roger W. Schvaneveldt (Hg.): Pathfinder associative networks. Studies in knowledge organizations. Norwood, N.J: Ablex Pub. Corp., S. 74-87.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(15, 0.7, type="gnp"), "name", value=1:15)
g2 = set.vertex.attribute(erdos.renyi.game(15, 0.7, type="gnp"), "name", value=1:15)
analyze.similarity(conceptmap(g1), conceptmap(g2))
</code></pre>

<hr>
<h2 id='analyze.subgraphs'>Analyzing small subgraph patterns.</h2><span id='topic+analyze.subgraphs'></span>

<h3>Description</h3>

<p><code>analyze.subgraphs</code> analyzes the frequency of subgraph patterns given a list of concepts and a set of maps in a conceptmaps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.subgraphs(maps, concept.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.subgraphs_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="analyze.subgraphs_+3A_concept.list">concept.list</code></td>
<td>
<p>A list of concepts (as strings) that define the subgraphs to be analyzed. must be between 2 and 4 concepts in length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements. The first is a vector that contains the absolute number of occurrences for each subgraph pattern.
The second element is a list of igraph objects of the pattern themselves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

analyze.subgraphs(simple_cms, c("1", "2", "3"))
</code></pre>

<hr>
<h2 id='as.matrix.conceptmap'>Convert a conceptmap object to a matrix</h2><span id='topic+as.matrix.conceptmap'></span>

<h3>Description</h3>

<p><code>as.matrix</code> converts a conceptmap object into a matrix. The output can be fed back into <code><a href="#topic+conceptmap.matrix">conceptmap.matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.conceptmap_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="as.matrix.conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 3 columns and one row for each proposition of the concept map.
The 3 columns contain the start and end node of each proposition as well as the label of the edge (as character vectors).
</p>

<hr>
<h2 id='as.matrix.conceptmaps'>Convert a conceptmaps object to a matrix</h2><span id='topic+as.matrix.conceptmaps'></span>

<h3>Description</h3>

<p><code>as.matrix</code> converts a conceptmaps object into a matrix. The output can be fed back into <code><a href="#topic+conceptmaps.matrix">conceptmaps.matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.conceptmaps_+3A_x">x</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="as.matrix.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 4 columns and one row for each proposition of one of the concept maps.
The 4 columns contain an id of the map (starting from 1) and then the start and end node of each proposition as well as the label of the edge (as character vectors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cms = conceptmaps(data)
 as.matrix(cms) 
</code></pre>

<hr>
<h2 id='clustering'>Clustering maps of a conceptmaps object</h2><span id='topic+clustering'></span>

<h3>Description</h3>

<p><code>clustering</code> is a convenience function that implements two frequently used ways of clustering conceptmaps directly.
The first is clustering using the MBMM algorithm and the concept matrix, the second is clustering using the PAM algorithm and 
the graph similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering(maps, method = c("MBMM", "PAM"), min = 1, max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="clustering_+3A_method">method</code></td>
<td>
<p>Either &quot;PAM&quot; or &quot;MBMM&quot;, indicating which algorithm should be used.</p>
</td></tr>
<tr><td><code id="clustering_+3A_min">min</code></td>
<td>
<p>The minimal number of components that is tested. For the PAM algorithm, 1 is not allowed.</p>
</td></tr>
<tr><td><code id="clustering_+3A_max">max</code></td>
<td>
<p>The maximal number of components that is tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of either <code><a href="#topic+MBM.cluster">MBM.cluster</a></code> or <code><a href="#topic+PAM.cluster">PAM.cluster</a></code>, depending on the value of <code>method</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assuming that there are concept maps in folder "~/maps"
cms = read.folder.tgf("~/maps")

clustering(cms, method="MBMM")

## End(Not run)
</code></pre>

<hr>
<h2 id='concept.vector'>Forming the concept vector of a conceptmap object</h2><span id='topic+concept.vector'></span>

<h3>Description</h3>

<p><code>concept.vector</code> transforms a concept map into a numeric vector that contains for each occuring concept the number of 
adjacent edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concept.vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concept.vector_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. The columns are named after the concepts and sorted alphabetically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept map from a random graph
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
cm = conceptmap(g1)

concept.vector(cm)
</code></pre>

<hr>
<h2 id='conceptmap'>Constructing a conceptmap object</h2><span id='topic+conceptmap'></span>

<h3>Description</h3>

<p><code>conceptmap</code> creates an object that encompasses a concept maps. For actual implementations, see
<code><a href="#topic+conceptmap.default">conceptmap.default</a></code>, <code><a href="#topic+conceptmap.igraph">conceptmap.igraph</a></code>, or <code><a href="#topic+conceptmap.matrix">conceptmap.matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conceptmap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmap_+3A_x">x</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>

<hr>
<h2 id='conceptmap.default'>Basic creation of a conceptmap object</h2><span id='topic+conceptmap.default'></span>

<h3>Description</h3>

<p><code>conceptmap</code> creates a conceptmap object based on either an empty concept map or on (matrix) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
conceptmap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmap.default_+3A_x">x</code></td>
<td>
<p>The concept map data. For NULL, an empty concept map is created, otherwise the object is cooerced into a matrix.</p>
</td></tr>
<tr><td><code id="conceptmap.default_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>empty_cm = conceptmap(NULL)
</code></pre>

<hr>
<h2 id='conceptmap.igraph'>Creation of a conceptmap object from an existing graph</h2><span id='topic+conceptmap.igraph'></span>

<h3>Description</h3>

<p><code>conceptmap</code> takes an existing igraph object and tries of coerce it into a conceptmap object (encompassing the igraph object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
conceptmap(x, strip = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmap.igraph_+3A_x">x</code></td>
<td>
<p>An igraph object. It must have an attribute called &quot;name&quot; for both vertices and edges. Additional attributes are preserved for graph, vertices and edges.</p>
</td></tr>
<tr><td><code id="conceptmap.igraph_+3A_strip">strip</code></td>
<td>
<p>If TRUE, nodes without adjacent edges are removed from the graph / concept map.</p>
</td></tr>
<tr><td><code id="conceptmap.igraph_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create conceptmap from a complete graph with 5 nodes
require("igraph")
graph = graph.full(5)
graph = set.vertex.attribute(graph, "name", value=1:5)
simple_cm = conceptmap(graph)
</code></pre>

<hr>
<h2 id='conceptmap.matrix'>Creation of a conceptmap object from matrix data</h2><span id='topic+conceptmap.matrix'></span>

<h3>Description</h3>

<p><code>conceptmap</code> creates a conceptmap object from a given matrix of a particular format (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
conceptmap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmap.matrix_+3A_x">x</code></td>
<td>
<p>A matrix of character vectors with at least 3 columns. Each row is of the form:
start, end, label, (edge attribute 1), ..., (edge attribute m).
Each such row will be interpreted as a directed edge from concept &quot;start&quot; to concept &quot;end&quot; with the name &quot;label&quot; and (optional) m additional edge attributes.
The colum names of <code>map.data</code>, if present, will be preserved as the names for the attributes.</p>
</td></tr>
<tr><td><code id="conceptmap.matrix_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = rbind(cbind("Object", "Class", "is instance of"), cbind("Class", "Attribute", "has"))
cm = conceptmap(data)
</code></pre>

<hr>
<h2 id='conceptmaps'>Constructing a conceptmaps object</h2><span id='topic+conceptmaps'></span>

<h3>Description</h3>

<p><code>conceptmaps</code> creates an object that encompasses a set of concept maps. For actual implementations, see
<code><a href="#topic+conceptmaps.default">conceptmaps.default</a></code>, <code><a href="#topic+conceptmaps.list">conceptmaps.list</a></code>, <code><a href="#topic+conceptmaps.matrix">conceptmaps.matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conceptmaps(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmaps_+3A_x">x</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object.
</p>

<hr>
<h2 id='conceptmaps.default'>Basic creation of a conceptmaps object</h2><span id='topic+conceptmaps.default'></span>

<h3>Description</h3>

<p><code>conceptmaps</code> creates a conceptmaps object based on either an empty set of concept map or on a list of concept maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
conceptmaps(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmaps.default_+3A_x">x</code></td>
<td>
<p>The set of concept maps. For NULL, an empty set of concept maps is created, otherwise the object is cooerced into a list.</p>
</td></tr>
<tr><td><code id="conceptmaps.default_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>empty_cms = conceptmaps(NULL)
</code></pre>

<hr>
<h2 id='conceptmaps.list'>Creation of a conceptmaps object from a list</h2><span id='topic+conceptmaps.list'></span>

<h3>Description</h3>

<p><code>conceptmaps</code> creates a conceptmaps object from a list of conceptmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
conceptmaps(x, filter = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmaps.list_+3A_x">x</code></td>
<td>
<p>A list of conceptmap objects.</p>
</td></tr>
<tr><td><code id="conceptmaps.list_+3A_filter">filter</code></td>
<td>
<p>If TRUE, empty concept maps (i.e. concept maps without any proposition) are not contained in the resulting set.</p>
</td></tr>
<tr><td><code id="conceptmaps.list_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))
</code></pre>

<hr>
<h2 id='conceptmaps.matrix'>Creation of a conceptmaps object from a matrix</h2><span id='topic+conceptmaps.matrix'></span>

<h3>Description</h3>

<p><code>conceptmaps</code> creates a conceptmaps object from a set of concept maps represented as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
conceptmaps(x, filter = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptmaps.matrix_+3A_x">x</code></td>
<td>
<p>A matrix that represents a set of concept maps. The first colum is taken to identify the map, i.e.
for each value occuring in the first column, the rows with identical values are extracted and <code><a href="#topic+conceptmap.matrix">conceptmap.matrix</a></code>
is called on the matrix of these rows and the remaining columns to create a conceptmap object.</p>
</td></tr>
<tr><td><code id="conceptmaps.matrix_+3A_filter">filter</code></td>
<td>
<p>If TRUE, empty concept maps (i.e. concept maps without any proposition) are not contained in the resulting set.</p>
</td></tr>
<tr><td><code id="conceptmaps.matrix_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cms = conceptmaps(data)
</code></pre>

<hr>
<h2 id='edge.vector'>Forming the edge vector of a conceptmap object</h2><span id='topic+edge.vector'></span>

<h3>Description</h3>

<p><code>edge.vector</code> transforms a concept map into a numeric vector that contains for each occuring pair of concepts whether or not
this pair is connected by a proposition in the concept map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.vector_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. The columns are named after the concept-pairs which are sorted alphabetically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept map from a random graph
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
cm = conceptmap(g1)

edge.vector(cm)
</code></pre>

<hr>
<h2 id='get.unified.concepts'>Finding all concepts used.</h2><span id='topic+get.unified.concepts'></span>

<h3>Description</h3>

<p><code>get.unified.concepts</code> identifies the common superset of concepts that is used by the maps of a conceptmaps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.unified.concepts(maps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.unified.concepts_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings of each concepts that appears in at least one of the maps of <code>maps</code>.
</p>

<hr>
<h2 id='Hopkins.index'>Non-randomness of data</h2><span id='topic+Hopkins.index'></span>

<h3>Description</h3>

<p><code>Hopkins.index</code> calculates the Hopkins index that can be used as an indicator of the non-randomness of data prior to clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hopkins.index(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hopkins.index_+3A_data">data</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hopkins index as a numeric value
</p>


<h3>See Also</h3>

<p>The index is described in, e.g.: Han, Jiawei; Kamber, Micheline (2010): Data mining. Concepts and techniques. 2nd ed., Amsterdam: Elsevier/Morgan Kaufmann (The Morgan Kaufmann series in data management systems).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Random data generation, 10 dimensions, 500 observations, 2 clusters, 
#Multivariate-Bernoulli distributed
require("gtools")
data = c()
p = 0.0
for (i in 1:2)
{
temp = c()
for (j in 1:10)
temp = cbind(temp, rbinom(250, 1, p+(i-1)*0.5+(0.025*i)*j))  
data=rbind(data, temp)
}
data = data[permute(1:500),]

Hopkins.index(data)

## End(Not run)
</code></pre>

<hr>
<h2 id='landscape'>Aggregating the maps of a conceptmaps object into a concept landscape</h2><span id='topic+landscape'></span>

<h3>Description</h3>

<p><code>landscape</code> transforms a set of concept maps into a concept landscape using one of several possible methods.
Depending on the value of <code>result</code> and accumulation or amalgamation is performed on the concept map data. The amalgamation
forms a weighted graph based on the unified set of concepts. An accumulation transforms each concept map into a vector and
returns a matrix of these vectors. Using <code>FUN</code> the process of transformation can be influenced in both cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape(maps, result = c("graph", "matrix"), mode, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="landscape_+3A_result">result</code></td>
<td>
<p>Either &quot;graph&quot; or &quot;matrix&quot; defines the return type and the method of aggregation. An amalgamation results in a weighted graph and
an accumulation results a matrix.</p>
</td></tr>
<tr><td><code id="landscape_+3A_mode">mode</code></td>
<td>
<p>If <code>result</code> is &quot;graph&quot;, it can be either &quot;directed&quot; or &quot;undirected&quot; deciding how the graph should be formed. 
First, a weight matrix is formed from the set of concept maps. If <code>FUN</code> is NULL, the weights simply reflect the number of maps in which 
a given edge is present. Otherwise, <code>FUN</code> must be a function that accepts three parameters and returns a numeric value. For the first parameter
the current conceptmap object will be passed and for the second and third parameters the start and end concepts of an edge is passed.
The return value of the function will then be added to the weight matrix. If <code>result</code> is &quot;matrix&quot;, it can be one of &quot;graph.sim&quot;, &quot;concept.vector&quot;, &quot;edge.vector&quot; or &quot;custom&quot;. &quot;graph.sim&quot; return the graph similarity matrix,
&quot;concept.vector&quot; and &quot;edge.vector&quot; return the concept matrix or edge matrix respectively. Finally, &quot;custom&quot; can be used for arbitrary
transformations: For each map, the function passed to <code>FUN</code> and the resulting vector is forming a row of the returned matrix.</p>
</td></tr>
<tr><td><code id="landscape_+3A_fun">FUN</code></td>
<td>
<p>If <code>result</code> is &quot;matrix&quot; and <code>mode</code> is &quot;custom&quot;, a function with one parameter of type conecptmap must be given that is 
called for each of the consituent maps. The function must return a numeric vector of equal length for all maps of a conceptmaps object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>result</code> either an igraph object or a numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

landscape(cms, result="graph", mode="undirected")

landscape(cms, result="matrix", mode="concept.vector")
</code></pre>

<hr>
<h2 id='MBM.cluster'>MBMM clustering</h2><span id='topic+MBM.cluster'></span>

<h3>Description</h3>

<p><code>MBM.cluster</code> calculates a model based clustering using multivariate Bernoulli-mixtures as probabilistic model of the data.
The quality of the clustering is judged using the AIC criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBM.cluster(data, min = 1, max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MBM.cluster_+3A_data">data</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="MBM.cluster_+3A_min">min</code></td>
<td>
<p>The minimal number of components that is tested.</p>
</td></tr>
<tr><td><code id="MBM.cluster_+3A_max">max</code></td>
<td>
<p>The maximal number of components that is tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements. The first element is the minimal AIC value for each tested number of components.
The second element is a vector of all AIC values. The third is the actual clustering as returned by the EM algorithm using
the optimal number of components according to AIC. The element is again a list that contains the mixture coefficients, the actual
parameters of the mutlivariate Benroulli distributions, the probability matrix of each observation (i.e. row if  <code>data</code>) 
and component and the number of iterations that the EM algorithm needed to converge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Random data generation, 100 observations, 5 dimensions, dependencies within the dimensions
data = cbind(round(runif(100)), round(runif(100)), round(runif(100)))
data = cbind(data, data[,2], 1-data[,3])

#Noisy data:
s = round(runif(2, 1, 100))
data[s, c(4,5)] = 1 - data[s, c(4,5)]

#MBMM Clustering
res = MBM.cluster(data, 1,8)
</code></pre>

<hr>
<h2 id='merge.conceptmaps'>Unify sets of conceptmaps</h2><span id='topic+merge.conceptmaps'></span>

<h3>Description</h3>

<p><code>merge</code> takes two conceptsmaps objects and merges the underyling sets of conceptmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.conceptmaps_+3A_x">x</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="merge.conceptmaps_+3A_y">y</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="merge.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object that consist of the maps of <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cm1 = conceptmaps(data[1:2,])
 cm2 = conceptmaps(data[3:5,])
 merge(cm1, cm2)
</code></pre>

<hr>
<h2 id='modify.concepts'>Modify the concepts of concept maps</h2><span id='topic+modify.concepts'></span>

<h3>Description</h3>

<p><code>modify.concepts</code> modifies the list of concept of a concept map or of all maps of a set.
For actual implementations see <code><a href="#topic+modify.concepts.conceptmap">modify.concepts.conceptmap</a></code>, or <code><a href="#topic+modify.concepts.conceptmaps">modify.concepts.conceptmaps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify.concepts(x, concept.list, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify.concepts_+3A_x">x</code></td>
<td>
<p>A conceptmap or conceptmaps object.</p>
</td></tr>
<tr><td><code id="modify.concepts_+3A_concept.list">concept.list</code></td>
<td>
<p>A list of concepts.</p>
</td></tr>
<tr><td><code id="modify.concepts_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps or conceptmap object.
</p>

<hr>
<h2 id='modify.concepts.conceptmap'>Adapt list of concepts of a conceptmap object</h2><span id='topic+modify.concepts.conceptmap'></span>

<h3>Description</h3>

<p><code>modify.concepts</code> modifes the list of concepts according to a given list.
This includes removing concepts and adjacent propositions as well as adding (unconnected) concepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
modify.concepts(x, concept.list, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify.concepts.conceptmap_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="modify.concepts.conceptmap_+3A_concept.list">concept.list</code></td>
<td>
<p>A vector of strings that contains the list of concepts.</p>
</td></tr>
<tr><td><code id="modify.concepts.conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object that encompasses exactly the concepts of <code>concept.list</code>.
Concepts not originally in <code>map</code> are added as isolated nodes/concepts. Concepts of <code>map</code> that are not in <code>concept.list</code>
are removed together with their adjacent propositions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = rbind(cbind("Object", "Class", "is instance of"), cbind("Class", "Attribute", "has"))
cm = conceptmap(data)
modify.concepts(cm, c("Object", "Class", "Method"))
</code></pre>

<hr>
<h2 id='modify.concepts.conceptmaps'>Modifying the concepts of all maps of a conceptmaps object.</h2><span id='topic+modify.concepts.conceptmaps'></span>

<h3>Description</h3>

<p><code>modify.concepts</code> calls <code><a href="#topic+modify.concepts.conceptmap">modify.concepts.conceptmap</a></code> for each conceptmap object of a conceptmaps object.
Therefore, all concept maps will share the same set of concepts afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
modify.concepts(x, concept.list, filter = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify.concepts.conceptmaps_+3A_x">x</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="modify.concepts.conceptmaps_+3A_concept.list">concept.list</code></td>
<td>
<p>A vector of strings that contains the list of concepts.</p>
</td></tr>
<tr><td><code id="modify.concepts.conceptmaps_+3A_filter">filter</code></td>
<td>
<p>If TRUE, concept maps that contain no propositions after the concept modification are removed from the result.</p>
</td></tr>
<tr><td><code id="modify.concepts.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object that contains (possibly a subset of) the maps of <code>maps</code> in which every map contains the concepts of <code>concept.list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cms = conceptmaps(data)
 
 modify.concepts(cms, c("Object", "Class"), filter=TRUE)
</code></pre>

<hr>
<h2 id='PAM.cluster'>Similarity based clustering</h2><span id='topic+PAM.cluster'></span>

<h3>Description</h3>

<p><code>PAM.cluster</code> calculates a clustering using the PAM algorithm (k-medoids). The quality of the clustering is judged using the 
G1 index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PAM.cluster(data, min = 2, max = 10, metric = "manhattan")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PAM.cluster_+3A_data">data</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="PAM.cluster_+3A_min">min</code></td>
<td>
<p>The minimal number of components that is tested. Must be at least 2.</p>
</td></tr>
<tr><td><code id="PAM.cluster_+3A_max">max</code></td>
<td>
<p>The maximal number of components that is tested.</p>
</td></tr>
<tr><td><code id="PAM.cluster_+3A_metric">metric</code></td>
<td>
<p>If empty, data will be treated as a distance matrix. Otherwise, the value will be passed to the call of <code>dist</code> 
to compute the distance matrix from <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements. The first element contains the optimal number of components according to the G1 index. 
The second element contains a vector of the G1 values. The thrid element contains the clustering itself, 
i.e. the return value of <code>PAM</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Random data generation, 10 dimensions, 500 observations, 2 clusters
require("gtools")
data = c()
p = 0.0
for (i in 1:2)
{
temp = c()
for (j in 1:10)
temp = cbind(temp, rbinom(250, 1, p+(i-1)*0.5+(0.025*i)*j))  
data=rbind(data, temp)
}
data = data[permute(1:500),]

PAM.cluster(data)

## End(Not run)
</code></pre>

<hr>
<h2 id='pathfinder'>Construct a Pathfinder network from a conceptmap or a concept landscape</h2><span id='topic+pathfinder'></span>

<h3>Description</h3>

<p><code>pathfinder</code> creates Pathfinder network. For more information and actual implementations
see <code><a href="#topic+pathfinder.matrix">pathfinder.matrix</a></code>, <code><a href="#topic+pathfinder.conceptmaps">pathfinder.conceptmaps</a></code>, or <code><a href="#topic+pathfinder.igraph">pathfinder.igraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathfinder(data, q, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathfinder_+3A_data">data</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="pathfinder_+3A_q">q</code></td>
<td>
<p>The q parameter of the Pathfinder algorithm.</p>
</td></tr>
<tr><td><code id="pathfinder_+3A_r">r</code></td>
<td>
<p>The r parameter of the Pathfinder algorithm.</p>
</td></tr>
<tr><td><code id="pathfinder_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Pathfinder network of the input data.
</p>

<hr>
<h2 id='pathfinder.conceptmaps'>Creating a Pathfinder network from a conceptmaps object</h2><span id='topic+pathfinder.conceptmaps'></span>

<h3>Description</h3>

<p><code>pathfinder</code> creates the Pathfinder network from a given set of conceptmaps. The conecpts of each concept map are
unified, then the concept maps are transformed into a weight matrix and <code><a href="#topic+pathfinder.matrix">pathfinder.matrix</a></code> is called on the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
pathfinder(data, q = 2, r = 1, threshold = 0,
  directed = F, prune.edges = F, return.cm = F, filename = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathfinder.conceptmaps_+3A_data">data</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_q">q</code></td>
<td>
<p>The parameter q used in the Pathfinder algorithm. The resulting graph will be q-triangular.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_r">r</code></td>
<td>
<p>The parameter r used in the Pathfinder algorithm for the r-metric.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value used for pruning the graph before the Pathfinder algorithm. The pruning works in conjunction with
the value of <code>prune.edges</code>.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_directed">directed</code></td>
<td>
<p>if TRUE, the direction of the edges will be kept and the resulting Pathfinder network will be directed as well.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_prune.edges">prune.edges</code></td>
<td>
<p>If TRUE, each entry of the weight matrix that is lower than <code>threshold</code> will be set to 0 and columns
with a resulting sum of 0 are removed. If FALSE, only columns of the weight matrix with a sum of less than <code>threshold</code> 
will be removed.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_return.cm">return.cm</code></td>
<td>
<p>If TRUE, a conceptmap object will be returned. Otherwise, an igrpah object will be returned.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_filename">filename</code></td>
<td>
<p>Optional. If specified, the resulting Pathfinder network will be stored in TGF format in the given file.</p>
</td></tr>
<tr><td><code id="pathfinder.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>return.cm</code> either an igraph object or a conceptmap object that represents the Pathfinder network.
If an igraph object is returned, the graph will be weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

#Create Pathfinder network from data and return a conceptmap object
cm = pathfinder(simple_cms, q=1, return.cm=TRUE)
</code></pre>

<hr>
<h2 id='pathfinder.igraph'>Creating a Pathfinder network from an igraph object</h2><span id='topic+pathfinder.igraph'></span>

<h3>Description</h3>

<p><code>pathfinder</code> creates the Pathfinder network from a weighted graph based on <code><a href="#topic+pathfinder.matrix">pathfinder.matrix</a></code>. It is a convenience method that can be called
on the result of a call to <code><a href="#topic+landscape">landscape</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
pathfinder(data, q = 2, r = 1, threshold = 0,
  prune.edges = F, filename = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathfinder.igraph_+3A_data">data</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_q">q</code></td>
<td>
<p>The parameter q used in the Pathfinder algorithm. The resulting graph will be q-triangular.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_r">r</code></td>
<td>
<p>The parameter r used in the Pathfinder algorithm for the r-metric.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value used for pruning the graph before the Pathfinder algorithm. The pruning works in conjunction with
the value of <code>prune.edges</code>.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_prune.edges">prune.edges</code></td>
<td>
<p>If TRUE, each entry of the weight matrix that is lower than <code>threshold</code> will be set to 0 and columns
with a resulting sum of 0 are removed. If FALSE, only columns of the weight matrix with a sum of less than <code>threshold</code> 
will be removed.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_filename">filename</code></td>
<td>
<p>Optional. If specified, the resulting Pathfinder network will be stored in TGF format in the given file.</p>
</td></tr>
<tr><td><code id="pathfinder.igraph_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object that represents the Pathfinder network as a weighted graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))
pathfinder(landscape(simple_cms, result="graph", mode="undirected"))
</code></pre>

<hr>
<h2 id='pathfinder.matrix'>Creating a Pathfinder network from a matrix</h2><span id='topic+pathfinder.matrix'></span>

<h3>Description</h3>

<p><code>pathfinder</code> creates the Pathfinder network from a given weight matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
pathfinder(data, q, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathfinder.matrix_+3A_data">data</code></td>
<td>
<p>A non-negative weight matrix of a graph that can be either directed or undirected.</p>
</td></tr>
<tr><td><code id="pathfinder.matrix_+3A_q">q</code></td>
<td>
<p>The parameter q used in the Pathfinder algorithm. The resulting graph will be q-triangular.</p>
</td></tr>
<tr><td><code id="pathfinder.matrix_+3A_r">r</code></td>
<td>
<p>The parameter r used in the Pathfinder algorithm for the r-metric.</p>
</td></tr>
<tr><td><code id="pathfinder.matrix_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric weight matrix that represented the Pathfinder graph of the input graph.
</p>


<h3>See Also</h3>

<p>The Pathfinder algorithm is implemented based on the description in:
Dearholt, Donald W.; Schvaneveldt, Roger W. (1990): Properties of Pathfinder Netowrks. In: Roger W. Schvaneveldt (Hg.): Pathfinder associative networks. Studies in knowledge organizations. Norwood, N.J: Ablex Pub. Corp., S. 1-30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Manually create a weighted graph
data = matrix(data = 0, nrow = 6, ncol=6)
colnames(data) &lt;- c("Object", "Class", "Method", "Attribute", "Visibility", "Algorithm")
rownames(data) &lt;- c("Object", "Class", "Method", "Attribute", "Visibility", "Algorithm")
data["Object", "Class"] = 3
data["Object", "Method"] = 3
data["Object", "Attribute"] = 10
data["Object", "Visibility"] = Inf
data["Object", "Algorithm"] = 9
data["Class", "Method"] = 7
data["Class", "Attribute"] = 6
data["Class", "Visibility"] = 8
data["Class", "Algorithm"] = 10
data["Method", "Attribute"] = 4
data["Method", "Visibility"] = 9
data["Method", "Algorithm"] = 3
data["Attribute", "Visibility"] = 5
data["Attribute", "Algorithm"] = 10
data["Visibility", "Algorithm"] = Inf

data = data + t(data)

#Run the Pathfinder algorithm with several different parameters
pathfinder(data, 5, 1)
pathfinder(data, 2, 1)
pathfinder(data, 5,Inf)
pathfinder(data, 2, Inf)
</code></pre>

<hr>
<h2 id='plot.conceptmap'>Plotting a conceptmap</h2><span id='topic+plot.conceptmap'></span>

<h3>Description</h3>

<p><code>plot</code> plots a concept map. Includes finding a good layout based on communities and a circular layout.
Is especially suited for plotting larger concept maps, in particular amalgamations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
plot(x, edge.labels = T, max.label.len = 25,
  scale = 1, layout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.conceptmap_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="plot.conceptmap_+3A_edge.labels">edge.labels</code></td>
<td>
<p>If TRUE, the labels of edges will be plotted as well.</p>
</td></tr>
<tr><td><code id="plot.conceptmap_+3A_max.label.len">max.label.len</code></td>
<td>
<p>The maximal length of labels (in characters) that are plotted completely. Longer labels will be shortend by &quot;...&quot;.</p>
</td></tr>
<tr><td><code id="plot.conceptmap_+3A_scale">scale</code></td>
<td>
<p>Overall scaling factor that is applied to the plot.</p>
</td></tr>
<tr><td><code id="plot.conceptmap_+3A_layout">layout</code></td>
<td>
<p>If not NULL, must either be one of &quot;fruchterman.reingold&quot;, &quot;kamada.kawai&quot;, &quot;spring&quot; or &quot;reingold.tilford&quot; or a numeric matrix.
If it is a string, the corresponding layouting algorithm of the igraph package will be called. If it is a numeric matrix, it must contain a row
for each concept and two columns that determine the x and y coordinates of this concept. Then this layout will be used directly.</p>
</td></tr>
<tr><td><code id="plot.conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept map from a random graph
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
E(g1)$name &lt;- rep("", length(E(g1)))
plot(conceptmap(g1), edge.labels=FALSE, layout="kamada.kawai")
</code></pre>

<hr>
<h2 id='plot.conceptmaps'>Plotting a series of concept maps</h2><span id='topic+plot.conceptmaps'></span>

<h3>Description</h3>

<p><code>plot</code> plots a set of concept maps. The layout is determined based on the union of all concept maps, then each
map is individually plotted using this fixed layout. Is escpecially useful for visualizing horizontal landscapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
plot(x, edge.labels = T, max.label.len = 25,
  scale = 1, layout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.conceptmaps_+3A_x">x</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="plot.conceptmaps_+3A_edge.labels">edge.labels</code></td>
<td>
<p>If TRUE, the labels of edges will be plotted as well.</p>
</td></tr>
<tr><td><code id="plot.conceptmaps_+3A_max.label.len">max.label.len</code></td>
<td>
<p>The maximal length of labels (in characters) that are plotted completely. Longer labels will be shortend by &quot;...&quot;.</p>
</td></tr>
<tr><td><code id="plot.conceptmaps_+3A_scale">scale</code></td>
<td>
<p>Overall scaling factor that is applied to the plot.</p>
</td></tr>
<tr><td><code id="plot.conceptmaps_+3A_layout">layout</code></td>
<td>
<p>If not NULL, must be one of &quot;fruchterman.reingold&quot;, &quot;kamada.kawai&quot;, &quot;spring&quot; or &quot;reingold.tilford&quot;.
The corresponding layouting algorithm of the igraph package will be called. If it is NULL, the layouting based on communities and
a circular layout will be used.</p>
</td></tr>
<tr><td><code id="plot.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
E(g1)$name &lt;- rep("", length(E(g1)))
E(g2)$name &lt;- rep("", length(E(g2)))
E(g3)$name &lt;- rep("", length(E(g3)))
#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

plot(simple_cms, layout="spring")
</code></pre>

<hr>
<h2 id='print.conceptmap'>Display basic information of a conceptmap object</h2><span id='topic+print.conceptmap'></span>

<h3>Description</h3>

<p><code>print</code> displays basic information. For plotting, see <code><a href="#topic+plot.conceptmap">plot.conceptmap</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.conceptmap_+3A_x">x</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="print.conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>

<hr>
<h2 id='print.conceptmaps'>Display basic information of a conceptmaps object</h2><span id='topic+print.conceptmaps'></span>

<h3>Description</h3>

<p><code>print</code> displays basic information. For plotting, see <code><a href="#topic+plot.conceptmaps">plot.conceptmaps</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.conceptmaps_+3A_x">x</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="print.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>

<hr>
<h2 id='read.folder.tgf'>Importing a set of concept maps from TGF files.</h2><span id='topic+read.folder.tgf'></span>

<h3>Description</h3>

<p><code>read.folder.tgf</code> reads several TGF files and imports them as a conceptmaps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.folder.tgf(folder, strip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.folder.tgf_+3A_folder">folder</code></td>
<td>
<p>The path of a folder in which every TGF file is read.</p>
</td></tr>
<tr><td><code id="read.folder.tgf_+3A_strip">strip</code></td>
<td>
<p>Passed to the call of <code><a href="#topic+read.tgf">read.tgf</a></code> that is used to import the single concept maps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of a conceptmaps object and the list of filenames (in the same order as the maps in the conceptmaps object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assuming that the data is in the folder "~/cmaps"
cm = read.folder.tgf("~/cmaps")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.folder.yEd'>Importing a set of concept maps from GraphML files.</h2><span id='topic+read.folder.yEd'></span>

<h3>Description</h3>

<p><code>read.folder.yEd</code> reads several graphML files that were created by yEd and imports them as a conceptmaps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.folder.yEd(folder, strip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.folder.yEd_+3A_folder">folder</code></td>
<td>
<p>The path of a folder in which every graphML file is read.</p>
</td></tr>
<tr><td><code id="read.folder.yEd_+3A_strip">strip</code></td>
<td>
<p>Passed to the call of <code><a href="#topic+read.yEd">read.yEd</a></code> that is used to import the single concept maps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of a conceptmaps object and the list of filenames (in the same order as the maps in the conceptmaps object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assuming that the data is in the folder "~/cmaps"
cm = read.folder.yEd("~/cmaps")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.tgf'>Importing a concept map from a TGF file.</h2><span id='topic+read.tgf'></span>

<h3>Description</h3>

<p><code>read.tgf</code> reads a TGF file and imports the graph as a conceptmap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.tgf(file, strip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tgf_+3A_file">file</code></td>
<td>
<p>The filename and path that should be read.</p>
</td></tr>
<tr><td><code id="read.tgf_+3A_strip">strip</code></td>
<td>
<p>Passed to the call of <code><a href="#topic+conceptmap.igraph">conceptmap.igraph</a></code> that is used to create the conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assuming that the data is in "~/cmap.tgf"
cm = read.tgf("~/cmap.tgf")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.yEd'>Importing a concept map from a GraphML file.</h2><span id='topic+read.yEd'></span>

<h3>Description</h3>

<p><code>read.yEd</code> reads a graphML file that was created by yEd and imports the graph as a conceptmap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.yEd(file, strip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.yEd_+3A_file">file</code></td>
<td>
<p>The filename and path that should be read.</p>
</td></tr>
<tr><td><code id="read.yEd_+3A_strip">strip</code></td>
<td>
<p>Passed to the call of <code><a href="#topic+conceptmap.igraph">conceptmap.igraph</a></code> that is used to create the conceptmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmap object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Assuming that the data is in "~/cmap.graphml"
cm = read.yEd("~/cmap.graphml")

## End(Not run)
</code></pre>

<hr>
<h2 id='splice'>Select a subset of a set of conceptmaps</h2><span id='topic+splice'></span>

<h3>Description</h3>

<p><code>splice</code> selects a subset of a set of concept maps and returns them as a new conceptmaps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splice(maps, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splice_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="splice_+3A_keep">keep</code></td>
<td>
<p>A numeric vector containing the indices of the maps in <code>maps</code> that should be retained in the subset.
Regular R list indexing is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object that consist of the maps with indiced of <code>maps</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cms = conceptmaps(data)
 
 splice(cms, c(1,3))
</code></pre>

<hr>
<h2 id='summary.conceptmap'>Return basic information of a conceptmap object</h2><span id='topic+summary.conceptmap'></span>

<h3>Description</h3>

<p><code>summary</code> returns basic information about a conceptmap object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmap'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.conceptmap_+3A_object">object</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="summary.conceptmap_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the number of concepts, edges and components of the concept map.
</p>

<hr>
<h2 id='summary.conceptmaps'>Return basic information of a conceptmaps object</h2><span id='topic+summary.conceptmaps'></span>

<h3>Description</h3>

<p><code>summary</code> returns basic information about a conceptmaps object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conceptmaps'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.conceptmaps_+3A_object">object</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
<tr><td><code id="summary.conceptmaps_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one column for each concept map in the set and the number of concepts, edges, and components of this map
respectively in 3 rows.
</p>

<hr>
<h2 id='unify.concepts'>Unifying the concepts of a conceptmap object.</h2><span id='topic+unify.concepts'></span>

<h3>Description</h3>

<p><code>unify.concepts</code> first calls <code><a href="#topic+get.unified.concepts">get.unified.concepts</a></code> on the maps of a conceptmaps object and then calls
<code><a href="#topic+modify.concepts.conceptmaps">modify.concepts.conceptmaps</a></code> on each of the constituent maps. Afterwards, therefore, each map of the conceptmaps object will
share the same common superset of concepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unify.concepts(maps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unify.concepts_+3A_maps">maps</code></td>
<td>
<p>A conceptmaps object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conceptmaps object in of the same map of <code>maps</code>, in which every map shares the same concepts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = rbind(
 cbind("1", "Object", "Class", "is instance of"),
 cbind("1", "Object", "Attribute", "has"),
 cbind("2", "Class", "Attribute", "possesses"),
 cbind("2", "Attribute", "Data-type", "has"),
 cbind("3", "Object", "Class", "is instance of")
 )
 cms = conceptmaps(data)
 
 unify.concepts(cms)
</code></pre>

<hr>
<h2 id='write.tgf'>Saving a concept map to a TGF file</h2><span id='topic+write.tgf'></span>

<h3>Description</h3>

<p><code>write.tgf</code> stores the graph underlying a conceptmap object into a file using the &quot;Trivial Grpah Format&quot; (TGF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.tgf(map, file, translation = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.tgf_+3A_map">map</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="write.tgf_+3A_file">file</code></td>
<td>
<p>The location including filename where the file should be stored.</p>
</td></tr>
<tr><td><code id="write.tgf_+3A_translation">translation</code></td>
<td>
<p>If not NULL, a vector of strings of equal length as the number of concepts used in the concept map.
Then, the names given in this vector will be used in the file instead of the original concepts. Can be used, for example,
to translate the concepts into a different language for export.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create concept map from a random graph
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

write.tgf(conceptmap(g1), "~/cmap.tgf", 
          translation = c("Node_1", "Node_2", "Node_3", "Node_4", "Node_5"))

## End(Not run)
</code></pre>

<hr>
<h2 id='write.tgf.folder'>Saving a set of concept maps to TGF files</h2><span id='topic+write.tgf.folder'></span>

<h3>Description</h3>

<p><code>write.tgf.folder</code> stores the graphs underlying the maps of a conceptmaps object into a folder using the &quot;Trivial Grpah Format&quot; (TGF).
The function calls <code><a href="#topic+write.tgf">write.tgf</a></code> for each of the maps of a conceptmaps object. The files will be named &quot;1.tgf&quot;, &quot;2.tgf&quot; and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.tgf.folder(maps, folder, translation = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.tgf.folder_+3A_maps">maps</code></td>
<td>
<p>A conceptmap object.</p>
</td></tr>
<tr><td><code id="write.tgf.folder_+3A_folder">folder</code></td>
<td>
<p>The location where the files should be stored. The folder is created, if necessary.</p>
</td></tr>
<tr><td><code id="write.tgf.folder_+3A_translation">translation</code></td>
<td>
<p>See <code><a href="#topic+write.tgf">write.tgf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create concept maps from three random graphs
require("igraph")
g1 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g2 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)
g3 = set.vertex.attribute(erdos.renyi.game(5, 0.7, type="gnp"), "name", value=1:5)

#Create conceptmaps object from three conceptmap objects
simple_cms = conceptmaps(list(conceptmap(g1), conceptmap(g2), conceptmap(g3)))

write.tgf.folder(simple_cms, "~/cmaps")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
