<!DOCTYPE html><html lang="en"><head><title>Help for package causalDisco</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {causalDisco}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_confusion'><p>Compute confusion matrix for comparing two adjacency matrices</p></a></li>
<li><a href='#as.graphNEL'><p>Convert adjacency matrix to graphNEL object</p></a></li>
<li><a href='#average_degree'><p>Compute average degree for adjacency matrix</p></a></li>
<li><a href='#compare'><p>Compare two tpdag or tskeleton objects</p></a></li>
<li><a href='#confusion'><p>Compute confusion matrix for comparing two adjacency matrices</p></a></li>
<li><a href='#corTest'><p>Test for vanishing partial correlations</p></a></li>
<li><a href='#dir_confusion'><p>Compute confusion matrix for comparing two adjacency matrices</p></a></li>
<li><a href='#edges'><p>List of edges in adjacency matrix</p></a></li>
<li><a href='#essgraph2amat'><p>Convert essential graph to adjacency matrix</p></a></li>
<li><a href='#evaluate'><p>Evaluate adjacency matrix estimation</p></a></li>
<li><a href='#evaluate.array'><p>Evaluate adjacency matrix estimation</p></a></li>
<li><a href='#evaluate.matrix'><p>Evaluate adjacency matrix estimation</p></a></li>
<li><a href='#evaluate.tamat'><p>Evaluate adjacency matrix estimation</p></a></li>
<li><a href='#F1'><p>F1 score</p></a></li>
<li><a href='#FDR'><p>False Discovery Rate</p></a></li>
<li><a href='#FOR'><p>False Omission Rate</p></a></li>
<li><a href='#G1'><p>G1 score</p></a></li>
<li><a href='#gausCorScore'><p>Gaussian L0 score computed on correlation matrix</p></a></li>
<li><a href='#graph2amat'><p>Convert graphNEL object to adjacency matrix</p></a></li>
<li><a href='#is_cpdag'><p>Check for CPDAG</p></a></li>
<li><a href='#is_pdag'><p>Check for PDAG</p></a></li>
<li><a href='#maketikz'><p>Generate Latex tikz code for plotting a temporal DAG or PDAG.</p></a></li>
<li><a href='#maxnedges'><p>Compute maximal number of edges for graph</p></a></li>
<li><a href='#nDAGs'><p>Number of different DAGs</p></a></li>
<li><a href='#nedges'><p>Number of edges in adjacency matrix</p></a></li>
<li><a href='#NPV'><p>Negative predictive value</p></a></li>
<li><a href='#plot.tamat'><p>Plot adjacency matrix with order information</p></a></li>
<li><a href='#plot.tpdag'><p>Plot temporal partially directed acyclic graph (TPDAG)</p></a></li>
<li><a href='#plot.tskeleton'><p>Plot temporal skeleton</p></a></li>
<li><a href='#plotTempoMech'><p>Plot temporal data generating mechanism</p></a></li>
<li><a href='#precision'><p>Precision</p></a></li>
<li><a href='#probmat2amat'><p>Convert a matrix of probabilities into an adjacency matrix</p></a></li>
<li><a href='#recall'><p>Recall</p></a></li>
<li><a href='#regTest'><p>Regression-based information loss test</p></a></li>
<li><a href='#shd'><p>Structural hamming distance between adjacency matrices</p></a></li>
<li><a href='#simDAG'><p>Simulate a random DAG</p></a></li>
<li><a href='#simGausFromDAG'><p>Simulate Gaussian data according to DAG</p></a></li>
<li><a href='#specificity'><p>Specificity</p></a></li>
<li><a href='#tamat'><p>Make a temporal adjacency matrix</p></a></li>
<li><a href='#tpc'><p>Perform causal discovery using the temporal PC algorithm (TPC)</p></a></li>
<li><a href='#tpcExample'><p>Simulated data example</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Causal Discovery on Observational Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Various tools for inferring causal models from observational data. The package 
    includes an implementation of the temporal Peter-Clark (TPC) algorithm. Petersen, Osler 
    and Ekstr√∏m (2021) &lt;<a href="https://doi.org/10.1093%2Faje%2Fkwab087">doi:10.1093/aje/kwab087</a>&gt;. It also includes general tools
    for evaluating differences in adjacency matrices, which can be used for evaluating
    performance of causal discovery procedures. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/annennenne/causalDisco">https://github.com/annennenne/causalDisco</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/annennenne/causalDisco/issues">https://github.com/annennenne/causalDisco/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>pcalg, igraph, RColorBrewer, gtools, clipr, methods, scales</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-10 16:40:10 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Anne Helby Petersen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anne Helby Petersen &lt;ahpe@sund.ku.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-12 07:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_confusion'>Compute confusion matrix for comparing two adjacency matrices</h2><span id='topic+adj_confusion'></span>

<h3>Description</h3>

<p>Two adjacency matrices are compared either in terms of adjacencies
(<code>type = "adj"</code>) or orientations (<code>type = "dir"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_confusion(est_amat, true_amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj_confusion_+3A_est_amat">est_amat</code></td>
<td>
<p>The estimated adjacency matrix</p>
</td></tr>
<tr><td><code id="adj_confusion_+3A_true_amat">true_amat</code></td>
<td>
<p>The true adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the former case, the confusion matrix is a cross-tabulation
of adjacencies.
</p>
<p>In the latter case, the orientation confusion matrix is conditional on agreement on
adjacency. This means that only adjacencies that are shared in both input matrices are
considered, and agreement wrt. orientation is then computed only among these edges
that occur in both matrices. A true positive is a correctly placed arrowhead (1),
a false positive marks placement of arrowhead (1) where there should have been a tail (0),
a false negative marks placement of tail (0) where there should have been an arrowhead (1),
and a true negative marks correct placement of a tail (0).
</p>


<h3>Value</h3>

<p>A list with entries <code>$tp</code> (number of true positives),  <code>$tn</code> (number of true negatives),
<code>$fp</code> (number of false positives), and  <code>$tp</code> (number of false negatives).
</p>

<hr>
<h2 id='as.graphNEL'>Convert adjacency matrix to graphNEL object</h2><span id='topic+as.graphNEL'></span>

<h3>Description</h3>

<p>Convert adjacency matrix to graphNEL object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.graphNEL(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.graphNEL_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>graphNEL</code> object, see  <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code>.
</p>

<hr>
<h2 id='average_degree'>Compute average degree for adjacency matrix</h2><span id='topic+average_degree'></span>

<h3>Description</h3>

<p>Computes the average degree, i.e. the number of edges divided
by the number of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_degree(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_degree_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='compare'>Compare two tpdag or tskeleton objects</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Compare edges in two tpdag objects or two tskeleton objects.
Note that they should be based on the same variables.
Only edge absence/presence is compared, not edge orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_+3A_x">x</code></td>
<td>
<p>First object</p>
</td></tr>
<tr><td><code id="compare_+3A_y">y</code></td>
<td>
<p>Second object (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries: <code>$nedges1</code> (the number of
edges in the first object), <code>$nedges2</code> (the number of edges
in the second object), <code>$psi1</code> (the test significance level
of the first object), <code>$psi2</code> (the test significance level of
the second object), <code>$nadded</code> (the number of additional edges in
object 2, relative to object 1), and <code>nremoved</code> (the number of
absent edges in object 2, relative to object 1).
</p>

<hr>
<h2 id='confusion'>Compute confusion matrix for comparing two adjacency matrices</h2><span id='topic+confusion'></span>

<h3>Description</h3>

<p>Two adjacency matrices are compared either in terms of adjacencies
(<code>type = "adj"</code>) or orientations (<code>type = "dir"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusion(est_amat, true_amat, type = "adj")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confusion_+3A_est_amat">est_amat</code></td>
<td>
<p>The estimated adjacency matrix</p>
</td></tr>
<tr><td><code id="confusion_+3A_true_amat">true_amat</code></td>
<td>
<p>The true adjacency matrix</p>
</td></tr>
<tr><td><code id="confusion_+3A_type">type</code></td>
<td>
<p>String indicating whether the confusion matrix should be computed for adjacencies
(<code>"adj"</code>, the default) or for (conditional) orientations (<code>dir</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the former case, the confusion matrix is a cross-tabulation
of adjacencies.
</p>
<p>In the latter case, the orientation confusion matrix is conditional on agreement on
adjacency. This means that only adjacencies that are shared in both input matrices are
considered, and agreement wrt. orientation is then computed only among these edges
that occur in both matrices. A true positive is a correctly placed arrowhead (1),
a false positive marks placement of arrowhead (1) where there should have been a tail (0),
a false negative marks placement of tail (0) where there should have been an arrowhead (1),
and a true negative marks correct placement of a tail (0).
</p>


<h3>Value</h3>

<p>A list with entries <code>$tp</code> (number of true positives),  <code>$tn</code> (number of true negatives),
<code>$fp</code> (number of false positives), and  <code>$tp</code> (number of false negatives).
</p>

<hr>
<h2 id='corTest'>Test for vanishing partial correlations</h2><span id='topic+corTest'></span>

<h3>Description</h3>

<p>This function simply calls the <code><a href="pcalg.html#topic+gaussCItest">gaussCItest</a></code>
function from the <code>pcalg</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corTest(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corTest_+3A_x">x</code></td>
<td>
<p>Index of x variable</p>
</td></tr>
<tr><td><code id="corTest_+3A_y">y</code></td>
<td>
<p>Index of y variable</p>
</td></tr>
<tr><td><code id="corTest_+3A_s">S</code></td>
<td>
<p>Index of S variable(s), possibly NULL</p>
</td></tr>
<tr><td><code id="corTest_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic; list with data,
binary variables and order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric, which is the p-value of the test.
</p>

<hr>
<h2 id='dir_confusion'>Compute confusion matrix for comparing two adjacency matrices</h2><span id='topic+dir_confusion'></span>

<h3>Description</h3>

<p>Two adjacency matrices are compared either in terms of adjacencies
(<code>type = "adj"</code>) or orientations (<code>type = "dir"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_confusion(est_amat, true_amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dir_confusion_+3A_est_amat">est_amat</code></td>
<td>
<p>The estimated adjacency matrix</p>
</td></tr>
<tr><td><code id="dir_confusion_+3A_true_amat">true_amat</code></td>
<td>
<p>The true adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the former case, the confusion matrix is a cross-tabulation
of adjacencies.
</p>
<p>In the latter case, the orientation confusion matrix is conditional on agreement on
adjacency. This means that only adjacencies that are shared in both input matrices are
considered, and agreement wrt. orientation is then computed only among these edges
that occur in both matrices. A true positive is a correctly placed arrowhead (1),
a false positive marks placement of arrowhead (1) where there should have been a tail (0),
a false negative marks placement of tail (0) where there should have been an arrowhead (1),
and a true negative marks correct placement of a tail (0).
</p>


<h3>Value</h3>

<p>A list with entries <code>$tp</code> (number of true positives),  <code>$tn</code> (number of true negatives),
<code>$fp</code> (number of false positives), and  <code>$tp</code> (number of false negatives).
</p>

<hr>
<h2 id='edges'>List of edges in adjacency matrix</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>Produces a list of edges from an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edges_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of two lists: One for oriented edges (<code>$dir</code>),
and one for unoriented edges (<code>$undir</code>).
</p>

<hr>
<h2 id='essgraph2amat'>Convert essential graph to adjacency matrix</h2><span id='topic+essgraph2amat'></span>

<h3>Description</h3>

<p>Extracts the adjacency matrix from an <code><a href="pcalg.html#topic+EssGraph-class">EssGraph-class</a></code> object. This object is returned
by score-based causal discovery algorithms in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>essgraph2amat(essgraph, p = length(essgraph$field(".nodes")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="essgraph2amat_+3A_essgraph">essgraph</code></td>
<td>
<p>An <code>EssGraph</code> object</p>
</td></tr>
<tr><td><code id="essgraph2amat_+3A_p">p</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix (square matrix with 0/1 entries).
</p>

<hr>
<h2 id='evaluate'>Evaluate adjacency matrix estimation</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Applies several different metrics to evaluate difference between
estimated and true adjacency matrices. Intended to be used to evaluate
performance of causal discovery algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(est, true, metrics, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_+3A_est">est</code></td>
<td>
<p>Estimated adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_true">true</code></td>
<td>
<p>True adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_metrics">metrics</code></td>
<td>
<p>List of metrics, see details.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>
<p>Further arguments that depend on input type.  Currently only <code>list.out</code> is allowed, and
only if the first argument is a matrix (see details under Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two options for input are available: Either <code>est</code> and <code>true</code>
can be two adjacency matrices, or they can be two arrays of adjacency matrices.
The arrays should have shape <code class="reqn">n * p * p</code> where n is the number of of matrices,
and p is the number of nodes/variables.
</p>
<p>The metrics should be given as a list with slots <code>$adj</code>, <code>$dir</code> and
<code>$other</code>. Metrics under <code>$adj</code> are applied to the adjacency confusion
matrix, while metrics under <code>$dir</code> are applied to the conditional orientation
confusion matrix (see <a href="#topic+confusion">confusion</a>). Metrics under <code>$other</code> are applied
without computing confusion matrices first.
</p>
<p>Available metrics to be used with confusion matrices are <a href="#topic+precision">precision</a>, <a href="#topic+recall">recall</a>,
<a href="#topic+specificity">specificity</a>, <a href="#topic+FOR">FOR</a>, <a href="#topic+FDR">FDR</a>, <a href="#topic+NPV">NPV</a>, <a href="#topic+F1">F1</a> and <a href="#topic+G1">G1</a>. The user
can supply custom metrics as well: They need to have the confusion matrix as their first
argument and should return a numeric.
</p>
<p>Available metrics to be used as &quot;other&quot; is: <a href="#topic+shd">shd</a>. The user
can supply custom metrics as well: They need to have arguments <code>est_amat</code> and <code>true_amat</code>,
where the former is the estimated adjacency matrix and the latter is the true adjacency matrix. The
metrics should return a numeric.
</p>


<h3>Value</h3>

<p>A data.frame with one column for each computed metric and one row per evaluated
matrix pair. Adjacency metrics are prefixed with &quot;adj_&quot;, orientation metrics are prefixed
with &quot;dir_&quot;, other metrics do not get a prefix. If the first argument is a matrix, <code>list.out = TRUE</code>
can be used to change the return object to a list instead. This list will contain three lists, where
adjacency, orientation and other metrics are reported, respectively.
</p>

<hr>
<h2 id='evaluate.array'>Evaluate adjacency matrix estimation</h2><span id='topic+evaluate.array'></span>

<h3>Description</h3>

<p>Applies several different metrics to evaluate difference between
estimated and true adjacency matrices. Intended to be used to evaluate
performance of causal discovery algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
evaluate(est, true, metrics, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate.array_+3A_est">est</code></td>
<td>
<p>Estimated adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.array_+3A_true">true</code></td>
<td>
<p>True adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.array_+3A_metrics">metrics</code></td>
<td>
<p>List of metrics, see details.</p>
</td></tr>
<tr><td><code id="evaluate.array_+3A_...">...</code></td>
<td>
<p>Further arguments that depend on input type.  Currently only <code>list.out</code> is allowed, and
only if the first argument is a matrix (see details under Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two options for input are available: Either <code>est</code> and <code>true</code>
can be two adjacency matrices, or they can be two arrays of adjacency matrices.
The arrays should have shape <code class="reqn">n * p * p</code> where n is the number of of matrices,
and p is the number of nodes/variables.
</p>
<p>The metrics should be given as a list with slots <code>$adj</code>, <code>$dir</code> and
<code>$other</code>. Metrics under <code>$adj</code> are applied to the adjacency confusion
matrix, while metrics under <code>$dir</code> are applied to the conditional orientation
confusion matrix (see <a href="#topic+confusion">confusion</a>). Metrics under <code>$other</code> are applied
without computing confusion matrices first.
</p>
<p>Available metrics to be used with confusion matrices are <a href="#topic+precision">precision</a>, <a href="#topic+recall">recall</a>,
<a href="#topic+specificity">specificity</a>, <a href="#topic+FOR">FOR</a>, <a href="#topic+FDR">FDR</a>, <a href="#topic+NPV">NPV</a>, <a href="#topic+F1">F1</a> and <a href="#topic+G1">G1</a>. The user
can supply custom metrics as well: They need to have the confusion matrix as their first
argument and should return a numeric.
</p>
<p>Available metrics to be used as &quot;other&quot; is: <a href="#topic+shd">shd</a>. The user
can supply custom metrics as well: They need to have arguments <code>est_amat</code> and <code>true_amat</code>,
where the former is the estimated adjacency matrix and the latter is the true adjacency matrix. The
metrics should return a numeric.
</p>


<h3>Value</h3>

<p>A data.frame with one column for each computed metric and one row per evaluated
matrix pair. Adjacency metrics are prefixed with &quot;adj_&quot;, orientation metrics are prefixed
with &quot;dir_&quot;, other metrics do not get a prefix. If the first argument is a matrix, <code>list.out = TRUE</code>
can be used to change the return object to a list instead. This list will contain three lists, where
adjacency, orientation and other metrics are reported, respectively.
</p>

<hr>
<h2 id='evaluate.matrix'>Evaluate adjacency matrix estimation</h2><span id='topic+evaluate.matrix'></span>

<h3>Description</h3>

<p>Applies several different metrics to evaluate difference between
estimated and true adjacency matrices. Intended to be used to evaluate
performance of causal discovery algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
evaluate(est, true, metrics, list.out = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate.matrix_+3A_est">est</code></td>
<td>
<p>Estimated adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.matrix_+3A_true">true</code></td>
<td>
<p>True adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.matrix_+3A_metrics">metrics</code></td>
<td>
<p>List of metrics, see details.</p>
</td></tr>
<tr><td><code id="evaluate.matrix_+3A_list.out">list.out</code></td>
<td>
<p>If <code>FALSE</code> (default), output is returned as a data.frame, otherwise
it will be a list.</p>
</td></tr>
<tr><td><code id="evaluate.matrix_+3A_...">...</code></td>
<td>
<p>Further arguments that depend on input type.  Currently only <code>list.out</code> is allowed, and
only if the first argument is a matrix (see details under Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two options for input are available: Either <code>est</code> and <code>true</code>
can be two adjacency matrices, or they can be two arrays of adjacency matrices.
The arrays should have shape <code class="reqn">n * p * p</code> where n is the number of of matrices,
and p is the number of nodes/variables.
</p>
<p>The metrics should be given as a list with slots <code>$adj</code>, <code>$dir</code> and
<code>$other</code>. Metrics under <code>$adj</code> are applied to the adjacency confusion
matrix, while metrics under <code>$dir</code> are applied to the conditional orientation
confusion matrix (see <a href="#topic+confusion">confusion</a>). Metrics under <code>$other</code> are applied
without computing confusion matrices first.
</p>
<p>Available metrics to be used with confusion matrices are <a href="#topic+precision">precision</a>, <a href="#topic+recall">recall</a>,
<a href="#topic+specificity">specificity</a>, <a href="#topic+FOR">FOR</a>, <a href="#topic+FDR">FDR</a>, <a href="#topic+NPV">NPV</a>, <a href="#topic+F1">F1</a> and <a href="#topic+G1">G1</a>. The user
can supply custom metrics as well: They need to have the confusion matrix as their first
argument and should return a numeric.
</p>
<p>Available metrics to be used as &quot;other&quot; is: <a href="#topic+shd">shd</a>. The user
can supply custom metrics as well: They need to have arguments <code>est_amat</code> and <code>true_amat</code>,
where the former is the estimated adjacency matrix and the latter is the true adjacency matrix. The
metrics should return a numeric.
</p>


<h3>Value</h3>

<p>A data.frame with one column for each computed metric and one row per evaluated
matrix pair. Adjacency metrics are prefixed with &quot;adj_&quot;, orientation metrics are prefixed
with &quot;dir_&quot;, other metrics do not get a prefix. If the first argument is a matrix, <code>list.out = TRUE</code>
can be used to change the return object to a list instead. This list will contain three lists, where
adjacency, orientation and other metrics are reported, respectively.
</p>

<hr>
<h2 id='evaluate.tamat'>Evaluate adjacency matrix estimation</h2><span id='topic+evaluate.tamat'></span>

<h3>Description</h3>

<p>Applies several different metrics to evaluate difference between
estimated and true adjacency matrices. Intended to be used to evaluate
performance of causal discovery algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tamat'
evaluate(est, true, metrics, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate.tamat_+3A_est">est</code></td>
<td>
<p>Estimated adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.tamat_+3A_true">true</code></td>
<td>
<p>True adjacency matrix/matrices.</p>
</td></tr>
<tr><td><code id="evaluate.tamat_+3A_metrics">metrics</code></td>
<td>
<p>List of metrics, see details.</p>
</td></tr>
<tr><td><code id="evaluate.tamat_+3A_...">...</code></td>
<td>
<p>Further arguments that depend on input type.  Currently only <code>list.out</code> is allowed, and
only if the first argument is a matrix (see details under Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two options for input are available: Either <code>est</code> and <code>true</code>
can be two adjacency matrices, or they can be two arrays of adjacency matrices.
The arrays should have shape <code class="reqn">n * p * p</code> where n is the number of of matrices,
and p is the number of nodes/variables.
</p>
<p>The metrics should be given as a list with slots <code>$adj</code>, <code>$dir</code> and
<code>$other</code>. Metrics under <code>$adj</code> are applied to the adjacency confusion
matrix, while metrics under <code>$dir</code> are applied to the conditional orientation
confusion matrix (see <a href="#topic+confusion">confusion</a>). Metrics under <code>$other</code> are applied
without computing confusion matrices first.
</p>
<p>Available metrics to be used with confusion matrices are <a href="#topic+precision">precision</a>, <a href="#topic+recall">recall</a>,
<a href="#topic+specificity">specificity</a>, <a href="#topic+FOR">FOR</a>, <a href="#topic+FDR">FDR</a>, <a href="#topic+NPV">NPV</a>, <a href="#topic+F1">F1</a> and <a href="#topic+G1">G1</a>. The user
can supply custom metrics as well: They need to have the confusion matrix as their first
argument and should return a numeric.
</p>
<p>Available metrics to be used as &quot;other&quot; is: <a href="#topic+shd">shd</a>. The user
can supply custom metrics as well: They need to have arguments <code>est_amat</code> and <code>true_amat</code>,
where the former is the estimated adjacency matrix and the latter is the true adjacency matrix. The
metrics should return a numeric.
</p>


<h3>Value</h3>

<p>A data.frame with one column for each computed metric and one row per evaluated
matrix pair. Adjacency metrics are prefixed with &quot;adj_&quot;, orientation metrics are prefixed
with &quot;dir_&quot;, other metrics do not get a prefix. If the first argument is a matrix, <code>list.out = TRUE</code>
can be used to change the return object to a list instead. This list will contain three lists, where
adjacency, orientation and other metrics are reported, respectively.
</p>

<hr>
<h2 id='F1'>F1 score</h2><span id='topic+F1'></span>

<h3>Description</h3>

<p>Computes F1 score from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
The F1 score is defined as  <code class="reqn">2 * TP/(2 * TP + FP + FN)</code>, where TP are true positives,
FP are false positives, and FN are false negatives. If TP + FP + FN = 0, 1 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F1(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F1_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='FDR'>False Discovery Rate</h2><span id='topic+FDR'></span>

<h3>Description</h3>

<p>Computes false discovery rate from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
False discovery rate is defined as FP/(FP + TP), where FP are false positives and
TP are true positives. If FP + TP = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDR(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FDR_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='FOR'>False Omission Rate</h2><span id='topic+FOR'></span>

<h3>Description</h3>

<p>Computes false omission rate from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
False omission rate is defined as FN/(FN + TN), where FN are false negatives and
TN are true negatives. If FN + TN = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOR(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FOR_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='G1'>G1 score</h2><span id='topic+G1'></span>

<h3>Description</h3>

<p>Computes G1 score from a confusion matrix, see <a href="#topic+confusion">confusion</a>. G1 score is F1 score with
reversed roles of 0/1 classifications, see Petersen et al. 2022.
The G1 score is defined as  <code class="reqn">2 * TN/(2 * TN + FN + FP)</code>, where TN are true negatives,
FP are false positives, and FN are false negatives. If TN + FN + FP = 0, 1 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G1(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G1_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>


<h3>References</h3>

<p>Petersen, Anne Helby, et al. &quot;Causal discovery for observational sciences using
supervised machine learning.&quot; arXiv preprint arXiv:2202.12813 (2022).
</p>

<hr>
<h2 id='gausCorScore'>Gaussian L0 score computed on correlation matrix</h2><span id='topic+gausCorScore'></span>

<h3>Description</h3>

<p>The score is intended to be used with score-based causal discovery algorithms
from the pcalg package. It is identical to the <code><a href="pcalg.html#topic+GaussL0penObsScore-class">GaussL0penObsScore-class</a></code>,
except that it takes in a correlation matrix instead of the full data set.
<code><a href="pcalg.html#topic+GaussL0penObsScore-class">GaussL0penObsScore-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gausCorScore(cormat, n, p = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gausCorScore_+3A_cormat">cormat</code></td>
<td>
<p>A correlation matrix. Needs to be symmetric.</p>
</td></tr>
<tr><td><code id="gausCorScore_+3A_n">n</code></td>
<td>
<p>The number of observations in the dataset that the correlation matrix was computed from.</p>
</td></tr>
<tr><td><code id="gausCorScore_+3A_p">p</code></td>
<td>
<p>The number of variables. This is inferred from the cormat if not supplied.</p>
</td></tr>
<tr><td><code id="gausCorScore_+3A_lambda">lambda</code></td>
<td>
<p>Penalty to use for the score. If <code>NULL</code> (default), the BIC score penalty is used. See
<code><a href="pcalg.html#topic+GaussL0penObsScore-class">GaussL0penObsScore-class</a></code> for further details.</p>
</td></tr>
<tr><td><code id="gausCorScore_+3A_...">...</code></td>
<td>
<p>Other arguments passed along to <code><a href="pcalg.html#topic+GaussL0penObsScore-class">GaussL0penObsScore-class</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Score</code> object (S4), see <code><a href="pcalg.html#topic+Score-class">Score-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and compute correlation matrix
x1 &lt;- rnorm(100)
x2 &lt;- rnorm(100)
x3 &lt;- x1 + x2 + rnorm(100)
d &lt;- data.frame(x1, x2, x3)
cmat &lt;- cor(d)

# Use gausCorScore with pcalg::ges() 
pcalg::ges(gausCorScore(cmat, n = 100))


</code></pre>

<hr>
<h2 id='graph2amat'>Convert graphNEL object to adjacency matrix</h2><span id='topic+graph2amat'></span>

<h3>Description</h3>

<p>Convert graphNEL object to adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2amat(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2amat_+3A_graph">graph</code></td>
<td>
<p>A graphNEL object.</p>
</td></tr>
</table>

<hr>
<h2 id='is_cpdag'>Check for CPDAG</h2><span id='topic+is_cpdag'></span>

<h3>Description</h3>

<p>Check for CPDAG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cpdag(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_cpdag_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check: Is adjacency matrix proper CPDAG? See <code><a href="pcalg.html#topic+isValidGraph">isValidGraph</a></code> for
definition.
</p>


<h3>Value</h3>

<p>A logical.
</p>

<hr>
<h2 id='is_pdag'>Check for PDAG</h2><span id='topic+is_pdag'></span>

<h3>Description</h3>

<p>Check for PDAG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pdag(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_pdag_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check: Is adjacency matrix proper PDAG? See <code><a href="pcalg.html#topic+isValidGraph">isValidGraph</a></code> for
definition.
</p>


<h3>Value</h3>

<p>A logical.
</p>

<hr>
<h2 id='maketikz'>Generate Latex tikz code for plotting a temporal DAG or PDAG.</h2><span id='topic+maketikz'></span>

<h3>Description</h3>

<p>Generate Latex tikz code for plotting a temporal DAG or PDAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maketikz(
  model,
  xjit = 2,
  yjit = 2,
  markperiods = TRUE,
  xpgap = 4,
  annotateEdges = NULL,
  addAxis = TRUE,
  varLabels = NULL,
  periodLabels = NULL,
  annotationLabels = NULL,
  clipboard = TRUE,
  colorAnnotate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maketikz_+3A_model">model</code></td>
<td>
<p><code>tpdag</code> or <code>tamat</code> object to plot.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_xjit">xjit</code></td>
<td>
<p>How much should nodes within a period be jittered horizontally.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_yjit">yjit</code></td>
<td>
<p>Vertical distance between nodes within a period.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_markperiods">markperiods</code></td>
<td>
<p>If <code>TRUE</code>, gray boxes are drawn behind each period.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_xpgap">xpgap</code></td>
<td>
<p>Horizontal gap between different periods.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_annotateedges">annotateEdges</code></td>
<td>
<p>If <code>TRUE</code>, add a text annotation to edges. If <code>annotationlabels</code>
are supplied, these labels will be used. Otherwise, the value in the inputted adjacency matrix corresponding
to the edge will be used.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_addaxis">addAxis</code></td>
<td>
<p>If <code>TRUE</code>, a horizontal axis with period labels are added.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_varlabels">varLabels</code></td>
<td>
<p>Optional labels for nodes (variables). Should be given as a named list, where
the name is the variable name, and the entry is the label, e.g. <code>list(vname = "Label for vname")</code>.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_periodlabels">periodLabels</code></td>
<td>
<p>Optional labels for periods. Should be given as a named list, where
the name is the period name (as stored in the <code>tamat</code>), and the entry is the label,
e.g. <code>list(periodname = "Label for period")</code>.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_annotationlabels">annotationLabels</code></td>
<td>
<p>Optional labels for edge annotations. Only used if <code>annotateEdges = TRUE</code>.
Should be given as a named list, where the name is the edge annotation (as stored in the <code>tamat</code>),
and the entry is the label, e.g. <code>list(h = "High")</code>.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_clipboard">clipboard</code></td>
<td>
<p>If <code>TRUE</code>, the tikz code is not printed, but instead copied to the clipboard,
so it can easily be pasted into a Latex document.</p>
</td></tr>
<tr><td><code id="maketikz_+3A_colorannotate">colorAnnotate</code></td>
<td>
<p>Named list of colors to use to mark edge annotations instead of labels. This
overrules <code>annotateEdges</code> and both are not available at the same time. The list should be given with
annotations as names and colors as entries, e.g. <code>list(h = "blue")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it is necessary to read in relevant tikz libraries in the
Latex preamble. The relevant lines of code are (depending a bit on parameter settings): <br />
<code>\usepackage{tikz}</code> <br />
<code>\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}</code> <br />
<code>\usepackage{pgfplots}</code>
</p>


<h3>Value</h3>

<p>Silently returns a character vector with lines of tikz code. The function
furthermore has a side-effect. If <code>clipboard = TRUE</code>, the side-effect is that the tikz
code is also copied to the clipboard. If <code>clipboard = FALSE</code>, the tikz code is instead printed
in the console.
</p>

<hr>
<h2 id='maxnedges'>Compute maximal number of edges for graph</h2><span id='topic+maxnedges'></span>

<h3>Description</h3>

<p>Computes the number of edges a graph with <code>p</code> nodes will have if its
fully connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxnedges(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxnedges_+3A_p">p</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='nDAGs'>Number of different DAGs</h2><span id='topic+nDAGs'></span>

<h3>Description</h3>

<p>Computes the number of different possible DAGs that can be constructed over
a given number of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nDAGs(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nDAGs_+3A_p">p</code></td>
<td>
<p>The number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='nedges'>Number of edges in adjacency matrix</h2><span id='topic+nedges'></span>

<h3>Description</h3>

<p>Counts the number of edges in an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nedges(amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nedges_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric (non-negative integer).
</p>

<hr>
<h2 id='NPV'>Negative predictive value</h2><span id='topic+NPV'></span>

<h3>Description</h3>

<p>Computes negative predictive value recall from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
Negative predictive value is defined as TN/(TN + FN), where TN are true negatives and
FN are false negatives. If TP + FN = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPV(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NPV_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='plot.tamat'>Plot adjacency matrix with order information</h2><span id='topic+plot.tamat'></span>

<h3>Description</h3>

<p>Plot adjacency matrix with order information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tamat'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tamat_+3A_x">x</code></td>
<td>
<p>tamat (temporal adjacency matrix) object to be plotted
(as outputted from <code><a href="#topic+tamat">tamat</a></code>).</p>
</td></tr>
<tr><td><code id="plot.tamat_+3A_...">...</code></td>
<td>
<p>Further plotting arguments passed along to <code><a href="#topic+plotTempoMech">plotTempoMech</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the function is called for its side-effects (plotting).
</p>

<hr>
<h2 id='plot.tpdag'>Plot temporal partially directed acyclic graph (TPDAG)</h2><span id='topic+plot.tpdag'></span>

<h3>Description</h3>

<p>Plot temporal partially directed acyclic graph (TPDAG)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpdag'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tpdag_+3A_x">x</code></td>
<td>
<p>tpdag (temporal partially directed acyclic graph) object
to be plotted (as outputted from <code><a href="#topic+tpc">tpc</a></code>).</p>
</td></tr>
<tr><td><code id="plot.tpdag_+3A_...">...</code></td>
<td>
<p>Further plotting arguments passed along to <code><a href="#topic+plotTempoMech">plotTempoMech</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the function is called for its side-effects (plotting).
</p>

<hr>
<h2 id='plot.tskeleton'>Plot temporal skeleton</h2><span id='topic+plot.tskeleton'></span>

<h3>Description</h3>

<p>Plot temporal skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tskeleton'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tskeleton_+3A_x">x</code></td>
<td>
<p>tskeleton (temporal skeleton) object to be plotted
(as outputted from <code><a href="#topic+tpc">tpc</a></code>).</p>
</td></tr>
<tr><td><code id="plot.tskeleton_+3A_...">...</code></td>
<td>
<p>Further plotting arguments passed along to <code><a href="#topic+plotTempoMech">plotTempoMech</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the function is called for its side-effects (plotting).
</p>

<hr>
<h2 id='plotTempoMech'>Plot temporal data generating mechanism</h2><span id='topic+plotTempoMech'></span>

<h3>Description</h3>

<p>Plots tpdag, tskeleton and tamat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTempoMech(
  x,
  addTimeAxis = TRUE,
  addPsi = TRUE,
  varLabels = NULL,
  periodLabels = NULL,
  colors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTempoMech_+3A_x">x</code></td>
<td>
<p>The tpdag/tskeleton or tamat to plot.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_addtimeaxis">addTimeAxis</code></td>
<td>
<p>Logical indicating whether a time axis should be
added to the plot.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_addpsi">addPsi</code></td>
<td>
<p>Logical indicating whether the sparsity level should be
added to the plot.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_varlabels">varLabels</code></td>
<td>
<p>A named list of variable labels.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_periodlabels">periodLabels</code></td>
<td>
<p>A character vector with labels for periods.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_colors">colors</code></td>
<td>
<p>A character vector with colors to use for marking periods.
Should have at least as many elements as the numbers of periods.</p>
</td></tr>
<tr><td><code id="plotTempoMech_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the function is called for its side-effects (plotting).
</p>

<hr>
<h2 id='precision'>Precision</h2><span id='topic+precision'></span>

<h3>Description</h3>

<p>Computes precision (aka positive predictive value) from a confusion matrix,
see <a href="#topic+confusion">confusion</a>.
Precision is defined as TP/(TP + FP), where TP are true positives and
FP are false positives. If TP + FP = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='probmat2amat'>Convert a matrix of probabilities into an adjacency matrix</h2><span id='topic+probmat2amat'></span>

<h3>Description</h3>

<p>Convert a matrix of probabilities into an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probmat2amat(
  probmat,
  threshold,
  method = "cutoff",
  keep_vnames = TRUE,
  graph_criterion = "pdag",
  deletesym = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probmat2amat_+3A_probmat">probmat</code></td>
<td>
<p>Square matrix of probabilities.</p>
</td></tr>
<tr><td><code id="probmat2amat_+3A_threshold">threshold</code></td>
<td>
<p>Value between 0 and 1. Any probabilities lower than
this value will be set to 0 (no arrowhead).</p>
</td></tr>
<tr><td><code id="probmat2amat_+3A_method">method</code></td>
<td>
<p>Either <code>"cutoff"</code> or <code>"bpco"</code>, see details.</p>
</td></tr>
<tr><td><code id="probmat2amat_+3A_keep_vnames">keep_vnames</code></td>
<td>
<p>If <code>TRUE</code>, variable names (provided as rownames in the input probmat)
will be preserved in the output.</p>
</td></tr>
<tr><td><code id="probmat2amat_+3A_graph_criterion">graph_criterion</code></td>
<td>
<p>Which criterion to check if the output graph fulfills for the bpco
method. Should be one of <code>"dag"</code>, <code>"pdag"</code> or <code>"cpdag"</code>  or
<code>NULL</code>. Choosing <code>NULL</code> (the default) puts no further restrictions on the output.
See <code><a href="pcalg.html#topic+isValidGraph">isValidGraph</a></code> for definitions.</p>
</td></tr>
<tr><td><code id="probmat2amat_+3A_deletesym">deletesym</code></td>
<td>
<p>If <code>TRUE</code>, edges are deleted symmetrically in the bcpo method. This means that instead
of removing arrowheads (setting singular elements to 0), the procedure removes full edges (setting both potential
arrowheads for the given edge to zero). This only makes a difference if the graph may include undirected edges,
which should be encoded as bidirected edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two methods for converting the probability matrix into an adjacency
matrix are implemented. First, the cutoff-method (<code>method = "cutoff"</code>) simply
uses a threshold value and sets all values below that to zero in the outputted
adjacency matrix. No checks are performed to ensure that the resulting
matrix is a proper dag/pdag/cpdag adjacency matrix. Second, the backwards
PC orientation method (<code>method = "bpco"</code>) first uses a cutoff, and then
sets further elements to zero until the resulting matrix can be converted into
a proper adjacency matrix (using the graph criterion specified in the
<code>graph_criterion</code> argument) by applying the PC algorithm orientation rules.
See Petersen et al. 2022 for further details.
</p>


<h3>Value</h3>

<p>A square matrix of probabilities (all entries in [0,1]).
</p>


<h3>References</h3>

<p>Petersen, Anne Helby, et al. &quot;Causal discovery for observational sciences using supervised machine learning.&quot;
arXiv preprint arXiv:2202.12813 (2022).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make random probability matrix that can be 
#converted into adjancency matrix
pmat &lt;- matrix(runif(25, 0, 1), 5, 5)
diag(pmat) &lt;- 0

#Convert to adjacency matrix using cutoff-method (threshold = 0.5)
probmat2amat(pmat, threshold = 0.5)

#Convert to adjacency matrix using BPCO-method (threshold = 0.5)
probmat2amat(pmat, threshold = 0.5, method = "bpco")

</code></pre>

<hr>
<h2 id='recall'>Recall</h2><span id='topic+recall'></span>

<h3>Description</h3>

<p>Computes recall from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
Recall is defined as TP/(TP + FN), where TP are true positives and
FN are false negatives. If TP + FN = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recall(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recall_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='regTest'>Regression-based information loss test</h2><span id='topic+regTest'></span>

<h3>Description</h3>

<p>We test whether <code>x</code> and <code>y</code> are associated, given
<code>S</code> using a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regTest(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regTest_+3A_x">x</code></td>
<td>
<p>Index of x variable</p>
</td></tr>
<tr><td><code id="regTest_+3A_y">y</code></td>
<td>
<p>Index of y variable</p>
</td></tr>
<tr><td><code id="regTest_+3A_s">S</code></td>
<td>
<p>Index of S variable(s), possibly NULL</p>
</td></tr>
<tr><td><code id="regTest_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic; list with data,
binary variables and order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All included variables should be either numeric or binary. If
<code>y</code> is binary, a logistic regression model is fitted. If <code>y</code> is numeric,
a linear regression model is fitted. <code>x</code> and <code>S</code> are included as
explanatory variables. Any numeric variables among <code>x</code> and <code>S</code> are
modeled with spline expansions (natural splines, 3 df). This model is tested
against a numeric where <code>x</code> (including a possible spline expansion) has
been left out using a likelihood ratio test.
The model is fitted in both directions (interchanging the roles
of <code>x</code> and <code>y</code>). The final p-value is the maximum of the two
obtained p-values.
</p>


<h3>Value</h3>

<p>A numeric, which is the p-value of the test.
</p>

<hr>
<h2 id='shd'>Structural hamming distance between adjacency matrices</h2><span id='topic+shd'></span>

<h3>Description</h3>

<p>Computes the structural hamming distance between two adjacency matrices. This implementation
is a modification of the <code><a href="pcalg.html#topic+shd">shd</a></code> function from the pcalg package, but here we
avoid working on the heavy <code>graphNEL</code> objects for representing graphs that are used in the
pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shd(est_amat, true_amat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shd_+3A_est_amat">est_amat</code></td>
<td>
<p>Estimated adjacency matrix</p>
</td></tr>
<tr><td><code id="shd_+3A_true_amat">true_amat</code></td>
<td>
<p>True adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the function is symmetric in the two inputted adjacency matrices.
</p>


<h3>Value</h3>

<p>A numeric (a non-negative integer).
</p>

<hr>
<h2 id='simDAG'>Simulate a random DAG</h2><span id='topic+simDAG'></span>

<h3>Description</h3>

<p>Simulates a random directed acyclic graph adjacency (DAG) matrix with
the provided edge sparsity. The edge sparsity is the percentage of edges
that are absent, relative to a fully connected DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDAG(p, sparsity = NULL, sparsityLim = c(0, 0.8), permute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simDAG_+3A_p">p</code></td>
<td>
<p>The number of nodes.</p>
</td></tr>
<tr><td><code id="simDAG_+3A_sparsity">sparsity</code></td>
<td>
<p>If <code>NULL</code> (the default), a random edge sparsity
is sampled from the interval provided in <code>sparsityLim</code>. Otherwise,
the sparsity should be provided as a numeric in [0,1].</p>
</td></tr>
<tr><td><code id="simDAG_+3A_sparsitylim">sparsityLim</code></td>
<td>
<p>A vector of two numerics, both must be in [0,1].</p>
</td></tr>
<tr><td><code id="simDAG_+3A_permute">permute</code></td>
<td>
<p>If <code>FALSE</code>, the adjacency matrix will include nodes
in their causal ordering. This is avoided by setting <code>permute = TRUE</code>,
in which case the node order is permuted randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a DAG adjacency matrix with 5 nodes
simDAG(5) 

</code></pre>

<hr>
<h2 id='simGausFromDAG'>Simulate Gaussian data according to DAG</h2><span id='topic+simGausFromDAG'></span>

<h3>Description</h3>

<p>Simulates a jointly Gaussian dataset given a DAG
adjacency matrix. The data is simulated using linear structural
equations and the parameters (residual standard deviations and
regression coefficients) are sampled from chosen intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGausFromDAG(
  amat,
  n,
  regparLim = c(0.5, 2),
  resSDLim = c(0.1, 1),
  pnegRegpar = 0.4,
  standardize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simGausFromDAG_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
<tr><td><code id="simGausFromDAG_+3A_n">n</code></td>
<td>
<p>The number of observations that should be simulated.</p>
</td></tr>
<tr><td><code id="simGausFromDAG_+3A_regparlim">regparLim</code></td>
<td>
<p>The interval from which regression parameters are
sampled.</p>
</td></tr>
<tr><td><code id="simGausFromDAG_+3A_ressdlim">resSDLim</code></td>
<td>
<p>The interval from which residual standard deviations
are sampled.</p>
</td></tr>
<tr><td><code id="simGausFromDAG_+3A_pnegregpar">pnegRegpar</code></td>
<td>
<p>The probability of sampling a negative regression
parameter.</p>
</td></tr>
<tr><td><code id="simGausFromDAG_+3A_standardize">standardize</code></td>
<td>
<p>If <code>FALSE</code> (the default), the raw data are
returned. If <code>TRUE</code>, the data are first standardized, i.e.,
each variable will have its mean subtracted and be divided by its
standard deviation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variable <code class="reqn">X_{i}</code> is simulated as <br />
<code class="reqn">X_{i} := \sum_{Z \in pa(X_{i})} \beta_{Z} * Z + e_{i}</code> <br />
where <code class="reqn">pa(X_{i})</code> are the parents of <code class="reqn">X_{i}</code> in the DAG.
The residual, <code class="reqn">e_{i}</code>, is drawn from a normal distribution.
</p>


<h3>Value</h3>

<p>A data.frame of identically distributed simulated observations.
</p>

<hr>
<h2 id='specificity'>Specificity</h2><span id='topic+specificity'></span>

<h3>Description</h3>

<p>Computes specificity from a confusion matrix, see <a href="#topic+confusion">confusion</a>.
Specificity is defined as TN/(TN + FP), where TN are true negatives and
FP are false positives. If TN + FP = 0, 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity(confusion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specificity_+3A_confusion">confusion</code></td>
<td>
<p>Confusion matrix as obtained from <a href="#topic+confusion">confusion</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric in [0,1].
</p>

<hr>
<h2 id='tamat'>Make a temporal adjacency matrix</h2><span id='topic+tamat'></span>

<h3>Description</h3>

<p>Make a temporal adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tamat(amat, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tamat_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix. A square matrix of 0 or 1s. A
1 in the (i,j)th entry means that there is an edge from j to i.
Row names and column names should be identical and be the names of
the variables/nodes. Variable names should be prefixed with their
period, e.g. &quot;child_x&quot; for variable &quot;x&quot; at period &quot;child&quot;</p>
</td></tr>
<tr><td><code id="tamat_+3A_order">order</code></td>
<td>
<p>A character vector with the periods in their order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tamat</code> object, which is a matrix with a &quot;order&quot;
attribute(a character vector listing the temporal order of the variables
in the adjacency matrix).
</p>

<hr>
<h2 id='tpc'>Perform causal discovery using the temporal PC algorithm (TPC)</h2><span id='topic+tpc'></span>

<h3>Description</h3>

<p>Perform causal discovery using the temporal PC algorithm (TPC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpc(
  data,
  order,
  sparsity = 10^(-1),
  test = regTest,
  suffStat = NULL,
  output = "tpdag",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpc_+3A_data">data</code></td>
<td>
<p>A data.frame with data. All variables should be
assigned to exactly one period by prefixing them with the period name
(see example below).</p>
</td></tr>
<tr><td><code id="tpc_+3A_order">order</code></td>
<td>
<p>A character vector with period-prefixes in their
temporal order (see example below).</p>
</td></tr>
<tr><td><code id="tpc_+3A_sparsity">sparsity</code></td>
<td>
<p>The sparsity level to be used for independence
testing (i.e. significance level threshold to use for each test).</p>
</td></tr>
<tr><td><code id="tpc_+3A_test">test</code></td>
<td>
<p>A procedure for testing conditional independence.
The default, <code>regTest</code> uses a regression-based information
loss test. Another available option is <code>corTest</code> which
tests for vanishing partial correlations. User supplied functions
may also be used, see details below about the required syntax.</p>
</td></tr>
<tr><td><code id="tpc_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic. If this argument is supplied, the
sufficient statistic is not computed from the inputted data. The format and
contents of the sufficient statistic depends on which test is being used.</p>
</td></tr>
<tr><td><code id="tpc_+3A_output">output</code></td>
<td>
<p>One of <code>"tpdag"</code> or <code>"tskeleton"</code>. If
<code>"skeleton"</code>, a temporal skeleton is constructed and outputted,
but the edges are not directed. If <code>"tpdag"</code> (the default), a
the edges are directed, resulting in a temporal partially directed
acyclic graph.</p>
</td></tr>
<tr><td><code id="tpc_+3A_...">...</code></td>
<td>
<p>Further optional arguments which are currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all independence test procedures implemented
in the <code>pcalg</code> package may be used, see <code><a href="pcalg.html#topic+pc">pc</a></code>.
</p>


<h3>Value</h3>

<p>A <code>tpdag</code> or <code>tskeleton</code> object. Both return types are
S3 objects, i.e., lists with entries: <code>$amat</code> (the estimated adjacency
matrix), <code>$order</code> (character vector with the order, as inputted to
this function), <code>$psi</code> (the significance level used for testing), and
<code>$ntests</code> (the number of tests conducted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TPC on included example data, use sparsity psi = 0.01, default test (regression-based
#information loss):
data(tpcExample)
tpc(tpcExample, order = c("child", "youth", "oldage"), sparsity = 0.01)


#TPC on included example data, use sparsity psi = 0.01, use test for vanishing partial
# correlations:
data(tpcExample)
tpc(tpcExample, order = c("child", "youth", "oldage"), sparsity = 0.01,
test = corTest)


#TPC on another simulated data set

#Simulate data
set.seed(123)
n &lt;- 500
child_x &lt;- rnorm(n)^2
child_y &lt;- 0.5*child_x + rnorm(n)
child_z &lt;- sample(c(0,1), n, replace = TRUE,
                  prob = c(0.3, 0.7))
         
adult_x &lt;- child_x + rnorm(n)
adult_z &lt;- as.numeric(child_z + rnorm(n) &gt; 0)
adult_w &lt;- 2*adult_z + rnorm(n)
adult_y &lt;- 2*sqrt(child_x) + adult_w^2 + rnorm(n)

simdata &lt;- data.frame(child_x, child_y, child_z,
                      adult_x, adult_z, adult_w,
                      adult_y)

#Define order
simorder &lt;- c("child", "adult")

#Perform TPC with sparsity psi = 0.001
results &lt;- tpc(simdata, order = simorder, sparsity = 10^(-3))

</code></pre>

<hr>
<h2 id='tpcExample'>Simulated data example</h2><span id='topic+tpcExample'></span>

<h3>Description</h3>

<p>A small simulated data example intended to showcase the TPC algorithm. Note that the variable name
prefixes defines with period they are related to (&quot;child&quot;, &quot;youth&quot; or &quot;oldage&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpcExample
</code></pre>


<h3>Format</h3>

<p>A data.frame with 200 rows and 6 variables.
</p>

<dl>
<dt>child_x1</dt><dd><p>Structural equation: <code class="reqn">X1 := \epsilon1</code> with <code class="reqn">\epsilon1  ~ Unif{0,1}</code></p>
</dd>
<dt>child_x2</dt><dd><p>Structural equation: <code class="reqn">X2 := 2 * X1 + \epsilon2</code> with <code class="reqn">\epsilon2  ~  N(0,1)</code></p>
</dd>
<dt>youth_x3</dt><dd><p>Structural equation: <code class="reqn">X3 := \epsilon3</code> with <code class="reqn">\epsilon3  ~  Unif{0, 1}</code></p>
</dd>
<dt>youth_x4</dt><dd><p>Structural equation: <code class="reqn">X4 := X2 + \epsilon4</code> with <code class="reqn">\epsilon4  ~  N(0,1)</code></p>
</dd>
<dt>oldage_x5</dt><dd><p>Structural equation: <code class="reqn">X5 := X3^2 + X3 - 3 * X2 + \epsilon5</code> with <code class="reqn">\epsilon5  ~  N(0,1)</code></p>
</dd>
<dt>oldage_x6</dt><dd><p>Structural equation: <code class="reqn">X6 := X4^3 + X4^2 + 2 * X5 + \epsilon6</code> with <code class="reqn">\epsilon6  ~  N(0,1)</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Petersen, AH; Osler, M \&amp; Ekstr√∏m, CT (2021): Data-Driven Model Building for Life-Course Epidemiology,
American Journal of Epidemiology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(tpcExample)
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
