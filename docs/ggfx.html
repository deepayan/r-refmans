<!DOCTYPE html><html><head><title>Help for package ggfx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggfx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggfx-package'><p>ggfx: Pixel Filters for 'ggplot2' and 'grid'</p></a></li>
<li><a href='#as_colourspace'><p>Collect channels into a single layer of a specific colourspace</p></a></li>
<li><a href='#as_group'><p>Collect layers into a group that can be treated as a single layer</p></a></li>
<li><a href='#as_reference'><p>Create a reference to a layer for use in other filters</p></a></li>
<li><a href='#blend_raster'><p>Raster Helpers</p></a></li>
<li><a href='#Channels'><p>Set a channel of interest from a layer</p></a></li>
<li><a href='#object_support'><p>Supported object types</p></a></li>
<li><a href='#raster_placement'><p>Control placements of raster in the plot</p></a></li>
<li><a href='#render_context'><p>Rendering information</p></a></li>
<li><a href='#with_blend'><p>Blend a layer with a reference</p></a></li>
<li><a href='#with_blend_custom'><p>Create a custom blend type</p></a></li>
<li><a href='#with_bloom'><p>Apply bloom to your layer</p></a></li>
<li><a href='#with_blur'><p>Apply a gaussian blur to your layer</p></a></li>
<li><a href='#with_circle_dither'><p>Dither image using a threshold dithering map</p></a></li>
<li><a href='#with_custom'><p>Apply a custom filter</p></a></li>
<li><a href='#with_displacement'><p>Apply a displacement map to a layer</p></a></li>
<li><a href='#with_dither'><p>Dither image using Floyd-Steinberg error correction dithering</p></a></li>
<li><a href='#with_inner_glow'><p>Apply an inner glow to your layer</p></a></li>
<li><a href='#with_interpolate'><p>Blend two layerrs together by averaging them out</p></a></li>
<li><a href='#with_kernel'><p>Apply a gaussian blur to your layer</p></a></li>
<li><a href='#with_mask'><p>Apply a mask to a layer</p></a></li>
<li><a href='#with_motion_blur'><p>Apply a motion blur to your layer</p></a></li>
<li><a href='#with_outer_glow'><p>Apply an outer glow to your layer</p></a></li>
<li><a href='#with_raster'><p>Convert a layer to a raster</p></a></li>
<li><a href='#with_shade'><p>Apply a gaussian blur to your layer</p></a></li>
<li><a href='#with_shadow'><p>Apply a drop shadow to a layer</p></a></li>
<li><a href='#with_variable_blur'><p>Apply a variable blur to a layer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pixel Filters for 'ggplot2' and 'grid'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a range of filters that can be applied to layers from the 
    'ggplot2' package and its extensions, along with other graphic elements such 
    as guides and theme elements. The filters are applied at render time and 
    thus uses the exact pixel dimensions needed.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>magick (&ge; 2.7.1), ragg, grid, ggplot2, grDevices, gtable,
rlang</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggfx.data-imaginist.com">https://ggfx.data-imaginist.com</a>, <a href="https://github.com/thomasp85/ggfx">https://github.com/thomasp85/ggfx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/ggfx/issues">https://github.com/thomasp85/ggfx/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, farver (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 07:41:01 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  RStudio [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 08:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggfx-package'>ggfx: Pixel Filters for 'ggplot2' and 'grid'</h2><span id='topic+ggfx'></span><span id='topic+ggfx-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides a range of filters that can be applied to layers from the 'ggplot2' package and its extensions, along with other graphic elements such as guides and theme elements. The filters are applied at render time and thus uses the exact pixel dimensions needed.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ggfx.data-imaginist.com">https://ggfx.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/ggfx">https://github.com/thomasp85/ggfx</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/ggfx/issues">https://github.com/thomasp85/ggfx/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_colourspace'>Collect channels into a single layer of a specific colourspace</h2><span id='topic+as_colourspace'></span>

<h3>Description</h3>

<p>If you need to work on single channels one by one you can use the different
<a href="#topic+ch_red">ch_*()</a> selectors. If the result needs to be combined again into a
colour layer you can use <code>as_colourspace</code> and pass in the required channels
to make up the colourspace. By default the alpha channel will be created as
the combination of the alpha channels from the provided channel layers.
Alternatively you can set <code>auto_opacity = FALSE</code> and provide one additional
channel which will then be used as alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_colourspace(
  ...,
  colourspace = "sRGB",
  auto_opacity = TRUE,
  id = NULL,
  include = is.null(id)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_colourspace_+3A_...">...</code></td>
<td>
<p>A range of layers to combine. If there are no channel spec set the
luminosity will be used</p>
</td></tr>
<tr><td><code id="as_colourspace_+3A_colourspace">colourspace</code></td>
<td>
<p>Which colourspace should the provided colour channels be
interpreted as coming from.</p>
</td></tr>
<tr><td><code id="as_colourspace_+3A_auto_opacity">auto_opacity</code></td>
<td>
<p>Should the opacity be derived from the input layers or
taken from a provided alpha channel</p>
</td></tr>
<tr><td><code id="as_colourspace_+3A_id">id</code></td>
<td>
<p>A string identifying this layer for later use</p>
</td></tr>
<tr><td><code id="as_colourspace_+3A_include">include</code></td>
<td>
<p>Should the layer itself be included in the graphic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>Layer</code> objects
</p>


<h3>See Also</h3>

<p>Other layer references: 
<code><a href="#topic+as_group">as_group</a>()</code>,
<code><a href="#topic+as_reference">as_reference</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

segments &lt;- data.frame(
  x = runif(300),
  y = runif(300),
  xend = runif(300),
  yend = runif(300)
)

# We use 'white' as that is the maximum value in all channels
ggplot(mapping = aes(x, y, xend = xend, yend = yend)) +
  as_colourspace(
    geom_segment(data = segments[1:100,], colour = 'white'),
    geom_segment(data = segments[101:200,], colour = 'white'),
    geom_segment(data = segments[201:300,], colour = 'white'),
    colourspace = 'CMY'
  )

</code></pre>

<hr>
<h2 id='as_group'>Collect layers into a group that can be treated as a single layer</h2><span id='topic+as_group'></span>

<h3>Description</h3>

<p>While you often want to apply filters to layers one by one, there are times
when one filter should be applied to a collection of layers as if they were
one. This can be achieved by first combining all the layers into a group with
<code>as_group()</code> and applying the filter to the resulting group. This can only be
done to ggplot2 layers and grobs as the other supported objects are not part
of a graphic stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_group(..., id = NULL, include = is.null(id))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_group_+3A_...">...</code></td>
<td>
<p>A range of layers to combine</p>
</td></tr>
<tr><td><code id="as_group_+3A_id">id</code></td>
<td>
<p>A string identifying this layer for later use</p>
</td></tr>
<tr><td><code id="as_group_+3A_include">include</code></td>
<td>
<p>Should the layer itself be included in the graphic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>Layer</code> objects or a <a href="grid.html#topic+grid.grob">gTree</a> depending on the
input
</p>


<h3>See Also</h3>

<p>Other layer references: 
<code><a href="#topic+as_colourspace">as_colourspace</a>()</code>,
<code><a href="#topic+as_reference">as_reference</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# With no grouping the filters on layers are applied one by one
ggplot(mtcars, aes(mpg, disp)) +
  with_shadow(geom_smooth(alpha = 1), sigma = 4) +
  with_shadow(geom_point(), sigma = 4)

# Grouping the layers allows you to apply a filter on the combined result
ggplot(mtcars, aes(mpg, disp)) +
  as_group(
    geom_smooth(alpha = 1),
    geom_point(),
    id = 'group_1'
  ) +
  with_shadow('group_1', sigma = 4)

</code></pre>

<hr>
<h2 id='as_reference'>Create a reference to a layer for use in other filters</h2><span id='topic+as_reference'></span>

<h3>Description</h3>

<p>This function is basically synonymous with <code>with_raster()</code> but exist to make
the intend of marking a layer with a specific id clear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_reference(x, id = NULL, include = is.null(id))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_reference_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="as_reference_+3A_id">id</code></td>
<td>
<p>A string identifying this layer for later use</p>
</td></tr>
<tr><td><code id="as_reference_+3A_include">include</code></td>
<td>
<p>Should the layer itself be included in the graphic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other layer references: 
<code><a href="#topic+as_colourspace">as_colourspace</a>()</code>,
<code><a href="#topic+as_group">as_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot() +
  as_reference(
    geom_point(aes(20, 300), size = 100, colour = 'white'),
    id = 'mask_layer'
  ) +
  with_mask(
    geom_point(aes(mpg, disp), mtcars, size = 5),
    mask = 'mask_layer'
  )


</code></pre>

<hr>
<h2 id='blend_raster'>Raster Helpers</h2><span id='topic+blend_raster'></span><span id='topic+blend_custom_raster'></span><span id='topic+bloom_raster'></span><span id='topic+blur_raster'></span><span id='topic+displace_raster'></span><span id='topic+dither_raster'></span><span id='topic+inner_glow_raster'></span><span id='topic+interpolate_raster'></span><span id='topic+convolve_grob'></span><span id='topic+mask_raster'></span><span id='topic+motion_blur_raster'></span><span id='topic+ordered_dither_raster'></span><span id='topic+outer_glow_raster'></span><span id='topic+raster_helpers'></span><span id='topic+shade_raster'></span><span id='topic+variably_blur_raster'></span>

<h3>Description</h3>

<p>Raster Helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blend_raster(x, bg_layer, blend_type = "Over", flip_order = FALSE, alpha = NA)

blend_custom_raster(x, bg_layer, a, b, c, d, flip_order = FALSE, alpha = NA)

bloom_raster(
  x,
  threshold_lower = 80,
  threshold_upper = 100,
  sigma = 5,
  strength = 1,
  keep_alpha = TRUE
)

blur_raster(x, sigma = 0.5, stack = FALSE)

displace_raster(x, x_map, y_map = x_map, x_scale = 1, y_scale = x_scale)

dither_raster(x, max_colours = 256, colourspace = "sRGB")

inner_glow_raster(x, colour = "black", sigma = 3, expand = 0)

interpolate_raster(x, bg_layer, src_percent, bg_percent)

convolve_grob(
  x,
  kernel,
  iterations = 1,
  scaling = NULL,
  bias = NULL,
  stack = FALSE
)

mask_raster(x, mask, invert = FALSE)

motion_blur_raster(x, sigma = 0.5, angle = 0)

ordered_dither_raster(x, map, colourspace = "sRGB", offset = NULL)

outer_glow_raster(x, colour = "black", sigma = 3, expand = 0)

shade_raster(
  x,
  height_map,
  azimuth = 30,
  elevation = 30,
  strength = 10,
  sigma = 0,
  blend_type = "overlay"
)

variably_blur_raster(
  x,
  x_sigma,
  y_sigma = x_sigma,
  angle = NULL,
  x_scale = 1,
  y_scale = x_scale,
  angle_range = 0
)
</code></pre>


<h3>Value</h3>

<p>A nativeRaster object
</p>

<hr>
<h2 id='Channels'>Set a channel of interest from a layer</h2><span id='topic+Channels'></span><span id='topic+ch_red'></span><span id='topic+ch_green'></span><span id='topic+ch_blue'></span><span id='topic+ch_alpha'></span><span id='topic+ch_hue'></span><span id='topic+ch_chroma'></span><span id='topic+ch_luminance'></span><span id='topic+ch_saturation'></span><span id='topic+ch_lightness'></span><span id='topic+ch_cyan'></span><span id='topic+ch_magenta'></span><span id='topic+ch_yellow'></span><span id='topic+ch_black'></span><span id='topic+ch_key'></span><span id='topic+ch_custom'></span>

<h3>Description</h3>

<p>Some effects uses a particular channel for specific parameters, such as
<code><a href="#topic+with_displacement">with_displacement()</a></code>, which grabs the relative x and y displacements from
different channels in some other layer. To facilitate specifying which
channel to use from a layer (which is always multichannel), you can wrap the
specification in a channel specifier given below. If a filter requires a
specific channel and none is specified it will default to <code>luminance</code> (based
on the <code>hcl</code> colour space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ch_red(x, colourspace = "sRGB", invert = FALSE)

ch_green(x, colourspace = "sRGB", invert = FALSE)

ch_blue(x, colourspace = "sRGB", invert = FALSE)

ch_alpha(x, colourspace = "sRGB", invert = FALSE)

ch_hue(x, colourspace = "HCL", invert = FALSE)

ch_chroma(x, colourspace = "HCL", invert = FALSE)

ch_luminance(x, colourspace = "HCL", invert = FALSE)

ch_saturation(x, colourspace = "HSL", invert = FALSE)

ch_lightness(x, colourspace = "HSL", invert = FALSE)

ch_cyan(x, colourspace = "CMYK", invert = FALSE)

ch_magenta(x, colourspace = "CMYK", invert = FALSE)

ch_yellow(x, colourspace = "CMYK", invert = FALSE)

ch_black(x, colourspace = "CMYK", invert = FALSE)

ch_key(x, colourspace = "CMYK", invert = FALSE)

ch_custom(x, channel, colourspace, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Channels_+3A_x">x</code></td>
<td>
<p>Any object interpretable as a layer</p>
</td></tr>
<tr><td><code id="Channels_+3A_colourspace">colourspace</code></td>
<td>
<p>The colourspace the channel should be extracted from.</p>
</td></tr>
<tr><td><code id="Channels_+3A_invert">invert</code></td>
<td>
<p>Should the channel values be inverted before use</p>
</td></tr>
<tr><td><code id="Channels_+3A_channel">channel</code></td>
<td>
<p>The name of a channel in the given colourspace</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with a channel spec attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
volcano_long &lt;- data.frame(
  x = as.vector(col(volcano)),
  y  = as.vector(row(volcano)),
  z = as.vector(volcano)
)

# invert the green channel
ggplot(volcano_long, aes(y, x)) +
  as_reference(
    geom_contour_filled(aes(z = z, fill = after_stat(level))),
    id = 'contours'
  ) +
  as_colourspace(
    ch_red('contours'),
    ch_green('contours', invert = TRUE),
    ch_blue('contours')
  )

</code></pre>

<hr>
<h2 id='object_support'>Supported object types</h2><span id='topic+object_support'></span>

<h3>Description</h3>

<p>The different filters provided by ggfx are applicable to a wide range of
object types. Rather than documenting how to use them with each type in every
documentation entry, the information is collected here. While the examples
will use <code><a href="#topic+with_blur">with_blur()</a></code> they are general and applicable to all filters in
ggfx.
</p>


<h3>Value</h3>

<p>All filters will generally return a new version of the same object,
the only exception being filtering of rasters, functions, and references
which returns a Layer object
</p>


<h3>Method specific arguments</h3>


<ul>
<li> <p><code>id</code>: A string that identifies the result of this filter, to be referenced
by other filters in the same graphic.
</p>
</li>
<li> <p><code>include</code>: A logical flag that indicates whether the filtered image should
be displayed. By default, the result will not be displayed if it is given
an <code>id</code> (as it is assumed that it is meant for later use), but this can be
overewritten by setting <code>include = TRUE</code>.
</p>
</li>
<li> <p><code>ignore_background</code>: Should the background of the plot be removed before
applying the filter and re-added afterwards?
</p>
</li>
<li> <p><code>background</code>: A grob to draw below the result of the filter. Mainly for
internal use for supporting <code>ignore_background</code>.
</p>
</li></ul>



<h3>Filtering layers</h3>

<p>This is perhaps the most common and obvious use of ggfx, and the one
show-cased in the respective docs of each filter. In order to apply a filter
to a ggplot2 layer you wrap it around the layer constructor (usually a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function) and pass in additional parameters after it:
</p>
<div class="sourceCode r"><pre>ggplot(mtcars) +
  with_blur(
    geom_point(aes(x = mpg, y = disp)),
    sigma = 4
  )
</pre></div>
<p>Apart from the arguments specific to the filter, layer filters also take an
<code>id</code>, and <code>include</code> argument. Providing an id (as a string) will make this
filter be referable by other filters. By default this turns of rendering of
the result, but setting <code>include = TRUE</code> will turn rendering back on (while
still making it referable). Referable layers should <strong>always</strong> come before
whatever other layer ends up referring to them, since ggfx does not have
control over the rendering order. Not following this rule will have undefined
consequences (either an error or a weird plot - or maybe the correct result)
</p>


<h3>Filtering layer references</h3>

<p>While the first argument to a filter is mostly some sort of graphic
generating object, it can also be a text string referring to another filter.
This allows you to string together filters, should you so choose. The big
caveat is that filtering a reference will always result in a layer - i.e. it
is not compatible outside of ggplot2.
</p>
<div class="sourceCode r"><pre>ggplot(mtcars) +
  with_blur(
    geom_point(aes(x = mpg, y = disp)),
    sigma = 4,
    id = 'blurred_points'
  ) +
  with_shadow(
    'blurred_points'
  )
</pre></div>


<h3>Filtering guides</h3>

<p>ggplot2 does not only consist of layers - there are all sort of other graphic
elements around them. Guides are one such type of element and these can be
filtered by wrapping the filter around the guide constructor:
</p>
<div class="sourceCode r"><pre>ggplot(mtcars) +
  geom_point(aes(x = mpg, y = disp, colour = gear)) +
  guides(colour = with_blur(guide_colourbar(), sigma = 4))
</pre></div>
<p>There is a caveat here in that it is not possible to use this with the string
shorthand (i.e. <code>with_blur('colourbar')</code> won't work) â€” you have to use the
functional form.
</p>


<h3>Filtering theme elements</h3>

<p>Theme elements, like guides, is another non-layer graphic that is amenable to
filtering. It can be done by wrapping the <code style="white-space: pre;">&#8288;element_*()&#8288;</code> constructor with a
filter:
</p>
<div class="sourceCode r"><pre>ggplot(mtcars) +
  geom_point(aes(x = mpg, y = disp)) +
  ggtitle("A blurry title") +
  theme(plot.title = with_blur(element_text(), sigma = 4))
</pre></div>
<p>There is a caveat here as well. The filtering doesn't get carried through
inheritance so you cannot set filtering at a top-level element and expect all
child elements to be filtered.
</p>


<h3>Filtering ggplots</h3>

<p>While you normally only want to add a filter to a part of the plot, it is
also possible to add it to everthing, simply by wrapping the filter function
around the plot. You can elect to remove the background element while
applying the filter and add it back on afterwards by setting
<code>ignore_background = TRUE</code> on the filter
</p>
<div class="sourceCode r"><pre>p &lt;- ggplot(mtcars) +
  geom_point(aes(x = mpg, y = disp))

with_blur(p, sigma = 4)
</pre></div>
<p>An alternative is to put the filter around the <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> call, which will
have the same effect and may fit better with your plot construction code
</p>
<div class="sourceCode r"><pre>with_blur(ggplot(mtcars), sigma = 4) +
  geom_point(aes(x = mpg, y = disp))
</pre></div>


<h3>Filtering grobs</h3>

<p>At the lowest level, it is possible to apply a filter to a grob. This is what
powers all of the above at some level and that power is also available to
you. It is done in the same manner as all of the above, by wrapping the grob
in a filter:
</p>
<div class="sourceCode r"><pre>blurred_circle &lt;- with_blur(circleGrob(), sigma = 4)

grid.newpage()
grid.draw(blurred_circle)
</pre></div>
<p>As with layers, filters applied to grobs also take an <code>id</code> and <code>include</code>
argument and they have the same effect. It should be noted that it can be
difficult to grasp the rendering order of elements in a manually created grid
graphics, so take care when using filters that refer to each other as the
rule about the rendering order still applies.
</p>
<p>There are not a lot of people who use grid directly, but if you develop
ggplot2 extensions the ability to apply filters to grobs means that you can
create geoms with filters build right into them!
</p>

<hr>
<h2 id='raster_placement'>Control placements of raster in the plot</h2><span id='topic+raster_placement'></span><span id='topic+ras_fill'></span><span id='topic+ras_fit'></span><span id='topic+ras_stretch'></span><span id='topic+ras_place'></span><span id='topic+ras_tile'></span>

<h3>Description</h3>

<p>When using raster objects directly you need to somehow define how it should
be located in resized in the plot. These function can be used to inform the
filter on how it should be used. They only work on <code>raster</code> type object, so
cannot be used around functions or layer id's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras_fill(raster, align_to = "canvas")

ras_fit(raster, align_to = "canvas")

ras_stretch(raster, align_to = "canvas")

ras_place(raster, align_to = "canvas", anchor = "topleft", offset = c(0, 0))

ras_tile(
  raster,
  align_to = "canvas",
  anchor = "topleft",
  offset = c(0, 0),
  flip = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_placement_+3A_raster">raster</code></td>
<td>
<p>A <code>raster</code> or <code>nativeRaster</code> object or an object coercible to
a <code>raster</code> object</p>
</td></tr>
<tr><td><code id="raster_placement_+3A_align_to">align_to</code></td>
<td>
<p>Should the raster be positioned according to the canvas or
the current viewport</p>
</td></tr>
<tr><td><code id="raster_placement_+3A_anchor">anchor</code></td>
<td>
<p>Where should the raster be placed relative to the alignment
area</p>
</td></tr>
<tr><td><code id="raster_placement_+3A_offset">offset</code></td>
<td>
<p>A unit or numeric vector giving an additional offset relative
to the anchor. Positive values moves right/down and negative values move
left/up</p>
</td></tr>
<tr><td><code id="raster_placement_+3A_flip">flip</code></td>
<td>
<p>Should every other repetition be flipped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input with additional information attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
logo &lt;- as.raster(magick::image_read(
  system.file('help', 'figures', 'logo.png', package = 'ggfx')
))

# Default is to fill the viewport area, preserving the aspect ratio of the
# raster
ggplot(mtcars) +
  with_blend(
    geom_point(aes(mpg, disp)),
    logo
  )

# But you can change that with these functions:
ggplot(mtcars) +
  with_blend(
    geom_point(aes(mpg, disp)),
    ras_place(logo, 'vp', 'bottomright')
  )

# Here we tile it with flipping, centering on the middle of the canvas
ggplot(mtcars) +
  with_blend(
    geom_point(aes(mpg, disp)),
    ras_tile(logo, anchor = 'center', flip = TRUE)
  )

</code></pre>

<hr>
<h2 id='render_context'>Rendering information</h2><span id='topic+render_context'></span><span id='topic+viewport_location'></span><span id='topic+index_raster'></span><span id='topic+get_raster_area'></span><span id='topic+set_raster_area'></span><span id='topic+get_viewport_area'></span><span id='topic+set_viewport_area'></span><span id='topic+viewport_is_clipping'></span><span id='topic+current_resolution'></span><span id='topic+to_pixels'></span><span id='topic+from_pixels'></span>

<h3>Description</h3>

<p>These utility functions can help when creating custom filters (using
<code><a href="#topic+with_custom">with_custom()</a></code>) as they can provide information about the current rendering
context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewport_location()

index_raster(raster, cols, rows)

get_raster_area(raster, xmin, ymin, xmax, ymax)

set_raster_area(raster, value, xmin, ymin)

get_viewport_area(raster)

set_viewport_area(raster, value)

viewport_is_clipping()

current_resolution()

to_pixels(x, y_axis = FALSE, location = FALSE)

from_pixels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_context_+3A_raster">raster</code></td>
<td>
<p>A <code>raster</code> or <code>nativeRaster</code> object</p>
</td></tr>
<tr><td><code id="render_context_+3A_cols">cols</code>, <code id="render_context_+3A_rows">rows</code></td>
<td>
<p>Column and row indices</p>
</td></tr>
<tr><td><code id="render_context_+3A_xmin">xmin</code>, <code id="render_context_+3A_ymin">ymin</code>, <code id="render_context_+3A_xmax">xmax</code>, <code id="render_context_+3A_ymax">ymax</code></td>
<td>
<p>Boundaries of the area in pixels. 0,0 is the
top-left corner</p>
</td></tr>
<tr><td><code id="render_context_+3A_value">value</code></td>
<td>
<p>An object of the same type as <code>raster</code></p>
</td></tr>
<tr><td><code id="render_context_+3A_x">x</code></td>
<td>
<p>A numeric or unit object</p>
</td></tr>
<tr><td><code id="render_context_+3A_y_axis">y_axis</code></td>
<td>
<p>is the unit pertaining to the y-axis? Defaults to <code>FALSE</code> (i.e.
it is measured on the x-axis)</p>
</td></tr>
<tr><td><code id="render_context_+3A_location">location</code></td>
<td>
<p>is the unit encoding a location? Defaults to <code>FALSE</code> (i.e. it
is encoding a dimension). Pixel locations are encoded based on a top-left
starting point, as opposed to grid's bottom-left coordinate system. This
means that y-axis locations will flip around when converted to pixels.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>viewport_location()</code>: Returns the bounding box defining the current
viewport in pixels in the order <code>xmin</code>, <code>ymin</code>, <code>xmax</code>, <code>ymax</code>
</p>
</li>
<li> <p><code>index_raster()</code>: Is a version of the classic <code style="white-space: pre;">&#8288;[,]&#8288;</code> indexing that is aware
of the row-major order of rasters
</p>
</li>
<li> <p><code>get_raster_area()</code>: Extracts an area of a raster based on a bounding box
</p>
</li>
<li> <p><code>set_raster_area()</code>: Sets an area of a raster to a new raster value
</p>
</li>
<li> <p><code>get_viewport_area()</code>: A version of <code>get_raster_area()</code> that specifically
extract the area defined by the current viewport
</p>
</li>
<li> <p><code>set_viewport_area()</code>: A version of <code>set_raster_area()</code> that specifically
sets the area defined by the current viewport
</p>
</li>
<li> <p><code>viewport_is_clipping()</code>: Returns <code>TRUE</code> if the current viewport has
clipping turned on
</p>
</li>
<li> <p><code>current_resolution()</code>: Returns the resolution of the active device in ppi
(pixels-per-inch)
</p>
</li>
<li> <p><code>to_pixels(x)</code>: Converts <code>x</code> to pixels if <code>x</code> is given as a unit object. It
is assumed that x encodes a dimension and not a location. If <code>x</code> is a
numeric it is assumed to already be in pixels
</p>
</li>
<li> <p><code>from_pixels</code>: Converts a numeric giving some pixel dimension to a unit
object.
</p>
</li></ul>



<h3>Value</h3>

<p>Depends on the function - see details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These functions are intended to be used inside filter functions, e.g.
library(ggplot2)

flip_raster &lt;- function(raster, horizontal = TRUE) {
  # Get the viewport area of the raster
  vp &lt;- get_viewport_area(raster)

  # Get the columns and rows of the raster - reverse order depending on
  # the value of horizontal
  dims &lt;- dim(vp)
  rows &lt;- seq_len(dims[1])
  cols &lt;- seq_len(dims[2])
  if (horizontal) {
    cols &lt;- rev(cols)
  } else {
    rows &lt;- rev(rows)
  }

  # change the order of columns or rows in the viewport raster
  vp &lt;- index_raster(vp, cols, rows)

  # Assign the modified viewport back
  set_viewport_area(raster, vp)
}

ggplot() +
  with_custom(
    geom_text(aes(0.5, 0.75, label = 'Flippediflop!'), size = 10),
    filter = flip_raster,
    horizontal = TRUE
  )

</code></pre>

<hr>
<h2 id='with_blend'>Blend a layer with a reference</h2><span id='topic+with_blend'></span>

<h3>Description</h3>

<p>This filter blends the layer with a reference according to one of many rules
as laid out in the <em>Details</em> section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_blend(
  x,
  bg_layer,
  blend_type = "over",
  flip_order = FALSE,
  alpha = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_blend_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_blend_+3A_bg_layer">bg_layer</code></td>
<td>
<p>The background layer to use. Can either be a string
identifying a registered filter, or a raster object. The map will be resized
to match the dimensions of x.</p>
</td></tr>
<tr><td><code id="with_blend_+3A_blend_type">blend_type</code></td>
<td>
<p>The type of blending to perform. See <em>Details</em></p>
</td></tr>
<tr><td><code id="with_blend_+3A_flip_order">flip_order</code></td>
<td>
<p>Should the order of the background and the overlay be
flipped so that <code>bg_layer</code> is treated as being on top and <code>x</code> being below.</p>
</td></tr>
<tr><td><code id="with_blend_+3A_alpha">alpha</code></td>
<td>
<p>For non-Duff-Porter blends the alpha channel may become modified.
This argument can be used to set the resulting alpha channel to that of the
source (<code>"src"</code>) or destination (<code>"dst"</code>)</p>
</td></tr>
<tr><td><code id="with_blend_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two images can be blended in a variety of ways as described below. In the
following <em>source</em> will refer to the top-most image, and <em>destination</em>  to
the bottom-most image. Note that which is which can be controlled with the
<code>flip_order</code> argument.
</p>


<h4>Duff-Porter alpha blend modes</h4>

<p>This is a set of well-defined blend types for composing two images, taking
their opacity into account:
</p>

<ul>
<li> <p><code>"source"</code>: Completely disregards the destination, leaving only the source
</p>
</li>
<li> <p><code>"destination"</code>: Completely disregards the source, leaving only the
destination
</p>
</li>
<li> <p><code>"clear"</code>: Disregards both destination and source
</p>
</li>
<li> <p><code>"xor"</code>: Composes source on top of destination, setting shared areas to
transparent
</p>
</li>
<li> <p><code>"over"</code>: Composes source on top of destination
</p>
</li>
<li> <p><code>"in"</code>: Shows source, but only where the destination is opaque
</p>
</li>
<li> <p><code>"out"</code>: Shows source but only where the destination is transparent
</p>
</li>
<li> <p><code>"atop"</code>: Composes source on top of destination, keeping the transparency
of destination
</p>
</li>
<li> <p><code>"copy"</code>: Like source, but will only affect the area occupied by the source
image
</p>
</li></ul>




<h4>Mathmathical blend modes</h4>

<p>These blend modes perform often complex channel operations based on the
different channel values in the source and destination:
</p>

<ul>
<li> <p><code>"multiply"</code>: Multiplies the channel values of source and destination
together (after scaling them to 0-1) to obtain new channel values
</p>
</li>
<li> <p><code>"screen"</code>: As multiply except that the channels are scaled to 1-0 before
multiplication, and the result is reversed again before being used
</p>
</li>
<li> <p><code>"bumpmap"</code>: Like multiple, except source is converted to greyscale first
</p>
</li>
<li> <p><code>"divide"</code>: Divide the channel values in source by the channel values in
destination
</p>
</li>
<li> <p><code>"plus"</code>: Add the channel values together <em>including the alpha channel</em>
</p>
</li>
<li> <p><code>"minus"</code>: Subtracts the destination channels from the source channels
</p>
</li>
<li> <p><code>"modulus_plus"</code>: As plus, but overflow will wrap around instead of being
capped
</p>
</li>
<li> <p><code>"modulus_minus"</code>: As minus but overflow (underflow) will wrap around
instead of being capped
</p>
</li>
<li> <p><code>"difference"</code>: Takes the absolute difference in channel values between
source and destination
</p>
</li>
<li> <p><code>"exclusion"</code>: <code>source + destination - 2*source*destination</code>. A sort of
averaged difference
</p>
</li>
<li> <p><code>"lighten"</code>: Will pick the lightest pixel at each pixel
</p>
</li>
<li> <p><code>"darken"</code>: Will pick the darkest pixel at each pixel
</p>
</li>
<li> <p><code>"lighten_intensity"</code>: Will pick the most intense colour at each pixel
</p>
</li>
<li> <p><code>"darken_intensity"</code>: Will pick the least intense colour at each pixel
</p>
</li></ul>




<h4>Lighting blend modes</h4>

<p>These blend modes are designed to provide different lighting effects:
</p>

<ul>
<li> <p><code>"overlay"</code>: Simultaneously multiplies and screens at the same time based
on the colour values of the destination. Will colorize midtones in the
destination with the source
</p>
</li>
<li> <p><code>"hard_light"</code>: The inverse of overlay (i.e. the source acts as the
destination and vice versa)
</p>
</li>
<li> <p><code>"soft_light"</code>: Like overlay but will extent the range of colorization past
the midtones
</p>
</li>
<li> <p><code>"pegtop_light"</code>: Like soft-light, but without any discontinuity in the
blend
</p>
</li>
<li> <p><code>"linear_light"</code>: Combines dodging and burning so that the destination will
be dodged (lightened) when the source is light and burned (darkened) when
the source is dark
</p>
</li>
<li> <p><code>"vivid_light"</code>: A refinement of linear-light that better avoids shading
intense colours
</p>
</li>
<li> <p><code>"pin_light"</code>: Preserves midtones of the destination and only shades
lighter and darker parts, resulting in harsh, contrasty lightning.
</p>
</li>
<li> <p><code>"linear_dodge"</code>: Lighten the destination if the source is light
</p>
</li>
<li> <p><code>"linear_burn"</code>: Darked the destination if the source is dark
</p>
</li>
<li> <p><code>"color_dodge"</code>: Like linear-dodge, but preserves blacks in the destination
image
</p>
</li>
<li> <p><code>"color_burn"</code>: Like linear-burn but preserve whites in the destination
image
</p>
</li></ul>




<h4>Channel copying blends</h4>

<p>These blend modes copies a single channel from the source to the destination
</p>

<ul>
<li> <p><code>"copy_opacity"</code>: Will set the opacity of destination to the grayscale
version of source. To copy the opacity of source into destination use
<code>blend_type = "in"</code> with <code>flip_order = TRUE</code>.
</p>
</li>
<li> <p><code>"copy_red"</code>: Copies the red channel in source into the red channel in
destination
</p>
</li>
<li> <p><code>"copy_green"</code>: Copies the green channel in source into the green channel in
destination
</p>
</li>
<li> <p><code>"copy_blue"</code>: Copies the blue channel in source into the blue channel in
destination
</p>
</li>
<li> <p><code>"hue"</code>: Replaces the hue of the destination with the hue of the source
</p>
</li>
<li> <p><code>"saturate"</code>: Replaces the saturation of the destination with the
saturation of the source
</p>
</li>
<li> <p><code>"luminize"</code>: Replaces the luminance of the destination with the luminance
of the source
</p>
</li>
<li> <p><code>"colorize"</code>: Combines hue and saturate
</p>
</li></ul>




<h4>Special blends</h4>


<ul>
<li> <p><code>"unique"</code>: Only keep pixels in the source that differ from the
destination.
</p>
</li></ul>

<p>The above is obviously a very quick overview. More information can be found
in <a href="https://legacy.imagemagick.org/Usage/compose/">https://legacy.imagemagick.org/Usage/compose/</a>
</p>



<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blend filters: 
<code><a href="#topic+with_blend_custom">with_blend_custom</a>()</code>,
<code><a href="#topic+with_interpolate">with_interpolate</a>()</code>,
<code><a href="#topic+with_mask">with_mask</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot() +
  as_reference(
    geom_text(aes(0.5, 0.5, label = 'Blend Modes!'), size = 10, fontface = 'bold'),
    id = "text"
  ) +
  with_blend(
    geom_polygon(aes(c(0, 1, 1), c(0, 0, 1)), colour = NA, fill = 'magenta'),
    bg_layer = "text",
    blend_type = 'xor'
  )

</code></pre>

<hr>
<h2 id='with_blend_custom'>Create a custom blend type</h2><span id='topic+with_blend_custom'></span>

<h3>Description</h3>

<p>Many of the blend types available in <code><a href="#topic+with_blend">with_blend()</a></code> are variations over the
formula: <code>a*src*dst + b*src + c*dst + d</code>, where <code>src</code> stands for the channel
value in the source image and <code>dst</code> stands for the destination image (the
background). Multiply is e.g. defined as <code style="white-space: pre;">&#8288;a:1, b:0, c:0, d:0&#8288;</code>. This filter
gives you free reign over setting the coefficient of the blend calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_blend_custom(
  x,
  bg_layer,
  a = 0,
  b = 0,
  c = 0,
  d = 0,
  flip_order = FALSE,
  alpha = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_blend_custom_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_blend_custom_+3A_bg_layer">bg_layer</code></td>
<td>
<p>The background layer to use. Can either be a string
identifying a registered filter, or a raster object. The map will be resized
to match the dimensions of x.</p>
</td></tr>
<tr><td><code id="with_blend_custom_+3A_a">a</code>, <code id="with_blend_custom_+3A_b">b</code>, <code id="with_blend_custom_+3A_c">c</code>, <code id="with_blend_custom_+3A_d">d</code></td>
<td>
<p>The coefficients defining the blend operation</p>
</td></tr>
<tr><td><code id="with_blend_custom_+3A_flip_order">flip_order</code></td>
<td>
<p>Should the order of the background and the overlay be
flipped so that <code>bg_layer</code> is treated as being on top and <code>x</code> being below.</p>
</td></tr>
<tr><td><code id="with_blend_custom_+3A_alpha">alpha</code></td>
<td>
<p>For non-Duff-Porter blends the alpha channel may become modified.
This argument can be used to set the resulting alpha channel to that of the
source (<code>"src"</code>) or destination (<code>"dst"</code>)</p>
</td></tr>
<tr><td><code id="with_blend_custom_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blend filters: 
<code><a href="#topic+with_blend">with_blend</a>()</code>,
<code><a href="#topic+with_interpolate">with_interpolate</a>()</code>,
<code><a href="#topic+with_mask">with_mask</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(mpg, aes(class, hwy)) +
  as_reference(geom_boxplot(fill = 'green'), 'box') +
  with_blend_custom(geom_point(colour = 'red'),
                    bg_layer = 'box', a = -0.5, b = 1, c = 1)

</code></pre>

<hr>
<h2 id='with_bloom'>Apply bloom to your layer</h2><span id='topic+with_bloom'></span>

<h3>Description</h3>

<p>Bloom is the effect of strong light sources spilling over into neighbouring
dark areas. It is used a lot in video games and movies to give the effect of
strong light, even though the monitor is not itself capable of showing light
at that strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_bloom(
  x,
  threshold_lower = 80,
  threshold_upper = 100,
  sigma = 5,
  strength = 1,
  keep_alpha = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_bloom_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_bloom_+3A_threshold_lower">threshold_lower</code>, <code id="with_bloom_+3A_threshold_upper">threshold_upper</code></td>
<td>
<p>The lowest channel value to consider
emitting light and the highest channel value that should be considered
maximum light strength, given in percent</p>
</td></tr>
<tr><td><code id="with_bloom_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel used for the
bloom. Will affect the size of the halo around light objects</p>
</td></tr>
<tr><td><code id="with_bloom_+3A_strength">strength</code></td>
<td>
<p>A value between 0 and 1 to use for changing the strength of
the effect.</p>
</td></tr>
<tr><td><code id="with_bloom_+3A_keep_alpha">keep_alpha</code></td>
<td>
<p>Should the alpha channel of the layer be kept, effectively
limiting the bloom effect to the filtered layer. Setting this to false will
allow the bloom to spill out to the background, but since it is not being
blended correctly with the background the effect looks off.</p>
</td></tr>
<tr><td><code id="with_bloom_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
points &lt;- data.frame(
  x = runif(1000),
  y = runif(1000),
  col = runif(1000)
)
ggplot(points, aes(x, y, colour = col)) +
  with_bloom(
    geom_point(size = 10),
  ) +
  scale_colour_continuous(type = 'viridis')

</code></pre>

<hr>
<h2 id='with_blur'>Apply a gaussian blur to your layer</h2><span id='topic+with_blur'></span>

<h3>Description</h3>

<p>This filter adds a blur to the provided ggplot layer. The amount of blur can
be controlled and the result can optionally be put underneath the original
layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_blur(x, sigma = 0.5, stack = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_blur_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_blur_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel. Increase it to
apply more blurring. If a numeric it will be interpreted as given in pixels.
If a unit object it will automatically be converted to pixels at rendering
time</p>
</td></tr>
<tr><td><code id="with_blur_+3A_stack">stack</code></td>
<td>
<p>Should the original layer be placed on top?</p>
</td></tr>
<tr><td><code id="with_blur_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blur filters: 
<code><a href="#topic+with_motion_blur">with_motion_blur</a>()</code>,
<code><a href="#topic+with_variable_blur">with_variable_blur</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(mtcars, aes(mpg, disp)) +
  with_blur(geom_point(data = mtcars, size = 3), sigma = 3)

</code></pre>

<hr>
<h2 id='with_circle_dither'>Dither image using a threshold dithering map</h2><span id='topic+with_circle_dither'></span><span id='topic+with_custom_dither'></span><span id='topic+with_halftone_dither'></span><span id='topic+with_ordered_dither'></span>

<h3>Description</h3>

<p>These filters reduces the number of colours in your layer and uses various
threshold maps along with a dithering algorithm to disperse colour error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_circle_dither(
  x,
  map_size = 7,
  levels = NULL,
  black = TRUE,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_custom_dither(
  x,
  map = "checks",
  levels = NULL,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_halftone_dither(
  x,
  map_size = 8,
  levels = NULL,
  angled = TRUE,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_ordered_dither(x, map_size = 8, levels = NULL, colourspace = "sRGB", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_circle_dither_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_map_size">map_size</code></td>
<td>
<p>One of 2, 3, 4, or 8. Sets the threshold map used for
dithering. The larger, the better approximation of the input colours</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_levels">levels</code></td>
<td>
<p>The number of threshold levels in each channel. Either a single
integer to set the same number of levels in each channel, or 3 values to set
the levels individually for each colour channel</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_black">black</code></td>
<td>
<p>Should the map consist of dark circles expanding into the light,
or the reverse</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_colourspace">colourspace</code></td>
<td>
<p>In which colourspace should the dithering be calculated</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_offset">offset</code></td>
<td>
<p>The angle offset between the colour channels</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_map">map</code></td>
<td>
<p>The name of the threshold map to use as understood by
<code><a href="magick.html#topic+color">magick::image_ordered_dither()</a></code></p>
</td></tr>
<tr><td><code id="with_circle_dither_+3A_angled">angled</code></td>
<td>
<p>Should the halftone pattern be at an angle or orthogonal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other dithering filters: 
<code><a href="#topic+with_dither">with_dither</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

# Ordered dither
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_ordered_dither(
    geom_raster(aes(fill = density), interpolate = TRUE)
  ) +
  scale_fill_continuous(type = 'viridis')

# Halftone dither
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_halftone_dither(
    geom_raster(aes(fill = density), interpolate = TRUE)
  ) +
  scale_fill_continuous(type = 'viridis')

# Circle dither with offset
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_circle_dither(
    geom_raster(aes(fill = density), interpolate = TRUE),
    offset = 29,
    colourspace = 'cmyk'
  ) +
  scale_fill_continuous(type = 'viridis')

</code></pre>

<hr>
<h2 id='with_custom'>Apply a custom filter</h2><span id='topic+with_custom'></span>

<h3>Description</h3>

<p>This function allows you to apply a custom filtering function to a layer. The
function must take a <code>nativeRaster</code> object as the first argument along with
any other arguments passed to <code>...</code>. Be aware that the raster spans the full
device size and not just the viewport currently rendered to. This is because
graphics may extend outside of the viewport depending on the clipping
settings. You can use <code><a href="#topic+get_viewport_area">get_viewport_area()</a></code> along with all the other raster
helpers provided by ggfx to facilitate working with the input raster. See the
example below for some inspiration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_custom(x, filter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_custom_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_custom_+3A_filter">filter</code></td>
<td>
<p>A function taking a <code>nativeRaster</code> object as the first argument
along with whatever you pass in to <code>...</code></p>
</td></tr>
<tr><td><code id="with_custom_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>filter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
flip_raster &lt;- function(raster, horizontal = TRUE) {
  # Get the viewport area of the raster
  vp &lt;- get_viewport_area(raster)

  # Get the columns and rows of the raster - reverse order depending on
  # the value of horizontal
  dims &lt;- dim(vp)
  rows &lt;- seq_len(dims[1])
  cols &lt;- seq_len(dims[2])
  if (horizontal) {
    cols &lt;- rev(cols)
  } else {
    rows &lt;- rev(rows)
  }

  # change the order of columns or rows in the viewport raster
  vp &lt;- index_raster(vp, cols, rows)

  # Assign the modified viewport back
  set_viewport_area(raster, vp)
}

ggplot() +
  with_custom(
    geom_text(aes(0.5, 0.75, label = 'Flippediflop!'), size = 10),
    filter = flip_raster,
    horizontal = TRUE
  )

ggplot() +
  with_custom(
    geom_text(aes(0.5, 0.75, label = 'Flippediflop!'), size = 10),
    filter = flip_raster,
    horizontal = FALSE
  )

</code></pre>

<hr>
<h2 id='with_displacement'>Apply a displacement map to a layer</h2><span id='topic+with_displacement'></span>

<h3>Description</h3>

<p>This filter displaces the pixels based on the colour values of another layer
or raster object. As such it can be used to distort the content of the layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_displacement(x, x_map, y_map = x_map, x_scale = 1, y_scale = x_scale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_displacement_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_displacement_+3A_x_map">x_map</code>, <code id="with_displacement_+3A_y_map">y_map</code></td>
<td>
<p>The displacement maps to use. Can either be a string
identifying a registered filter, or a raster object. The maps will be resized
to match the dimensions of x. Only one channel will be used - see
<a href="#topic+Channels">the docs on channels</a> for info on how to set them.</p>
</td></tr>
<tr><td><code id="with_displacement_+3A_x_scale">x_scale</code>, <code id="with_displacement_+3A_y_scale">y_scale</code></td>
<td>
<p>How much displacement should a maximal channel value
correspond to? If a numeric it will be interpreted as pixel dimensions. If a
unit object it will be converted to pixel dimension when rendered.</p>
</td></tr>
<tr><td><code id="with_displacement_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot() +
  as_reference(
    geom_polygon(aes(c(0, 1, 1), c(0, 0, 1)), colour = NA, fill = 'magenta' ),
    id = "displace_map"
  ) +
  with_displacement(
    geom_text(aes(0.5, 0.5, label = 'Displacements!'), size = 10),
    x_map = ch_red("displace_map"),
    y_map = ch_blue("displace_map"),
    x_scale = unit(0.025, 'npc'),
    y_scale = unit(0.025, 'npc')
  )

</code></pre>

<hr>
<h2 id='with_dither'>Dither image using Floyd-Steinberg error correction dithering</h2><span id='topic+with_dither'></span>

<h3>Description</h3>

<p>This filter reduces the number of colours in your layer and uses the
Floyd-Steinberg algorithm to even out the error introduced by the colour
reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_dither(x, max_colours = 256, colourspace = "sRGB", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_dither_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_dither_+3A_max_colours">max_colours</code></td>
<td>
<p>The maximum number of colours to use. The result may
contain fewer colours but never more.</p>
</td></tr>
<tr><td><code id="with_dither_+3A_colourspace">colourspace</code></td>
<td>
<p>In which colourspace should the dithering be calculated</p>
</td></tr>
<tr><td><code id="with_dither_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other dithering filters: 
<code><a href="#topic+with_circle_dither">with_circle_dither</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_dither(
    geom_raster(aes(fill = density), interpolate = TRUE),
    max_colours = 10
  ) +
  scale_fill_continuous(type = 'viridis')

</code></pre>

<hr>
<h2 id='with_inner_glow'>Apply an inner glow to your layer</h2><span id='topic+with_inner_glow'></span>

<h3>Description</h3>

<p>This filter adds an inner glow to your layer with a specific colour and size.
The best effect is often had by drawing the stroke separately so the glow is
only applied to the fill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_inner_glow(x, colour = "black", sigma = 3, expand = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_inner_glow_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_inner_glow_+3A_colour">colour</code></td>
<td>
<p>The colour of the glow</p>
</td></tr>
<tr><td><code id="with_inner_glow_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel. Increase it to
apply more blurring. If a numeric it will be interpreted as given in pixels.
If a unit object it will automatically be converted to pixels at rendering
time</p>
</td></tr>
<tr><td><code id="with_inner_glow_+3A_expand">expand</code></td>
<td>
<p>An added dilation to the glow mask before blurring it</p>
</td></tr>
<tr><td><code id="with_inner_glow_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other glow filters: 
<code><a href="#topic+with_outer_glow">with_outer_glow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot(mtcars, aes(as.factor(gear), disp)) +
  with_inner_glow(
    geom_boxplot(),
    colour = 'red',
    sigma = 10
  )

# This gives a red tone to the lines as well which may not be desirable
# This can be fixed by drawing fill and stroke separately
ggplot(mtcars, aes(as.factor(gear), disp)) +
  with_inner_glow(
    geom_boxplot(colour = NA),
    colour = 'red',
    sigma = 10
  ) +
  geom_boxplot(fill = NA)

</code></pre>

<hr>
<h2 id='with_interpolate'>Blend two layerrs together by averaging them out</h2><span id='topic+with_interpolate'></span>

<h3>Description</h3>

<p>Two layers can be blended together in the literal sense (not like
<code><a href="#topic+with_blend">with_blend()</a></code>) so that the result is the average of the two. This is the
purpose of <code>with_interpolate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_interpolate(x, bg_layer, src_percent, bg_percent = 100 - src_percent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_interpolate_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_interpolate_+3A_bg_layer">bg_layer</code></td>
<td>
<p>The layer to blend with</p>
</td></tr>
<tr><td><code id="with_interpolate_+3A_src_percent">src_percent</code>, <code id="with_interpolate_+3A_bg_percent">bg_percent</code></td>
<td>
<p>The contribution of this layer and the
background layer to the result. Should be between 0 and 100</p>
</td></tr>
<tr><td><code id="with_interpolate_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blend filters: 
<code><a href="#topic+with_blend_custom">with_blend_custom</a>()</code>,
<code><a href="#topic+with_blend">with_blend</a>()</code>,
<code><a href="#topic+with_mask">with_mask</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(mpg, aes(class, hwy)) +
  as_reference(geom_boxplot(), 'box') +
  with_interpolate(geom_point(), bg_layer = 'box', src_percent = 70)

</code></pre>

<hr>
<h2 id='with_kernel'>Apply a gaussian blur to your layer</h2><span id='topic+with_kernel'></span>

<h3>Description</h3>

<p>This filter allows you to apply a custom kernel to your layer, thus giving
you more control than e.g. <code><a href="#topic+with_blur">with_blur()</a></code> which is also applying a kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_kernel(
  x,
  kernel = "Gaussian:0x2",
  iterations = 1,
  scaling = NULL,
  bias = NULL,
  stack = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_kernel_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_kernel_+3A_kernel">kernel</code></td>
<td>
<p>either a square matrix or a string. The string can either be a
parameterized <a href="magick.html#topic+kernel_types">kerneltype</a> such as: <code>"DoG:0,0,2"</code> or <code>"Diamond"</code>
or it can contain a custom matrix (see examples)</p>
</td></tr>
<tr><td><code id="with_kernel_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="with_kernel_+3A_scaling">scaling</code></td>
<td>
<p>string with kernel scaling. The special flag <code>"!"</code> automatically scales to full
dynamic range, for example: <code>"50%!"</code></p>
</td></tr>
<tr><td><code id="with_kernel_+3A_bias">bias</code></td>
<td>
<p>output bias string, for example <code>"50%"</code></p>
</td></tr>
<tr><td><code id="with_kernel_+3A_stack">stack</code></td>
<td>
<p>Should the original layer be placed on top?</p>
</td></tr>
<tr><td><code id="with_kernel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
# Add directional blur using the comet kernel
ggplot(mtcars, aes(mpg, disp)) +
  with_kernel(geom_point(size = 3), 'Comet:0,10')

</code></pre>

<hr>
<h2 id='with_mask'>Apply a mask to a layer</h2><span id='topic+with_mask'></span>

<h3>Description</h3>

<p>This filter applies a mask to the given layer, i.e. sets the opacity of the
layer based on another layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mask(x, mask, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mask_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_mask_+3A_mask">mask</code></td>
<td>
<p>The layer to use as mask. Can either be a string
identifying a registered filter, or a raster object. Will by default extract
the luminosity of the layer and use that as mask. To pick another channel use
one of the <a href="#topic+Channels">channel specification</a> function.</p>
</td></tr>
<tr><td><code id="with_mask_+3A_invert">invert</code></td>
<td>
<p>Should the mask be inverted before applying it</p>
</td></tr>
<tr><td><code id="with_mask_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blend filters: 
<code><a href="#topic+with_blend_custom">with_blend_custom</a>()</code>,
<code><a href="#topic+with_blend">with_blend</a>()</code>,
<code><a href="#topic+with_interpolate">with_interpolate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
volcano_raster &lt;- as.raster((volcano - min(volcano))/diff(range(volcano)))
circle &lt;- data.frame(
  x = cos(seq(0, 2*pi, length.out = 360)),
  y = sin(seq(0, 2*pi, length.out = 360))
)

ggplot() +
  as_reference(
    geom_polygon(aes(x = x, y = y), circle),
    id = 'circle'
  ) +
  with_mask(
    annotation_raster(volcano_raster, -1, 1, -1, 1, TRUE),
    mask = ch_alpha('circle')
  )

# use invert = TRUE to flip the mask
ggplot() +
  as_reference(
    geom_polygon(aes(x = x, y = y), circle),
    id = 'circle'
  ) +
  with_mask(
    annotation_raster(volcano_raster, -1, 1, -1, 1, TRUE),
    mask = ch_alpha('circle'),
    invert = TRUE
  )

</code></pre>

<hr>
<h2 id='with_motion_blur'>Apply a motion blur to your layer</h2><span id='topic+with_motion_blur'></span>

<h3>Description</h3>

<p>This filter adds a directional blur to the provided ggplot layer. The amount
of blur, as well as the angle, can be controlled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_motion_blur(x, sigma = 0.5, angle = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_motion_blur_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_motion_blur_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel. Increase it to
apply more blurring. If a numeric it will be interpreted as given in pixels.
If a unit object it will automatically be converted to pixels at rendering
time</p>
</td></tr>
<tr><td><code id="with_motion_blur_+3A_angle">angle</code></td>
<td>
<p>Direction of the movement in degrees (0 corresponds to a
left-to-right motion and the angles move in clockwise direction)</p>
</td></tr>
<tr><td><code id="with_motion_blur_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blur filters: 
<code><a href="#topic+with_blur">with_blur</a>()</code>,
<code><a href="#topic+with_variable_blur">with_variable_blur</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
ggplot(mtcars, aes(mpg, disp)) +
  with_motion_blur(
    geom_point(size = 3),
    sigma = 6,
    angle = -45
  )

</code></pre>

<hr>
<h2 id='with_outer_glow'>Apply an outer glow to your layer</h2><span id='topic+with_outer_glow'></span>

<h3>Description</h3>

<p>This filter adds an outer glow to your layer with a specific colour and size.
For very thin objects such as text it may be beneficial to add some
expansion. See the examples for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_outer_glow(x, colour = "black", sigma = 3, expand = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_outer_glow_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_outer_glow_+3A_colour">colour</code></td>
<td>
<p>The colour of the glow</p>
</td></tr>
<tr><td><code id="with_outer_glow_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel. Increase it to
apply more blurring. If a numeric it will be interpreted as given in pixels.
If a unit object it will automatically be converted to pixels at rendering
time</p>
</td></tr>
<tr><td><code id="with_outer_glow_+3A_expand">expand</code></td>
<td>
<p>An added dilation to the glow mask before blurring it</p>
</td></tr>
<tr><td><code id="with_outer_glow_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other glow filters: 
<code><a href="#topic+with_inner_glow">with_inner_glow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot(mtcars, aes(as.factor(gear), disp)) +
  with_outer_glow(
    geom_boxplot(),
    colour = 'red',
    sigma = 10
  )

# For thin objects (as the whiskers above) you may need to add a bit of
# expansion to make the glow visible:

ggplot(mtcars, aes(mpg, disp)) +
  geom_point() +
  with_outer_glow(
    geom_text(aes(label = rownames(mtcars))),
    colour = 'white',
    sigma = 10,
    expand = 10
  )

</code></pre>

<hr>
<h2 id='with_raster'>Convert a layer to a raster</h2><span id='topic+with_raster'></span>

<h3>Description</h3>

<p>This filter simply converts the given layer, grob, or ggplot to a raster and
inserts it back again. It is useful for vector graphics devices such as
svglite if a layer contains a huge amount of primitives that would make the
file slow to render. <code>as_reference(x, id)</code> is a shorthand for
<code>with_raster(x, id = id, include = FALSE)</code> that makes the intent of using
this grob or layer as only a filter reference clear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_raster(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_raster_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_raster_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(mtcars, aes(mpg, disp)) +
  with_raster(geom_point(data = mtcars, size = 3))

</code></pre>

<hr>
<h2 id='with_shade'>Apply a gaussian blur to your layer</h2><span id='topic+with_shade'></span>

<h3>Description</h3>

<p>This filter adds a blur to the provided ggplot layer. The amount of blur can
be controlled and the result can optionally be put underneath the original
layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_shade(
  x,
  height_map,
  azimuth = 30,
  elevation = 30,
  strength = 10,
  sigma = 0,
  blend_type = "overlay",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_shade_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_shade_+3A_height_map">height_map</code></td>
<td>
<p>The layer to use as a height_map. Can either be a string
identifying a registered filter, or a raster object. Will by default extract
the luminosity of the layer and use that as mask. To pick another channel use
one of the <a href="#topic+Channels">channel specification</a> function.</p>
</td></tr>
<tr><td><code id="with_shade_+3A_azimuth">azimuth</code>, <code id="with_shade_+3A_elevation">elevation</code></td>
<td>
<p>The location of the light source.</p>
</td></tr>
<tr><td><code id="with_shade_+3A_strength">strength</code></td>
<td>
<p>The strength of the shading. A numeric larger or equal to <code>1</code></p>
</td></tr>
<tr><td><code id="with_shade_+3A_sigma">sigma</code></td>
<td>
<p>The sigma used for blurring the shading before applying it.
Setting it to <code>0</code> turns off blurring. Using a high <code>strength</code> may reveal
artefacts in the calculated shading, especially if the <code>height_map</code> is
low-detail. Adding a slight blur may remove some of those artefacts.</p>
</td></tr>
<tr><td><code id="with_shade_+3A_blend_type">blend_type</code></td>
<td>
<p>A blend type as used in <code><a href="#topic+with_blend">with_blend()</a></code> for adding the
calculated shading to the layer. Should generally be left as-is</p>
</td></tr>
<tr><td><code id="with_shade_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
volcano_long &lt;- data.frame(
  x = as.vector(col(volcano)),
  y  = as.vector(row(volcano)),
  z = as.vector(volcano)
)
ggplot(volcano_long, aes(y, x)) +
  as_reference(
    geom_raster(aes(alpha = z), fill = 'black', interpolate = TRUE, show.legend = FALSE),
    id = 'height_map'
  ) +
  with_shade(
    geom_contour_filled(aes(z = z, fill = after_stat(level))),
    height_map = ch_alpha('height_map'),
    azimuth = 150,
    height = 5,
    sigma = 10
  ) +
  coord_fixed() +
  guides(fill = guide_coloursteps(barheight = 10))


</code></pre>

<hr>
<h2 id='with_shadow'>Apply a drop shadow to a layer</h2><span id='topic+with_shadow'></span>

<h3>Description</h3>

<p>This filter applies the familiar drop-shadow effect on elements in a layer.
It takes the outline of each shape, offsets it from its origin and applies a
blur to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_shadow(
  x,
  colour = "black",
  x_offset = 10,
  y_offset = 10,
  sigma = 1,
  stack = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_shadow_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_shadow_+3A_colour">colour</code></td>
<td>
<p>The colour of the shadow</p>
</td></tr>
<tr><td><code id="with_shadow_+3A_x_offset">x_offset</code>, <code id="with_shadow_+3A_y_offset">y_offset</code></td>
<td>
<p>The offset of the shadow from the origin
as numerics</p>
</td></tr>
<tr><td><code id="with_shadow_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the gaussian kernel. Increase it to
apply more blurring. If a numeric it will be interpreted as given in pixels.
If a unit object it will automatically be converted to pixels at rendering
time</p>
</td></tr>
<tr><td><code id="with_shadow_+3A_stack">stack</code></td>
<td>
<p>Should the original layer be placed on top?</p>
</td></tr>
<tr><td><code id="with_shadow_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(mtcars, aes(mpg, disp)) +
  with_shadow(geom_point(colour = 'red', size = 3), sigma = 3)

</code></pre>

<hr>
<h2 id='with_variable_blur'>Apply a variable blur to a layer</h2><span id='topic+with_variable_blur'></span>

<h3>Description</h3>

<p>This filter will blur a layer, but in contrast to <code><a href="#topic+with_blur">with_blur()</a></code> the amount
and nature of the blur need not be constant across the layer. The blurring is
based on a weighted ellipsoid, with width and height based on the values in
the corresponding <code>x_sigma</code> and <code>y_sigma</code> layers. The angle of the ellipsoid
can also be controlled and further varied based on another layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_variable_blur(
  x,
  x_sigma,
  y_sigma = x_sigma,
  angle = NULL,
  x_scale = 1,
  y_scale = x_scale,
  angle_range = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_variable_blur_+3A_x">x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td></tr>
<tr><td><code id="with_variable_blur_+3A_x_sigma">x_sigma</code>, <code id="with_variable_blur_+3A_y_sigma">y_sigma</code>, <code id="with_variable_blur_+3A_angle">angle</code></td>
<td>
<p>The layers to use for looking up the sigma
values and angledefining the blur ellipse at every point. Can either be a
string identifying a registered filter, or a raster object. The maps will be
resized to match the dimensions of x. Only one channel will be used - see
<a href="#topic+Channels">the docs on channels</a> for info on how to set them.</p>
</td></tr>
<tr><td><code id="with_variable_blur_+3A_x_scale">x_scale</code>, <code id="with_variable_blur_+3A_y_scale">y_scale</code></td>
<td>
<p>Which sigma should a maximal channel value correspond
to? If a numeric it will be interpreted as pixel dimensions. If a unit object
it will be converted to pixel dimension when rendered.</p>
</td></tr>
<tr><td><code id="with_variable_blur_+3A_angle_range">angle_range</code></td>
<td>
<p>The minimum and maximum angle that min and max in the
<code>angle</code> layer should correspond to. If <code>angle == NULL</code> or only a single value
is provided to <code>angle_range</code> the rotation will be constant across the whole
layer</p>
</td></tr>
<tr><td><code id="with_variable_blur_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to methods. See
<a href="#topic+object_support">the documentation of supported object</a> for a description of
object specific arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blur filters: 
<code><a href="#topic+with_blur">with_blur</a>()</code>,
<code><a href="#topic+with_motion_blur">with_motion_blur</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
cos_wave &lt;- function(width, height) {
  x &lt;- matrix(0, ncol = width, nrow = height)
  x &lt;- cos(col(x)/100)
  as.raster((x + 1) / 2)
}
ggplot() +
  as_reference(
    cos_wave,
    id = "wave"
  ) +
  with_variable_blur(
    geom_point(aes(disp, mpg), mtcars, size = 4),
    x_sigma = ch_red("wave"),
    y_sigma = ch_alpha("wave"),
    angle = ch_red("wave"),
    x_scale = 15,
    y_scale = 15,
    angle_range = c(-45, 45)
  )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
