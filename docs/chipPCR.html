<!DOCTYPE html><html><head><title>Help for package chipPCR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chipPCR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chipPCR-package'>
<p>Toolkit of functions to pre-process amplification data</p></a></li>
<li><a href='#AmpSim'>
<p>Amplification curve simulator</p></a></li>
<li><a href='#AmpSim.gui'>
<p>Amplification Curve Simulation Graphical User Interface</p></a></li>
<li><a href='#amptest'><p>Class <code>"amptest"</code></p></a></li>
<li><a href='#amptester'>
<p>Amplification test</p></a></li>
<li><a href='#amptester.gui'>
<p>Amplification Test Graphical User Interface</p></a></li>
<li><a href='#bg'><p>Class <code>"bg"</code></p></a></li>
<li><a href='#bg.max'>
<p>Simple function to detect and correct the background range</p></a></li>
<li><a href='#C126EG595'>
<p>qPCR Experiment for the Amplification of HPRT1 Using the Bio-Rad iQ5 thermo cycler</p></a></li>
<li><a href='#C126EG685'>
<p>qPCR Experiment for the Amplification of HPRT1 Using the Roche Light Cycler</p>
1.5</a></li>
<li><a href='#C127EGHP'>
<p>qPCR Experiment for the Amplification of MLC-2v Using the Roche Light Cycler</p>
1.5</a></li>
<li><a href='#C17'>
<p>Helicase Dependent Amplification of HPRT1 at Different Temperatures using the</p>
'VideoScan' Platform 2.0</a></li>
<li><a href='#C316.amp'>
<p>qPCR Experiment for the Amplification of adk Using the Bio-Rad iQ5 thermo cycler</p></a></li>
<li><a href='#C316.melt.hr'>
<p>Melting Curves (resolution: 0.2 degrees Celsius / step) for the Gene adk Using</p>
the Bio-Rad iQ5 thermo cycler</a></li>
<li><a href='#C316.melt.lr'>
<p>Melting Curves (resolution: 0.5 degrees Celsius / step) for the Gene adk Using the Bio-Rad iQ5 thermo cycler</p></a></li>
<li><a href='#C317.amp'>
<p>qPCR Experiment for the Amplification of adk Using the Bio-Rad CFX96 thermo cycler</p></a></li>
<li><a href='#C317.melt.hr'>
<p>Melting Curves (resolution: 0.1 degrees Celsius / step) for the Gene adk Using</p>
the Bio-Rad CFX96 thermo cycler</a></li>
<li><a href='#C317.melt.lr'>
<p>Melting Curves (resolution: 0.5 degrees Celsius / step) for the Gene adk Using the Bio-Rad CFX96 thermo cycler</p></a></li>
<li><a href='#C54'>
<p>qPCR Experiment for the amplification of MLC-2v using the 'VideoScan'</p>
heating/cooling-unit</a></li>
<li><a href='#C60.amp'>
<p>qPCR Experiment for the Amplification of MLC-2v and Vimentin (as decadic</p>
dilutions) Using the Roche Light Cycler 1.5</a></li>
<li><a href='#C60.melt'>
<p>Melt Curves MLC-2v and Vimentin for the qPCR Experiment C60.amp Using the</p>
Roche Light Cycler 1.5</a></li>
<li><a href='#C67'>
<p>Helicase Dependent Amplification of HPRT1 with different input DNA</p>
quantities using the Bio-Rad iQ5 thermo cycler</a></li>
<li><a href='#C81'>
<p>Helicase Dependent Amplification of pCNG1 using the 'VideoScan' Platform</p></a></li>
<li><a href='#C85'>
<p>Helicase Dependent Amplification of Vimentin using the 'VideoScan' Platform</p></a></li>
<li><a href='#capillaryPCR'>
<p>capillary convective PCR</p></a></li>
<li><a href='#CD74'>
<p>Quantitative PCR with a hydrolysis probe and DNA binding dye</p></a></li>
<li><a href='#CD75'>
<p>Helicase Dependent Amplification in the 'VideoScan' 'HCU'</p></a></li>
<li><a href='#chipPCR.datasets'>
<p>Overview for data sets of the <code>chipPCR</code> package</p></a></li>
<li><a href='#CPP'>
<p>Curve Pre-processor</p></a></li>
<li><a href='#der'><p>Class <code>"der"</code></p></a></li>
<li><a href='#eff'><p>Class <code>"eff"</code></p></a></li>
<li><a href='#Eff1000'>
<p>Highly Replicate Number Amplification Curves</p></a></li>
<li><a href='#Eff625'>
<p>Highly Replicate Number Amplification Curves</p></a></li>
<li><a href='#Eff750'>
<p>Highly Replicate Number Amplification Curves</p></a></li>
<li><a href='#Eff875'>
<p>Highly Replicate Number Amplification Curves</p></a></li>
<li><a href='#effcalc'>
<p>Analysis of the amplification efficiency</p></a></li>
<li><a href='#fixNA'>
<p>Impute missing values into a column of amplification data</p></a></li>
<li><a href='#humanrater'>
<p>humanrater, a graphical interface to rate curves</p></a></li>
<li><a href='#inder'>
<p>Interpolate derivatives</p></a></li>
<li><a href='#LAMP'>
<p>real-time loop-mediated isothermal amplification (LAMP) by Tanner et al. (2012)</p></a></li>
<li><a href='#lm.coefs'>
<p>Compute linear model coefficients</p></a></li>
<li><a href='#MFIaggr'>
<p>Multiple comparison of the cycle dependent variance of the fluorescence</p></a></li>
<li><a href='#MFIaggr.gui'>
<p>Multiple Comparison of the Cycle Dependent Variance - Graphical User</p>
Interface</a></li>
<li><a href='#normalizer'>
<p>Normalize data</p></a></li>
<li><a href='#plot.bg'>
<p>Plot <code>bg</code> objects</p></a></li>
<li><a href='#plot.der'>
<p>Plot <code>der</code> objects</p></a></li>
<li><a href='#plot.eff'>
<p>Plot <code>eff</code> objects</p></a></li>
<li><a href='#plot.refMFI'>
<p>Plot <code>refMFI</code> objects</p></a></li>
<li><a href='#plotCurves'>
<p>Plot Curves in an Orthogonal Matrix</p></a></li>
<li><a href='#refMFI'><p>Class <code>"refMFI"</code></p></a></li>
<li><a href='#rounder'>
<p>Round der objects</p></a></li>
<li><a href='#RPA'>
<p>Recombinase polymerase amplification (RPA) by Lutz et al.(2009)</p></a></li>
<li><a href='#smoother'>
<p>Wrapper for Several Smoothers of Amplification Data</p></a></li>
<li><a href='#summary-bg'>
<p>Summary <code>bg</code> objects</p></a></li>
<li><a href='#summary-der'>
<p>Summary <code>der</code> objects</p></a></li>
<li><a href='#summary-refMFI'>
<p>Summary <code>refMFI</code> objects</p></a></li>
<li><a href='#th'><p>Class <code>"th"</code></p></a></li>
<li><a href='#th.cyc'>
<p>Threshold Cycle</p></a></li>
<li><a href='#VIMCFX96_60'>
<p>Amplification Reaction Using the Bio-Rad CFX96</p></a></li>
<li><a href='#VIMCFX96_69'>
<p>Amplification Reaction Using the Bio-Rad CFX96</p></a></li>
<li><a href='#VIMCFX96_meltcurve'>
<p>Melting Curve Measured with the Bio-Rad CFX96</p></a></li>
<li><a href='#VIMiQ5_595'>
<p>Amplification Reaction Using the Bio-Rad iQ5</p></a></li>
<li><a href='#VIMiQ5_685'>
<p>Amplification Reaction Using the Bio-Rad iQ5</p></a></li>
<li><a href='#VIMiQ5_melt'>
<p>Melting Curve Measured with the Bio-Rad iQ5</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit of Helper Functions to Pre-Process Amplification Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-02</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to pre-process amplification curve data from polymerase chain reaction (PCR) or isothermal amplification reactions. Contains functions to normalize and baseline amplification curves, to detect both the start and end of an amplification reaction, several smoothers (e.g., LOWESS, moving average, cubic splines, Savitzky-Golay), a function to detect false positive amplification reactions and a function to determine the amplification efficiency. Quantification point (Cq) methods include the first (FDM) and second approximate derivative maximum (SDM) methods (calculated by a 5-point-stencil) and the cycle threshold method. Data sets of experimental nucleic acid amplification systems ('VideoScan HCU', capillary convective PCR (ccPCR)) and commercial systems are included. Amplification curves were generated by helicase dependent amplification (HDA), ccPCR or PCR. As detection system intercalating dyes (EvaGreen, SYBR Green) and hydrolysis probes (TaqMan) were used. For more information see: Roediger et al. (2015) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtv205">doi:10.1093/bioinformatics/btv205</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PCRuniversum/chipPCR">https://github.com/PCRuniversum/chipPCR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PCRuniversum/chipPCR/issues">https://github.com/PCRuniversum/chipPCR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>drc, knitr, markdown, qpcR, RDML, rmarkdown, spelling,
testthat, tinytex, xtable</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>lmtest, MASS, outliers, ptw, quantreg, Rfit, robustbase,
shiny, signal</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-04 14:36:42 UTC; tux</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Roediger <a href="https://orcid.org/0000-0002-1441-6512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Michal Burdukiewicz
    <a href="https://orcid.org/0000-0001-8926-582X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Konstantin A. Blagodatskikh [ctb],
  Andrej-Nikolai Spiess
    <a href="https://orcid.org/0000-0002-9630-4724"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Roediger &lt;stefan.roediger@b-tu.de&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-05 07:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='chipPCR-package'>
Toolkit of functions to pre-process amplification data
</h2><span id='topic+chipPCR-package'></span><span id='topic+chipPCR'></span>

<h3>Description</h3>

<p>A toolkit of functions to pre-process 
amplification curve data. Amplification data can be obtained from 
conventional PCR reactions or isothermal amplification reactions. Contains functions to normalize and baseline amplification curves, 
a routine to detect the start of an amplification reaction, several 
smoothers for amplification data, a function to distinguish positive and 
negative amplification reactions and a function to determine the 
amplification efficiency. The smoothers are based on LOWESS, moving 
average, cubic splines, Savitzky-Golay and others. In addition the first 
approximate approximate derivative maximum (FDM) and second approximate 
derivative maximum (SDM) can be calculated by a 5-point-stencil as 
quantification points from real-time amplification curves. <code>chipPCR</code> 
contains data sets of experimental nucleic acid amplification systems 
including the 'VideoScan' 'HCU' and a capillary convective PCR (ccPCR) system. 
The amplification data were generated by helicase dependent amplification 
(HDA) or polymerase chain reaction (PCR) under various temperature 
conditions. As detection system intercalating dyes (EvaGreen, SYBR Green) 
and hydrolysis probes (TaqMan) were used.
The latest source code is available via: 
<a href="https://github.com/PCRuniversum/chipPCR">https://github.com/PCRuniversum/chipPCR</a>
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> chipPCR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.8-12</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-06-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="#topic+bg.max">bg.max</a></code> can be used to remove missing 
values in amplification curve data. <code><a href="#topic+amptester">amptester</a></code> tests if an amplification is 
positive. <code><a href="#topic+fixNA">fixNA</a></code> is used to impute missing values 
from a data column. <code><a href="#topic+CPP">CPP</a></code> can be used to normalize 
curve data, to remove background, to remove outliers and further steps. Contains further functions to smooth the data by different 
functions including LOWESS, Moving Average, Friedman's SuperSmoother, Cubic 
Spline and Savitzky-Golay smoothing. 
</p>
<p>For more exhaustive description see the vignette (<code>vignette("chipPCR")</code>).
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>
<p>Maintainer: Stefan Roediger &lt;stefan.roediger@b-tu.de&gt;
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>
<p>Nucleic acid detection based on the use of microbeads: a review. S. 
Roediger, C. Liebsch, C. Schmidt, W. Lehmann, U. Resch-Genger, U. Schedler, 
P. Schierack. <em>Microchim Acta</em> 2014:1&ndash;18. DOI: 
10.1007/s00604-014-1243-4
</p>
<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>
<p>Spiess, A.-N., Deutschmann, C., Burdukiewicz, M., Himmelreich, R., Klat, K., 
Schierack, P., Roediger, S., 2014. Impact of Smoothing on Parameter Estimation 
in Quantitative DNA Amplification Experiments. <em>Clinical Chemistry</em> 
clinchem.2014.230656. doi:10.1373/clinchem.2014.230656
</p>


<h3>See Also</h3>

<p><a href="qpcR.html#topic+qpcR.news">qpcR.news</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: A simple function to test for a background range.
# Data were taken form the chipPCR C17 data set.
data(C17)
plot(C17[, 2], C17[,  3], xlab = "time [min]", ylab = "Fluorescence", 
      pch = 20)
res &lt;- bg.max(C17[, 2], C17[, 3], bg.corr = 1.4, bg.start = 3)
abline(v = c(slot(res, "bg.start"), slot(res, "bg.stop")), col = c(1,2))
abline(h = slot(res, "fluo"), col = "blue")
</code></pre>

<hr>
<h2 id='AmpSim'>
Amplification curve simulator
</h2><span id='topic+AmpSim'></span>

<h3>Description</h3>

<p>This function is a simple simulator of an amplification reaction based on a 
5-parameter Richards function. This simplified approach was chosen because it 
is impossible to model the shape of any amplification curve. An 
implementation of realistic models is ambitious and not conclusively 
addressed in the literature. First, they have to take &ldquo;all&rdquo; random 
effects of noise into consideration and second, they need to be generic 
enough to cover all amplification processes. More sophisticated mechanistic 
models and simulations have been proposed elsewhere <cite>mehra_2005, 
cobbs_2012</cite>. This approach of <code>AmpSim</code> is similar to the 
<code>pcrsim</code> function from the <em>qpcR</em> package, which offers 
simulations of sigmoidal qPCR data with goodness-of-fit analysis by 
Ritz and Spiess 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmpSim(cyc = 1:35, b.eff = -25, bl = 0.05, ampl = 1, Cq = 20, 
	noise = FALSE, nnl = 0.025, nnl.method = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AmpSim_+3A_cyc">cyc</code></td>
<td>

<p>is a vector containing the cycle values.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_b.eff">b.eff</code></td>
<td>

<p>can be used to adjust the amplification efficiency.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_bl">bl</code></td>
<td>

<p>is used to define the base level (minimum) of the background range.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_ampl">ampl</code></td>
<td>

<p>defines the plateau (maximum) of the amplification reaction.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_cq">Cq</code></td>
<td>

<p>defines approximately the quantification point (Cq) of the amplification 
reaction.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_noise">noise</code></td>
<td>

<p>adds some noise to the amplification reaction.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_nnl">nnl</code></td>
<td>

<p>level of noise during the amplification reaction.
</p>
</td></tr>
<tr><td><code id="AmpSim_+3A_nnl.method">nnl.method</code></td>
<td>

<p>trend of noise level during the amplification reaction. &quot;constant&quot; uses same
noise of amplification, &quot;decreasing&quot; leads to less noise at the end of the 
amplification reaction, and &quot;increasing&quot; leads to more noise at the end of 
the amplification reaction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AmpSim</code> is a simple simulator for amplification reaction. 
This function has several parameters which can be used to simulate the 
amplification curve. <code>b.eff</code> and <code>Cq</code> are most connected with 
another. Thus changing one of them will change both values. <code>Cq</code> can be 
used to define an approximate Cq value. The expression &quot;approximate Cq value&quot; is 
used here because the actual Cq value is dependent on the users preferred method 
(e.g., Cy0 method, Second Derivative Maximum (SDM) method, threshold method). 
<code>AmpSim</code> can be used to compare an experimental system to a 
predicted model. Moreover it can be used to simulate data with noise, missing 
values (NA), signal-to-noise ratios, photo-bleaching and other influences on a 
PCR reaction.
</p>


<h3>Value</h3>

<p>A <code>list</code> where one element represents the cycle (cyc) and one represents 
the fluorescence (fluo) of a simulated qPCR experiment.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Ritz, C., Spiess, A.-N.: qpcR: an R package for sigmoidal model
selection in quantitative real-time polymerase chain reaction analysis.
<em>Bioinformatics</em> 24(13), 1549&ndash;1551 (2008).
doi:10.1093/bioinformatics/btn227. PMID: 18482995. 
</p>
<p>See also <code><a href="qpcR.html#topic+qpcR.news">qpcR.news</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example one
# Simulate a qPCR reaction with AmpSim for 40 cycles.
# Use an in-silico dilution of the template be adjusting 
# the Cq parameter. A change of 3.32 cycles corresponds 
# approximately to a 10-fold dilution.
default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,1))
plot(NA, NA, xlim = c(1,40), ylim = c(0.01,2), xlab = "Cycles", 
     ylab = "Fluorescence", main = "In-silco Dilution Experiment")
cycle.dilution &lt;- seq(18, 35, 3.32)
for (i in 1:6) {
  lines(AmpSim(cyc = 1:40, b.eff = -25, bl = 0.01, ampl = 2, 
	      Cq = cycle.dilution[i]), type = "b", col = i, pch = 20)
}

# Example two
# Simulate a qPCR reaction with AmpSim for 40 cycles and some noise.
plot(NA, NA, xlim = c(1,40), ylim = c(0.01,2.2), xlab = "Cycles", 
     ylab = "Fluorescence", 
     main = "In-silco Dilution Experiment with Some Noise")
cycle.dilution &lt;- seq(18, 35, 3.32)
for (i in 1:6) {
  lines(AmpSim(cyc = 1:40, b.eff = -25, bl = 0.01, ampl = 2, 
	      Cq = cycle.dilution[i], noise = TRUE, nnl = 0.05), 
	      type = "b", col = i, pch = 20)
}
par(mfrow = c(1,1))

# Example three
# Apply constant, increasing, decreasing nose to 
# amplification data.

par(mfrow = c(3,1))
method &lt;- c("constant", "increase", "decrease")
for (j in 1:3){
    plot(NA, NA, xlim = c(1,40), ylim = c(0.02,2.2), xlab = "Cycles", 
	ylab = "Fluorescence", 
	main = paste("In-silco Dilution Experiment with noise method: ", 
					    method[j]))
    cycle.dilution &lt;- seq(18, 35, 3.32)
    for (i in 1:6) {
      lines(AmpSim(cyc = 1:40, b.eff = -25, bl = 0.02, ampl = 2, 
		   Cq = cycle.dilution[i], noise = TRUE, nnl = 0.08, 
		   nnl.method = method[j]), type = "b", col = i, pch = 20)
   }
}
par(default.par)
</code></pre>

<hr>
<h2 id='AmpSim.gui'>
Amplification Curve Simulation Graphical User Interface
</h2><span id='topic+AmpSim.gui'></span>

<h3>Description</h3>

<p>Launches graphical user interface that allows simulating and analyzing 
amplification reactions. This function will open the GUI in a webpage
of the default browser. All parameters of the <code><a href="#topic+AmpSim">AmpSim</a></code> 
function can be used. In addition to this, the GUI shows some information calculated
by the <code><a href="#topic+bg.max">bg.max</a></code> in a summary field and a plot
below the simulated amplification curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmpSim.gui()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Warning </h3>

<p>Any ad-blocking software may be cause of malfunctions. 
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AmpSim">AmpSim</a></code>, <code><a href="#topic+bg.max">bg.max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The code chunk below will fail if the web browser is not installed. if on UNIX platform try:
# as.vector(Sys.getenv("R_BROWSER"))
# Invoke the shiny AmpSim app in the default browser
## Not run: 
#do not execute using example(), it breaks the sequence of the plots in shiny app
AmpSim.gui()

## End(Not run)
</code></pre>

<hr>
<h2 id='amptest'>Class <code>"amptest"</code></h2><span id='topic+amptest'></span><span id='topic+amptest-class'></span><span id='topic+summary.amptest'></span><span id='topic+summary+2Camptest-method'></span><span id='topic+show.amptest'></span><span id='topic+show+2Camptest-method'></span><span id='topic+plot.amptest'></span><span id='topic+plot+2Camptest-method'></span><span id='topic+plot+2Camptest+2CANY-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+amptester">amptester</a></code> 
function.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+amptest-class">amptest</a></code> class containing result of the test as well as
the original data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"numeric"</code> is a vector containing the 
fluorescence values.</p>
</dd>
<dt><code>decisions</code>:</dt><dd><p><code>"logical"</code> contains outcomes of various tests.
<code>shap.noisy</code> is presence of noise, <code>lrt.test</code> states if data are 
likely from a amplification curve and both <code>tht.dec</code> and <code>tht.dec</code>
defines if the amplification is &quot;positive&quot; or &quot;negative&quot;.</p>
</dd>
<dt><code>noiselevel</code>:</dt><dd> <p><code>"numeric"</code> user-defined threshold for a 
significant amplification signal.</p>
</dd>
<dt><code>background</code>:</dt><dd><p>range of the background signal in the 
amplification curve.</p>
</dd>
<dt><code>polygon</code>:</dt><dd><p>The pco test determines if the points in an amplification curve 
(like a polygon) are in a &quot;clockwise&quot; order. The sum over the edges 
result in a positive value if the amplification curve is &quot;clockwise&quot; 
and is negative if the curve is counter-clockwise.</p>
</dd>
<dt><code>slope.ratio</code>:</dt><dd><p>ratio of the slopes at the start and the end of 
exponential phase..</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "amptest")</code>: prints summary 
of the object. Silently returns <code>vector</code> of all calculated parameters.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "amptest")</code>: prints only 
<code>.Data</code> slot of the object.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "amptest")</code>: plots input data and graphical
interpretation of <code>link{amptester}</code> tests' results.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amptester">amptester</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare a positive and a negative amplification reaction.
# First simulate positive reaction (fluo.pos) and than the 
# negative reaction (fluo.neg).
# Simulation of an amplifiaction curve with some noise and a high signal.

fluo.pos &lt;- AmpSim(cyc = 1:40, noise = TRUE)[, 2]
ampt.pos &lt;- amptester(fluo.pos, manual = TRUE, background = c(0, 15), 
		      noiselevel = 0.15)

# Plot amplification curve and result of amptester
plot(fluo.pos, xlab = "Cycles", ylab = "RFU", pch = 19, ylim = c(0, 1))
lines(ampt.pos, col = 2, pch = 19, type = "b")
legend(5, 1, c("Raw data", "amptester output"), 
       col = c(1,2,3), bty = "n", pch = c(19, 19))
# Borders for background calculation
abline(v = c(0,15), col = 2)
# Level for background threshold
abline(h = 0.15, col = 3, lty = 2)
text(5, 0.18, "Noise threshold")
# Summary of amptester results 
summary(ampt.pos)

# Simulation of an amplifiaction curve with high noise and a low signal.

fluo.neg &lt;- AmpSim(cyc = 1:40, noise = TRUE, ampl = 0.13, nnl = 0.4)[, 2]
ampt.neg &lt;- amptester(fluo.neg, manual = TRUE, background = c(0, 15), 
		      noiselevel = 0.15)

# Plot amplification curve and result of amptester
plot(fluo.neg, xlab = "Cycles", ylab = "RFU", pch = 19, ylim = c(0, 1))
lines(ampt.neg, col = 2, pch = 19, type = "b")
legend(5, 1, c("Raw data", "amptester output"), 
       col = c(1,2,3), bty = "n", pch = c(19, 19))
# Borders for background calculation
abline(v = c(0,15), col = 2)
# Level for background threshold
abline(h = 0.15, col = 3, lty = 2)
text(5, 0.18, "Noise threshold")
# Summary of amptester results
summary(ampt.neg)
#plot amptester results
plot(ampt.neg)
</code></pre>

<hr>
<h2 id='amptester'>
Amplification test
</h2><span id='topic+amptester'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+amptester">amptester</a></code> function tests if an amplification is significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amptester(y, manual = FALSE, noiselevel = 0.08, background = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amptester_+3A_y">y</code></td>
<td>

<p>is a vector containing the fluorescence values.
</p>
</td></tr>
<tr><td><code id="amptester_+3A_manual">manual</code></td>
<td>

<p>switches between a statistical test (based on a Wilcoxon rank sum 
test (<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>)) or manual test for a positive 
amplification signal.
</p>
</td></tr>
<tr><td><code id="amptester_+3A_noiselevel">noiselevel</code></td>
<td>

<p>can be set to a user defined value as threshold for a significant 
amplification signal.
</p>
</td></tr>
<tr><td><code id="amptester_+3A_background">background</code></td>
<td>

<p>is the range of the background signal in the amplification curve. 
The values can be added by the user or taken from the 
<code><a href="#topic+bg.max">bg.max</a></code> function. Ignored if <code>manual</code> is
<code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to estimate if data indicates an amplification process. 
Several instances of tests are included. The first involves a 
semiautomatic test if the range of the background is lower than the range 
of the assumed signal. To differ between the ranges an instance of 
<code><a href="#topic+bg.max">bg.max</a></code> is used. Herein, this function assumes that an 
amplification takes place in case the signal of the amplification is larger 
than the <code><a href="stats.html#topic+median">median</a></code> + 5 * <code><a href="stats.html#topic+mad">mad</a></code> than 
the background. The automatic test uses a Wilcoxon rank sum test 
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> to compare the first and the last elements 
of the data. The input values are delivered by <code><a href="utils.html#topic+head">head</a></code> 
and <code><a href="utils.html#topic+tail">tail</a></code>, respectively. For other methods please refer 
to the references listed below. Instead of assigning a zero to negative 
amplification reaction uses the current implementation of 
<code><a href="#topic+amptester">amptester</a></code> very small random values. This is because 
some post function might fail in case all values are set to zero.
</p>
<p># FIRST TEST - Shapiro test (SHt)
</p>
<p>This is a simple test based on the hypothesis that in case 
amplification curve data come from noise is the distribution similar to a normal 
distribution. The Shapiro's normality test is used to test this hypothesis. If 
p is &gt;= 5e-04, then the distribution of the curve data indicates noise (no 
amplification).
</p>
<p># SECOND TEST - Resids growth test (RGt)
</p>
<p>This tests if fluorescence values in a linear phase are stable. Whenever no amplification 
occurs, fluorescence values quickly deviate from linear model. Their standardized
residuals will be strongly correlated with their value. For real amplification curves,
situation is much more stable. Noise (that means deviations from linear model) 
in  background do not correlate strongly with the changes in fluorescence. 
The decision is based on the threshold value (here 0.5).
</p>
<p># THIRD TEST - Linear Regression test (LRt)
</p>
<p>This test determines the R^2 by a linear regression. The R^2 are determined from 
a run of circa 15 percent range of the data. If a sequence of more than six R^2s 
is larger than 0.8 is found that is likely a nonlinear signal. This is a bit 
counterintuitive because R^2 of nonlinear data should be low.
</p>
<p># FOURTH TEST (MANUAL) - Threshold test (THt)
</p>
<p>This a commonly employed method. In the manual test one needs to define a 
fixed threshold. If the amplification curve signal exceeds the threshold than the 
amplification reaction is positive. Waring: This method will report positive 
amplification reaction if a negative amplification has a positive trend.
</p>
<p># FOURTH TEST (AUTOMATIC) - Threshold test (THt)
</p>
<p>Takes the first 20 percent and the last 15 percent of any input data set 
(amplification curve) and perform a Wilcoxon rank sum tests with the head (nh) 
and tail (nt). This test is recommended over the manual THt. Warning: This 
method may report positive amplification reaction if a negative amplification 
has a positive trend.
</p>
<p># FIFTH TEST - Signal level test (SLt)
</p>
<p>The meaningfulness of an amplification curve reaction can be tested by 
comparison of the signals 1) A robust &quot;sigma&quot; rule by median + 2 * mad 2) 
comparison of the signal/noise ratio. If less than 1.25 (25 percent) signal 
increase it is likely that nothing happened during the reaction. Waring: This 
method may report positive amplification reaction if a negative amplification 
has a positive trend.
</p>
<p># SIXTH TEST - pco test (pco)
</p>
<p>This test determines if the points in an amplification curve (like a polygon, in 
particular non-convex polygons) are in a &quot;clockwise&quot; order. The sum over the 
edges result in a positive value if the amplification curve is &quot;clockwise&quot; and 
is negative if the curve is counter-clockwise ((x2 - x1)(y2 + y1)). From 
experience is noise positive and &quot;true&quot; amplification curves &quot;highly&quot; negative. 
This test depends on the definition of a threshold.
</p>
<p># SEVENTH TEST - Slope ratio (SlR)
</p>
<p>Uses the inder function to find the approximated first derivative maximum, 
second derivative minimum and the second derivative maximum. Next the raw 
fluorescence at the approximated second derivative minimum and the second 
derivative maximum are taken from the original data set. The fluorescence 
intensities are normalized to the maximum fluorescence of this data. This data 
is used for a linear regression. Where the slope is used.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+amptest-class">amptest</a></code> class containing result of the test as well as
the original data.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Frank, D. N. BARCRAWL and BARTAB: software tools for the design and 
implementation of barcoded primers for highly multiplexed DNA sequencing 
<em>BMC bioinformatics</em>, 2009, Vol. 10, pp. 362
</p>
<p>Peirson, S. N., Butler, J. N. and Foster, R. G. Experimental validation of 
novel and conventional approaches to quantitative real-time PCR data analysis 
<em>Nucleic Acids Research</em>, 2003, Vol. 31(14), pp. e73-e73
</p>
<p>Rao, X., Lai, D. and Huang, X. A New Method for Quantitative Real-Time 
Polymerase Chain Reaction Data Analysis <em>Journal of Computational 
Biology</em>, 2013, Vol. 20(9), pp. 703-711
</p>
<p>Ruijter, J. M., Ramakers, C., Hoogaars, W. M. H., Karlen, Y., Bakker, O., 
Hoff, M. J. B. v. d. and Moorman, A. F. M. Amplification efficiency: 
linking baseline and bias in the analysis of quantitative PCR data, 
<em>Nucleic Acids Research</em>, 2009, Vol. 37(6), pp. e45-e45
</p>
<p>Rutledge, R. G. and Stewart, D. A kinetic-based sigmoidal model for the 
polymerase chain reaction and its application to high-capacity absolute 
quantitative real-time PCR <em>BMC biotechnology</em>, 2008, Vol. 8, pp. 47
</p>
<p>Tichopad, A., Dilger, M., Schwarz, G. and Pfaffl, M. W. Standardized 
determination of real-time PCR efficiency from a single reaction set-up 
<em>Nucleic Acids Research</em>, 2003, Vol. 31(20), pp. e122
</p>
<p>Wilhelm, J., Pingoud, A. and Hahn, M. SoFAR: software for fully automatic 
evaluation of real-time PCR data <em>BioTechniques</em>, 2003, Vol. 34(2), 
pp. 324-332
</p>
<p>Zhao, S. and Fernald, R. D. Comprehensive Algorithm for Quantitative 
Real-Time Polymerase Chain Reaction <em>Journal of computational biology: 
a journal of computational molecular cell biology</em>, 2005, Vol. 12(8), pp. 
1047-1064
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
# Arrange graphs in orthogonal matrix and set parameter for the plot.
default.par &lt;- par(no.readonly = TRUE)
par(las = 0, bty = "n", cex.axis = 1.5, cex.lab = 1.5, 
    font = 2, cex.main = 1.8, oma = c(1,1,1,1))
    
# Simulation of an amplification curve with 40 cycles and a Cq of
# circa 28. The amplification curve of "pos" (positive) has low 
# noise and the amplification curve of "neg" (negative) has high 
# noise.

pos &lt;- AmpSim(cyc = 1:40, Cq = 28, noise = TRUE, nnl = 0.03)
neg &lt;- AmpSim(cyc = 1:40, Cq = 28, noise = TRUE, nnl = 0.8)

# Plot the raw data of the simulations.

par(fig = c(0,0.5,0.5,1))
plot(NA, NA, xlim = c(1, 40), ylim = c(0, 2.1), xlab = "Cycles", 
     ylab = "Fluorescence", main = "qPCR - Raw data", type = "b")
mtext("A", cex = 2, side = 3, adj = 0, font = 2)
points(pos, col = 1, typ = "b", pch = 19)
points(neg, col = 2, typ = "b", pch = 20)
legend(1, 2, c("Positive", "Negative Control (noise)"), 
	       pch = c(19,20), col = c(1,2), lwd = 2, bty = "n")

# Plot data again after an analysis by ampteser. "neg" is set to small 
# random numbers, while "pos" remains unchanged.

par(fig = c(0,0.5,0,0.5), new = TRUE)
plot(NA, NA, xlim = c(1, 40), ylim = c(0, 2.1), xlab = "Cycles", 
     ylab = "Fluorescence", main = "qPCR - amptester", type = "b")
points(amptester(pos[, 2]), col = 1, type = "b", pch = 19)
points(amptester(neg[, 2]), col = 2, type = "b", pch = 20)
legend(1, 2, c("Positive", "Negative Control (noise)"), 
       pch = c(19,20), col = c(1,2), lwd = 2, bty = "n")

# Use of amptester for time-dependent measurements. Amplification curves 
# from the capillaryPCR data set were processed in a loop. The results of 
# amptester are added to the raw data.

par(fig = c(0.5,1,0,1), new = TRUE)
colors &lt;- rainbow(8)
plot(NA, NA, xlim = c(0,80), ylim = c(0,1300), xlab = "Time [min]", 
     ylab = "Voltage (micro V)", main = "ccPCR")
mtext("B", cex = 2, side = 3, adj = 0, font = 2)
sapply(c(1,3,5,7), function(i) {
    xy.tmp &lt;- cbind(capillaryPCR[1:750, i], capillaryPCR[1:750, i + 1])
    
# Use amptester to analyse the amplification curve.
# Note: The decisions of amptester can be invoked via res.ampt@decisions
# in the present example.

    res.ampt &lt;- amptester(xy.tmp[, 2])
    
# Use the "decisions" of amptester in a logic to automatically decide if an
# amplification reaction is positive. In this example linear regression test
# (lrt.test) and the threshold test (tht.dec) are used.

    res.ampt &lt;- ifelse(res.ampt@decisions[2] == TRUE &amp;&amp; 
		       res.ampt@decisions[4] == TRUE, "positve", "negative")

# Plot the amplification curve with the decisions.
    lines(xy.tmp[, 1], xy.tmp[, 2], type = "b", pch = 20, col = colors[i])
    text(75, max(na.omit(xy.tmp[, 2])), res.ampt, cex = 1.3, col = colors[i])
  }
)
# Second Example
# Example to test an amplification reaction.
# Simulate first a positive amplification curve with 45 cycles and than a 
# negative amplification curve with 45 cycles. The negative amplification
# curve is created from a normal distribution
# 
fluo.neg &lt;- rnorm(45)
fluo.pos &lt;- AmpSim(cyc = 1:45, Cq = 45, ampl = 40, noise = TRUE, 
		   nnl = 0.03)[, 2]

plot(NA, NA, xlim = c(1, 45), ylim = c(-1, 45), xlab = "Cycles", 
     ylab = "Fluorescence", 
     main = "Simulation of a qPCR with 45 Cycles", type = "b")
points(amptester(fluo.pos), type = "b", pch = 20)
points(amptester(fluo.neg), type = "b", col = "red", pch = 20)
points(1:45, fluo.neg, col = "red")

legend(1,40, c("Positive", "Negative Control (noise)", 
       "noise pattern"), pch = c(20,20,1), col = c(1,2,2), lwd = 2)
par(default.par)
</code></pre>

<hr>
<h2 id='amptester.gui'>
Amplification Test Graphical User Interface
</h2><span id='topic+amptester.gui'></span>

<h3>Description</h3>

<p><code><a href="#topic+amptester.gui">amptester.gui</a></code> is a graphical user interface for the 
<code><a href="#topic+amptester">amptester</a></code> function. This function can be used for a 
fast and convenient analysis of amplification curve data. In addition it is 
possible to analyze the Cq (quantification cycle) and to perform a report 
generation of the analyzed data. </p>


<h3>Usage</h3>

<pre><code class='language-R'>amptester.gui()
</code></pre>


<h3>Value</h3>

<p>An object of <code><a href="#topic+amptest-class">amptest</a></code> class containing result of the test as 
well as the original data.
</p>


<h3>Warning </h3>

<p>Any ad-blocking software may be cause of malfunctions. 
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AmpSim">AmpSim</a></code>, <code><a href="#topic+bg.max">bg.max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The code chunk below will fail if the web browser is not installed. if on UNIX platform try:
# as.vector(Sys.getenv("R_BROWSER"))
# Invoke the shiny AmpSim app in the default browser
## Not run: 
#do not execute using example(), it breaks the sequence of the plots in shiny app
amptester.gui()

## End(Not run)
</code></pre>

<hr>
<h2 id='bg'>Class <code>"bg"</code></h2><span id='topic+bg-class'></span><span id='topic+bg'></span><span id='topic+show.bg'></span><span id='topic+show+2Cbg-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+bg.max">bg.max</a></code> function.
</p>


<h3>Value</h3>

<p>An object containing result of the <code><a href="#topic+bg.max">bg.max</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"matrix"</code> which columns represent respectively cycle number, 
raw fluorescence data, first derivative and second derivative.</p>
</dd>
<dt><code>bg.start</code>:</dt><dd> <p><code>"numeric"</code> value representing start of the background range.</p>
</dd>
<dt><code>bg.stop</code>:</dt><dd> <p><code>"numeric"</code> value representing end of the background range.</p>
</dd>
<dt><code>bg.corr</code>:</dt><dd> <p><code>"numeric"</code> a value which helps to tweak on the suggested
background value of <code>bg.max</code>.</p>
</dd>
<dt><code>fluo</code>:</dt><dd> <p><code>"numeric"</code> a value of fluorescence at the end of amplification.</p>
</dd>
<dt><code>amp.stop</code>:</dt><dd> <p><code>"numeric"</code> value representing end of the amplification
.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "bg")</code>: plots background information. 
See <code><a href="#topic+plot.bg">plot.bg</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "bg")</code>: prints only <code>.Data</code> slot of the
object.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "bg")</code>: prints information about object 
prettier than <code>show</code> and allows easy access to some slots. See 
<code><a href="#topic+summary.bg">summary.bg</a></code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bg.max">bg.max</a></code>, <code><a href="#topic+plot.bg">plot.bg</a></code>, 
<code><a href="#topic+summary.bg">summary.bg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- AmpSim(cyc = 1:40, Cq = 25)
tmp &lt;- bg.max(res)
summary(tmp)
plot(tmp)
</code></pre>

<hr>
<h2 id='bg.max'>
Simple function to detect and correct the background range
</h2><span id='topic+bg.max'></span><span id='topic+bg.max.numeric'></span><span id='topic+bg.max.matrix'></span><span id='topic+bg.max.data.frame'></span><span id='topic+bg.max+2Cnumeric+2Cnumeric-method'></span><span id='topic+bg.max+2Cmatrix+2Cmissing-method'></span><span id='topic+bg.max+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+bg.max">bg.max</a></code> detects and corrects background noise. 
The detection is made without any assumptions 
regarding the model of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
bg.max(x, y, bg.corr = 1.3, bg.start = 2, 
		  inder.approx = TRUE)

## S4 method for signature 'matrix,missing'
bg.max(x, y, bg.corr = 1.3, bg.start = 2, 
		  inder.approx = TRUE)

## S4 method for signature 'data.frame,missing'
bg.max(x, y, bg.corr = 1.3, bg.start = 2, 
		  inder.approx = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bg.max_+3A_x">x</code></td>
<td>

<p>is a vector containing the time or cycle values or data frame/matrix 
containing cycle in the first column and fluorescence values in the second 
column. 
</p>
</td></tr>
<tr><td><code id="bg.max_+3A_y">y</code></td>
<td>

<p>is a vector containing the fluorescence values. Used only if <code>x</code> 
is also a vector. 
</p>
</td></tr>
<tr><td><code id="bg.max_+3A_bg.corr">bg.corr</code></td>
<td>

<p>a value which helps to tweak on the suggested background value of 
<code><a href="#topic+bg.max">bg.max</a></code>.
</p>
</td></tr>
<tr><td><code id="bg.max_+3A_bg.start">bg.start</code></td>
<td>

<p>a user defined value for the start of the background range.
</p>
</td></tr>
<tr><td><code id="bg.max_+3A_inder.approx">inder.approx</code></td>
<td>

<p>a <code>logical</code> value defining if data should be numerically derived 
by <code><a href="#topic+inder">inder</a></code> function. If <code>FALSE</code>, derivatives are calculated by the
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Background range herein refers to a level of fluorescence measured before 
any specific amplification is detectable. The raw data (e.g., fluorescence 
intensity) measured after each step (cycle or time point) follow a 
non-linear progress. The background is assumed to be constant for the 
entire measurement. The algorithm of <code><a href="#topic+bg.max">bg.max</a></code> is based 
on the assumption that during the linear ground phase the signal difference 
of successive cycles is approximately constant. After transition to the 
early exponential phase the signal changes drastically. First data are 
smoothed by Friedman's 'super smoother' (as found in 
<code><a href="stats.html#topic+supsmu">supsmu</a></code>. Thereof the approximate first and second 
derivative are calculated by a five-point stencil 
<code><a href="#topic+inder">inder</a></code>. 
</p>
<p>The difference of cycles at the maxima of the first and second approximate 
derivative as well as a correction factor are used to estimate the range before 
the exponential phase. This function finds the background range 
without modeling the relationship between signal and cycle number. The start of 
the background range is defined be a fixed value. Since many signals tend to 
overshot in the first cycles a default value of 3 is chosen. 
<code><a href="#topic+bg.max">bg.max</a></code> tries also to estimate the end of an amplification 
reaction.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+bg-class">bg</a></code> class containing predicted background range 
as well as other parameters.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>D. N. Frank. BARCRAWL and BARTAB: software tools for the design and 
implementation of barcoded primers for highly multiplexed DNA sequencing. 
<em>BMC Bioinformatics</em>, 10:362, 2009. ISSN 1471-2105. doi: 
10.1186/1471-2105-10-362. PMID: 19874596 PMCID: PMC2777893.
</p>
<p>S. N. Peirson, J. N. Butler, and R. G. Foster. Experimental validation of 
novel and conventional approaches to quantitative real-time PCR data 
analysis. <em>Nucleic Acids Research</em>, 31(14):e73, July 2003. ISSN 
1362-4962. PMID: 12853650 PMCID: PMC167648.
</p>
<p>X. Rao, D. Lai, and X. Huang. A new method for quantitative real-time 
polymerase chain reaction data analysis. <em>Journal of computational 
biology: a journal of computational molecular cell biology</em>, 
20(9):703&ndash;711, Sept. 2013. ISSN 1557-8666. doi: 10.1089/cmb.2012.0279. 
PMID: 23841653 PMCID: PMC3762066.
</p>
<p>A. Tichopad, M. Dilger, G. Schwarz, and M. W. Pfaffl. Standardized 
determination of real-time PCR efficiency from a single reaction set-up. 
<em>Nucleic Acids Research</em>, 31(20):e122, Oct. 2003. ISSN 1362-4962. 
PMID: 14530455 PMCID: PMC219490.
</p>
<p>J. Wilhelm, A. Pingoud, and M. Hahn. Real-time PCR-based method for the 
estimation of genome sizes. <em>Nucleic Acids Research</em>, 31(10):e56, May 
2003. ISSN 0305-1048. PMID: 12736322 PMCID: PMC156059.
</p>
<p>S. Zhao and R. D. Fernald. Comprehensive algorithm for quantitative 
real-time polymerase chain reaction. <em>Journal of computational 
biology: a journal of computational molecular cell biology</em>, 12(8): 
1047&ndash;1064, Oct. 2005. ISSN 1066-5277. doi:10.1089/cmb.2005.12.1047. PMID: 16241897 PMCID: PMC2716216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: Test for the background of an amplification reaction.
default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,1))
res &lt;- AmpSim(cyc = 1:40, Cq = 25)
background &lt;- bg.max(res)
plot(background, main = "Estimation of the Background Range\n
in Absence of Noise")
res.noise &lt;- AmpSim(cyc = 1:40, Cq = 25, noise = TRUE)
background.noise &lt;- bg.max(res.noise)
plot(background.noise, main = "Estimation of the Background Range\n
in Presence of Noise")
par(mfrow = c(1,1))


# Second example: A simple function to test for a background range.
# Data were taken form the chipPCR C17 data set.
# Note that the not the time but the "cycle number" was
# used to calculate the background range.
data(C17)
plot(C17[, 2], C17[,  3], xlab = "Cycle", ylab = "RFU", 
     main = "Estimate the begin of the Amplification\n of a HDA", 
     pch = 20)
res &lt;- bg.max(C17[, 2:3], bg.corr = 1.4, bg.start = 1)
abline(v = c(slot(res, "bg.start"), slot(res, "bg.stop")), 
       col = c(1,2))
abline(h = slot(res, "fluo"), col = "blue")

# Third example: Test for the background of an amplification reaction.
# Simulate amplification curves with different quantification points
# within 40 cycles.
cyc &lt;- seq(1, 40, 1)

# Use a five parameter model to simulate amplification curves
b &lt;- -15; c &lt;- 0.02; d &lt;- 1
# Define the different quantification points with a difference of
# circa 3.32 cycles
e &lt;- seq(21, 35, 3.32)

# Plot the amplification curves and the estimated background ranges.
plot(NA, NA, xlim = c(1, 40), ylim = c(0, 1), xlab = "Cycles", 
     ylab = "Fluorescence")
     
for (i in 1:length(e)) {
  fluo &lt;- c + (d - c)/(1 + exp(b * (log(cyc) - log(e[i]))))
  points(cyc, fluo, type = "b", col = i, pch = 20)
  res &lt;- bg.max(cyc, fluo, bg.corr = 1.4, bg.start = 1)
  abline(v = slot(res, "bg.stop"), col = i)
  abline(h = slot(res, "fluo"), col = i)
}
par(default.par)
</code></pre>

<hr>
<h2 id='C126EG595'>
qPCR Experiment for the Amplification of HPRT1 Using the Bio-Rad iQ5 thermo cycler
</h2><span id='topic+C126EG595'></span>

<h3>Description</h3>

<p>A quantitative PCR (qPCR) with the DNA binding dye (EvaGreen) (Mao et al. 2007) 
was performed in a Bio-Rad iQ5 thermo cycler. The cycle-dependent increase 
of the fluorescence was quantified at the annealing step (59.5 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C126EG595)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycle&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>HPRT1 was amplified in the Bio-Rad iQ5. The the change of 
fluorescence was simultaneously monitored for the Hydrolysis probe of HPRT1 
and EvaGreen. The primer sequences for HPRT1 were taken from Roediger et al. 
(2013). A 10 micro L qPCR reaction was composed of 250 nM primer (forward and 
reverse), qPCR Mix (according to the manufactures recommendations), 1 micro L 
template  (HPRT1 amplification product), 60 nM hydrolysis probe probe for 
HPRT1. EvaGreen was used at 0.5 x final. During the amplification was monitored 
59.5 degrees Celsius.
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C126EG595)
tmp  &lt;- C126EG595

plot(NA,NA, xlim = c(1,40), ylim = c(min(tmp[, 2:ncol(tmp)]), 
   max(tmp[, 2:ncol(tmp)])), xlab = "Cycle", ylab = "RFU (FAM)", 
   main = "Amplification monitored at \n58.5 degrees Celsius (annealing step)")
apply(tmp[, 2:ncol(tmp)], 2, 
      function(x) lines(tmp[1:nrow(tmp),1],x))
</code></pre>

<hr>
<h2 id='C126EG685'>
qPCR Experiment for the Amplification of HPRT1 Using the Roche Light Cycler 
1.5
</h2><span id='topic+C126EG685'></span>

<h3>Description</h3>

<p>A quantitative PCR (qPCR) with the DNA binding dye (EvaGreen) (Mao et al. 
2007) was performed in the Roche Light Cycler 1.5 thermo cycler. The 
cycle-dependent increase of the fluorescence was quantified at the 
elongation step (68.5 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C126EG685)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The 
first 
column (&quot;Cycles&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>MLC-2v was amplified in the Roche Light Cycler 1.5. The the change of 
fluorescence was simultaneously monitored for the Hydrolysis probe of 
MLC-2v and EvaGreen. The primer sequences for MLC-2v were taken from 
Roediger et al. (2013). A 10 micro L qPCR reaction was composed of 250 nM 
primer (forward and reverse), qPCR Mix (according to the manufactures 
recommendations), 1 micro L template  (MLC-2v amplification product), 60 nM 
hydrolysis probe probe for MLC-2v. EvaGreen was used at 0.5 x final. The 
amplification was monitored at 68.5 degrees Celsius (elongation step).
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, 
Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the 
Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. 
Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C126EG685)
tmp &lt;- C126EG685

plot(NA,NA, xlim = c(1,40), ylim = c(min(tmp[, 2:ncol(tmp)]), 
    max(tmp[, 2:ncol(tmp)])), xlab = "Cycle", 
    ylab = "RFU (FAM)", 
    main = "Amplification monitored at \n68.5 degrees Celsius (elongation 
step)")

apply(tmp[, 2:ncol(tmp)], 2, 
      function(x) lines(tmp[1:nrow(tmp),1],x))
      
</code></pre>

<hr>
<h2 id='C127EGHP'>
qPCR Experiment for the Amplification of MLC-2v Using the Roche Light Cycler 
1.5
</h2><span id='topic+C127EGHP'></span>

<h3>Description</h3>

<p>Quantitative PCR (qPCR) with a hydrolysis probe (Cy5/BHQ2) and DNA binding dye 
(EvaGreen) (Mao et al. 2007) was performed in the Roche Light Cycler 1.5 
thermo cycler. The cycle-dependent increase of the fluorescence was 
quantified at the annealing step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C127EGHP)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 66 variables. The first columns
(&quot;index&quot;) contains index of a sample and second column (&quot;Cycle&quot;) contains the number 
of cycle. Consecutive columns EG1-EG32 contains fluorescence data for Eva Green dye.
Consecutive columns HP1-HP32 contains data for hydrolysis probe.
</p>


<h3>Details</h3>

<p>MLC-2v was amplified in the Roche Light Cycler 1.5. The the change of 
fluorescence was simultaneously monitored for the Hydrolysis probe of MLC-2v 
and EvaGreen. The primer sequences for MLC-2v were taken from Roediger et al. 
(2013). A 10 micro L qPCR reaction was composed of 250 nM primer (forward and 
reverse), qPCR Mix (according to the manufactures recommendations), 1 micro L 
template  (MLC-2v amplification product), 60 nM hydrolysis probe probe for 
MLC-2v. EvaGreen was used at 0.5 x final. During the amplification was 
monitored 59.5 degrees Celsius.
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol.</em> 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(C127EGHP)
data(C127EGHP)
tmp &lt;- C127EGHP

default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,1))
plot(NA, NA, xlim = c(1,40), ylim = c(0,10), xlab = "Cycle", 
      ylab = "Fluorescence", main = "MLC-2v qPCR - EvaGreen")
  for (i in 3:34) {
    points(tmp[, 2], tmp[, i], type = "l", col = i)
  }

plot(NA, NA, xlim = c(1,40), ylim = c(0,10), xlab = "Cycle", 
      ylab = "Fluorescence", main = "MLC-2v qPCR - Hydrolysis probe")
  for (i in 35:66) {
    points(tmp[, 2], tmp[, i], type = "l", col = i)
  }
par(default.par)
</code></pre>

<hr>
<h2 id='C17'>
Helicase Dependent Amplification of HPRT1 at Different Temperatures using the 
'VideoScan' Platform 2.0
</h2><span id='topic+C17'></span>

<h3>Description</h3>

<p>A Helicase Dependent Amplification (HDA) of HPRT1 (Homo sapiens 
hypoxanthine phosphoribosyltransferase 1) was performed at different 
temperatures in the 'VideoScan' Platform 2.0 (similar to Roediger et al. 
(2013)). The HDA was performed at 55, 60 and 65 degrees Celsius. The optimal 
temperature for a HDA is circa 65 degrees Celsius. Lower temperatures will 
affect the slope and plateau of the HDA amplification curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C17)</code></pre>


<h3>Format</h3>

<p>A data frame with 125 observations on the following 5 variables.
</p>

<dl>
<dt><code>C17.t</code></dt><dd><p>Elapsed time during HDA in seconds.</p>
</dd>
<dt><code>C17.cycle</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C17.T55</code></dt><dd><p>Time-dependent fluorescence at 55 degrees Celsius</p>
</dd>
<dt><code>C17.T60</code></dt><dd><p>Time-dependent fluorescence at 60 degrees Celsius</p>
</dd>
<dt><code>C17.T65</code></dt><dd><p>Time-dependent fluorescence at 65 degrees Celsius</p>
</dd>
</dl>



<h3>Details</h3>

<p>To perform an isothermal amplification in 'VideoScan' 2.0, standard 
conditions for the IsoAmp(R) III Universal tHDA Kit (Biohelix) were used. 
The reaction was composed of 12.5 micro L buffer A containing 1.25 micro L 
10x reaction buffer, 150 nM primer (forward and reverse), 0.75  micro L 
template (synthetic) and A. bidest which was covered with 50 micro L 
mineral oil. The primer sequences for HPRT1 were taken from Roediger et al. 
(2013). Preincubation: This mixture was incubated for 2 min at 95 degree. 
Celsius and immediately placed on ice. 12.5 micro L of reaction buffer B 
which was composed of 1.25 micro L 10x buffer, 40 mM NaCl, 5 mM MgSO4, 1.75 
micro L dNTPs, 0.2 x EvaGreen, 1 micro L Enzyme mix and A. bidest. The 
fluorescence measurement in 'VideoScan' 'HCU' started directly after adding 
buffer B at 55, 60 or 65 degrees Celsius and revealed optimal conditions for 
the amplification when using 60 or 65 degrees Celsius.
Temperature profile (after Preincubation):
- 60 seconds at 65 degrees Celsius 
- 11 seconds at 55 degrees Celsius &amp;&amp; Measurement
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, 
Senftenberg, Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C17)
plot(NA, NA, xlim = c(0,5000), ylim = c(0,1.2), xlab = "Time [sec]", 
     ylab = "Fluorescence", 
     main = "Temperature dependency of HDA amplification reactions")
  points(C17[, 1], C17[, 3], type = "b", col = 1, pch = 20)
  points(C17[, 1], C17[, 4], type = "b", col = 2, pch = 20)
  points(C17[, 1], C17[, 5], type = "b", col = 3, pch = 20)
legend(2000, 0.4, c("55 degrees Celsius", "60 degrees Celsius", 
       "65 degrees Celsius"), 
	col = c(1,2,3), pch = rep(20,3))
</code></pre>

<hr>
<h2 id='C316.amp'>
qPCR Experiment for the Amplification of adk Using the Bio-Rad iQ5 thermo cycler
</h2><span id='topic+C316.amp'></span>

<h3>Description</h3>

<p>A quantitative real-time PCR of adk was performed.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C316.amp")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycle&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad iQ5. The change of fluorescence was 
simultaneously monitored (EvaGreen, Mao et al. 2007). The 
primer sequences for adk were taken from this study.
</p>
<p>gDNA: 28.43 ng/microL DNA concentration, 260/280 ratio= 1.96
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions:
10 minutes at 95 degrees Celsius
40 x 
30 seconds at 95 degrees Celsius
45 seconds at 59 degrees Celsius
45 seconds at 68 degrees Celsius

</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C316.amp)
str(C316.amp)
</code></pre>

<hr>
<h2 id='C316.melt.hr'>
Melting Curves (resolution: 0.2 degrees Celsius / step) for the Gene adk Using 
the Bio-Rad iQ5 thermo cycler
</h2><span id='topic+C316.melt.hr'></span>

<h3>Description</h3>

<p>A melting curve for adk was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C316.melt.hr")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;T&quot;) contains the temperature (resolution: 0.2 degrees Celsius / step) 
and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad iQ5. After PCR, the temperature-dependent 
change of fluorescence was simultaneously monitored (EvaGreen, Mao et al. 2007). 
The primer sequences for adk were taken from this study.
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions: <code><a href="#topic+C316.amp">C316.amp</a></code>
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C316.melt.hr)
str(C316.melt.hr)
</code></pre>

<hr>
<h2 id='C316.melt.lr'>
Melting Curves (resolution: 0.5 degrees Celsius / step) for the Gene adk Using the Bio-Rad iQ5 thermo cycler
</h2><span id='topic+C316.melt.lr'></span>

<h3>Description</h3>

<p>A melting curve for adk was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C316.melt.lr")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;T&quot;) contains the temperature (resolution: 0.5 degrees Celsius / step) and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad iQ5. After PCR, the temperature-dependent 
change of fluorescence was simultaneously monitored (EvaGreen, Mao et al. 2007). 
The primer sequences for adk were taken from this study.
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions: <code><a href="#topic+C316.amp">C316.amp</a></code>
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C316.melt.lr)
str(C316.melt.lr)
</code></pre>

<hr>
<h2 id='C317.amp'>
qPCR Experiment for the Amplification of adk Using the Bio-Rad CFX96 thermo cycler
</h2><span id='topic+C317.amp'></span>

<h3>Description</h3>

<p>A quantitative real-time PCR of adk was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C317.amp")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycle&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad CFX96. The change of fluorescence was 
simultaneously monitored (EvaGreen, Mao et al. 2007). The 
primer sequences for adk were taken from this study.
</p>
<p>gDNA: 28.43 ng/microL DNA concentration, 260/280 ratio= 1.96
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions:
10 minutes at 95 degrees Celsius
40 x 
30 seconds at 95 degrees Celsius
45 seconds at 59 degrees Celsius
45 seconds at 68 degrees Celsius

</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(C317.amp)
  str(C317.amp)
  </code></pre>

<hr>
<h2 id='C317.melt.hr'>
Melting Curves (resolution: 0.1 degrees Celsius / step) for the Gene adk Using 
the Bio-Rad CFX96 thermo cycler
</h2><span id='topic+C317.melt.hr'></span>

<h3>Description</h3>

<p>A melting curve for adk was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C317.melt.hr")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Temperature&quot;) contains the temperature (resolution: 0.1 degrees Celsius / step) 
and consecutive columns 
contain the replicates (&quot;A1&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad CFX96. After PCR, the temperature-dependent 
change of fluorescence was simultaneously monitored (EvaGreen, Mao et al. 2007). 
The primer sequences for adk were taken from this study.
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions: <code><a href="#topic+C317.amp">C317.amp</a></code>
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(C317.melt.hr)
  str(C317.melt.hr)
  </code></pre>

<hr>
<h2 id='C317.melt.lr'>
Melting Curves (resolution: 0.5 degrees Celsius / step) for the Gene adk Using the Bio-Rad CFX96 thermo cycler
</h2><span id='topic+C317.melt.lr'></span>

<h3>Description</h3>

<p>A melting curve for adk was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("C317.melt.lr")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Temperature&quot;) contains the temperature (resolution: 0.5 degrees Celsius / step) and consecutive columns 
contain the replicates (&quot;A1&quot; to &quot;H12&quot;).
</p>


<h3>Details</h3>

<p>adk was amplified in the Bio-Rad CFX96. After PCR, the temperature-dependent 
change of fluorescence was simultaneously monitored (EvaGreen, Mao et al. 2007). 
The primer sequences for adk were taken from this study.
</p>
<p>adk fw: CTCAGGCTCAGTTCATCATGGA 
adk rv: AGTTTGCCAGCATCCATAATGTC
</p>
<p>PCR conditions: <code><a href="#topic+C317.amp">C317.amp</a></code>
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann, Claudia Zelck (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(C317.melt.lr)
  str(C317.melt.lr)
  </code></pre>

<hr>
<h2 id='C54'>
qPCR Experiment for the amplification of MLC-2v using the 'VideoScan' 
heating/cooling-unit
</h2><span id='topic+C54'></span>

<h3>Description</h3>

<p>qPCR Experiment for the amplification of MLC-2v using the 'VideoScan' 
heating/cooling-unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C54)</code></pre>


<h3>Format</h3>

<p>A data frame with 56 observations on the following 4 variables.
</p>

<dl>
<dt><code>Cycle</code></dt><dd><p>Cycle number</p>
</dd>
<dt><code>D1</code></dt><dd><p>Stock concentration of input cDNA</p>
</dd>
<dt><code>D2</code></dt><dd><p>1/10 diluted stock cDNA</p>
</dd>
<dt><code>D3</code></dt><dd><p>1/100 diluted stock cDNA</p>
</dd>
</dl>



<h3>Details</h3>

<p>The aim was to amplify MLC-2v in the 'VideoScan' and to monitor with a 
hydrolysis probe for MLC-2v. The primer sequences for MLC-2v were taken 
from Roediger et al. (2013). The amplification was detected in solution of 
the '1 HCU' (see Roediger et al. 2013 for details). A 20 micro L PCR reaction 
was composed of 250 nM primer (forward and reverse), 1x Maxima Probe qPCR 
Master Mix (Fermentas), 1 micro L template (MLC-2v amplification product in 
different dilutions), 50 nM hydrolysis probe probe for MLC-2v and A. 
bidest. During the amplification, fluorescence was measured at 59.5 degree 
Celsius. The Cy5 channel was used to monitor the MLC-2v specific hydrolysis 
probe. Input stock cDNA was used undiluted (D1). D2 was 1/1000 and D3 
1/1000000 diluted in A. bidest. The D1, D2, and D3 have different numbers 
measure points and D2 contains a missing value at cycle 37.
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C54)
str(C54)
plot(NA, NA, xlim = c(0,56), ylim = c(0, 0.7), xlab = "Cycle", 
     ylab = "refMFI")
apply(C54[, c(2:4)], 2, function(x) lines(C54[, 1], x))
</code></pre>

<hr>
<h2 id='C60.amp'>
qPCR Experiment for the Amplification of MLC-2v and Vimentin (as decadic 
dilutions) Using the Roche Light Cycler 1.5
</h2><span id='topic+C60.amp'></span>

<h3>Description</h3>

<p>Dilution experiment and metling curve (<code><a href="#topic+C60.melt">C60.melt</a></code>) for 
the human genes MLC-2v and Vimentin (see Roediger et al. 2013) using the 
Roch Light Cycler 1.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C60.amp)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 33 variables.
</p>

<dl>
<dt><code>Index</code></dt><dd><p>Index of Cycles</p>
</dd>
<dt><code>Vim.0.1</code></dt><dd><p>Vimentin water control</p>
</dd>
<dt><code>Vim.0.2</code></dt><dd><p>Vimentin water control</p>
</dd>
<dt><code>Vim.1.1</code></dt><dd><p>Vimentin 10^-3 diluted</p>
</dd>
<dt><code>Vim.1.2</code></dt><dd><p>Vimentin 10^-3 diluted</p>
</dd>
<dt><code>Vim.2.1</code></dt><dd><p>Vimentin 10^-4 diluted</p>
</dd>
<dt><code>Vim.2.2</code></dt><dd><p>Vimentin 10^-4 diluted</p>
</dd>
<dt><code>Vim.3.1</code></dt><dd><p>Vimentin 10^-5 diluted</p>
</dd>
<dt><code>Vim.3.2</code></dt><dd><p>Vimentin 10^-5 diluted</p>
</dd>
<dt><code>Vim.4.1</code></dt><dd><p>Vimentin 10^-6 diluted</p>
</dd>
<dt><code>Vim.4.2</code></dt><dd><p>Vimentin 10^-6 diluted</p>
</dd>
<dt><code>Vim.5.1</code></dt><dd><p>Vimentin 10^-7 diluted</p>
</dd>
<dt><code>Vim.5.2</code></dt><dd><p>Vimentin 10^-7 diluted</p>
</dd>
<dt><code>Vim.6.1</code></dt><dd><p>Vimentin 10^-8 diluted</p>
</dd>
<dt><code>Vim.6.2</code></dt><dd><p>Vimentin 10^-8 diluted</p>
</dd>
<dt><code>Vim.7.1</code></dt><dd><p>Vimentin 10^-9 diluted</p>
</dd>
<dt><code>Vim.7.2</code></dt><dd><p>Vimentin 10^-9 diluted</p>
</dd>
<dt><code>MLC2v.1.1</code></dt><dd><p>MLC-2v 10^-3 diluted</p>
</dd>
<dt><code>MLC2v.1.2</code></dt><dd><p>MLC-2v 10^-3 diluted</p>
</dd>
<dt><code>MLC2v.2.1</code></dt><dd><p>MLC-2v 10^-4 diluted</p>
</dd>
<dt><code>MLC2v.2.2</code></dt><dd><p>MLC-2v 10^-4 diluted</p>
</dd>
<dt><code>MLC2v.3.1</code></dt><dd><p>MLC-2v 10^-5 diluted</p>
</dd>
<dt><code>MLC2v.3.2</code></dt><dd><p>MLC-2v 10^-5 diluted</p>
</dd>
<dt><code>MLC2v.4.1</code></dt><dd><p>MLC-2v 10^-6 diluted</p>
</dd>
<dt><code>MLC2v.4.2</code></dt><dd><p>MLC-2v 10^-6 diluted</p>
</dd>
<dt><code>MLC2v.5.1</code></dt><dd><p>MLC-2v 10^-7 diluted</p>
</dd>
<dt><code>MLC2v.5.2</code></dt><dd><p>MLC-2v 10^-7 diluted</p>
</dd>
<dt><code>MLC2v.6.1</code></dt><dd><p>MLC-2v 10^-8 diluted</p>
</dd>
<dt><code>MLC2v.6.2</code></dt><dd><p>MLC-2v 10^-8 diluted</p>
</dd>
<dt><code>MLC2v.7.1</code></dt><dd><p>MLC-2v 10^-9 diluted</p>
</dd>
<dt><code>MLC2v.7.2</code></dt><dd><p>MLC-2v 10^-9 diluted</p>
</dd>
<dt><code>MLC2v.0.1</code></dt><dd><p>MLC-2v water control</p>
</dd>
<dt><code>MLC2v.0.2</code></dt><dd><p>MLC-2v water control</p>
</dd>
</dl>



<h3>Details</h3>

 
<p>MLC-2v and Vimentin were amplified in the Roche Light Cycler 1.5. 
Decadic dilutions of the input cDNA were prepared. The  change of 
fluorescence was simultaneously monitored with EvaGreen. The primer 
sequences for MLC-2v were taken from Roediger et al. (2013). A 10 micro L 
qPCR reaction was composed of 250 nM primer (forward and reverse), Roche 
qPCR Master-Mix (according to the manufactures recommendations) and 1 
micro L input DNA. EvaGreen was used at 1x final. During the amplification 
was monitored 58 degrees Celsius. Temperature profile:
</p>
<p>95 deg C for 8 minutes
40 x 
95 deg C for 10 sec
58 deg C for 15 sec
69 deg C for 25 sec

</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(C60.amp)
matplot(C60.amp[, 1], C60.amp[, c(3,5,7)], type = "l",
        xlab = "Cycle", ylab = "RFU")
</code></pre>

<hr>
<h2 id='C60.melt'>
Melt Curves MLC-2v and Vimentin for the qPCR Experiment C60.amp Using the 
Roche Light Cycler 1.5
</h2><span id='topic+C60.melt'></span>

<h3>Description</h3>

<p>Melting curves were continuously monitored with the Light Cycler 1.5 
(Roche). For details on sample preparation refer to 
<a href="#topic+C60.amp">C60.amp</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C60.melt)</code></pre>


<h3>Format</h3>

<p>A data frame with 128 observations on the following 65 variables. Refer 
to <a href="#topic+C60.amp">C60.amp</a> for details of the specific samples.
</p>

<dl>
<dt><code>Index</code></dt><dd><p>Index of elements</p>
</dd>
<dt><code>Vim.0.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.0.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.0.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.0.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.1.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.1.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.1.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.1.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.2.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.2.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.2.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.2.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.3.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.3.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.3.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.3.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.4.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.4.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.4.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.4.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.5.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.5.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.5.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.5.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.6.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.6.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.6.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.6.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.7.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.7.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>Vim.7.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>Vim.7.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.1.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.1.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.1.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.1.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.2.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.2.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.2.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.2.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.3.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.3.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.3.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.3.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.4.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.4.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.4.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.4.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.5.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.5.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.5.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.5.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.6.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.6.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.6.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.6.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.7.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.7.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.7.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.7.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.0.1.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.0.1.F</code></dt><dd><p>Fluorescence</p>
</dd>
<dt><code>MLC2v.0.2.T</code></dt><dd><p>Temperature</p>
</dd>
<dt><code>MLC2v.0.2.F</code></dt><dd><p>Fluorescence</p>
</dd>
</dl>



<h3>Details</h3>

<p>Melting curves were continuously monitored with the Light Cycler 1.5 
(Roche).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p> A Highly Versatile Microscope Imaging Technology Platform for 
the Multiplex Real-Time Detection of Biomolecules and Autoimmune 
Antibodies. S. Roediger, P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. 
Froemmel, C. Schmidt, M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and 
C. Schroeder. <em>Advances in Biochemical Bioengineering/Biotechnology</em>. 
133:33&ndash;74, 2013. 
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(C60.melt)
matplot(C60.melt[, c(2,4,6)], C60.melt[, c(3,5,7)], type = "l",
        xlab = "Temperature", ylab = "RFU")
</code></pre>

<hr>
<h2 id='C67'>
Helicase Dependent Amplification of HPRT1 with different input DNA 
quantities using the Bio-Rad iQ5 thermo cycler
</h2><span id='topic+C67'></span>

<h3>Description</h3>

<p>A Helicase Dependent Amplification (HDA) of HPRT1 (Homo sapiens 
hypoxanthine phosphoribosyltransferase 1) was performed at three different 
input DNA quantities using the Bio-Rad iQ5 thermo cycler. The HDA was 
performed at 65 degrees Celsius. The optimal temperature for a HDA is circa 
65 degrees Celsius. Lower temperatures will affect the slope and plateau of 
the HDA amplification curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C67)</code></pre>


<h3>Format</h3>

<p>A data frame with 43 observations on the following 6 variables.
</p>

<dl>
<dt><code>Cycles.C67</code></dt><dd><p>a numeric vector containing the cycle numbers</p>
</dd>
<dt><code>t.C67</code></dt><dd><p>a numeric vector containing the time elapsed 
between the cycles. The time was calculated by the cycle duration of one
iQ5 thermocycler step (71 seconds / step).</p>
</dd>
<dt><code>D1</code></dt><dd><p>Dilution 1.</p>
</dd>
<dt><code>D2</code></dt><dd><p>Dilution 2.</p>
</dd>
<dt><code>D3</code></dt><dd><p>Dilution 3.</p>
</dd>
<dt><code>D4</code></dt><dd><p>Dilution 4.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To perform an isothermal amplification in 'VideoScan', standard conditions 
for the IsoAmp(R) III Universal tHDA Kit (Biohelix) were used. The reaction 
was composed of 12.5 micro L buffer A containing 1.25 micro L 10x reaction 
buffer, 150 nM primer (forward and reverse), 0.75  micro L template 
(synthetic) and A. bidest which was covered with 50 micro L mineral oil. 
The primer sequences for HPRT1 were taken from Roediger et al. (2013). 
Preincubation: This mixture was incubated for 2 min at 95 degree. Celsius 
and immediately placed on ice. 12.5 micro L of reaction buffer B which was 
composed of 1.25 micro L 10x buffer, 40 mM NaCl, 5 mM MgSO4, 1.75 micro L 
dNTPs, 0.2 x EvaGreen, 1 micro L Enzyme mix and A. bidest. The fluorescence 
measurement started directly after adding buffer B and the preincubation step.
Temperature profile if the iQ5 thermo cycler (after Preincubation):
- 60 seconds at 65 degrees Celsius 
- 11 seconds at 55 degrees Celsius &amp;&amp; Measurement
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, 
Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the 
Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. 
Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C67)
matplot(C67[, -c(1,2)], type = "l", xlab = "Time [sec]", ylab = "RFU")
</code></pre>

<hr>
<h2 id='C81'>
Helicase Dependent Amplification of pCNG1 using the 'VideoScan' Platform
</h2><span id='topic+C81'></span>

<h3>Description</h3>

<p>A Helicase Dependent Amplification (HDA) of pCNG1 was performed. The 'VideoScan' 
Platform (Roediger et al. (2013)) was used to monitor the amplification. The 
HDA was performed at 65 degrees Celsius. Two concentrations of input DNA were 
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C81)</code></pre>


<h3>Format</h3>

<p>A data frame with 351 observations on the following 5 variables.
</p>

<dl>
<dt><code>Cycle</code></dt><dd><p>Cycles HDA measurements.</p>
</dd>
<dt><code>t.D1</code></dt><dd><p>Dilution 1, elapsed time during HDA in seconds.</p>
</dd>
<dt><code>MFI.D1</code></dt><dd><p>Dilution 1, fluorescence.</p>
</dd>
<dt><code>t.D2</code></dt><dd><p>Dilution 2, elapsed time during HDA in seconds.</p>
</dd>
<dt><code>MFI.D2</code></dt><dd><p>Dilution 2, fluorescence.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To perform an isothermal amplification in 'VideoScan', standard conditions for 
the IsoAmp(R) III Universal tHDA Kit (Biohelix) were used. The reaction was 
composed of reaction mix A)10 micro L A. bidest, 1.25 micro L 10xbuffer, 
0.75 micro L primer(150 nM final), 0.5 micro L template plasmid. Preincubation: 
This mixture was incubated for 2 min at 95 degree. Celsius and immediately 
placed on ice. Reaction mix B) 5 micro L A. bidest., 1.25 micro L 10x buffer, 
2 micro L NaCl, 1.25 micro L MgSO4, 1.75 micro L dNTPs, 0.25 micro L EvaGreen, 
1 micro L enzyme mix. The mix was covered with 50 micro L mineral oil. The 
fluorescence measurement in 'VideoScan' 'HCU' started directly after adding 
buffer B at 65 degrees Celsius. A 1x (D1) and a 1:10 dilution (D2) were tested.
Temperature profile (after Preincubation):
- 60 seconds at 65 degrees Celsius 
- 11 seconds at 55 degrees Celsius &amp;&amp; Measurement
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C81)
# First example
# Comparison of Lowess, Moving average and splines to smooth amplification curve 
# data of
# HDA for pCNG1.

plot(NA, NA, xlim = c(0, 120), ylim = c(0, 1.2), xlab = "Time [min]", 
     ylab = "Fluorescence", main = "VideScan HCU HDA amplification - Raw data")
  points(C81[, 2]/60, C81[, 3], type = "b", col = 1, pch = 20)
  points(C81[, 4]/60, C81[, 5], type = "b", col = 2, pch = 20)
legend(2000, 0.4, c("D1", "D2"), col = c(1,2), pch = rep(20,2))
</code></pre>

<hr>
<h2 id='C85'>
Helicase Dependent Amplification of Vimentin using the 'VideoScan' Platform
</h2><span id='topic+C85'></span>

<h3>Description</h3>

<p>A Helicase Dependent Amplification (HDA) of Vimentin (Vim) was performed. The 
'VideoScan' Platform (Roediger et al. (2013)) was used to monitor the 
amplification. The HDA was performed at 65 degrees Celsius. Three 
concentrations of input DNA (D1, D2, D3) were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C85)</code></pre>


<h3>Format</h3>

<p>A data frame with 301 observations on the following 5 variables.
</p>

<dl>
<dt><code>Cycle</code></dt><dd><p>Cycles HDA measurements.</p>
</dd>
<dt><code>t.D1</code></dt><dd><p>Dilution 1, elapsed time during HDA in seconds.</p>
</dd>
<dt><code>MFI.D1</code></dt><dd><p>Dilution 1, fluorescence.</p>
</dd>
<dt><code>t.D2</code></dt><dd><p>Dilution 2, elapsed time during HDA in seconds.</p>
</dd>
<dt><code>MFI.D2</code></dt><dd><p>Dilution 2, fluorescence.</p>
</dd>
<dt><code>t.D3</code></dt><dd><p>Dilution 3, elapsed time during HDA in seconds.</p>
</dd>
<dt><code>MFI.D3</code></dt><dd><p>Dilution 3, fluorescence.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To perform an isothermal amplification in 'VideoScan', standard conditions for 
the IsoAmp(R) III Universal tHDA Kit (Biohelix) were used. Primers and 
templates are described in Roediger et al. (2013). The reaction was composed 
of reaction mix A)10 micro L A. bidest, 1.25 micro L 10xbuffer, 0.75 micro L 
primer(150nM final), 0.5 micro L template plasmid. Preincubation: This mixture 
was incubated for 2 min at 95 degree. Celsius and immediately placed on ice. 
Reaction mix B) 5 micro L A. bidest., 1.25 micro L 10x buffer, 2 micro L NaCl, 
1.25 micro L MgSO4, 1.75 micro L dNTPs, 0.25 micro L EvaGreen, 1 micro L 
enzyme mix. The mix was covered with 50 micro L mineral oil. The fluorescence 
measurement in 'VideoScan' 'HCU' started directly after adding buffer B at 65 
degrees Celsius. A 1x (D1), a 1:10 dilution (D2) and a 1:100 (D3) dilution were 
tested.
Temperature profile (after Preincubation):
- 60 seconds at 65 degrees Celsius 
- 11 seconds at 55 degrees Celsius &amp;&amp; Measurement
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C85)
# First example
plot(NA, NA, xlim = c(0,85), ylim = c(0,1), xlab = "Time [min]", 
      ylab = "Fluorescence", main = "HDA amplification")
points(C85[, 2]/60, C85[, 3], type = "b", col = 1, pch = 20)
points(C85[, 4]/60, C85[, 5], type = "b", col = 2, pch = 20)
points(C85[, 6]/60, C85[, 7], type = "b", col = 3, pch = 20)
legend(40, 0.5, c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
	pch = rep(20,3))

# Second example
plot(NA, NA, xlim = c(0,30), ylim = c(0,0.8), xlab = "Time [min]", 
      ylab = "Fluorescence", main = "HDA amplification")
points(C85[, 2]/60, C85[, 3], type = "b", col = 1, pch = 20)
points(C85[, 2]/60, smoother(C85[, 2]/60, C85[, 3], 
      method = list("savgol")), type = "b", col = 2, pch = 20)
points(C85[, 2]/60, smoother(C85[, 2]/60, C85[, 3], 
      method = list("smooth")), type = "b", col = 3, pch = 20)
points(C85[, 2]/60, smoother(C85[, 2]/60, C85[, 3], 
      method = list("mova")), type = "b", col = 4, pch = 20)

legend(1, 0.8, c("D1, raw", "D1, savgol", "D1, smooth", "D1, mova"), 
	col = c(1:4), pch = rep(20,4))

# Third example
# Comparison of Lowess, Moving average and splines to smooth amplification 
# curve data of
# a HDA using the 'VideoScan' 'HCU' for amplification and monitoring.

xrange &lt;- 2:2400
plot(NA, NA, xlim = c(0,85), ylim = c(0.4, 0.8), xlab = "Time [min]", 
      ylab = "RFI", main = "Raw data")
points(C85[, 2]/60, C85[, 3], type = "b", col = 1, pch = 20)
points(C85[, 4]/60, C85[, 5], type = "b", col = 2, pch = 20)
points(C85[, 6]/60, C85[, 7], type = "b", col = 3, pch = 20)
legend("topleft", c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
	pch = rep(20,3))

mtext("A", cex = 2, side = 3, adj = 0, font = 2)

plot(NA, NA, xlim = c(0,40), ylim = c(-0.05, 0.3), xlab = "Time [min]", 
      ylab = "RFI", main = "Moving average")
movaww &lt;- seq(1,17,4)
for (i in 1:length(movaww)) {
  for (j in c(2,4,6)) {
    tmp &lt;- data.frame(na.omit(C85[xrange, j])/60, na.omit(C85[xrange, j + 1]))
    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list(mova = list(movaww = movaww[i])), 
			bg.outliers = TRUE)
    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, cex = 0.5, 
	  col = i)
    }
}
mtext("B", cex = 2, side = 3, adj = 0, font = 2)
legend("topleft", c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
	pch = rep(20,3))
legend("bottomright", 6, paste("movaww : ", movaww), pch = 20, lwd = 2, 
	col = 1:length(movaww))
    
plot(NA, NA, xlim = c(0,40), ylim = c(-0.05, 0.3), xlab = "Time [min]", 
      ylab = "RFI", main = "Cubic Spline")
df.fact &lt;- seq(0.5,0.9,0.1)
for (i in 1:length(df.fact)) {
  for (j in c(2,4,6)) {
    tmp &lt;- data.frame(na.omit(C85[xrange, j])/60, na.omit(C85[xrange, j + 1]))
    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], 
		  method = list(smooth = list(df.fact = df.fact[i])), 
		  bg.outliers = TRUE)
    
    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, 
    cex = 0.5, col = i)
    }
}
    
mtext("C", cex = 2, side = 3, adj = 0, font = 2)
legend("topleft", c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
pch = rep(20,3))
legend("bottomright", paste("df.fact : ", df.fact), pch = 20, lwd = 2, 
col = 1:length(df.fact))
    
plot(NA, NA, xlim = c(0,40), ylim = c(-0.05, 0.3), xlab = "Time [min]", 
ylab = "RFI", main = "Lowess")
f &lt;- seq(0.01,0.2,0.04)
for (i in 1:length(f)) {
  for (j in c(2,4,6)) {
    tmp &lt;- data.frame(na.omit(C85[xrange, j])/60, na.omit(C85[xrange, j + 1]))
    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list(lowess = list(f = f[i])), 
		  bg.outliers = TRUE)
    
    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, cex = 0.5, 
    col = i)
    }
    }
    
    mtext("D", cex = 2, side = 3, adj = 0, font = 2)
    legend("topleft", c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
    pch = rep(20,3))
    legend("bottomright", paste("f : ", f), pch = 20, lwd = 2, col = 1:length(f))
	
plot(NA, NA, xlim = c(0,40), ylim = c(-0.05, 0.3), xlab = "Time [min]", 
ylab = "RFI", main = "Friedman's\n''super smoother''")
span &lt;- seq(0.01,0.05,0.01)
for (i in 1:length(span)) {
  for (j in c(2,4,6)) {
    tmp &lt;- data.frame(na.omit(C85[xrange, j])/60, na.omit(C85[xrange, j + 1]))
    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list(supsmu = list(span = span[i])), 
	  bg.outliers = TRUE)
    
    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, cex = 0.5, 
col = i)
    }
    }
    
    mtext("E", cex = 2, side = 3, adj = 0, font = 2)
    legend("topleft", c("D1, 1x", "D2, 1:10", "D3, 1:100"), col = c(1:3), 
pch = rep(20,3))
    legend("bottomright", paste("span : ", span), pch = 20, lwd = 2, col = 1:length(span))
	  
plot(NA, NA, xlim = c(0,40), ylim = c(-0.05, 0.3), xlab = "Time [min]", 
ylab = "RFI", main = "Savitzky-Golay")

for (j in c(2,4,6)) {
  tmp &lt;- data.frame(na.omit(C85[xrange, j])/60, na.omit(C85[xrange, j + 1]))
  tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list("savgol"), 
	bg.outliers = TRUE)
  
  lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, cex = 0.5, 
col = 1)
  }
  
  mtext("F", cex = 2, side = 3, adj = 0, font = 2)
  legend("bottomright", paste("/ : ", NULL), pch = 20, lwd = 2, col = 1:length(span))
</code></pre>

<hr>
<h2 id='capillaryPCR'>
capillary convective PCR
</h2><span id='topic+capillaryPCR'></span>

<h3>Description</h3>

<p>The capillary convective PCR (ccPCR) is a modified device of the ccPCR system 
proposed by Chou et al. 2011. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(capillaryPCR)</code></pre>


<h3>Format</h3>

<p>A data frame with 1844 observations on the following 10 variables.
</p>

<dl>
<dt><code>t.121205</code></dt><dd><p>Elapsed time during amplification</p>
</dd>
<dt><code>ED.121205</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>t.121128</code></dt><dd><p>Elapsed time during amplification</p>
</dd>
<dt><code>ED.121128</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>t.121130.1</code></dt><dd><p>Elapsed time during amplification</p>
</dd>
<dt><code>ED.121130.1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>t.121130.2</code></dt><dd><p>Elapsed time during amplification</p>
</dd>
<dt><code>ED.121130.2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>t.121130.3</code></dt><dd><p>Elapsed time during amplification</p>
</dd>
<dt><code>ED.121130.3</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Modified version of the capillary convective tube isothermal heater heater by 
Chou et al. 2011. As heating system a conventional block heat was used. On the 
top of the heating block, we placed for the uptake of the capillaries an 
aluminum block (8 mm height) in which four holes (3.2 mm diameter and 3.0 mm 
depth with round shaped bottom) were drilled. The capillaries are regular 100 
micro L Roche LightCycler(R). These glass capillaries have a round shaped 
closed bottom (2.3 mm inner diameter and 3.2 mm outer diameter). An &quot;ESE-Log&quot; 
detector (QIAGEN Lake Constance) was used for the real time fluorescent 
measurements, which was mounted in a distance of 5-10 mm next to the 
capillary. The PCR was performed with SYBR(R) Green fluorescent intercalating 
dye. Thereof the ESE-Log has in one channel the excitation at 470 nm and the 
detection at 520 nm. The data was recorded by the FL Digital Software (QIAGEN 
Lake Constance) and the exported text based raw data.
</p>


<h3>Source</h3>

<p>Ralf Himmelreich, IMM, Mainz, Germany
</p>


<h3>References</h3>

<p>Chou, W., Chen, P., Miao Jr, M., Kuo, L., Yeh, S. and Chen, P. (2011). Rapid 
DNA amplification in a capillary tube by natural convection with a single 
isothermal heater. Biotech. 50, 52-57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default.par &lt;- par(no.readonly = TRUE)
# First example
data(capillaryPCR)
plot(NA, NA, xlim = c(0,80), ylim = c(0,1300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Raw Data")

for (i in c(1,3,5,7)) {
  lines(capillaryPCR[, i], capillaryPCR[, i+1], type = "b", pch = 20) 
}

abline(h = 290, v = c(18, 23, 35))
legend(60,800, c("Run 1", "Run 2", "Run 3", "Control"), pch = 20, lwd = 2)
  
# Second example
par(mfrow = c(2,1))

type &lt;- c("mova", "spline", "savgol")
plot(NA, NA, xlim = c(0,80), ylim = c(0,1100), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR with mova, 
     spline and savgol")
for (i in 1:3) {
  for (j in c(1,3,5,7)) {
      tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			na.omit(capillaryPCR[, j+1]))
      tmp.sm &lt;- smoother(tmp[, 1], tmp[, 2], method = list(type[i]))
      lines(data.frame(tmp[, 1], tmp.sm), type = "b", pch = 20, cex = 0.5, 
	    col = i)
  }
}

abline(h = 200, v = c(17.5, 21.3, 32.9))
legend(0, 1000, c("mova", "spline", "savgol"), pch = 20, lwd = 2, 
	col = c(1:3))
  
plot(NA, NA, xlim = c(10,40), ylim = c(50,300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR with mova, 
     spline and savgol")
for (i in 1:3) {
  for (j in c(1,3,5,7)) {
      tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			na.omit(capillaryPCR[, j+1]))
      tmp.sm &lt;- smoother(tmp[, 1], tmp[, 2], method = list(type[i]))
      lines(data.frame(tmp[, 1], tmp.sm), type = "b", pch = 20, cex = 0.5, 
	    col = i)
  }
}
abline(h = 200, v = c(17.5, 21.3, 32.9))
legend(10, 300, c("mova", "spline", "savgol"), pch = 20, lwd = 2, 
	col = c(1:3))

par(mfrow = c(1,1))

# Third example
method &lt;- c("lowess","mova","savgol","smooth","spline", "supsmu")

plot(NA, NA, xlim = c(0,100), ylim = c(-50,1100), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "capillary convective PCR")
for (i in 1:length(method)) {
  for (j in c(1,3,5,7)) {
      tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			na.omit(capillaryPCR[, j+1]))
      tmp.sm &lt;- smoother(tmp[, 1], tmp[, 2], method = list(method[i]))
      lines(data.frame(tmp[, 1], tmp.sm), type = "l", pch = 20, cex = 0.5, 
	    col = i)
  }
}
legend(0,1000, method, pch = 20, lwd = 2, col = 1:length(method))


par(fig = c(0.5,1,0.25,0.8), new = TRUE)
plot(NA, NA, xlim = c(10,40), ylim = c(50,300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "")
for (i in 1:length(method)) {
  for (j in c(1,3,5,7)) {
      tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			na.omit(capillaryPCR[, j+1]))
      tmp.sm &lt;- smoother(tmp[, 1], tmp[, 2], method = list(method[i]))
      lines(data.frame(tmp[, 1], tmp.sm), type = "l", pch = 20, cex = 0.5, 
	    col = i)
  }
}
legend(0,1000, method, pch = 20, lwd = 2, col = 1:length(method))

# Fourth example
# Comparison of Lowess, Moving average and splines to smooth amplification 
# curve data of
# a capillary convective PCR.

plot(NA, NA, xlim = c(10,40), ylim = c(50, 300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Moving average")
movaww &lt;- seq(1,17,4)
for (i in 1:length(movaww)) {
  for (j in c(1,3,5,7)) {
	    tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			      na.omit(capillaryPCR[, j+1]))
	    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], 
                 method = list(mova = list(movaww = movaww[i])))
	    
	    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, 
		  cex = 0.5, col = i)
  }
}
text(10,300, "A)", cex = 3)
legend(25,200, paste("movaww : ", movaww), pch = 20, lwd = 2, 
	col = 1:length(movaww))

plot(NA, NA, xlim = c(10,40), ylim = c(50, 300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Cubic Spline")
df.fact &lt;- seq(0.5,0.9,0.1)
for (i in 1:length(df.fact)) {
  for (j in c(1,3,5,7)) {
    tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
		      na.omit(capillaryPCR[, j+1]))
    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list(smooth = 
    list(df.fact = df.fact[i])))
   
    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, 
		  cex = 0.5, col = i)
  }
}
text(10,300, "B)", cex = 3)
legend(30,200, paste("df.fact : ", df.fact), pch = 20, lwd = 2, 
	col = 1:length(df.fact))
	

plot(NA, NA, xlim = c(10,40), ylim = c(50, 300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Lowess")
f &lt;- seq(0.01,0.2,0.04)
for (i in 1:length(f)) {
  for (j in c(1,3,5,7)) {
	    tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			      na.omit(capillaryPCR[, j+1]))
	    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], method = list(lowess = list(f = f[i])))
	    
	    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, 
		  cex = 0.5, col = i)
  }
}
text(10,300, "C)", cex = 3)
legend(30,200,  paste("f : ", f), pch = 20, lwd = 2, col = 1:length(f))

plot(NA, NA, xlim = c(10,40), ylim = c(50, 300), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", 
     main = "ccPCR - Friedman's ''super smoother''")
span &lt;- seq(0.01,0.05,0.01)
for (i in 1:length(span)) {
  for (j in c(1,3,5,7)) {
	    tmp &lt;- data.frame(na.omit(capillaryPCR[, j]), 
			      na.omit(capillaryPCR[, j+1]))
	    tmp.out &lt;- smoother(tmp[, 1], tmp[, 2], 
                 method = list(supsmu = list(span = span[i])))
	    
	    lines(data.frame(tmp[, 1], tmp.out), type = "l", pch = 20, 
		  cex = 0.5, col = i)
  }
}
text(10,300, "D)", cex = 3)
legend(25,200,  paste("span : ", f), pch = 20, lwd = 2, col = 1:length(span))

par(default.par)
</code></pre>

<hr>
<h2 id='CD74'>
Quantitative PCR with a hydrolysis probe and DNA binding dye
</h2><span id='topic+CD74'></span>

<h3>Description</h3>

<p>Quantitative PCR (qPCR) with a hydrolysis probe and DNA binding dye (EvaGreen) 
(Mao et al. 2007) was performed in the 'VideoScan' heating cooling unit. The 
cycle-dependent increase of the fluorescence was quantified at three different 
temperatures in order to estimate temperature dependent effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CD74)</code></pre>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 19 variables. refMFI 
(referenced Mean Fluorescence Intensity), 
fluorescence. Dilution A, 1x; Dilution B, 1:10; Dilution B, 1:100.
</p>

<dl>
<dt><code>Cycle</code></dt><dd><p>PCR cycles</p>
</dd>
<dt><code>EG.30.A</code></dt><dd><p>refMFI at 30 degrees Celsius, EvaGreen, Dilution A</p>
</dd>
<dt><code>EG.59.5.A</code></dt><dd><p>refMFI at 59.5 degrees Celsius, EvaGreen, Dilution A</p>
</dd>
<dt><code>EG.68.5.A</code></dt><dd><p>refMFI at 68.5 degrees Celsius, EvaGreen, Dilution A</p>
</dd>
<dt><code>HP.30.A</code></dt><dd><p>refMFI at 30 degrees Celsius, hydrolysis probe, 
Dilution A</p>
</dd>
<dt><code>HP.59.5.A</code></dt><dd><p>refMFI at 59.5 degrees Celsius, hydrolysis probe, 
Dilution A</p>
</dd>
<dt><code>HP.68.5.A</code></dt><dd><p>refMFI at 68.5 degrees Celsius, hydrolysis probe, 
Dilution A</p>
</dd>
<dt><code>EG.30.B</code></dt><dd><p>refMFI at 30 degrees Celsius, EvaGreen, Dilution B</p>
</dd>
<dt><code>EG.59.5.B</code></dt><dd><p>refMFI at 59.5 degrees Celsius, EvaGreen, Dilution B</p>
</dd>
<dt><code>EG.68.5.B</code></dt><dd><p>refMFI at 68.5 degrees Celsius, EvaGreen, Dilution B</p>
</dd>
<dt><code>HP.30.B</code></dt><dd><p>refMFI at 30 degrees Celsius, hydrolysis probe, 
Dilution B</p>
</dd>
<dt><code>HP.59.5.B</code></dt><dd><p>refMFI at 59.5 degrees Celsius, hydrolysis probe, 
Dilution B</p>
</dd>
<dt><code>HP.68.5.B</code></dt><dd><p>refMFI at 68.5 degrees Celsius, hydrolysis probe, 
Dilution B</p>
</dd>
<dt><code>EG.30.C</code></dt><dd><p>refMFI at 30 degrees Celsius, EvaGreen, Dilution C</p>
</dd>
<dt><code>EG.59.5.C</code></dt><dd><p>refMFI at 59.5 degrees Celsius, EvaGreen, Dilution C</p>
</dd>
<dt><code>EG.68.5.C</code></dt><dd><p>refMFI at 68.5 degrees Celsius, EvaGreen, Dilution C</p>
</dd>
<dt><code>HP.30.C</code></dt><dd><p>refMFI at 30 degrees Celsius, hydrolysis probe, 
Dilution C</p>
</dd>
<dt><code>HP.59.5.C</code></dt><dd><p>refMFI at 59.5 degrees Celsius, hydrolysis probe, 
Dilution C</p>
</dd>
<dt><code>HP.68.5.C</code></dt><dd><p>refMFI at 68.5 degrees Celsius, hydrolysis probe, 
Dilution C</p>
</dd>
</dl>



<h3>Details</h3>

<p>The aim was to amplify MLC-2v in the 'VideoScan' platform while the 
intercalating dye EvaGreen and a hydrolysis probe for MLC-2v were used 
simultaneously. The primer sequences for MLC-2v were taken from Roediger et 
al. (2013). The amplification was detected in solution of the '1 HCU' (see 
Roediger et al. 2013 for details). A 20 micro L PCR reaction was composed of 
500 nM primer (forward and reverse), 1x Maxima Probe qPCR Master Mix 
(Fermentas), 1 micro L template (MLC-2v amplification product in different 
dilutions), 50 nM hydrolysis probe probe for MLC-2v, 0.5 x EvaGreen and A. 
bidest. During the amplification, fluorescence was measured at 3 different 
temperatures, at 59.5 degrees Celsius the annealing temperature, at 68.5 degree 
Celsius the elongation temperature and at 30 degrees Celsius. The FAM channel 
was used to monitor EvaGreen and the Cy5 channel to monitor the MLC-2v specific 
hydrolysis probe.
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>
<p>Mao, F., Leung, W.-Y., Xin, X., 2007. Characterization of EvaGreen and the 
implication of its physicochemical properties for qPCR applications. 
<em>BMC Biotechnol</em>. 7, 76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
# Comparison of smoothers and filter on amplification curves
# Amplification curves were measured at three temperature (30, 
# 59.5, 68.5 degrees Celsius) using the 'VideoScan' 'HCU' (see 
# Roediger et al. 2013 for details). MLC-2v was amplified.
# The change of fluorescence was monitored by the intercalating
# dye EvaGreen and hydrolysis probes.

data(CD74)
default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
plot(NA, NA, xlim = c(1,30), ylim = c(0,2), xlab = "Cycle", 
     ylab = "MFI", main = "VideoScan HCU\nRaw Data")
lim &lt;- 1:30
for (j in c(2:4)) {
  for (i in seq(j,19,6)) {
    lines(CD74[lim, 1], CD74[lim, i], col = 1) 
  }
}
for (j in c(5:7)) {
  for (i in seq(j,19,6)) {
    lines(CD74[lim, 1], CD74[lim, i], col = 2) 
  }
}

plot(NA, NA, xlim = c(1,30), ylim = c(0,1.8), xlab = "Cycle", 
     ylab = "MFI", main = "VideoScan HCU\nSmoothed Data")
lim &lt;- 1:30
for (j in c(2:4)) {
  for (i in seq(j,19,6)) {
    lines(CD74[lim, 1], smoother(CD74[lim, 1], CD74[lim, i], trans = TRUE), 
	  col = 1) 
  }
}
for (j in c(5:7)) {
  for (i in seq(j,19,6)) {
    lines(CD74[lim, 1], smoother(CD74[lim, 1], CD74[lim, i], trans = TRUE), 
	  col = 2) 
  }
}
par(default.par)
</code></pre>

<hr>
<h2 id='CD75'>
Helicase Dependent Amplification in the 'VideoScan' 'HCU'
</h2><span id='topic+CD75'></span>

<h3>Description</h3>

<p>Helicase Dependent Amplification in the 'VideoScan' 'HCU' of HPRT1 (Homo 
sapiens hypoxanthine phosphoribosyltransferase 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CD75)</code></pre>


<h3>Format</h3>

<p>A data frame with 93 observations on the following 6 variables. The data 
frame contains three replicates of a HDA for HPRT1.
</p>

<dl>
<dt><code>CD75.t1</code></dt><dd><p>Elapsed time during HDA in seconds.</p>
</dd>
<dt><code>CD75.F1</code></dt><dd><p>Time-dependent fluorescence during HDA.</p>
</dd>
<dt><code>CD75.t2</code></dt><dd><p>Elapsed time during HDA in seconds.a numeric vector</p>
</dd>
<dt><code>CD75.F2</code></dt><dd><p>Time-dependent fluorescence during HDA</p>
</dd>
<dt><code>CD75.t3</code></dt><dd><p>Elapsed time during HDA in seconds.</p>
</dd>
<dt><code>CD75.F3</code></dt><dd><p>Time-dependent fluorescence during HDA.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To perform an isothermal amplification in 'VideoScan', standard conditions for 
the IsoAmp(R) III Universal tHDA Kit (Biohelix) were used. The reaction was 
composed of 12.5 micro L buffer A containing 1.25 micro L 10x reaction buffer, 
150 nM primer (forward and reverse), 0.75  micro L template (synthetic) and 
A. bidest which was covered with 50 micro L mineral oil. The primer sequences 
for HPRT1 were taken from Roediger et al. (2013). Preincubation: This mixture 
was incubated for 2 min at 95 degree. Celsius and immediately placed on ice. 
12.5 micro L of reaction buffer B which was composed of 1.25 micro L 10x 
buffer, 40 mM NaCl, 5 mM MgSO4, 1.75 micro L dNTPs, 0.2 x EvaGreen, 1 micro L 
Enzyme mix and A. bidest. The fluorescence measurement in 'VideoScan' 'HCU' 
started directly after adding buffer B at 55, 60 or 65 degrees Celsius and 
revealed optimal conditions for the amplification when using 60 or 65 degree 
Celsius. Temperature profile (after Preincubation):
- 60 seconds at 65 degrees Celsius 
- 11 seconds at 55 degrees Celsius &amp;&amp; Measurement
</p>


<h3>Source</h3>

<p>Claudia Deutschmann &amp; Stefan Roediger, BTU Cottbus - Senftenberg, Senftenberg, 
Germany
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CD75)
matplot(CD75[1:80, c(1,3,4)], CD75[1:80, c(2,4,6)], type = "l", 
        xlab = "Temperature", ylab = "RFU")
</code></pre>

<hr>
<h2 id='chipPCR.datasets'>
Overview for data sets of the <code>chipPCR</code> package
</h2><span id='topic+chipPCR.datasets'></span>

<h3>Description</h3>

<p>The <code>chipPCR</code> package contains numerous data sets from commercial and 
experimental technologies for the amplification of nucleic acids. The data 
sets include results from qPCR experiments with the 'VideoScan' 'HCU' 
(Roediger et al. 2013), Bio-Rad (iQ5, CFX96), capillary convective PCR (ccPCR) and 
Roche Light Cycler 1.5. Real-time monitored amplification reactions were 
performed using standard amplification methods (qPCR, based on Taq 
polymerase) and quantitative isothermal amplification (qIA). In selected 
data 
sets are melting curves and dilution series available. Most of the data 
sets have equidistant measure points. However, some datasets have none 
homogeneous measure points as indicated below.
</p>
<p><strong>capillary convective PCR (ccPCR)</strong>
</p>
<p><code><a href="#topic+capillaryPCR">capillaryPCR</a></code>:
The capillary convective PCR (ccPCR) is a modified device of the ccPCR 
system proposed by Chou et al. 2013.
</p>
<p><strong>standard qPCR - commercial thermo cyclers</strong>
</p>
<p><code><a href="#topic+C60.amp">C60.amp</a></code>:
qPCR Experiment for the Amplification of MLC-2v and Vimentin (as decadic 
dilutions) Using the Roche Light Cycler 1.5.
</p>
<p><code><a href="#topic+C60.melt">C60.melt</a></code>:
Melt Curves MLC-2v and Vimentin for the qPCR experiment 
<code><a href="#topic+C60.amp">C60.amp</a></code> using the Roche Light Cycler 1.5
</p>
<p><code><a href="#topic+C126EG595">C126EG595</a></code>:
A quantitative PCR (qPCR) with the DNA binding dye (EvaGreen) (Mao et al. 
2007) was performed in a Bio-Rad iQ5 thermo cycler. The 
cycle-dependent increase of the fluorescence was quantified at the 
elongation step (59.5 degrees Celsius).
</p>
<p><code><a href="#topic+C126EG685">C126EG685</a></code>:
A quantitative PCR (qPCR) with the DNA binding dye (EvaGreen) (Mao et al. 
2007) was performed in a Bio-Rad iQ5 thermo cycler. The 
cycle-dependent increase of the fluorescence was quantified at the 
elongation step (68.5 degrees Celsius).
</p>
<p><code><a href="#topic+C127EGHP">C127EGHP</a></code>:
Quantitative PCR (qPCR) with a hydrolysis probe (Cy5/BHQ2) and DNA binding 
dye (EvaGreen) (Mao et al. 2007) performed in the Roche Light Cycler 
1.5 thermo cycler.
</p>
<p><code><a href="#topic+VIMCFX96_60">VIMCFX96_60</a></code>:
Human vimentin amplification curve data (measured during annealing phase at 
60 degrees Celsius) for 96 replicate samples in a Bio-Rad CFX96 thermo cycler.
</p>
<p><code><a href="#topic+VIMCFX96_69">VIMCFX96_69</a></code>:
Human vimentin amplification curve data (measured during elongation phase at 
69 degrees Celsius) for 96 replicate samples in a Bio-Rad CFX96 thermo cycler.
</p>
<p><code><a href="#topic+VIMCFX96_meltcurve">VIMCFX96_meltcurve</a></code>:
Human vimentin melting curve data for 96 replicate samples in a Bio-Rad 
CFX96 thermo cycler.
</p>
<p><code><a href="#topic+VIMiQ5_595">VIMiQ5_595</a></code>:
Human vimentin amplification curve data (measured during annealing phase at 
59.5 degrees Celsius) for 96 replicate samples in a Bio-Rad iQ5 thermo cycler.
</p>
<p><code><a href="#topic+VIMiQ5_685">VIMiQ5_685</a></code>:
Human vimentin amplification curve data (measured during elongation phase at 
68.5 degrees Celsius) for 96 replicate samples in a Bio-Rad iQ5 thermo cycler.
</p>
<p><code><a href="#topic+VIMiQ5_melt">VIMiQ5_melt</a></code>:
Human vimentin melting curve data for 96 replicate samples in a Bio-Rad 
iQ5 thermo cycler.
</p>
<p><strong>standard qPCR - experimental thermo cyclers</strong>
</p>
<p><code><a href="#topic+C54">C54</a></code>:
qPCR Experiment in the 'VideoScan' heating/cooling-unit for the 
amplification using different concentrations of MLC-2v input cDNA 
quantities. 
</p>
<p><code><a href="#topic+CD74">CD74</a></code>:
Quantitative PCR with a hydrolysis probe and DNA binding dye (EvaGreen) for 
MLC-2v measured at 59.5 degrees Celsius (annealing temperature), 68.5 
degrees Celsius (elongation temperature) and at 30 degrees Celsius.
</p>
<p><strong>Simulations</strong>
</p>
<p><code><a href="#topic+Eff625">Eff625</a></code>:
Highly replicate number amplification curves with an approximate 
amplification efficiency of 62.5 percent at cycle number 18. The data were 
derived from a simulation such as the AmpSim function.
</p>
<p><code><a href="#topic+Eff750">Eff750</a></code>:
Highly replicate number amplification curves with an approximate 
amplification efficiency of 75 percent at cycle number 18. The data were 
derived from a simulation such as the AmpSim function.
</p>
<p><code><a href="#topic+Eff875">Eff875</a></code>:
Highly replicate number amplification curves with an approximate 
amplification efficiency of 87.5 percent at cycle number 18. The data were 
derived from a simulation such as the AmpSim function.
</p>
<p><code><a href="#topic+Eff1000">Eff1000</a></code>:
Highly replicate number amplification curves with an approximate 
amplification efficiency of 100 percent at cycle number 18. The data were 
derived from a simulation such as the AmpSim function.
</p>
<p><strong>Isothermal Amplification - Helicase Dependent Amplification</strong>
</p>
<p><code><a href="#topic+C67">C67</a></code>:
A Helicase Dependent Amplification (HDA) of HPRT1 (Homo sapiens 
hypoxanthine phosphoribosyltransferase 1), performed at different 
input DNA quantities using the Bio-Rad iQ5 thermo cycler.
</p>
<p><code><a href="#topic+CD75">CD75</a></code>:
Helicase Dependent Amplification in the 'VideoScan' 'HCU' of HPRT1 (Homo 
sapiens hypoxanthine phosphoribosyltransferase 1) measured at at 55, 60 or 
65 degrees Celsius.
</p>
<p><code><a href="#topic+C81">C81</a></code>:
Helicase Dependent Amplification (HDA) of pCNG1 using the 'VideoScan' 
Platform (Roediger et al. (2013)). The HDA was performed at 65 degree 
Celsius. Two concentrations of input DNA were used.
</p>
<p><code><a href="#topic+C85">C85</a></code>:
Helicase Dependent Amplification (HDA) of Vimentin (Vim) in the 'VideoScan' 
Platform (Roediger et al. (2013)). The HDA was performed at 65 degree 
Celsius with three dilutions of input DNA.
</p>


<h3>Source</h3>

<p>Stefan Roediger
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the 
Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. 
Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMiQ5_melt)

tmp &lt;- VIMiQ5_melt

plot(NA, NA, xlim = c(55,95), ylim = c(0, 40000), 
    xlab = "Temperature (degrees Celsius)",ylab = "RFU", 
    main = "Melting curve in iQ5 (Bio-Rad)")
apply(tmp[, 2:ncol(tmp)], 2, 
      function(x) lines(tmp[1:nrow(tmp),1],x))

Fmean &lt;- rowMeans(tmp[, 2:ncol(tmp)])
lines(tmp[1:nrow(tmp),1], Fmean, col = "red", lwd = 3)

legend(55, 4000, c("Raw", "Mean"), pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='CPP'>
Curve Pre-processor
</h2><span id='topic+CPP'></span><span id='topic+CPP.numeric'></span><span id='topic+CPP.matrix'></span><span id='topic+CPP.data.frame'></span><span id='topic+CPP+2Cnumeric+2Cnumeric-method'></span><span id='topic+CPP+2Cmatrix+2Cmissing-method'></span><span id='topic+CPP+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+CPP">CPP</a></code> encompasses a set of functions to 
pre-process an amplification curve. The pre-processing includes options to 
normalize curve data, to remove background, to remove outliers
in the background range and to test if an amplification is significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
CPP(x, y, smoother = TRUE, method = "savgol", 
				trans = FALSE, method.reg = "lmrob", 
				bg.outliers = FALSE, median = FALSE, 
				method.norm = "none", qnL = 0.03, amptest = FALSE, 
				manual = FALSE, nl = 0.08, bg.range = NULL, ...)

## S4 method for signature 'matrix,missing'
CPP(x, y, smoother = TRUE, method = "savgol", 
			       trans = FALSE, method.reg = "lmrob", 
			       bg.outliers = FALSE, median = FALSE, 
			       method.norm = "none", qnL = 0.03, amptest = FALSE, 
			       manual = FALSE, nl = 0.08, bg.range = NULL, ...)

## S4 method for signature 'data.frame,missing'
CPP(x, y, smoother = TRUE, 
				   method = "savgol", trans = FALSE, 
				   method.reg = "lmrob", bg.outliers = FALSE, 
				   median = FALSE, method.norm = "none", 
				   qnL = 0.03, amptest = FALSE, 
				   manual = FALSE, nl = 0.08, bg.range = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPP_+3A_x">x</code></td>
<td>

<p>is a vector containing the time or cycle values or a matrix or data frame
containing both time or cycle values and fluorescence.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_y">y</code></td>
<td>

<p>is a vector containing the fluorescence values. Omitted if 
<code>x</code> 
is a data frame or matrix.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_smoother">smoother</code></td>
<td>

<p>logical parameter which indicates if smoother should be used.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_method">method</code></td>
<td>

<p>a vector of names defining which smoothing method 
should be used. The Savitzky-Golay smoothing filter is the default 
smoother. Use &quot;lowess&quot; for LOWESS smoother (locally-weighted polynomial 
regression), &quot;mova&quot; for moving average, &quot;savgol&quot; for Savitzky-Golay 
smoothing filter, &quot;smooth&quot; for cubic spline smooth, &quot;spline&quot; for standard 
cubic spline smooth, &quot;supsmu&quot; for Friedman's SuperSmoother, &quot;whit1&quot; for 
weighted Whittaker smoothing with a first order finite difference penalty, 
&quot;whit2&quot; for weighted Whittaker smoothing with a second order finite 
difference penalty or &quot;all&quot; for all implemented smoothing algorithms. 
</p>
</td></tr>
<tr><td><code id="CPP_+3A_trans">trans</code></td>
<td>

<p>defines if the slope of the background range in a curve should be 
corrected by a linear regression.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_method.reg">method.reg</code></td>
<td>

<p>defines the method (&quot;rfit&quot;, &quot;lmrob&quot;, &quot;rq&quot;) for the robust linear 
regression. If equal to &quot;least&quot;, <code>CPP</code> uses linear regression.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_bg.outliers">bg.outliers</code></td>
<td>

<p>is a logical argument which to remove outliers in the background 
range.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_median">median</code></td>
<td>

<p>If set to TRUE, median is used instead of mean in outlier 
replacement.  The mean is used by default.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_method.norm">method.norm</code></td>
<td>

<p>is a argument to use a &quot;none&quot;, &quot;minm&quot;, &quot;max&quot;, &quot;lugn&quot;, or
&quot;zscore&quot; normalization.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_qnl">qnL</code></td>
<td>

<p>is the quantile to be used for the quantile normalization.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_amptest">amptest</code></td>
<td>

<p>is a logical operator which is used to set a test for a positive 
amplification.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_manual">manual</code></td>
<td>

<p>is used to test for a fixed threshold value of the background.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_nl">nl</code></td>
<td>

<p>is a value used as fixed threshold value for the background.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_bg.range">bg.range</code></td>
<td>

<p>is a <code>numeric</code> vector of length 2 pointing the background range.
If <code>NULL</code>, the background range is calculated by <code><a href="#topic+bg.max">bg.max</a></code> function.
</p>
</td></tr>
<tr><td><code id="CPP_+3A_...">...</code></td>
<td>

<p>dot operator for diverse arguments of 
<code><a href="#topic+smoother">smoother</a></code> for details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+CPP">CPP</a></code> uses the <code><a href="#topic+bg.max">bg.max</a></code> function to estimate automatically the start of the 
amplification process. In the background range there is often noise which 
makes it harder to determine a meaningful background value. Therefore 
<code><a href="#topic+CPP">CPP</a></code> can optionally remove outliers by finding the 
value with largest difference from the mean as provided by the 
<code><a href="outliers.html#topic+rm.outlier">rm.outlier</a></code> function. This function also tries to 
prevent calculations of non amplified signals. 
</p>
<p>The slope of the background range is often unequal to 
zero. By setting the parameter <code>trans</code> it is possible to apply a 
simple correction of the slope. Thereby either a robust linear regression 
by computing MM-type regression estimators, a nonparametric rank-based 
estimator or a standard linear regression model. Care is needed when 
using 
<code>trans</code> with time series (see <code><a href="stats.html#topic+lm">lm</a></code> for details).
</p>


<h3>Value</h3>

<p>A <code>list</code> where each element represents the pre-process data and parameters 
for the background region (BG) of a qPCR experiment.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

 
<p>Normalization: <code><a href="#topic+normalizer">normalizer</a></code>
</p>
<p>Smoothing: <code><a href="#topic+smoother">smoother</a></code>
</p>
<p>Robust linear regression: <code><a href="#topic+lm.coefs">lm.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function to pre-process an amplification curve.
# Take a subset of the C17 data frame.
data(C17)
default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,1))
plot(NA, NA, xlab = "Time [sec]", ylab = "refMFI", 
     main = "HDA Raw Data", 
     xlim = c(0, 2500), ylim = c(0,1.1), pch = 20)
for (i in 3:5) {
  lines(C17[1:50, 1], C17[1:50, i], col = i - 2, 
	type = "b", pch = 20)
}

legend(50, 0.5, c("55 degrees Celsius", "60 degrees Celsius", "65 degrees Celsius"), 
	col = c(1,2,3), pch = rep(20,3))

# Use CPP to pre-process the data by removing the missing value and 
# normalization of the data
plot(NA, NA, xlab = "Time [sec]", ylab = "refMFI", 
     main = "Curve Pre-processor Applied to HDA Data", 
     xlim = c(0, 2500), ylim = c(0,1.1), pch = 20)
for (i in 3:5) {
  y.cpp &lt;- CPP(C17[2:50, 1], C17[2:50, i], method.norm = "minm", 
	      bg.outliers = TRUE)$y.norm
  lines(C17[2:50, 1], y.cpp, col = i - 2, 
	type = "b", pch = 20)
}
legend(50, 1, c("55 degrees Celsius", "60 degrees Celsius", "65 degrees Celsius"), 
	col = c(1,2,3), pch = rep(20,3))

par(default.par)
</code></pre>

<hr>
<h2 id='der'>Class <code>"der"</code></h2><span id='topic+der'></span><span id='topic+der-class'></span><span id='topic+show.der'></span><span id='topic+show+2Cder-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+inder">inder</a></code> function.
</p>


<h3>Value</h3>

<p>A class for a <code>matrix</code> of derivatives from amplifications curve 
data of a qPCR experiment.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"matrix"</code> is a matrix containing smoothed data as well as
the first and second derivative.</p>
</dd>
<dt><code>method</code>:</dt><dd><p><code>"character"</code> used method of smoothing.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "der")</code>: calculates and prints approximate first
derivative maximum, second derivative maximum, second derivative minimum and second
derivative center. See <code><a href="#topic+summary.der">summary.der</a></code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "der")</code>: prints only <code>.Data</code> slot of the
object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inder">inder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcr &lt;- AmpSim(cyc = 1:40)
res &lt;- inder(pcr[, 1], pcr[, 2])
sums &lt;- summary(res)
print(sums)
</code></pre>

<hr>
<h2 id='eff'>Class <code>"eff"</code></h2><span id='topic+eff-class'></span><span id='topic+eff'></span><span id='topic+show.eff'></span><span id='topic+show+2Ceff-method'></span><span id='topic+summary.eff'></span><span id='topic+summary+2Ceff-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+effcalc">effcalc</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"matrix"</code> containing the &quot;Concentration&quot;, &quot;Location&quot; 
(mean, median), &quot;Deviation&quot; (standard deviation, median absolute 
deviation), &quot;Coefficient of Variance&quot; (CV, RSD) sequential in the 
columns.</p>
</dd>
<dt><code>amplification.efficiency</code>:</dt><dd> <p><code>"numeric"</code> value representing 
amplification efficiency.</p>
</dd>
<dt><code>regression</code>:</dt><dd> <p><code>"lm"</code> the results of the linear regression and .</p>
</dd>
<dt><code>correlation.test</code>:</dt><dd> <p><code>"htest"</code>. the correlation test 
(Pearson) results.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "eff")</code>: plots calculated efficiency. 
See <code><a href="#topic+plot.eff">plot.eff</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "eff")</code>: prints only <code>.Data</code> slot of the
object.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "eff")</code>: prints information about object 
prettier than <code>show</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+effcalc">effcalc</a></code>, <code><a href="#topic+plot.eff">plot.eff</a></code>,
</p>

<hr>
<h2 id='Eff1000'>
Highly Replicate Number Amplification Curves
</h2><span id='topic+Eff1000'></span>

<h3>Description</h3>

<p>Highly replicate number amplification curves with an approximate amplification 
efficiency of 100 percent at cycle number 18. The data were derived from a 
simulation such as the AmpSim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Eff1000)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 (Cycles) observations on the following 1000 
(amplification curves) variables. The columns are all replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Eff1000)

plot(NA, NA, xlim = c(1,40), ylim = c(0,max(Eff1000)), xlab = "Cycle",
    ylab = "RFU", 
    main = "Amplification Curves with 100 Percent Efficiency")
apply(Eff1000[, 1:ncol(Eff1000)], 2, function(x) lines(1:40,x))

Fmean &lt;- rowMeans(Eff1000[, 1:ncol(Eff1000)])
lines(1:40, Fmean, col = "red", lwd = 3)

legend(1, quantile(unlist(Eff1000), 0.9), c("Raw", "Mean"), 
	pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='Eff625'>
Highly Replicate Number Amplification Curves
</h2><span id='topic+Eff625'></span>

<h3>Description</h3>

<p>Highly replicate number amplification curves with an approximate amplification 
efficiency of 62.5 percent at cycle number 18. The data were derived from a 
simulation such as the AmpSim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Eff625)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 (Cycles) observations on the following 1000 
(amplification curves) variables. The columns are all replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Eff625)

plot(NA, NA, xlim = c(1,40), ylim = c(0,max(Eff625)), xlab = "Cycle",
    ylab = "RFU", 
    main = "Amplification Curves with 62.5 Percent Efficiency")
apply(Eff625[, 1:ncol(Eff625)], 2, function(x) lines(1:40,x))

Fmean &lt;- rowMeans(Eff625[, 1:ncol(Eff625)])
lines(1:40, Fmean, col = "red", lwd = 3)

legend(1, quantile(unlist(Eff625), 0.9), c("Raw", "Mean"), 
      pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='Eff750'>
Highly Replicate Number Amplification Curves
</h2><span id='topic+Eff750'></span>

<h3>Description</h3>

<p>Highly replicate number amplification curves with an approximate amplification 
efficiency of 75 percent at cycle number 18. The data were derived from a 
simulation such as the AmpSim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Eff750)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 (Cycles) observations on the following 1000 
(amplification curves) variables. The columns are all replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Eff750)

plot(NA, NA, xlim = c(1,40), ylim = c(0,max(Eff750)), xlab = "Cycle",
    ylab = "RFU", 
    main = "Amplification Curves with 75 Percent Efficiency")
apply(Eff750[, 1:ncol(Eff750)], 2, function(x) lines(1:40,x))

Fmean &lt;- rowMeans(Eff750[, 1:ncol(Eff750)])
lines(1:40, Fmean, col = "red", lwd = 3)

legend(1, quantile(unlist(Eff750), 0.9), c("Raw", "Mean"), 
	pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='Eff875'>
Highly Replicate Number Amplification Curves
</h2><span id='topic+Eff875'></span>

<h3>Description</h3>

<p>Highly replicate number amplification curves with an approximate amplification 
efficiency of 87.5 percent at cycle number 18. The data were derived from a 
simulation such as the AmpSim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Eff875)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 (Cycles) observations on the following 1000 
(amplification curves) variables. The columns are all replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Eff875)

plot(NA, NA, xlim = c(1,40), ylim = c(0,max(Eff875)), xlab = "Cycle",
    ylab = "RFU", 
    main = "Amplification Curves with 87.5 Percent Efficiency")
apply(Eff875[, 1:ncol(Eff875)], 2, function(x) lines(1:40,x))

Fmean &lt;- rowMeans(Eff875[, 1:ncol(Eff875)])
lines(1:40, Fmean, col = "red", lwd = 3)

legend(1, quantile(unlist(Eff875), 0.9), c("Raw", "Mean"), 
	pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='effcalc'>
Analysis of the amplification efficiency
</h2><span id='topic+effcalc'></span><span id='topic+effcalc.numeric'></span><span id='topic+effcalc.matrix'></span><span id='topic+effcalc.data.frame'></span><span id='topic+effcalc+2Cnumeric+2Cnumeric-method'></span><span id='topic+effcalc+2Cmatrix+2Cmissing-method'></span><span id='topic+effcalc+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p>effcalc calculates the amplification efficiency of a dilution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
effcalc(x, y, logx = TRUE, RSD = FALSE, rob = FALSE,
                                    level = 0.95)
## S4 method for signature 'matrix,missing'
effcalc(x, y, logx = TRUE, RSD = FALSE, rob = FALSE,
                                   level = 0.95)
## S4 method for signature 'matrix,missing'
effcalc(x, y, logx = TRUE, RSD = FALSE, rob = FALSE,
                                   level = 0.95)        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effcalc_+3A_x">x</code></td>
<td>
<p> is the column of a data frame for the concentration 
(dilution). </p>
</td></tr>
<tr><td><code id="effcalc_+3A_y">y</code></td>
<td>
<p> are multiple columns of Cq values from a 
<code>data.frame</code> (e.g., [, c(1:n)]). </p>
</td></tr>
<tr><td><code id="effcalc_+3A_logx">logx</code></td>
<td>
<p> is a logical parameter used to convert the concentration 
into a decadic logarithm. </p>
</td></tr>
<tr><td><code id="effcalc_+3A_rsd">RSD</code></td>
<td>
<p> Setting the option <code>RSD = TRUE</code> shows the relative 
standard deviation (RSD) in percent. </p>
</td></tr>
<tr><td><code id="effcalc_+3A_rob">rob</code></td>
<td>
<p> Using the option <code>rob</code> as TRUE the median and the median 
absolute deviation (MAD) is plotted instead of the mean and standard 
deviation. </p>
</td></tr>
<tr><td><code id="effcalc_+3A_level">level</code></td>
<td>
<p> Tolerance/confidence level. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the class <code><a href="#topic+eff-class">eff</a></code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>
<p>S. Mehra and W.-S. Hu. A kinetic model of quantitative real-time polymerase 
chain reaction. <em>Biotechnology and bioengineering</em>, 91(7):848&ndash;860, 
Sept. 2005. ISSN 0006-3592. doi: 10.1002/bit.20555. PMID: 15986490.
</p>
<p>M. Guescini, D. Sisti, M. B. Rocchi, L. Stocchi, and V. Stocchi. A new 
real-time PCR method to overcome significant quantitative inaccuracy due to 
slight amplification inhibition. <em>BMC Bioinformatics</em>, 9(1):326, July 
2008. ISSN 1471-2105. doi: 10.1186/1471-2105-9-326. PMID: 18667053.
</p>
<p>A. Tichopad, M. Dilger, G. Schwarz, and M. W. Pfaffl. Standardized 
determination of real-time PCR efficiency from a single reaction set-up. 
<em>Nucleic Acids Research</em>, 31(20):e122, Oct. 2003. ISSN 1362-4962. 
PMID: 14530455 PMCID: PMC219490.
</p>
<p>A. Staalberg, P. Aman, B. Ridell, P. Mostad, and M. Kubista. Quantitative 
real-time PCR method for detection of b-lymphocyte monoclonality by 
comparison of kappa and lambda immunoglobulin light chain expression. 
<em>Clinical Chemistry</em>, 49(1):51&ndash;59, Jan. 2003. ISSN 0009-9147. PMID: 
12507960.
</p>
<p>W. Liu and D. A. Saint. A new quantitative method of real time reverse 
transcription polymerase chain reaction assay based on simulation of 
polymerase chain reaction kinetics. <em>Analytical Biochemistry</em>, 
302(1):52&ndash;59, Mar. 2002. ISSN 0003-2697. doi: 10.1006/abio.2001.5530. 
PMID: 11846375.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+eff-class">eff</a></code>
</p>
<p><code><a href="#topic+plot.eff">plot.eff</a></code>
</p>

<hr>
<h2 id='fixNA'>
Impute missing values into a column of amplification data
</h2><span id='topic+fixNA'></span><span id='topic+fixNA.numeric'></span><span id='topic+fixNA.matrix'></span><span id='topic+fixNA.data.frame'></span><span id='topic+fixNA+2Cnumeric+2Cnumeric-method'></span><span id='topic+fixNA+2Cmatrix+2Cmissing-method'></span><span id='topic+fixNA+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+fixNA">fixNA</a></code> imputes missing values in a single 
column of data. The imputation is based on a linear approximation by default. 
However, the data can also be estimated from an approximation by splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
fixNA(x, y, spline = TRUE, verbose = FALSE)
## S4 method for signature 'matrix,missing'
fixNA(x, y, spline = TRUE, verbose = FALSE)
## S4 method for signature 'data.frame,missing'
fixNA(x, y, spline = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixNA_+3A_x">x</code></td>
<td>

<p><code>x</code> is a vector containing the time or cycle values or data frame/matrix where second 
column contains missing data.
</p>
</td></tr>
<tr><td><code id="fixNA_+3A_y">y</code></td>
<td>

<p><code>y</code> is a vector containing missing values. Used only if <code>x</code> is 
also a vector. 
</p>
</td></tr>
<tr><td><code id="fixNA_+3A_spline">spline</code></td>
<td>

<p><code>spline</code> if <code>TRUE</code> missing values are imputed by spline approximation as per 
<code><a href="stats.html#topic+spline">spline</a></code>. The default <code>FAlSE</code> is linear a approximation as 
per <code><a href="stats.html#topic+approx">approx</a></code>.
</p>
</td></tr>
<tr><td><code id="fixNA_+3A_verbose">verbose</code></td>
<td>

<p><code>verbose</code> defines if the number of missing values should be reported.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amplification data of experimental systems may contain missing values (NA). 
The NAs may be caused by detector problems, acquisition error or other 
assorted problems. There are different ways to handle missing values. One 
approach is to ignore NAs which is generally acceptable. However, in case of 
further calculation it is often necessary to handle cases of missing values in 
a way that the next calculation steps can be performed. Missing values can be 
eliminated by a imputation. Imputation encompasses various approaches. This 
includes to calculate a location parameter (e.g., mean, median) or other 
significant values (e.g., minimum, maximum, modus) of a data column. However, 
in non-linear processes such as amplification processes its is better to 
estimate the missing values from a trend. <code><a href="#topic+fixNA">fixNA</a></code> was empirically tested and relies on a linear 
trend estimation based on the <code><a href="stats.html#topic+approx">approx</a></code> function. This 
approach is useful but may be problematic on the phases other then background 
or plateau phases of an amplification reaction. The parameter 
<code><a href="stats.html#topic+spline">spline</a></code> on <code><a href="#topic+fixNA">fixNA</a></code> enables a trend 
estimation on splines and may be more appropriate in most scenarios. Other 
smoothing functions such as the Savitzky-Golay smoothing filter have the 
intrinsic capability to remove missing values [Savitzky and Golay 1964, 
Eilers 2003].
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Eilers, P. H. C. Anal. Chem. 2003, 75, 3631&ndash;3636.
Savitzky, A.; Golay, M. J. E. Anal. Chem. 1964, 36, 1627&ndash;1639  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a qPCR reaction with AmpSim with for 40 cycles
res &lt;- AmpSim(cyc = c(1:40))
# Introduce a missing value in the transition between 
# the background and the exponential phase
res.NA &lt;- res
res.NA[18, 2] &lt;- NA

default.par &lt;- par(no.readonly = TRUE)

par(mfrow = c(2,2))
plot(res, xlab = "Cycles", ylab = "Fluorescence", type = "b", pch = 20, 
     main = "Simulation without missing value")
     abline(v = c(17.5, 18.5), col = "grey")
     abline(h = c(0.09, 0.14), col = "grey")

res.NA.linear &lt;- fixNA(res.NA[, 1], res.NA[, 2], spline = FALSE, 
		       verbose = FALSE)
plot(res.NA.linear, xlab = "Cycles", ylab = "Fluorescence", type = "b", 
     pch = 20, main = "Simulation with linear imputed\n NA 
     value during transition")
     abline(v = c(17.5, 18.5), col = "grey")
     abline(h = c(0.09, 0.14), col = "grey")

plot(res.NA, xlab = "Cycles", ylab = "Fluorescence", type = "b", pch = 20, 
     main = "Simulation with missing\n value during transition")
     abline(v = c(17.5, 18.5), col = "grey")
     abline(h = c(0.09, 0.14), col = "grey")
res.NA.spline &lt;- fixNA(res.NA[, 1], res.NA[, 2], spline = TRUE, 
		       verbose = FALSE)
plot(res.NA.spline, xlab = "Cycles", ylab = "Fluorescence", type = "b", 
      pch = 20, main = "Simulation with spline imputed\n NA value 
      during transition")
     abline(v = c(17.5, 18.5), col = "grey")
     abline(h = c(0.09, 0.14), col = "grey")     
par(default.par)
</code></pre>

<hr>
<h2 id='humanrater'>
humanrater, a graphical interface to rate curves
</h2><span id='topic+humanrater'></span>

<h3>Description</h3>

<p><code>humanrater</code> allows rating a curve for a certain characteristic in the interactive,
semi-blind manner. <code>humanrater</code> draws
individual graphs of a curve and prompts an input field for the user. This
function can be used to compare the human rating and the rating of a
machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>humanrater(x, cyc = 1, repeats = 1,
	designations = list(y = "yes", a = "ambiguous", n = "not"),
	shuffle = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="humanrater_+3A_x">x</code></td>
<td>

<p>is the input data (matrix or data.frame).
</p>
</td></tr>
<tr><td><code id="humanrater_+3A_cyc">cyc</code></td>
<td>

<p>is the index of column containing the cycle data.
</p>
</td></tr>
<tr><td><code id="humanrater_+3A_repeats">repeats</code></td>
<td>

<p>number of repeats to rate the samples.
</p>
</td></tr>
<tr><td><code id="humanrater_+3A_designations">designations</code></td>
<td>

<p>a named list of length at least 2. See Details.
</p>
</td></tr>
<tr><td><code id="humanrater_+3A_shuffle">shuffle</code></td>
<td>

<p>logical, if <code>TRUE</code> sequence of curves is shuffled for purpose of rating.
</p>
</td></tr>
<tr><td><code id="humanrater_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A user can specify the list of designations characterizing the curve, where the names of
elements specify short designations used during rating. Defaults are <code>y</code> for &quot;yes&quot;, <code>a</code>
for &quot;ambiguous&quot; and <code>n</code> for &quot;no&quot;.
The supplied designation list must have length at least two (for example &quot;true&quot;/&quot;false&quot;).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the classification and conformity of 
amplification curves as determined by a human rater.
</p>


<h3>Author(s)</h3>

<p>Michal Burdukiewicz, Stefan Roediger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata &lt;- data.frame(1:35,
			AmpSim(Cq = 15, noise = TRUE)[, 2],
			AmpSim(Cq = 25, noise = TRUE)[, 2],
			rnorm(35),
			AmpSim(Cq = 35, noise = TRUE)[, 2],
			rnorm(35),
			AmpSim(Cq = 45, noise = TRUE)[, 2])
#we strongly advise against running code below using 'example(humanrater)'
#due to the highly interactive nature of this function (it would not end
#without user's input), it is recommended to just copy lines below into R
#command line
## Not run: 
  #check testdata for significance of amplification in two repeats
  human.test1 &lt;- humanrater(testdata, repeats = 2)
  #check testdata for significance of amplification in one repeat and declare more
  #finger friendly (but less obvious) designations
  human.test2 &lt;- humanrater(testdata, repeats = 1, list(q = "yes", w = "no"))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='inder'>
Interpolate derivatives
</h2><span id='topic+inder'></span><span id='topic+inder.numeric'></span><span id='topic+inder.matrix'></span><span id='topic+inder.data.frame'></span><span id='topic+inder+2Cnumeric+2Cnumeric-method'></span><span id='topic+inder+2Cmatrix+2Cmissing-method'></span><span id='topic+inder+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p>A function <code>inder</code> (&quot;in&quot; + &quot;der&quot; = interpolate derivatives) for 
interpolating first and second derivatives using the five-point stencil. 
Therefore this function can be used to estimate the Cq (cycle of 
quantification) of an amplification curve. First positive derivative also 
known as First Derivative Maximum (FDM) and the Second Derivative Maximum 
(SDM) are calculated this way (Ruijter et al. 2013). However, from the 
mathematical point of view it can also be used to calculate the melting 
point for melting curve analysis (compare Roediger et al. 2013) provided 
that the sign of the derivative is changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inder(x, y, Nip = 4, logy = FALSE, smooth.method = "spline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inder_+3A_x">x</code></td>
<td>

<p>is a <code>numeric</code> vector of independent variable or data frame/matrix 
containing
abscissa and ordinate values.
</p>
</td></tr>
<tr><td><code id="inder_+3A_y">y</code></td>
<td>

<p>is a vector of dependent variable. Omitted if <code>x</code> is data frame or 
matrix.
</p>
</td></tr>
<tr><td><code id="inder_+3A_nip">Nip</code></td>
<td>

<p>is a value which defines how often an interpolation takes place at n 
equally 
spaced points spanning the interval (default 4). <code>Nip</code> is a such a 
resolution. A high <code>Nip</code> may improve the precision. <code>Nip</code>s less 
than 
2 and higher than 20 are not meaningful for conventional qPCR with up to 
50 cycles. However, higher <code>Nip</code>s might be appropriate for isothermal
amplification reactions.
</p>
</td></tr>
<tr><td><code id="inder_+3A_logy">logy</code></td>
<td>

<p>If <code>logy</code> is TRUE than a semi-decadic log scale graph (corresponds to 
the 
linear phase) to illustrate the exponential dynamic of the qPCR 
amplification
is used.
</p>
</td></tr>
<tr><td><code id="inder_+3A_smooth.method">smooth.method</code></td>
<td>

<p>a character vector of length 1 or <code>NULL</code> defining smoothing method used. Currently 
accepted character values: &quot;spline&quot;, &quot;supsmu&quot;. If <code>NULL</code>, smoothing is not performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>y = f(x)</code> is numerically derived using the five-point stencil. 
This method does not require any assumptions regarding the function <code>f</code>.
</p>
<p>A smoothing procedure greatly enhances calculating derivative calculation. <code>inder</code>
uses two smoothing algorithms best suited for this approach. A smoothing can
be omitted by setting <code>smooth.method</code> to <code>NULL</code>, which is advisable in case of 
the already smoothed data.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+der-class">der</a></code> class.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Ruijter JM, Pfaffl MW, Zhao S, et al. (2013) Evaluation of qPCR curve 
analysis methods for reliable biomarker discovery: bias, resolution, 
precision, and implications. <em>Methods</em> San Diego Calif 59:32&ndash;46.
</p>
<p>Surface Melting Curve Analysis with R. S. Roediger, A. Boehm and I. 
Schimke. <em>The R Journal</em>. 5(2):37&ndash;52, 2013. 
<a href="https://journal.r-project.org">https://journal.r-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
# Derive sinus
x &lt;- 1:100/10
y &lt;- sin(x)
ders &lt;- inder(x, y)
plot(x, y, type = "l")
lines(ders[, "x"], ders[, "d1y"], col = "red")
lines(ders[, "x"], ders[, "d2y"], col = "green")
legend("topright", c("f(x)", "f'(x)", "f''(x)"), lty = 1, col = c("black", 
	"red", "green"))

# Second example
# Determine the approximate second derivative maximum
# for a qPCR experiment. SDM, 
isPCR &lt;- AmpSim(cyc = 1:40)

res &lt;- inder(isPCR)

plot(isPCR, xlab = "Cycle", ylab = "RFU", ylim = c(-0.15,1),
     main = "Approximate Second Derivative Maximum (SDM)", 
     type = "b", pch = 20)

  lines(res[, "x"], res[, "d1y"], col = "blue")
  lines(res[, "x"], res[, "d2y"], col = "red")
  summ &lt;- summary(res, print = FALSE)
  abline(v = c(summ["SDM"], summ["SDm"], summ["SDC"]), col = c(3,4,5))
  text(summ["SDM"], 0.5, paste0("SDM ~ ", round(summ["SDM"], 2)), 
       cex = 1.5, col = 3)
  text(summ["SDC"], 0.7, paste0("SDC ~ ", round(summ["SDC"], 2)), 
       cex = 1.5, col = 5)
  text(summ["SDm"], 0.9, paste0("SDm ~ ", round(summ["SDm"], 2)), 
       cex = 1.5, col = 4)
  text(summ["FDM"] + 10, 0.65, paste("FDM ~ ", round(summ["FDM"], 2)), 
       cex = 1.5, col = 1)
       
  legend(1, 1, c("raw", "first derivative", "second derivative"), 
	 col = c(1,4,2), lty = c(2,1,1), cex = 1.2)
</code></pre>

<hr>
<h2 id='LAMP'>
real-time loop-mediated isothermal amplification (LAMP) by Tanner et al. (2012)
</h2><span id='topic+LAMP'></span>

<h3>Description</h3>

<p>Real-time amplification plot of a Loop-mediated isothermal amplification 
(LAMP) by Tanner et al.(2012) in a CFX96 Real Time System (Bio-Rad Laboratories, 
Hercules, CA, USA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LAMP")</code></pre>


<h3>Format</h3>

<p>A data frame with 115 observations on the following 2 variables.
</p>

<dl>
<dt><code>Time</code></dt><dd><p>Time in minutes</p>
</dd>
<dt><code>Normalized.RFU</code></dt><dd><p>RFU (Normalized)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were digitized as described by Poisot (2011). The image for 
data extraction was taken from Figure 4B by Tanner et al.(2012). For further 
experimental and technical details refer to Tanner et al.(2012).
</p>


<h3>Source</h3>

<p>The original data were taken from Figure 4B by Tanner et al.(2012).
</p>


<h3>References</h3>

<p>Poisot, T. (2011). The digitize Package: Extracting Numerical Data from 
Scatterplots. <em>The R Journal</em> 3, 25&ndash;26.
</p>
<p>Tanner, N.A., Zhang, Y., and Evans, T.C. (2012). Simultaneous multiple target 
detection in real-time loop-mediated isothermal amplification. 
<em>BioTechniques</em> 53, 81&ndash;89.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(LAMP, main = "LAMP by Tanner et al.(2012)", xlab = "Time (minutes)", 
       ylab = "RFU (Normalized)", col = "red", type = "l")
abline(h = 0.05, lty = 2, col = "grey")
legend("bottomright", c("E. coli (Cy5)"), col = "red", pch = 19)
</code></pre>

<hr>
<h2 id='lm.coefs'>
Compute linear model coefficients
</h2><span id='topic+lm.coefs'></span>

<h3>Description</h3>

<p>Computes linear model using the robust linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.coefs(x, y, method.reg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.coefs_+3A_x">x</code></td>
<td>

<p>a vector of ordinate values.
</p>
</td></tr>
<tr><td><code id="lm.coefs_+3A_y">y</code></td>
<td>

<p>a vector of abscissa values.
</p>
</td></tr>
<tr><td><code id="lm.coefs_+3A_method.reg">method.reg</code></td>
<td>

<p>defines the method (&quot;rfit&quot;, &quot;lmrob&quot;, &quot;rq&quot;, &quot;least&quot;) for the linear 
regression.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lm.coefs</code> is a convenient wrapper around few functions performing 
normal (least squares) and robust linear regression. If the robust linear 
regression is impossible, <code>lm.coefs</code> will give a warning and perform linear 
regression using the least squares method.
This function can be used to calculate the background of an amplification
curve. The coefficients of the analysis can be used for a trend based
correction of the entire data set.
</p>


<h3>Value</h3>

<p>A data frame with one column and two rows representing coefficients of the linear
model.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq">rq</a></code>, <code><a href="Rfit.html#topic+rfit">rfit</a></code>, 
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(VIMCFX96_69[, 1], VIMCFX96_69[, 2], type = "l", xlab = "Cycle", 
     ylab = "Fluorescence")
rect(1,0,10,5000)
method &lt;- c("lmrob", "rq", "least", "rfit")
for (i in 1:4) {
  tmp &lt;- lm.coefs(VIMCFX96_69[1:10, 1], VIMCFX96_69[1:10, 2], 
		  method.reg = method[i])
  abline(a = tmp[1, 1], b = tmp[2, 1], col = i + 1, lwd = 1.5)
}
legend(2, 3000, c("Data", "lmrob", "rq", "least", "rfit"), lty = 1, col = 1:5, 
       cex = 1.5)
</code></pre>

<hr>
<h2 id='MFIaggr'>
Multiple comparison of the cycle dependent variance of the fluorescence
</h2><span id='topic+MFIaggr'></span><span id='topic+MFIaggr.numeric'></span><span id='topic+MFIaggr.matrix'></span><span id='topic+MFIaggr.data.frame'></span><span id='topic+MFIaggr+2Cnumeric+2Cnumeric-method'></span><span id='topic+MFIaggr+2Cmatrix+2Cmissing-method'></span><span id='topic+MFIaggr+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p>MFIaggr is used for a fast multiple comparison of the cycle dependent 
variance of the fluorescence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
MFIaggr(x, y, cyc = 1, fluo = 2:ncol(x), 
		   RSD = FALSE, rob = FALSE, llul = c(1,10))
## S4 method for signature 'matrix,missing'
MFIaggr(x, y, cyc = 1, fluo = 2:ncol(x), 
		   RSD = FALSE, rob = FALSE, llul = c(1,10))
## S4 method for signature 'data.frame,missing'
MFIaggr(x, y, cyc = 1, fluo = 2:ncol(x), 
		   RSD = FALSE, rob = FALSE, llul = c(1,10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MFIaggr_+3A_x">x</code></td>
<td>
<p> is the column of a data frame for the cycle or data.frame/matrix with whole data.</p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_y">y</code></td>
<td>
<p> are multiple columns of fluorescence values from a 
<code>data.frame</code> (e.g., [, c(1:n)]). </p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_cyc">cyc</code></td>
<td>
<p> is the index of column containing the cycle data. 
Used only if <code>y</code> is missing.</p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_fluo">fluo</code></td>
<td>
<p> are the columns containing the fluorescence data. 
Used only if <code>y</code> is missing.</p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_rsd">RSD</code></td>
<td>
<p> Setting the option <code>RSD = TRUE</code> shows the relative 
standard deviation (RSD) in percent. </p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_rob">rob</code></td>
<td>
<p> Using the option <code>rob</code> as TRUE the median and the 
median 
absolute deviation (MAD) are calculated instead of the mean and standard 
deviation. </p>
</td></tr>
<tr><td><code id="MFIaggr_+3A_llul">llul</code></td>
<td>
<p> is a parameter to define the lower and upper 
data limit (cycle), aka region of interest (ROI) used for the density 
and quantile plot. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code><a href="#topic+refMFI-class">refMFI</a></code>. refMFI means referenced 
Mean Fluorescence Intensity (Roediger et al. 2013).
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First Example
# Cycle dependent variance of the refMFI using standard measures 
# (Mean, Standard Deviation (SD)).
# Use Standard Deviation (SD) in the plot

data(VIMCFX96_60)

MFIaggr(VIMCFX96_60[, 1], VIMCFX96_60[, 2:ncol(VIMCFX96_60)])

#alternative usage
MFIaggr(VIMCFX96_60)

#only second and forth column
plot(MFIaggr(VIMCFX96_60, fluo = c(2, 4)))

# Example
# Use of MFIaggr to test for heteroskedasticity using the Breusch-Pagan 
# test. The data were aggregated with the MFIaggr function and assigned to
# the object res. The standard deviation was transformed to the variance.
# The plot shows the cycle dependent variance.
# First cycles 1 to 10 of 96 qPCR replicate amplification curves were
# analyzed. Next the cycles 1 to 40 of the same amplification curve data 
# were analyzed. The Breusch-Pagan confirmed the heteroskedasticity in the
# amplification curve data.

default.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2), bty = "n")
res &lt;- MFIaggr(VIMCFX96_60[, 1], VIMCFX96_60[, 2:ncol(VIMCFX96_60)], 
	       llul = c(1,10))
head(res)
plot(res[, 1], res[, 3]^2, xlab = "Cycle", ylab = "Variance of refMFI", 
     xlim = c(1,10), main = "ROI from Cycle 1 to 10", pch = 19, type = "b")
abline(v = c(1,10), col = "grey", lty = 2, lwd = 2)
legend("top", paste0("Breusch-Pagan test p-value: \n", format(summary(res)[5], 
       digits = 2)), bty = "n")

res &lt;- MFIaggr(VIMCFX96_60[, 1], VIMCFX96_60[, 2:ncol(VIMCFX96_60)], 
	       llul = c(1,40))
head(res)
plot(res[, 1], res[, 3]^2, xlab = "Cycle", ylab = "Variance of refMFI", 
     main = "ROI from Cycle 1 to 40", pch = 19, type = "b")
abline(v = c(1,40), col = "grey", lty = 2, lwd = 2)
legend("top", paste0("Breusch-Pagan test p-value: \n", format(summary(res)[5], 
       digits = 2)), bty = "n")
par(default.par)
</code></pre>

<hr>
<h2 id='MFIaggr.gui'>
Multiple Comparison of the Cycle Dependent Variance - Graphical User 
Interface
</h2><span id='topic+MFIaggr.gui'></span>

<h3>Description</h3>

<p><code>MFIaggr.gui</code> is a Graphical User Interface based on the <code>shiny</code> 
package. The core if this GUI is based on the Comparison of the 
<code><a href="#topic+MFIaggr">MFIaggr</a></code> function. The cycle dependent variance can
be analyzed intuitively. This GUI dynamically generates reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFIaggr.gui()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Warning </h3>

<p>Any ad-blocking software may be cause of malfunctions. 
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFIaggr">MFIaggr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The code chunk below will fail if the web browser is not installed. if on UNIX platform try:
# as.vector(Sys.getenv("R_BROWSER"))
# Invoke the shiny AmpSim app in the default browser
## Not run: 
#do not execute using example(), it breaks the sequence of the plots in shiny app
MFIaggr.gui()

## End(Not run)

</code></pre>

<hr>
<h2 id='normalizer'>
Normalize data
</h2><span id='topic+normalizer'></span>

<h3>Description</h3>

<p><code>normalizer</code> normalizes any data set using a chosen method (see Details). 
It may be used when the data from an experiment have considerable variation regarding the 
background and plateau signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizer(y, method.norm = "none", qnL = 0.03)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizer_+3A_y">y</code></td>
<td>

<p>is a vector containing the fluorescence values.
</p>
</td></tr>
<tr><td><code id="normalizer_+3A_method.norm">method.norm</code></td>
<td>

<p>is a argument to use a &quot;none&quot;, &quot;minm&quot;, &quot;max&quot;, &quot;luqn&quot;, or
&quot;zscore&quot; normalization. See Details.
</p>
</td></tr>
<tr><td><code id="normalizer_+3A_qnl">qnL</code></td>
<td>

<p>is the quantile to be used for the quantile normalization. Ignored if 
<code>method.norm</code> is not equal to &quot;luqn&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>qnL</code> is 
a user defined quantile which is used for the quantile normalization. A 
quantile normalization herein refers to an approach which is less prone to 
outliers than a normalization based on the minimum and the maximum of an 
amplification curve.
<code>minm</code> does a min-max normalization between 0 and 1 (see Roediger et al. 
2013 for explanation).
<code>max</code> does a normalization to the maximum value (MFI/max(MFI)).
<code>luqn</code> does a quantile normalization based on a symmetric proportion 
as defined by the <code>qnL</code> parameter (e.g., qnL = 0.03 equals 3 and 97 
percent quantiles).
<code>zscore</code> performs a z-score normalization with a mean of 0 and a 
standard deviation of 1.
</p>


<h3>Value</h3>

<p>A vector of normalized fluorescence values.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Surface Melting Curve Analysis with R. S. Roediger, A. Boehm and I. 
Schimke. <em>The R Journal</em>. 5(2):37&ndash;52, 2013. 
<a href="https://journal.r-project.org">https://journal.r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CPP">CPP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalizer(C17[2L:50, 1], "minm")
</code></pre>

<hr>
<h2 id='plot.bg'>
Plot <code>bg</code> objects
</h2><span id='topic+plot.bg'></span><span id='topic+plot+2Cbg-method'></span><span id='topic+plot+2Cbg+2CANY-method'></span>

<h3>Description</h3>

<p>Draws diagnostic plots of amplification reaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bg'
plot(x, what = 1:3, add = FALSE, indicators = TRUE, 
		    legend = TRUE, stan.labs = TRUE, 
		    plot.colors = c("black", "red", "blue"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bg_+3A_x">x</code></td>
<td>

<p>is a <code><a href="#topic+bg-class">bg</a></code> object.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_what">what</code></td>
<td>

<p>is a vector specifying what should be plotted. <code>1</code> means raw data, 
<code>2</code> means first derivative and <code>3</code> means second derivative. Any 
combination of mentioned values is valid, for example: c(1,2), c(1, 2, 3), 
c(2, 3). See Details and Examples.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_add">add</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>TRUE</code>, plot is added to existing 
plot. Moreover, enforces <code>indicators</code> = <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_indicators">indicators</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>FALSE</code>, background start, stop and 
plateau transition indication lines aren't plotted.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_legend">legend</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>TRUE</code>, legend is added to the 
plot.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_stan.labs">stan.labs</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>TRUE</code>, standard axis labels 
(&quot;Cycle&quot; and &quot;Fluorescence&quot;) are added.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_plot.colors">plot.colors</code></td>
<td>

<p>is a vectors of colors used in plot. Must have length 3.
</p>
</td></tr>
<tr><td><code id="plot.bg_+3A_...">...</code></td>
<td>

<p>Arguments to be passed further to the plot function, such as graphical 
parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.bg</code> is simplified, ready-to-use version of 
<code><a href="#topic+plot.der">plot.der</a></code>, which still can be used whenever more 
flexible function is needed.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bg-class">bg</a></code>, <code><a href="#topic+plot.der">plot.der</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#step-by-step plotting bg object

res &lt;- AmpSim(cyc = 1:40, Cq = 25)
background &lt;- bg.max(res)

plot(background)

#above is equivalent of below
plot(rounder(inder(res)), xlab = "Cycles", 
     ylab = "Fluorescence",
     pch = 20, legend = FALSE)

abline(v = slot(background, "bg.start"))
  text(slot(background, "bg.start"), 0.2, "Background start", pos = 4)
abline(v = slot(background, "bg.stop"), col = "blue")
  text(slot(background, "bg.stop"), 0.25, "Background stop", pos = 4, 
       col = "blue")
abline(v = slot(background, "amp.stop"), col = "green")
  text(slot(background, "amp.stop"), 0.3, "Plateau transition", pos = 4, 
       col = "green")
legend(4, 1, c("Raw data", "First derivative", "Second derivative"), 
       pch = rep(20, 3), col = c(1, 2, 4))

</code></pre>

<hr>
<h2 id='plot.der'>
Plot <code>der</code> objects
</h2><span id='topic+plot.der'></span><span id='topic+plot+2Cder-method'></span><span id='topic+plot+2Cder+2CANY-method'></span>

<h3>Description</h3>

<p>Plots interpolated derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'der'
plot(x, what = 1:3, add = FALSE, legend = TRUE, 
        plot.colors = c("black", "red", "blue"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.der_+3A_x">x</code></td>
<td>

<p>is a <code><a href="#topic+der-class">der</a></code> object.
</p>
</td></tr>
<tr><td><code id="plot.der_+3A_what">what</code></td>
<td>

<p>is a vector specifying what should be plotted. <code>1</code> means raw data, 
<code>2</code> means first derivative and <code>3</code> means second derivative. Any 
combination of mentioned values is valid, for example: c(1,2), c(1, 2, 3), 
c(2, 3). See Details and Examples.
</p>
</td></tr>
<tr><td><code id="plot.der_+3A_add">add</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>TRUE</code>, plot is added to existing 
plot.
</p>
</td></tr>
<tr><td><code id="plot.der_+3A_legend">legend</code></td>
<td>

<p>is a <code>"logical"</code> argument. If <code>TRUE</code>, legend is added to the 
plot.
</p>
</td></tr>
<tr><td><code id="plot.der_+3A_plot.colors">plot.colors</code></td>
<td>

<p>is a vectors of colors used in plot. Must have length 3 for the original function, first, 
and second derivative, respectively.
</p>
</td></tr>
<tr><td><code id="plot.der_+3A_...">...</code></td>
<td>

<p>Arguments to be passed further to the plot function, such as graphical 
parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+der-class">der</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- inder(AmpSim(cyc = 1:40, Cq = 25))
plot(res)
#round the result of inder
plot(rounder(res))

</code></pre>

<hr>
<h2 id='plot.eff'>
Plot <code>eff</code> objects
</h2><span id='topic+plot.eff'></span><span id='topic+plot+2Ceff-method'></span><span id='topic+plot+2Ceff+2CANY-method'></span>

<h3>Description</h3>

<p>Draws diagnostic plots of the amplification efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'eff'
plot(x, xlab = "log10(Concentration)", 
                     ylab = "Cq", main = "Efficiency Plot", 
                     trend = TRUE, res.fit = "topright", CI = FALSE, 
                     level = 0.95, type = "p", pch = 19, 
                     er.length = 0.05, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.eff_+3A_x">x</code></td>
<td>

<p>is a <code><a href="#topic+eff-class">eff</a></code> object. 
</p>
</td></tr>
<tr><td><code id="plot.eff_+3A_xlab">xlab</code></td>
<td>
<p> a title for the x axis. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_ylab">ylab</code></td>
<td>
<p> a title for the y axis. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_main">main</code></td>
<td>
<p> an overall title for the plot. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_trend">trend</code></td>
<td>
<p> Setting the option <code>trend = TRUE</code> shows the linear 
regression line in the plot. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_res.fit">res.fit</code></td>
<td>
<p> If <code>res.fit</code> sets where the results (goodness of fit, amplification 
efficiency, correlation ) of the linear regression line in the plot should be plotted.
Accepts the same location keywords as <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plot.eff_+3A_ci">CI</code></td>
<td>
<p> Setting the option <code>CI = TRUE</code> shows the confidence
interval lines in the plot. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_level">level</code></td>
<td>
<p> Tolerance/confidence level. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_type">type</code></td>
<td>
<p> is a graphical parameter setting the plot use lines, points 
or both (see <code><a href="base.html#topic+plot">plot</a></code>). </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_pch">pch</code></td>
<td>
<p> is a graphical parameter used to define the symbol used in 
the plot. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_er.length">er.length</code></td>
<td>
 <p><code>length</code> is a graphical parameter used to define the 
length of the error bar used in the plot. </p>
</td></tr>
<tr><td><code id="plot.eff_+3A_col">col</code></td>
<td>
 <p><code>col</code> is a graphical parameter used to define the color of the points
on the plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot being a result of this function is built from three subplots.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eff-class">eff</a></code>
</p>

<hr>
<h2 id='plot.refMFI'>
Plot <code>refMFI</code> objects
</h2><span id='topic+plot.refMFI'></span><span id='topic+plot+2CrefMFI-method'></span><span id='topic+plot+2CrefMFI+2CANY-method'></span><span id='topic+plot+2CrefMFI+2CrefMFI-method'></span>

<h3>Description</h3>

<p>Draw quick diagnostic plots of amplification reaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'refMFI'
plot(x, CV = FALSE, type = "p", pch = 19, length = 0.05, 
                        col = "black")
## S4 method for signature 'refMFI,refMFI'
plot(x, y, CV = FALSE, type = "p", pch = 19, length = 0.05, 
                        col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.refMFI_+3A_x">x</code></td>
<td>

<p>is a <code><a href="#topic+refMFI-class">refMFI</a></code> object. refMFI means referenced Mean Fluorescence Intensity (Roediger et al. 2013)
</p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_y">y</code></td>
<td>

<p>optionally an additional <code><a href="#topic+refMFI-class">refMFI</a></code> object.
</p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_cv">CV</code></td>
<td>
<p> If <code>CV</code> is true the coefficient of variation (RSD, CV) is 
plotted. If set to <code>FALSE</code> the deviation as Standard Deviation or 
Median Absolute Deviation is plotted. </p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_type">type</code></td>
<td>
<p> is a graphical parameter setting the plot use lines, points 
or both (see <code><a href="base.html#topic+plot">plot</a></code>). </p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_pch">pch</code></td>
<td>
<p> is a graphical parameter used to define the symbol used in 
the plot. </p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_length">length</code></td>
<td>
 <p><code>length</code> is a graphical parameter used to define the 
length of the error bar used in the plot. </p>
</td></tr>
<tr><td><code id="plot.refMFI_+3A_col">col</code></td>
<td>
 <p><code>col</code> is a graphical parameter used to define the length 
of the error bar used in the plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a relative of the MFIerr function from the MBmca package 
(Roediger et al. 2013, The R Journal). The plot being a result of this 
function is built from three subplots. If <code>y</code> parameter is
not absent, it is plotted in lighter color than <code>x</code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+refMFI-class">refMFI</a></code>
</p>

<hr>
<h2 id='plotCurves'>
Plot Curves in an Orthogonal Matrix
</h2><span id='topic+plotCurves'></span>

<h3>Description</h3>

<p>Plots many curves on one plot in table-like fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCurves(x, y, cyc = 1, fluo = 2:ncol(x), one.plot = FALSE, 
           nrow = ceiling(sqrt(ncol(y))), CPP = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCurves_+3A_x">x</code></td>
<td>
<p> is the column of a data frame for the cycle or data.frame/matrix with whole data.</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_y">y</code></td>
<td>
<p> are multiple columns of fluorescence values from a 
<code>data.frame</code> (e.g., [, c(1:n)]).</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_cyc">cyc</code></td>
<td>
<p> is the index of column containing the cycle data. 
Used only if <code>y</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_fluo">fluo</code></td>
<td>
<p> are the columns containing the fluorescence data. 
Used only if <code>y</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_one.plot">one.plot</code></td>
<td>
 <p><code>logical</code>, curves may be plotted on single chart (<code>TRUE</code>)
or in matrix-like multiplot (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_nrow">nrow</code></td>
<td>

<p>number of rows in plot. Applies only if <code>one.plot</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_cpp">CPP</code></td>
<td>

<p>logical, if <code>TRUE</code> CPP analysis is added to a plot. Ignored if <code>one.plot</code> is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plotCurves_+3A_...">...</code></td>
<td>

<p>additional arguments to <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotCurves</code> is a function for the quick assessment of amplification 
curve raw data in an orthogonal matrix.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz, Konstantin A. Blagodatskikh
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
plotCurves(VIMCFX96_60[, 1], VIMCFX96_60[, 2L:16], type = "l")

# Second example
y &lt;- VIMCFX96_60[, 2L:16]
# Introduce some missing values.
y[c(1,4,5,6,23,34), c(2,4,9,15)] &lt;- NA
plotCurves(VIMCFX96_60[, 1], y, nrow = 4, type = "l")

# Third example
# Same as second example but the CPP option is set to TRUE.
# Noise and missing values will be removed. 

y &lt;- VIMCFX96_60[, 2L:16]
# Introduce some missing values.
y[c(1,4,5,6,23,34), c(2,4,9,15)] &lt;- NA
plotCurves(VIMCFX96_60[, 1], y, nrow = 4, CPP = TRUE, type = "l")

# Fourth example
plotCurves(VIMCFX96_60, y = NULL, one.plot = TRUE, type = "l")
plotCurves(VIMCFX96_60, y = NULL, one.plot = FALSE, type = "l")


</code></pre>

<hr>
<h2 id='refMFI'>Class <code>"refMFI"</code></h2><span id='topic+refMFI-class'></span><span id='topic+refMFI'></span><span id='topic+show+2CrefMFI-method'></span><span id='topic+qqline+2CrefMFI-method'></span><span id='topic+qqnorm+2CrefMFI-method'></span><span id='topic+show+2CrefMFI-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+MFIaggr">MFIaggr</a></code> function. 
refMFI means referenced Mean Fluorescence Intensity (Roediger et al. 2013)
</p>


<h3>Value</h3>

<p>A class for a <code>matrix</code> of amplifications curve data from a qPCR experiment.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"matrix"</code> containing the &quot;Cycle&quot;, 
&quot;Location&quot; 
(mean, median), &quot;Deviation&quot; (standard deviation, median absolute 
deviation), &quot;Coefficient of Variance&quot; (CV, RSD) sequential in the 
columns.</p>
</dd>
<dt><code>density</code>:</dt><dd><p><code>"density"</code> containing results of the 
density analysis.</p>
</dd>
<dt><code>qqnorm.data</code>:</dt><dd><p><code>"data.frame"</code> containing data required 
for 
Quantile-Quantile plots.</p>
</dd>
<dt><code>stats</code>:</dt><dd> <p><code>"numeric"</code> vector containing general 
statistics.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>qqnorm</dt><dd><p><code>signature(y = "refMFI")</code>: plots a normal QQ 
plot. 
See <code><a href="stats.html#topic+qqnorm">qqnorm</a></code></p>
</dd>
<dt>qqline</dt><dd><p><code>signature(y = "refMFI")</code>: adds a line to QQ plot. 
See <code><a href="stats.html#topic+qqline">qqline</a></code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "refMFI")</code>: plots the
object. See <code><a href="#topic+plot.refMFI">plot.refMFI</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "refMFI")</code>: prints only 
<code>.Data</code> slot of the
object.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "refMFI")</code>: prints general 
statistics and 
allows easy access to <code>stats</code> slot. See 
<code><a href="#topic+summary.refMFI">summary.refMFI</a></code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFIaggr">MFIaggr</a></code>, <code><a href="#topic+plot.refMFI">plot.refMFI</a></code>, 
<code><a href="#topic+summary.refMFI">summary.refMFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMCFX96_60)

res &lt;- MFIaggr(VIMCFX96_60)
#summarize analysis
summary(res)
#plot results of the analysis
plot(res)
#plot a QQ plot
qqnorm(res)
#add QQ line
qqline(res)
</code></pre>

<hr>
<h2 id='rounder'>
Round der objects
</h2><span id='topic+rounder'></span>

<h3>Description</h3>

<p><code><a href="#topic+inder">inder</a></code> calculates numeric derivatives on 
smoothed data which results in data points not observable in reality. The 
<code>rounder</code> function averages such result to the real values of cycle 
number.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rounder(object, cyc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rounder_+3A_object">object</code></td>
<td>

<p>a class <code><a href="#topic+der-class">der</a></code> object.
</p>
</td></tr>
<tr><td><code id="rounder_+3A_cyc">cyc</code></td>
<td>

<p>a column containing cycle numbers after smoothing. In case of objects 
created by the <code><a href="#topic+inder">inder</a></code> function, it is the first 
column.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code><a href="#topic+der-class">der</a></code> containing cycle number and 
averaged values of the fluorescence, first derivative and second 
derivative.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inder">inder</a></code>, <code><a href="#topic+der-class">der</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isPCR &lt;- AmpSim(cyc = 1:40)
res &lt;- inder(isPCR)
rd &lt;- rounder(res)
plot(rd)

</code></pre>

<hr>
<h2 id='RPA'>
Recombinase polymerase amplification (RPA) by Lutz et al.(2009)
</h2><span id='topic+RPA'></span>

<h3>Description</h3>

<p>Real-time amplification plot of an Recombinase Polymerase Amplification (RPA) 
by Lutz et al.(2009) in a centrifugal microfluidic foil cartridge. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("RPA")</code></pre>


<h3>Format</h3>

<p>A data frame with 184 observations on the following 2 variables.
</p>

<dl>
<dt><code>Reaction.Time</code></dt><dd><p>Reaction Time [min]</p>
</dd>
<dt><code>RFU</code></dt><dd><p>Relative fluorescence units [RFU]</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were digitized as described by Poisot (2011). The image for data 
extraction was taken from Figure 3b by Lutz et al.(2009). The amplification 
curve present the results of a cross-contamination test of a foil disk for a 
sample containing 2000 copies of the mecA gene. For further experimental and 
technical details refer to Lutz et al.(2009). 
</p>


<h3>Source</h3>

<p>The original data (open access under CC BY-NC-ND license) were taken from Figure 
3b by Lutz et al.(2009).
</p>


<h3>References</h3>

<p>Poisot, T. (2011). The digitize Package: Extracting Numerical Data from 
Scatterplots. <em>The R Journal</em> 3, 25&ndash;26.
</p>
<p>Lutz, S., Weber, P., Focke, M., Faltin, B., Roth, G., Piepenburg, O., Armes, 
N., Mark, D., Zengerle, R., and von Stetten, F. (2009). Isothermal Polymerase 
Amplification in a Centrifugal Microfluidic Foil Cartridge. <em>Procedia 
Chemistry</em> 1, 529&ndash;531.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RPA)
plot(RPA, main = "RPA by Lutz et al.(2009)", xlab = "Reaction Time [min]", 
     ylab = "Relative fluorescence units [RFU]", type = "l")
abline(h = 5, lty = 2, col = "grey")
</code></pre>

<hr>
<h2 id='smoother'>
Wrapper for Several Smoothers of Amplification Data
</h2><span id='topic+smoother'></span><span id='topic+smoother.numeric'></span><span id='topic+smoother.matrix'></span><span id='topic+smoother.data.frame'></span><span id='topic+smoother+2Cnumeric+2Cnumeric-method'></span><span id='topic+smoother+2Cmatrix+2Cmissing-method'></span><span id='topic+smoother+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p>Smoother is a wrapper for several smoothing functions including LOWESS, 
Moving Average, Friedman's SuperSmoother, Cubic Spline and Savitzky-Golay 
smoothing filter, Friedman's SuperSmoother, and Whittaker smoother for 
amplification curve 
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
smoother(x, y, trans = FALSE, 
		    bg.outliers = FALSE, method = "savgol", 
		    CPP = TRUE, paralell = NULL)
## S4 method for signature 'matrix,missing'
smoother(x, y, trans = FALSE, 
		    bg.outliers = FALSE, method = "savgol", 
		    CPP = TRUE, paralell = NULL)
## S4 method for signature 'data.frame,missing'
smoother(x, y, trans = FALSE, 
		    bg.outliers = FALSE, method = "savgol", 
		    CPP = TRUE, paralell = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoother_+3A_x">x</code></td>
<td>

<p><code>x</code> is a vector containing values for smoothing or data 
frame/matrix with values for smoothing. 
</p>
</td></tr>
<tr><td><code id="smoother_+3A_y">y</code></td>
<td>

<p><code>y</code> values for smoothing. Used only if <code>x</code> is also 
a vector. 
</p>
</td></tr>
<tr><td><code id="smoother_+3A_trans">trans</code></td>
<td>

<p>perform a linear transformation based on the trend of the 
background range.
</p>
</td></tr>
<tr><td><code id="smoother_+3A_bg.outliers">bg.outliers</code></td>
<td>

<p>logical parameter which indicates of outliers 
should 
be removed from background range.
</p>
</td></tr>
<tr><td><code id="smoother_+3A_method">method</code></td>
<td>

<p>a list where each element is character vector representing a smoothing 
method or a named list of additional arguments to a smoothing algorithm.
See Examples section. The Savitzky-Golay smoothing filter is the default 
smoother. Use &quot;lowess&quot; for LOWESS smoother (locally-weighted polynomial 
regression, &quot;mova&quot; for moving average, &quot;savgol&quot; for Savitzky-Golay 
smoothing filter, &quot;smooth&quot; for cubic spline smooth, &quot;spline&quot; for standard 
cubic spline smooth, &quot;supsmu&quot; for Friedman's SuperSmoother, &quot;whit1&quot; for 
weighted Whittaker smoothing with a first order finite difference penalty, 
&quot;whit2&quot; for weighted Whittaker smoothing with a second order finite 
difference penalty or &quot;all&quot; for all implemented smoothing algorithms. Both 
upper and lower case names are accepted.
</p>
</td></tr>
<tr><td><code id="smoother_+3A_cpp">CPP</code></td>
<td>

<p>logical parameter which indicates if CPP (curve 
pre-processor) should be used.
</p>
</td></tr>
<tr><td><code id="smoother_+3A_paralell">paralell</code></td>
<td>

<p>should contain a cluster object, created by package <code>parallel</code> or 
<code>snow</code> package. If <code>NULL</code>, no parallelization is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amplification curve data of experimental thermo-cyclers may deliver results 
which are hard to interpret due to noise and scatter. For data presentation 
it is often useful to smooth or filter the data prior to presentation. 
Smoothing and filtering are different approaches with a similar outcome to 
preprocess an input signal in order to make it available for an analysis 
step. Filtering uses methods of signal processing. They take a data input 
and apply a function to form an output. There are linear and non-linear 
filters. The most common example of a linear filter is the the moving 
average. A moving average filter replaces sequentially data points with the 
average of the neighbor data points. The average is calculated from a 
defined span (&quot;window&quot;) of odd count (e.g., 3, 5). The average herein may 
also refer to the median, the geometric or exponential mean. Smoothing in 
contrast uses statistical approaches. Such approaches use for example local 
regression models (e.g., least squares estimate) or cubic splines. Splines apply 
non-parametric regression by local cubic polynomials between knot points. Other 
examples for smoothers include Savitzky-Golay smoothing filter, Friedman's 
SuperSmoother, and Whittaker smoother. Several methods were integrated in the 
<code>chipPCR</code> package. A careful evaluation of this preprocessing step is of 
high importance (Spiess et al. 2014).
</p>
<p><code><a href="#topic+smoother">smoother</a></code> is a wrapper for smoother 
functions and filters commonly used to process amplification curve data. 
The <code><a href="#topic+smoother">smoother</a></code> function was enhanced by functionality 
of the <code><a href="#topic+fixNA">fixNA</a></code> and <code><a href="#topic+CPP">CPP</a></code> 
functions. The parameter &quot;lowess&quot; for LOWESS smoother (locally-weighted 
polynomial regression) can be tuned by the parameters <code>f</code> and 
<code>iter</code> (see <code><a href="stats.html#topic+lowess">lowess</a></code> for details). The parameter 
&quot;mova&quot; for moving average can be tuned by the parameter <code>movaww</code>. 
<code>movaww</code> is the window size used for the moving average (see 
<code><a href="stats.html#topic+filter">filter</a></code> for details). The parameter &quot;savgol&quot; for 
Savitzky-Golay smoothing filter can be tuned by the parameter <code>p</code> and 
<code>n</code> (see <code><a href="signal.html#topic+sgolayfilt">sgolayfilt</a></code> for details). The parameter 
&quot;smooth&quot; for cubic spline smooth can be tuned by the parameter <code>df.fact</code>. 
A <code>df.fact</code> value of 1 will leave the raw data almost unaffected while a 
value 0.5 will smooth the curve considerably. For further details refer to 
the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function. The parameter &quot;spline&quot; for 
standard cubic spline smooth has currently no additional parameter. The 
parameter &quot;supsmu&quot; for Friedman's SuperSmoother can be tuned by the 
parameter <code>span</code>. For further details refer to the 
<code><a href="stats.html#topic+supsmu">supsmu</a></code> function. The parameter &quot;lambda&quot; is used in 
Weighted Whittaker smoothing.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>
<p>Spiess, A.-N., Deutschmann, C., Burdukiewicz, M., Himmelreich, R., Klat, K., 
Schierack, P., Roediger, S., 2014. Impact of Smoothing on Parameter Estimation 
in Quantitative DNA Amplification Experiments. <em>Clinical Chemistry</em> 
clinchem.2014.230656. doi:10.1373/clinchem.2014.230656
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Results of different smoothers. A in-silico amplification was performed
# using the AmpSim function and different smoothers were applied. Optimally
# all smoothers should give the same result (which is not the case)).
# refMFI means referenced Mean Fluorescence Intensity 
# (Roediger et al. 2013)
tmp &lt;- AmpSim(cyc = 1:35, bl = 0)

plot(tmp, main = "In-silico real-time PCR\n Effect of Smoother", 
     xlab = "Cycles", ylab ="refMFI", ylim = c(0,1), pch = 20, 
     type = "b", lwd = 2)

legend(25, 0.8, c("Raw data", "savgol", "lowess", "mova 3", "mova 5", 
		  "smooth", "spline", "supsmu"), pch = 20, lwd = 2, 
		  col = c(1:8))

#else
tmp.smooths &lt;- smoother(tmp, method = list("savgol",
                                           "lowess",
                                           mova = list(movaww = 3),
                                           mova = list(movaww = 5),
                                           "smooth",
                                           "spline",
                                           "supsmu"))
for (i in 1:ncol(tmp.smooths))
  lines(tmp[, 1], tmp.smooths[, i], type = "b", pch = 20, lwd = 2, col = i 
+ 1)

default.par &lt;- par(no.readonly = TRUE)
par(fig = c(0.15,0.6,0.45,0.99), new = TRUE)
plot(tmp, main = "", xlab = "Cycles", ylab ="refMFI", 
     pch = 20, xlim = c(14,20), ylim = c(0,0.45))

for (i in 1:ncol(tmp.smooths))
  lines(tmp[, 1], tmp.smooths[, i], type = "b", pch = 20, lwd = 2, col = i 
+ 1)


# Plot the difference of the smoothed / filtered data
# to the raw data against the cycles
# The largest error is in the transition phases between
# start and end of the detectable amplification process.
par(fig = c(0,1,0,0.65))
plot(NA, NA, type = "b", col = 2, pch = 20, xlim = c(1,35), 
      ylim = c(-0.1,0.1), xlab = "Cycle", 
      ylab = "delta refMFI (raw - smoothed)", 
     main = "Smoothed / Filtered data")

legend(1.5, 0.1, ncol = 2, c("savgol", "lowess", "mova 3", "mova 5", 
	"smooth", "spline", "supsmu"), pch = 20, lwd = 2, 
	col = c(2:8))

for (i in 1:ncol(tmp.smooths))
  lines(tmp[, 1], tmp[, 2] - tmp.smooths[, i], type = "b", pch = 20, lwd = 
2, col = i + 1)

par(fig = c(0,1,0.55,1), new = TRUE)

plot(tmp, type = "b", col = 1, pch = 20, xlab = "", ylab = "RFU", 
      main = "Raw data")

#different ways of using smoother
#1. single method
single.smooth &lt;- smoother(tmp, method = list("mova"))
#single smooth, additional argument specified
single.smooth.add &lt;- smoother(tmp, method = list(mova = list(movaww = 3)))
#3. more than one smoothing method, no additional arguments specified
double.smooth &lt;- smoother(tmp, method = list("savgol", "mova"))
#4. more than one smoothing method, additional arguments specified
double.smooth.add &lt;- smoother(tmp, method = list("savgol", mova = 
list(movaww = 3)))
#5. all smoothing methods, no additional arguments specified
all.smooth &lt;- smoother(tmp, method = list("all"))
par(default.par)
</code></pre>

<hr>
<h2 id='summary-bg'>
Summary <code>bg</code> objects
</h2><span id='topic+summary.bg'></span><span id='topic+summary+2Cbg-method'></span>

<h3>Description</h3>

<p>Summarize <code><a href="#topic+bg-class">bg</a></code> objects and easily access results of 
<code><a href="#topic+bg">bg</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bg'
summary(object, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-bg_+3A_object">object</code></td>
<td>

<p>is a <code><a href="#topic+bg-class">bg</a></code> object.
</p>
</td></tr>
<tr><td><code id="summary-bg_+3A_print">print</code></td>
<td>

<p>is a <code>logical</code> value determining if pretty summary of the object 
should be printed.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bg-class">bg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- AmpSim(cyc = 1:40, Cq = 25)
background &lt;- bg.max(res[, 1], res[, 2])
#just print summary
summary(background)

#assign summary to variable without printing
vals &lt;- summary(background, print = FALSE)
print(vals)

#easily access different values
vals["FDM"]
</code></pre>

<hr>
<h2 id='summary-der'>
Summary <code>der</code> objects
</h2><span id='topic+summary.der'></span><span id='topic+summary-der'></span><span id='topic+summary+2Cder-method'></span>

<h3>Description</h3>

<p>Summarize <code><a href="#topic+der-class">der</a></code> objects and easily access results of 
<code><a href="#topic+inder">inder</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'der'
summary(object, digits = getOption("digits") - 3, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-der_+3A_object">object</code></td>
<td>

<p>is a <code><a href="#topic+der-class">der</a></code> object.
</p>
</td></tr>
<tr><td><code id="summary-der_+3A_digits">digits</code></td>
<td>

<p>is a <code>numeric</code> value determining the number of decimal places. Used 
only
for printed values. See <a href="base.html#topic+format">format</a>.
</p>
</td></tr>
<tr><td><code id="summary-der_+3A_print">print</code></td>
<td>

<p>is a <code>logical</code> value determining if pretty summary of the object 
should be printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate second derivative maximum (SDM) which is commonly used to 
quantify quantitative real-time PCR experiments. The SDM might also be 
useful for isothermal amplification processes. The SDM is calculated from a 
derived cubic spline. Similarly the first approximate approximate 
derivative maximum (FDM), second derivative minimum (SDm), and approximate 
second derivative center (SDC, geometric mean of SDM and SDm) are 
available. FDM, SDm and SDC values can be used to further characterize the 
amplification process.
</p>


<h3>Value</h3>

<p>A named vector of four elements. The element named <code>2nd_der</code> contains 
values of the second first derivative. The element named <code>SDM</code> 
contains approximate second derivative maximum, <code>SDm</code> contains 
approximate second derivative minimum, and <code>SDC</code> contains approximate 
second derivative center.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Ruijter JM, Pfaffl MW, Zhao S, et al. (2013) Evaluation of qPCR curve 
analysis methods for reliable biomarker discovery: bias, resolution, 
precision, and implications. <em>Methods</em> San Diego Calif 59:32&ndash;46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+der-class">der</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- AmpSim(cyc = 1:40, Cq = 25)
test.der &lt;- inder(res)
#just print summary
summary(test.der)
#print without rounding
summary(test.der, digits = 6)

#assign summary to variable without printing and 
vals &lt;- summary(test.der, print = FALSE)
print(vals)

#easily access different values
vals["bg.start"]
</code></pre>

<hr>
<h2 id='summary-refMFI'>
Summary <code>refMFI</code> objects
</h2><span id='topic+summary.refMFI'></span><span id='topic+summary+2CrefMFI-method'></span>

<h3>Description</h3>

<p>Summarize <code><a href="#topic+refMFI-class">refMFI</a></code> objects and access general statistics 
of amplification reaction. refMFI means referenced Mean Fluorescence 
Intensity (Roediger et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'refMFI'
summary(object, digits = getOption("digits") - 3, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-refMFI_+3A_object">object</code></td>
<td>

<p>is a <code><a href="#topic+refMFI-class">refMFI</a></code> object.
</p>
</td></tr>
<tr><td><code id="summary-refMFI_+3A_digits">digits</code></td>
<td>

<p>is a <code>numeric</code> value determining the number of decimal places. Used 
only
for printed values. See <a href="base.html#topic+format">format</a>.
</p>
</td></tr>
<tr><td><code id="summary-refMFI_+3A_print">print</code></td>
<td>

<p>is a <code>logical</code> value determining if pretty summary of the object 
should be printed.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Roediger S, Boehm A, Schimke I. Surface Melting Curve Analysis with R. 
<em>The R Journal</em> 2013;5:37&ndash;53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+refMFI-class">refMFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- AmpSim(cyc = 1:50, Cq = 41)
summary(inder(res), print = TRUE)
</code></pre>

<hr>
<h2 id='th'>Class <code>"th"</code></h2><span id='topic+th'></span><span id='topic+th-class'></span><span id='topic+summary.th'></span><span id='topic+summary+2Cth-method'></span><span id='topic+show.th'></span><span id='topic+show+2Cth-method'></span>

<h3>Description</h3>

<p>An S4 class containing the output <code><a href="#topic+th.cyc">th.cyc</a></code> 
function.
</p>


<h3>Value</h3>

<p>A class for calculated results (Ct value and fluorescence) from amplifications 
curve data of a qPCR experiment.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p><code>"matrix"</code> is a matrix containing the 
threshold cycle and threshold fluorescence.</p>
</dd>
<dt><code>stats</code>:</dt><dd><p><code>"summary.lm"</code> contains linear model used for Ct estimation.</p>
</dd>
<dt><code>input</code>:</dt><dd><p><code>"matrix"</code> input data for linear model.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "th")</code>: prints summary 
of the object.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "th")</code>: prints only 
<code>.Data</code> slot of the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+th.cyc">th.cyc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- th.cyc(VIMCFX96_69[, 1], VIMCFX96_69[, 3], r = 2300)
summary(res)
slot(res, "input")
</code></pre>

<hr>
<h2 id='th.cyc'>
Threshold Cycle
</h2><span id='topic+th.cyc'></span>

<h3>Description</h3>

<p><code>th.cyc</code> calculates the number of cycles at which the 
fluorescence exceeds a defined threshold, called the threshold cycle (Ct). 
According to the MIQE guidelines the Ct is referred to as quantification 
cycle (Cq). The calculated Cq is a relative value, which depends on the 
template copy number, instrument, reagents, amplification efficiency and 
probe technology. Low Cqs correlate with high quantities template copy 
numbers. Real-time technologies enable the quantification of nucleic acids 
by calculation of specific curve parameters like the quantification point 
(Cq) and the amplification efficiency (AE) based on the kinetics of the 
amplification curve. The Cq represents the number of cycles (time for qIA) 
needed to reach a defined fluorescence signal level in the exponential 
phase of the amplification curve. The Cq can be determined from a fixed 
threshold value or by various analytical algorithm as described elsewhere 
(Bustin et al. 2009, Ruijter et al. 2013, Tellinghuisen et al. 2014). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>th.cyc(x, y, r = 2500, auto = FALSE, linear = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="th.cyc_+3A_x">x</code></td>
<td>

<p>is a vector containing the time or cycle values.
</p>
</td></tr>
<tr><td><code id="th.cyc_+3A_y">y</code></td>
<td>

<p>is a vector containing the fluorescence values.
</p>
</td></tr>
<tr><td><code id="th.cyc_+3A_r">r</code></td>
<td>

<p>a fluorescence value which defines the threshold.
</p>
</td></tr>
<tr><td><code id="th.cyc_+3A_auto">auto</code></td>
<td>

<p>is logical parameter which indicates if an automatic estimation of the 
threshold should be used (Note: Experimental, not safe to use).
</p>
</td></tr>
<tr><td><code id="th.cyc_+3A_linear">linear</code></td>
<td>

<p>is logical parameter which indicates if a linear or quadratic regression 
should be used for the calculation. (Note: Experimental, not safe to use).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Threshold Cycle (Ct) (Cq according to MIQE, see Bustin et al. 2009) is 
the cycle number at which the fluorescence exceeds significantly a point 
above the baseline and defined threshold in a particular samples. Thus the 
Ct is the cycle when sufficient numbers of amplicons have accumulated. The 
<code>th.cyc</code> calculates the intersection of the user defined Ct value 
(<code>r</code>) and a linear regression or quadratic polynomial in the range of 
the user defined Ct value. In contrast to other methods, 
<code>th.cyc</code> have no requirement to fit a &quot;complex&quot; non linear model to 
the entire data set but rather focuses on the specific area. The polynomial 
is calculated from four neighbor values at the fluorescence threshold.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+th-class">th</a></code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Roediger, Michal Burdukiewicz
</p>


<h3>References</h3>

<p>Stephen A. Bustin, Vladimir Benes, Jeremy A. Garson, Jan Hellemans, Jim 
Huggett, Mikael Kubista, Reinhold Mueller, Tania Nolan, Michael W. Pfaffl, 
Gregory L. Shipley, Jo Vandesompele, and Carl T. Wittwer. (Apr 2009). &quot;The 
MIQE Guidelines: Minimum Information for Publication of Quantitative 
Real-Time PCR Experiments&quot;. <em>Clin Chem</em>. 55 (4):611&ndash;22. 
doi:10.1373/clinchem.2008.112797. PMID 19246619
</p>
<p>Ruijter, J.M., Pfaffl, M.W., Zhao, S., Spiess, A.N., Boggy, G., Blom,
J., Rutledge, R.G., Sisti, D., Lievens, A., De Preter, K., Derveaux, S.,
Hellemans, J., Vandesompele, J.: Evaluation of qPCR curve analysis
methods for reliable biomarker discovery: bias, resolution, precision,
and implications. <em>Methods (San Diego, Calif.)</em> 59(1), 32&ndash;46 (2013).
doi:10.1016/j.ymeth.2012.08.011. PMID: 22975077
</p>
<p>Tellinghuisen, J., Spiess, A.-N.: Comparing real-time quantitative 
polymerase chain reaction analysis methods for precision, linearity, and 
accuracy of estimating amplification efficiency. <em>Analytical 
Biochemistry</em> 449, 76&ndash;82 (2014). doi:10.1016/j.ab.2013.12.020. PMID: 
24365068
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
# Raw data from the VIMCFX96_69 data set.
# Cycles
x &lt;- VIMCFX96_69[, 1]
# Fluoresce values
y &lt;- VIMCFX96_69[, 2]

# Plot the raw data
plot(x, y, xlab = "Cycle", ylab = "Fluo")
# Calculate the the Ct value
res &lt;- th.cyc(x, y, r = 2300)
lines(res@input, col = 2, lwd = 2)
# Threshold fluorescence value
abline(h = res@.Data[2], col = 3)
# Calculated Ct value
abline(v = res@.Data[1], col = 4)

# Second example
# Application of the th.cyc method to determine the Cq from a continous
# amplification reaction.
plot(NA, NA, xlim = c(0,80), ylim = c(0,1200), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Raw Data")

# Threshold level "r" (50 micro Volts)
for (i in c(1,3,5,7)) {
  y.tmp &lt;- capillaryPCR[, i + 1] - mean(capillaryPCR[1L:150, i + 1])
  Ct.tmp &lt;- th.cyc(capillaryPCR[, i], y.tmp, r = 50, linear = FALSE)
  abline(v = Ct.tmp[1])
  text(Ct.tmp[1] * 1.1, 1200, paste(round(Ct.tmp[1], 1), "\nmin"))
  lines(capillaryPCR[, i], y.tmp, type = "b", pch = 20 - i) 
  points(Ct.tmp@input, col = "red", pch = 19)
}
abline(h = 50)
legend(5,800, c("Run 1", "Run 2", "Run 3", "Control"), pch = c(19, 17, 15, 13), 
      lwd = 1.5)
</code></pre>

<hr>
<h2 id='VIMCFX96_60'>
Amplification Reaction Using the Bio-Rad CFX96
</h2><span id='topic+VIMCFX96_60'></span>

<h3>Description</h3>

<p>Data set of an amplification reaction using the Bio-Rad CFX96 thermo cycler. 
The samples of Vimentin were amplified in the CFX96 as replicates according to 
Roediger et al. (2013). The quantification was performed during the annealing 
step (60 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMCFX96_60)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycle&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A1&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMCFX96_60)
data(VIMCFX96_69)

T60 &lt;- rowMeans(VIMCFX96_60[, 2:ncol(VIMCFX96_60)])
T69 &lt;- rowMeans(VIMCFX96_69[, 2:ncol(VIMCFX96_69)])

plot(1:length(T60), T60, main = "Fluorescence at different 
      temperatures\nQuantification in CFX96 (Bio-Rad)", xlab = "Cycle", 
      ylab = "Cycle dependent fluorescence", pch = 15, type = "b")
lines(1:length(T69), T69, pch = 19, type = "b", col = 2)
legend(1, 4500, c("Annealing (60 deg C)", "Elongation (69 deg C)"), 
	pch = c(15, 19), col = c(1,2))
</code></pre>

<hr>
<h2 id='VIMCFX96_69'>
Amplification Reaction Using the Bio-Rad CFX96
</h2><span id='topic+VIMCFX96_69'></span>

<h3>Description</h3>

<p>Data set of an amplification reaction using the Bio-Rad CFX96 thermo cycler. 
The samples of Vimentin were amplified in the CFX96 as replicates according to 
Roediger et al. (2013). The quantification was performed during the elongation 
step (69 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMCFX96_69)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycle&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A1&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMCFX96_60)
data(VIMCFX96_69)

T60 &lt;- rowMeans(VIMCFX96_60[, 2:ncol(VIMCFX96_60)])
T69 &lt;- rowMeans(VIMCFX96_69[, 2:ncol(VIMCFX96_69)])

plot(1:length(T60), T60, main = "Fluorescence at different 
      temperatures\nQuantification in CFX96 (Bio-Rad)", xlab = "Cycle", 
      ylab = "Cycle dependent fluorescence", pch = 15, type = "b")
lines(1:length(T69), T69, pch = 19, type = "b", col = 2)
legend(1, 4500, c("Annealing (60 deg C)", "Elongation (69 deg C)"), 
	pch = c(15, 19), col = c(1,2))
</code></pre>

<hr>
<h2 id='VIMCFX96_meltcurve'>
Melting Curve Measured with the Bio-Rad CFX96
</h2><span id='topic+VIMCFX96_meltcurve'></span>

<h3>Description</h3>

<p>Data set of a melting curve using the Bio-Rad CFX96 thermo cycler. The samples 
of Vimentin were measured in the CFX96 as replicates according to Roediger et 
al. (2013). The quantification was performed during the gradient from 55 to 95 
degrees Celsius with a resolution of 0.5 degrees Celsius per step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMCFX96_meltcurve)</code></pre>


<h3>Format</h3>

<p>A data frame with 81 observations on the following 97 variables. The first 
column (&quot;Temperature&quot;) contains the temperature and consecutive columns 
contain the replicates (&quot;A1&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMCFX96_meltcurve)
tmp &lt;- VIMCFX96_meltcurve

plot(NA, NA, xlim = c(55,95), ylim = c(2000, 7000), xlab = "Temperature 
    (degrees Celsius)",
    ylab = "RFU", main = "Melting curve in CFX96 (Bio-Rad)")
apply(tmp[, 2:ncol(tmp)], 2, 
      function(x) lines(tmp[1:nrow(tmp),1],x))

Fmean &lt;- rowMeans(tmp[, 2:ncol(tmp)])
lines(tmp[1:nrow(tmp),1], Fmean, col = "red", lwd = 3)

legend(55, 4000, c("Raw", "Mean"), pch = c(19,19), col = c(1,2))
</code></pre>

<hr>
<h2 id='VIMiQ5_595'>
Amplification Reaction Using the Bio-Rad iQ5
</h2><span id='topic+VIMiQ5_595'></span>

<h3>Description</h3>

<p>Data set of an amplification reaction using the Bio-Rad iQ5 thermo cycler. The 
samples of Vimentin were amplified in the iQ5 as replicates according to 
Roediger et al. (2013). The quantification was performed during the annealing 
step (59.5 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMiQ5_595)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycles&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T595 &lt;- rowMeans(VIMiQ5_595[, 2:ncol(VIMiQ5_595)])
T685 &lt;- rowMeans(VIMiQ5_685[, 2:ncol(VIMiQ5_685)])

plot(1:length(T595), T595, main = "Fluorescence at different 
    temperatures\nQuantification in iQ5 (Bio-Rad)", xlab = "Cycle", 
    ylab = "Cycle dependent fluorescence", pch = 15, type = "b")
lines(1:length(T685), T685, pch = 19, type = "b", col = 2)
legend(1, 10000, c("Annealing (59.5 deg C)", "Elongation (68.5 deg C)"), 
	pch = c(15, 19), col = c(1,2))
</code></pre>

<hr>
<h2 id='VIMiQ5_685'>
Amplification Reaction Using the Bio-Rad iQ5
</h2><span id='topic+VIMiQ5_685'></span>

<h3>Description</h3>

<p>Data set of an amplification reaction using the Bio-Rad iQ5 thermo cycler. The 
samples of Vimentin were amplified in the iQ5 as replicates according to 
Roediger et al. (2013). The quantification was performed during the elongation 
step (68.5 degrees Celsius).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMiQ5_685)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 97 variables. The first 
column (&quot;Cycles&quot;) contains the number of cycles and consecutive columns 
contain the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, 
M. Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder.
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T595 &lt;- rowMeans(VIMiQ5_595[, 2:ncol(VIMiQ5_595)])
T685 &lt;- rowMeans(VIMiQ5_685[, 2:ncol(VIMiQ5_685)])

plot(1:length(T595), T595, main = "Fluorescence at different 
      temperatures\nQuantification in iQ5 (Bio-Rad)", xlab = "Cycle", 
      ylab = "Cycle dependent fluorescence", pch = 15, type = "b")
lines(1:length(T685), T685, pch = 19, type = "b", col = 2)
legend(1, 10000, c("Annealing (59.5 deg C)", "Elongation (68.5 deg C)"), 
      pch = c(15, 19), col = c(1,2))
</code></pre>

<hr>
<h2 id='VIMiQ5_melt'>
Melting Curve Measured with the Bio-Rad iQ5
</h2><span id='topic+VIMiQ5_melt'></span>

<h3>Description</h3>

<p>Data set of a melting curve using the Bio-Rad iQ5 thermo cycler. The 
samples of Vimentin were measured in the CFX96 as replicates according to 
Roediger et al. (2013). The quantification was performed during the gradient 
from 55 to 95 degrees Celsius with a resolution of 0.5 degrees Celsius per step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VIMiQ5_melt)</code></pre>


<h3>Format</h3>

<p>A data frame with 81 observations on the following 97 variables. The 
first column (&quot;T&quot;) contains the temperature and consecutive columns contain 
the replicates (&quot;A01&quot; to &quot;H12&quot;).
</p>


<h3>Source</h3>

<p>Stefan Roediger, Claudia Deutschmann (BTU Cottbus - Senftenberg)
</p>


<h3>References</h3>

<p>A Highly Versatile Microscope Imaging Technology Platform for the Multiplex 
Real-Time Detection of Biomolecules and Autoimmune Antibodies. S. Roediger, 
P. Schierack, A. Boehm, J. Nitschke, I. Berger, U. Froemmel, C. Schmidt, M. 
Ruhland, I. Schimke, D. Roggenbuck, W. Lehmann and C. Schroeder. 
<em>Advances in Biochemical Bioengineering/Biotechnology</em>. 133:33&ndash;74, 
2013. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VIMiQ5_melt)
tmp &lt;- VIMiQ5_melt

plot(NA, NA, xlim = c(55,95), ylim = c(0, 40000), 
    xlab = "Temperature (degrees Celsius)",ylab = "RFU", 
    main = "Melting curve in iQ5 (Bio-Rad)")
apply(tmp[, 2:ncol(tmp)], 2, 
      function(x) lines(tmp[1:nrow(tmp),1],x))

Fmean &lt;- rowMeans(tmp[, 2:ncol(tmp)])
lines(tmp[1:nrow(tmp),1], Fmean, col = "red", lwd = 3)

legend(55, 4000, c("Raw", "Mean"), pch = c(19,19), col = c(1,2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
