<!DOCTYPE html><html lang="en"><head><title>Help for package MFPCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MFPCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.PACE'><p>Calculate univariate functional PCA</p></a></li>
<li><a href='#calcBasisIntegrals'><p>Utility function that calculates matrix of basis-scalar products (one dimension)</p></a></li>
<li><a href='#calcMFPCA'><p>Internal function that implements the MFPCA algorithm for given univariate decompositions</p></a></li>
<li><a href='#check_FCP_TPA_input'><p>Check input of FCP TPA function</p></a></li>
<li><a href='#dct2D'><p>Calculate and threshold DCT for an image</p></a></li>
<li><a href='#dct3D'><p>Calculate and threshold DCT for an 3D image</p></a></li>
<li><a href='#dctBasis2D'><p>Calculate a cosine basis representation for functional data on two- or</p>
three-dimensional domains</a></li>
<li><a href='#dctFunction2D'><p>Calculate linear combinations of orthonormal cosine basis functions on</p>
two- or three-dimensional domains</a></li>
<li><a href='#expandBasisFunction'><p>Calculate a linear combination of arbitrary basis function</p></a></li>
<li><a href='#FCP_TPA'><p>The functional CP-TPA algorithm</p></a></li>
<li><a href='#fcptpaBasis'><p>Calculate a smooth PCA representation for functional data on two-dimensional</p>
domains</a></li>
<li><a href='#fdaBasis'><p>Use a basis from package fda for univariate representation</p></a></li>
<li><a href='#findAlphaVopt'><p>Find the optimal smoothing parameters in FCP_TPA using GCV</p></a></li>
<li><a href='#fpcaBasis'><p>Calculate a functional principal component basis representation for</p>
functional data on one-dimensional domains</a></li>
<li><a href='#gcv'><p>Generalized cross-validation for the FCP-TPA algorithm</p></a></li>
<li><a href='#givenBasis'><p>Use given basis functions for univariate representation</p></a></li>
<li><a href='#idct2D'><p>Calculate an inverse DCT for an image</p></a></li>
<li><a href='#idct3D'><p>Calculate an inverse DCT for a 3D image</p></a></li>
<li><a href='#maxeig'><p>Compute the largest eigenvalue and associated eigenvector of a matrix A using the power method</p></a></li>
<li><a href='#MFPCA'><p>Multivariate functional principal component analysis for functions on</p>
different (dimensional) domains</a></li>
<li><a href='#multivExpansion'><p>Calculate multivariate basis expansion</p></a></li>
<li><a href='#normVec'><p>Calculate the euclidean norm of a vector</p></a></li>
<li><a href='#PACE'><p>Univariate functional principal component analysis by smoothed covariance</p></a></li>
<li><a href='#plot.MFPCAfit'><p>Plot MFPCA results</p></a></li>
<li><a href='#predict.MFPCAfit'><p>Function prediction based on MFPCA results</p></a></li>
<li><a href='#print.MFPCAfit'><p>Print the results of a Multivariate Functional Principal Component Analysis</p></a></li>
<li><a href='#print.summary.MFPCAfit'><p>Print summary of a Multivariate Functional Principal Component Analysis</p></a></li>
<li><a href='#scoreplot'><p>Scoreplot Generic</p></a></li>
<li><a href='#scoreplot.MFPCAfit'><p>Plot the Scores of a Multivariate Functional Principal Component Analysis</p></a></li>
<li><a href='#screeplot.MFPCAfit'><p>Screeplot for Multivariate Functional Principal Component Analysis</p></a></li>
<li><a href='#splineBasis1D'><p>Calculate a spline basis decomposition for functional data on one-dimensional</p>
domains</a></li>
<li><a href='#splineBasis2D'><p>Calculate a spline basis representation for functional data on</p>
two-dimensional domains</a></li>
<li><a href='#splineFunction1D'><p>Calculate linear combinations of spline basis functions on one-dimensional</p>
domains</a></li>
<li><a href='#splineFunction2D'><p>Calculate linear combinations of spline basis functions on</p>
two-dimensional domains</a></li>
<li><a href='#stratSample'><p>Sample stratified indices according to a factor variable</p></a></li>
<li><a href='#summary.MFPCAfit'><p>Summarize a Multivariate Functional Principal Component Analysis</p></a></li>
<li><a href='#ttv'><p>Tensor times vector calculation</p></a></li>
<li><a href='#ttvCalculation'><p>Internal function for the Tensor times Vector calculation</p></a></li>
<li><a href='#UMPCA'><p>UMPCA: Uncorrelated Multilinear Principle Component Analysis</p></a></li>
<li><a href='#umpcaBasis'><p>Calculate an uncorrelated multilinear principal component basis</p>
representation for functional data on two-dimensional domains</a></li>
<li><a href='#univDecomp'><p>Univariate basis decomposition</p></a></li>
<li><a href='#univExpansion'><p>Calculate a univariate basis expansion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Functional Principal Component Analysis for Data
Observed on Different Dimensional Domains</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clara Happ-Kurz &lt;chk_R@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate a multivariate functional principal component analysis
    for data observed on different dimensional domains. The estimation algorithm
    relies on univariate basis expansions for each element of the multivariate
    functional data  (Happ &amp; Greven, 2018) &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1273115">doi:10.1080/01621459.2016.1273115</a>&gt;. 
    Multivariate and univariate functional data objects are
    represented by S4 classes for this type of data implemented in the package
    'funData'. For more details on the general concepts of both packages and a case 
    study, see Happ-Kurz (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v093.i05">doi:10.18637/jss.v093.i05</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ClaraHapp/MFPCA">https://github.com/ClaraHapp/MFPCA</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, foreach, irlba, Matrix(&ge; 1.5-0), methods, mgcv (&ge;
1.8-33), plyr, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), funData (&ge; 1.3-4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, fda, testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libfftw3 (&gt;= 3.3.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-15 07:48:19 UTC; clara</td>
</tr>
<tr>
<td>Author:</td>
<td>Clara Happ-Kurz <a href="https://orcid.org/0000-0003-4737-3835"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-15 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.PACE'>Calculate univariate functional PCA</h2><span id='topic+.PACE'></span>

<h3>Description</h3>

<p>This function is a slightly adapted version of the 
<code>fpca.sc</code> function in the <strong>refund</strong> package for 
calculating univariate functional principal components based on a smoothed 
covariance function. The smoothing basis functions are penalized splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.PACE(
  X,
  Y,
  Y.pred = NULL,
  nbasis = 10,
  pve = 0.99,
  npc = NULL,
  makePD = FALSE,
  cov.weight.type = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".PACE_+3A_x">X</code></td>
<td>
<p>A vector of xValues.</p>
</td></tr>
<tr><td><code id=".PACE_+3A_y">Y</code></td>
<td>
<p>A matrix of observed functions (by row).</p>
</td></tr>
<tr><td><code id=".PACE_+3A_y.pred">Y.pred</code></td>
<td>
<p>A matrix of functions (by row) to be approximated using the 
functional principal components. Defaults to <code>NULL</code>, i.e. the 
prediction is made for the functions in <code>Y</code>.</p>
</td></tr>
<tr><td><code id=".PACE_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer, giving the number of B-spline basis to use. 
Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id=".PACE_+3A_pve">pve</code></td>
<td>
<p>A value between 0 and 1, giving the percentage of variance 
explained in the data by the functional principal components. This value is
used to choose the number of principal components. Defaults to <code>0.99</code></p>
</td></tr>
<tr><td><code id=".PACE_+3A_npc">npc</code></td>
<td>
<p>The number of principal components to be estimated. Defaults to 
<code>NULL</code>. If given, this overrides <code>pve</code>.</p>
</td></tr>
<tr><td><code id=".PACE_+3A_makepd">makePD</code></td>
<td>
<p>Logical, should positive definiteness be enforced for the 
covariance estimate? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".PACE_+3A_cov.weight.type">cov.weight.type</code></td>
<td>
<p>The type of weighting used for the smooth covariance
estimate. Defaults to <code>"none"</code>, i.e. no weighting. Alternatively, 
<code>"counts"</code> (corresponds to <code>fpca.sc</code> in <strong>refund</strong>) weights the pointwise estimates of the covariance function
by the number of observation points.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>The approximation of <code>Y.pred</code> (if <code>NULL</code>, the 
approximation of <code>Y</code>) based on the functional principal components.</p>
</td></tr> 
<tr><td><code>scores</code></td>
<td>
<p>A matrix containing the estimated scores (observations by 
row).</p>
</td></tr> <tr><td><code>mu</code></td>
<td>
<p>The estimated mean function.</p>
</td></tr> <tr><td><code>efunctions</code></td>
<td>
<p>A matrix 
containing the estimated eigenfunctions (by row).</p>
</td></tr> <tr><td><code>evalues</code></td>
<td>
<p>The 
estimated eigenvalues.</p>
</td></tr> <tr><td><code>npc</code></td>
<td>
<p>The number of principal comopnents that 
were calculated.</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>The estimated variance of the measurement 
error.</p>
</td></tr>  <tr><td><code>estVar</code></td>
<td>
<p>The estimated smooth variance function of the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Di, C., Crainiceanu, C., Caffo, B., and Punjabi, N. (2009). 
Multilevel functional principal component analysis. Annals of Applied 
Statistics, 3, 458&ndash;488. Yao, F., Mueller, H.-G., and Wang, J.-L. (2005). 
Functional data analysis for sparse longitudinal data. Journal of the 
American Statistical Association, 100, 577&ndash;590.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PACE">PACE</a></code>
</p>

<hr>
<h2 id='calcBasisIntegrals'>Utility function that calculates matrix of basis-scalar products (one dimension)</h2><span id='topic+calcBasisIntegrals'></span>

<h3>Description</h3>

<p>If the element <code class="reqn">X^{(j)}</code> is expanded in basis functions <code class="reqn">b_i^{(j)}(t),~ i = 1, \ldots, K_j</code>,
this function calculates the <code class="reqn">K_j \times K_j</code> matrix <code class="reqn">B^{(jj)}</code> with entries
</p>
<p style="text-align: center;"><code class="reqn">B^{(jj)}_{mn} = \int_{\mathcal{T_j}} b_m^{(j)}(t) b_n^{(j)}(t) \mathrm{d} t</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBasisIntegrals(basisFunctions, dimSupp, argvals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBasisIntegrals_+3A_basisfunctions">basisFunctions</code></td>
<td>
<p>Array of <code>npc</code> basis functions of dimensions <code>npc x M1</code> or <code>npc x M1 x M2</code>.</p>
</td></tr>
<tr><td><code id="calcBasisIntegrals_+3A_dimsupp">dimSupp</code></td>
<td>
<p>dimension of the support of the basis functions (1 or 2)</p>
</td></tr>
<tr><td><code id="calcBasisIntegrals_+3A_argvals">argvals</code></td>
<td>
<p>List of corresponding x-values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the scalar product of all combinations of basis functions (matrix <code class="reqn">B^{(j)}</code>)
</p>


<h3>Warning</h3>

<p>This function is implemented only for functions on one- or two-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>, <code><a href="funData.html#topic+dimSupp">dimSupp</a></code>
</p>

<hr>
<h2 id='calcMFPCA'>Internal function that implements the MFPCA algorithm for given univariate decompositions</h2><span id='topic+calcMFPCA'></span>

<h3>Description</h3>

<p>Internal function that implements the MFPCA algorithm for given univariate decompositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMFPCA(
  N,
  p,
  Bchol,
  M,
  type,
  weights,
  npc,
  argvals,
  uniBasis,
  fit = FALSE,
  approx.eigen = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMFPCA_+3A_n">N</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_p">p</code></td>
<td>
<p>Number of elements in multivariate functional data.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_bchol">Bchol</code></td>
<td>
<p>Cholesky decomposition of B = block diagonal of Cholesky decompositions.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_m">M</code></td>
<td>
<p>The number of multivariate functional principal components to
calculate.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_type">type</code></td>
<td>
<p>Vector of univariate decompositions to use.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_weights">weights</code></td>
<td>
<p>Vector of weights.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_npc">npc</code></td>
<td>
<p>Vector giving the number of univariate basis functions used.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_argvals">argvals</code></td>
<td>
<p>List of argument values for each of the univariate basis functions.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_unibasis">uniBasis</code></td>
<td>
<p>List of univariate basis functions.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_fit">fit</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a truncated multivariate Karhunen-Loeve
representation for the data is calculated based on the estimated scores and
eigenfunctions.</p>
</td></tr>
<tr><td><code id="calcMFPCA_+3A_approx.eigen">approx.eigen</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the eigenanalysis problem for
the estimated covariance matrix is solved approximately using the
<span class="pkg">irlba</span> package, which is much faster. If the number <code>M</code> of
eigenvalues to calculate is high with respect to the number of observations
in <code>mFData</code> or the number of estimated univariate eigenfunctions, the
approximation may be inappropriate. In this case, approx.eigen is set to
<code>FALSE</code> and the function throws a warning. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following
components: </p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>A vector of estimated eigenvalues <code class="reqn">\hat \nu_1
  , \ldots , \hat \nu_M</code>.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A
<code><a href="funData.html#topic+multiFunData">multiFunData</a></code> object containing the estimated
multivariate functional principal components <code class="reqn">\hat \psi_1, \ldots, \hat
  \psi_M</code>.</p>
</td></tr> <tr><td><code>scores</code></td>
<td>
<p> A matrix of dimension <code>N x M</code> containing the
estimated scores <code class="reqn">\hat \rho_{im}</code>.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>A matrix
representing the eigenvectors associated with the combined univariate score
vectors. This might be helpful for calculating predictions.</p>
</td></tr>
<tr><td><code>normFactors</code></td>
<td>
<p>The normalizing factors used for calculating the
multivariate eigenfunctions and scores. This might be helpful when
calculation predictions.</p>
</td></tr> <tr><td><code>meanFunction</code></td>
<td>
<p>A multivariate functional
data object, corresponding to the mean function. The MFPCA is applied to
the de-meaned functions in <code>mFData</code>.</p>
</td></tr><tr><td><code>fit</code></td>
<td>
<p>A
<code><a href="funData.html#topic+multiFunData">multiFunData</a></code> object containing estimated
trajectories for each observation based on the truncated Karhunen-Loeve
representation and the estimated scores and eigenfunctions.</p>
</td></tr>
</table>

<hr>
<h2 id='check_FCP_TPA_input'>Check input of FCP TPA function</h2><span id='topic+check_FCP_TPA_input'></span>

<h3>Description</h3>

<p>Check input of FCP TPA function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_FCP_TPA_input(X, K, penMat, alphaRange, verbose, tol, maxIter, adaptTol)
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='dct2D'>Calculate and threshold DCT for an image</h2><span id='topic+dct2D'></span>

<h3>Description</h3>

<p>This function calculates the (orthonormal) discrete cosine
transformation for an image and returns thresholded DCT coefficients
using the C-library <code>fftw3</code> (see <a href="http://www.fftw.org/">http://www.fftw.org/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct2D(image, qThresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dct2D_+3A_image">image</code></td>
<td>
<p>An image (a 2D matrix with real values).</p>
</td></tr>
<tr><td><code id="dct2D_+3A_qthresh">qThresh</code></td>
<td>
<p>A numeric with value in <code class="reqn">[0,1]</code>, giving the quantile
for thresholding the coefficients. See <code><a href="#topic+dctBasis2D">dctBasis2D</a></code> for
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ind</code></td>
<td>
<p>An integer vector, containing the indices of
non-thresholded (hence non-zero) coefficients.</p>
</td></tr> <tr><td><code>val</code></td>
<td>
<p>A numeric
vector, giving the values of the corresponding coefficients.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, this function is disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dctBasis2D">dctBasis2D</a></code>
</p>

<hr>
<h2 id='dct3D'>Calculate and threshold DCT for an 3D image</h2><span id='topic+dct3D'></span>

<h3>Description</h3>

<p>This function calculates the (orthonormal) discrete cosine
transformation for a 3D image and returns thresholded DCT coefficients
using the C-library <code>fftw3</code> (see <a href="http://www.fftw.org/">http://www.fftw.org/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct3D(image, qThresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dct3D_+3A_image">image</code></td>
<td>
<p>A 3D image (a 3D array with real values).</p>
</td></tr>
<tr><td><code id="dct3D_+3A_qthresh">qThresh</code></td>
<td>
<p>A numeric with value in <code class="reqn">[0,1]</code>, giving the quantile
for thresholding the coefficients. See <code><a href="#topic+dctBasis3D">dctBasis3D</a></code> for
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ind</code></td>
<td>
<p>An integer vector, containing the indices of
non-thresholded (hence non-zero) coefficients.</p>
</td></tr> <tr><td><code>val</code></td>
<td>
<p>A numeric
vector, giving the values of the corresponding coefficients.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, this function is disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dctBasis3D">dctBasis3D</a></code>
</p>

<hr>
<h2 id='dctBasis2D'>Calculate a cosine basis representation for functional data on two- or
three-dimensional domains</h2><span id='topic+dctBasis2D'></span><span id='topic+dctBasis3D'></span>

<h3>Description</h3>

<p>These functions calculate  a tensor cosine basis representation for
functional data on two- or three-dimensional domains based on a
discrete cosine transformation (DCT) using the C-library <code>fftw3</code>
(<a href="http://www.fftw.org/">http://www.fftw.org/</a>). Coefficients under a given threshold are
set to 0 to reduce complexity and for denoising.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dctBasis2D(funDataObject, qThresh, parallel = FALSE)

dctBasis3D(funDataObject, qThresh, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dctBasis2D_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code>
containing the observed functional data samples and for which the
basis representation is calculated.</p>
</td></tr>
<tr><td><code id="dctBasis2D_+3A_qthresh">qThresh</code></td>
<td>
<p>A numeric with value in <code class="reqn">[0,1]</code>, giving the quantile
for thresholding the coefficients. See Details.</p>
</td></tr>
<tr><td><code id="dctBasis2D_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the coefficients for the basis
functions are calculated in parallel. The implementation is based on
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function and requires a parallel
backend that must be registered before; see
<code><a href="foreach.html#topic+foreach">foreach</a></code> for details. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the (discretized) observed functions <code class="reqn">X_i</code>, the function
<code>dctBasis2D</code> calculates a basis representation </p>
<p style="text-align: center;"><code class="reqn">X_i(s,t) =
\sum_{m = 0}^{K_1-1} \sum_{n = 0}^{K_2-1} \theta_{mn} f_{mn}(s,t)</code>
</p>
<p> of a
two-dimensional function <code class="reqn">X_i(s,t)</code> in terms of (orthogonal) tensor
cosine basis functions </p>
<p style="text-align: center;"><code class="reqn">f_{mn}(s,t) = c_m c_n \cos(ms) \cos(nt),
\quad (s,t) \in \mathcal{T}</code>
</p>
<p> with <code class="reqn">c_m = \frac{1}{\sqrt{\pi}}</code> for
<code class="reqn">m=0</code> and <code class="reqn">c_m = \sqrt{\frac{2}{\pi}}</code> for <code class="reqn">m=1,2,\ldots</code>
based on a discrete cosine transform (DCT).
</p>
<p>If not thresholded (<code>qThresh = 0</code>), the function returns all
non-zero coefficients <code class="reqn">\theta_{mn}</code> in the basis representation in
a <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> (package <span class="pkg">Matrix</span>) called
<code>scores</code>. Otherwise, coefficients with </p>
<p style="text-align: center;"><code class="reqn">|\theta_{mn}| &lt;= q </code>
</p>

<p>are set to zero, where <code class="reqn">q</code> is the <code>qThresh</code>-quantile of
<code class="reqn">|\theta_{mn}|</code>.
</p>
<p>For functions <code class="reqn">X_i(s,t,u)</code> on three-dimensional domains, the
function <code>dctBasis3D</code> calculates a basis representation
</p>
<p style="text-align: center;"><code class="reqn">X_i(s,t,u) = \sum_{m = 0}^{K_1-1} \sum_{n = 0}^{K_2-1} \sum_{k =
0}^{K_3-1} \theta_{mnk} f_{mnk}(s,t,u)</code>
</p>
<p> in terms of (orthogonal) tensor
cosine basis functions </p>
<p style="text-align: center;"><code class="reqn">f_{mnk}(s,t,u) = c_m c_n c_k \cos(ms)
\cos(nt) \cos(ku), \quad (s,t,u) \in \mathcal{T}</code>
</p>
<p> again with
<code class="reqn">c_m = \frac{1}{\sqrt{pi}}</code> for <code class="reqn">m=0</code> and <code class="reqn">c_m =
\sqrt{\frac{2}{pi}}</code> for <code class="reqn">m=1,2,\ldots</code> based on a discrete cosine
transform (DCT). The thresholding works analogous as for the
two-dimensional case.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> of scores
(coefficients) with dimension <code>N x K</code>, reflecting the weights
<code class="reqn">\theta_{mn}</code> (<code class="reqn">\theta_{mnk}</code>) for each basis function in
each observation, where <code>K</code> is the total number of basis
functions used.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>A diagonal matrix, giving the norms of the
different basis functions used (as they are orthogonal).</p>
</td></tr>
<tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>FALSE</code>, as basis functions are
orthogonal, but in general not orthonormal.</p>
</td></tr>
<tr><td><code>functions</code></td>
<td>
<p><code>NULL</code>, as basis functions are known.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, this function is disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="#topic+dct2D">dct2D</a></code>,
<code><a href="#topic+dct3D">dct3D</a></code>
</p>

<hr>
<h2 id='dctFunction2D'>Calculate linear combinations of orthonormal cosine basis functions on
two- or three-dimensional domains</h2><span id='topic+dctFunction2D'></span><span id='topic+dctFunction3D'></span>

<h3>Description</h3>

<p>Given scores (coefficients), these functions calculate a linear
combination of two- or three-dimensional cosine tensor basis functions
on two- or three-dimensional domains using the C-library <code>fftw3</code>
(see <a href="http://www.fftw.org/">http://www.fftw.org/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dctFunction2D(scores, argvals, parallel = FALSE)

dctFunction3D(scores, argvals, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dctFunction2D_+3A_scores">scores</code></td>
<td>
<p>A sparse matrix of dimension <code>N x L</code>, representing
the <code>L</code> scores (coefficients), where <code>N</code> is the number of
observations.</p>
</td></tr>
<tr><td><code id="dctFunction2D_+3A_argvals">argvals</code></td>
<td>
<p>A list containing two or three numeric vectors,
corresponding to the domain grid (x and y values for two-dimensional
domains; x,y and z values fro three-dimensional domains.)</p>
</td></tr>
<tr><td><code id="dctFunction2D_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the coefficients for the basis
functions are calculated in parallel. The implementation is based on
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function and requires a parallel
backend that must be registered before; see
<code><a href="foreach.html#topic+foreach">foreach</a></code> for details. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>funData</code> with <code>N</code> observations on
the two- or threedimensional domain specified by <code>argvals</code>,
corresponding to the linear combination of orthonormal cosine basis
functions.
</p>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, the functions are disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univExpansion">univExpansion</a></code>, <code><a href="#topic+idct2D">idct2D</a></code>,
<code><a href="#topic+idct3D">idct3D</a></code>, <code><a href="#topic+dctBasis2D">dctBasis2D</a></code>,
<code><a href="#topic+dctBasis3D">dctBasis3D</a></code>
</p>

<hr>
<h2 id='expandBasisFunction'>Calculate a linear combination of arbitrary basis function</h2><span id='topic+expandBasisFunction'></span>

<h3>Description</h3>

<p>This function calculates a linear combination of arbitrary basis functions on 
domains with arbitrary dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandBasisFunction(scores, argvals = functions@argvals, functions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandBasisFunction_+3A_scores">scores</code></td>
<td>
<p>A matrix of dimension <code>N x K</code>, representing the <code>K</code> 
scores (coefficients) for each of the <code>N</code> observations.</p>
</td></tr>
<tr><td><code id="expandBasisFunction_+3A_argvals">argvals</code></td>
<td>
<p>A list representing the domain, see <code><a href="funData.html#topic+funData">funData</a></code>
for details. Defaults to <code>functions@argvals</code>.</p>
</td></tr>
<tr><td><code id="expandBasisFunction_+3A_functions">functions</code></td>
<td>
<p>A <code>funData</code> object, representing <code>K</code> basis 
functions on a domain with arbitrary dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>funData</code> with <code>N</code> observations on 
<code>argvals</code>, corresponding to the linear combination of the basis 
functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univExpansion">univExpansion</a></code>
</p>

<hr>
<h2 id='FCP_TPA'>The functional CP-TPA algorithm</h2><span id='topic+FCP_TPA'></span>

<h3>Description</h3>

<p>This function implements the functional CP-TPA (FCP-TPA) algorithm, that 
calculates a smooth PCA for 3D tensor data (i.e. <code>N</code> observations of 2D 
images with dimension <code>S1 x S2</code>). The results are given in a 
CANDECOMP/PARAFRAC (CP) model format </p>
<p style="text-align: center;"><code class="reqn">X = \sum_{k = 1}^K d_k \cdot u_k 
\circ v_k \circ w_k</code>
</p>
<p>  where 
<code class="reqn">\circ</code> stands for the outer product, <code class="reqn">d_k</code> is a scalar and 
<code class="reqn">u_k, v_k, w_k</code> are eigenvectors for each direction of the tensor. In 
this representation, the outer product <code class="reqn">v_k \circ w_k</code> can
be regarded as the <code class="reqn">k</code>-th eigenimage, while <code class="reqn">d_k \cdot u_k</code> 
represents the vector of individual scores for this eigenimage and each 
observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCP_TPA(
  X,
  K,
  penMat,
  alphaRange,
  verbose = FALSE,
  tol = 1e-04,
  maxIter = 15,
  adaptTol = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FCP_TPA_+3A_x">X</code></td>
<td>
<p>The data tensor of dimensions <code>N x S1 x S2</code>.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_k">K</code></td>
<td>
<p>The number of eigentensors to be calculated.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_penmat">penMat</code></td>
<td>
<p>A list with entries <code>v</code> and <code>w</code>, containing a 
roughness penalty matrix for each direction of the image. The algorithm 
does not induce smoothness along observations (see Details).</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_alpharange">alphaRange</code></td>
<td>
<p>A list of length 2 with entries <code>v</code> and <code>w</code> , 
containing the range of smoothness parameters to test for each direction.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, computational details are given on 
the standard output during calculation of the FCP_TPA.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_tol">tol</code></td>
<td>
<p>A numeric value, giving the tolerance for relative error values in
the algorithm. Defaults to <code>1e-4</code>. It is automatically multiplied by 
10 after <code>maxIter</code> steps, if <code>adaptTol = TRUE</code>.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_maxiter">maxIter</code></td>
<td>
<p>A numeric value, the maximal iteration steps. Can be doubled, 
if <code>adaptTol = TRUE</code>.</p>
</td></tr>
<tr><td><code id="FCP_TPA_+3A_adapttol">adaptTol</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the tolerance is adapted (multiplied
by 10), if the algorithm has not converged after <code>maxIter</code> steps and 
another <code>maxIter</code> steps are allowed with the increased tolerance, see 
Details. Use with caution. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smoothness of the eigenvectors <code class="reqn">v_k, w_k</code> is induced by penalty 
matrices for both image directions, that are weighted by smoothing parameters
<code class="reqn">\alpha_{vk}, \alpha_{wk}</code>. The eigenvectors <code class="reqn">u_k</code> are not smoothed, 
hence the algorithm does not induce smoothness along observations.
</p>
<p>Optimal smoothing parameters are found via a nested generalized cross 
validation. In each iteration of the TPA (tensor power algorithm), the GCV 
criterion is optimized via <code><a href="stats.html#topic+optimize">optimize</a></code> on the interval 
specified via <code>alphaRange$v</code> (or <code>alphaRange$w</code>, respectively).
</p>
<p>The FCP_TPA algorithm is an iterative algorithm. Convergence is assumed if 
the relative difference between the actual and the previous values are all 
below the tolerance level <code>tol</code>. The tolerance level is increased 
automatically, if the algorithm has not converged after <code>maxIter</code> steps 
and if <code>adaptTol = TRUE</code>. If the algorithm did not converge after
<code>maxIter</code> steps (or <code>2 * maxIter</code>) steps, the function throws a
warning.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p>A vector of length <code>K</code>, containing the numeric weights 
<code class="reqn">d_k</code> in the CP model.</p>
</td></tr> <tr><td><code>U</code></td>
<td>
<p>A matrix of dimensions <code>N x K</code>, 
containing the eigenvectors <code class="reqn">u_k</code> in the first dimension.</p>
</td></tr> <tr><td><code>V</code></td>
<td>
<p>A 
matrix of dimensions <code>S1 x K</code>, containing the eigenvectors <code class="reqn">v_k</code> 
in the second dimension.</p>
</td></tr> <tr><td><code>W</code></td>
<td>
<p>A matrix of dimensions <code>S2 x K</code>, 
containing the eigenvectors <code class="reqn">w_k</code> in the third dimension.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G. I. Allen, &quot;Multi-way Functional Principal Components 
Analysis&quot;, IEEE International Workshop on Computational Advances in 
Multi-Sensor Adaptive Processing, 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fcptpaBasis">fcptpaBasis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # set.seed(1234)
 
 N &lt;- 100
 S1 &lt;- 75
 S2 &lt;- 75

 # define "true" components
 v &lt;- sin(seq(-pi, pi, length.out = S1))
 w &lt;- exp(seq(-0.5, 1, length.out = S2))
 
 # simulate tensor data with dimensions N x S1 x S2
 X &lt;- rnorm(N, sd = 0.5) %o% v %o% w
 
 # create penalty matrices (penalize first differences for each dimension)
 Pv &lt;- crossprod(diff(diag(S1)))
 Pw &lt;- crossprod(diff(diag(S2)))
 
 # estimate one eigentensor
 res &lt;- FCP_TPA(X, K = 1, penMat = list(v = Pv, w = Pw),
             alphaRange = list(v = c(1e-4, 1e4), w = c(1e-4, 1e4)),
             verbose = TRUE)
 
 # plot the results and compare to true values
 plot(res$V)
 points(v/sqrt(sum(v^2)), pch = 20)
 legend("topleft", legend = c("True", "Estimated"), pch = c(20, 1))
 
 plot(res$W)
 points(w/sqrt(sum(w^2)), pch = 20)
 legend("topleft", legend = c("True", "Estimated"), pch = c(20, 1))
</code></pre>

<hr>
<h2 id='fcptpaBasis'>Calculate a smooth PCA representation for functional data on two-dimensional 
domains</h2><span id='topic+fcptpaBasis'></span>

<h3>Description</h3>

<p>This function calculates a smooth PCA representation based on the FCP_TPA 
algorithm (see References) for functional data on two-dimensional domains. In 
this case, the data can be interpreted as images with <code>S1 x S2</code> pixels 
(assuming <code>nObsPoints(funDataObject) = (S1, S2)</code>), i.e. the total data 
for <code>N</code> observations can be represented as third order tensor of 
dimension <code>N x S1 x S2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcptpaBasis(
  funDataObject,
  npc,
  smoothingDegree = rep(2, 2),
  alphaRange,
  orderValues = TRUE,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcptpaBasis_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code> 
containing the observed functional data samples (here: images) for which the
smooth PCA is to be calculated.</p>
</td></tr>
<tr><td><code id="fcptpaBasis_+3A_npc">npc</code></td>
<td>
<p>An integer, giving the number of principal components to be 
calculated.</p>
</td></tr>
<tr><td><code id="fcptpaBasis_+3A_smoothingdegree">smoothingDegree</code></td>
<td>
<p>A numeric vector of length 2, specifying the degree of 
the difference penalties inducing smoothness in both directions of the 
image. Defaults to <code>2</code> for each direction (2nd differences).</p>
</td></tr>
<tr><td><code id="fcptpaBasis_+3A_alpharange">alphaRange</code></td>
<td>
<p>A list of length 2 with entries <code>v</code> and <code>w</code> 
containing the range of smoothness parameters to test for each direction.</p>
</td></tr>
<tr><td><code id="fcptpaBasis_+3A_ordervalues">orderValues</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the eigenvalues are ordered
decreasingly, together with their associated eigenimages and scores.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fcptpaBasis_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> the eigenfunctions are normalized to 
have norm 1. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smooth PCA of the tensor data is calculated via the <code><a href="#topic+FCP_TPA">FCP_TPA</a></code> 
function. Smoothness is induced by difference penalty matrices for both 
directions of the images, weighted by smoothing parameters <code class="reqn">\alpha_v, 
\alpha_w</code>. The resulting eigenvectors can be interpreted in terms of 
eigenfunctions and individual scores for each observation. See 
<code><a href="#topic+FCP_TPA">FCP_TPA</a></code> for details.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) with dimension <code>N
 x npc</code>, reflecting the weights for principal component in each observation.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A matrix containing the scalar product of all pairs of basis 
functions.</p>
</td></tr> <tr><td><code>ortho</code></td>
<td>
<p>Logical, indicating whether the eigenfunctions are 
orthonormal. Set to <code>normalize</code>, as this influences whether a 
normalization is done or not.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A functional data object, 
representing the functional principal component basis functions.</p>
</td></tr> 
<tr><td><code>values</code></td>
<td>
<p>A vector of length <code>npc</code>, containing the eigenvalues in 
decreasing order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G. I. Allen, &quot;Multi-way Functional Principal Components Analysis&quot;,
In IEEE International Workshop on Computational Advances in Multi-Sensor 
Adaptive Processing, 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="#topic+FCP_TPA">FCP_TPA</a></code>
</p>

<hr>
<h2 id='fdaBasis'>Use a basis from package fda for univariate representation</h2><span id='topic+fdaBasis'></span>

<h3>Description</h3>

<p>This function allows to use univariate basis representations from the
<span class="pkg">fda</span> package using the <code><a href="funData.html#topic+funData2fd">funData2fd</a></code> function
from package <span class="pkg">funData</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdaBasis(funDataObject, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdaBasis_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code>
containing the observed functional data samples and for which the
basis representation is to be calculated.</p>
</td></tr>
<tr><td><code id="fdaBasis_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="funData.html#topic+funData2fd">funData2fd</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>The coefficient matrix.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>A matrix
containing the scalar product of all pairs of basis functions. This
is <code>NULL</code>, if <code>ortho = TRUE</code>.</p>
</td></tr><tr><td><code>ortho</code></td>
<td>
<p>Logical, set to
<code>TRUE</code>, if basis functions are orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A
functional data object containing the basis functions.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The package <span class="pkg">fda</span> has be be installed to use this
functionality.
</p>


<h3>See Also</h3>

<p><code><a href="funData.html#topic+funData2fd">funData2fd</a></code>, <code><a href="fda.html#topic+eval.fd">eval.fd</a></code>
</p>

<hr>
<h2 id='findAlphaVopt'>Find the optimal smoothing parameters in FCP_TPA using GCV</h2><span id='topic+findAlphaVopt'></span><span id='topic+findAlphaWopt'></span>

<h3>Description</h3>

<p>These functions find the optimal smoothing parameters <code class="reqn">\alpha_v,
\alpha_w</code> for the two image directions (v and w) in the FCP_TPA algorithm
based on generalized cross-validation, which is nested in the tensor power
algorithm. Given a range of possible values of <code class="reqn">\alpha_v</code> (or
<code class="reqn">\alpha_w</code>, respectively), the optimum is found by optimizing the GCV
criterion using the function <code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAlphaVopt(alphaRange, data, u, w, alphaW, OmegaW, GammaV, lambdaV)

findAlphaWopt(alphaRange, data, u, v, alphaV, OmegaV, GammaW, lambdaW)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findAlphaVopt_+3A_alpharange">alphaRange</code></td>
<td>
<p>A numeric vector with two elements, containing the minimal 
and maximal value for the smoothing parameter that is to be optimized.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_data">data</code></td>
<td>
<p>The tensor containing the data, an array of dimensions <code>N x 
S1 x S2</code>.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_u">u</code>, <code id="findAlphaVopt_+3A_v">v</code>, <code id="findAlphaVopt_+3A_w">w</code></td>
<td>
<p>The current value of the eigenvectors <code class="reqn">u_k, v_k, w_k</code> (not 
normalized) of dimensions <code>N</code>, <code>S1</code> and <code>S2</code>.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_gammav">GammaV</code>, <code id="findAlphaVopt_+3A_gammaw">GammaW</code></td>
<td>
<p>A matrix of dimension <code>S1 x S1</code> (<code>GammaV</code> in  <code>findAlphaVopt</code>) or <code>S2 x S2</code> (<code>GammaW</code> in  <code>findAlphaWopt</code>), containing the 
eigenvectors of the penalty matrix for the image direction for which the optimal smoothing parameter is to be found.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_lambdav">lambdaV</code></td>
<td>
<p>lambdaW A numeric vector of length  <code>S1</code>(<code>lambdaV</code> in  <code>findAlphaVopt</code>) or <code>S2</code> (<code>lambdaW</code> in  <code>findAlphaWopt</code>), containing the 
eigenvalues of the penalty matrix for the image direction for which the optimal smoothing parameter is to be found.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_alphav">alphaV</code>, <code id="findAlphaVopt_+3A_alphaw">alphaW</code></td>
<td>
<p>The current value of the smoothing parameter for the
other image direction (<code class="reqn">\alpha_w</code> for <code>findAlphaVopt</code> and
<code class="reqn">\alpha_v</code> for <code>findAlphaWopt</code>), which is kept as fixed.</p>
</td></tr>
<tr><td><code id="findAlphaVopt_+3A_omegav">OmegaV</code></td>
<td>
<p>OmegaW A matrix of dimension <code>S1 x S1</code> (<code>OmegaV</code> in  <code>findAlphaWopt</code>) or <code>S2 x S2</code> (<code>OmegaW</code> in  <code>findAlphaVopt</code>), the penalty matrix for 
other image direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal <code class="reqn">\alpha_v</code> (or <code class="reqn">\alpha_w</code>, respectively), found by optimizing the GCV criterion 
within the given range of possible values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>findAlphaWopt</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>G. I. Allen (2013), &quot;Multi-way Functional Principal Components 
Analysis&quot;, IEEE International Workshop on Computational Advances in 
Multi-Sensor Adaptive Processing.
</p>
<p>J. Z. Huang, H. Shen and A. Buja (2009), &quot;The Analysis of Two-Way
Functional Data Using Two-Way Regularized Singular Value Decomposition&quot;. 
Journal of the American Statistical Association, Vol. 104, No. 488, 1609 &ndash;
1620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FCP_TPA">FCP_TPA</a></code>, <code><a href="#topic+gcv">gcv</a></code>
</p>

<hr>
<h2 id='fpcaBasis'>Calculate a functional principal component basis representation for 
functional data on one-dimensional domains</h2><span id='topic+fpcaBasis'></span>

<h3>Description</h3>

<p>This function calculates a functional principal component basis
representation for functional data on one-dimensional domains. The FPCA is
calculated via the <code><a href="#topic+PACE">PACE</a></code> function, which is built on
<code>fpca.sc</code> in the <strong>refund</strong> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpcaBasis(
  funDataObject,
  nbasis = 10,
  pve = 0.99,
  npc = NULL,
  makePD = FALSE,
  cov.weight.type = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpcaBasis_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code> 
containing the observed functional data samples and for which the FPCA is 
to be calculated.</p>
</td></tr>
<tr><td><code id="fpcaBasis_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer, representing the number of  B-spline basis 
functions used for estimation of the mean function and bivariate smoothing 
of the covariance surface. Defaults to <code>10</code> (cf. 
<code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="fpcaBasis_+3A_pve">pve</code></td>
<td>
<p>A numeric value between 0 and 1, the proportion of variance 
explained: used to choose the number of principal components. Defaults to 
<code>0.99</code> (cf. <code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="fpcaBasis_+3A_npc">npc</code></td>
<td>
<p>An integer, giving a prespecified value for the number of 
principal components. Defaults to <code>NULL</code>. If given, this overrides 
<code>pve</code> (cf. <code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="fpcaBasis_+3A_makepd">makePD</code></td>
<td>
<p>Logical: should positive definiteness be enforced for the 
covariance surface estimate? Defaults to <code>FALSE</code> (cf. 
<code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="fpcaBasis_+3A_cov.weight.type">cov.weight.type</code></td>
<td>
<p>The type of weighting used for the smooth covariance
estimate in <code><a href="#topic+PACE">PACE</a></code>. Defaults to <code>"none"</code>, i.e. no weighting. Alternatively, 
<code>"counts"</code> (corresponds to <code>fpca.sc</code> in <strong>refund</strong>) weights the pointwise estimates of the covariance function
by the number of observation points.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) with dimension 
<code>N x K</code>, reflecting the weights for each principal component in each 
observation, where <code>N</code> is the number of observations in
<code>funDataObject</code> and <code>K</code> is the number of functional principal
components.</p>
</td></tr> <tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>TRUE</code>, as basis functions
are orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A functional data object, representing
the functional principal component basis functions.</p>
</td></tr> <tr><td><code>meanFunction</code></td>
<td>
<p>The smoothed mean function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="#topic+PACE">PACE</a></code>
</p>

<hr>
<h2 id='gcv'>Generalized cross-validation for the FCP-TPA algorithm</h2><span id='topic+gcv'></span>

<h3>Description</h3>

<p>These function calculates the generalized cross-validation criterion for the 
smoothing parameters <code class="reqn">\alpha_v</code> or <code class="reqn">\alpha_w</code> that are used in the 
<code><a href="#topic+FCP_TPA">FCP_TPA</a></code> algorithm. As the criterion is symmetric in <code class="reqn">v</code> and
<code class="reqn">w</code>, this function implements a generic criterion, which is called by 
<code><a href="#topic+findAlphaVopt">findAlphaVopt</a></code>, <code><a href="#topic+findAlphaWopt">findAlphaWopt</a></code> with the correct values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv(alpha, n, z, eta, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcv_+3A_alpha">alpha</code></td>
<td>
<p>The current value of the smoothing parameter.</p>
</td></tr>
<tr><td><code id="gcv_+3A_n">n</code></td>
<td>
<p>The length of the dimension, for which the smoothing parameter is to
be optimized.</p>
</td></tr>
<tr><td><code id="gcv_+3A_z">z</code></td>
<td>
<p>A vector of length <code>n</code>. See Details.</p>
</td></tr>
<tr><td><code id="gcv_+3A_eta">eta</code></td>
<td>
<p>A vector of length <code>n</code>. See Details.</p>
</td></tr>
<tr><td><code id="gcv_+3A_lambda">lambda</code></td>
<td>
<p>A vector of length <code>n</code>, containing the eigenvalues of the
penalty matrix corresponding the the current image direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The criterion can be evaluated in a numerically efficient way, adopting the ideas in Huang, Shen and Buja (2008) to three-ways tensors. TODO!
</p>


<h3>Value</h3>

<p>The value of the GCV criterion.
</p>


<h3>References</h3>

<p>G. I. Allen, &quot;Multi-way Functional Principal Components 
Analysis&quot;, IEEE International Workshop on Computational Advances in 
Multi-Sensor Adaptive Processing, 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FCP_TPA">FCP_TPA</a></code>
</p>

<hr>
<h2 id='givenBasis'>Use given basis functions for univariate representation</h2><span id='topic+givenBasis'></span>

<h3>Description</h3>

<p>Use given basis functions for univariate representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givenBasis(funDataObject, functions, scores = NULL, ortho = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="givenBasis_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code>
containing the observed functional data samples and for which the basis
representation is to be calculated. The data is assumed to be demeaned.</p>
</td></tr>
<tr><td><code id="givenBasis_+3A_functions">functions</code></td>
<td>
<p>A <code>funData</code> object that contains the basis functions.</p>
</td></tr>
<tr><td><code id="givenBasis_+3A_scores">scores</code></td>
<td>
<p>An optional matrix containing the scores or coefficients of the
individual observations and each basis function. If <code>N</code> denotes the
number of observations and <code>K</code> denotes the number of basis functions,
then <code>scores</code> must be a matrix of dimensions <code>N x K</code>. As the data
is assumed to be demeaned, each column must have an average of
approximately 0. If not supplied, the scores are calculated as projection
of each observation on the basis functions.</p>
</td></tr>
<tr><td><code id="givenBasis_+3A_ortho">ortho</code></td>
<td>
<p>An optional parameter, specifying whether the given basis
functions are orthonormal (<code>ortho = TRUE</code>) or not (<code>ortho =
FALSE</code>). If not supplied, the basis functions are considered as
non-orthonormal and their pairwise scalar product is calculated for later
use in the MFPCA.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>The coefficient matrix.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>A matrix containing
the scalar product of all pairs of basis functions. This is <code>NULL</code>, if
<code>ortho = TRUE</code>.</p>
</td></tr><tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>TRUE</code>, if basis
functions are orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A functional data object
containing the basis functions.</p>
</td></tr>
</table>

<hr>
<h2 id='idct2D'>Calculate an inverse DCT for an image</h2><span id='topic+idct2D'></span>

<h3>Description</h3>

<p>This function calculates an inverse (orthonormal) discrete cosine
transformation for given coefficients in two dimensions using the
C-library <code>fftw3</code> (see <a href="http://www.fftw.org/">http://www.fftw.org/</a>). As many
coefficients are expected to be zero, the values are given in
compressed format (indices and values only of non-zero coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idct2D(scores, ind, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idct2D_+3A_scores">scores</code></td>
<td>
<p>A numeric vector, containing the non-zero coefficients.</p>
</td></tr>
<tr><td><code id="idct2D_+3A_ind">ind</code></td>
<td>
<p>An integer vector, containing the indices of the non-zero
coefficients.</p>
</td></tr>
<tr><td><code id="idct2D_+3A_dim">dim</code></td>
<td>
<p>A numeric vector of length 2, giving the resulting image
dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimensions <code>dim</code>, which is a linear
combination of cosine tensor basis functions with the given
coefficients.
</p>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, this function is disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dctBasis2D">dctBasis2D</a></code>
</p>

<hr>
<h2 id='idct3D'>Calculate an inverse DCT for a 3D image</h2><span id='topic+idct3D'></span>

<h3>Description</h3>

<p>This function calculates an inverse (orthonormal) discrete cosine
transformation for given coefficients in three dimensions using the
C-library <code>fftw3</code> (see <a href="http://www.fftw.org/">http://www.fftw.org/</a>). As many
coefficients are expected to be zero, the values are given in
compressed format (indices and values only of non-zero coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idct3D(scores, ind, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idct3D_+3A_scores">scores</code></td>
<td>
<p>A numeric vector, containing the non-zero coefficients.</p>
</td></tr>
<tr><td><code id="idct3D_+3A_ind">ind</code></td>
<td>
<p>An integer vector, containing the indices of the non-zero
coefficients.</p>
</td></tr>
<tr><td><code id="idct3D_+3A_dim">dim</code></td>
<td>
<p>A numeric vector of length 3, giving the resulting image
dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimensions <code>dim</code>, which is a linear
combination of cosine tensor basis functions with the given
coefficients.
</p>


<h3>Warning</h3>

<p>If the C-library <code>fftw3</code> is not available when
the package <code>MFPCA</code> is installed, this function is disabled an
will throw an error. For full functionality install the C-library
<code>fftw3</code> from <a href="http://www.fftw.org/">http://www.fftw.org/</a> and reinstall
<code>MFPCA</code>. This function has not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dctBasis3D">dctBasis3D</a></code>
</p>

<hr>
<h2 id='maxeig'>Compute the largest eigenvalue and associated eigenvector of a matrix A using the power method</h2><span id='topic+maxeig'></span>

<h3>Description</h3>

<p>MATLAB Function: Copyright 1999 by Todd K. Moon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxeig(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxeig_+3A_a">A</code></td>
<td>
<p>Matrix whose eigenvalue is sought</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>Largest eigenvalue</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>corresponding eigenvector</p>
</td></tr>
</table>

<hr>
<h2 id='MFPCA'>Multivariate functional principal component analysis for functions on
different (dimensional) domains</h2><span id='topic+MFPCA'></span>

<h3>Description</h3>

<p>This function calculates a multivariate functional principal component
analysis (MFPCA) based on i.i.d. observations <code class="reqn">x_1, \ldots, x_N</code> of a
multivariate functional data-generating process <code class="reqn">X = (X^{(1)}, \ldots
X^{(p)})</code> with elements <code class="reqn">X^{(j)} \in
L^2(\mathcal{T}_j)</code> defined on a domain
<code class="reqn">\mathcal{T}_j \subset IR^{d_j}</code>. In particular, the
elements can be defined on different (dimensional) domains. The results
contain the mean function, the estimated multivariate functional principal
components <code class="reqn">\hat \psi_1, \ldots, \hat \psi_M</code> (having the same structure
as <code class="reqn">x_i</code>), the associated eigenvalues <code class="reqn">\hat \nu_1 \geq \ldots \geq
\hat \nu_M &gt; 0</code> and the individual scores <code class="reqn">\hat \rho_{im} =
\widehat{&lt;x_i, \psi_m&gt;}</code>. Moreover,
estimated trajectories for each observation based on the truncated
Karhunen-Loeve representation </p>
<p style="text-align: center;"><code class="reqn">\hat x_i = \sum_{m = 1}^M \hat \rho_{im}
\hat \psi_m</code>
</p>
<p> are given
if desired (<code>fit = TRUE</code>). The implementation of the observations
<code class="reqn">x_i = (x_i^{(1)}, \ldots , x_i^{(p)}),~ i = 1 , \ldots, N</code>, the mean function and
multivariate functional principal components <code class="reqn">\hat \psi_1, \ldots, \hat
\psi_M</code> uses the <code><a href="funData.html#topic+multiFunData">multiFunData</a></code> class, which is defined
in the package <span class="pkg">funData</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFPCA(
  mFData,
  M,
  uniExpansions,
  weights = rep(1, length(mFData)),
  fit = FALSE,
  approx.eigen = FALSE,
  bootstrap = FALSE,
  nBootstrap = NULL,
  bootstrapAlpha = 0.05,
  bootstrapStrat = NULL,
  verbose = options()$verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFPCA_+3A_mfdata">mFData</code></td>
<td>
<p>A  <code><a href="funData.html#topic+multiFunData">multiFunData</a></code> object containing the
<code>N</code> observations.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_m">M</code></td>
<td>
<p>The number of multivariate functional principal components to
calculate.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_uniexpansions">uniExpansions</code></td>
<td>
<p>A list characterizing the (univariate) expansion that is
calculated for each element. See Details.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights, defaults to <code>1</code> for each
element. See Details.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_fit">fit</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a truncated multivariate Karhunen-Loeve
representation for the data is calculated based on the estimated scores and
eigenfunctions.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_approx.eigen">approx.eigen</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the eigenanalysis problem for
the estimated covariance matrix is solved approximately using the
<span class="pkg">irlba</span> package, which is much faster. If the number <code>M</code> of
eigenvalues to calculate is high with respect to the number of observations
in <code>mFData</code> or the number of estimated univariate eigenfunctions, the
approximation may be inappropriate. In this case, approx.eigen is set to
<code>FALSE</code> and the function throws a warning. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Logical. If <code>TRUE</code>, pointwise bootstrap confidence
bands are calculated for the multivariate functional principal components.
Defaults to <code>FALSE</code>. See Details.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>The number of bootstrap iterations to use. Defaults to
<code>NULL</code>, which leads to an error, if <code>bootstrap = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_bootstrapalpha">bootstrapAlpha</code></td>
<td>
<p>A vector of numerics (or a single number) giving the
significance level for bootstrap intervals. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_bootstrapstrat">bootstrapStrat</code></td>
<td>
<p>A stratification variable for bootstrap. Must be a
factor of length <code>nObs(mFData)</code> or <code>NULL</code> (default). If
<code>NULL</code>, no stratification is made in the bootstrap resampling, i.e.
the curves are sampled with replacement. If <code>bootstrapStrat</code> is not
<code>NULL</code>, the curves are resampled with replacement within the groups
defined by <code>bootstrapStrat</code>, hence keeping the group proportions
fixed.</p>
</td></tr>
<tr><td><code id="MFPCA_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function reports
extra-information about the progress (incl. timestamps). Defaults to
<code>options()$verbose</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Weighted MFPCA</h4>

<p>If the elements vary considerably in domain,
range or variation, a weight vector <code class="reqn">w_1 , \ldots, w_p</code> can be supplied
and the MFPCA is based on the weighted scalar product </p>
<p style="text-align: center;"><code class="reqn">&lt;&lt;f,g&gt;&gt;_w =
\sum_{j = 1}^p w_j \int_{\mathcal{T}_j} f^{(j)}(t) g^{(j)}(t) \mathrm{d}
t</code>
</p>
<p> and the
corresponding weighted covariance operator <code class="reqn">\Gamma_w</code>.</p>



<h4>Bootstrap</h4>

<p>If <code>bootstrap = TRUE</code>, pointwise bootstrap
confidence bands are generated for the multivariate eigenvalues <code class="reqn">\hat
\nu_1, \ldots, \hat \nu_M </code> as well as for multivariate functional principal
components <code class="reqn">\hat \psi_1, \ldots, \hat \psi_M</code>. The parameter <code>nBootstrap</code> gives the number of bootstrap
iterations. In each iteration, the observations are resampled on the level of
(multivariate) functions and the whole MFPCA is recalculated. In particular,
if the univariate basis depends on the data (FPCA approaches), basis
functions and scores are both re-estimated. If the basis functions are fixed
(e.g. splines), the scores from the original estimate are used to speed up
the calculations. The confidence bands for the eigenfunctions are calculated
separately for each element as pointwise percentile bootstrap confidence
intervals. Analogously, the confidence bands for the eigenvalues are also
percentile bootstrap confidence bands. The significance level(s) can be
defined by the <code>bootstrapAlpha</code> parameter, which defaults to 5%. As a
result, the <code>MFPCA</code> function returns a list <code>CI</code> of the same length
as <code>bootstrapAlpha</code>, containing the lower and upper bounds of the
confidence bands for the principal components as <code>multiFunData</code> objects
of the same structure as <code>mFData</code>. The confidence bands for the
eigenvalues are returned in a list <code>CIvalues</code>, containing the upper and
lower bounds for each significance level.</p>



<h4>Univariate Expansions</h4>

<p>The multivariate functional principal
component analysis relies on a univariate basis expansion for each element
<code class="reqn">X^{(j)}</code>. The univariate basis representation is calculated using
the <code><a href="#topic+univDecomp">univDecomp</a></code> function, that passes the univariate functional
observations and optional parameters to the specific function. The univariate
decompositions are specified via the <code>uniExpansions</code> argument in the
<code>MFPCA</code> function. It is a list of the same length as the <code>mFData</code>
object, i.e. having one entry for each element of the multivariate functional
data. For each element, <code>uniExpansion</code> must specify at least the type of
basis functions to use. Additionally, one may add further parameters. The
following basis representations are supported: </p>
<ul>
<li><p> Given basis
functions. Then <code>uniExpansions[[j]] = list(type = "given", functions,
scores, ortho)</code>, where <code>functions</code> is a <code>funData</code> object on the
same domain as <code>mFData</code>, containing the given basis functions. The
parameters <code>scores</code> and <code>ortho</code> are optional. <code>scores</code> is an
<code>N x K</code> matrix containing the scores (or coefficients) of the observed
functions for the given basis functions, where <code>N</code> is the number of
observed functions and <code>K</code> is the number of basis functions. Note that
the scores need to be demeaned to give meaningful results. If scores are not
supplied, they are calculated using the given basis functions. The parameter
<code>ortho</code> specifies whether the given basis functions are orthonormal
<code>orhto = TRUE</code> or not <code>ortho = FALSE</code>. If <code>ortho</code> is not
supplied, the functions are treated as non-orthogonal. <code>scores</code> and
<code>ortho</code> are not checked for plausibility, use them at your own risk!
</p>
</li>
<li><p> Univariate functional principal component analysis. Then
<code>uniExpansions[[j]] = list(type = "uFPCA", nbasis, pve, npc, makePD)</code>,
where <code>nbasis,pve,npc,makePD</code> are parameters passed to the
<code><a href="#topic+PACE">PACE</a></code> function for calculating the univariate functional
principal component analysis. </p>
</li>
<li><p> Basis functions expansions from the
package <span class="pkg">fda</span>. Then <code>uniExpansions[[j]] = list(type = "fda", ...)</code>,
where <code>...</code> are passed to <code><a href="funData.html#topic+funData2fd">funData2fd</a></code>, which
heavily builds on <code><a href="fda.html#topic+eval.fd">eval.fd</a></code>. If <span class="pkg">fda</span> is not available,
a warning is thrown. </p>
</li>
<li><p> Spline basis functions (not penalized). Then
<code>uniExpansions[[j]] = list(type = "splines1D", bs, m, k)</code>, where
<code>bs,m,k</code> are passed to the functions <code><a href="#topic+univDecomp">univDecomp</a></code> and
<code><a href="#topic+univExpansion">univExpansion</a></code>. For two-dimensional tensor product splines, use
<code>type = "splines2D"</code>. </p>
</li>
<li><p> Spline basis functions (with smoothness
penalty). Then <code>uniExpansions[[j]] = list(type = "splines1Dpen", bs, m,
k)</code>, where <code>bs,m,k</code> are passed to the functions <code><a href="#topic+univDecomp">univDecomp</a></code>
and <code><a href="#topic+univExpansion">univExpansion</a></code>. Analogously to the unpenalized case, use
<code>type = "splines2Dpen"</code> for 2D penalized tensor product splines. </p>
</li>
<li>
<p>Cosine basis functions. Use <code>uniExpansions[[j]] = list(type = "DCT2D",
qThresh, parallel)</code> for functions one two-dimensional domains (images) and
<code>type = "DCT3D"</code> for 3D images. The calculation is based on the discrete
cosine transform (DCT) implemented in the C-library <code>fftw3</code>. If this
library is not available, the function will throw  a warning. <code>qThresh</code>
gives the quantile for hard thresholding the basis coefficients based on
their absolute value. If <code>parallel = TRUE</code>, the coefficients for
different images are calculated in parallel.</p>
</li></ul>
<p> See <code><a href="#topic+univDecomp">univDecomp</a></code>
and <code><a href="#topic+univExpansion">univExpansion</a></code> for details.</p>



<h3>Value</h3>

<p>An object of class <code>MFPCAfit</code> containing the following
components: </p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>A vector of estimated eigenvalues <code class="reqn">\hat \nu_1
  , \ldots , \hat \nu_M</code>.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A
<code><a href="funData.html#topic+multiFunData">multiFunData</a></code> object containing the estimated
multivariate functional principal components <code class="reqn">\hat \psi_1, \ldots, \hat
  \psi_M</code>.</p>
</td></tr> <tr><td><code>scores</code></td>
<td>
<p> A matrix of dimension <code>N x M</code> containing the
estimated scores <code class="reqn">\hat \rho_{im}</code>.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>A matrix
representing the eigenvectors associated with the combined univariate score
vectors. This might be helpful for calculating predictions.</p>
</td></tr>
<tr><td><code>normFactors</code></td>
<td>
<p>The normalizing factors used for calculating the
multivariate eigenfunctions and scores. This might be helpful when
calculation predictions.</p>
</td></tr> <tr><td><code>meanFunction</code></td>
<td>
<p>A multivariate functional
data object, corresponding to the mean function. The MFPCA is applied to
the de-meaned functions in <code>mFData</code>.</p>
</td></tr><tr><td><code>fit</code></td>
<td>
<p>A
<code><a href="funData.html#topic+multiFunData">multiFunData</a></code> object containing estimated
trajectories for each observation based on the truncated Karhunen-Loeve
representation and the estimated scores and eigenfunctions.</p>
</td></tr> <tr><td><code>CI</code></td>
<td>
<p>A
list of the same length as <code>bootstrapAlpha</code>, containing the pointwise
lower and upper bootstrap confidence bands for each eigenfunction and each
significance level in form of <code><a href="funData.html#topic+multiFunData">multiFunData</a></code> objects
(only if <code>bootstrap = TRUE</code>).</p>
</td></tr> <tr><td><code>CIvalues</code></td>
<td>
<p>A list of the same
length as <code>bootstrapAlpha</code>, containing the lower and upper bootstrap
confidence bands for each eigenvalue and each significance level (only if
<code>bootstrap = TRUE</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>C. Happ, S. Greven (2018): Multivariate Functional Principal
Component Analysis for Data Observed on Different (Dimensional) Domains.
Journal of the American Statistical Association, 113(522): 649-659. DOI:
<a href="https://doi.org/10.1080/01621459.2016.1273115">doi:10.1080/01621459.2016.1273115</a>
</p>
<p>C. Happ-Kurz (2020): Object-Oriented Software for Functional
Data. Journal of Statistical Software, 93(5): 1-38. DOI:
<a href="https://doi.org/10.18637/jss.v093.i05">doi:10.18637/jss.v093.i05</a>
</p>


<h3>See Also</h3>

<p>See Happ-Kurz (2020. <a href="https://doi.org/10.18637/jss.v093.i05">doi:10.18637/jss.v093.i05</a>) for a general
introduction to the <span class="pkg">funData</span> package and it's interplay with
<span class="pkg">MFPCA</span>. This file also includes a case study on how to use
<code>MFPCA</code>. Useful functions: <code><a href="funData.html#topic+multiFunData">multiFunData</a></code>,
<code><a href="#topic+PACE">PACE</a></code>, <code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="#topic+univExpansion">univExpansion</a></code>,
<code><a href="#topic+summary.MFPCAfit">summary</a></code>,
<code><a href="#topic+plot.MFPCAfit">plot</a></code>,
<code><a href="#topic+scoreplot.MFPCAfit">scoreplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)

set.seed(1)

### simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                        M = 5, eFunType = "Poly", eValType = "linear", N = 100)

# MFPCA based on univariate FPCA
uFPCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                                  list(type = "uFPCA")))
summary(uFPCA)
plot(uFPCA) # plot the eigenfunctions as perturbations of the mean
scoreplot(uFPCA) # plot the scores

# MFPCA based on univariate spline expansions
splines &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "splines1D", k = 10),
                                                          list(type = "splines1D", k = 10)),
                 fit = TRUE) # calculate reconstruction, too
summary(splines)
plot(splines) # plot the eigenfunctions as perturbations of the mean
scoreplot(splines) # plot the scores

### Compare estimates to true eigenfunctions
# flip to make results more clear
uFPCA$functions &lt;- flipFuns(sim$trueFuns, uFPCA$functions)
splines$functions &lt;- flipFuns(sim$trueFuns, splines$functions)

par(mfrow = c(1,2))
plot(sim$trueFuns[[1]], main = "Eigenfunctions\n1st Element", lwd = 2)
plot(uFPCA$functions[[1]], lty = 2, add = TRUE)
plot(splines$functions[[1]], lty = 3, add = TRUE)

plot(sim$trueFuns[[2]], main = "Eigenfunctions\n2nd Element", lwd = 2)
plot(uFPCA$functions[[2]], lty = 2, add = TRUE)
plot(splines$functions[[2]], lty = 3, add = TRUE)
legend("bottomleft", c("True", "uFPCA", "splines"), lty = 1:3, lwd = c(2,1,1))

# Test reconstruction for the first 10 observations
plot(sim$simData[[1]], obs = 1:10, main = "Reconstruction\n1st Element", lwd = 2)
plot(splines$fit[[1]], obs = 1:10, lty = 2, col = 1, add = TRUE)

plot(sim$simData[[2]], obs = 1:10, main = "Reconstruction\n2nd Element", lwd = 2)
plot(splines$fit[[2]], obs = 1:10, lty = 2, col = 1, add = TRUE)
legend("bottomleft", c("True", "Reconstruction"), lty = c(1,2), lwd = c(2,1))

# MFPCA with Bootstrap-CI for the first 2 eigenfunctions
### ATTENTION: Takes long

splinesBoot &lt;- MFPCA(sim$simData, M = 2, uniExpansions = list(list(type = "splines1D", k = 10),
                                                          list(type = "splines1D", k = 10)),
                 bootstrap = TRUE, nBootstrap = 100, bootstrapAlpha = c(0.05, 0.1), verbose = TRUE)
summary(splinesBoot)
                                 
plot(splinesBoot$functions[[1]], ylim = c(-2,1.5))
plot(splinesBoot$CI$alpha_0.05$lower[[1]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.05$upper[[1]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$lower[[1]], lty = 3, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$upper[[1]], lty = 3, add = TRUE)
abline(h = 0, col = "gray")
 
plot(splinesBoot$functions[[2]], ylim = c(-1,2.5))
plot(splinesBoot$CI$alpha_0.05$lower[[2]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.05$upper[[2]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$lower[[2]], lty = 3, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$upper[[2]], lty = 3, add = TRUE)
abline(h = 0, col = "gray")
legend("topleft", c("Estimate", "95% CI", "90% CI"), lty = 1:3, lwd = c(2,1,1))

# Plot 95% confidence bands for eigenvalues
plot(1:2, splinesBoot$values, pch = 20, ylim = c(0, 1.5), 
     main = "Estimated eigenvalues with 95% CI",
     xlab = "Eigenvalue no.", ylab = "")
arrows(1:2, splinesBoot$CIvalues$alpha_0.05$lower,
       1:2, splinesBoot$CIvalues$alpha_0.05$upper,
       length = 0.05, angle = 90, code = 3)
points(1:2, sim$trueVals[1:2], pch = 20, col = 4)
legend("topright", c("Estimate", "True value"), pch = 20, col = c(1,4))


### simulate data (two- and one-dimensional domains)
### ATTENTION: Takes long

set.seed(2)
sim &lt;-  simMultiFunData(type = "weighted",
                 argvals = list(list(seq(0,1,0.01), seq(-1,1,0.02)), list(seq(-0.5,0.5,0.01))),
                 M = list(c(4,5), 20), eFunType = list(c("Fourier", "Fourier"), "Poly"),
                 eValType = "exponential", N = 150)

# MFPCA based on univariate spline expansions (for images) and univariate FPCA (for functions)
pca &lt;- MFPCA(sim$simData, M = 10,
             uniExpansions = list(list(type = "splines2D", k = c(10,12)),
                             list(type = "uFPCA")))
summary(pca)
plot(pca) # plot the eigenfunctions as perturbations of the mean
scoreplot(pca) # plot the scores

### Compare to true eigenfunctions
# flip to make results more clear
pca$functions &lt;- flipFuns(sim$trueFuns[1:10], pca$functions)

par(mfrow = c(5,2), mar = rep(2,4))
for(m in 2:6) # for m = 1, image.plot (used in plot(funData)) produces an error...
{
  plot(sim$trueFuns[[1]], main = paste("True, m = ", m), obs = m)
  plot(pca$functions[[1]], main = paste("Estimate, m = ", m), obs = m)
}

par(mfrow = c(1,1))
plot(sim$trueFuns[[2]], main = "Eigenfunctions (2nd element)", lwd = 2, obs=  1:5)
plot(pca$functions[[2]], lty = 2, add = TRUE, obs=  1:5)
legend("bottomleft", c("True", "MFPCA"), lty = 1:2, lwd = c(2,1))

par(oldPar)
</code></pre>

<hr>
<h2 id='multivExpansion'>Calculate multivariate basis expansion</h2><span id='topic+multivExpansion'></span>

<h3>Description</h3>

<p>Calculate multivariate basis expansion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivExpansion(multiFuns, scores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multivExpansion_+3A_multifuns">multiFuns</code></td>
<td>
<p>A multivariate functional data object, containing the
multivariate basis functions</p>
</td></tr>
<tr><td><code id="multivExpansion_+3A_scores">scores</code></td>
<td>
<p>A matrix containing the scores for each observation in each
row. The number of columns must match the number of basis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>multiFunData</code> object containing the expanded functions for
each observation.
</p>

<hr>
<h2 id='normVec'>Calculate the euclidean norm of a vector</h2><span id='topic+normVec'></span>

<h3>Description</h3>

<p>Calculate the euclidean norm of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normVec(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normVec_+3A_x">x</code></td>
<td>
<p>The vector for which the norm is to be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The euclidean norm of <code>x</code>.
</p>

<hr>
<h2 id='PACE'>Univariate functional principal component analysis by smoothed covariance</h2><span id='topic+PACE'></span>

<h3>Description</h3>

<p>This function calculates a univariate functional principal components 
analysis by smoothed covariance based on code from 
<code>fpca.sc</code> in package <strong>refund</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PACE(
  funDataObject,
  predData = NULL,
  nbasis = 10,
  pve = 0.99,
  npc = NULL,
  makePD = FALSE,
  cov.weight.type = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PACE_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code> or 
<code><a href="funData.html#topic+irregFunData">irregFunData</a></code> containing the functional data 
observed, for which the functional principal component analysis is 
calculated. If the data is sampled irregularly (i.e. of class 
<code><a href="funData.html#topic+irregFunData">irregFunData</a></code>), <code>funDataObject</code> is transformed 
to a <code><a href="funData.html#topic+funData">funData</a></code> object first.</p>
</td></tr>
<tr><td><code id="PACE_+3A_preddata">predData</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code>, for which
estimated trajectories based on a truncated Karhunen-Loeve representation 
should be estimated. Defaults to <code>NULL</code>, which implies prediction for 
the given data.</p>
</td></tr>
<tr><td><code id="PACE_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer, representing the number of  B-spline basis 
functions used for estimation of the mean function and bivariate smoothing 
of the covariance surface. Defaults to <code>10</code> (cf. 
<code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="PACE_+3A_pve">pve</code></td>
<td>
<p>A numeric value between 0 and 1, the proportion of variance 
explained: used to choose the number of principal components. Defaults to 
<code>0.99</code> (cf. <code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="PACE_+3A_npc">npc</code></td>
<td>
<p>An integer, giving a prespecified value for the number of 
principal components. Defaults to <code>NULL</code>. If given, this overrides 
<code>pve</code> (cf. <code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="PACE_+3A_makepd">makePD</code></td>
<td>
<p>Logical: should positive definiteness be enforced for the 
covariance surface estimate? Defaults to <code>FALSE</code> (cf. 
<code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr>
<tr><td><code id="PACE_+3A_cov.weight.type">cov.weight.type</code></td>
<td>
<p>The type of weighting used for the smooth covariance 
estimate. Defaults to <code>"none"</code>, i.e. no weighting. Alternatively, 
<code>"counts"</code> (corresponds to <code>fpca.sc</code> in <strong>refund</strong>) weights the
pointwise estimates of the covariance function by the number of observation
points.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>A <code><a href="funData.html#topic+funData">funData</a></code> object with one 
observation, corresponding to the mean function.</p>
</td></tr> <tr><td><code>values</code></td>
<td>
<p>A vector 
containing the estimated eigenvalues.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A 
<code><a href="funData.html#topic+funData">funData</a></code> object containing the estimated functional 
principal components.</p>
</td></tr> <tr><td><code>scores</code></td>
<td>
<p>An matrix of estimated scores for the 
observations in <code>funDataObject</code>. Each row corresponds to the scores of
one observation.</p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>A <code><a href="funData.html#topic+funData">funData</a></code> object 
containing the estimated trajectories based on the truncated Karhunen-Loeve
representation and the estimated scores and functional principal components
for <code>predData</code> (if this is not <code>NULL</code>) or <code>funDataObject</code> 
(if <code>predData</code> is <code>NULL</code>).</p>
</td></tr> <tr><td><code>npc</code></td>
<td>
<p>The number of functional 
principal components: either the supplied <code>npc</code>, or the minimum number
of basis functions needed to explain proportion <code>pve</code> of the variance 
in the observed curves (cf. <code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr> 
<tr><td><code>sigma2</code></td>
<td>
<p>The estimated measurement error variance (cf. 
<code>fpca.sc</code> in <strong>refund</strong>).</p>
</td></tr> <tr><td><code>estVar</code></td>
<td>
<p>The estimated smooth
variance function of the data.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This function works only for univariate functional data 
observed on one-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="funData.html#topic+funData">funData</a></code>, 
<code><a href="#topic+fpcaBasis">fpcaBasis</a></code>, <code><a href="#topic+univDecomp">univDecomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  oldPar &lt;- par(no.readonly = TRUE)

  # simulate data
  sim &lt;- simFunData(argvals = seq(-1,1,0.01), M = 5, eFunType = "Poly",
                    eValType = "exponential", N = 100)

  # calculate univariate FPCA
  pca &lt;- PACE(sim$simData, npc = 5)

  # Plot the results
  par(mfrow = c(1,2))
  plot(sim$trueFuns, lwd = 2, main = "Eigenfunctions")
  # flip estimated functions for correct signs
  plot(flipFuns(sim$trueFuns,pca$functions), lty = 2, add = TRUE)
  legend("bottomright", c("True", "Estimate"), lwd = c(2,1), lty = c(1,2))

  plot(sim$simData, lwd = 2, main = "Some Observations", obs = 1:7)
  plot(pca$fit, lty = 2, obs = 1:7, add = TRUE) # estimates are almost equal to true values
  legend("bottomright", c("True", "Estimate"), lwd = c(2,1), lty = c(1,2))

  par(oldPar)

</code></pre>

<hr>
<h2 id='plot.MFPCAfit'>Plot MFPCA results</h2><span id='topic+plot.MFPCAfit'></span>

<h3>Description</h3>

<p>Plots the eigenfunctions as perturbations of the mean (i.e. the mean function
plus/minus a constant factor times each eigenfunction separately). If all 
elements have a one-dimensional domain, the plots can be combined, otherwise 
the effects of adding and subtracting are shown in two separate rows for each
eigenfunction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
plot(
  x,
  plotPCs = seq_len(nObs(x$functions)),
  stretchFactor = NULL,
  combined = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MFPCAfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>MFPCAfit</code>, typically returned by the 
<a href="#topic+MFPCA">MFPCA</a> function.</p>
</td></tr>
<tr><td><code id="plot.MFPCAfit_+3A_plotpcs">plotPCs</code></td>
<td>
<p>The principal components to be plotted. Defaults to all 
components in the <code>MFPCAfit</code> object.</p>
</td></tr>
<tr><td><code id="plot.MFPCAfit_+3A_stretchfactor">stretchFactor</code></td>
<td>
<p>The factor by which the principal components are 
multiplied before adding / subtracting them from the mean function. If 
<code>NULL</code> (the default), the median absolute value of the scores of each 
eigenfunction is used.</p>
</td></tr>
<tr><td><code id="plot.MFPCAfit_+3A_combined">combined</code></td>
<td>
<p>Logical: Should the plots be combined? (Works only if all 
dimensions are one-dimensional). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Further graphical parameters passed to the
<a href="funData.html#topic+plot.funData">plot.funData</a> functions for functional data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the principal components as perturbations of the mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>, <code><a href="funData.html#topic+plot.funData">plot.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate multivariate functional data on one-dimensonal domains
# and calculate MFPCA (cf. MFPCA help)
set.seed(1)
# simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                       M = 5, eFunType = "Poly", eValType = "linear", N = 100)
# MFPCA based on univariate FPCA
PCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                     list(type = "uFPCA")))

# Plot the results
plot(PCA, combined = TRUE) # combine addition and subtraction in one plot
</code></pre>

<hr>
<h2 id='predict.MFPCAfit'>Function prediction based on MFPCA results</h2><span id='topic+predict.MFPCAfit'></span>

<h3>Description</h3>

<p>Predict functions based on a truncated multivariate Karhunen-Loeve 
representation: </p>
<p style="text-align: center;"><code class="reqn">\hat x = \hat mu + \sum_{m = 1}^M \rho_m \hat \psi_m</code>
</p>
 
<p>with estimated mean function <code class="reqn">\hat \mu</code> and principal components 
<code class="reqn">\psi_m</code>. The scores <code class="reqn">\rho_m</code> can be either estimated (reconstruction
of observed functions) or user-defined (construction of new functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
predict(object, scores = object$scores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MFPCAfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>MFPCAfit</code>, typically resulting from 
a <a href="#topic+MFPCA">MFPCA</a> function call.</p>
</td></tr>
<tr><td><code id="predict.MFPCAfit_+3A_scores">scores</code></td>
<td>
<p>A matrix containing the score values. The number of columns in 
<code>scores</code> must equal the number of principal components in 
<code>object</code>. Each row represents one curve. Defaults to the estimated
scores in <code>object</code>, which yields reconstructions of the original
data used for the MFPCA calculation.</p>
</td></tr>
<tr><td><code id="predict.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>multiFunData</code> object containing the predicted functions.
</p>


<h3>See Also</h3>

<p><a href="#topic+MFPCA">MFPCA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Simulate multivariate functional data on one-dimensonal domains
# and calculate MFPCA (cf. MFPCA help)
set.seed(1)
# simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                       M = 5, eFunType = "Poly", eValType = "linear", N = 100)
# MFPCA based on univariate FPCA
PCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                     list(type = "uFPCA")))

# Reconstruct the original data
pred &lt;- predict(PCA) # default reconstructs data used for the MFPCA fit

# plot the results: 1st element
plot(sim$simData[[1]]) # original data
plot(pred[[1]], add = TRUE, lty = 2) # reconstruction

# plot the results: 2nd element
plot(sim$simData[[2]]) # original data
plot(pred[[2]], add = TRUE, lty = 2) # reconstruction
</code></pre>

<hr>
<h2 id='print.MFPCAfit'>Print the results of a Multivariate Functional Principal Component Analysis</h2><span id='topic+print.MFPCAfit'></span>

<h3>Description</h3>

<p>A <code>print</code> function for class <code>MFPCAfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MFPCAfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>MFPCAfit</code>, usually returned by a
call to <a href="#topic+MFPCA">MFPCA</a>.</p>
</td></tr>
<tr><td><code id="print.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='print.summary.MFPCAfit'>Print summary of a Multivariate Functional Principal Component Analysis</h2><span id='topic+print.summary.MFPCAfit'></span>

<h3>Description</h3>

<p>A <code>print</code> method for class <code>MFPCAfit.summary</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.MFPCAfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.MFPCAfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>MFPCAfit.summary</code>, usually returned by a
call to <code>MFPCAfit.summary</code>.</p>
</td></tr>
<tr><td><code id="print.summary.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='scoreplot'>Scoreplot Generic</h2><span id='topic+scoreplot'></span>

<h3>Description</h3>

<p>Redirects to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreplot(PCAobject, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreplot_+3A_pcaobject">PCAobject</code></td>
<td>
<p>A principal component object</p>
</td></tr>
<tr><td><code id="scoreplot_+3A_...">...</code></td>
<td>
<p>Arguments passed from or to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bivariate plot of scores.
</p>

<hr>
<h2 id='scoreplot.MFPCAfit'>Plot the Scores of a Multivariate Functional Principal Component Analysis</h2><span id='topic+scoreplot.MFPCAfit'></span>

<h3>Description</h3>

<p>This function plots two scores of a multivariate functional principal 
component analysis for each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
scoreplot(PCAobject, choices = 1:2, scale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreplot.MFPCAfit_+3A_pcaobject">PCAobject</code></td>
<td>
<p>An object of class <code>MFPCAfit</code>, typically returned by the
<a href="#topic+MFPCA">MFPCA</a> function.</p>
</td></tr>
<tr><td><code id="scoreplot.MFPCAfit_+3A_choices">choices</code></td>
<td>
<p>The indices of the scores that should by displayed. Defaults 
to <code>1:2</code>, i.e. the scores corresponding to the two leading modes of 
variability in the data.</p>
</td></tr>
<tr><td><code id="scoreplot.MFPCAfit_+3A_scale">scale</code></td>
<td>
<p>Logical. Should the scores be scaled by the estimated
eigenvalues to emphasize the proportions of total variance explained by the
components. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scoreplot.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bivariate plot of scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># and calculate MFPCA (cf. MFPCA help)
set.seed(1)
# simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                       M = 5, eFunType = "Poly", eValType = "linear", N = 100)
# MFPCA based on univariate FPCA
PCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                     list(type = "uFPCA")))

# Plot the first two scores
scoreplot(PCA) # no scaling (default)
scoreplot(PCA, scale = TRUE) # scale the scores by the first two eigenvalues 
</code></pre>

<hr>
<h2 id='screeplot.MFPCAfit'>Screeplot for Multivariate Functional Principal Component Analysis</h2><span id='topic+screeplot.MFPCAfit'></span>

<h3>Description</h3>

<p>This function plots the proportion of variance explained by the leading
eigenvalues in an MFPCA against the number of the principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
screeplot(
  x,
  npcs = min(10, length(x$values)),
  type = "lines",
  ylim = NULL,
  main = deparse(substitute(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.MFPCAfit_+3A_x">x</code></td>
<td>
<p>An object of class MFPCAfit, typically returned by a call to
<code><a href="#topic+MFPCA">MFPCA</a></code>.</p>
</td></tr>
<tr><td><code id="screeplot.MFPCAfit_+3A_npcs">npcs</code></td>
<td>
<p>The number of eigenvalued to be plotted. Defaults to all
eigenvalues if their number is less or equal to 10, otherwise show
only the leading first 10 eigenvalues.</p>
</td></tr>
<tr><td><code id="screeplot.MFPCAfit_+3A_type">type</code></td>
<td>
<p>The type of screeplot to be plotted. Can be either
<code>"lines"</code> or <code>"barplot"</code>. Defaults to <code>"lines"</code>.</p>
</td></tr>
<tr><td><code id="screeplot.MFPCAfit_+3A_ylim">ylim</code></td>
<td>
<p>The limits for the y axis. Can be passed either as a vector
of length 2 or as <code>NULL</code> (default). In the second case,
<code>ylim</code> is set to <code>(0,max(pve))</code>, with <code>pve</code> the
proportion of variance explained by the principal
components to be plotted.</p>
</td></tr>
<tr><td><code id="screeplot.MFPCAfit_+3A_main">main</code></td>
<td>
<p>The title of the plot. Defaults to the variable name of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="screeplot.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Other graphic parameters passed to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> (for <code>type = "lines"</code>) or
<code><a href="graphics.html#topic+barplot">barplot</a></code> (for <code>type = "barplot"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A screeplot, showing the decrease of the principal component score.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>, <code><a href="stats.html#topic+screeplot">screeplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate multivariate functional data on one-dimensonal domains
# and calculate MFPCA (cf. MFPCA help)
set.seed(1)
# simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                       M = 5, eFunType = "Poly", eValType = "linear", N = 100)
# MFPCA based on univariate FPCA
PCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                     list(type = "uFPCA")))

# screeplot
screeplot(PCA) # default options
screeplot(PCA, npcs = 3, type = "barplot", main= "Screeplot")
</code></pre>

<hr>
<h2 id='splineBasis1D'>Calculate a spline basis decomposition for functional data on one-dimensional
domains</h2><span id='topic+splineBasis1D'></span><span id='topic+splineBasis1Dpen'></span>

<h3>Description</h3>

<p>These functions calculate a penalized or unpenalized spline basis 
decomposition for functional data on one-dimensional domains based on the 
<a href="mgcv.html#topic+gam">gam</a> function in the <span class="pkg">mgcv</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineBasis1D(funDataObject, bs = "ps", m = NA, k = -1)

splineBasis1Dpen(funDataObject, bs = "ps", m = NA, k = -1, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splineBasis1D_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code> 
containing the observed functional data samples and for which the basis 
decomposition is calculated.</p>
</td></tr>
<tr><td><code id="splineBasis1D_+3A_bs">bs</code></td>
<td>
<p>A character string, specifying the type of basis functions to be 
used. Defaults to <code>"ps"</code> (B-spline functions). Please refer to 
<code><a href="mgcv.html#topic+smooth.terms">smooth.terms</a></code> for a list of possible basis functions.</p>
</td></tr>
<tr><td><code id="splineBasis1D_+3A_m">m</code></td>
<td>
<p>A numeric, the order of the spline basis. Defaults to <code>NA</code>, 
i.e. the order is chosen automatically. See  <code><a href="mgcv.html#topic+s">s</a></code> for 
details.</p>
</td></tr>
<tr><td><code id="splineBasis1D_+3A_k">k</code></td>
<td>
<p>A numeric, the number of basis functions used. Defaults to 
<code>-1</code>, i.e. the number of basis functions is chosen automatically. See 
<code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
<tr><td><code id="splineBasis1D_+3A_parallel">parallel</code></td>
<td>
<p>Logical (only for <code>splineBasis1Dpen</code>. If <code>TRUE</code>, 
the coefficients for the basis functions are calculated in parallel. The 
implementation is based on the <code><a href="foreach.html#topic+foreach">foreach</a></code> function and 
requires a parallel backend that must be registered before. See 
<code><a href="foreach.html#topic+foreach">foreach</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) with dimension 
<code>N x K</code>, reflecting the weights for each of the <code>K</code> basis 
functions and for each of the <code>N</code> observations.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>A matrix 
containing the scalar product of all pairs of basis functions.</p>
</td></tr> 
<tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>FALSE</code>, as basis functions are not 
orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p><code>NULL</code>, as basis functions are known</p>
</td></tr> 
<tr><td><code>settings</code></td>
<td>
<p>A list with entries <code>bs</code>, <code>m</code> and <code>k</code>, 
giving the actual parameters used for generating the spline basis 
functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="foreach.html#topic+foreach">foreach</a></code>
</p>

<hr>
<h2 id='splineBasis2D'>Calculate a spline basis representation for functional data on 
two-dimensional domains</h2><span id='topic+splineBasis2D'></span><span id='topic+splineBasis2Dpen'></span>

<h3>Description</h3>

<p>These functions calculate a penalized or unpenalized tensor product spline 
basis representation for functional data on two-dimensional domains based on 
the <code><a href="mgcv.html#topic+gam">gam</a></code>/<code><a href="mgcv.html#topic+bam">bam</a></code> functions in the
<span class="pkg">mgcv</span> package. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineBasis2D(funDataObject, bs = "ps", m = NA, k = -1)

splineBasis2Dpen(funDataObject, bs = "ps", m = NA, k = -1, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splineBasis2D_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code> 
containing the observed functional data samples and for which the basis 
representation is calculated.</p>
</td></tr>
<tr><td><code id="splineBasis2D_+3A_bs">bs</code></td>
<td>
<p>A vector of character strings (or a single character string), 
specifying the type of basis functions to be used. Defaults to <code>"ps"</code> 
(P-spline functions). Please refer to <code><a href="mgcv.html#topic+te">te</a></code> for a list of 
possible basis functions.</p>
</td></tr>
<tr><td><code id="splineBasis2D_+3A_m">m</code></td>
<td>
<p>A numeric vector (or a single number), the order of the spline 
basis. Defaults to <code>NA</code>, i.e. the order is chosen automatically.  See 
<code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
<tr><td><code id="splineBasis2D_+3A_k">k</code></td>
<td>
<p>An numeric vector (or a single number), the number of basis 
functions used.  Defaults to <code>-1</code>, i.e. the number of basis functions 
is chosen automatically.   See  <code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
<tr><td><code id="splineBasis2D_+3A_parallel">parallel</code></td>
<td>
<p>Logical (only for function <code>splineBasis2Dpen</code>). If 
<code>TRUE</code>, the coefficients for the basis functions are calculated in 
parallel. The implementation is based on the <code><a href="foreach.html#topic+foreach">foreach</a></code>
function and requires a parallel backend that must be registered before. 
See <code><a href="foreach.html#topic+foreach">foreach</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the basis representation is calculated without penalization 
(<code>splineBasis2D</code>), the coefficients are computed using the 
<code><a href="mgcv.html#topic+gam">gam</a></code> function from the <span class="pkg">mgcv</span> package. In the case of 
penalization (<code>splineBasis2Dpen</code>), the function <code><a href="mgcv.html#topic+bam">bam</a></code>
(for large GAMs) is used instead.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) with dimension 
<code>N x K</code>, reflecting the weights for each basis function in each 
observation, where <code>K</code> is the total number of basis functions used.</p>
</td></tr> 
<tr><td><code>B</code></td>
<td>
<p>A matrix containing the scalar product of all pairs of basis 
functions.</p>
</td></tr> <tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>FALSE</code>, as basis functions 
are not orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p><code>NULL</code>, as basis functions are 
known.</p>
</td></tr> <tr><td><code>settings</code></td>
<td>
<p>A list with entries <code>bs</code>, <code>m</code> and 
<code>k</code>, giving the actual parameters used for generating the spline basis
functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>, <code><a href="#topic+splineBasis1D">splineBasis1D</a></code>, 
<code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+bam">bam</a></code>, 
<code><a href="foreach.html#topic+foreach">foreach</a></code>
</p>

<hr>
<h2 id='splineFunction1D'>Calculate linear combinations of spline basis functions on one-dimensional 
domains</h2><span id='topic+splineFunction1D'></span>

<h3>Description</h3>

<p>Given scores (coefficients), this function calculates a linear combination of
spline basis functions on one-dimensional domains based on the 
<a href="mgcv.html#topic+gam">gam</a> function in the <span class="pkg">mgcv</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineFunction1D(scores, argvals, bs, m, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splineFunction1D_+3A_scores">scores</code></td>
<td>
<p>A matrix of dimension <code>N x K</code>, representing the <code>K</code> 
scores (coefficients) for each of the <code>N</code> observations.</p>
</td></tr>
<tr><td><code id="splineFunction1D_+3A_argvals">argvals</code></td>
<td>
<p>A list containing a vector of x-values, on which the functions
should be defined.</p>
</td></tr>
<tr><td><code id="splineFunction1D_+3A_bs">bs</code></td>
<td>
<p>A character string, specifying the type of basis functions to be 
used. Please refer to <code><a href="mgcv.html#topic+smooth.terms">smooth.terms</a></code> for a list of 
possible basis functions.</p>
</td></tr>
<tr><td><code id="splineFunction1D_+3A_m">m</code></td>
<td>
<p>A numeric, the order of the spline basis. See  <code><a href="mgcv.html#topic+s">s</a></code>
for details.</p>
</td></tr>
<tr><td><code id="splineFunction1D_+3A_k">k</code></td>
<td>
<p>A numeric, the number of basis functions used. See 
<code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>funData</code> with <code>N</code> observations on 
<code>argvals</code>, corresponding to the linear combination of spline basis 
functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univExpansion">univExpansion</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="#topic+splineBasis1D">splineBasis1D</a></code>
</p>

<hr>
<h2 id='splineFunction2D'>Calculate linear combinations of spline basis functions on
two-dimensional domains</h2><span id='topic+splineFunction2D'></span><span id='topic+splineFunction2Dpen'></span>

<h3>Description</h3>

<p>Given scores (coefficients), these functions calculate a linear
combination of spline tensor basis functions on two-dimensional domains
based on the <code><a href="mgcv.html#topic+gam">gam</a></code>/<code><a href="mgcv.html#topic+bam">bam</a></code> functions
in the <span class="pkg">mgcv</span> package. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineFunction2D(scores, argvals, bs, m, k)

splineFunction2Dpen(scores, argvals, bs, m, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splineFunction2D_+3A_scores">scores</code></td>
<td>
<p>A matrix of dimension <code>N x K</code>, representing the
<code>K</code> scores (coefficients) for each of the <code>N</code> observations.</p>
</td></tr>
<tr><td><code id="splineFunction2D_+3A_argvals">argvals</code></td>
<td>
<p>A list containing a two numeric vectors, corresponding
to the x- and y-values, on which the functions should be defined.</p>
</td></tr>
<tr><td><code id="splineFunction2D_+3A_bs">bs</code></td>
<td>
<p>A vector of character strings (or a single character), the
type of basis functions to be used. Please refer to
<code><a href="mgcv.html#topic+te">te</a></code> for a list of possible basis functions.</p>
</td></tr>
<tr><td><code id="splineFunction2D_+3A_m">m</code></td>
<td>
<p>A numeric vector (or a single number), the order of the spline
basis. See <code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
<tr><td><code id="splineFunction2D_+3A_k">k</code></td>
<td>
<p>A numeric vector (or a single number), the number of basis
functions used.  See  <code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the scores have been calculated based on an unpenalized tensor
spline basis, the linear combination is computed based on the
<code><a href="mgcv.html#topic+gam">gam</a></code> functions ((<code>splineFunction2D</code>)). If the
scores were obtained using penalization, the expansion is calculated
via <a href="mgcv.html#topic+bam">bam</a> (<code>splineFunction2Dpen</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>funData</code> with <code>N</code> observations on
the two-dimensional domain specified by <code>argvals</code>, corresponding
to the linear combination of spline basis functions.
</p>


<h3>Warning</h3>

<p>The function <code>splineFunction2Dpen</code>, which relies
on <a href="mgcv.html#topic+bam">bam</a> has not been tested with ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univExpansion">univExpansion</a></code>,  <code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="#topic+splineBasis2D">splineBasis2D</a></code>
</p>

<hr>
<h2 id='stratSample'>Sample stratified indices according to a factor variable</h2><span id='topic+stratSample'></span>

<h3>Description</h3>

<p>Sample stratified indices according to a factor variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratSample(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratSample_+3A_f">f</code></td>
<td>
<p>A factor variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>f</code>, containing the resampled
indices, stratified according to the levels of f
</p>

<hr>
<h2 id='summary.MFPCAfit'>Summarize a Multivariate Functional Principal Component Analysis</h2><span id='topic+summary.MFPCAfit'></span>

<h3>Description</h3>

<p>A <code>summary</code> method for class <code>MFPCAfit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFPCAfit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MFPCAfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>MFPCAfit</code>, usually returned by a
call to <a href="#topic+MFPCA">MFPCA</a>.</p>
</td></tr>
<tr><td><code id="summary.MFPCAfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.MFPCAfit</code>
</p>

<hr>
<h2 id='ttv'>Tensor times vector calculation</h2><span id='topic+ttv'></span>

<h3>Description</h3>

<p>Functionality adapted from the MATLAB tensor toolbox 
(<a href="https://www.tensortoolbox.org/">https://www.tensortoolbox.org/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttv(A, v, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttv_+3A_a">A</code></td>
<td>
<p>An array.</p>
</td></tr>
<tr><td><code id="ttv_+3A_v">v</code></td>
<td>
<p>A list of the same length as <code>dim</code>.</p>
</td></tr>
<tr><td><code id="ttv_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions for the multiplication.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>A</code> be a tensor with dimensions <code class="reqn">d_1 \times d_2 \times \ldots 
\times d_p</code> and let <code>v</code> be a vector of length 
<code class="reqn">d_i</code>. Then the tensor-vector-product along the <code class="reqn">i</code>-th dimension is 
defined as </p>
<p style="text-align: center;"><code class="reqn">B_{j_1 \ldots j_{i-1}j_{i+1} \ldots j_d} = \sum_{i=1}^{d_i} 
A_{j_1 \ldots j_{i-1} i j_{i+1} \ldots j_d} \cdot v_i.</code>
</p>
<p> It can hence be seen as a generalization of the 
matrix-vector product.
</p>
<p>The tensor-vector-product along several dimensions between a tensor <code>A</code> 
and multiple vectors <code>v_1,...,v_k</code> (<code class="reqn">k \le p</code>) is defined as a 
series of consecutive tensor-vector-product along the different dimensions.
For consistency, the multiplications are calculated from the dimension of the
highest order to the lowest.
</p>


<h3>Value</h3>

<p>An array, the result of the multiplication.
</p>


<h3>References</h3>

<p>B. W. Bader and T. G. Kolda. Algorithm 862: MATLAB tensor classes
for fast algorithm prototyping, ACM Transactions on Mathematical Software 
32(4):635-653, December 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UMPCA">UMPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a three-mode tensor
a1 &lt;- seq(0,1, length.out = 10)
a2 &lt;- seq(-1,1, length.out = 20)
a3 &lt;- seq(-pi, pi, length.out = 15)
A &lt;-a1 %o% a2 %o% a3
dim(A)

# multiply along different dimensions
dim(ttv(A = A, v = list(rnorm(10)), dim = 1))
dim(ttv(A = A, v = list(rnorm(20)), dim = 2))
dim(ttv(A = A, v = list(rnorm(15)), dim = 3))

# multiply along more than one dimension
length(ttv(A = A, v = list(rnorm(10), rnorm(15)), dim = c(1,3)))
</code></pre>

<hr>
<h2 id='ttvCalculation'>Internal function for the Tensor times Vector calculation</h2><span id='topic+ttvCalculation'></span>

<h3>Description</h3>

<p>Internal function for the Tensor times Vector calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttvCalculation(A, v, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttvCalculation_+3A_a">A</code></td>
<td>
<p>Tensor</p>
</td></tr>
<tr><td><code id="ttvCalculation_+3A_v">v</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="ttvCalculation_+3A_dim">dim</code></td>
<td>
<p>Dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of tensor times vector calculation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ttv">ttv</a></code>
</p>

<hr>
<h2 id='UMPCA'>UMPCA: Uncorrelated Multilinear Principle Component Analysis</h2><span id='topic+UMPCA'></span>

<h3>Description</h3>

<p>This function implements the uncorrelated multilinear principal component
analysis for tensors of dimension 2, 3 or 4. The code is basically the same
as in the  MATLAB toolbox UMPCA by Haiping Lu (Link:
<a href="https://www.mathworks.com/matlabcentral/fileexchange/35432-uncorrelated-multilinear-principal-component-analysis-umpca">https://www.mathworks.com/matlabcentral/fileexchange/35432-uncorrelated-multilinear-principal-component-analysis-umpca</a>,
see also references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UMPCA(TX, numP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UMPCA_+3A_tx">TX</code></td>
<td>
<p>The input training data in tensorial representation, the last mode
is the sample mode. For <code>N</code>th-order tensor data, <code>TX</code> is of
<code>(N+1)</code>th-order with the <code>(N+1)</code>-mode to be the sample mode.
E.g., 30x20x10x100 for 100 samples of size 30x20x10.</p>
</td></tr>
<tr><td><code id="UMPCA_+3A_nump">numP</code></td>
<td>
<p>The dimension of the projected vector, denoted as <code class="reqn">P</code> in the
paper. It is the number of elementary multilinear projections (EMPs) in
tensor-to-vector projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Us</code></td>
<td>
<p>The multilinear projection, consisting of <code>numP</code>
(<code class="reqn">P</code> in the paper) elementary multilinear projections (EMPs), each EMP
is consisted of <code>N</code> vectors, one in each mode.</p>
</td></tr> <tr><td><code>TXmean</code></td>
<td>
<p>The mean
of the input training samples <code>TX</code>.</p>
</td></tr> <tr><td><code>odrIdx</code></td>
<td>
<p>The ordering index
of projected features in decreasing variance.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>As this algorithm aims more at uncorrelated features than
at an optimal reconstruction of the data, hence it might give poor results
when used for the univariate decomposition of images in MFPCA.
</p>


<h3>References</h3>

<p>Haiping Lu, K.N. Plataniotis, and A.N. Venetsanopoulos,
&quot;Uncorrelated Multilinear Principal Component Analysis for Unsupervised
Multilinear Subspace Learning&quot;, IEEE Transactions on Neural Networks, Vol.
20, No. 11, Page: 1820-1836, Nov. 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)

 # define "true" components
 a &lt;- sin(seq(-pi, pi, length.out = 100))
 b &lt;- exp(seq(-0.5, 1, length.out = 150))

 # simulate tensor data
 X &lt;- a %o% b %o% rnorm(80, sd = 0.5)

 # estimate one component
 UMPCAres &lt;- UMPCA(X, numP = 1)

 # plot the results and compare to true values
 plot(UMPCAres$Us[[1]][,1])
 points(a/sqrt(sum(a^2)), pch = 20) # eigenvectors are defined only up to a sign change!
 legend("topright", legend = c("True", "Estimated"), pch = c(20, 1))

 plot(UMPCAres$Us[[2]][,1])
 points(b/sqrt(sum(b^2)), pch = 20)
 legend("topleft", legend = c("True", "Estimated"), pch = c(20, 1))
</code></pre>

<hr>
<h2 id='umpcaBasis'>Calculate an uncorrelated multilinear principal component basis
representation for functional data on two-dimensional domains</h2><span id='topic+umpcaBasis'></span>

<h3>Description</h3>

<p>This function calculates an uncorrelated multilinear principal component
analysis (UMPCA) representation for functional data on two-dimensional
domains. In this case, the data can be interpreted as images with <code>S1 x
S2</code> pixels (assuming <code>nObsPoints(funDataObject) = (S1, S2)</code>), i.e. the
total observed data are represented as third order tensor of dimension
<code>N x S1 x S2</code>.  The UMPCA of a tensor of this kind is calculated via the
<a href="#topic+UMPCA">UMPCA</a> function, which is an <code>R</code>-version of the analogous
functions in the <code>UMPCA</code> MATLAB toolbox by Haiping Lu (Link:
<a href="https://www.mathworks.com/matlabcentral/fileexchange/35432-uncorrelated-multilinear-principal-component-analysis-umpca">https://www.mathworks.com/matlabcentral/fileexchange/35432-uncorrelated-multilinear-principal-component-analysis-umpca</a>,
see also references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umpcaBasis(funDataObject, npc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="umpcaBasis_+3A_fundataobject">funDataObject</code></td>
<td>
<p>An object of class <code><a href="funData.html#topic+funData">funData</a></code>
containing the observed functional data samples (here: images) for which
the UMPCA is to be calculated.</p>
</td></tr>
<tr><td><code id="umpcaBasis_+3A_npc">npc</code></td>
<td>
<p>An integer, giving the number of principal components to be
calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) with dimension
<code>N x k</code>, reflecting the weight of each principal component in each
observation.</p>
</td></tr>  <tr><td><code>B</code></td>
<td>
<p>A matrix containing the scalar product of all pairs
of basis functions.</p>
</td></tr> <tr><td><code>ortho</code></td>
<td>
<p>Logical, set to <code>FALSE</code>, as basis
functions are not orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A functional data object,
representing the functional principal component basis functions.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>As this algorithm aims more at uncorrelated features than
at an optimal reconstruction of the data, hence it might give poor results
when used for the univariate decomposition of images in MFPCA. The function
therefore throws a warning.
</p>


<h3>References</h3>

<p>Haiping Lu, K.N. Plataniotis, and A.N. Venetsanopoulos,
&quot;Uncorrelated Multilinear Principal Component Analysis for Unsupervised
Multilinear Subspace Learning&quot;, IEEE Transactions on Neural Networks, Vol.
20, No. 11, Page: 1820-1836, Nov. 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+univDecomp">univDecomp</a></code>
</p>

<hr>
<h2 id='univDecomp'>Univariate basis decomposition</h2><span id='topic+univDecomp'></span>

<h3>Description</h3>

<p>This function calculates a univariate basis decomposition for a
(univariate) functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univDecomp(type, funDataObject, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="univDecomp_+3A_type">type</code></td>
<td>
<p>A character string, specifying the basis for which the
decomposition is to be calculated.</p>
</td></tr>
<tr><td><code id="univDecomp_+3A_fundataobject">funDataObject</code></td>
<td>
<p>A <code>funData</code> object, representing the
(univariate) functional data samples.</p>
</td></tr>
<tr><td><code id="univDecomp_+3A_...">...</code></td>
<td>
<p>Further parameters, passed to the function for the
particular basis to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional data <code class="reqn">X_i(t)</code> can often be approximated by a linear
combination of basis functions <code class="reqn">b_k(t)</code> </p>
<p style="text-align: center;"><code class="reqn">X_i(t) = \sum_{k =
1}^K \theta_{ik} b_k(t), i = 1, \ldots, N.</code>
</p>
<p> The basis functions may be
prespecified (such as spline basis functions or Fourier bases) or can
be estimated from the data (e.g. by functional principal component
analysis) and are the same for all observations <code class="reqn">X_1(t), \ldots,
X_n(t)</code>. The coefficients (or scores) <code class="reqn">\theta_{ik}</code> reflect the
weight of each basis function <code class="reqn">b_k(t)</code> for the observed function
<code class="reqn">X_i(t)</code> and can be used to characterize the individual
observations.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) for each
observation based on the prespecified basis functions.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>A
matrix containing the scalar products of the basis functions. Can be
<code>NULL</code> if the basis functions are orthonormal.</p>
</td></tr>
<tr><td><code>ortho</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the basis functions are all
orthonormal.</p>
</td></tr> <tr><td><code>functions</code></td>
<td>
<p>A functional data object, representing
the basis functions. Can be <code>NULL</code> if the basis functions are
not estimated from the data, but have a predefined form. See
Details.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The options <code>type = "DCT2D"</code> and <code>type =
  "DCT3D"</code> have not been tested with ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>, <code><a href="#topic+univExpansion">univExpansion</a></code>,
<code><a href="#topic+fpcaBasis">fpcaBasis</a></code>, <code><a href="#topic+splineBasis1D">splineBasis1D</a></code>,
<code><a href="#topic+splineBasis1Dpen">splineBasis1Dpen</a></code>, <code><a href="#topic+splineBasis2D">splineBasis2D</a></code>,
<code><a href="#topic+splineBasis2Dpen">splineBasis2Dpen</a></code>, <code><a href="#topic+umpcaBasis">umpcaBasis</a></code>,
<code><a href="#topic+fcptpaBasis">fcptpaBasis</a></code>, <code><a href="#topic+fdaBasis">fdaBasis</a></code>,
<code><a href="#topic+dctBasis2D">dctBasis2D</a></code>, <code><a href="#topic+dctBasis3D">dctBasis3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some data
dat &lt;- simFunData(argvals = seq(0,1,0.01), M = 5,
                  eFunType = "Poly", eValType = "linear", N = 100)$simData

# decompose the data in univariate functional principal components...
decFPCA &lt;- univDecomp(type = "uFPCA", funDataObject = dat, npc = 5)
str(decFPCA)

# or in splines (penalized)
decSplines &lt;- univDecomp(type = "splines1Dpen", funDataObject = dat) # use mgcv's default params
str(decSplines)
</code></pre>

<hr>
<h2 id='univExpansion'>Calculate a univariate basis expansion</h2><span id='topic+univExpansion'></span>

<h3>Description</h3>

<p>This function calculates a univariate basis expansion based on given
scores (coefficients) and basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univExpansion(
  type,
  scores,
  argvals = ifelse(!is.null(functions), functions@argvals, NULL),
  functions,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="univExpansion_+3A_type">type</code></td>
<td>
<p>A character string, specifying the basis for which the
decomposition is to be calculated.</p>
</td></tr>
<tr><td><code id="univExpansion_+3A_scores">scores</code></td>
<td>
<p>A matrix of scores (coefficients) for each observation
based on the given basis functions.</p>
</td></tr>
<tr><td><code id="univExpansion_+3A_argvals">argvals</code></td>
<td>
<p>A list, representing the domain of the basis functions.
If <code>functions</code> is not <code>NULL</code>, the usual default is
<code>functions@argvals</code>. See funData and the
underlying expansion functions for details.</p>
</td></tr>
<tr><td><code id="univExpansion_+3A_functions">functions</code></td>
<td>
<p>A functional data object, representing the basis
functions. Can be <code>NULL</code> if the basis functions are not
estimated from observed data, but have a predefined form. See
Details.</p>
</td></tr>
<tr><td><code id="univExpansion_+3A_params">params</code></td>
<td>
<p>A list containing the parameters for the particular basis
to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates functional data <code class="reqn">X_i(t), i= 1 \ldots N</code>
that is represented as a linear combination of basis functions
<code class="reqn">b_k(t)</code> </p>
<p style="text-align: center;"><code class="reqn">X_i(t) = \sum_{k = 1}^K \theta_{ik} b_k(t), i = 1,
\ldots, N.</code>
</p>
<p> The basis functions may be prespecified (such as spline
basis functions or Fourier bases) or can be estimated from observed
data (e.g. by functional principal component analysis). If <code>type =
"default"</code> (i.e. a linear combination of arbitrary basis functions is
to be calculated), both scores and basis functions must be supplied.
</p>


<h3>Value</h3>

<p>An object of class <code>funData</code> with <code>N</code> observations on
<code>argvals</code>, corresponding to the linear combination of the basis
functions.
</p>


<h3>Warning</h3>

<p>The options <code>type = "spline2Dpen"</code>, <code>type =
  "DCT2D"</code> and <code>type = "DCT3D"</code> have not been tested with
ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFPCA">MFPCA</a></code>, <code><a href="#topic+splineFunction1D">splineFunction1D</a></code>,
<code><a href="#topic+splineFunction2D">splineFunction2D</a></code>, <code><a href="#topic+splineFunction2Dpen">splineFunction2Dpen</a></code>,
<code><a href="#topic+dctFunction2D">dctFunction2D</a></code>, <code><a href="#topic+dctFunction3D">dctFunction3D</a></code>,
<code><a href="#topic+expandBasisFunction">expandBasisFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,1))

set.seed(1234)

### Spline basis ###
# simulate coefficients (scores) for N = 10 observations and K = 8 basis functions
N &lt;- 10
K &lt;- 8
scores &lt;- t(replicate(n = N, rnorm(K, sd = (K:1)/K)))
dim(scores)

# expand spline basis on [0,1]
funs &lt;- univExpansion(type = "splines1D", scores = scores, argvals = list(seq(0,1,0.01)),
                      functions = NULL, # spline functions are known, need not be given
                      params = list(bs = "ps", m = 2, k = K)) # params for mgcv

plot(funs, main = "Spline reconstruction")

### PCA basis ###
# simulate coefficients (scores) for N = 10 observations and K = 8 basis functions
N &lt;- 10
K &lt;- 8

scores &lt;- t(replicate(n = N, rnorm(K, sd = (K:1)/K)))
dim(scores)

# Fourier basis functions as eigenfunctions
eFuns &lt;- eFun(argvals = seq(0,1,0.01), M = K, type = "Fourier")

# expand eigenfunction basis
funs &lt;-  univExpansion(type = "uFPCA", scores = scores,
                       argvals = NULL, # use argvals of eFuns (default)
                       functions = eFuns)

plot(funs, main = "PCA reconstruction")

par(oldPar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
