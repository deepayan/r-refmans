<!DOCTYPE html><html lang="en"><head><title>Help for package VARshrink</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VARshrink}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Acoef_sh'><p>Coefficient matrices of endogenous variables</p></a></li>
<li><a href='#arch.test_sh'><p>ARCH-LM test</p></a></li>
<li><a href='#Bcoef_sh'><p>Coefficient matrix</p></a></li>
<li><a href='#BQ_sh'><p>BQ function for class &quot;varshrinkest&quot;</p></a></li>
<li><a href='#calcSSE_Acoef'><p>Sum of squared errors (SSE) between coefficients of two VARs</p></a></li>
<li><a href='#causality_sh'><p>Causality Analysis for class &quot;varshrinkest&quot;</p></a></li>
<li><a href='#convPsi2varresult'><p>Convert format for VAR coefficients from Psi to varresult</p></a></li>
<li><a href='#createVARCoefs_ltriangular'><p>Create coefficients of a VAR model</p></a></li>
<li><a href='#fevd.varshrinkest'><p>Forecast Error Variance Decomposition</p></a></li>
<li><a href='#irf.varshrinkest'><p>Impulse response function</p></a></li>
<li><a href='#lm_full_Bayes_SR'><p>Full Bayesian Shrinkage Estimation Method for Multivariate Regression</p></a></li>
<li><a href='#lm_multiv_ridge'><p>Multivariate Ridge Regression</p></a></li>
<li><a href='#lm_semi_Bayes_PCV'><p>Semiparametric Bayesian Shrinkage Estimation Method for Multivariate</p>
Regression</a></li>
<li><a href='#lm_ShVAR_KCV'><p>K-fold Cross Validation for Selection of Shrinkage Parameters of</p>
Semiparametric Bayesian Shrinkage Estimator for Multivariate Regression</a></li>
<li><a href='#logLik.varshrinkest'><p>Log-likelihood method for class &quot;varshrinkest&quot;</p></a></li>
<li><a href='#normality.test_sh'><p>Normality, multivariate skewness and kurtosis test</p></a></li>
<li><a href='#Phi.varshrinkest'><p>Coefficient matrices of the MA represention</p></a></li>
<li><a href='#predict.varshrinkest'><p>Predict method for objects of class varshrinkest</p></a></li>
<li><a href='#print.varshrinkest'><p>Print method for class &quot;varshrinkest&quot;</p></a></li>
<li><a href='#print.varshsum'><p>Print method for class &quot;varshsum&quot;</p></a></li>
<li><a href='#restrict_sh'><p>Restricted VAR</p></a></li>
<li><a href='#roots_sh'><p>Eigenvalues of the companion coefficient matrix of</p>
a VAR(p)-process</a></li>
<li><a href='#serial.test_sh'><p>Test for serially correlated errors for VAR shrinkage estimate</p></a></li>
<li><a href='#shrinkVARcoef'><p>Semiparametric Bayesian Shrinkage Estimator for</p>
Multivariate Regression</a></li>
<li><a href='#simVARmodel'><p>Generate multivariate time series data using the given VAR model</p></a></li>
<li><a href='#stability_sh'><p>Stability function</p></a></li>
<li><a href='#summary.shrinklm'><p>Summary method for class &quot;shrinklm&quot;</p></a></li>
<li><a href='#summary.varshrinkest'><p>Summary method for an object of class 'varshrinkest',</p>
VAR parameters estimated by VARshrink()</a></li>
<li><a href='#VARshrink'><p>Shrinkage estimation of VAR parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Shrinkage Estimation Methods for Vector Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Vector autoregressive (VAR) model is a fundamental and effective approach
    for multivariate time series analysis. Shrinkage estimation methods can be
    applied to high-dimensional VAR models with dimensionality greater than
    the number of observations, contrary to the standard ordinary least squares
    method. This package is an integrative package delivering nonparametric,
    parametric, and semiparametric methods in a unified and consistent manner,
    such as the multivariate ridge regression in Golub, Heath, and Wahba (1979)
    &lt;<a href="https://doi.org/10.2307%2F1268518">doi:10.2307/1268518</a>&gt;, a James-Stein type nonparametric shrinkage method in
    Opgen-Rhein and Strimmer (2007) &lt;<a href="https://doi.org/10.1186%2F1471-2105-8-S2-S3">doi:10.1186/1471-2105-8-S2-S3</a>&gt;, and
    Bayesian estimation methods using noninformative and informative priors
    in Lee, Choi, and S.-H. Kim (2016) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.03.007">doi:10.1016/j.csda.2016.03.007</a>&gt; and
    Ni and Sun (2005) &lt;<a href="https://doi.org/10.1198%2F073500104000000622">doi:10.1198/073500104000000622</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vars (&ge; 1.5.3), ars (&ge; 0.6), corpcor (&ge; 1.6.9),
strucchange, stats, MASS, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rticles, kableExtra</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/namgillee/VARshrink/">https://github.com/namgillee/VARshrink/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/namgillee/VARshrink/issues/">https://github.com/namgillee/VARshrink/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-10-07 13:31:17 UTC; namgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Namgil Lee <a href="https://orcid.org/0000-0003-0593-9028"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Heon Young Yang [ctb],
  Sung-Ho Kim [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Namgil Lee &lt;namgil.lee@kangwon.ac.kr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-10-09 15:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Acoef_sh'>Coefficient matrices of endogenous variables</h2><span id='topic+Acoef_sh'></span>

<h3>Description</h3>

<p>Returns the estimated coefficient matrices of the lagged endogenous
variables of a VAR(p) model.
This is a modification of vars::Acoef() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Acoef_sh(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Acoef_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkeset&quot;, generated by VARshrink().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + C d_t + e_t .</code>
</p>

<p>The function returns the K-by-K matrices A_1, ..., A_p as a list object.
</p>


<h3>Value</h3>

<p>A list object with K-by-K VAR coefficient matrices A_1, A_2, ..., A_p
</p>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+Acoef">Acoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
Acoef_sh(estim)
</code></pre>

<hr>
<h2 id='arch.test_sh'>ARCH-LM test</h2><span id='topic+arch.test_sh'></span>

<h3>Description</h3>

<p>Performs univariate and multivariate ARCH-LM tests for a VAR.
This is a modification of vars::arch.test() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arch.test_sh(x, lags.single = 16, lags.multi = 5,
  multivariate.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arch.test_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; obtained by VARshrink()</p>
</td></tr>
<tr><td><code id="arch.test_sh_+3A_lags.single">lags.single</code></td>
<td>
<p>An integer of the lag order used for
univariate ARCH statistics.</p>
</td></tr>
<tr><td><code id="arch.test_sh_+3A_lags.multi">lags.multi</code></td>
<td>
<p>An integer of the lag order used for
multivariate ARCH statistic.</p>
</td></tr>
<tr><td><code id="arch.test_sh_+3A_multivariate.only">multivariate.only</code></td>
<td>
<p>If TRUE, only the multivariate statistic
is computed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+arch.test">arch.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
arch.test_sh(estim)
</code></pre>

<hr>
<h2 id='Bcoef_sh'>Coefficient matrix</h2><span id='topic+Bcoef_sh'></span>

<h3>Description</h3>

<p>Returns the estimated coefficients of a VAR(p) model as a matrix.
This is a modification of vars::Bcoef() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bcoef_sh(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bcoef_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; generated by VARshrink().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + C d_t + e_t .</code>
</p>

<p>The function returns the concatenated matrix (A_1, ..., A_p, C) as a matrix
object.
</p>


<h3>Value</h3>

<p>A matrix holding the estimated coefficients of a VAR.
</p>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+Bcoef">Bcoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
Bcoef_sh(estim)
</code></pre>

<hr>
<h2 id='BQ_sh'>BQ function for class &quot;varshrinkest&quot;</h2><span id='topic+BQ_sh'></span>

<h3>Description</h3>

<p>This is a modification of vars::BQ() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BQ_sh(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BQ_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; obtained by VARshrink().</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+BQ">BQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
BQ_sh(estim)
</code></pre>

<hr>
<h2 id='calcSSE_Acoef'>Sum of squared errors (SSE) between coefficients of two VARs</h2><span id='topic+calcSSE_Acoef'></span>

<h3>Description</h3>

<p>Compute sum of squared errors of coefficients of lagged endogenous
variables (Acoef) of two VAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSSE_Acoef(Acoef1, Acoef2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcSSE_Acoef_+3A_acoef1">Acoef1</code>, <code id="calcSSE_Acoef_+3A_acoef2">Acoef2</code></td>
<td>
<p>Each one is a list object with K-by-K coefficient
matrices of lagged endogenous variables. See help(Acoef_sh), or,
help(Acoef).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + C d_t + e_t.</code>
</p>

<p>The SSE of two VAR(p) models is expressed as
</p>
<p style="text-align: center;"><code class="reqn">sum_{k=1}^p sum_{i=1}^K sum_{j=1}^K ( (A_k)_{ij} - (A_k')_{ij} )^2.</code>
</p>



<h3>Value</h3>

<p>SSE value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim1 &lt;- VARshrink(y, p = 2, type = "const", method = "fbayes")
Acoef1 &lt;- Acoef_sh(estim1)
estim2 &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
Acoef2 &lt;- Acoef_sh(estim2)
calcSSE_Acoef(Acoef1, Acoef2)
</code></pre>

<hr>
<h2 id='causality_sh'>Causality Analysis for class &quot;varshrinkest&quot;</h2><span id='topic+causality_sh'></span>

<h3>Description</h3>

<p>A modification of vars::causality() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causality_sh(x, cause = NULL, vcov. = NULL, boot = FALSE,
  boot.runs = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="causality_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; obtained by VARshrink().</p>
</td></tr>
<tr><td><code id="causality_sh_+3A_cause">cause</code>, <code id="causality_sh_+3A_vcov.">vcov.</code>, <code id="causality_sh_+3A_boot">boot</code>, <code id="causality_sh_+3A_boot.runs">boot.runs</code></td>
<td>
<p>Other arguments for
causality analysis; see help(causality) for details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+causality">causality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
causality_sh(estim, cause = "e")
</code></pre>

<hr>
<h2 id='convPsi2varresult'>Convert format for VAR coefficients from Psi to varresult</h2><span id='topic+convPsi2varresult'></span>

<h3>Description</h3>

<p>Convert a matrix of VAR coefficients estimated by a shrinkage method
into a list of &quot;shrinklm&quot; object, where the class &quot;shrinklm&quot; inherits the
class &quot;lm&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convPsi2varresult(Psi, Y, X, lambda0, type = c("const", "trend", "both",
  "none"), ybar = NULL, xbar = NULL, Q_values = NULL, callstr = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convPsi2varresult_+3A_psi">Psi</code></td>
<td>
<p>An M-by-K matrix of VAR coefficients</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_y">Y</code></td>
<td>
<p>An N-by-K data matrix of dependent variables</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_x">X</code></td>
<td>
<p>An N-by-M data matrix of regressors</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_lambda0">lambda0</code></td>
<td>
<p>A rescaled shrinkage intensity parameter, based on which the
effective number of parameters is computed by </p>
<p style="text-align: center;"><code class="reqn">Trace(X(X'X+lambda0*I)^{-1} X')</code>
</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_type">type</code></td>
<td>
<p>Type of deterministic variables in the VAR estimation problem.
Either of &quot;const&quot;, &quot;trend&quot;, &quot;both&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_ybar">ybar</code>, <code id="convPsi2varresult_+3A_xbar">xbar</code></td>
<td>
<p>NULL if Y and X are not centered. Mean vectors if Y and X
had been centered. If Y and X had been centered (ybar and xbar are not NULL)
and type is &quot;const&quot; or &quot;both&quot;, then the coefficients for the constant term
is computed and concatenated to the coefficients.</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_q_values">Q_values</code></td>
<td>
<p>Nonnegative weight vector of length N. Default is NULL.
Take weights on rows (samples) of Y and X by sqrt(Q).</p>
</td></tr>
<tr><td><code id="convPsi2varresult_+3A_callstr">callstr</code></td>
<td>
<p>The call to VARshrink().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + C d_t + e_t.</code>
</p>

<p>It can be written in the matrix form:
</p>
<p style="text-align: center;"><code class="reqn">Y = X Psi + E,</code>
</p>

<p>where Psi is a concatenated M-by-K matrix, Psi = (A_1, ..., A_p, C)^T.
It can be written in the multiple linear regression form of a VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_j = X psi_j + e_j, \quad j=1,...,K,</code>
</p>

<p>where y_j, psi_j, and e_j are the j-th column vectors of Y, Psi, and E,
respectively.
This function converts Psi into a list of &quot;shrinklm&quot; objects, where
each &quot;shrinklm&quot; object contains the length-M vector psi_j as coefficients.
</p>
<p>Considering that each coefficient vector psi_j is estimated by a
shrinkage method, the effective number of parameters, k_eff, is
computed as:
</p>
<p style="text-align: center;"><code class="reqn">k_{eff} = Trace(X (X^T X + lambda0 * I)^{-1} X^T).</code>
</p>

<p>Then, the degree of freedom of residuals is computed as:
</p>
<p style="text-align: center;"><code class="reqn">df.residual = N - k_{eff},</code>
</p>

<p>where N is the number of rows of data matrices Y and X.
</p>


<h3>Value</h3>

<p>A list object with objects of class c(&quot;shrinklm&quot;, &quot;lm&quot;).
Each &quot;shrinklm&quot; object has components: coefficients, residuals, fitted.values,
rank, df.residual, lambda0, call, terms, svd
</p>

<hr>
<h2 id='createVARCoefs_ltriangular'>Create coefficients of a VAR model</h2><span id='topic+createVARCoefs_ltriangular'></span>

<h3>Description</h3>

<p>Randomly create sparse lower-triangular matrices for VAR coefficients of
lagged endogenous variables, and set a constant vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createVARCoefs_ltriangular(p = 1, K = 5, diag_val = 1/p,
  num_nonzero = 0, const_vector = NULL, range_min = 0.2,
  range_max = 1/p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createVARCoefs_ltriangular_+3A_p">p</code></td>
<td>
<p>lag order</p>
</td></tr>
<tr><td><code id="createVARCoefs_ltriangular_+3A_k">K</code></td>
<td>
<p>Number of time series variables.</p>
</td></tr>
<tr><td><code id="createVARCoefs_ltriangular_+3A_diag_val">diag_val</code></td>
<td>
<p>diagonal values of A1,...,Ap</p>
</td></tr>
<tr><td><code id="createVARCoefs_ltriangular_+3A_num_nonzero">num_nonzero</code></td>
<td>
<p>Number of nonzero entries on the lower-triangular parts of
A1, ..., Ap</p>
</td></tr>
<tr><td><code id="createVARCoefs_ltriangular_+3A_const_vector">const_vector</code></td>
<td>
<p>constant vector c of the VAR model</p>
</td></tr>
<tr><td><code id="createVARCoefs_ltriangular_+3A_range_min">range_min</code>, <code id="createVARCoefs_ltriangular_+3A_range_max">range_max</code></td>
<td>
<p>Each nonzero off-diagonal entry of coefficient
matrices is drawn uniformly from the interval
[-range_max, -range_min] U [range_min, range_max]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider VAR(p) model:
</p>
<p style="text-align: center;"><code class="reqn">y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + c + e_t,</code>
</p>

<p>with the constant deterministic variable (d_t = 1).
The function creates the coefficient matrices A_1, ..., A_p and constant
vector c.
</p>
<p>Diagonal elements of each K-by-K matrix A_k are all equal to diag_val,
and off-diagonal elements are all zero except for a few randomly selected
nonzero elements. Nonzero off-diagonal elements are selected from
lower-triangular parts of A_i and the values are drawn from a uniform
distribution over [-range_max, -range_min] U [range_min, range_max].
</p>


<h3>Value</h3>

<p>A list object with components $A and $c. $A is a list of K-by-K
matrices A_1, ..., A_p, and $c is a constant vector of length K.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 1; K &lt;- 20;
const_vector &lt;- c(rep(0.2, 5), rep(0.7, 15))
createVARCoefs_ltriangular(p = p, K = K, diag_val = 0.6,
num_nonzero = K, const_vector = const_vector, range_max = 1)
</code></pre>

<hr>
<h2 id='fevd.varshrinkest'>Forecast Error Variance Decomposition</h2><span id='topic+fevd.varshrinkest'></span>

<h3>Description</h3>

<p>Computes the forecast error variance decomposition of a VAR(p) for
n.ahead steps.
This is a modification of vars::fevd() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
fevd(x, n.ahead = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fevd.varshrinkest_+3A_x">x</code></td>
<td>
<p>Object of class 'varshrinkest';
generated by <code>VARshrink()</code>.</p>
</td></tr>
<tr><td><code id="fevd.varshrinkest_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="fevd.varshrinkest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+fevd">fevd</a></code>
</p>

<hr>
<h2 id='irf.varshrinkest'>Impulse response function</h2><span id='topic+irf.varshrinkest'></span>

<h3>Description</h3>

<p>Computes the impulse response coefficients of a VAR(p)
(or transformed VECM to VAR(p)) for n.ahead steps.
This is a modification of vars::irf() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
irf(x, impulse = NULL, response = NULL,
  n.ahead = 10, ortho = TRUE, cumulative = FALSE, boot = TRUE,
  ci = 0.95, runs = 100, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irf.varshrinkest_+3A_x">x</code></td>
<td>
<p>Object of class 'varshrinkest';
generated by <code>VARshrink()</code></p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_impulse">impulse</code></td>
<td>
<p>A character vector of the impulses,
default is all variables.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_response">response</code></td>
<td>
<p>A character vector of the responses,
default is all variables.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_ortho">ortho</code></td>
<td>
<p>Logical, if TRUE (the default) the
orthogonalised impulse response coefficients are
computed (only for objects of class 'varshrinkest').</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulated impulse
response coefficients are computed. The default value
is false.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_boot">boot</code></td>
<td>
<p>Logical, if TRUE (the default) bootstrapped
error bands for the imuplse response coefficients are
computed.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_ci">ci</code></td>
<td>
<p>Numeric, the confidence interval for the
bootstrapped errors bands.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_runs">runs</code></td>
<td>
<p>An integer, specifying the runs for the
bootstrap.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_seed">seed</code></td>
<td>
<p>An integer, specifying the seed for the
rng of the bootstrap.</p>
</td></tr>
<tr><td><code id="irf.varshrinkest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+irf">irf</a></code>
</p>

<hr>
<h2 id='lm_full_Bayes_SR'>Full Bayesian Shrinkage Estimation Method for Multivariate Regression</h2><span id='topic+lm_full_Bayes_SR'></span>

<h3>Description</h3>

<p>Estimate regression coefficients and scale matrix for noise by using
Gibbs MCMC algorithm. The function assumes 1) multivariate t-distribution
for noise as a sampling distribution, and 2) noninformative priors for
regression coefficients and scale matrix for noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_full_Bayes_SR(Y, X, dof = Inf, burnincycle = 1000,
  mcmccycle = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_full_Bayes_SR_+3A_y">Y</code></td>
<td>
<p>An N x K matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="lm_full_Bayes_SR_+3A_x">X</code></td>
<td>
<p>An N x M matrix of regressors.</p>
</td></tr>
<tr><td><code id="lm_full_Bayes_SR_+3A_dof">dof</code></td>
<td>
<p>Degree of freedom for multivariate t-distribution.
If dof = Inf (default), then multivariate normal distribution is applied and
weight vector q is not estimated. If dof = NULL or dof &lt;= 0, then dof and q
are estimated automatically. If dof is a positive number, q is estimated.</p>
</td></tr>
<tr><td><code id="lm_full_Bayes_SR_+3A_burnincycle">burnincycle</code>, <code id="lm_full_Bayes_SR_+3A_mcmccycle">mcmccycle</code></td>
<td>
<p>Number of burnin cycles is the number of
initially generated sample values to drop. Number of MCMC cycles is the
number of generated sample values to compute estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the multivariate regression:
</p>
<p style="text-align: center;"><code class="reqn">Y = X Psi + e, \quad e ~ mvt(0, dof, Sigma).</code>
</p>

<p>Psi is a M-by-K matrix of regression coefficients and
Sigma is a K-by-K scale matrix for multivariate t-distribution for noise.
</p>
<p>Sampling distribution for noise e is multivariate t-distribution with
degree of freedom dof and scale matrix Sigma: e ~ mvt(0, dof, Sigma).
The priors are noninformative priors: 1) the shrinkage prior for regression
coefficients Psi, and 2) the reference prior for scale matrix Sigma.
</p>
<p>The function implements Gibbs MCMC algorithm for estimating regression
coefficients Psi and scale matrix Sigma.
</p>


<h3>Value</h3>

<p>A list object with estimated parameters: Psi, Sigma, dof, delta
(delta is the reciprocal of lambda), and lambda.
Additional components are se.param (standard error of the parameters) and
LINEXVARmodel (estimates under LINEX loss).
</p>


<h3>References</h3>

<p>S. Ni and D. Sun (2005). Bayesian estimates for vector
autoregressive models. Journal of Business &amp; Economic Statistics 23(1),
105-117.
</p>

<hr>
<h2 id='lm_multiv_ridge'>Multivariate Ridge Regression</h2><span id='topic+lm_multiv_ridge'></span>

<h3>Description</h3>

<p>Estimate regression coefficients by using ridge regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_multiv_ridge(Y, X, lambda = 0, do_scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_multiv_ridge_+3A_y">Y</code></td>
<td>
<p>An N x K matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="lm_multiv_ridge_+3A_x">X</code></td>
<td>
<p>An N x M matrix of regressors.</p>
</td></tr>
<tr><td><code id="lm_multiv_ridge_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector of lambda values</p>
</td></tr>
<tr><td><code id="lm_multiv_ridge_+3A_do_scale">do_scale</code></td>
<td>
<p>If true, X is centered and scaled, and Y is centered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the multivariate regression:
</p>
<p style="text-align: center;"><code class="reqn">Y = X Psi + e.</code>
</p>

<p>Psi is a M-by-K matrix of regression coefficients.
The ridge regression estimate for the coefficients is
</p>
<p style="text-align: center;"><code class="reqn">Psi = (X'X + lambda * I)^{-1} X'Y.</code>
</p>



<h3>Value</h3>

<p>A list object with the components: 1) Psi - A list of
estimated Psi matrices, 2) lambda - A vector of
lambda values, 3) GCV - A vector of GCV values
</p>


<h3>References</h3>

<p>G. H. Golub, M. Heath, G. Wahba (1979).
Generalized cross-validation as a method for choosing a good
ridge parameter. Technometrics 21(2), 215-223. doi: 10.2307/1268518
</p>

<hr>
<h2 id='lm_semi_Bayes_PCV'>Semiparametric Bayesian Shrinkage Estimation Method for Multivariate
Regression</h2><span id='topic+lm_semi_Bayes_PCV'></span>

<h3>Description</h3>

<p>Estimate regression coefficients and scale matrix for noise by using
a parameterized cross validation (PCV). The function assumes
1) multivariate t-distribution for noise as a sampling distribution,
and 2) informative priors for regression coefficients and scale matrix
for noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_semi_Bayes_PCV(Y, X, dof = Inf, lambda = NULL, lambda_var = NULL,
  prior_type = c("NCJ", "CJ"), num_folds = 5, m0 = ncol(Y))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_semi_Bayes_PCV_+3A_y">Y</code></td>
<td>
<p>An N x K matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_x">X</code></td>
<td>
<p>An N x M matrix of regressors.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_dof">dof</code></td>
<td>
<p>Degree of freedom for multivariate t-distribution.
If dof = Inf (default), then multivariate normal distribution is applied and
weight vector q is not estimated. If dof = NULL or a numeric vector,
then dof is selected by K-fold CV automatically and q is estimated.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_lambda">lambda</code></td>
<td>
<p>If NULL or a vector of length &gt;=2, it is selected by PCV.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_lambda_var">lambda_var</code></td>
<td>
<p>If NULL, it is selected by a Stein-type shrinkage method.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_prior_type">prior_type</code></td>
<td>
<p>&quot;NCJ&quot; for non-conjugate prior and &quot;CJ&quot; for conjugate
prior for scale matrix Sigma.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_num_folds">num_folds</code></td>
<td>
<p>Number of folds for PCV.</p>
</td></tr>
<tr><td><code id="lm_semi_Bayes_PCV_+3A_m0">m0</code></td>
<td>
<p>A hyperparameter for inverse Wishart distribution for Sigma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the multivariate regression:
</p>
<p style="text-align: center;"><code class="reqn">Y = X Psi + e, \quad e ~ mvt(0, dof, Sigma).</code>
</p>

<p>Psi is a M-by-K matrix of regression coefficients and
Sigma is a K-by-K scale matrix for multivariate t-distribution for noise.
</p>
<p>Sampling distribution for noise e is the multivariate t-distribution with
degree of freedom dof and scale matrix Sigma: e ~ mvt(0, dof, Sigma).
The priors are informative priors: 1) a shrinkage prior for regression
coefficients Psi, and 2) inverse Wishart prior for scale matrix Sigma,
which can be either non-conjugate (&quot;NCJ&quot;) or conjugate (&quot;CJ&quot;) to the
shrinkage prior for coefficients Psi.
</p>
<p>The function implements parameterized cross validation (PCV) for
selecting a shrinkage parameter lambda for estimating regression
coefficients (0 &lt; lambda &lt;= 1).
In addition, the function uses a Stein-type shrinkage method for selecting
a shrinkage parameter lambda_var for estimating variances of
time series variables.
</p>


<h3>References</h3>

<p>N. Lee, H. Choi, and S.-H. Kim (2016). Bayes shrinkage
estimation for high-dimensional VAR models with scale mixture of normal
distributions for noise. Computational Statistics &amp; Data Analysis 101,
250-276. doi: 10.1016/j.csda.2016.03.007
</p>

<hr>
<h2 id='lm_ShVAR_KCV'>K-fold Cross Validation for Selection of Shrinkage Parameters of
Semiparametric Bayesian Shrinkage Estimator for Multivariate Regression</h2><span id='topic+lm_ShVAR_KCV'></span>

<h3>Description</h3>

<p>Estimate regression coefficients and scale matrix for noise by using
semiparametric Bayesian shrinkage estimator, whose shrinkage parameters
are selected by K-fold cross validation (KCV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_ShVAR_KCV(Y, X, dof = Inf, lambda = NULL, lambda_var = NULL,
  prior_type = c("NCJ", "CJ"), num_folds = 5, m0 = ncol(Y))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_ShVAR_KCV_+3A_y">Y</code></td>
<td>
<p>An N x K matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_x">X</code></td>
<td>
<p>An N x M matrix of regressors.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_dof">dof</code></td>
<td>
<p>Degree of freedom for multivariate t-distribution.
If dof = Inf (default), then multivariate normal distribution is applied and
weight vector q is not estimated. If dof = NULL or a numeric vector,
then dof is selected by K-fold CV automatically and q is estimated.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_lambda">lambda</code></td>
<td>
<p>If NULL or a vector of length &gt;=2, it is selected by KCV.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_lambda_var">lambda_var</code></td>
<td>
<p>If NULL or a vector of length &gt;=2, it is selected by KCV.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_prior_type">prior_type</code></td>
<td>
<p>&quot;NCJ&quot; for non-conjugate prior and &quot;CJ&quot; for conjugate
prior for scale matrix Sigma.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_num_folds">num_folds</code></td>
<td>
<p>Number of folds for KCV.</p>
</td></tr>
<tr><td><code id="lm_ShVAR_KCV_+3A_m0">m0</code></td>
<td>
<p>A hyperparameter for inverse Wishart distribution for Sigma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shrinkage parameters, lambda and lambda_var, for the semiparametric
Bayesian shrinkage estimator are selected by KCV. See help(lm_semi_Bayes_PCV)
for details about semiparametric Bayesian estimator.
</p>


<h3>References</h3>

<p>N. Lee, H. Choi, and S.-H. Kim (2016). Bayes shrinkage
estimation for high-dimensional VAR models with scale mixture of normal
distributions for noise. Computational Statistics &amp; Data Analysis 101,
250-276. doi: 10.1016/j.csda.2016.03.007
</p>

<hr>
<h2 id='logLik.varshrinkest'>Log-likelihood method for class &quot;varshrinkest&quot;</h2><span id='topic+logLik.varshrinkest'></span>

<h3>Description</h3>

<p>Returns the log-likelihood of a VAR model estimated by VARshrink().
It extends vars::logLik.varest() to incorporate
1) multivariate t-distribution for residuals,
2) scale matrix Sigma provided by shrinkage methods, and
3) effective number of parameters provided by shrinkage methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.varshrinkest_+3A_object">object</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;</p>
</td></tr>
<tr><td><code id="logLik.varshrinkest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Acknowledgement: This code was contributed by
Sung-Hoon Han &amp; Dong-Han Lee @ Kangwon National University (2018.11.29.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
logLik(estim)
</code></pre>

<hr>
<h2 id='normality.test_sh'>Normality, multivariate skewness and kurtosis test</h2><span id='topic+normality.test_sh'></span>

<h3>Description</h3>

<p>This function computes univariate and multivariate Jarque-Bera tests and
multivariate skewness and kurtosis tests for the residuals of a VAR(p)
or of a VECM in levels.
This is a modification of vars::normality.test() for
the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normality.test_sh(x, multivariate.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normality.test_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; obtained by VARshrink().</p>
</td></tr>
<tr><td><code id="normality.test_sh_+3A_multivariate.only">multivariate.only</code></td>
<td>
<p>If TRUE, only the multivariate statistics
is computed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+normality.test">normality.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
normality.test_sh(estim)
</code></pre>

<hr>
<h2 id='Phi.varshrinkest'>Coefficient matrices of the MA represention</h2><span id='topic+Phi.varshrinkest'></span>

<h3>Description</h3>

<p>Returns the estimated coefficient matrices of the moving average
representation of a stable VAR(p), of an SVAR as an array or a converted
VECM to VAR.
This is a modification of vars::Phi() for the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
Phi(x, nstep = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Phi.varshrinkest_+3A_x">x</code></td>
<td>
<p>An object of class 'varshrinkest',
generated by <code>VARshrink()</code>.</p>
</td></tr>
<tr><td><code id="Phi.varshrinkest_+3A_nstep">nstep</code></td>
<td>
<p>An integer specifying the number of moving error
coefficient matrices to be calculated.</p>
</td></tr>
<tr><td><code id="Phi.varshrinkest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+Phi">Phi</a></code>
</p>

<hr>
<h2 id='predict.varshrinkest'>Predict method for objects of class varshrinkest</h2><span id='topic+predict.varshrinkest'></span>

<h3>Description</h3>

<p>Forecating a VAR object of class 'varshrinkest'
with confidence bands.
This is a modification of vars::predict.varest() for the class
&quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
predict(object, ..., n.ahead = 10, ci = 0.95,
  dumvar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.varshrinkest_+3A_object">object</code></td>
<td>
<p>An object of class 'varshrinkest';
generated by <code>VARshrink()</code></p>
</td></tr>
<tr><td><code id="predict.varshrinkest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="predict.varshrinkest_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of forecast steps.</p>
</td></tr>
<tr><td><code id="predict.varshrinkest_+3A_ci">ci</code></td>
<td>
<p>The forecast confidence interval</p>
</td></tr>
<tr><td><code id="predict.varshrinkest_+3A_dumvar">dumvar</code></td>
<td>
<p>Matrix for objects of class ‘vec2var’ or ‘varest’,
if the dumvar argument in ca.jo() has been used or if the exogen
argument in VARshrink() has been used, respectively. The matrix should
have the same column dimension as in the call to ca.jo() or to
VARshrink() and row dimension equal to n.ahead.</p>
</td></tr>
</table>

<hr>
<h2 id='print.varshrinkest'>Print method for class &quot;varshrinkest&quot;</h2><span id='topic+print.varshrinkest'></span>

<h3>Description</h3>

<p>Print method for an object of class &quot;varshrinkest&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
print(x, digits = max(3, getOption("digits") - 3),
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.varshrinkest_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;</p>
</td></tr>
<tr><td><code id="print.varshrinkest_+3A_digits">digits</code>, <code id="print.varshrinkest_+3A_...">...</code></td>
<td>
<p>Other arguments for print() method</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
print(estim)
</code></pre>

<hr>
<h2 id='print.varshsum'>Print method for class &quot;varshsum&quot;</h2><span id='topic+print.varshsum'></span>

<h3>Description</h3>

<p>Print method for an object obtained by summary.varshrinkest().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshsum'
print(x, digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.varshsum_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshsum&quot;</p>
</td></tr>
<tr><td><code id="print.varshsum_+3A_digits">digits</code>, <code id="print.varshsum_+3A_signif.stars">signif.stars</code>, <code id="print.varshsum_+3A_...">...</code></td>
<td>
<p>Other arguments for print(),
printCoefmat(), format() method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends print.varsum() for VAR models estimated by
shrinkage methods.
The output includes scale matrix Sigma and degree of freedom dof
for multivariate t-distribution for residuals.
</p>

<hr>
<h2 id='restrict_sh'>Restricted VAR</h2><span id='topic+restrict_sh'></span>

<h3>Description</h3>

<p>This is a modification of vars::restrict() for the class &quot;varshrinkest&quot;.
Warning: THIS CODE IS NOT COMPLETE:
this function may raise an error because it ignores shrinkage
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_sh(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restrict_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;</p>
</td></tr>
<tr><td><code id="restrict_sh_+3A_...">...</code></td>
<td>
<p>Other arguments to vars::restrict()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+restrict">restrict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
restrict_sh(estim)
</code></pre>

<hr>
<h2 id='roots_sh'>Eigenvalues of the companion coefficient matrix of
a VAR(p)-process</h2><span id='topic+roots_sh'></span>

<h3>Description</h3>

<p>This is a variant of vars::roots() for an object of class 'varshrinkest',
VAR parameters estimated by <code>VARshrink()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots_sh(x, modulus = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roots_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;</p>
</td></tr>
<tr><td><code id="roots_sh_+3A_modulus">modulus</code></td>
<td>
<p>TRUE for modulus of the roots.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+roots">roots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
roots_sh(estim)
</code></pre>

<hr>
<h2 id='serial.test_sh'>Test for serially correlated errors for VAR shrinkage estimate</h2><span id='topic+serial.test_sh'></span>

<h3>Description</h3>

<p>An extension of vars::serial.test() to the class &quot;varshrinkest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial.test_sh(x, lags.pt = 16, lags.bg = 5,
  type = c("PT.asymptotic", "PT.adjusted", "BG", "ES"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serial.test_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot; obtained by VARshrink().</p>
</td></tr>
<tr><td><code id="serial.test_sh_+3A_lags.pt">lags.pt</code>, <code id="serial.test_sh_+3A_lags.bg">lags.bg</code>, <code id="serial.test_sh_+3A_type">type</code></td>
<td>
<p>Other arguments for vars::serial.test().
see help(serial.test) for details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+serial.test">serial.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
serial.test_sh(estim)
</code></pre>

<hr>
<h2 id='shrinkVARcoef'>Semiparametric Bayesian Shrinkage Estimator for
Multivariate Regression</h2><span id='topic+shrinkVARcoef'></span>

<h3>Description</h3>

<p>Compute the semiparametric Bayesian shrinkage estimator of Psi and Sigma
for a given shrinkage parameter lambda.
The function is a private function for lm_semi_Bayes_PCV() and
lm_ShVAR_KCV().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkVARcoef(Y, X, lambda, dof = Inf, prior_type = "NCJ",
  TolDRes = 1e-04, m0 = ncol(Y))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkVARcoef_+3A_y">Y</code></td>
<td>
<p>An N x K matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_x">X</code></td>
<td>
<p>An N x M matrix of regressors.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_lambda">lambda</code></td>
<td>
<p>A shrinkage intensity parameter value between 0~1.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_dof">dof</code></td>
<td>
<p>Degree of freedom for multivariate t-distribution.
If NULL or Inf, then use multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_prior_type">prior_type</code></td>
<td>
<p>&quot;NCJ&quot; for non-conjugate prior and &quot;CJ&quot; for conjugate
prior for scale matrix Sigma.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_toldres">TolDRes</code></td>
<td>
<p>Tolerance parameter for stopping criterion.</p>
</td></tr>
<tr><td><code id="shrinkVARcoef_+3A_m0">m0</code></td>
<td>
<p>A hyperparameter for inverse Wishart distribution for Sigma</p>
</td></tr>
</table>


<h3>References</h3>

<p>N. Lee, H. Choi, and S.-H. Kim (2016). Bayes shrinkage
estimation for high-dimensional VAR models with scale mixture of normal
distributions for noise. Computational Statistics &amp; Data Analysis 101,
250-276. doi: 10.1016/j.csda.2016.03.007
</p>

<hr>
<h2 id='simVARmodel'>Generate multivariate time series data using the given VAR model</h2><span id='topic+simVARmodel'></span>

<h3>Description</h3>

<p>Generate a multivariate time series data set using the given VAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simVARmodel(numT, model, burnin = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simVARmodel_+3A_numt">numT</code></td>
<td>
<p>Number of observed time points, T.</p>
</td></tr>
<tr><td><code id="simVARmodel_+3A_model">model</code></td>
<td>
<p>A list object with Coef, Sigma, dof;
Coef is a list with A and c; A is a list object of K-by-K coefficient
matrices and c is a length-K vector.
Sigma is a K-by-K scale matrix and
dof is a degree of freedom for multivariate t-distribution for noise.</p>
</td></tr>
<tr><td><code id="simVARmodel_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial points which are not included in the final values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, it creates (p+burnin+numT x K) data, then
it remove the first (p+burnin) vectors.
Finally, it returns (numT x K) data.
</p>


<h3>Value</h3>

<p>A numT-by-K matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCoef &lt;- list(A = list(matrix(c(0.5, 0, 0, 0.5), 2, 2)), c = c(0.2, 0.7))
myModel &lt;- list(Coef = myCoef, Sigma = diag(0.1^2, 2), dof = Inf)
simVARmodel(numT = 100, model = myModel, burnin = 10)
</code></pre>

<hr>
<h2 id='stability_sh'>Stability function</h2><span id='topic+stability_sh'></span>

<h3>Description</h3>

<p>A variant of vars::stability().
Warning: this function has not been tested for small sample sizes yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability_sh(x, type = c("OLS-CUSUM", "Rec-CUSUM", "Rec-MOSUM",
  "OLS-MOSUM", "RE", "ME", "Score-CUSUM", "Score-MOSUM", "fluctuation"),
  h = 0.15, dynamic = FALSE, rescale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability_sh_+3A_x">x</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;</p>
</td></tr>
<tr><td><code id="stability_sh_+3A_type">type</code>, <code id="stability_sh_+3A_h">h</code>, <code id="stability_sh_+3A_dynamic">dynamic</code>, <code id="stability_sh_+3A_rescale">rescale</code>, <code id="stability_sh_+3A_...">...</code></td>
<td>
<p>Other arguments to strucchange::efp()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+stability">stability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
stability_sh(estim)
</code></pre>

<hr>
<h2 id='summary.shrinklm'>Summary method for class &quot;shrinklm&quot;</h2><span id='topic+summary.shrinklm'></span>

<h3>Description</h3>

<p>Class &quot;shrinklm&quot; inherits the class &quot;lm&quot;, and it extends
the &quot;lm&quot; class to incorporate shrinkage estimates with
effective number of parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shrinklm'
summary(object, correlation = FALSE,
  symbolic.cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.shrinklm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;shrinklm&quot;</p>
</td></tr>
<tr><td><code id="summary.shrinklm_+3A_correlation">correlation</code></td>
<td>
<p>If TRUE, the correlation matrix of the
the estimated coefficients is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.shrinklm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>If TRUE, print the correlations in a symbolic form
rather than as numbers</p>
</td></tr>
<tr><td><code id="summary.shrinklm_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.varshrinkest'>Summary method for an object of class 'varshrinkest',
VAR parameters estimated by VARshrink()</h2><span id='topic+summary.varshrinkest'></span>

<h3>Description</h3>

<p>Extend summary.varest() to class 'varshrinest' to incorporate
adapted methods for new classes:
summary.shrinklm(), logLik.varshrinkest(), roots.varshrinkest().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varshrinkest'
summary(object, equations = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.varshrinkest_+3A_object">object</code></td>
<td>
<p>An object of class &quot;varshrinkest&quot;, usually
a result of call to &quot;VARshrink()&quot;.</p>
</td></tr>
<tr><td><code id="summary.varshrinkest_+3A_equations">equations</code></td>
<td>
<p>Subset of names of endogenous time series variables
to summarize.</p>
</td></tr>
<tr><td><code id="summary.varshrinkest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code is modified to avoid call to data matrices ($y, $datamat)
and to use effective numbers of parameters of shrinkage estimates.
</p>
<p>Output includes the scale matrix, Sigma, and degree-of-freedom, dof,
for multivariate t-distribution for residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
estim &lt;- VARshrink(y, p = 2, type = "const", method = "ridge")
summary(estim)
</code></pre>

<hr>
<h2 id='VARshrink'>Shrinkage estimation of VAR parameters</h2><span id='topic+VARshrink'></span>

<h3>Description</h3>

<p>Shrinkage estimation methods for high-dimensional VAR models.
Consider VAR(p) model: y_t = A_1 y_t-1 + ... + A_p y_t-p + C d_t + e_t,
where y_t is K-dimensional time series,
d_t is deterministic regressors, e_t is a noise process, and
A_1, ..., A_p, and C are coefficient matrices.
Exogenous variables can be included additionally as regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARshrink(y, p = 1, type = c("const", "trend", "both", "none"),
  season = NULL, exogen = NULL, method = c("ridge", "ns", "fbayes",
  "sbayes", "kcv"), lambda = NULL, lambda_var = NULL, dof = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VARshrink_+3A_y">y</code></td>
<td>
<p>A T-by-K matrix of endogenous variables</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_p">p</code></td>
<td>
<p>Integer for the lag order</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_type">type</code></td>
<td>
<p>Type of deterministic regressors to include.
#' 1) &quot;const&quot; - the constant.
2) &quot;trend&quot; - the trend.
3) &quot;both&quot; - both the constant and the trend.
4) &quot;none&quot;  - no deterministic regressors.
***Note: In the package version &lt;= 0.3, method='ns' does not accept
type=&quot;const&quot; and type=&quot;both&quot; to avoid constant term.</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_season">season</code></td>
<td>
<p>An integer value of frequency for inclusion of
centered seasonal dummy variables. abs(season) &gt;= 3.</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_exogen">exogen</code></td>
<td>
<p>A T-by-L matrix of exogenous variables. Default is NULL.</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_method">method</code></td>
<td>
<p>1) &quot;ridge&quot; - multivariate ridge regression.
2) &quot;ns&quot; - a Stein-type nonparametric shrinkage method.
3) &quot;fbayes&quot; - a full Bayesian shrinkage method using noninformative priors.
4) &quot;sbayes&quot; - a semiparametric Bayesian shrinkage method using parameterized
cross validation.
5) &quot;kcv&quot; - a semiparametric Bayesian shrinkage method using
K-fold cross validation</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_lambda">lambda</code>, <code id="VARshrink_+3A_lambda_var">lambda_var</code></td>
<td>
<p>Shrinkage parameter value(s).
Use of this parameter is slightly different for each method:
the same value does not imply the same shrinkage estimates.</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_dof">dof</code></td>
<td>
<p>Degree of freedom of multivariate t-distribution for noise.
Valid only for method = &quot;fbayes&quot; and method = &quot;sbayes&quot;.
dof=Inf means multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="VARshrink_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to a specific function of the
estimation method. For example, burnincycle and mcmccycle are for
&quot;fbayes&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shrinkage estimation methods can estimate the coefficients
even when the dimensionality K is larger than the
number of observations.
</p>


<h3>Value</h3>

<p>An object of class &quot;varshrinkest&quot; with the components:
varresult, datamat, y, type, p, K, obs,
totobs, restrictions, method, lambda, call.
The class &quot;varshrinkest&quot; inherits the class &quot;varest&quot;
in the package vars.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package = "vars")
y &lt;- diff(Canada)
VARshrink(y, p = 2, type = "const", method = "ridge")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
