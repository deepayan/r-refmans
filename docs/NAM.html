<!DOCTYPE html><html><head><title>Help for package NAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NAM-package'>
<p>Nested Association Mapping</p></a></li>
<li><a href='#Dataset 1'>
<p>Tetra-seed Pods</p></a></li>
<li><a href='#Dataset 2'>
<p>Multi-environmental trial</p></a></li>
<li><a href='#FST'>
<p>Fixation Index</p></a></li>
<li><a href='#GWAS'>
<p>Empirical Bayes Genome Wide Association Mapping</p></a></li>
<li><a href='#GWP'>
<p>Genome-wide prediction</p></a></li>
<li><a href='#Manhattan'>
<p>Manhattan plot for Association Studies</p></a></li>
<li><a href='#MLM Gibbs'>
<p>Bayesian Mixed Model</p></a></li>
<li><a href='#MLM REML'>
<p>Restricted Maximum Likelihood</p></a></li>
<li><a href='#MLM Trials'>
<p>Genomic mixed model</p></a></li>
<li><a href='#Optimizations'>
<p>Internal functions</p></a></li>
<li><a href='#SNP H2'>
<p>SNP heritability</p></a></li>
<li><a href='#SNP QC'>
<p>SNP Quality Control</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nested Association Mapping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Alencar Xavier, William Muir, Katy Rainey, Shizhong Xu.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alencar Xavier &lt;alenxav@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for association studies in nested association mapping (NAM) panels, experimental and random panels. The method is described by Xavier et al. (2015) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtv448">doi:10.1093/bioinformatics/btv448</a>&gt;. It includes tools for genome-wide associations of multiple populations, marker quality control, population genetics analysis, genome-wide prediction, solving mixed models and finding variance components through likelihood and Bayesian methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-23 15:20:51 UTC; rd7564</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bWGR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-23 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='NAM-package'>
Nested Association Mapping
</h2><span id='topic+NAM-package'></span><span id='topic+NAM'></span>

<h3>Description</h3>

<p>Designed for association studies in nested association mapping (NAM) panels, also handling experimental and random panels. The method is described by Xavier et al. (2015) &lt;doi:10.1093/bioinformatics/btv448&gt;. It includes tools for genome-wide associations of multiple populations, marker quality control, population genetics analysis, genome-wide prediction, solving mixed models and finding variance components through likelihood and Bayesian methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> NAM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.7.3 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-09-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alencar Xavier, William Muir, Katy Rainey, Shizhong Xu.
</p>
<p>Maintainer: Alencar Xavier &lt;alenxav@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Package include functions to perform association analysis (gwas, gwas2, gwas3), meta-gwas (gwasGE, meta3), solve mixed models (gibbs, reml), genomic prediction (wgr, gmm, press), populations genetic analysis (Fst, Gdist, LD), data quality control (snpQC, snpH2, markov), spatial analysis (covar, SPC, SPM), build kinships (GRM, GAU, PedMat) and more.
</p>

<hr>
<h2 id='Dataset+201'>
Tetra-seed Pods
</h2><span id='topic+tpod'></span><span id='topic+gen'></span><span id='topic+chr'></span><span id='topic+fam'></span><span id='topic+y'></span>

<h3>Description</h3>

<p>Two soybean bi-parental crosses phenotyped for the percentage of pods containing four seeds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(tpod)
</code></pre>


<h3>Details</h3>

<p>Soybean nested association panel with 2 families (<code class="reqn">fam</code>) containing 196 indiviuals. Genotypic matrix (<code class="reqn">gen</code>) have 376 SNP across 20 chromosome (<code class="reqn">chr</code>). Phenotypic information (<code class="reqn">y</code>) regards the proportion of four seed pods. Data provided by Rainey Lab for Soybean Breeding and Genetics, Purdue University.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier and Katy Rainey
</p>

<hr>
<h2 id='Dataset+202'>
Multi-environmental trial
</h2><span id='topic+met'></span><span id='topic+Gen'></span><span id='topic+Obs'></span>

<h3>Description</h3>

<p>Data collected from the SoyNAM population in Indiana 2013-2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(met)
</code></pre>


<h3>Details</h3>

<p>Data provided by Rainey Lab for Soybean Breeding and Genetics, Purdue University. Genotypic matrix (<code class="reqn">Gen</code>) have 4240 SNPs. The data frame <code class="reqn">Obs</code> contains the soybean id (<code class="reqn">ID</code>), environment (<code class="reqn">Year</code>), field location (<code class="reqn">Block,Row,Col</code>) and three phenotypes: grain yield (<code class="reqn">YLD</code>), days to maturity (<code class="reqn">DTM</code>) and average canopy closure (<code class="reqn">ACC</code>).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier, Ben Hall and Katy Rainey
</p>


<h3>References</h3>

<p>Xavier, A., Hall, B., Hearst, A.A., Cherkauer, K.A. and Rainey, K.M., 2017. Genetic Architecture of Phenomic-Enabled Canopy Coverage in Glycine max. Genetics, 206(2), pp.1081-1089.
</p>

<hr>
<h2 id='FST'>
Fixation Index
</h2><span id='topic+Fst'></span><span id='topic+plot.fst'></span>

<h3>Description</h3>

<p>Genetic variation associated with markers distributed among subpopulations. The function generates a plot for structure diagnosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Fst(gen,fam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FST_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and (<code class="reqn">m</code>) columns of molecular markers. SNPs must be coded as <code>0, 1, 2</code>, for founder homozigous, heterozygous and reference homozygous. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="FST_+3A_fam">fam</code></td>
<td>

<p>Numeric vector of length (<code class="reqn">n</code>) indicating which subpopulations (<code class="reqn">i.e.</code> family) each observation comes from. <code>NA</code> is not allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>F-statistics (Wright 1965) represent the differentiation among populations for a given locus. Weir and Cockerham (1984) provided an unbiased version for molecular analysis. 
</p>
<p>FIT is the correlation between gametes that unite to produce the individuals, relative to the gametes of the total population. FIS is the average over all subdivisions of the correlation between uniting gametes relative to those of their own subdivision. FST is the correlation between random gametes within subdivisions, relative to gametes of the total population. Neutral markers have an expected FST 0.05.
</p>


<h3>Value</h3>

<p>List with values of FST, FIS and FIT. Unbiased F-statistics from weighted AOV (Weir and Cockerham 1984).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier and William Muir
</p>


<h3>References</h3>

<p>Weir, B. S., and Cockerham, C. C. (1984). Estimating F-statistics for the analysis of population structure. Evolution, 38(6), 1358-1370.
</p>
<p>Wright, S. (1965). The interpretation of population structure by F-statistics with special regard to systems of mating. Evolution, 19(3), 395-420.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data(tpod)
  Fstat = Fst(gen=gen,fam=fam)
  plot(Fstat,chr=chr)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='GWAS'>
Empirical Bayes Genome Wide Association Mapping 
</h2><span id='topic+gwas'></span><span id='topic+gwas2'></span><span id='topic+gwas3'></span><span id='topic+gwasGE'></span><span id='topic+meta3'></span>

<h3>Description</h3>

<p>The gwas function calculates the likelihood ratio for each marker under the empirical Bayesian framework. The method allows analysis with multiple populations. <code>gwas2</code> is computationally optimized. <code>gwas3</code> was design for multiple random populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwas(y,gen,fam=NULL,chr=NULL,window=NULL,fixed=FALSE)
gwas2(y,gen,fam=NULL,chr=NULL,fixed=FALSE,EIG=NULL,cov=NULL)
gwas3(y,gen,fam=NULL,chr=NULL,EIG=NULL,cov=NULL)
gwasGE(Phe,gen,fam,chr=NULL,cov=NULL,ge=FALSE,ammi=1)
meta3(ByEnv,ammi=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWAS_+3A_y">y</code></td>
<td>

<p>Numeric vector of observations (<code class="reqn">n</code>) describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and (<code class="reqn">m</code>) columns of molecular markers. SNPs must be coded as <code>0, 1, 2</code>, for founder homozygous, heterozygous and reference homozigous. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_fam">fam</code></td>
<td>

<p>Numeric vector of length <code class="reqn">n</code> indicating a stratification factor or which subpopulation (<code class="reqn">e.g.</code> family) that each observation comes from. Default assumes that all observations are from the same populations.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_chr">chr</code></td>
<td>

<p>Numeric vector indicating the number of markers in each chromosome. The sum of <code class="reqn">chr</code> must be equal to the number of columns in <code class="reqn">gen</code>. Default assumes that all markers are from the same chromosome.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_window">window</code></td>
<td>

<p>Numeric. If specified, genetic distance between markers is used for moving window strategy. Window must be specified in Morgans (<code class="reqn">e.g.</code> 0.05 would represent 5cM). Genetic distance is calculated assuming that individuals are RILs.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_fixed">fixed</code></td>
<td>

<p>Logical. If TRUE, markers are treated as fixed effect and hence, evaluated through Wald statistics. If markers are specief as fixed, the argument 'window' is not applicable.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_eig">EIG</code></td>
<td>

<p>Output of the R function 'eigen'. It is used for user-defined kinship matrix.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_cov">cov</code></td>
<td>

<p>Numeric vector of length <code class="reqn">n</code> to be used as covariate in the association analysis.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_phe">Phe</code></td>
<td>

<p>Numeric matrix of observations (<code class="reqn">n*e</code>) where rows represent genotypes and columns represent environments. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_ge">ge</code></td>
<td>

<p>Logical. If TRUE, meta-analysis (function gwasGE) will be done for the <code class="reqn">G</code>x<code class="reqn">E</code> interactions term only. If FALSE, variance components will be computed for three terms: genotype, environment and interaction.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_ammi">ammi</code></td>
<td>

<p>Integer. It indicates the number of principal components used to represent <code class="reqn">G</code>x<code class="reqn">E</code> interactions through additive main-effects and multiplicative interaction (AMMI).
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_byenv">ByEnv</code></td>
<td>

<p>List of objected output from <code>gwas3</code> to perform meta-analysis.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empirical Bayes model (Wang 2016) with a special incidence matrix is recreated to optimize the information provided by the subpopulations. Each locus is recoded as a vector with length <code class="reqn">f</code> equal to number of subpopulations, or NAM families, as the interaction locus by family. For example, a locus heterozigous from an individual from subpopulation 2 is coded as [ 1, 0, 1 , ... ,<code class="reqn">f</code> ], a locus homozigous for the reference allele from any subpopulation is coded as [ 2, 0, 0, ... , <code class="reqn">f</code> ] and a locus homozigous for the founder allele from an individual from subpopulation 1 is coded as [ 0, 2, 0, ... ,<code class="reqn">f</code> ]. The base model for genome scanning is described by:
</p>
<p style="text-align: center;"><code class="reqn">y = Xb + Zu + g + e</code>
</p>

<p>That includes the fixed effect (<code class="reqn">Xb</code>), the marker (<code class="reqn">Zu</code>), the polygene (<code class="reqn">g</code>) and the residuals (<code class="reqn">e</code>). If the <code class="reqn">window</code> term is specified, the model for genome scanning is expanded as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = Xb + Zu[k-1] + Zu + Zu[k+1] + g - g[k] + e</code>
</p>

<p>This model includes three extra terms: the left side genome ( <code class="reqn">Zu[k-1]</code> ) and the right side genome ( <code class="reqn">Zu[k+1]</code> ), also subtracting the window polygene ( <code class="reqn">-g[k]</code> ). Windows are based on genetic distance, which is computed using Kosambi map function. The recombination rate is estimated under the assuption markers are ordered and that genotypes are recombinant inbred lines.
</p>
<p>The polygenic term is calculated only once (Zhang et al 2010) using eigendecomposition with a GEMMA-like algorithm (Zhou ans Stephens 2012). Efficient inversion of capacitance matrix is obtained through the Woodbury matrix identities. Models and algorithms are described with more detail by Xavier et al (2015) and Wei and Xu (2016).
</p>
<p>In order to analyze large dateset, one can avoid memory issues by using the function <code class="reqn">gwas2</code>, but that the argument 'window' is not implemented for <code class="reqn">gwas2</code>. This function also allows used-defined kindship through the argument EIG, and the use of a numeric covariate vector through the argument cov.
</p>
<p>When multi-environmental trials are the target of mapping, one may use the function <code class="reqn">gwasGE</code> to perform analysis by environment, followed by &quot;meta-analysis&quot; used to combine the results. This strategy provides an idea of the variation on QTL effect due to environment, genetic background (provided by the stratification factor) and the interaction between environment and genetics.
</p>
<p>An alternative to this method is the mega-analysis, where one can provide the stratification factor as a combination of subpopulation and environment. Meta-analysis can be performed in a single step with function <code>gwasGE</code>, or users can perform multiple association analyses using <code>gwas3</code> and perform meta-analysis with <code>meta3</code>. In <code>gwasGE</code>, the same genotype will often appear more than once in the phenotypic and genotypic data, so that phenotypes are provided as a matrix. The statistical detail about the meta-analysis are available in the vignette <code class="reqn">Background for Meta-analysis</code>.
</p>
<p>The function <code>gwas3</code> is an alternative for association analysis and meta-analysis, also solved in the Empirical-Bayes framework for multiple populations. Unlike <code>gwas</code>, <code>gwas2</code> and <code>gwasGE</code>, this function does not set a reference allele and analysis each marker as the interaction of allele by stratification factor (ie. family or subpopulation). Therefore,  <code>gwas3</code> is compatible with any allele coding.
</p>
<p>For further statistical background:
</p>
<p>1) <code>system(paste('open',system.file("doc","gwa_description.pdf",package="NAM")))</code>
</p>
<p>2) <code>system(paste('open',system.file("doc","gwa_ge_interactions.pdf",package="NAM")))</code>
</p>


<h3>Value</h3>

<p>The function gwas returns a list containing the method deployed (<code class="reqn">Method</code>), a summary of predicted parameters and statistical tests (<code class="reqn">PolyTest</code>), estimated genetic map for NAM panels (<code class="reqn">MAP</code>) and the marker names (<code class="reqn">SNPs</code>).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier, Tiago Pimenta, Qishan Wang and Shizhong Xu
</p>


<h3>References</h3>

<p>Wang, Q., Wei, J., Pan, Y., &amp; Xu, S. (2016). An efficient empirical Bayes method for genomewide association studies. Journal of Animal Breeding and Genetics, 133(4), 253-263.  
</p>
<p>Wei, J., &amp; Xu, S. (2016). A Random Model Approach to QTL Mapping in Multi-parent Advanced Generation Inter-cross (MAGIC) Populations. Genetics, 202(2), 471-486.
</p>
<p>Xavier, A., Xu, S., Muir, W. M., &amp; Rainey, K. M. (2015). NAM: Association Studies in Multiple Populations. Bioinformatics, 31(23), 3862-3864.
</p>
<p>Zhang et al. 2010. Mixed linear model approach adapted for genome-wide association studies. Nat. Genet. 42:355-360.
</p>
<p>Zhou, X., &amp; Stephens, M. (2012). Genome-wide efficient mixed-model analysis for association studies. Nature genetics, 44(7), 821-824.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(tpod)
gen=reference(gen)
gwa=gwas2(y=y,gen=gen,fam=fam,chr=chr,fixed=TRUE)
plot(gwa,pch=20,lwd=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='GWP'>
Genome-wide prediction
</h2><span id='topic+wgr'></span><span id='topic+ben'></span>

<h3>Description</h3>

<p>Univariate model to find breeding values through regression with optional resampling techniques (SBMC) and polygenic term (Kernel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgr(y,X,it=1500,bi=500,th=1,bag=1,rp=FALSE,iv=FALSE,de=FALSE,
    pi=0,df=5,R2=0.5,eigK=NULL,VarK=0.95,verb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWP_+3A_y">y</code></td>
<td>

<p>Numeric vector of observations (<code class="reqn">n</code>) describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_x">X</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and (<code class="reqn">m</code>) columns of molecular markers.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_it">it</code></td>
<td>

<p>Integer. Number of iterations or samples to be generated.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_bi">bi</code></td>
<td>

<p>Integer. Burn-in, the number of iterations or samples to be discarted.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_th">th</code></td>
<td>

<p>Integer. Thinning parameter, used to save memory by storing only one every 'th' samples.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_bag">bag</code></td>
<td>

<p>If different than one, it indicates the proportion of data to be subsampled in each Markov chain. For datasets with moderate number of observations, values of bag from 0.30 to 0.60 may speed up computation without losses in predicion properties. This argument enable users to enhance MCMC through Subsampling bootstrap Markov chain (SBMC).
</p>
</td></tr>
<tr><td><code id="GWP_+3A_rp">rp</code></td>
<td>

<p>Logical. Use replacement for bootstrap samples when bag is different than one.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_iv">iv</code></td>
<td>

<p>Logical. Assign markers independent variance, a T prior from a mixture of normals. If true, turns the default model BLUP into BayesA.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_de">de</code></td>
<td>

<p>Logical. Assign markers independent variance through double-exponential prior. If true, turns the default model BLUP into Bayesian LASSO. This argument overides iv.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_pi">pi</code></td>
<td>

<p>Value between 0 and 1. If greater than zero it activates variable selection, where markers have expected probability pi of having null effect.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_df">df</code></td>
<td>

<p>Prior degrees of freedom of variance components.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_r2">R2</code></td>
<td>

<p>Expected R2, used to calculate the prior shape.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_eigk">eigK</code></td>
<td>

<p>Output of function 'eigen'. Spectral decomposition of the kernel used to compute the polygenic term.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_vark">VarK</code></td>
<td>

<p>Numeric between 0 and 1. For reduction of dimensionality. Indicates the proportion of variance explained by Eigenpairs used to fit the polygenic term.
</p>
</td></tr>
<tr><td><code id="GWP_+3A_verb">verb</code></td>
<td>

<p>Logical. If verbose is TRUE, function displays MCMC progress bar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model for the whole-genome regression is as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = mu + Xb + u + e</code>
</p>

<p>where <code class="reqn">y</code> is the response variable, <code class="reqn">mu</code> is the intercept, <code class="reqn">X</code> is the genotypic matrix, <code class="reqn">b</code> is the regression coefficient or effect of an allele substitution, with <code class="reqn">d</code> probability of being included into the model, <code class="reqn">u</code> is the polygenic term if a kernel is used, and <code class="reqn">e</code> is the residual term.
</p>
<p>Users can obtain four WGR methods out of this function: BRR (pi=0,iv=F), BayesA (pi=0,iv=T), BayesB (pi=0.95,iv=T), BayesC (pi=0.95,iv=F) and Bayesian LASSO or BayesL (pi=0,de=T). Theoretical basis of each model is described by de los Campos et al. (2013).
</p>
<p>Gibbs sampler that updates regression coefficients is adapted from GSRU algorithm (Legarra and Misztal 2008). The variable selection works through the unconditional prior algorithm proposed by Kuo and Mallick (1998). Prior shape estimates are computed as Sb = R2*df*var(y)/MSx and Se = (1-R2)*df*var(y). The polygenic term is solved by Bayesian algorithm of reproducing kernel Hilbert Spaces proposed by de los Campos et al. (2010).
</p>


<h3>Value</h3>

<p>The function wgr returns a list with expected value from the marker effect (<code class="reqn">b</code>), probability of marker being in the model (<code class="reqn">d</code>), regression coefficient (<code class="reqn">g</code>), variance of each marker (<code class="reqn">Vb</code>), the intercept (<code class="reqn">mu</code>), the polygene (<code class="reqn">u</code>) and polygenic variance (<code class="reqn">Vk</code>), residual variance (<code class="reqn">Ve</code>) and the fitted value (<code class="reqn">hat</code>).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>References</h3>

<p>de los Campos, G., Hickey, J. M., Pong-Wong, R., Daetwyler, H. D., and Calus, M. P. (2013). Whole-genome regression and prediction methods applied to plant and animal breeding. Genetics, 193(2), 327-345.
</p>
<p>de los Campos, G., Gianola, D., Rosa, G. J., Weigel, K. A., &amp; Crossa, J. (2010). Semi-parametric genomic-enabled prediction of genetic values using reproducing kernel Hilbert spaces methods. Genetics Research, 92(04), 295-308.
</p>
<p>Kuo, L., &amp; Mallick, B. (1998). Variable selection for regression models. Sankhya: The Indian Journal of Statistics, Series B, 65-81.
</p>
<p>Legarra, A., &amp; Misztal, I. (2008). Technical note: Computing strategies in genome-wide selection. Journal of dairy science, 91(1), 360-366.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 
# Load data
data(tpod)

# BLUP
BRR = wgr(y,gen,iv=FALSE,pi=0)
cor(y,BRR$hat)

# BayesA
BayesA = wgr(y,gen,iv=TRUE,pi=0)
cor(y,BayesA$hat)

# BayesB
BayesB = wgr(y,gen,iv=TRUE,pi=.95)
cor(y,BayesB$hat)

# BayesC
BayesC = wgr(y,gen,iv=FALSE,pi=.95)
cor(y,BayesC$hat)

# BayesCpi
BayesCpi = BCpi(y,gen)
cor(y,BayesCpi$hat)        
        
# BayesL
BayesL = wgr(y,gen,de=TRUE)
cor(y,BayesL$hat)
        
   
## End(Not run)
</code></pre>

<hr>
<h2 id='Manhattan'>
Manhattan plot for Association Studies 
</h2><span id='topic+plot.NAM'></span>

<h3>Description</h3>

<p>Generates a graphical visualization for the output of the function gwas/gwas2/gwasGE. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NAM'
plot(x,...,alpha=0.05,colA=2,colB=4,find=NULL,FDR=NULL,gtz=FALSE,phys=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Manhattan_+3A_x">x</code></td>
<td>

<p>Output of the gwas/gwas2/gwas3 function.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_alpha">alpha</code></td>
<td>

<p>Numberic. Significance threshold to display in the Manhattan plot.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_cola">colA</code></td>
<td>

<p>Color of odd chromosomes in the Manhattan plot.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_colb">colB</code></td>
<td>

<p>Color of even chromosomes in the Manhattan plot.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_find">find</code></td>
<td>

<p>Integer. If provided, you can click on the specified number of hits in the Manhattan plot to obtain the name of the markers.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_fdr">FDR</code></td>
<td>

<p>Null or numeric between zero and one. If provided, it will display the Manhattan plot with Bonferroni threshold by chromosome, adjusted for the specified false discovery rate (FDR). Thus, zero provides the Bonferroni correction.
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_gtz">gtz</code></td>
<td>

<p>Logical. If TRUE, the argument FDR will just take into account markers with p-value Greater Than Zero (GTZ).
</p>
</td></tr>
<tr><td><code id="Manhattan_+3A_phys">phys</code></td>
<td>

<p>Numeric vector with length equal to the number of markers. If provided, the Manhattan plot is generated using the physical distance in the x axis.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alencar Xavier and William Beavis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(tpod)
test=gwas2(y=y,gen=gen[,1:240],fam=fam,chr=chr[1:12])
par(mfrow=c(2,1))

# Example Manhattan 1
SIGNIF = 1+(2*test$PolyTest$lrt&gt;4.9)
plot(x=test,pch=SIGNIF+3,lwd=SIGNIF,main="Example 2")

# Example Manhattan 2
plot(x=test,main="Example 3",pch=20,lwd=2)
Kern = ksmooth(1:240,test$PolyTest$lrt,bandwidth=1)
lines(Kern,type="l",lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='MLM+20Gibbs'>
Bayesian Mixed Model
</h2><span id='topic+gibbs'></span><span id='topic+ml'></span><span id='topic+gibbs2'></span><span id='topic+plot.gibbs'></span>

<h3>Description</h3>

<p>Mixed model solver through Bayesian Gibbs Sampling or iterative solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs(y,Z=NULL,X=NULL,iK=NULL,iR=NULL,Iter=1500,Burn=500,
      Thin=2,DF=5,S=NULL,nor=TRUE,GSRU=FALSE)
ml(y,Z=NULL,X=NULL,iK=NULL,iR=NULL,DF=5,S=0.5,nor=TRUE)
gibbs2(Y,Z=NULL,X=NULL,iK=NULL,Iter=150,Burn=50,Thin=1,DF=5,S=0.5,nor=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLM+2B20Gibbs_+3A_y">y</code></td>
<td>

<p>Numeric vector of observations (<code class="reqn">n</code>) describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_z">Z</code></td>
<td>

<p>Right-hand side formula or list of numeric matrices (<code class="reqn">n</code> by <code class="reqn">p</code>) with incidence matrices for random effect. <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_x">X</code></td>
<td>

<p>Right-hand side formula or incidence matrices (<code class="reqn">n</code> by <code class="reqn">p</code>) for fixed effect. <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_ik">iK</code></td>
<td>

<p>Numeric matrix or list of numeric matrices (<code class="reqn">p</code> by <code class="reqn">p</code>) corresponding to the the inverse kinship matrix of each random effect with <code class="reqn">p</code> parameters.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_ir">iR</code></td>
<td>

<p>Numeric matrix (<code class="reqn">n</code> by <code class="reqn">n</code>) corresponding to the inverse residual correlation matrix.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_iter">Iter</code></td>
<td>

<p>Integer. Number of iterations or samples to be generated.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_burn">Burn</code></td>
<td>

<p>Integer. Number of iterations or samples to be discarted.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_thin">Thin</code></td>
<td>

<p>Integer. Thinning parameter, used to save memory by storing only one every 'Thin' samples.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_df">DF</code></td>
<td>

<p>Integer. Hyperprior degrees of freedom of variance components.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_s">S</code></td>
<td>

<p>Integer or NULL. Hyperprior shape of variance components. If NULL, the hyperprior solution for the scale parameter is calculated as proposed by de los Campos et al. (2013).
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_nor">nor</code></td>
<td>

<p>Logical. If TRUE, it normilizes the response variable(s).
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_gsru">GSRU</code></td>
<td>

<p>Logical. If TRUE, it updates the regression coefficient using Gauss-Seidel Residual Update (Legarra and Misztal 2008). Useful for p&gt;&gt;n, but does not work when iK or iR are provided.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Gibbs_+3A_y">Y</code></td>
<td>

<p>Numeric matrix of observations for multivariate mixed models. Each column represents a trait. <code>NA</code> is allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general model is <code class="reqn">y=Xb+Zu+e</code>, where <code class="reqn">u=N(0,A\sigma2a)</code> and <code class="reqn">e=N(0,R\sigma2e)</code>. The function solves Gaussian mixed models in the Bayesian framework as described by Garcia-Cortes and Sorensen (1996) and Sorensen and Gianola (2002) with conjugated priors. The alternative function, &quot;ml&quot;, finds the solution iteratively using the full-conditional expectation. The function &quot;gibbs2&quot; can be used for the multivariate case, check Xavier et al. (2017) for an example of multivariate mixed model using Gibbs sampling.
</p>


<h3>Value</h3>

<p>The function gibbs returns a list with variance components distribution a posteriori (Posterior.VC) and mode estimated (VC.estimate), a list with the posterior distribution of regression coefficients (Posterior.Coef) and the posterior mean (Coef.estimate), and the fitted values using the mean (Fit.mean) of posterior coefficients.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>References</h3>

<p>de los Campos, G., Hickey, J. M., Pong-Wong, R., Daetwyler, H. D., and Calus, M. P. (2013). Whole-genome regression and prediction methods applied to plant and animal breeding. Genetics, 193(2), 327-345.
</p>
<p>Legarra, A., &amp; Misztal, I. (2008). Technical note: Computing strategies in genome-wide selection. Journal of dairy science, 91(1), 360-366.
</p>
<p>Garcia-Cortes, L. A., and Sorensen, D. (1996). On a multivariate implementation of the Gibbs sampler. Genetics Selection Evolution, 28(1), 121-126.
</p>
<p>Sorensen, D., &amp; Gianola, D. (2002). Likelihood, Bayesian, and MCMC methods in quantitative genetics. Springer Science &amp; Business Media.
</p>
<p>Xavier, A., Hall, B., Casteel, S., Muir, W. and Rainey, K.M. (2017). Using unsupervised learning techniques to assess interactions among complex traits in soybeans. Euphytica, 213(8), p.200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
      
data(tpod)

# Fitting GBLUP
K = GRM(gen)
iK = chol2inv(K)
      
# FIT
test1 = gibbs(y,iK=iK,S=1)

# PLOT
par(mfrow=c(1,3))
plot(test1$Fit.mean,y,pch=20,lwd=2,col=3,main='GBLUP')
plot(test1,col=4,lwd=2)
      
# Heritability
print(paste('h2 =',round(test1$VC.estimate[1]/sum(test1$VC.estimate),3)))

# Fitting RKHS
G = GAU(gen)
EIG = eigen(G,symmetric = TRUE)
ev = 20
U = EIG$vectors[,1:ev]
iV = diag(1/EIG$values[1:ev])

# FIT
test2 = gibbs(y,Z=U,iK=iV,S=1)

# PLOT
par(mfrow=c(1,3))
plot(test2$Fit.mean,y,pch=20,lwd=2,col=2,main='RKHS')
plot(test2,col=3,lwd=2)
      
# Heritability
print(paste('h2 =',round(test2$VC.estimate[1]/sum(test2$VC.estimate),3)))


## End(Not run)
</code></pre>

<hr>
<h2 id='MLM+20REML'>
Restricted Maximum Likelihood
</h2><span id='topic+reml'></span><span id='topic+MCreml'></span>

<h3>Description</h3>

<p>Univariate REML estimators and variance components for a single random variable fitted by an EMMA-like algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reml(y,X=NULL,Z=NULL,K=NULL)
MCreml(y,K,X=NULL,MC=300,samp=300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLM+2B20REML_+3A_y">y</code></td>
<td>

<p>Numeric vector of observations (<code class="reqn">n</code>) describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20REML_+3A_x">X</code></td>
<td>

<p>Formula or incidence matrix (<code class="reqn">n</code> by <code class="reqn">p</code>) for fixed effect. <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20REML_+3A_z">Z</code></td>
<td>

<p>Formula or numeric matrix (<code class="reqn">n</code> by <code class="reqn">p</code>) that corresponds to the incidence matrix of random effect. <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20REML_+3A_k">K</code></td>
<td>

<p>Numeric matrix (<code class="reqn">p</code> by <code class="reqn">p</code>). Kinship matrix for random effect with <code class="reqn">p</code> parameters. <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20REML_+3A_mc">MC</code></td>
<td>

<p>Number of sampling procedures to estimate variance components using MCreml.
</p>
</td></tr>
<tr><td><code id="MLM+2B20REML_+3A_samp">samp</code></td>
<td>

<p>Sample size of the sampling procedure to estimate variance components using MCreml.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solve mixed models with a single random effects minizing the log restricted maximum likelihood (REML) using the EMMA algorithm (Kang et al 2008). Prediction of random coefficients for ridge-type model are performed according to VanRaden (2008), and kernel-type model via RKHS according to de los Campos et al. (2010).
</p>
<p>If y is a matrix with multiple traits, the fuctions solves the mixed model via an ECM algorithm adapted from the EMMREML package (Akdemir and Godfrey 2014).
</p>
<p>MCreml is based on subsampling with <code>samp</code> observations at a time, repeating the procedure <code>MC</code> times. Subsampling is a common Monte Carlo strategy to reduce the computational burden to estimate variance components in large datasets.
</p>


<h3>Value</h3>

<p>The function reml returns a list with variance components and heritability (VC), fixed effect coefficients and standard variations (Fixed) and estimated breeding values (EBV). 
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier, Tiago Pimenta and Shizhong Xu
</p>


<h3>References</h3>

<p>Akdemir, D., and O. U. Godfrey (2014) EMMREML: Fitting Mixed Models with Known Covariance Structures. R Package Version 2.0. Available at: http://CRAN.R-project.org/package=EMMREML.
</p>
<p>de los Campos, G., Gianola, D., Rosa, G. J., Weigel, K. A., &amp; Crossa, J. (2010). Semi-parametric genomic-enabled prediction of genetic values using reproducing kernel Hilbert spaces methods. Genetics Research, 92(04), 295-308.
</p>
<p>Kang, H. M., Zaitlen, N. A., Wade, C. M., Kirby, A., Heckerman, D., Daly, M. J., &amp; Eskin, E. (2008). Efficient control of population structure in model organism association mapping. Genetics, 178(3), 1709-1723.
</p>
<p>VanRaden, P. M. (2008). Efficient methods to compute genomic predictions. Journal of dairy science, 91(11), 4414-4423.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fitting a random model
data(tpod)
FIT = reml(y=y,Z=~as.factor(fam))

# Fitting GBLUP
G = GRM(gen)
GBLUP = reml(y=y,K=G)

# GBLUP vs RRBLUP
g = tcrossprod(gen)
gblup = reml(y=y,K=g)
rrblup = reml(y=y,Z=gen)
rbind(gblup$VC,rrblup$VC)
gebv_gblup = gblup$EBV
gebv_rrblup = c(tcrossprod(t(rrblup$EBV),gen))
plot(gebv_gblup,gebv_rrblup)

## End(Not run)
</code></pre>

<hr>
<h2 id='MLM+20Trials'>
Genomic mixed model
</h2><span id='topic+gmm'></span>

<h3>Description</h3>

<p>This function was developed to solve a mixel model for multi-environmental trials and/or replicated trials when genomic is available. The model includes a semi-parametric term to account for spatial variation when the field layout of the experiment is know. Covariates (fixed effects), genetics (random effect) and spatial term are fitted all in a single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm(y,gen,dta=NULL,it=75,bi=25,th=1,model="BRR",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLM+2B20Trials_+3A_y">y</code></td>
<td>

<p>Numeric vector of phenotypes of length <code class="reqn">obs</code> (missing values are allowed). <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix, with dimension <code class="reqn">n</code> x <code class="reqn">p</code>. Attention: Rows must be named with genotype IDs. Missing values are replaced by the SNP expectation.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_dta">dta</code></td>
<td>

<p>Data frame with <code class="reqn">obs</code> number of rows containg the genotype ID, spatial information and any other set covariates. Make sure to add a column called &quot;ID&quot; (with capital letters) informing the genotype ID with some match in the object <code>gen</code>. For the spatial adjustment, it is necessary to add three numeric columns (not factors) to <code>dta</code>: &quot;Block&quot;, &quot;Row&quot; and &quot;Col&quot; (case sensitive), where Block may refer to a field block or an enviroment without blocks Therefore, make sure that blocks from different environments are named differently. Row and Col provide the coordinates for the identification of neighbor plots.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_it">it</code></td>
<td>

<p>Integer. Total numeric of MCMC iterations used to fit the model.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_bi">bi</code></td>
<td>

<p>Integer. Burn-in of MCMC iterations, i.e., number of iteration to be discarted prior to model convergence.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_th">th</code></td>
<td>

<p>Integer. Thinning parameter: saves only 1 interation every <code>th</code>. Thinning is used to reduce the auto-correlation between Markov chains.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_model">model</code></td>
<td>

<p>Prediction model: The options are: <code>BRR</code>, <code>BayesA</code>, <code>GBLUP</code> and <code>RKHS</code>.
</p>
</td></tr>
<tr><td><code id="MLM+2B20Trials_+3A_...">...</code></td>
<td>

<p>Pass arguments to the function that builds the spatial splines <code>NNsrc</code>: rho and dist. By default, <code>rho=1</code> and <code>dist=3</code>. To check how it looks like in the field, type <code>NNsrc(rho=1,dist=3)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general model is <code class="reqn">y=Xb+Zu+f(x)+e</code>, where <code class="reqn">y</code> is the response variable, <code class="reqn">Xb</code> refers to the fixed effects, <code class="reqn">Zu</code> regards the genetic effect, <code class="reqn">f(x)</code> represents the field variation, and <code class="reqn">e</code> is the vector of residuals. In this model <code class="reqn">u</code> is a link function that represents the genetic component, which depends on the model specified.
</p>
<p>For whole-genome regression models (BRR or BayesA), <code class="reqn">u = Ma</code>, where <code class="reqn">M</code> is the matrix of genotypes. For kernel models (RKHS and GBLUP), <code class="reqn">u=N(0,K\sigma2a)</code>, where K is either a Gaussian kernel (RKHS) or a linear kernel (GBLUP). To avoid over-representation of genotypes, <code class="reqn">u</code> is not weighted according to the number of observations of each genotype.
</p>
<p>Unobserved genotypes not provided in <code>dta</code> but provided in <code>gen</code> are predicted in the output of the function. Genotypes without genotypic information are transfered to the fixed effect (eg. checks). Missing loci are imputed with the expectation. If <code>dta</code> is not provided, the function will work as a regular genomic prediction model, so the length of <code>y</code> must match the number of rows of <code>gen</code>.
</p>
<p>In whole-genome regression models, the regularization of the genetic term is either based on chosen prior (t, Gaussian), Gaussian (from ridge regression) and t (from BayesA). Kernel models (GBLUP and RKHS) are regularized as Gaussian process, which is similar to a ridge regression of Eigenvectors where the regularization of Eigenpairs also relies on the Eigenvalues.
</p>
<p>If there is a large number of trials and users acknowledge the necessity of sparse matrices, we recommend installing the Matrix package and run the following code that enables sparsity:
</p>
<p><code>source(system.file("add","sparseGMM.R",package="NAM"))</code>
</p>


<h3>Value</h3>

<p>The function gmm returns a list containing the fitted values (<code>hat</code>), observed values (<code>obs</code>), intercept (<code>mu</code>, incidence matrix of genotypes (<code>Z</code>) and the vector of breeding values (<code>EBV</code>). If fixed effects are provided, it also returns the design matrices and coefficients of fixed effects (<code>X</code>,<code>b</code>). If the model was kernel or regression, output will include
the random effect coefficients (<code>g</code>), variance components of markers (<code>Vg</code>) and residuals (<code>Ve</code>). Kernel models regress the Eigenvectors of the kernel, weighted by the Eigenvalue. The coefficient (<code>cxx</code>) used in the <code>BRR</code> model to convert marker variance <code class="reqn">Vb</code> into genetic variance <code class="reqn">Va</code>. If spatial information is provided, the output includes the fitted spatial term (<code>sp</code>).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

  # Checking heritability
data(tpod)
fit = gmm(y,gen,model = 'BRR')
fit$Vg*fit$cxx / (fit$Vg*fit$cxx+fit$Ve)
  
# For a demo with wulti-environmental trial type:
# demo(fittingMET)
  

## End(Not run)
</code></pre>

<hr>
<h2 id='Optimizations'>
Internal functions
</h2><span id='topic+calcSize'></span><span id='topic+funI'></span><span id='topic+funX'></span><span id='topic+inputRow'></span><span id='topic+RcppExports'></span><span id='topic+timesMatrix'></span><span id='topic+timesVec'></span><span id='topic+SAMP'></span><span id='topic+SAMP2'></span><span id='topic+gs'></span><span id='topic+KMUP'></span><span id='topic+KMUP2'></span><span id='topic+emRR'></span><span id='topic+emBA'></span><span id='topic+emBB'></span><span id='topic+emBC'></span><span id='topic+emBD'></span><span id='topic+emBL'></span><span id='topic+emDE'></span><span id='topic+emEN'></span><span id='topic+emML'></span><span id='topic+emML2'></span><span id='topic+emMX'></span><span id='topic+emCV'></span><span id='topic+BRR2'></span><span id='topic+Gdist'></span><span id='topic+markov'></span><span id='topic+eigX'></span><span id='topic+covar'></span><span id='topic+PedMat'></span><span id='topic+PedMat2'></span><span id='topic+LD'></span><span id='topic+G2A_Kernels'></span><span id='topic+Import_data'></span><span id='topic+NNsrc'></span><span id='topic+NNcov'></span><span id='topic+CNT'></span><span id='topic+MSX'></span><span id='topic+IMP'></span><span id='topic+NOR'></span><span id='topic+GAU'></span><span id='topic+GRM'></span><span id='topic+SPC'></span><span id='topic+SPM'></span><span id='topic+press'></span><span id='topic+emGWA'></span><span id='topic+BCpi'></span><span id='topic+mrr'></span><span id='topic+mrrV2'></span><span id='topic+mrr2X'></span><span id='topic+mkr'></span><span id='topic+mkr2X'></span><span id='topic+mrrFast'></span>

<h3>Description</h3>

<p>Internal function under optimization, complimentary statistics, and loops written in C++ to speed up <code class="reqn">gwas</code>, <code class="reqn">gibbs</code> and <code class="reqn">wgr</code>.
</p>


<h3>Details</h3>

<p>Some of the functions available for users include:
</p>
<p>01) <code>Import_data(file,type=c('GBS','HapMap','VCF')):</code>  This function can be used to import genotypic data in the NAM format, providing a list with a genotypic matrix <code>gen</code> coded as <code>012</code> and a vector <code>chr</code> with count of markers per chromosome. Currently, it helps users to import three types of files: GBS text, HapMap and VCF.
</p>
<p>02) <code>markov(gen,chr):</code>  Imputation method based forwards Markov model for SNP data coded as <code>012</code>. We recommend users to remove non-segregating markers before using this function.
</p>
<p>03) <code>LD(gen):</code>  Computes the linkage disequilibrium in terms of r2 for SNP data coded as <code>012</code>. Missing data is not allowed.
</p>
<p>04) <code>PedMat(ped):</code>  Builds a kinship from a pedigree. Input format is provided with <code>PedMat()</code>.
</p>
<p>05) <code>PedMat2(ped,gen=NULL,IgnoreInbr=FALSE,PureLines=FALSE):</code>  Builds a kinship from a genomic data and pedigree. Useful when not all individuals are genotyped. Row names of <code>gen</code> must indicate the genotype id.
</p>
<p>06) <code>Gdist(gen, method = 1):</code>  Computes genetic distance among individuals. Five methods are available: 1) Nei distance; 2) Edwards distance; 3) Reynolds distance; 4) Rogers distance; 5) Provesti's distance. 6) Modified Rogers distance
</p>
<p>07) <code>covar(sp=NULL,rho=3.5,type=1,dist=2.5):</code>  Builds a spatial kernel from field plot information. Input format is provided with <code>covar()</code>. Parameter <code>rho</code> detemines the decay of relationship among neighbor plots. <code>type</code> defines if the kernel is exponential (1), Gaussian (2) or some intermediate. <code>dist</code> informs the distance ratio between range neighbors and row neighbors.
</p>
<p>08) <code>eigX(gen,fam):</code>  Computes the input of the argument <code>EIG</code> of the function <code>gwas2</code>.
</p>
<p>09) <code>G2A_Kernels(gen):</code>  Computes a list of orthogonal kernels containing additive, dominant and first-order epistatic effects, in accordance to the G2A model from ZB Zeng et al. 2005. These kernels can be used for description of genetic architecture through variance components, for that we recommend packages <code>varComp</code> and <code>BGLR</code>.
</p>
<p>10) <code>NNsrc(sp=NULL,rho=1,dist=3):</code>  Using the same field data input required by the function <code>covar</code>, this function provides a list of nearest neighbor plots for each entry.
</p>
<p>11) <code>NNcov(NN,y):</code>  This function utilizes the output of <code>NNsrc</code> to generate a numeric vector, averageing the observed values of <code>y</code>. This function is useful to generate field covariates to control micro-environmental variance without krigging.
</p>
<p>11) <code>emXX(y,gen,...):</code>  Fits whole-genome regressions using the expectation-maximization algorithm as opposed to MCMC. Currently avaible methods include BayesA (<code>emBA</code>), BayesB (<code>emBB</code>), BayesC (<code>emBC</code>), BayesD (<code>emBD</code>), BLASSO (<code>emBL</code>), FLM (<code>emDE</code>), Elastic-Net (<code>emEN</code>), maximum likelihood (<code>emML</code>) and ridge regression (<code>emRR</code>). A cross-validation option is also available (<code>emCV</code>).
</p>
<p>12) <code>CNT(X):</code>  Centralizes parameters from matrix <code>X</code>.
</p>
<p>13) <code>IMP(X):</code>  Imputes missing points from matrix <code>X</code> with the average value of the column.
</p>
<p>14) <code>GAU(X):</code> Creates a Gaussian kernel from matrix <code>X</code>.
</p>
<p>15) <code>GRM(X, Code012=FALSE):</code> Creates genomic relationship matrix as linear kernel from matrix <code>X</code>. If genotypes are coded as 012 and Code012=TRUE, the kinship is the same as proposed by VanRaden (2008), otherwise the outcome is an additive G2A kernel.
</p>
<p>16) <code>MSX(X):</code> Computes the cross-product of each column of <code>X</code> and the sum of variances of each column of <code>X</code>.
</p>
<p>17) <code>NOR(y,X,cxx,xx,maxit=50,tol=10e-6):</code> Solves a ridge regression using GSRU, where  <code>y</code> corresponds to the response variable, <code>X</code> is the set of parameters, <code>cxx</code> and <code>xx</code> are the output from the MSX function, <code>maxit</code> and <code>tol</code> are the convergence criteria.
</p>
<p>18) <code>SPC(y,blk,row,col,rN=3,cN=1):</code> Computes a spatial covariate, similar to what could be obtained using NNsrc and NNcov but in a single step. It often is faster than NNsrc/NNcov.
</p>
<p>19) <code>SPM(blk,row,col,rN=3,cN=1):</code> Computes a spatial matrix that capture nearest neighbots, to be used as design matrix of random effects. The least-square solution gives the same as SPC.
</p>
<p>20) <code>BRR2(y,X1,X2,it=1500,bi=500,df=5,R2=0.5):</code> A simple C++ implementation of a Bayesian Ridge Regression that accomodates two random effects.
</p>
<p>21) <code>emML2(y,X1,X2,D1=NULL,D2=NULL):</code> A simple C++ implementation of emML that accomodates two random effects.
</p>
<p>22) <code>press(y,K,MaxIt=10):</code>Solves a PRESS-regularized GBLUP. You can provide K as a matrix or as the output of the functin eigen. MaxIt the maximum number of iterations to for updating missing values (if any) if H*y does not converge. 
</p>
<p>23) <code>emGWA(y,gen):</code> A vanilla algorithm written in C++ for GWAS (very simple, but very efficient). It fits a snpBLUP via EM-REML based GSRU, then run an additional round checkinkg the likelihood of treating each marker as fixed effect instead of random, thus avoiding double-fitting. It returns the marker p-values, snpBLUP marker effects for genomic prediction, LS marker effects from the GWAS, variance components, heritability, and GEBVs (fitted values).
</p>
<p>24) <code>BCpi(y,X,it=3000,bi=500,df=5,R2=0.5):</code> A vanilla implementation in C++ of BayesCpi for GWAS or GWP. It returns the marker p-values (as the minus log probability of marker excluded), marker effects for genomic prediction, probability of marker included, variance components, heritability, and GEBVs (fitted values). 
</p>
<p>25) <code>mrr(Y,X)/mkr(Y,K)/mrrV2(Y,X)/mrr2X(Y,X1,X2)/mkr2X(Y,K1,K2):</code>A C++ implementation for multivariate regression.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 


# Forward gen imputation
data(tpod)
fast.impute = markov(gen,chr)

# Wright's A matrix 
PedMat()

# Pairwise LD
ld = LD(gen[,1:10])
heatmap(ld)

# Spatial correlation (kernel-based)
covar()

# Spatial correlation (NN-based)
NNsrc()

# Genetic distance
round(Gdist(gen[1:10,],method=1),2)

# PCs of a NAM kinship
eG = eigX(gen,fam)
plot(eG[[2]],col=fam)

# Polygenic kinship matrices
Ks = G2A_Kernels(gen)
ls(Ks)

# Genomic regression fitted via EM
h = emBA(y,gen)
plot(h$b,pch=20)

# GBLUP and RRBLUP
g = GRM(gen)
eg = eigen(g)
gblup = emML(y=y, gen=eg$vectors,D=eg$values)
rrblup = emML(y=y, gen=gen)
plot(gblup$hat,rrblup$hat,xlab = 'gblup',ylab='rrblup')

# Vanilla GWAS
gwa = emGWA(y,gen)
plot(gwa$PVAL,pch=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='SNP+20H2'>
SNP heritability
</h2><span id='topic+snpH2'></span><span id='topic+plot.H2'></span>

<h3>Description</h3>

<p>Calculates the ability of markers to carry a gene (Foneris et al. 2015). The index is also an indicator of Mendelian segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpH2(gen,K=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNP+2B20H2_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code> rows of observations and (<code class="reqn">m</code>) columns of molecular markers.
</p>
</td></tr>
<tr><td><code id="SNP+2B20H2_+3A_k">K</code></td>
<td>

<p>Optional. Numeric matrix containing the genetic relationship matrix. A square and symmetric matrix (<code class="reqn">n</code>x<code class="reqn">n</code>) with the same observations as the matrix gen, also in the same order. If not provided, the kinship matrix is estimated from the genotypic matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector containing the heritability of each markers. Foneris et al. (2015) recommends to avoid using markers with index lower than 0.98. 
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>References</h3>

<p>Forneris, N. S., Legarra, A., Vitezica, Z. G., Tsuruta, S., Aguilar, I., Misztal, I., &amp; Cantet, R. J. (2015). Quality Control of Genotypes Using Heritability Estimates of Gene Content at the Marker. Genetics 199(3):675-681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(tpod)
Heritability=snpH2(gen)
plot(Heritability,chr=chr)

## End(Not run)
</code></pre>

<hr>
<h2 id='SNP+20QC'>
SNP Quality Control
</h2><span id='topic+snpQC'></span><span id='topic+cleanREP'></span><span id='topic+reference'></span>

<h3>Description</h3>

<p>Functions for quality control. 'snpQC' may be used to count/remove neighbor repeated SNPs, markers with MAF lower than a given threshold, and imputations. 'cleanREP' identifies and merge duplicate genotypes. The 'reference' function changes the reference genotype. For NAM populations, this function must be used when genotypes are coded according to the reference genome instead of the standard parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpQC(gen,psy=1,MAF=0.05,misThr=0.8,remove=TRUE,impute=FALSE)
cleanREP(y,gen,fam=NULL,thr=0.95)
reference(gen,ref=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNP+2B20QC_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and (<code class="reqn">m</code>) columns of molecular markers. SNPs must be coded as <code>0, 1, 2</code>, for founder homozigous, heterozigous and reference homozigous. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_psy">psy</code></td>
<td>

<p>Tolerance parameter for markers in Perfect SYymmetry (psy). This QC remove identical markers (aka. full LD) that carry the same information. Default is 1, which removes only SNPs 100% equal to its following neighbor.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_maf">MAF</code></td>
<td>

<p>Minor Allele Frequency. Default is 0.05. Useful to inform or remove markers below the MAF threshold. Markers with standard deviation below the MAF threshold will be also removed.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_misthr">misThr</code></td>
<td>

<p>Missing value threshold. Default is 0.8, removing markers with more than 80 percent missing values. 
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_remove">remove</code></td>
<td>

<p>Logical. Remove SNPs due to PSY or MAF.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_impute">impute</code></td>
<td>

<p>If TRUE, impute missing values using the expected value.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_y">y</code></td>
<td>

<p>Numeric vector (<code class="reqn">n</code>) or numeric matrix (<code class="reqn">n</code> x <code class="reqn">t</code>) of observations describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_fam">fam</code></td>
<td>

<p>Numeric vector of length (<code class="reqn">n</code>) indicating which subpopulations (<code class="reqn">i.e.</code> family) each observation comes from. Default assumes that all observations are from the same populations.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_thr">thr</code></td>
<td>

<p>Threshold above which genotypes are considered identical. Default is 0.95, merging genotypes &gt;95 percent identical.
</p>
</td></tr>
<tr><td><code id="SNP+2B20QC_+3A_ref">ref</code></td>
<td>

<p>Numeric vector of length <code class="reqn">n</code> with elements coded as <code>0, 1, 2</code>, it represents the genotypic information of a new reference genotype. Default assumes that more frequent allele represents the reference genome.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snpQC - Returns the genomic matrix without missing values, redundancy or low MAF markers.
</p>
<p>cleanREP - List containing the inputs without replicates. Groups of replicates are replaced by a single observation with the phenotypic expected value. The algorithm keeps the genotypic information of the first individual (genotypic matrix order).
</p>
<p>reference - Returns a recoded <code class="reqn">gen</code> matrix
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier, Katy Rainey and William Muir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
data(tpod)
gen=reference(gen)
gen=snpQC(gen=gen,psy=1,MAF=0.05,remove=TRUE,impute=FALSE)
test=cleanREP(y,gen)
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
