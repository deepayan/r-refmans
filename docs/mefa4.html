<!DOCTYPE html><html><head><title>Help for package mefa4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mefa4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mefa4-package'>
<p>Multivariate Data Handling with S4 Classes and Sparse Matrices</p></a></li>
<li><a href='#+25notin+25'>
<p>Negated Value Matching</p></a></li>
<li><a href='#abmibirds'>
<p>Raw Dataset of Bird Point Counts</p></a></li>
<li><a href='#find_max'>
<p>Utility functions for factors and compositional data</p></a></li>
<li><a href='#groupSums'>
<p>Compute Summary Statistics of Data Subsets</p></a></li>
<li><a href='#mbind'>
<p>Combine R Objects by Rows and Columns</p></a></li>
<li><a href='#Mefa'>
<p>'Mefa' Class</p></a></li>
<li><a href='#Melt'>
<p>Melting Matrices</p></a></li>
<li><a href='#nameAlnum'>
<p>Utility functions, mostly for character manipulation</p></a></li>
<li><a href='#nonDuplicated'>
<p>Non Duplicated Rows in Data Frame</p></a></li>
<li><a href='#r2rmd'>
<p>Parse R source file and return R markdown</p></a></li>
<li><a href='#samp'>
<p>Accessing and Replacing Parts of 'Mefa' Objects</p></a></li>
<li><a href='#Xtab'>
<p>Sparse Cross Tabulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Data Handling with S4 Classes and Sparse Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;solymos@ualberta.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An S4 update of the 'mefa' package
  using sparse matrices for enhanced efficiency.
  Sparse array-like objects are supported via
  lists of sparse matrices.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), methods, Matrix (&ge; 1.4-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mefa</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/mefa4">https://github.com/psolymos/mefa4</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/mefa4/issues">https://github.com/psolymos/mefa4/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-09 14:54:54 UTC; Peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-12 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mefa4-package'>
Multivariate Data Handling with S4 Classes and Sparse Matrices
</h2><span id='topic+mefa4-package'></span><span id='topic+mefa4'></span>

<h3>Description</h3>

<p>An S4 update of the 'mefa' package
using sparse matrices for enhanced efficiency.
</p>


<h3>Details</h3>

<p>An S4 update of the 'mefa' package
using sparse matrices for enhanced efficiency.
Sparse array-like objects are supported via
lists of sparse matrices.
</p>
<p>Main functions: <code><a href="#topic+Xtab">Xtab</a></code>, <code><a href="#topic+Mefa">Mefa</a></code>.
</p>
<p>Accessor and replacement functions: <code><a href="#topic+xtab">xtab</a></code>, 
<code><a href="#topic+samp">samp</a></code>, <code><a href="#topic+taxa">taxa</a></code>.
</p>
<p>Methods: <code><a href="#topic+mbind">mbind</a></code>, <code><a href="#topic+groupSums">groupSums</a></code>, 
<code><a href="#topic+groupMeans">groupMeans</a></code>.
</p>
<p>Coercion methods and virtual classes defined for
cross compatibility with the <code><a href="mefa.html#topic+mefa">mefa</a></code> package.
S4 object classes are described in <code><a href="#topic+Mefa">Mefa</a></code> help page.
</p>
<p>The vignette <code>vignette("mefa4")</code> gives an overview of the package,
gives a comparison of S3 and S4 object classes, and presents a performance
review.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>
<p>Maintainer: Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>References</h3>

<p>Solymos P. (2008) mefa: an R 
package for handling and reporting count data. 
<em>Community Ecology</em> <b>9</b>, 125&ndash;127.
</p>
<p>Solymos P. (2009) Processing ecological 
data in R with the mefa package. 
<em>Journal of Statistical Software</em> 
<b>29(8)</b>, 1&ndash;28. 
doi: <a href="https://doi.org/10.18637/jss.v029.i08">10.18637/jss.v029.i08</a>
</p>


<h3>See Also</h3>

<p>S3 classes: <code><a href="mefa.html#topic+mefa">mefa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vignette("mefa4")

## End(Not run)
</code></pre>

<hr>
<h2 id='+25notin+25'>
Negated Value Matching
</h2><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p><code>%notin%</code> is the negation of <code><a href="base.html#topic++25in+25">%in%</a></code>, 
which returns a logical vector indicating if there is a non-match or not 
for its left operand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25notin+2B25_+3A_x">x</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be matched.
</p>
</td></tr>
<tr><td><code id="+2B25notin+2B25_+3A_table">table</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be matched against.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, indicating if a non-match was located for each element of 
<code>x</code>: thus the values are <code>TRUE</code> or <code>FALSE</code> and never <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>All the opposite of what is written for <code><a href="base.html#topic++25in+25">%in%</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1:10 %notin% c(1,3,5,9)
sstr &lt;- c("c","ab","B","bba","c",NA,"@","bla","a","Ba","%")
sstr[sstr %notin% c(letters, LETTERS)]
</code></pre>

<hr>
<h2 id='abmibirds'>
Raw Dataset of Bird Point Counts
</h2><span id='topic+abmibirds'></span>

<h3>Description</h3>

<p>A data set of bird point counts collected by the Alberta
Biodiversity Monitoring Institute (ABMI, https://www.abmi.ca).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(abmibirds)</code></pre>


<h3>Format</h3>

<p>A data frame with 59341 observations on the following 21 variables.
</p>

<dl>
<dt><code>Rotation</code></dt><dd><p>a factor. Reference describing when data was
collected at a broad level.
Code definition: Prototype = 2003&ndash;2006, Rotation 1 = 2007&ndash;2012</p>
</dd>
<dt><code>ABMI.Site</code></dt><dd><p>a numeric vector. Reference number given to
each ABMI data collection site (1&ndash;1656).</p>
</dd>
<dt><code>Year</code></dt><dd><p>a numeric vector. Collection year.</p>
</dd>
<dt><code>Field.Date</code></dt><dd><p>a factor. Day, month, and year data was
collected.</p>
</dd>
<dt><code>Field.Crew.Members</code></dt><dd><p>a factor. Initials for the field
technicians collecting the field data.</p>
</dd>
<dt><code>Identification.Date</code></dt><dd><p>a factor. Day, month, and year
data was analyzed by specialist.</p>
</dd>
<dt><code>Identification.Analyst</code></dt><dd><p>a factor. Initials for the
technicians/specialists identifying the specimens.</p>
</dd>
<dt><code>Point.Count.Station</code></dt><dd><p>a numeric vector. Point count
station where recording was made: 9 stations were
located around each ABMI site (1&ndash;9).</p>
</dd>
<dt><code>Wind.Conditions</code></dt><dd><p>a factor. Estimate of wind conditions
on a scale of 0&ndash;5.
0 = no wind, 1 = calm, 2 = leaves rustling, 3 small branches
moving, 4 = large branches moving, 5 = large branches moving and
the tree is swaying</p>
</dd>
<dt><code>Precipitation</code></dt><dd><p>a factor. Classification for precipitation
conditions in 5 categories.
Input value: Drizzle, Fog, Rain, Sleet, Snow, None</p>
</dd>
<dt><code>Start.of.Point.Count</code></dt><dd><p>a factor. Time of day recording was
started.
Input value: 24 hour clock (hh:mm).</p>
</dd>
<dt><code>End.of.Point.Count</code></dt><dd><p>a factor. Time of day recording was
finished. Input value: 24 hour clock (hh:mm).</p>
</dd>
<dt><code>Common.Name</code></dt><dd><p>a factor. Common name of bird species detected
during point counts.</p>
</dd>
<dt><code>Scientific.Name</code></dt><dd><p>a factor. Scientific name of bird species
detected during point count.</p>
</dd>
<dt><code>Unique.Taxonomic.Identification.Number</code></dt><dd><p>a factor. Globally
unique identifier of bird species detected during point
count. Unique taxonomic identifiers are generally taken from the
International Taxonomic Information System
(ITIS; <a href="https://www.itis.gov/">https://www.itis.gov/</a>).</p>
</dd>
<dt><code>Taxonomic.Resolution</code></dt><dd><p>a factor. Resolution to which bird
species was identified (e.g. Family, Genus, Species etc.).</p>
</dd>
<dt><code>Time.First.Detected</code></dt><dd><p>a factor. Approximate time the bird
analyst first detects a bird species from
the recording; listed in 10-second intervals.</p>
</dd>
<dt><code>Interval.1</code></dt><dd><p>a factor. First time interval of the 10-minute
point count (0&ndash;200 seconds)
when bird species are detected and identified.</p>
</dd>
<dt><code>Interval.2</code></dt><dd><p>a factor. Middle time interval of the 10-minute
point count (201&ndash;400 seconds) when bird species are detected or
re-detected.</p>
</dd>
<dt><code>Interval.3</code></dt><dd><p>a factor. Last time interval of the 10-minute
point count (401&ndash;600 seconds) when bird species are detected or
re-detected.</p>
</dd>
<dt><code>Behaviour</code></dt><dd><p>a factor. Classification given to each species
detection (if possible).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Breeding birds were measured at nine point count stations. Point count stations
were in a grid pattern with point count station no. 1 located at site-centre and the
remaining stations located 300 m apart surrounding site centre.
We conducted breeding bird surveys from one half hour before sunrise to 10:00 hrs.
</p>
<p>We recorded vocalizations of birds for 10 minutes at each point count station using
an omni-directional microphone (CZM microphone; River Forks Research Corp.)
mounted at ear level on a professional tripod and connected to a mini hard drive
recorder. We recorded birds on a Marantz PM D670 or PM D660 Solid State
recorder at 320 kbps in .mp3 format. We calibrated the recorder volume to be in
the mid ranges.
</p>
<p>While conducting the 10 minute bird
recordings, we scanned the areas surrounding the point count station for all birds (even those
vocalizing), noting species, number of individuals (including flock sizes of birds flying overhead), and
distance from the point count station, for all bird observations. We also noted factors that potentially
bias bird recordings, such as wind speed and precipitation. Bird recordings were later analyzed by bird
identification specialists in a laboratory setting.
</p>
<p>If a bird point fell in open water, we established a new point if we were able to get within 100 m of the
original point, recording distance and direction from that original point. If it was not possible to get
within 100 m of the original point (i.e., &lt;200 m from the last point), we conducted a 10 minute visual
point count of the waterbody recording observations into the microphone. We may not have sampled
certain points because they were inaccessible (e.g., a stream made access hazardous or impossible).
</p>
<p>We analyzed bird recordings in a laboratory setting. We identified the species, time of first detection
(within 10 second intervals), behaviour (e.g., singing, calling, or alarm-calling), and the time interval that
individual birds were detected. We recognized 3 time intervals: Interval 1 (0&ndash;200 seconds), Interval 2
(201&ndash;400 seconds), and Interval 3 (401&ndash;600 seconds). Individual birds were detected in 1, 2, or 3 of
the time intervals. We identified red squirrel (<em>Tamiasciurus hudsonicus</em>) vocalizations in addition to bird
vocalizations. Bird recordings are randomly sampled and verified by other experts in bird identification
to ensure accuracy.
</p>
<p>Throughout ABMI raw data files, the following codes and definitions are applied.
</p>
<p>None or 0:
None or 0 is applied to any variable that was examined by field crews and found to be absent.
None is used for text entries and 0 is used for numerical entries. For example, when field crews
examine the canopy and find no Veteran trees in the canopy, this is recorded as None. When
there is no slope at the survey site, slope is recorded as 0. The numeral 0 can also be used as a
nominal code, for example, wind conditions can be recorded as 0.
</p>
<p>VNA Variable Not Applicable:
Some ABMI data is collected in a nested manner. For example Tree Species is a parent variable. This
variable has a number of child variables that are used to describe the parent variable in more detail
(e.g., condition, DBH, decay stage). When the parent variable is recorded as None, child variables
are no longer applied and are recorded as VNA. VNA is also used when the protocol calls for a
modified sampling procedure based on site conditions (e.g., surface substrate protocol variant for
hydric site conditions). The use of VNA implies that users of the data should not expect that any
data could be present.
</p>
<p>DNC, Did Not Collect:
DNC is used to describe variables that should have been collected but were not. There are a
number of reasons that data might not have been collected (e.g., staff oversight, equipment failure,
safety concerns, environmental conditions, or time constraints). Regardless of the reason data was not
collected, if under ideal conditions it should have been, the record in the data entry file reads DNC.
The use of DNC implies that users should expect the data to be present, though it is not.
</p>
<p>PNA, Protocol Not Available:
The ABMI's protocols were, and continue to be, implemented in a staged manner. As a result, the
collection of many variables began in years subsequent to the start of the prototype or operational
phases or where discontinued after a few years of trial. When a variable was not collected because the
protocol had yet to be implemented by the ABMI (or was discontinued by the ABMI), the data entry
record reads PNA. This is a global constraint to the data (i.e., a protocol was not implemented until
2006, therefore, previous years cannot have this variable). PNA is to be used to describe the lack of
data collection for entire years.
</p>
<p>SNI, Species Not Identified:
In various fields related to species identification, SNI is used to indicate that the organism was not
identified. Some possible reasons that identification was not possible include insufficient or deficient
sample collected and lack of field time.
</p>


<h3>Source</h3>

<p>RAW_T26BreedingBirds28621.csv, https://www.abmi.ca
</p>


<h3>References</h3>

<p>Raw breeding bird data (2004&ndash;2006 inclusive) from the Alberta Biodiversity Monitoring
Institute was used, in whole or part, to create this product. More information on the Institute
can be found at: https://www.abmi.ca
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abmibirds)
str(abmibirds)
</code></pre>

<hr>
<h2 id='find_max'>
Utility functions for factors and compositional data
</h2><span id='topic+compare_sets'></span><span id='topic+find_max'></span><span id='topic+find_min'></span><span id='topic+reclass'></span><span id='topic+redistribute'></span>

<h3>Description</h3>

<p>Utility functions for factors and compositional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_sets(x, y)
find_max(x)
find_min(x)
reclass(x, map, all = FALSE, allow_NA = FALSE)
redistribute(x, source, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_max_+3A_x">x</code>, <code id="find_max_+3A_y">y</code></td>
<td>

<p>any type for <code>compare_sets</code>,
matrix for <code>find_max</code>, <code>find_min</code>, and <code>redistribute</code>,
a factor for <code>reclass</code>.
</p>
</td></tr>
<tr><td><code id="find_max_+3A_map">map</code></td>
<td>

<p>a reclassification matrix with 2 columns (1st: original levels,
2nd: output levels mapped to original levels).
</p>
</td></tr>
<tr><td><code id="find_max_+3A_all">all</code></td>
<td>

<p>logical, whether all levels from mapping matrix should be
applied on the return object.
</p>
</td></tr>
<tr><td><code id="find_max_+3A_allow_na">allow_NA</code></td>
<td>

<p>logical, whether <code>NA</code>s are allowed as part of <code>map</code>.
</p>
</td></tr>
<tr><td><code id="find_max_+3A_source">source</code></td>
<td>

<p>numeric or character, single column index for input matrix <code>x</code>.
</p>
</td></tr>
<tr><td><code id="find_max_+3A_target">target</code></td>
<td>

<p>numeric or character, column index or indices for input matrix <code>x</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>compare_sets</code>.
</p>
<p>A data frame for <code>find_max</code> and <code>find_min</code>.
</p>
<p>A reclassified factor for <code>reclass</code>.
</p>
<p>A matrix for <code>redistribute</code> where the source column values are
redistributed among the target columns proportionally.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+intersect">intersect</a></code>, <code><a href="base.html#topic+setdiff">setdiff</a></code>,
<code><a href="base.html#topic+union">union</a></code>, <code><a href="stats.html#topic+relevel">relevel</a></code>, <code><a href="stats.html#topic+reorder">reorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric vector
compare_sets(1:10, 8:15)
## factor with 'zombie' labels
compare_sets(factor(1:10, levels=1:10), factor(8:15, levels=1:15))

(mat &lt;- matrix(rnorm(10*5), 10, 5))
(m &lt;- find_max(mat))
## column indices
as.integer(m$index)
find_min(mat)

map &lt;- cbind(c("a","b","c","d","e","f","g"),
             c("A","B","B","C","D","D","E"))
#x &lt;- factor(sample(map[1:6,1], 100, replace=TRUE), levels=map[,1])
x &lt;- as.factor(sample(map[1:6,1], 100, replace=TRUE))
x[2] &lt;- NA
table(x, reclass(x, map, all = FALSE), useNA="always")
table(x, reclass(x, map, all = TRUE), useNA="always")

map[c(4, 7), 2] &lt;- NA
table(x, reclass(x, map, all = FALSE, allow_NA = TRUE), useNA="always")
table(x, reclass(x, map, all = TRUE, allow_NA = TRUE), useNA="always")

(mat2 &lt;- exp(mat) / rowSums(exp(mat)))
(rmat2 &lt;- redistribute(mat2, source = 1, target = 2:4))
colMeans(mat2)
colMeans(rmat2)
stopifnot(abs(sum(mat2) - sum(rmat2)) &lt; 10^-6)

</code></pre>

<hr>
<h2 id='groupSums'>
Compute Summary Statistics of Data Subsets
</h2><span id='topic+sum_by'></span><span id='topic+groupSums'></span><span id='topic+groupSums+2Cmatrix-method'></span><span id='topic+groupSums+2CsparseMatrix-method'></span><span id='topic+groupSums+2CMefa-method'></span><span id='topic+groupMeans'></span><span id='topic+groupMeans+2Cmatrix-method'></span><span id='topic+groupMeans+2CsparseMatrix-method'></span><span id='topic+groupMeans+2CMefa-method'></span>

<h3>Description</h3>

<p>Compute summary statistics (sums, means) of data subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupSums(object, ...)
## S4 method for signature 'matrix'
groupSums(object, MARGIN, by, na.rm = FALSE, ...)
## S4 method for signature 'sparseMatrix'
groupSums(object, MARGIN, by, na.rm = FALSE, ...)
## S4 method for signature 'Mefa'
groupSums(object, MARGIN, by, replace, na.rm = FALSE, ...)

groupMeans(object, ...)
## S4 method for signature 'matrix'
groupMeans(object, MARGIN, by, na.rm = FALSE, ...)
## S4 method for signature 'sparseMatrix'
groupMeans(object, MARGIN, by, na.rm = FALSE, ...)
## S4 method for signature 'Mefa'
groupMeans(object, MARGIN, by, replace, na.rm = FALSE, ...)

sum_by(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupSums_+3A_object">object</code></td>
<td>

<p>an object.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_x">x</code></td>
<td>

<p>a vector.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_margin">MARGIN</code></td>
<td>

<p>numeric, <code>1</code> indicates rows are to be summed/averaged,
<code>2</code> indicates columns are to be summed/averaged.
<code>c(1, 2)</code> is not yet implemented, but can be calculated
calling the function twice.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_by">by</code></td>
<td>
<p>a vector of grouping elements corresponding to dimensions
of <code>object</code> and <code>MARGIN</code>.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_replace">replace</code></td>
<td>
<p>a data frame to be used when applying the method on a
<code>"Mefa"</code> object. The attribute table
corresponding to <code>MARGIN</code> is dropped (<code>NULL</code>),
<code>replace</code>ment table can be specified via this argument.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?
Sum is calculated by zeroing out <code>NA</code> values,
mean is calculated as dividing the sum by the number of
non-<code>NA</code> values when collapsing.
</p>
</td></tr>
<tr><td><code id="groupSums_+3A_...">...</code></td>
<td>

<p>other argument, currently not implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method sums/averages cells in a matrix.
The functions behind these methods use sparse matrices,
so calculations can be more efficient compared to using
<code><a href="stats.html#topic+aggregate">aggregate</a></code>.
</p>


<h3>Value</h3>

<p>An object similar to the input one.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rowSums">rowSums</a></code>, <code><a href="base.html#topic+rowMeans">rowMeans</a></code>,
<code><a href="base.html#topic+colSums">colSums</a></code>, <code><a href="base.html#topic+colMeans">colMeans</a></code>
</p>
<p>Standard <code><a href="stats.html#topic+aggregate">aggregate</a></code> in package <span class="pkg">stats</span>
</p>
<p><code><a href="mefa.html#topic+aggregate.mefa">aggregate.mefa</a></code> in package
<span class="pkg">mefa</span> for S3 <code>"mefa"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),
    "zero.pseudo"), count = c(1,2,10,3,4,0),
    stringsAsFactors = TRUE)
samp &lt;- data.frame(samples=levels(x$sample), var1=1:2,
    stringsAsFactors = TRUE)
taxa &lt;- data.frame(specnames=levels(x$species), var2=c("b","a"),
    stringsAsFactors = TRUE)
rownames(samp) &lt;- samp$samples
rownames(taxa) &lt;- taxa$specnames
x2 &lt;- Xtab(count ~ sample + species, x, cdrop=FALSE,rdrop=TRUE)
x5 &lt;- Mefa(x2, samp, taxa, join="inner")

groupSums(as.matrix(x2), 1, c(1,1,2))
groupSums(as.matrix(x2), 2, c(1,1,2,2))
groupSums(x2, 1, c(1,1,2))
groupSums(x2, 2, c(1,1,2,2))
groupSums(x5, 1, c(1,1,2))
groupSums(x5, 2, c(1,1,2,2))

groupMeans(as.matrix(x2), 1, c(1,1,2))
groupMeans(as.matrix(x2), 2, c(1,1,2,2))
groupMeans(x2, 1, c(1,1,2))
groupMeans(x2, 2, c(1,1,2,2))
groupMeans(x5, 1, c(1,1,2))
groupMeans(x5, 2, c(1,1,2,2))

sum_by(runif(100, 0, 1), sample(LETTERS[1:4], 100, replace=TRUE))
</code></pre>

<hr>
<h2 id='mbind'>
Combine R Objects by Rows and Columns
</h2><span id='topic+mbind'></span><span id='topic+mbind+2Cmatrix+2Cmatrix-method'></span><span id='topic+mbind+2CsparseMatrix+2CsparseMatrix-method'></span><span id='topic+mbind+2CMefa+2CMefa-method'></span><span id='topic+mbind2'></span><span id='topic+mbind2+2Cmatrix+2Cmatrix-method'></span><span id='topic+mbind2+2CsparseMatrix+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Combine R objects by rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbind(x, y, fill, ...)
mbind2(x, y, fill, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbind_+3A_x">x</code>, <code id="mbind_+3A_y">y</code></td>
<td>

<p>objects to combine, see Details.
</p>
</td></tr>
<tr><td><code id="mbind_+3A_fill">fill</code></td>
<td>

<p>numeric value or <code>NA</code> (default) to fill up outer set
(not part of union) of dimnames.
</p>
</td></tr>
<tr><td><code id="mbind_+3A_...">...</code></td>
<td>

<p>other argument, not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> are combined in a left join manner,
meaning that all the elements in
<code>x</code> are retained, and only non-overlapping elements in <code>y</code> are used.
Elements of the returning object that are not part of <code>x</code>
and <code>y</code> (outer set) are filled up with <code>fill</code>.
</p>
<p>If relational table in <code>x</code> is <code>NULL</code>,
corresponding values from same table
of <code>y</code> are used.
</p>
<p><code>mbind2</code> combines <code>x</code> and <code>y</code> so that inner set is
calculated as sum of corresponding elements from <code>x</code> and <code>y</code>
(unlike in <code>mbind</code> with a left join manner).
</p>


<h3>Value</h3>

<p>An object similar to the input one.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+cbind">cbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=matrix(1:4,2,2)
rownames(x) &lt;- c("a","b")
colnames(x) &lt;- c("A","B")
y=matrix(11:14,2,2)
rownames(y) &lt;- c("b","c")
colnames(y) &lt;- c("B","C")

sampx &lt;- data.frame(x1=1:2, x2=2:1,
    stringsAsFactors = TRUE)
rownames(sampx) &lt;- rownames(x)
sampy &lt;- data.frame(x1=3:4, x3=10:11,
    stringsAsFactors = TRUE)
rownames(sampy) &lt;- rownames(y)
taxay &lt;- data.frame(x1=1:2, x2=2:1,
    stringsAsFactors = TRUE)
rownames(taxay) &lt;- colnames(y)
taxax &lt;- NULL

mbind(x,y)
mbind(as(x,"sparseMatrix"),as(y,"sparseMatrix"))
xy &lt;- mbind(Mefa(x,sampx),Mefa(y,sampy,taxay))
unclass(xy)

mbind2(x,y)
mbind2(as(x,"sparseMatrix"),as(y,"sparseMatrix"))
xtab(xy) &lt;- mbind2(x, y)
unclass(xy)
</code></pre>

<hr>
<h2 id='Mefa'>
'Mefa' Class
</h2><span id='topic+Mefa'></span><span id='topic+Mefa-class'></span><span id='topic+MefaDataFrame'></span><span id='topic+MefaMatrix'></span><span id='topic+mefa'></span><span id='topic+stcs'></span><span id='topic+MefaDataFrame-class'></span><span id='topic+MefaMatrix-class'></span><span id='topic+mefa-class'></span><span id='topic+stcs-class'></span><span id='topic+dim+2CMefa-method'></span><span id='topic+dimnames+2CMefa-method'></span><span id='topic+dimnames+3C-+2CMefa+2Clist-method'></span><span id='topic+t+2CMefa-method'></span><span id='topic+show+2CMefa-method'></span><span id='topic+stack+2CMefa-method'></span>

<h3>Description</h3>

<p>Creating an object of class <code>"Mefa"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mefa(xtab, samp, taxa, join = c("left", "inner"), drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mefa_+3A_xtab">xtab</code></td>
<td>

<p>a matrix or a sparse matrix.
</p>
</td></tr>
<tr><td><code id="Mefa_+3A_samp">samp</code></td>
<td>

<p>a data frame or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="Mefa_+3A_taxa">taxa</code></td>
<td>

<p>a data frame or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="Mefa_+3A_join">join</code></td>
<td>

<p>character, <code>"left"</code> (default) or <code>"inner"</code>.
</p>
</td></tr>
<tr><td><code id="Mefa_+3A_drop">drop</code></td>
<td>

<p>logical, if unused levels in the data frames should be dropped.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>samp</code> and <code>taxa</code> tables are matched with
corresponding dimnames in <code>xtab</code>:
rownames with <code>samp</code>, colnames with <code>taxa</code>.
If <code>join = "left"</code>, all rows and columns in <code>xtab</code> are retained,
while missing items in the corresponding attribute tables are filled up with <code>NA</code>s.
If <code>join = "inner"</code>, only the intersection of corresponding names are retained.
</p>
<p>The <code>xtab</code> slot is a sparse matrix (<code>dgCMatrix</code>). The input
should be in class <code>MefaMatrix</code> that is a class union of
<code>matrix</code> and <code>sparseMatrix</code> classes.
</p>
<p>The <code>samp</code> and <code>taxa</code> slots take data frame or <code>NULL</code>, which two form
the <code>MefaDataFrame</code> class union.
</p>
<p>The virtual classes <code>mefa</code> and <code>stcs</code> are defined for
seamless coercion between S3 and S4 classes.
</p>


<h3>Value</h3>

<p>An S4 object of class <code>"Mefa"</code> with 4 slots: <code>xtab</code>,
<code>samp</code>, <code>taxa</code>, <code>join</code>.
</p>


<h3>Note</h3>

<p>If <code>xtab</code> has no dimnames, matching it up with the attribute tables can be problematic.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>Creating crosstabulations: <code><a href="#topic+Xtab">Xtab</a></code>, <code><a href="stats.html#topic+xtabs">xtabs</a></code> in package <span class="pkg">stats</span>, <code><a href="stats.html#topic+xtabs">xtabs</a></code> in package <span class="pkg">stats</span>
</p>
<p><code>"mefa"</code> S3 class: <code><a href="mefa.html#topic+mefa">mefa</a></code> in <span class="pkg">mefa</span> package.
</p>
<p>Accessing and replacing slots: <code><a href="#topic+xtab">xtab</a></code>, <code><a href="#topic+samp">samp</a></code>, <code><a href="#topic+taxa">taxa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    stringsAsFactors = TRUE)
samp &lt;- data.frame(samples=levels(x$sample), var1=1:2,
    stringsAsFactors = TRUE)
taxa &lt;- data.frame(specnames=levels(x$species), var2=c("b","a"),
    stringsAsFactors = TRUE)
rownames(samp) &lt;- samp$samples
rownames(taxa) &lt;- taxa$specnames

## Xtab class, counts by repetitions in RHS
(x0 &lt;- Xtab(~ sample + species, x))

## counts by LHS and repetitions in RHS
(x1 &lt;- Xtab(count ~ sample + species, x))

## drop all empty rows
(x2 &lt;- Xtab(count ~ sample + species, x, cdrop=FALSE,rdrop=TRUE))

## drop all empty columns
Xtab(count ~ sample + species, x, cdrop=TRUE,rdrop=FALSE)

## drop specific columns by placeholder
Xtab(count ~ sample + species, x, cdrop="zero.pseudo")

## Mefa class, standard
(x3 &lt;- Mefa(x1, samp, taxa))
unclass(x3)
x3@xtab
x3@samp
x3@taxa
x3@join

## effects of left join, NULL taxa slot, xtab is (not sparse) matrix
(x4 &lt;- Mefa(as.matrix(x1), samp[1:2,]))
unclass(x4)

## effects of inner join (intersect)
(x5 &lt;- Mefa(x2, samp, taxa, join="inner"))
unclass(x5)
unclass(Mefa(x1, samp[1:2,], join="inner"))

## xtab only Mefa
(x6 &lt;- Mefa(x1))

## creating new Mefa object without Mefa()
new("Mefa", xtab=x1, samp=samp, taxa=taxa,join="left")

## dim and dimnames
dim(x5)
dimnames(x5)
dn &lt;- list(paste("S", 1:3, sep=""), paste("SPP", 1:4, sep=""))
dimnames(x5) &lt;- dn
unclass(x5)
dimnames(x5)[[1]] &lt;- paste("S", 1:3, sep="_")
unclass(x5)
dimnames(x5)[[2]] &lt;- paste("SPP", 1:4, sep="_")
unclass(x5)

## transpose
x5
t(x5)
unclass(x5)
unclass(t(x5))

## 0 and 1 row/col Mefa object
x3[c(FALSE,FALSE,FALSE,FALSE),c(FALSE,FALSE,FALSE,FALSE)]
x3[c(TRUE,FALSE,FALSE,FALSE),c(FALSE,FALSE,FALSE,FALSE)]
x3[c(FALSE,FALSE,FALSE,FALSE),c(TRUE,FALSE,FALSE,FALSE)]
x3[c(TRUE,FALSE,FALSE,FALSE),c(TRUE,FALSE,FALSE,FALSE)]

## stack
stack(x3)
</code></pre>

<hr>
<h2 id='Melt'>
Melting Matrices
</h2><span id='topic+Melt'></span>

<h3>Description</h3>

<p>The function reverses the side effects of cross tabulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Melt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Melt_+3A_x">x</code></td>
<td>

<p>A matrix, or sparse matrix object, a list of sparse matrices with identical dimnames,
a 'mefa' or 'Mefa' object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns corresponding to <code>rows</code>, <code>cols</code>,
possibly <code>segm</code> (names of the list if <code>x</code> was a list of
sparse matrices), and <code>value</code>. <code>value</code> is numeric, other
columns are factors.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+stack">stack</a></code> in <span class="pkg">utils</span>,
and <code><a href="mefa.html#topic+melt">melt</a></code> in <span class="pkg">mefa</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    segment = letters[c(6,13,6,13,6,6)],
    stringsAsFactors = TRUE)
xx
xx0 &lt;- Xtab(count ~ sample + species, xx)
xx1 &lt;- Xtab(count ~ sample + species + segment, xx)
(M1 &lt;- Melt(xx0))
Melt(as.matrix(xx0))
(M2 &lt;- Melt(xx1))
stopifnot(identical(Xtab(value ~ rows + cols, M1), xx0))
stopifnot(identical(Xtab(value ~ rows + cols + segm, M2), xx1))
</code></pre>

<hr>
<h2 id='nameAlnum'>
Utility functions, mostly for character manipulation
</h2><span id='topic+nameAlnum'></span><span id='topic+pasteDate'></span><span id='topic+paste0date'></span><span id='topic+normalizeNames'></span>

<h3>Description</h3>

<p>Utility functions, mostly for character manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasteDate(..., sep = " ", collapse = NULL, sep.date = sep)
paste0date(..., collapse = NULL)
nameAlnum(x, capitalize=c("asis", "first", "none", "all", "mixed"),
    collapse=" ")
normalizeNames(x, pattern = list(" "), replacement = list("_"),
    alnum = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameAlnum_+3A_x">x</code></td>
<td>

<p>caharacter.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_...">...</code></td>
<td>

<p>one or more R objects, to be converted to character vectors.
For <code>normalizeNames</code> it takes arguments passed to <code>nameAlnum</code>
when <code>alnum = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_sep">sep</code></td>
<td>

<p>a character string to separate the terms.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_collapse">collapse</code></td>
<td>

<p>an optional character string to separate the results.
For <code>nameAlnum</code> it is the separator between the words in the output.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_sep.date">sep.date</code></td>
<td>

<p>a character string to separate the terms from the data itself.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_capitalize">capitalize</code></td>
<td>

<p>character, which letter of each words should be capitalized.
<code>"mixed"</code> capitalizes the first letter and case is unchanged
for the rest (CamelCase). <code>"first"</code> capitalizes first letter and
uses lower case for the rest. Other options are self explanatory.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_pattern">pattern</code></td>
<td>

<p>a list of character vectors that are replaced.
Must match argument <code>replacement</code>.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_replacement">replacement</code></td>
<td>

<p>a list of character vectors that are the replacements for <code>pattern</code>.
Must match argument <code>pattern</code>.
</p>
</td></tr>
<tr><td><code id="nameAlnum_+3A_alnum">alnum</code></td>
<td>

<p>logical, if <code>nameAlnum</code> should be applied after replacement.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with desired changes.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>, <code><a href="base.html#topic+paste0">paste0</a></code>,
<code><a href="base.html#topic+strsplit">strsplit</a></code>, <code><a href="base.html#topic+gsub">gsub</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paste0(pasteDate("file", "name", sep="-", sep.date="_"), ".csv")
paste0(paste0date("file", "name", sep.date="_"), ".csv")

data(abmibirds)
x &lt;- data.frame(Name=levels(abmibirds[["Common.Name"]]),
    NameAlnum=nameAlnum(levels(abmibirds[["Common.Name"]])),
    stringsAsFactors = TRUE)
x[grep("'", x$Name),]

data.frame(out=sapply(c("asis", "first", "none", "all", "mixed"),
    function(z) nameAlnum("Olive-sided Flycatcher", z)),
    stringsAsFactors = TRUE)

z &lt;- data.frame(Name=levels(abmibirds[["Common.Name"]]),
    NameNormalized=normalizeNames(levels(abmibirds[["Common.Name"]]),
        pattern=list("'", "-", " "), replacement=list("", "_", "_")),
    stringsAsFactors = TRUE)
z[grepl("'", z$Name) &amp; grepl("-", z$Name),]
</code></pre>

<hr>
<h2 id='nonDuplicated'>
Non Duplicated Rows in Data Frame
</h2><span id='topic+nonDuplicated'></span>

<h3>Description</h3>

<p>Subset a data frame using non duplicated elements in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonDuplicated(x, y, change.rownames = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonDuplicated_+3A_x">x</code></td>
<td>

<p>a data frame.
</p>
</td></tr>
<tr><td><code id="nonDuplicated_+3A_y">y</code></td>
<td>

<p>a vector. It can be a name of a column in <code>x</code> without quotes.
</p>
</td></tr>
<tr><td><code id="nonDuplicated_+3A_change.rownames">change.rownames</code></td>
<td>

<p>if original rownames of <code>x</code> are to be replaced by unique 
non duplicated values of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="nonDuplicated_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. If rows should be removed where <code>y</code> is <code>NA</code>.
This is to be applied if values of <code>y</code> are used as rownames
by setting <code>change.rownames = TRUE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is handy to keep only one set of 
duplicated data that is common
in long formatted database files.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abmibirds)
x &lt;- nonDuplicated(abmibirds, abmibirds$ABMI.Site, TRUE)
## or equivalently
#x &lt;- nonDuplicated(abmibirds, ABMI.Site, TRUE)
dim(abmibirds)
dim(x)
length(unique(abmibirds$ABMI.Site))
</code></pre>

<hr>
<h2 id='r2rmd'>
Parse R source file and return R markdown
</h2><span id='topic+r2rmd'></span>

<h3>Description</h3>

<p>Parses an R source file and returns an R markdown document that
can be turned into a human readable documentation of what the source file does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2rmd(file, out=paste(file, "md", sep=""), header=TRUE, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2rmd_+3A_file">file</code></td>
<td>

<p>a file name or connection (see <code><a href="base.html#topic+readLines">readLines</a></code>.
</p>
</td></tr>
<tr><td><code id="r2rmd_+3A_out">out</code></td>
<td>

<p>an output file name passed to <code><a href="base.html#topic+writeLines">writeLines</a></code>,
or <code>NULL</code> (no file written).
</p>
</td></tr>
<tr><td><code id="r2rmd_+3A_header">header</code></td>
<td>

<p>logical, if a yaml header (enclosed between tribple dashes, <code>---</code>)
is to be parsed.
</p>
</td></tr>
<tr><td><code id="r2rmd_+3A_extra">extra</code></td>
<td>

<p>character, optional string that is placed into the code chunk openings.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leading double hashes <code>##</code> treated as non-code.
Leading <code>#</code> followed by other than <code>#</code> is code comment.
Leading <code>#</code> after whitespace is code comment.
A newline is code when preceded and followed by code.
</p>
<p>The leading double hash <code>##</code> is trimmed for comment lines.
R markdown chunk start/end stuff is added for code chunks.
The argument <code>extra</code> adds chunk arguments, e.g. 
<code>extra=', eval=FALSE'</code> etc. See R markdown website at 
<a href="https://rmarkdown.rstudio.com/">https://rmarkdown.rstudio.com/</a>
</p>


<h3>Value</h3>

<p>Returns a character vector invisibly, and writes a file as a side effects 
unless <code>out=NULL</code> in which case no file is written.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><a href="https://rmarkdown.rstudio.com/">https://rmarkdown.rstudio.com/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(r2rmd(system.file("r2rmd_example.R", package="mefa4"), 
    out=NULL, extra=", eval=FALSE"))

## End(Not run)
</code></pre>

<hr>
<h2 id='samp'>
Accessing and Replacing Parts of 'Mefa' Objects
</h2><span id='topic+xtab'></span><span id='topic+samp'></span><span id='topic+taxa'></span><span id='topic+xtab+3C-'></span><span id='topic+samp+3C-'></span><span id='topic+taxa+3C-'></span><span id='topic++5B'></span><span id='topic+xtab+2CMefa-method'></span><span id='topic+samp+2CMefa-method'></span><span id='topic+taxa+2CMefa-method'></span><span id='topic+xtab+3C-+2CMefa+2CMefaMatrix-method'></span><span id='topic+samp+3C-+2CMefa+2CMefaDataFrame-method'></span><span id='topic+taxa+3C-+2CMefa+2CMefaDataFrame-method'></span><span id='topic++5B+2CMefa+2CANY+2CANY+2CANY-method'></span><span id='topic+samp+2Cmefa-method'></span><span id='topic+taxa+2Cmefa-method'></span><span id='topic+xtab+2Cmefa-method'></span>

<h3>Description</h3>

<p>Methods to access and replace parts (elements, slots) of <code>"Mefa"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtab(x)
"xtab&lt;-"(x, value)

samp(x)
"samp&lt;-"(x, value)

taxa(x)
"taxa&lt;-"(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_+3A_x">x</code></td>
<td>

<p>an object of S4 class <code>"Mefa"</code>.
</p>
</td></tr>
<tr><td><code id="samp_+3A_value">value</code></td>
<td>

<p>replacement value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>[</code> method ensures that the <code>xtab</code> sparse matrix part and the
corresponding attribute tables are subsetted correctly.
</p>
<p>Validity check is performed when replacing slots of an object.
</p>


<h3>Value</h3>

<p>An object of S4 class <code>"Mefa"</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mefa">Mefa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    stringsAsFactors = TRUE)
samp &lt;- data.frame(samples=levels(x$sample), var1=1:2,
    stringsAsFactors = TRUE)
taxa &lt;- data.frame(specnames=levels(x$species), var2=c("b","a"),
    stringsAsFactors = TRUE)
rownames(samp) &lt;- samp$samples
rownames(taxa) &lt;- taxa$specnames
x1 &lt;- Xtab(count ~ sample + species, x)
x3 &lt;- Mefa(x1, samp, taxa)

## accessing the xtab slot
xtab(x3)
## replacing the slot value
x1[3,1] &lt;- 999
xtab(x3) &lt;- x1
xtab(x3)

## accessing and replacing the samp slot
samp(x3)
samp(x3) &lt;- NULL
samp(x3)
samp(x3) &lt;- samp[1:3,]
samp(x3)

## accessing and replacing the taxa slot
taxa(x3)
taxa(x3) &lt;- NULL
taxa(x3)
taxa(x3) &lt;- taxa[1:3,]
taxa(x3)

## subsetting
unclass(x3[3:2, 1:2])
unclass(x3[3:2,])
unclass(x3[,1:2])
</code></pre>

<hr>
<h2 id='Xtab'>
Sparse Cross Tabulation
</h2><span id='topic+Xtab'></span><span id='topic+sparseMatrixList-class'></span>

<h3>Description</h3>

<p>Create a contingency table from cross-classifying factors, usually contained in a data frame, using a formula interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xtab(formula = ~., data = parent.frame(), rdrop, cdrop,
subset, na.action, exclude = c(NA, NaN), drop.unused.levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xtab_+3A_formula">formula</code></td>
<td>

<p>a <code><a href="stats.html#topic+formula">formula</a></code> object with the cross-classifying variables (separated by +) on the right hand side (or an object which can be coerced to a formula). Interactions are not allowed. On the left hand side, one may optionally give a vector or a matrix of counts; in the latter case, the columns are interpreted as corresponding to the levels of a variable. This is useful if the data have already been tabulated, see the examples below.
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_data">data</code></td>
<td>

<p>an optional matrix or data frame (or similar: see <code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the formula formula. By default the variables are taken from environment(formula).
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_rdrop">rdrop</code>, <code id="Xtab_+3A_cdrop">cdrop</code></td>
<td>

<p>logical (should zero marginal rows/columns be removed after cross tabulation), character or numeric (what rows/columns should be removed).
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain NAs.
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_exclude">exclude</code></td>
<td>

<p>a vector of values to be excluded when forming the set of levels of the classifying factors.
</p>
</td></tr>
<tr><td><code id="Xtab_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>

<p>a logical indicating whether to drop unused levels in the classifying factors. If this is FALSE and there are unused levels, the table will contain zero marginals, and a subsequent chi-squared test for independence of the factors will not work.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates two- or three-way cross tabulation. Only works for two or three factors.
</p>
<p>If a left hand side is given in formula, its entries are simply summed over the cells corresponding to the right hand side; this also works if the left hand side does not give counts.
</p>


<h3>Value</h3>

<p>A sparse numeric matrix inheriting from <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>, specifically an object of S4 class <code>dgCMatrix</code>.
</p>
<p>For three factors, a list of sparse matrices.
</p>


<h3>Author(s)</h3>

<p>This function is a slight modification of the <code><a href="stats.html#topic+xtabs">xtabs</a></code> function in the <span class="pkg">stats</span> package.
</p>
<p>Modified by Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>See also <code><a href="stats.html#topic+xtabs">xtabs</a></code> in <span class="pkg">stats</span> package.
</p>
<p><code><a href="#topic+sum_by">sum_by</a></code> for sums over a classes ('one-way table'),
and <code><a href="#topic+Melt">Melt</a></code> for the inverse operation of <code>Xtab</code>.
</p>
<p><code>"mefa"</code> S3 class: <code><a href="mefa.html#topic+mefa">mefa</a></code> in <span class="pkg">mefa</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    stringsAsFactors = TRUE)
x
## Xtab class, counts by repetitions in RHS
(x0 &lt;- Xtab(~ sample + species, x))
## counts by LHS and repetitions in RHS
(x1 &lt;- Xtab(count ~ sample + species, x))
## drop all empty rows
(x2 &lt;- Xtab(count ~ sample + species, x, cdrop=FALSE,rdrop=TRUE))
## drop all empty columns
Xtab(count ~ sample + species, x, cdrop=TRUE,rdrop=FALSE)
## drop specific columns by placeholder
Xtab(count ~ sample + species, x, cdrop="zero.pseudo")

## 2 and 3 way crosstabs
xx &lt;- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    segment = letters[c(6,13,6,13,6,6)],
    stringsAsFactors = TRUE)
xx
Xtab(count ~ sample + species, xx)
Xtab(count ~ sample + species + segment, xx)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
