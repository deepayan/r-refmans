<!DOCTYPE html><html><head><title>Help for package EMD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EMD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cvimpute.by.mean'><p>Imputation by the mean of the two adjacent values</p></a></li>
<li><a href='#cvtype'><p>Generating test dataset index for cross-validation</p></a></li>
<li><a href='#emd'><p>Empirical Mode Decomposition</p></a></li>
<li><a href='#EMD-internal'><p>Internal EMD Functions</p></a></li>
<li><a href='#emd.pred'><p>Prediction by EMD and VAR model</p></a></li>
<li><a href='#emd2d'><p>Bidimenasional Empirical Mode Decomposition</p></a></li>
<li><a href='#emddenoise'><p>Denoising by EMD and Thresholding</p></a></li>
<li><a href='#extractimf'><p>Intrinsic Mode Function</p></a></li>
<li><a href='#extractimf2d'><p>Bidimensional Intrinsic Mode Function</p></a></li>
<li><a href='#extrema'><p>Finding Local Extrema and Zero-crossings</p></a></li>
<li><a href='#extrema2dC'><p>Finding Local Extrema</p></a></li>
<li><a href='#hilbertspec'><p>Hilbert Transform and Instantaneous Frequency</p></a></li>
<li><a href='#imageEMD'><p>Plot of Bidimenasional Empirical Mode Decomposition Result</p></a></li>
<li><a href='#kospi200'><p>Korea Stock Price Index 200</p></a></li>
<li><a href='#lena'><p>Gray Lena image</p></a></li>
<li><a href='#lennon'><p>Gray John Lennon image</p></a></li>
<li><a href='#semd'><p>Statistical Empirical Mode Decomposition</p></a></li>
<li><a href='#solar'><p>Solar Irradiance Proxy Data</p></a></li>
<li><a href='#spectrogram'><p>Spectrogram</p></a></li>
<li><a href='#sunspot'><p>Sunspot Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Mode Decomposition and Hilbert Spectral Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Donghoh Kim [aut, cre],
  Hee-Seok Oh [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Donghoh Kim &lt;donghoh.kim@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), fields (&ge; 6.9.1), locfit (&ge; 1.5-8)</td>
</tr>
<tr>
<td>Description:</td>
<td>For multiscale analysis, this package carries out empirical mode decomposition and Hilbert spectral
        analysis. For usage of EMD, see Kim and Oh, 2009 (Kim, D and Oh, H.-S. (2009) EMD: A Package for Empirical 
        Mode Decomposition and Hilbert Spectrum, The R Journal, 1, 40-46). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-30 02:20:42 UTC; donghohkim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-04 00:10:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='cvimpute.by.mean'>Imputation by the mean of the two adjacent values</h2><span id='topic+cvimpute.by.mean'></span>

<h3>Description</h3>

<p>This function performs imputation by the mean of the two adjacent values for test dataset of cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvimpute.by.mean(y, impute.index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvimpute.by.mean_+3A_y">y</code></td>
<td>
<p>observation</p>
</td></tr>
<tr><td><code id="cvimpute.by.mean_+3A_impute.index">impute.index</code></td>
<td>
<p>test dataset index for cross-validation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs imputation by the mean of the two adjacent values for test dataset of cross-validation.
See Kim et al. (2012) for detalis.
</p>


<h3>Value</h3>

<table>
<tr><td><code>yimpute</code></td>
<td>
<p>imputed values by the mean of the two adjacent values</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, D., Kim, K.-O. and Oh, H.-S. (2012) Extending the Scope of Empirical Mode Decomposition using Smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012:168</b>, doi: 10.1186/1687-6180-2012-168.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cvtype">cvtype</a></code>, <code><a href="#topic+semd">semd</a></code>.
</p>

<hr>
<h2 id='cvtype'>Generating test dataset index for cross-validation</h2><span id='topic+cvtype'></span>

<h3>Description</h3>

<p>This function generates test dataset index for cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvtype(n, cv.bsize=1, cv.kfold, cv.random=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvtype_+3A_n">n</code></td>
<td>
<p>the number of observation</p>
</td></tr>
<tr><td><code id="cvtype_+3A_cv.bsize">cv.bsize</code></td>
<td>
<p>block size of cross-validation</p>
</td></tr>
<tr><td><code id="cvtype_+3A_cv.kfold">cv.kfold</code></td>
<td>
<p>the number of fold of cross-validation</p>
</td></tr>
<tr><td><code id="cvtype_+3A_cv.random">cv.random</code></td>
<td>
<p>whether or not random cross-validation scheme should be used. 
Set <code>cv.random=TRUE</code> for random cross-validation scheme</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides index of test dataset according to various cross-validation scheme.
One may construct K test datasets in a way that each testset consists of blocks of b
consecutive data. Set <code>cv.bsize = b</code> for this. 
To select each fold at random, set <code>cv.random = TRUE</code>. See Kim et al. (2012) for detalis.
</p>


<h3>Value</h3>

<p>matrix of which row is test dataset index for cross-validation
</p>


<h3>References</h3>

<p>Kim, D., Kim, K.-O. and Oh, H.-S. (2012) Extending the Scope of Empirical Mode Decomposition using Smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012:168</b>, doi: 10.1186/1687-6180-2012-168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Traditional 4-fold cross-validation for 100 observations
cvtype(n=100, cv.bsize=1, cv.kfold=4, cv.random=FALSE)
# Random 4-fold cross-validation with block size 2 for 100 observations
cvtype(n=100, cv.bsize=2, cv.kfold=4, cv.random=TRUE)
</code></pre>

<hr>
<h2 id='emd'>Empirical Mode Decomposition</h2><span id='topic+emd'></span>

<h3>Description</h3>

<p>This function performs empirical mode decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emd(xt, tt=NULL, tol=sd(xt)*0.1^2, max.sift=20, stoprule="type1",  
    boundary="periodic", sm="none", smlevels=c(1), spar=NULL, alpha=NULL, 
    check=FALSE, max.imf=10, plot.imf=FALSE, interm=NULL, weight=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emd_+3A_xt">xt</code></td>
<td>
<p>observation or signal observed at time <code>tt</code></p>
</td></tr>
<tr><td><code id="emd_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="emd_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting. If <code>stoprule=type5</code>, the number of iteration for S stoppage criterion.</p>
</td></tr>
<tr><td><code id="emd_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="emd_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of envelope mean must be less than the user-specified tolerance level 
in the sense that the local average of upper and lower envelope is zero.
The stopping rules <code>type2</code>, <code>type3</code>, <code>type4</code> and <code>type5</code> are the stopping rules given by equation (5.5) of Huang et al. (1998), equation (11a), 
equation (11b) and S stoppage of Huang and Wu (2008), respectively.</p>
</td></tr> 
<tr><td><code id="emd_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;wave&quot;, &ldquo;symmetric&quot;, &ldquo;periodic&quot; or &ldquo;evenodd&quot;. See Zeng and He (2004) for <code>evenodd</code> boundary condition.</p>
</td></tr>
<tr><td><code id="emd_+3A_sm">sm</code></td>
<td>
<p>specifies whether envelop is constructed by interpolation, spline smoothing, kernel smoothing, or local polynomial smoothing. 
Use &ldquo;none&quot; for interpolation, &ldquo;spline&quot; for spline smoothing, &ldquo;kernel&quot; for kernel smoothing, or &ldquo;locfit&quot; for local polynomial smoothing.
See Kim et al. (2012) for detalis.
</p>
</td></tr>
<tr><td><code id="emd_+3A_smlevels">smlevels</code></td>
<td>
<p>specifies which level of the IMF is obtained by smoothing other than interpolation.</p>
</td></tr>
<tr><td><code id="emd_+3A_spar">spar</code></td>
<td>
<p>specifies user-supplied smoothing parameter of spline smoothing, kernel smoothing, or local polynomial smoothing.</p>
</td></tr>
<tr><td><code id="emd_+3A_alpha">alpha</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="emd_+3A_check">check</code></td>
<td>
<p>specifies whether the sifting process is displayed. If <code>check=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
<tr><td><code id="emd_+3A_max.imf">max.imf</code></td>
<td>
<p>the maximum number of IMF's</p>
</td></tr>
<tr><td><code id="emd_+3A_plot.imf">plot.imf</code></td>
<td>
<p>specifies whether each IMF is displayed. If <code>plot.imf=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
<tr><td><code id="emd_+3A_interm">interm</code></td>
<td>
<p>specifies vector of periods to be excluded from the IMF's to cope with mode mixing.</p>
</td></tr>
<tr><td><code id="emd_+3A_weight">weight</code></td>
<td>
<p>deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs empirical mode decomposition.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>imf</code></td>
<td>
<p>IMF's</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting IMF's from observations <code>xt</code></p>
</td></tr>
<tr><td><code>nimf</code></td>
<td>
<p>the number of IMF's</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Huang, N. E. and Wu, Z. (2008) A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
<em>Reviews of Geophysics</em>, <b>46</b>, RG2006.
</p>
<p>Kim, D., Kim, K.-O. and Oh, H.-S. (2012) Extending the Scope of Empirical Mode Decomposition using Smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012:168</b>, doi: 10.1186/1687-6180-2012-168.
</p>
<p>Zeng, K and He, M.-X. (2004) A simple boundary process technique for empirical mode decomposition.
<em>Proceedings of 2004 IEEE International Geoscience and Remote Sensing Symposium</em>, <b>6</b>, 4258&ndash;4261.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrema">extrema</a></code>, <code><a href="#topic+extractimf">extractimf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Empirical Mode Decomposition
ndata &lt;- 3000
tt2 &lt;- seq(0, 9, length=ndata)
xt2 &lt;- sin(pi * tt2) + sin(2* pi * tt2) + sin(6 * pi * tt2)  + 0.5 * tt2

try &lt;- emd(xt2, tt2, boundary="wave")

### Ploting the IMF's
par(mfrow=c(try$nimf+1, 1), mar=c(2,1,2,1))
rangeimf &lt;- range(try$imf)
for(i in 1:try$nimf) {
    plot(tt2, try$imf[,i], type="l", xlab="", ylab="", ylim=rangeimf,
    main=paste(i, "-th IMF", sep="")); abline(h=0)
}
plot(tt2, try$residue, xlab="", ylab="", main="residue", type="l", axes=FALSE); box()
</code></pre>

<hr>
<h2 id='EMD-internal'>Internal EMD Functions</h2><span id='topic+EMD-internal'></span><span id='topic+hilbert'></span><span id='topic+unwrap'></span><span id='topic+C_extrema2dC'></span><span id='topic+extrema2dVC'></span><span id='topic+imageplot.ts'></span>

<h3>Description</h3>

<p>The <code>hilbert</code>, <code>unwrap</code>, <code>C_extrema2dC</code>, <code>extrema2dVC</code> and <code>imageplot.ts</code> are internal EMD functions.
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='emd.pred'>Prediction by EMD and VAR model</h2><span id='topic+emd.pred'></span>

<h3>Description</h3>

<p>This function calculates prediction values and confidence limits
using EMD and VAR (vector autoregressive) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emd.pred(varpred, trendpred, ci = 0.95, figure = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emd.pred_+3A_varpred">varpred</code></td>
<td>
<p>prediction result of IMF's by VAR model.</p>
</td></tr>
<tr><td><code id="emd.pred_+3A_trendpred">trendpred</code></td>
<td>
<p>prediction result of residue by polynomial regression model.</p>
</td></tr>
<tr><td><code id="emd.pred_+3A_ci">ci</code></td>
<td>
<p>confidence interval level.</p>
</td></tr>
<tr><td><code id="emd.pred_+3A_figure">figure</code></td>
<td>
<p>specifies whether prediction result is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates prediction values and confidence limits
using EMD and VAR (vector autoregressive) model. See Kim et al. (2008) for detalis.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fcst</code></td>
<td>
<p>prediction values</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower limits of prediction</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper limits of prediction</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, D, Paek, S.-H. and Oh, H.-S. (2008) A Hilbert-Huang Transform Approach for Predicting Cyber-Attacks.
<em>Journal of the Korean Statistical Society</em>, <b>37</b>, 277&ndash;283, doi:10.1016/j.jkss.2008.02.006.
</p>

<hr>
<h2 id='emd2d'>Bidimenasional Empirical Mode Decomposition</h2><span id='topic+emd2d'></span>

<h3>Description</h3>

<p>This function performs the bidimenasional empirical mode decomposition
utilizing extrema detection based
on the equivalence relation between neighboring pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emd2d(z, x = NULL, y = NULL, tol = sd(c(z)) * 0.1^2, max.sift = 20, 
    boundary = "reflexive", boundperc = 0.3, max.imf = 5, sm = "none", 
    smlevels = 1, spar = NULL, weight = NULL, plot.imf = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emd2d_+3A_z">z</code></td>
<td>
<p>matrix of an image observed at (<code>x</code>, <code>y</code>)</p>
</td></tr>
<tr><td><code id="emd2d_+3A_x">x</code>, <code id="emd2d_+3A_y">y</code></td>
<td>
<p>locations of regular grid at which the values in <code>z</code> are measured</p>
</td></tr>
<tr><td><code id="emd2d_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting</p>
</td></tr>
<tr><td><code id="emd2d_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="emd2d_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;symmetric&quot; or &ldquo;reflexive&quot;.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_boundperc">boundperc</code></td>
<td>
<p>expand an image by adding specified percentage of image at the boundary when boundary condition is 'symmetric' or 'reflexive'.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_max.imf">max.imf</code></td>
<td>
<p>the maximum number of IMF's</p>
</td></tr>
<tr><td><code id="emd2d_+3A_sm">sm</code></td>
<td>
<p>specifies whether envelop is constructed by interpolation, thin-plate smoothing, Kriging, local polynomial smoothing, or loess. 
Use &ldquo;none&quot; for interpolation, &ldquo;Tps&quot; for thin-plate smoothing, &ldquo;mKrig&quot; for Kriging, &ldquo;locfit&quot; for local polynomial smoothing, or &ldquo;loess&quot; for loess.
See Kim et al. (2012) for detalis.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_smlevels">smlevels</code></td>
<td>
<p>specifies which level of the IMF is obtained by smoothing other than interpolation.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_spar">spar</code></td>
<td>
<p>specifies user-supplied smoothing parameter of thin-plate smoothing, Kriging, local polynomial smoothing, or loess.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_weight">weight</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="emd2d_+3A_plot.imf">plot.imf</code></td>
<td>
<p>specifies whether each IMF is displayed. If <code>plot.imf=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the bidimenasional empirical mode decomposition
utilizing extrema detection based
on the equivalence relation between neighboring pixels. See Kim et al. (2012) for detalis.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>imf</code></td>
<td>
<p>two dimensional IMF's</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue image after extracting the IMF's</p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p>index of maxima</p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>index of minima</p>
</td></tr>
<tr><td><code>nimf</code></td>
<td>
<p>number of IMF's</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Kim, D., Park, M. and Oh, H.-S. (2012) Bidimensional Statistical Empirical Mode Decomposition. <em>IEEE Signal Processing Letters</em>, 
<b>19</b>, 191&ndash;194, doi: 10.1109/LSP.2012.2186566.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrema2dC">extrema2dC</a></code>, <code><a href="#topic+extractimf2d">extractimf2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lena)
z &lt;- lena[seq(1, 512, by=4), seq(1, 512, by=4)]
image(z, main="Lena", xlab="", ylab="", col=gray(0:100/100), axes=FALSE)

## Not run: 
lenadecom &lt;- emd2d(z, max.imf = 4)
imageEMD(z=z, emdz=lenadecom, extrema=TRUE, col=gray(0:100/100))
## End(Not run)

### Test Image
ndata &lt;- 128

x &lt;- y &lt;- seq(0, 9, length=ndata)
meanf1 &lt;- outer(sin(2 * pi * x), sin(2 * pi * y))
meanf2 &lt;- outer(sin(0.5 * pi * x), sin(0.5 * pi * y))
meanf &lt;- meanf1 + meanf2

snr &lt;- 2
set.seed(77)
zn &lt;- meanf + matrix(rnorm(ndata^2, 0, sd(c(meanf))/snr), ncol=ndata)

rangezn &lt;- range(c(meanf1, meanf2, meanf, zn))
par(mfrow=c(2,2), mar=0.1 + c(0, 0.25, 3, 0.25))
image(meanf1, main="high frequency component", xlab="", ylab="", zlim=rangezn, 
    col=gray(100:0/100), axes=FALSE)
image(meanf2, main="low frequency component", xlab="", ylab="", zlim=rangezn, 
    col=gray(100:0/100), axes=FALSE)
image(meanf, main="test image", xlab="", ylab="", zlim=rangezn, col=gray(100:0/100), axes=FALSE)
image(zn, main="noisy image", xlab="", ylab="", zlim=rangezn, col=gray(100:0/100), axes=FALSE)

## Not run: 
out &lt;- emd2d(zn, max.imf=3, sm="locfit", smlevels=1, spar=0.004125)
par(mfcol=c(3,1), mar=0.1 + c(0, 0.25, 0.25, 0.25)) 
image(out$imf[[1]], main="", xlab="", ylab="", col=gray(100:0/100), zlim=rangezn, axes=FALSE)
image(out$imf[[2]], main="", xlab="", ylab="", col=gray(100:0/100), zlim=rangezn, axes=FALSE)
image(out$imf[[3]], main="", xlab="", ylab="", col=gray(100:0/100), zlim=rangezn, axes=FALSE)
## End(Not run)
</code></pre>

<hr>
<h2 id='emddenoise'>Denoising by EMD and Thresholding</h2><span id='topic+emddenoise'></span>

<h3>Description</h3>

<p>This function performs denoising by empirical mode decomposition and thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emddenoise(xt, tt = NULL, cv.index, cv.level, cv.tol = 0.1^3, 
    cv.maxiter = 20, by.imf = FALSE, emd.tol = sd(xt) * 0.1^2, 
    max.sift = 20, stoprule = "type1", boundary = "periodic", 
    max.imf = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emddenoise_+3A_xt">xt</code></td>
<td>
<p>observation or signal observed at time <code>tt</code></p>
</td></tr>
<tr><td><code id="emddenoise_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_cv.index">cv.index</code></td>
<td>
<p>test dataset index according to cross-validation scheme</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_cv.level">cv.level</code></td>
<td>
<p>levels to be thresholded</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_cv.tol">cv.tol</code></td>
<td>
<p>tolerance for the optimization step of cross-validation</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_cv.maxiter">cv.maxiter</code></td>
<td>
<p>maximum iteration for the optimization step of cross-validation</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_by.imf">by.imf</code></td>
<td>
<p>specifies whether shrinkage is performed by each IMS or not.</p>
</td></tr> 
<tr><td><code id="emddenoise_+3A_emd.tol">emd.tol</code></td>
<td>
<p>tolerance for stopping rule of sifting. If <code>stoprule=type5</code>, the number of iteration for S stoppage criterion.</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of envelope mean must be less than the user-specified tolerance level 
in the sense that the local average of upper and lower envelope is zero.
The stopping rules <code>type2</code>, <code>type3</code>, <code>type4</code> and <code>type5</code> are the stopping rules given by equation (5.5) of Huang et al. (1998), equation (11a), 
equation (11b) and S stoppage of Huang and Wu (2008), respectively.</p>
</td></tr> 
<tr><td><code id="emddenoise_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;wave&quot;, &ldquo;symmetric&quot;, &ldquo;periodic&quot; or &ldquo;evenodd&quot;. See Zeng and He (2004) for <code>evenodd</code> boundary condition.</p>
</td></tr>
<tr><td><code id="emddenoise_+3A_max.imf">max.imf</code></td>
<td>
<p>the maximum number of IMF's</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs denoising by empirical mode decomposition and cross-validation. See Kim and Oh (2006) for details.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>dxt</code></td>
<td>
<p>denoised signal</p>
</td></tr>
<tr><td><code>optlambda</code></td>
<td>
<p>threshold values by cross-validation</p>
</td></tr>
<tr><td><code>lambdaconv</code></td>
<td>
<p>sequence of lambda's by cross-validation</p>
</td></tr>
<tr><td><code>perr</code></td>
<td>
<p>sequence of prediction error by cross-validation</p>
</td></tr>
<tr><td><code>demd</code></td>
<td>
<p>denoised IMF's and residue</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>the number of iteration for optimal threshold value</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Huang, N. E. and Wu, Z. (2008) A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
<em>Reviews of Geophysics</em>, <b>46</b>, RG2006.
</p>
<p>Kim, D. and Oh, H.-S. (2006) Hierarchical Smoothing Technique by Empirical Mode Decomposition (Korean). <em>The Korean Journal of Applied Statistics</em>, <b>19</b>, 319&ndash;330.
</p>
<p>Zeng, K and He, M.-X. (2004) A simple boundary process technique for empirical mode decomposition.
<em>Proceedings of 2004 IEEE International Geoscience and Remote Sensing Symposium</em>, <b>6</b>, 4258&ndash;4261.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cvtype">cvtype</a></code>, <code><a href="#topic+emd">emd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndata &lt;- 1024
tt &lt;- seq(0, 9, length=ndata)
meanf &lt;- (sin(pi*tt) + sin(2*pi*tt) + sin(6*pi*tt)) * (0.0&lt;tt &amp; tt&lt;=3.0) + 
 (sin(pi*tt) + sin(6*pi*tt)) * (3.0&lt;tt &amp; tt&lt;=6.0) +
 (sin(pi*tt) + sin(6*pi*tt) + sin(12*pi*tt)) * (6.0&lt;tt &amp; tt&lt;=9.0)
snr &lt;- 3.0
sigma &lt;- c(sd(meanf[tt&lt;=3]) / snr, sd(meanf[tt&lt;=6 &amp; tt&gt;3]) / snr, 
sd(meanf[tt&gt;6]) / snr)
set.seed(1)
error &lt;- c(rnorm(sum(tt&lt;=3), 0, sigma[1]), 
rnorm(sum(tt&lt;=6 &amp; tt&gt;3), 0, sigma[2]), rnorm(sum(tt&gt;6), 0, sigma[3]))
xt &lt;- meanf + error 

cv.index &lt;- cvtype(n=ndata, cv.kfold=2, cv.random=FALSE)$cv.index 

## Not run: 
try10 &lt;- emddenoise(xt, cv.index=cv.index, cv.level=2, by.imf=TRUE)

par(mfrow=c(2, 1), mar=c(2, 1, 2, 1))
plot(xt, type="l", main="noisy signal")
lines(meanf, lty=2)
plot(try10$dxt, type="l", main="denoised signal")
lines(meanf, lty=2)
## End(Not run)
</code></pre>

<hr>
<h2 id='extractimf'>Intrinsic Mode Function</h2><span id='topic+extractimf'></span>

<h3>Description</h3>

<p>This function extracts intrinsic mode function from given a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractimf(residue, tt=NULL, tol=sd(residue)*0.1^2, max.sift=20, 
    stoprule="type1", boundary="periodic", sm="none", spar=NULL, 
    alpha=NULL, check=FALSE, weight=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractimf_+3A_residue">residue</code></td>
<td>
<p>observation or signal observed at time <code>tt</code></p>
</td></tr>
<tr><td><code id="extractimf_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="extractimf_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting. If <code>stoprule=type5</code>, the number of iteration for S stoppage criterion.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="extractimf_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of envelope mean must be less than the user-specified tolerance level 
in the sense that the local average of upper and lower envelope is zero.
The stopping rules <code>type2</code>, <code>type3</code>, <code>type4</code> and <code>type5</code> are the stopping rules given by equation (5.5) of Huang et al. (1998), equation (11a), 
equation (11b) and S stoppage of Huang and Wu (2008), respectively.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;wave&quot;, &ldquo;symmetric&quot;, &ldquo;periodic&quot; or &ldquo;evenodd&quot;. See Zeng and He (2004) for <code>evenodd</code> boundary condition.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_sm">sm</code></td>
<td>
<p>specifies whether envelop is constructed by interpolation, spline smoothing, kernel smoothing, or local polynomial smoothing. 
Use &ldquo;none&quot; for interpolation, &ldquo;spline&quot; for spline smoothing, &ldquo;kernel&quot; for kernel smoothing, or &ldquo;locfit&quot; for local polynomial smoothing.
See Kim et al. (2012) for detalis.
</p>
</td></tr>
<tr><td><code id="extractimf_+3A_spar">spar</code></td>
<td>
<p>specifies user-supplied smoothing parameter of spline smoothing, kernel smoothing, or local polynomial smoothing.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_alpha">alpha</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_check">check</code></td>
<td>
<p>specifies whether the sifting process is displayed. If <code>check=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
<tr><td><code id="extractimf_+3A_weight">weight</code></td>
<td>
<p>deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts intrinsic mode function from given a signal.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>imf</code></td>
<td>
<p>imf</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting the finest imf from <code>residue</code></p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>the number of iteration to obtain the <code>imf</code></p>
</td></tr> 
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Huang, N. E. and Wu, Z. (2008) A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
<em>Reviews of Geophysics</em>, <b>46</b>, RG2006.
</p>
<p>Kim, D., Kim, K.-O. and Oh, H.-S. (2012) Extending the Scope of Empirical Mode Decomposition using Smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012:168</b>, doi: 10.1186/1687-6180-2012-168.
</p>
<p>Zeng, K and He, M.-X. (2004) A simple boundary process technique for empirical mode decomposition.
<em>Proceedings of 2004 IEEE International Geoscience and Remote Sensing Symposium</em>, <b>6</b>, 4258&ndash;4261.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrema">extrema</a></code>, <code><a href="#topic+emd">emd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generating a signal
ndata &lt;- 3000
par(mfrow=c(1,1), mar=c(1,1,1,1))
tt2 &lt;- seq(0, 9, length=ndata)
xt2 &lt;- sin(pi * tt2) + sin(2* pi * tt2) + sin(6 * pi * tt2)  + 0.5 * tt2
plot(tt2, xt2, xlab="", ylab="", type="l", axes=FALSE); box()

### Extracting the first IMF by sifting process
tryimf &lt;- extractimf(xt2, tt2, check=FALSE)
</code></pre>

<hr>
<h2 id='extractimf2d'>Bidimensional Intrinsic Mode Function</h2><span id='topic+extractimf2d'></span>

<h3>Description</h3>

<p>This function extracts the bidimensional intrinsic mode function from given an image
utilizing extrema detection based
on the equivalence relation between neighboring pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractimf2d(residue, x=NULL, y=NULL, nnrow=nrow(residue), 
    nncol=ncol(residue), tol=sd(c(residue))*0.1^2, 
    max.sift=20, boundary="reflexive", boundperc=0.3,  
    sm="none", spar=NULL, weight=NULL, check=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractimf2d_+3A_residue">residue</code></td>
<td>
<p>matrix of an image observed at (<code>x</code>, <code>y</code>)</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_x">x</code>, <code id="extractimf2d_+3A_y">y</code></td>
<td>
<p>locations of regular grid at which the values in <code>residue</code> are measured</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_nnrow">nnrow</code></td>
<td>
<p>the number of row of an input image</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_nncol">nncol</code></td>
<td>
<p>the number of column of an input image</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;symmetric&quot; or &ldquo;reflexive&quot;.</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_boundperc">boundperc</code></td>
<td>
<p>expand an image by adding specified percentage of image at the boundary when boundary condition is 'symmetric' or 'reflexive'.</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_sm">sm</code></td>
<td>
<p>specifies whether envelop is constructed by interpolation, thin-plate smoothing, Kriging, local polynomial smoothing, or loess.
Use &ldquo;none&quot; for interpolation, &ldquo;Tps&quot; for thin-plate smoothing, &ldquo;mKrig&quot; for Kriging, &ldquo;locfit&quot; for local polynomial smoothing, or &ldquo;loess&quot; for loess.</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_spar">spar</code></td>
<td>
<p>specifies user-supplied smoothing parameter of thin-plate smoothing, Kriging, local polynomial smoothing, or loess.</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_weight">weight</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="extractimf2d_+3A_check">check</code></td>
<td>
<p>specifies whether the sifting process is displayed. If <code>check=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the bidimensional intrinsic mode function from given image
utilizing extrema detection based
on the equivalence relation between neighboring pixels. See Kim et al. (2012) for detalis.
See Kim et al. (2012) for detalis.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>imf</code></td>
<td>
<p>two dimensional IMF</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting the finest IMF from <code>residue</code></p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p>index of maxima</p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p>index of minima</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iteration obtaining the IMF</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Kim, D., Park, M. and Oh, H.-S. (2012) Bidimensional Statistical Empirical Mode Decomposition. <em>IEEE Signal Processing Letters</em>, 
<b>19</b>, 191&ndash;194, doi: 10.1109/LSP.2012.2186566.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrema2dC">extrema2dC</a></code>, <code><a href="#topic+emd2d">emd2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lena)
z &lt;- lena[seq(1, 512, by=4), seq(1, 512, by=4)]

## Not run: 
lenaimf1 &lt;- extractimf2d(z, check=FALSE)
## End(Not run)
</code></pre>

<hr>
<h2 id='extrema'>Finding Local Extrema and Zero-crossings</h2><span id='topic+extrema'></span>

<h3>Description</h3>

<p>This function indentifies extrema and zero-crossings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrema(y, ndata = length(y), ndatam1 = ndata - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrema_+3A_y">y</code></td>
<td>
<p>input signal</p>
</td></tr>
<tr><td><code id="extrema_+3A_ndata">ndata</code></td>
<td>
<p>the number of observation</p>
</td></tr>
<tr><td><code id="extrema_+3A_ndatam1">ndatam1</code></td>
<td>
<p>the number of observation - 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function indentifies extrema and zero-crossings.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>minindex</code></td>
<td>
<p>matrix of time index at which local minima are attained. 
Each row specifies a starting and ending time index of a local minimum</p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p>matrix of time index at which local maxima are attained. 
Each row specifies a starting and ending time index of a local maximum.</p>
</td></tr>
<tr><td><code>nextreme</code></td>
<td>
<p>the number of extrema</p>
</td></tr> 
<tr><td><code>cross</code></td>
<td>
<p>matrix of time index of zero-crossings. 
Each row specifies a starting and ending time index of zero-crossings.</p>
</td></tr> 
<tr><td><code>ncross</code></td>
<td>
<p>the number of zero-crossings</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+extrema2dC">extrema2dC</a></code>, <code><a href="#topic+extractimf">extractimf</a></code>, <code><a href="#topic+emd">emd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(0, 1, 2, 1, -1, 1:4, 5, 6, 0, -4, -6, -5:5, -2:2)
#y &lt;- c(0, 0, 0, 1, -1, 1:4, 4, 4, 0, 0, 0, -5:5, -2:2, 2, 2)
#y &lt;- c(0, 0, 0, 1, -1, 1:4, 4, 4, 0, 0, 0, -5:5, -2:2, 0, 0)

plot(y, type = "b"); abline(h = 0)
extrema(y)
</code></pre>

<hr>
<h2 id='extrema2dC'>Finding Local Extrema</h2><span id='topic+extrema2dC'></span>

<h3>Description</h3>

<p>This function finds the bidimensional local extrema based
on the equivalence relation between neighboring pixels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrema2dC(z, nnrow=nrow(z), nncol=ncol(z))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrema2dC_+3A_z">z</code></td>
<td>
<p>matrix of an input image</p>
</td></tr>
<tr><td><code id="extrema2dC_+3A_nnrow">nnrow</code></td>
<td>
<p>the number of row of an input image</p>
</td></tr>
<tr><td><code id="extrema2dC_+3A_nncol">nncol</code></td>
<td>
<p>the number of column of an input image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the bidimensional local extrema based
on the equivalence relation between neighboring pixels. See Kim et al. (2012) for detalis.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>minindex</code></td>
<td>
<p>index of minima. Each row specifies index of local minimum.</p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p>index of maxima. Each row specifies index of local maximum.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, D., Park, M. and Oh, H.-S. (2012) Bidimensional Statistical Empirical Mode Decomposition. <em>IEEE Signal Processing Letters</em>, 
<b>19</b>, 191&ndash;194, doi: 10.1109/LSP.2012.2186566.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrema">extrema</a></code>, , <code><a href="#topic+extractimf2d">extractimf2d</a></code>, <code><a href="#topic+emd2d">emd2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lena)
z &lt;- lena[seq(1, 512, by=4), seq(1, 512, by=4)]

par(mfrow=c(1,3), mar=c(0, 0.5, 2, 0.5))
image(z, main="Lena", xlab="", ylab="", col=gray(0:100/100), axes=FALSE)    

example &lt;- extrema2dC(z=z)
localmin &lt;- matrix(256, 128, 128)
localmin[example$minindex] &lt;- z[example$minindex]
image(localmin, main="Local minimum", xlab="", ylab="", col=gray(0:100/100), axes=FALSE)

localmax &lt;- matrix(0, 128, 128)
localmax[example$maxindex] &lt;- z[example$maxindex]
image(localmax, main="Local maximum", xlab="", ylab="", col=gray(0:100/100), axes=FALSE)
</code></pre>

<hr>
<h2 id='hilbertspec'>Hilbert Transform and Instantaneous Frequency</h2><span id='topic+hilbertspec'></span>

<h3>Description</h3>

<p>This function calculates the amplitude and instantaneous frequency
using Hilbert transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbertspec(xt, tt=NULL, central=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbertspec_+3A_xt">xt</code></td>
<td>
<p>matrix of multiple signals. Each column represents a signal.</p>
</td></tr>
<tr><td><code id="hilbertspec_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="hilbertspec_+3A_central">central</code></td>
<td>
<p>If central=TRUE, use central difference method to calculate the instantaneous frequency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the amplitude and instantaneous frequency
using Hilbert transform.
</p>


<h3>Value</h3>

<table>
<tr><td><code>amplitude</code></td>
<td>
<p>matrix of amplitudes for multiple signals <code>xt</code></p>
</td></tr>
<tr><td><code>instantfreq</code></td>
<td>
<p>matrix of instantaneous frequencies for multiple signals <code>xt</code></p>
</td></tr>
<tr><td><code>energy</code></td>
<td>
<p>cumulative energy of multiple signals</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Dasios, A., Astin, T. R. and McCann C. (2001) Compressional-wave Q estimation
from full-waveform sonic data. <em>Geophysical Prospecting</em>, <b>49</b>, 353&ndash;373. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectrogram">spectrogram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 0.1, length = 2001)[1:2000]           
f1 &lt;- 1776; f2 &lt;- 1000
xt &lt;- sin(2*pi*f1*tt) * (tt &lt;= 0.033 | tt &gt;= 0.067) + sin(2*pi*f2*tt)
 
### Before treating intermittence
interm1 &lt;- emd(xt, tt, boundary="wave", max.imf=2, plot.imf=FALSE)  
### After treating intermittence
interm2 &lt;- emd(xt, tt, boundary="wave", max.imf=2, plot.imf=FALSE, 
interm=0.0007)

par(mfrow=c(2,1), mar=c(2,2,2,1))
test1 &lt;- hilbertspec(interm1$imf)
spectrogram(test1$amplitude[,1], test1$instantfreq[,1])

test2 &lt;- hilbertspec(interm2$imf, tt=tt)
spectrogram(test2$amplitude[,1], test2$instantfreq[,1])
</code></pre>

<hr>
<h2 id='imageEMD'>Plot of Bidimenasional Empirical Mode Decomposition Result</h2><span id='topic+imageEMD'></span>

<h3>Description</h3>

<p>This function draws plots of input image, IMF's, residue and extrema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageEMD(z = z, emdz, extrema = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageEMD_+3A_z">z</code></td>
<td>
<p>matrix of an image</p>
</td></tr>
<tr><td><code id="imageEMD_+3A_emdz">emdz</code></td>
<td>
<p>decomposition result</p>
</td></tr>
<tr><td><code id="imageEMD_+3A_extrema">extrema</code></td>
<td>
<p>specifies whether the extrma is displayed according to the level of IMF</p>
</td></tr>
<tr><td><code id="imageEMD_+3A_...">...</code></td>
<td>
<p>the usual arguments to the image function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws plots of input image, IMF's, residue and extrema.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lena)
z &lt;- lena[seq(1, 512, by=4), seq(1, 512, by=4)]
image(z, main="Lena", xlab="", ylab="", col=gray(0:100/100), axes=FALSE)

## Not run: 
lenadecom &lt;- emd2d(z, max.imf = 4)
imageEMD(z=z, emdz=lenadecom, extrema=TRUE, col=gray(0:100/100))
## End(Not run)
</code></pre>

<hr>
<h2 id='kospi200'>Korea Stock Price Index 200</h2><span id='topic+kospi200'></span>

<h3>Description</h3>

<p>the weekly KOSPI 200 index from January, 1990 to February, 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kospi200)
</code></pre>


<h3>Format</h3>

<p>A list of date and KOSPI200 index
</p>


<h3>Details</h3>

<p>See Kim and Oh (2009) for the analysis for kospi200 data using EMD.
</p>


<h3>References</h3>

<p>Kim, D. and Oh, H.-S. (2009) A Multi-Resolution Approach to Non-Stationary Financial Time Series Using the Hilbert-Huang Transform.
<em>The Korean Journal of Applied Statistics</em>, <b>22</b>, 499&ndash;513. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kospi200)
names(kospi200)
plot(kospi200$date, kospi200$index, type="l")
</code></pre>

<hr>
<h2 id='lena'>Gray Lena image</h2><span id='topic+lena'></span>

<h3>Description</h3>

<p>A 512x512 gray image of Lena.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lena)
</code></pre>


<h3>Format</h3>

<p>A 512x512 matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lena)
image(lena, col=gray(0:100/100), axes=FALSE)
</code></pre>

<hr>
<h2 id='lennon'>Gray John Lennon image</h2><span id='topic+lennon'></span>

<h3>Description</h3>

<p>A 256x256 gray image of John Lennon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lennon)
</code></pre>


<h3>Format</h3>

<p>A 256x256 matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lennon)
image(lennon, col=gray(100:0/100), axes=FALSE)
</code></pre>

<hr>
<h2 id='semd'>Statistical Empirical Mode Decomposition</h2><span id='topic+semd'></span>

<h3>Description</h3>

<p>This function performs empirical mode decomposition using spline smoothing not interpolation for sifting process.
The smoothing parameter is automatically detemined by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semd(xt, tt=NULL, cv.kfold, cv.tol=0.1^1, cv.maxiter=20, 
    emd.tol=sd(xt)*0.1^2, max.sift=20, stoprule="type1", boundary="periodic", 
    smlevels=1, max.imf=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semd_+3A_xt">xt</code></td>
<td>
<p>observation or signal observed at time <code>tt</code></p>
</td></tr>
<tr><td><code id="semd_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="semd_+3A_cv.kfold">cv.kfold</code></td>
<td>
<p>the number of fold of cross-validation</p>
</td></tr>
<tr><td><code id="semd_+3A_cv.tol">cv.tol</code></td>
<td>
<p>tolerance for cross-validation</p>
</td></tr>
<tr><td><code id="semd_+3A_cv.maxiter">cv.maxiter</code></td>
<td>
<p>maximum iteration for cross-validation</p>
</td></tr>
<tr><td><code id="semd_+3A_emd.tol">emd.tol</code></td>
<td>
<p>tolerance for stopping rule of sifting. If <code>stoprule=type5</code>, the number of iteration for S stoppage criterion.</p>
</td></tr>
<tr><td><code id="semd_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting</p>
</td></tr>
<tr><td><code id="semd_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of envelope mean must be less than the user-specified tolerance level 
in the sense that the local average of upper and lower envelope is zero.
The stopping rules <code>type2</code>, <code>type3</code>, <code>type4</code> and <code>type5</code> are the stopping rules given by equation (5.5) of Huang et al. (1998), equation (11a), 
equation (11b) and S stoppage of Huang and Wu (2008), respectively.</p>
</td></tr> 
<tr><td><code id="semd_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from &ldquo;none&quot;, &ldquo;wave&quot;, &ldquo;symmetric&quot;, &ldquo;periodic&quot; or &ldquo;evenodd&quot;. See Zeng and He (2004) for <code>evenodd</code> boundary condition.</p>
</td></tr>
<tr><td><code id="semd_+3A_smlevels">smlevels</code></td>
<td>
<p>specifies which level of the IMF is obtained by smoothing spline.</p>
</td></tr>
<tr><td><code id="semd_+3A_max.imf">max.imf</code></td>
<td>
<p>the maximum number of IMF's</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs empirical mode decomposition using spline smoothing not interpolation for sifting process.
The smoothing parameter is automatically detemined by cross-validation.
Optimization is done by golden section search. See Kim et al. (2012) for details.
</p>


<h3>Value</h3>

 
<table>
<tr><td><code>imf</code></td>
<td>
<p>IMF's</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting IMF's from observations <code>xt</code></p>
</td></tr>
<tr><td><code>nimf</code></td>
<td>
<p>the number of IMF's</p>
</td></tr> 
<tr><td><code>optlambda</code></td>
<td>
<p>smoothing parameter minimizing prediction errors of cross-validation</p>
</td></tr> 
<tr><td><code>lambdaconv</code></td>
<td>
<p>a sequence of smoothing parameters for searching optimal smoothing papameter</p>
</td></tr> 
<tr><td><code>perr</code></td>
<td>
<p>prediction errors of cross-validation according to <code>lambdaconv</code></p>
</td></tr> 
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Huang, N. E. and Wu, Z. (2008) A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
<em>Reviews of Geophysics</em>, <b>46</b>, RG2006.
</p>
<p>Kim, D., Kim, K.-O. and Oh, H.-S. (2012) Extending the Scope of Empirical Mode Decomposition using Smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012:168</b>, doi: 10.1186/1687-6180-2012-168.
</p>
<p>Zeng, K and He, M.-X. (2004) A simple boundary process technique for empirical mode decomposition.
<em>Proceedings of 2004 IEEE International Geoscience and Remote Sensing Symposium</em>, <b>6</b>, 4258&ndash;4261.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractimf">extractimf</a></code>, <code><a href="#topic+emd">emd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndata &lt;- 2048
tt &lt;- seq(0, 9, length=ndata)                 
xt &lt;- sin(pi * tt) + sin(2* pi * tt) + sin(6 * pi * tt)  + 0.5 * tt 
set.seed(1)
xt &lt;- xt + rnorm(ndata, 0, sd(xt)/5)

## Not run: 
### Empirical Mode Decomposition by Interpolation
emdbyint &lt;- emd(xt, tt, max.imf = 5, boundary = "wave")
### Empirical Mode Decomposition by Smoothing
emdbysm &lt;- semd(xt, tt, cv.kfold=4, boundary="wave", smlevels=1, max.imf=5)

par(mfcol=c(6,2), mar=c(2,2,2,1), oma=c(0,0,2,0))                              
rangext &lt;- range(xt); rangeimf &lt;- rangext - mean(rangext)
plot(tt, xt, xlab="", ylab="", main="signal", ylim=rangext, type="l")
mtext("Decomposition by EMD", side = 3, line = 2, cex=0.85, font=2)
plot(tt, emdbyint$imf[,1], xlab="", ylab="", main="imf 1", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbyint$imf[,2], xlab="", ylab="", main="imf 2", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbyint$imf[,3], xlab="", ylab="", main="imf 3", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbyint$imf[,4], xlab="", ylab="", main="imf 4", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbyint$imf[,5]+emdbyint$residue, xlab="", ylab="", main="remaining signal",
    ylim=rangext, type="l")

plot(tt, xt, xlab="", ylab="", main="signal", ylim=rangext, type="l")
mtext("Decomposition by SEMD", side = 3, line = 2, cex=0.85, font=2)
plot(tt, emdbysm$imf[,1], xlab="", ylab="", main="noise", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbysm$imf[,2], xlab="", ylab="", main="imf 1", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbysm$imf[,3], xlab="", ylab="", main="imf 2", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbysm$imf[,4], xlab="", ylab="", main="imf 3", ylim=rangeimf,  type="l")
abline(h=0, lty=2)
plot(tt, emdbysm$residue, xlab="", ylab="", main="residue", ylim=rangext, type="l")
## End(Not run)
</code></pre>

<hr>
<h2 id='solar'>Solar Irradiance Proxy Data</h2><span id='topic+solar+20irradiance'></span><span id='topic+solar.hs'></span><span id='topic+solar.lean'></span><span id='topic+beryllium'></span>

<h3>Description</h3>

<p>solar irradiance proxy data.
</p>
<p>Hoyt and Schatten (1993) reconstructed solar irradiance (from 1700 through 1997)
using the amplitude of the 11-year solar cycle together with a long term trend estimated
from solar-like stars. They put relatively more weight on the length of the 11-year cycle.
</p>
<p>Lean et al. (1995) reconstructed solar irradiance (from 1610 through 2000)
using the amplitude of the 11-year solar cycle and a long term trend estimated
from solar-like stars.
</p>
<p>10-Beryllium (10Be) is measured in polar ice from 1424 through 1985.
10-Beryllium (10Be) is produced in the atmosphere
by incoming cosmic ray flux, which in turn is influenced by
the solar activity. The higher the solar activity, the lower
the flux of cosmic radiation entering the earth atmosphere
and therefore the lower the production rate of 10Be. The
short atmospheric lifetime of 10Be of one to two years (Beer
et al. 1994) allows the tracking of solar activity changes and
offers an alternative way to the sunspot based techniques for
the analysis of the amplitude and length of the solar cycle
as well as for low frequency variations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(solar.hs)
data(solar.lean)
data(beryllium)
</code></pre>


<h3>Format</h3>

<p>A list of year and solar (solar irradiance proxy data) for solar.hs and solar.lean
A list of year and be (10-Beryllium) for beryllium
</p>


<h3>References</h3>

<p>Beer, J., Baumgartner, S., Dittrich-Hannen, B., Hauenstein, J.,
Kubik, P., Lukasczyk, C., Mende, W., Stellmacher, R. and Suter,
M. (1994) Solar variability traced by cosmogenic isotopes. <em>In:
Pap, J.M., FrQohlich, C., Hudson, H.S., Solanki, S. (Eds.), The
Sun as a Variable Star: Solar and Stellar Irradiance Variations</em>,
Cambridge University Press, Cambridge, 291&ndash;300.
</p>
<p>Beer, J., Mende, W. and Stellmacher, R. (2000) The role of the sun in
climate forcing. <em>Quaternary Science Reviews</em>, <b>19</b>, 403&ndash;415.
</p>
<p>Hoyt, D. V and, Schatten, K. H. (1993) A discussion of plausible
solar irradiance variations, 1700&ndash;1992. <em>Journal of Geophysical
Research</em>, <b>98 (A11)</b>, 18,895&ndash;18,906.
</p>
<p>Lean, J. L., Beer, J. and Bradley, R. S. (1995) Reconstruction of
solar irradiance since 1610: Implications for climate change.
<em>Geophysical Research Letters</em>, <b>22 (23)</b>, 3195&ndash;3198.
</p>
<p>Oh, H-S, Ammann, C. M., Naveau, P., Nychka, D. and Otto-Bliesner, B. L. 
(2003) Multi-resolution time series analysis applied to solar irradiance
and climate reconstructions. 
<em>Journal of Atmospheric and Solar-Terrestrial Physics</em>, <b>65</b>, 191&ndash;201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(solar.hs)
names(solar.hs)
plot(solar.hs$year, solar.hs$solar, type="l")

data(solar.lean)
names(solar.lean)
plot(solar.lean$year, solar.lean$solar, type="l")

data(beryllium)
names(beryllium)
plot(beryllium$year, beryllium$be, type="l")
</code></pre>

<hr>
<h2 id='spectrogram'>Spectrogram</h2><span id='topic+spectrogram'></span>

<h3>Description</h3>

<p>This function produces image of amplitude by time index and
instantaneous frequency. The horizontal axis represents time, the vertical axis is
instantaneous frequency,
and the color of each point in the image represents amplitude
of a particular frequency at a particular time. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrogram(amplitude, freq, tt = NULL, multi = FALSE, 
nlevel = NULL, size = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrogram_+3A_amplitude">amplitude</code></td>
<td>
<p>vector or matrix of amplitudes for multiple signals</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_freq">freq</code></td>
<td>
<p>vector or matrix of instantaneous frequencies for multiple signals</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_tt">tt</code></td>
<td>
<p>observation index or time index</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_multi">multi</code></td>
<td>
<p>specifies whether spectrograms of multiple signals are separated or not.</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_nlevel">nlevel</code></td>
<td>
<p>the number of color levels used in legend strip</p>
</td></tr>
<tr><td><code id="spectrogram_+3A_size">size</code></td>
<td>
<p>vector of image size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces image of amplitude by time index and
instantaneous frequency. The horizontal axis represents time, the vertical axis is
instantaneous frequency,
and the color of each point in the image represents amplitude
of a particular frequency at a particular time. 
</p>


<h3>Value</h3>

<p>image
</p>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hilbertspec">hilbertspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 0.1, length = 2001)[1:2000]           
f1 &lt;- 1776; f2 &lt;- 1000
xt &lt;- sin(2*pi*f1*tt) * (tt &lt;= 0.033 | tt &gt;= 0.067) + sin(2*pi*f2*tt)
 
### Before treating intermittence
interm1 &lt;- emd(xt, tt, boundary="wave", max.imf=2, plot.imf=FALSE)  
### After treating intermittence
interm2 &lt;- emd(xt, tt, boundary="wave", max.imf=2, plot.imf=FALSE, 
interm=0.0007)

par(mfrow=c(2,1), mar=c(2,2,2,1))
test1 &lt;- hilbertspec(interm1$imf)
spectrogram(test1$amplitude[,1], test1$instantfreq[,1])

test2 &lt;- hilbertspec(interm2$imf, tt=tt)
spectrogram(test2$amplitude[,1], test2$instantfreq[,1])
</code></pre>

<hr>
<h2 id='sunspot'>Sunspot Data</h2><span id='topic+sunspot'></span>

<h3>Description</h3>

<p>sunspot from 1610 through 1995. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sunspot)
</code></pre>


<h3>Format</h3>

<p>A list of year and sunspot 
</p>


<h3>References</h3>

<p>Oh, H-S, Ammann, C. M., Naveau, P., Nychka, D. and Otto-Bliesner, B. L. 
(2003) Multi-resolution time series analysis applied to solar irradiance
and climate reconstructions. 
<em>Journal of Atmospheric and Solar-Terrestrial Physics</em>, <b>65</b>, 191&ndash;201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sunspot)
names(sunspot)
plot(sunspot$year, sunspot$sunspot, type="l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
