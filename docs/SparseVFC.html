<!DOCTYPE html><html><head><title>Help for package SparseVFC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseVFC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#church'><p>The Church Photos</p></a></li>
<li><a href='#norm_vecs'><p>Normalize (a matrix of) vectors</p></a></li>
<li><a href='#predict.VFC'><p>Predict method for VFC fits</p></a></li>
<li><a href='#SparseVFC'><p>Sparse Vector Field Consensus</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Vector Field Consensus for Vector Field Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Sciurus365/SparseVFC">https://github.com/Sciurus365/SparseVFC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sciurus365/SparseVFC/issues">https://github.com/Sciurus365/SparseVFC/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>The sparse vector field consensus 
		(SparseVFC) algorithm (Ma et al., 2013 &lt;<a href="https://doi.org/10.1016%2Fj.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>&gt;) for robust vector 
		field learning. Largely translated from the Matlab functions in <a href="https://github.com/jiayi-ma/VFC">https://github.com/jiayi-ma/VFC</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>pdist, purrr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, dplyr, tibble, rmarkdown, grid, knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-09 15:20:45 UTC; jingm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingmeng Cui <a href="https://orcid.org/0000-0003-3421-8457"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingmeng Cui &lt;jingmeng.cui@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 17:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='church'>The Church Photos</h2><span id='topic+church'></span>

<h3>Description</h3>

<p>A dataset containing the vectors for the church photos.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>church
</code></pre>


<h3>Format</h3>

<p>A list with three components:
</p>

<dl>
<dt>X</dt><dd><p>The position of points in the first photo.</p>
</dd>
<dt>Y</dt><dd><p>The position of points in the second photo.</p>
</dd>
<dt>CorrectIndex</dt><dd><p>The indices for the correct point pairs.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/jiayi-ma/VFC">https://github.com/jiayi-ma/VFC</a>
</p>


<h3>References</h3>

<p>Ma et al. (2013) <a href="https://doi.org/10.1016/j.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>;
Zhao et al. (2011) <a href="https://doi.org/10.1109/CVPR.2011.5995336">doi:10.1109/CVPR.2011.5995336</a>
</p>

<hr>
<h2 id='norm_vecs'>Normalize (a matrix of) vectors</h2><span id='topic+norm_vecs'></span>

<h3>Description</h3>

<p>Normalize the data so that the mean of the vectors is <strong>0</strong> and the variance of the vectors is 1. Here the variance of vectors is calculated by interpreting the deviation as the Euclidean distance, which means the trace of the (population) covariance matrix is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_vecs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_vecs_+3A_x">x</code></td>
<td>
<p>The matrix to be normalized. Each row of <code>x</code> represent a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized matrix with two attributions <code>scale</code> and <code>mean</code>, which are used for normalization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_vecs(matrix(seq(1, 100), ncol = 2))
</code></pre>

<hr>
<h2 id='predict.VFC'>Predict method for VFC fits</h2><span id='topic+predict.VFC'></span>

<h3>Description</h3>

<p>Predicted values based on <code>VFC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VFC'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.VFC_+3A_object">object</code></td>
<td>
<p>A <code>VFC</code> object generated by <code><a href="#topic+SparseVFC">SparseVFC()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.VFC_+3A_newdata">newdata</code></td>
<td>
<p>A vector specifying the position.</p>
</td></tr>
<tr><td><code id="predict.VFC_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SparseVFC">SparseVFC()</a></code>
</p>

<hr>
<h2 id='SparseVFC'>Sparse Vector Field Consensus</h2><span id='topic+SparseVFC'></span>

<h3>Description</h3>

<p>The main function for the SparseVFC algorithm.
See <code>References</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseVFC(
  X,
  Y,
  M = 16,
  MaxIter = 500,
  gamma = 0.9,
  beta = 0.1,
  lambda = 3,
  theta = 0.75,
  a = 10,
  ecr = 1e-05,
  minP = 1e-05,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseVFC_+3A_x">X</code></td>
<td>
<p>The position of the vectors.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_y">Y</code></td>
<td>
<p>The value of the vectors.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_m">M</code></td>
<td>
<p>The number of the basis functions used for sparse approximation. Default value is 16.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_maxiter">MaxIter</code></td>
<td>
<p>Maximum iteration times. Default value is 500.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_gamma">gamma</code></td>
<td>
<p>Percentage of inliers in the samples. This is an initial value for EM iteration, and it is not important. Default value is 0.9.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_beta">beta</code></td>
<td>
<p>Parameter of Gaussian Kernel, <code class="reqn">k(x, y) = exp(-beta*||x-y||^2)</code>. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_lambda">lambda</code></td>
<td>
<p>Represents the trade-off between the goodness of data fit and smoothness of the field. Default value is 3.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_theta">theta</code></td>
<td>
<p>If the posterior probability of a sample being an inlier is larger than theta, then it will be regarded as an inlier. Default value is 0.75.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_a">a</code></td>
<td>
<p>Parameter of the uniform distribution. We assume that the outliers obey a uniform distribution <code class="reqn">1/a</code>. Default Value is 10.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_ecr">ecr</code></td>
<td>
<p>The minimum limitation of the energy change rate in the iteration process. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_minp">minP</code></td>
<td>
<p>The posterior probability Matrix P may be singular for matrix inversion. We set the minimum value of P as <code>minP</code>. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="SparseVFC_+3A_silent">silent</code></td>
<td>
<p>Should the messages be suppressed? Default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>VFC</code> object, which is a list containing the following elements:
</p>

<dl>
<dt>X</dt><dd><p>A matrix of the positions of kernels.</p>
</dd>
<dt>Y</dt><dd><p>A matrix of the input vectors.</p>
</dd>
<dt>beta</dt><dd><p>The input value of <code>beta</code>.</p>
</dd>
<dt>V</dt><dd><p>A matrix of the estimated vectors.</p>
</dd>
<dt>C</dt><dd><p>A matrix of the coefficients of each kernel.</p>
</dd>
<dt>P</dt><dd><p>A vector of the posterior probability of the input vectors (<code>Y</code>) being an inlier.</p>
</dd>
<dt>VFCIndex</dt><dd><p>A vector of indices of the inliers.</p>
</dd>
<dt>sigma2</dt><dd><p>The <code class="reqn">\sigma^2</code> of the estimations weighted by <code>P</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>The algorithm is described in Ma et al. (2013) <a href="https://doi.org/10.1016/j.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>.
This function is translated with permission from Jiayi Ma's Matlab function at <a href="https://github.com/jiayi-ma/VFC">https://github.com/jiayi-ma/VFC</a>.
Also see Zhao et al. (2011) <a href="https://doi.org/10.1109/CVPR.2011.5995336">doi:10.1109/CVPR.2011.5995336</a> for the earlier VFC algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(church)
set.seed(1614)
VecFld &lt;- SparseVFC(norm_vecs(church$X), norm_vecs(church$Y) - norm_vecs(church$X))
predict(VecFld, c(0, 0))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
