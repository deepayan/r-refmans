<!DOCTYPE html><html><head><title>Help for package PeakSegOptimal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PeakSegOptimal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#H3K4me3_PGP_immune_chunk24'>
<p>H3K4me3_PGP_immune ChIP-seq data set chunk 24</p></a></li>
<li><a href='#H3K4me3_XJ_immune_chunk1'>
<p>H3K4me3_XJ_immune chunk 1</p></a></li>
<li><a href='#oracleModelComplexity'><p>oracleModelComplexity</p></a></li>
<li><a href='#PeakSegFPOP'><p>PeakSegFPOP</p></a></li>
<li><a href='#PeakSegFPOPchrom'><p>PeakSegFPOPchrom</p></a></li>
<li><a href='#PeakSegPDPA'><p>PeakSegPDPA</p></a></li>
<li><a href='#PeakSegPDPAchrom'><p>PeakSegPDPAchrom</p></a></li>
<li><a href='#PeakSegPDPAInf'><p>PeakSegPDPAInf</p></a></li>
<li><a href='#PoissonLoss'><p>PoissonLoss</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Dylan Hocking</td>
</tr>
<tr>
<td>Version:</td>
<td>2024.1.24</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tdhock/PeakSegOptimal">https://github.com/tdhock/PeakSegOptimal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdhock/PeakSegOptimal/issues">https://github.com/tdhock/PeakSegOptimal/issues</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Segmentation Subject to Up-Down Constraints</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes optimal changepoint models using the
 Poisson likelihood for non-negative count data,
 subject to the PeakSeg constraint:
 the first change must be up, second change down, third change up, etc.
 For more info about the models and algorithms,
 read "A log-linear time algorithm for constrained changepoint detection"
 &lt;<a href="https://arxiv.org/abs/1703.03352">arXiv:1703.03352</a>&gt; by TD Hocking et al.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>penaltyLearning</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PeakSegDP (&ge; 2016.08.06), ggplot2, testthat, data.table (&ge;
1.9.8)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 18:49:16 UTC; th798</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='H3K4me3_PGP_immune_chunk24'>
H3K4me3_PGP_immune ChIP-seq data set chunk 24
</h2><span id='topic+H3K4me3_PGP_immune_chunk24'></span>

<h3>Description</h3>

<p>This data set revealed a bug in the PeakSegPDPA solver: at one point
it recovered a less likely model than PeakSegDP for McGill0091, 13 segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("H3K4me3_PGP_immune_chunk24")</code></pre>


<h3>Format</h3>

<p>A data frame with 66713 observations on the following 5 variables.
</p>


<h3>Source</h3>

<p>http://cbio.mines-paristech.fr/~thocking/chip-seq-chunk-db/
</p>

<hr>
<h2 id='H3K4me3_XJ_immune_chunk1'>
H3K4me3_XJ_immune chunk 1
</h2><span id='topic+H3K4me3_XJ_immune_chunk1'></span>

<h3>Description</h3>

<p>Some test data sets for the Poisson PeakSeg Segment Neighborhood Algo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("H3K4me3_XJ_immune_chunk1")</code></pre>


<h3>Format</h3>

<p>A data frame with 18027 observations on 5 variables: cell.type,
sample.id, chromStart, chromEnd, coverage. 
</p>

<hr>
<h2 id='oracleModelComplexity'>oracleModelComplexity</h2><span id='topic+oracleModelComplexity'></span>

<h3>Description</h3>

<p>Compute Oracle model complexity from paper of Cleynen et al.</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracleModelComplexity(bases, 
    segments)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracleModelComplexity_+3A_bases">bases</code></td>
<td>
<p>bases </p>
</td></tr>
<tr><td><code id="oracleModelComplexity_+3A_segments">segments</code></td>
<td>
<p>segments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of model complexity values.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='PeakSegFPOP'>PeakSegFPOP</h2><span id='topic+PeakSegFPOP'></span>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. For N data points, the functional pruning
algorithm is O(N log N) time and memory. It recovers the exact
solution to the following optimization problem. Let Z be an
N-vector of count data (<code>count.vec</code>, non-negative integers), let W
be an N-vector of positive weights (<code>weight.vec</code>), and let <code>penalty</code>
be a non-negative real number. Find the N-vector M of real numbers
(segment means) and (N-1)-vector C of change-point indicators in
<code class="reqn">\{-1,0,1\}</code> which minimize the penalized Poisson Loss,
<code class="reqn">\text{penalty}*\sum_{i=1}^{N_1} I(c_i=1) + \sum_{i=1}^N w_i*[m_i-z_i*\log(m_i)]</code>, subject to constraints: (1) the first
change is up and the next change is down, etc (<code class="reqn">\sum_{i=1}^t c_i \in \{0,1\} \forall t&lt;N-1</code>), and (2) the last change is down
<code class="reqn">0=\sum_{i=1}^{N-1}c_i</code>, and (3) Every zero-valued change-point
variable has an equal segment mean after: <code class="reqn">c_i=0</code> implies
<code class="reqn">m_i=m_{i+1}</code>, (4) every positive-valued change-point variable may
have an up change after: <code class="reqn">c_i=1</code> implies <code class="reqn">m_i&lt;=m_{i+1}</code>, (5) every
negative-valued change-point variable may have a down change
after: <code class="reqn">c_i=-1</code> implies <code class="reqn">m_i&gt;=m_{i+1}</code>. Note that when the equality
constraints are active for non-zero change-point variables, the
recovered model is not feasible for the strict inequality
constraints of the PeakSeg problem, and the optimum of the PeakSeg
problem is undefined.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOP(count.vec, 
    weight.vec = rep(1, 
        length(count.vec)), 
    penalty = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOP_+3A_count.vec">count.vec</code></td>
<td>
<p>integer vector of length &gt;= 3: non-negative count data to segment.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_+3A_weight.vec">weight.vec</code></td>
<td>
<p>numeric vector (same length as <code>count.vec</code>) of positive weights.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_+3A_penalty">penalty</code></td>
<td>
<p>non-negative numeric scalar: <code>penalty</code> parameter (smaller for more
peaks, larger for fewer peaks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of model parameters. <code>count.vec</code>, <code>weight.vec</code>, n.data, <code>penalty</code>
(input parameters), cost.mat (optimal Poisson loss), ends.vec
(optimal position of segment ends, 1-indexed), mean.vec (optimal
segment means), intervals.mat (number of intervals stored by the
functional pruning algorithm). To recover the solution in terms of
(M,C) variables, see the example.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the algo to compute the solution list.
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
n.data.vec &lt;- sapply(by.sample, nrow)
one &lt;- by.sample[[1]]
count.vec &lt;- one$coverage
weight.vec &lt;- with(one, chromEnd-chromStart)
penalty &lt;- 1000
fit &lt;- PeakSegFPOP(count.vec, weight.vec, penalty)

## Recover the solution in terms of (M,C) variables.
change.vec &lt;- with(fit, rev(ends.vec[ends.vec&gt;0]))
change.sign.vec &lt;- rep(c(1, -1), length(change.vec)/2)
end.vec &lt;- c(change.vec, fit$n.data)
start.vec &lt;- c(1, change.vec+1)
length.vec &lt;- end.vec-start.vec+1
mean.vec &lt;- rev(fit$mean.vec[1:(length(change.vec)+1)])
M.vec &lt;- rep(mean.vec, length.vec)
C.vec &lt;- rep(0, fit$n.data-1)
C.vec[change.vec] &lt;- change.sign.vec
diff.vec &lt;- diff(M.vec)
data.frame(
  change=c(C.vec, NA),
  mean=M.vec,
  equality.constraint.active=c(sign(diff.vec) != C.vec, NA))
stopifnot(cumsum(sign(C.vec)) %in% c(0, 1))

## Compute penalized Poisson loss of M.vec and compare to the value reported
## in the fit solution list.
n.peaks &lt;- sum(C.vec==1)
rbind(
  n.peaks*penalty + PoissonLoss(count.vec, M.vec, weight.vec),
  fit$cost.mat[2, fit$n.data])

## Plot the number of intervals stored by the algorithm.
FPOP.intervals &lt;- data.frame(
  label=ifelse(as.numeric(row(fit$intervals.mat))==1, "up", "down"),
  data=as.numeric(col(fit$intervals.mat)),
  intervals=as.numeric(fit$intervals.mat))
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(label ~ .)+
  geom_line(aes(data, intervals), data=FPOP.intervals)+
  scale_y_continuous(
    "intervals stored by the\nconstrained optimal segmentation algorithm")

</code></pre>

<hr>
<h2 id='PeakSegFPOPchrom'>PeakSegFPOPchrom</h2><span id='topic+PeakSegFPOPchrom'></span>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. This function is a user-friendly interface to
the <code><a href="#topic+PeakSegFPOP">PeakSegFPOP</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOPchrom(count.df, 
    penalty = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOPchrom_+3A_count.df">count.df</code></td>
<td>
<p>data.frame with columns count, chromStart, chromEnd.</p>
</td></tr>
<tr><td><code id="PeakSegFPOPchrom_+3A_penalty">penalty</code></td>
<td>
<p>non-negative numeric scalar: <code>penalty</code> parameter (smaller for more
peaks, larger for fewer peaks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data.frames: segments can be used for plotting the
segmentation model, loss summarizes the penalized <code><a href="#topic+PoissonLoss">PoissonLoss</a></code> and
feasibilty of the computed model.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
sample.id &lt;- "McGill0106"
H3K4me3_XJ_immune_chunk1$count &lt;- H3K4me3_XJ_immune_chunk1$coverage
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
one.sample &lt;- by.sample[[sample.id]]

penalty.constant &lt;- 3000
fpop.fit &lt;- PeakSegFPOPchrom(one.sample, penalty.constant)
fpop.breaks &lt;- subset(fpop.fit$segments, 1 &lt; first)
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  geom_step(aes(chromStart/1e3, coverage),
            data=one.sample, color="grey")+
  geom_segment(aes(chromStart/1e3, mean,
                   xend=chromEnd/1e3, yend=mean),
               color="green",
               data=fpop.fit$segments)+
  geom_vline(aes(xintercept=chromStart/1e3),
             color="green",
             linetype="dashed",
             data=fpop.breaks)

max.peaks &lt;- as.integer(fpop.fit$segments$peaks[1]+1)
pdpa.fit &lt;- PeakSegPDPAchrom(one.sample, max.peaks)
models &lt;- pdpa.fit$modelSelection.decreasing
models$PoissonLoss &lt;- pdpa.fit$loss[paste(models$peaks), "PoissonLoss"]
models$algorithm &lt;- "PDPA"
fpop.fit$loss$algorithm &lt;- "FPOP"
ggplot()+
  geom_abline(aes(slope=peaks, intercept=PoissonLoss, color=peaks),
              data=pdpa.fit$loss)+
  geom_label(aes(0, PoissonLoss, color=peaks,
                 label=paste0("s=", peaks, " ")),
            hjust=1,
            vjust=0,
            data=pdpa.fit$loss)+
  geom_point(aes(penalty.constant, penalized.loss, fill=algorithm),
             shape=21,
             data=fpop.fit$loss)+
  geom_point(aes(min.lambda, min.lambda*peaks + PoissonLoss,
                 fill=algorithm),
             shape=21,
             data=models)+
  xlab("penalty = lambda")+
  ylab("penalized loss = PoissonLoss_s + lambda * s")

</code></pre>

<hr>
<h2 id='PeakSegPDPA'>PeakSegPDPA</h2><span id='topic+PeakSegPDPA'></span>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. For N data points and S segments, the
functional pruning algorithm is O(S*NlogN) space and O(S*NlogN)
time. It recovers the exact solution to the following optimization
problem. Let Z be an N-vector of count data (<code>count.vec</code>,
non-negative integers) and let W be an N-vector of positive
weights (<code>weight.vec</code>). Find the N-vector M of real numbers (segment
means) and (N-1)-vector C of change-point indicators in <code class="reqn">\{-1,0,1\}</code>
which minimize the Poisson Loss,
<code class="reqn">\sum_{i=1}^N w_i*[m_i-z_i*\log(m_i)]</code>,
subject to constraints:
(1) there are exactly S-1 non-zero elements of C, and
(2) the first change is up and the next change is down, etc
(<code class="reqn">\sum_{i=1}^t c_i in \{0,1\} \forall t&lt;N</code>), and
(3) Every zero-valued change-point variable has an equal
segment mean after: <code class="reqn">c_i=0</code> implies <code class="reqn">m_i=m_{i+1}</code>,
(4) every positive-valued change-point variable may have an up change after:
<code class="reqn">c_i=1</code> implies <code class="reqn">m_i&lt;=m_{i+1}</code>,
(5) every negative-valued change-point
variable may have a down change after:
<code class="reqn">c_i=-1</code> implies <code class="reqn">m_i&gt;=m_{i+1}</code>.
Note that when the equality constraints are active
for non-zero change-point variables, the recovered model is not
feasible for the strict inequality constraints of the PeakSeg
problem, and the optimum of the PeakSeg problem is undefined.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegPDPA(count.vec, 
    weight.vec = rep(1, 
        length(count.vec)), 
    max.segments = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegPDPA_+3A_count.vec">count.vec</code></td>
<td>
<p>integer vector of count data.</p>
</td></tr>
<tr><td><code id="PeakSegPDPA_+3A_weight.vec">weight.vec</code></td>
<td>
<p>numeric vector (same length as <code>count.vec</code>) of positive weights.</p>
</td></tr>
<tr><td><code id="PeakSegPDPA_+3A_max.segments">max.segments</code></td>
<td>
<p>integer of length 1: maximum number of segments (must be &gt;= 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of model parameters. <code>count.vec</code>, <code>weight.vec</code>, n.data,
<code>max.segments</code> (input parameters), cost.mat (optimal Poisson loss),
ends.mat (optimal position of segment ends, 1-indexed), mean.mat
(optimal segment means), intervals.mat (number of intervals stored
by the functional pruning algorithm). To recover the solution in
terms of (M,C) variables, see the example.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the algo to compute the solution list.
data("H3K4me3_XJ_immune_chunk1", envir=environment())
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
n.data.vec &lt;- sapply(by.sample, nrow)
one &lt;- by.sample[[1]]
count.vec &lt;- one$coverage
weight.vec &lt;- with(one, chromEnd-chromStart)
max.segments &lt;- 19L
fit &lt;- PeakSegPDPA(count.vec, weight.vec, max.segments)

## Recover the solution in terms of (M,C) variables.
n.segs &lt;- 11L
change.vec &lt;- fit$ends.mat[n.segs, 2:n.segs]
change.sign.vec &lt;- rep(c(1, -1), length(change.vec)/2)
end.vec &lt;- c(change.vec, fit$n.data)
start.vec &lt;- c(1, change.vec+1)
length.vec &lt;- end.vec-start.vec+1
mean.vec &lt;- fit$mean.mat[n.segs, 1:n.segs]
M.vec &lt;- rep(mean.vec, length.vec)
C.vec &lt;- rep(0, fit$n.data-1)
C.vec[change.vec] &lt;- change.sign.vec
diff.vec &lt;- diff(M.vec)
data.frame(
  change=c(C.vec, NA),
  mean=M.vec,
  equality.constraint.active=c(sign(diff.vec) != C.vec, NA))
stopifnot(cumsum(sign(C.vec)) %in% c(0, 1))

## Compute Poisson loss of M.vec and compare to the value reported
## in the fit solution list.
rbind(
  PoissonLoss(count.vec, M.vec, weight.vec),
  fit$cost.mat[n.segs, fit$n.data])

## Plot the number of intervals stored by the algorithm.
PDPA.intervals &lt;- data.frame(
  segments=as.numeric(row(fit$intervals.mat)),
  data=as.numeric(col(fit$intervals.mat)),
  intervals=as.numeric(fit$intervals.mat))
some.intervals &lt;- subset(PDPA.intervals, segments&lt;data &amp; 1&lt;segments)
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(segments ~ .)+
  geom_line(aes(data, intervals), data=some.intervals)+
  scale_y_continuous(
    "intervals stored by the\nconstrained optimal segmentation algorithm",
    breaks=c(20, 40))

</code></pre>

<hr>
<h2 id='PeakSegPDPAchrom'>PeakSegPDPAchrom</h2><span id='topic+PeakSegPDPAchrom'></span>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. This function is a user-friendly interface to
the <code><a href="#topic+PeakSegPDPA">PeakSegPDPA</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegPDPAchrom(count.df, 
    max.peaks = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegPDPAchrom_+3A_count.df">count.df</code></td>
<td>
<p>data.frame with columns count, chromStart, chromEnd.</p>
</td></tr>
<tr><td><code id="PeakSegPDPAchrom_+3A_max.peaks">max.peaks</code></td>
<td>
<p>integer &gt; 0: maximum number of peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data.frames: segments can be used for plotting the
segmentation model, loss describes model loss and feasibility,
modelSelection.feasible describes the set of all linear penalty
(lambda) values which can be used to select the feasible models,
modelSelection.decreasing selects from all models that decrease
the Poisson loss relative to simpler models (same as <code><a href="#topic+PeakSegFPOP">PeakSegFPOP</a></code>).</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## samples for which pdpa recovers a more likely model, but it is
## not feasible for the PeakSeg problem (some segment means are
## equal).
sample.id &lt;- "McGill0322"
sample.id &lt;- "McGill0079"
sample.id &lt;- "McGill0106"
n.peaks &lt;- 3
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
H3K4me3_XJ_immune_chunk1$count &lt;- H3K4me3_XJ_immune_chunk1$coverage
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
one.sample &lt;- by.sample[[sample.id]]
pdpa.fit &lt;- PeakSegPDPAchrom(one.sample, 9L)
pdpa.segs &lt;- subset(pdpa.fit$segments, n.peaks == peaks)
both.segs.list &lt;- list(pdpa=data.frame(pdpa.segs, algorithm="PDPA"))
pdpa.breaks &lt;- subset(pdpa.segs, 1 &lt; first)
pdpa.breaks$feasible &lt;- ifelse(
  diff(pdpa.segs$mean)==0, "infeasible", "feasible")
both.breaks.list &lt;- list(pdpa=data.frame(pdpa.breaks, algorithm="PDPA"))
if(require(PeakSegDP)){
  dp.fit &lt;- PeakSegDP(one.sample, 9L)
  dp.segs &lt;- subset(dp.fit$segments, n.peaks == peaks)
  dp.breaks &lt;- subset(dp.segs, 1 &lt; first)
  dp.breaks$feasible &lt;- "feasible"
  both.segs.list$dp &lt;- data.frame(dp.segs, algorithm="cDPA")
  both.breaks.list$dp &lt;- data.frame(dp.breaks, algorithm="cDPA")
}
both.segs &lt;- do.call(rbind, both.segs.list)
both.breaks &lt;- do.call(rbind, both.breaks.list)
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(algorithm ~ ., scales="free")+
  geom_step(aes(chromStart/1e3, coverage),
            data=one.sample, color="grey")+
  geom_segment(aes(chromStart/1e3, mean,
                   xend=chromEnd/1e3, yend=mean),
               color="green",
               data=both.segs)+
  scale_linetype_manual(values=c(feasible="dotted", infeasible="solid"))+
  geom_vline(aes(xintercept=chromStart/1e3, linetype=feasible),
             color="green",
             data=both.breaks)

## samples for which pdpa recovers some feasible models that the
## heuristic dp does not.
sample.id.vec &lt;- c(
  "McGill0091", "McGill0107", "McGill0095",
  "McGill0059", "McGill0029", "McGill0010")
sample.id &lt;- sample.id.vec[4]
one.sample &lt;- by.sample[[sample.id]]
pdpa.fit &lt;- PeakSegPDPAchrom(one.sample, 9L)
gg.loss &lt;- ggplot()+
  scale_color_manual(values=c("TRUE"="black", "FALSE"="red"))+
  scale_size_manual(values=c(cDPA=1.5, PDPA=3))+
  scale_fill_manual(values=c(cDPA="white", PDPA="black"))+
  guides(color=guide_legend(override.aes=list(fill="black")))+
  geom_point(aes(peaks, PoissonLoss,
                 size=algorithm, fill=algorithm, color=feasible),
             shape=21,
             data=data.frame(pdpa.fit$loss, algorithm="PDPA"))
if(require(PeakSegDP)){
  dp.fit &lt;- PeakSegDP(one.sample, 9L)
  gg.loss &lt;- gg.loss+
    geom_point(aes(peaks, error,
                   size=algorithm, fill=algorithm),
               shape=21,
               data=data.frame(dp.fit$error, algorithm="cDPA"))
}
gg.loss

diff.df &lt;- data.frame(
  PeakSegPDPA.loss=pdpa.fit$loss$PoissonLoss,
  PeakSegDP.loss=dp.fit$error$error,
  peaks=dp.fit$error$peaks)
ggplot()+
  geom_point(aes(peaks, PeakSegDP.loss - PeakSegPDPA.loss), data=diff.df)

</code></pre>

<hr>
<h2 id='PeakSegPDPAInf'>PeakSegPDPAInf</h2><span id='topic+PeakSegPDPAInf'></span>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. This function is an interface to the C++ code
which always uses -Inf for the first interval's lower limit and
Inf for the last interval's upper limit &ndash; it is for testing the
number of intervals between the two implementations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegPDPAInf(count.vec, 
    weight.vec = rep(1, 
        length(count.vec)), 
    max.segments = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegPDPAInf_+3A_count.vec">count.vec</code></td>
<td>
<p>integer vector of count data.</p>
</td></tr>
<tr><td><code id="PeakSegPDPAInf_+3A_weight.vec">weight.vec</code></td>
<td>
<p>numeric vector (same length as <code>count.vec</code>) of positive weights.</p>
</td></tr>
<tr><td><code id="PeakSegPDPAInf_+3A_max.segments">max.segments</code></td>
<td>
<p>integer of length 1: maximum number of segments (must be &gt;= 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of model parameters. <code>count.vec</code>, <code>weight.vec</code>, n.data,
<code>max.segments</code> (input parameters), cost.mat (optimal Poisson loss),
ends.mat (optimal position of segment ends, 1-indexed), mean.mat
(optimal segment means), intervals.mat (number of intervals stored
by the functional pruning algorithm). To recover the solution in
terms of (M,C) variables, see the example.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the algo to compute the solution list.
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
n.data.vec &lt;- sapply(by.sample, nrow)
one &lt;- by.sample[[1]]
count.vec &lt;- one$coverage
weight.vec &lt;- with(one, chromEnd-chromStart)
max.segments &lt;- 19L

library(data.table)
ic.list &lt;- list()
for(fun.name in c("PeakSegPDPA", "PeakSegPDPAInf")){
  fun &lt;- get(fun.name)
  fit &lt;- fun(count.vec, weight.vec, max.segments)
  ic.list[[fun.name]] &lt;- data.table(
    fun.name,
    segments=as.numeric(row(fit$intervals.mat)),
    data=as.numeric(col(fit$intervals.mat)),
    cost=as.numeric(fit$cost.mat),
    intervals=as.numeric(fit$intervals.mat))
}
ic &lt;- do.call(rbind, ic.list)[0 &lt; intervals]
intervals &lt;- dcast(ic, data + segments ~ fun.name, value.var="intervals")
cost &lt;- dcast(ic, data + segments ~ fun.name, value.var="cost")
not.equal &lt;- cost[PeakSegPDPA != PeakSegPDPAInf]
stopifnot(nrow(not.equal)==0)

intervals[, increase := PeakSegPDPAInf-PeakSegPDPA]
table(intervals$increase)
quantile(intervals$increase)
ic[, list(
  mean=mean(intervals),
  max=max(intervals)
  ), by=list(fun.name)]

</code></pre>

<hr>
<h2 id='PoissonLoss'>PoissonLoss</h2><span id='topic+PoissonLoss'></span>

<h3>Description</h3>

<p>Compute the weighted Poisson loss function, which is <code>seg.mean</code> -
<code>count</code> * log(<code>seg.mean</code>). The edge case is when the mean is zero, in
which case the probability mass function takes a value of 1 when
the data is 0 (and 0 otherwise). Thus the log-likelihood of a
maximum likelihood segment with mean zero must be zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonLoss(count, seg.mean, 
    weight = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonLoss_+3A_count">count</code></td>
<td>
<p>count </p>
</td></tr>
<tr><td><code id="PoissonLoss_+3A_seg.mean">seg.mean</code></td>
<td>
<p>seg.mean </p>
</td></tr>
<tr><td><code id="PoissonLoss_+3A_weight">weight</code></td>
<td>
<p>weight </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>PoissonLoss(1, 1)
PoissonLoss(0, 0)
PoissonLoss(1, 0)
PoissonLoss(0, 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
