<!DOCTYPE html><html lang="en"><head><title>Help for package moonboot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {moonboot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distPower'><p>Ditribution with a Power Law</p></a></li>
<li><a href='#estimate.m'><p>Estimating a Subsample Size m</p></a></li>
<li><a href='#estimate.tau'><p>Estimating the convergence rate</p></a></li>
<li><a href='#mboot'><p>m-Out-of-n Bootstrap Implementation</p></a></li>
<li><a href='#mboot.ci'><p>m-Out-of-n Bootstrap Confidence Intervals</p></a></li>
<li><a href='#shorth'><p>Mean of the Shorthest Half</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>m-Out-of-n Bootstrap Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-21</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Functions and examples based on the m-out-of-n bootstrap suggested by
  Politis, D.N. and Romano, J.P. (1994) &lt;<a href="https://doi.org/10.1214%2Faos%2F1176325770">doi:10.1214/aos/1176325770</a>&gt;.
  Additionally there are functions to estimate the scaling factor tau
  and the subsampling size m. For a detailed description and a full list
  of references, see Dalitz, C. and Lögler, F. (2024)
  &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.05032">doi:10.48550/arXiv.2412.05032</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD 2-clause License</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods (&ge; 3.5.0), stats (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.3.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-21 13:44:16 UTC; dalitz</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Dalitz [aut, cre],
  Felix Lögler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph Dalitz &lt;christoph.dalitz@hs-niederrhein.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 14:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='distPower'>Ditribution with a Power Law</h2><span id='topic+distPower'></span><span id='topic+dpower'></span><span id='topic+ppower'></span><span id='topic+qpower'></span><span id='topic+rpower'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for a continuous distribution with the density
<code>(pow+1)*(x-min)^pow/(max-min)^(pow+1)</code> for <code>x</code>
in the range <code>[min,max]</code> and <code>pow &gt; -1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpower(x, pow, min = 0, max = 1)

ppower(x, pow, min = 0, max = 1)

qpower(p, pow, min = 0, max = 1)

rpower(n, pow, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distPower_+3A_x">x</code></td>
<td>
<p>vector of values where to evaluate the denisty or CDF.</p>
</td></tr>
<tr><td><code id="distPower_+3A_pow">pow</code></td>
<td>
<p>degree of the power law.</p>
</td></tr>
<tr><td><code id="distPower_+3A_min">min</code></td>
<td>
<p>minimum value of the support of the distribution.</p>
</td></tr>
<tr><td><code id="distPower_+3A_max">max</code></td>
<td>
<p>maximum value of the support of the distribution.</p>
</td></tr>
<tr><td><code id="distPower_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="distPower_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dpower</code> gives the density, <code>ppower</code> gives the cumulative
distribution function (CDF), <code>qpower</code> gives the quantile function
(i.e., the inverse of the CDF), and <code>rpower</code> generates random numbers.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rpower</code>, and is
the length of <code>x</code> or <code>p</code> for the other functions.
</p>

<hr>
<h2 id='estimate.m'>Estimating a Subsample Size m</h2><span id='topic+estimate.m'></span>

<h3>Description</h3>

<p>Estimates <code>m</code> using the selected <code>method</code>.
Additional parameters can be passed to the underlying methods using <code>params</code>.
It is also possible to pass parameters to the statistic using '...'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.m(
  data,
  statistic,
  tau = NULL,
  R = 1000,
  replace = FALSE,
  min.m = 3,
  method = "bickel",
  params = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.m_+3A_data">data</code></td>
<td>
<p>The data to be bootstrapped.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_statistic">statistic</code></td>
<td>
<p>The estimator of the parameter.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_tau">tau</code></td>
<td>
<p>The convergence rate.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_r">R</code></td>
<td>
<p>The amount of bootstrap replicates. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_replace">replace</code></td>
<td>
<p>If the sampling should be done with replacement. Setting this value to true requires a sufficient smooth estimator.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_min.m">min.m</code></td>
<td>
<p>Minimum subsample size to be tried. Should be the minimum size for which the statistic make sense.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_method">method</code></td>
<td>
<p>The method to be used, one of <code>c("goetze","bickel","politis", "sherman")</code>.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_params">params</code></td>
<td>
<p>Additional parameters to be passed to the internal functions, see details for more information.</p>
</td></tr>
<tr><td><code id="estimate.m_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different methods have different parameters. Therefore, this wrapper method has been given the <code>params</code> parameter, which can be used to
pass method-specific arguments to the underlying methods. The specific parameters are described below.
Most of the provided methods need <code>tau</code>. If not provided, it will be estimated using
<code>estimate.tau</code>. Note that method 'sherman' is using an alternative approach without using the scalation factor and
therefore <code>tau</code> will not be computed if selecting 'sherman' as method. Any non <code>NULL</code> values will be ignored when
selecting the method 'sherman'.
</p>
<p>Possible methods are:
</p>
<dl>
<dt>goetze:</dt><dd>
<p>The method from Goetze and Rackauskas is based on minimizing the distance between the
CDF of the bootstrap distributions of different subsampling sizes 'm'.
As distance measurement the 'Kolmogorov distance' is used.
The method uses the pairs 'm' and 'm/2' to be minimized.
As this would involve trying out all combinations of 'm' and 'm/2' this method has a running time of order Rn^2.
To reduce the runtime in practical use, <code>params</code> can be used to pass a <code>search.value</code>, which is a
list of the smallest and largest value for m to try.</p>
</dd>
<dt>bickel:</dt><dd>
<p>This method works similary to the previous one. The difference here is that the subsample sizes to be
compared are consecutive subsample sizes generated by <code>q^j*n</code> for <code>j = seq(2,n)</code> and a chosen <code>q</code> value between
zero and one.
The parameter <code>q</code> can be selected using <code>params</code>. The default value is <code>q=0.75</code>, as suggested in the corresponding paper.</p>
</dd>
<dt>politis:</dt><dd>
<p>This method is also known as the 'minimum volatility method'. It is based on the idea that there
should be some range for subsampling sizes, where its choice has little effect on the estimated confidence points.
The algorithm starts by smoothing the endpoints of the intervals and then calculates the standard deviation.
The <code>h.ci</code> parameter is used to select the number of neighbors used for smoothing.
The <code>h.sigma</code> parameter is the number of neighbors used in the standard deviation calculation.
Both parameters can be set by using <code>params</code>.
Note that the <code>h.*</code> neigbors from each side are used.
To use five elements for smoothing, <code>h.ci</code> should therefore be set to 2.</p>
</dd>
<dt>sherman:</dt><dd>
<p>This method is based on a 'double-bootstrap' approach.
It tries to estimate the coverage error of different subsampling sizes and chooses the subsampling
size with the lowest one.
As estimating the coverage error is highly computationally intensive, it is not practical to try all m values.
Therefore, the <code>beta</code> parameter can be used to control which <code>m</code> values are tried. The values
are then calculated by <code>ms = n^beta</code>. The default value is a sequence between 0.3 and 0.9 out of 15 values.
This parameter can be set using <code>params</code>.</p>
</dd></dl>



<h3>Value</h3>

<p>Subsampling size <code>m</code> choosen by the selected method.
</p>


<h3>References</h3>

<p>Götze F. and Rackauskas A. (2001) Adaptive choice of bootstrap sample sizes.
<em>Lecture Notes-Monograph Series</em>, 36(State of the Art in Probability and Statistics):286-309
</p>
<p>Bickel P.J. and Sakov A. (2008) On the choice of m in the m out of n bootstrap and confidence bounds for extrema.
<em>Statistic Sinica</em>, 18(3):967-985.
</p>
<p>Politis D.N. et al. (1999)
<em>Subsampling</em>, Springer, New York.
</p>
<p>Sherman M. and Carlstein E. (2004) Confidence intervals based on estimators with unknown rates of convergence.
<em>Computional statistics &amp; data analysis</em>, 46(1):123-136.
</p>


<h3>See Also</h3>

<p>mboot estimate.tau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- runif(1000)
estimate.max &lt;- function(data, indices) {return(max(data[indices]))}
tau &lt;- function(n){n} # convergence rate (usually sqrt(n), but n for max) 
choosen.m &lt;- estimate.m(data, estimate.max, tau, R = 1000, method = "bickel")
print(choosen.m)


</code></pre>

<hr>
<h2 id='estimate.tau'>Estimating the convergence rate</h2><span id='topic+estimate.tau'></span>

<h3>Description</h3>

<p>This function estimates the convergence rate of the bootstrap estimator
and returns it as a function of the form <code>tau_n = n^a</code>, where <code>n</code> is the input parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.tau(
  data,
  statistic,
  R = 1000,
  replace = FALSE,
  min.m = 3,
  beta = seq(0.2, 0.7, length.out = 5),
  method = "variance",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.tau_+3A_data">data</code></td>
<td>
<p>The data to be bootstrapped.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_statistic">statistic</code></td>
<td>
<p>The estimator of the parameter.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_r">R</code></td>
<td>
<p>Amount of bootstrap replicates used to estimate tau.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_replace">replace</code></td>
<td>
<p>If sampling should be done with replacement.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_min.m">min.m</code></td>
<td>
<p>Minimal subsampling size used to estimate tau. Should be set to the minimum size for which the statistic makes sense.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_beta">beta</code></td>
<td>
<p>The tested subsample sizes m are <code>n^beta</code>.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_method">method</code></td>
<td>
<p>Method to estimate tau, can be one of <code>c("variance", "quantile")</code>.</p>
</td></tr>
<tr><td><code id="estimate.tau_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the <code>mboot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two methods to choose from, <code>variance</code> and <code>quantile</code>.
The provided <code>beta</code> values are used to select subsample sizes <code>m</code> by using <code>ms = n^beta</code>.
Note that the choice of the <code>beta</code> values can impact the accuracy of the estimated <code>tau</code> (Dalitz &amp; Lögler, 2024).
For each selected subsample size <code>m</code> a bootstrap with <code>R</code> replications is performed.
The method 'variance' then fits a linear function to log(variance) of the bootstrap statistics as function of log(m).
The method 'quantile' averages over multiple quantile ranges Q and fits a linear function to log(Q) as a function of log(m).
</p>


<h3>Value</h3>

<p>A function for the square root of the convergence rate of the variance, i.e., <code>f(n) = tau_n</code>. This function can directly be passed to <code>mboot.ci</code>.
</p>


<h3>References</h3>

<p>Bertail P. et al. (1999) On subsampling estimators with unknown rate of convergence.
<em>Journal of the American Statistical Association</em>, 94(446):568-579.
</p>
<p>Politis D.N. et al. (1999)
<em>Subsampling</em>, Springer, New York.
</p>
<p>Dalitz, C, and Lögler, F. (2024)
<em>moonboot: An R Package Implementing m-out-of-n Bootstrap Methods</em>.
<a href="https://doi.org/10.48550/arXiv.2412.05032">doi:10.48550/arXiv.2412.05032</a>
</p>


<h3>See Also</h3>

<p>mboot.ci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- runif(1000)
estimate.max &lt;- function(data, indices) {return(max(data[indices]))}
estimated.tau &lt;- estimate.tau(data, estimate.max)
boot.out &lt;- mboot(data, estimate.max, R = 1000, m = 2*sqrt(NROW(data)), replace = FALSE)
cis &lt;- mboot.ci(boot.out, 0.95, estimated.tau, c("all"))
ci.basic &lt;- cis$basic
print(ci.basic)

</code></pre>

<hr>
<h2 id='mboot'>m-Out-of-n Bootstrap Implementation</h2><span id='topic+mboot'></span>

<h3>Description</h3>

<p>Generate <code>R</code> bootstrap replicates of the given <code>statistic</code> applied to the <code>data</code>.
Sampling can be done with or without replacement.
The subsample size m can either be chosen directly or estimated with <code><a href="#topic+estimate.m">estimate.m()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboot(data, statistic, m, R = 1000, replace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mboot_+3A_data">data</code></td>
<td>
<p>The data to be bootstrapped. If it is multidimensional, each row is considered as one observation passed to the <code>statistic</code>.</p>
</td></tr>
<tr><td><code id="mboot_+3A_statistic">statistic</code></td>
<td>
<p>A function returing the statistic of interest. It must take two arguments. The first argument passed will be the original data, the second
will be a vector of indicies. Any further arguments can be passed through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="mboot_+3A_m">m</code></td>
<td>
<p>The subsampling size.</p>
</td></tr>
<tr><td><code id="mboot_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="mboot_+3A_replace">replace</code></td>
<td>
<p>Whether sampling should be done with replacement or without replacement (the default).</p>
</td></tr>
<tr><td><code id="mboot_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the <code>statistic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>m</code> needs to be a numeric value meeting the condition <code>2&lt;=m&lt;=n</code>.
It must be chosen such that m goes to infinity as n goes to infinits,
but the ratio m/n must go to zero.
The m-out-of-n Bootstrap without replacement, known as subsampling, was introduced by Politis and Romano (1994).
</p>


<h3>Value</h3>

<p>The returned value is an object of the class <code>"mboot"</code> containing the following components:
</p>

<ul>
<li><p> t0: The observed value of <code>statistic</code> applied to the <code>data</code>.
</p>
</li>
<li><p> t: A matrix with <code>R</code> rows where each is a bootstrap replicate of the result of calling <code>statistic</code>.
</p>
</li>
<li><p> m,n: Selected subsample size and data size.
</p>
</li>
<li><p> data: The <code>data</code> passed to <code>mboot</code>.
</p>
</li>
<li><p> statistic: The <code>statistic</code> passed to <code>mboot</code>.
</p>
</li>
<li><p> replace: Whether the bootstrap replicates were done with or without replacement.
</p>
</li></ul>



<h3>References</h3>

<p>Politis D.N. and Romano J.P. (1994) Large sample confidence regions
based on subsamples under minimal assumptions. <em>The Annals of Statistics</em>, 22(4):2031-2050, <a href="https://doi.org/10.1214/aos/1176325770">doi:10.1214/aos/1176325770</a>
</p>


<h3>See Also</h3>

<p>mboot.ci estimate.m estimate.tau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- runif(1000)
estimate.max &lt;- function(data, indices) {return(max(data[indices]))}
boot.out &lt;- mboot(data, estimate.max, R = 1000, m = 2*sqrt(NROW(data)), replace = FALSE)

</code></pre>

<hr>
<h2 id='mboot.ci'>m-Out-of-n Bootstrap Confidence Intervals</h2><span id='topic+mboot.ci'></span>

<h3>Description</h3>

<p>Estimates the confidence interval using the methods provided by <code>types</code>.
<code>tau</code> must be a function that calculates teh scaling factor
tau(n) for a given n. If <code>tau</code> is not provided, it is estimated
with <code>estimate.tau</code> using the default settings of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboot.ci(boot.out, conf = 0.95, tau = NULL, types = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mboot.ci_+3A_boot.out">boot.out</code></td>
<td>
<p>The simulated bootstrap distribution from the <code>mboot</code> call.</p>
</td></tr>
<tr><td><code id="mboot.ci_+3A_conf">conf</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code id="mboot.ci_+3A_tau">tau</code></td>
<td>
<p>Function that returns the scaling factor tau in dependence of n. If <code>NULL</code>, <code>estimate.tau</code> is used to estimate <code>tau</code>.</p>
</td></tr>
<tr><td><code id="mboot.ci_+3A_types">types</code></td>
<td>
<p>The types of confidence intervals to be calculated. The value can be 'all' for all types, or a
subset of <code>c("basic", "norm", "sherman")</code>.</p>
</td></tr>
<tr><td><code id="mboot.ci_+3A_...">...</code></td>
<td>
<p>When <code>tau</code> is omitted, the additional parameters are passed to <code>statistic</code> during estimation of <code>tau</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As estimating the scaling factor tau(n) can be unreliable, it is recommended
to explicitly provide <code>tau</code>. Otherwise it is estimated with
<code>estimate.tau</code>. To specify additional arguments for
<code>estimate.tau</code>, call this function directly and use its return value
as <code>tau</code> argument. For the type <code>sherman</code>, <code>tau</code> is not
needed and its value is ignored.
</p>
<p>The following methods to compute teh confidence intervals are supported
through the parameter <code>type</code>:
</p>
<dl>
<dt>basic:</dt><dd>
<p>This method works for all estimators and computes the interval directly from the quantiles of the m-out-of-n bootstrap distribution.</p>
</dd>
<dt>norm:</dt><dd>
<p>This method only works for normally distributed estimators. It estimates the variance with the m-out-of-n bootstrap and then computes te interval with the quantiles of teh standard normal distribution.</p>
</dd>
<dt>sherman:</dt><dd>
<p>This method does not scale the interval with tau(m)/tau(n) and thus is too wide. To avoid over-coverage, this is compensated by centering it randomly around the point estimators of one of the m-out-of-n bootstrap samples. Although this results on average in the nominal coverage probability, the interval is less accurate than the other intervals and should be used only as a last resort if the scaling factor tau is neither known, nor estimatable.</p>
</dd></dl>



<h3>Value</h3>

<p>A list of confidence intervals for the given types.
</p>


<h3>References</h3>

<p>Politis D.N. and Romano J.P. (1994) Large sample confidence regions
based on subsamples under minimal assumptions. <em>The Annals of Statistics</em>, 22(4):2031-2050, <a href="https://doi.org/10.1214/aos/1176325770">doi:10.1214/aos/1176325770</a>
</p>
<p>Sherman M. and Carlstein E. (2004) Confidence intervals based on estimators with unknown rates of convergence.
<em>Computional statistics &amp; data analysis</em>, 46(1):123-136.
</p>
<p>Dalitz C. and Lögler M. (2024) moonboot: An R Package Implementing m-out-of-n Bootstrap Methods <a href="https://doi.org/10.48550/arXiv.2412.05032">doi:10.48550/arXiv.2412.05032</a>
</p>


<h3>See Also</h3>

<p>mboot estimate.tau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- runif(1000)
estimate.max &lt;- function(data, indices) {return(max(data[indices]))}
tau &lt;- function(n){n} # convergence rate (usually sqrt(n), but n for max) 
boot.out &lt;- mboot(data, estimate.max, R = 1000, m = 2*sqrt(NROW(data)), replace = FALSE)
cis &lt;- mboot.ci(boot.out, 0.95, tau, c("all"))
ci.basic &lt;- cis$basic
print(ci.basic)

</code></pre>

<hr>
<h2 id='shorth'>Mean of the Shorthest Half</h2><span id='topic+shorth'></span>

<h3>Description</h3>

<p>Calculates the mean of the data points in the shortest interval containing half of the data.
The arguments of the function are such that it directly can be used as a
statistic in the <code><a href="#topic+mboot">mboot()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shorth(data, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shorth_+3A_data">data</code></td>
<td>
<p>the data as a numeric vector.</p>
</td></tr>
<tr><td><code id="shorth_+3A_indices">indices</code></td>
<td>
<p>the selected indices of <code>data</code>, by default <code>seq_along(data)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of the data points in the shortest interval containing half of the data.
</p>


<h3>References</h3>

<p>Andrews D.F. et al. (1972) <em>Robust Estimates of Location</em> Princeton University Press, Princeton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rnorm(100)
shorth(data)
shorth(data, sample(1:100, size = 20))

# Calculating a CI for shorth using [mboot()]
data &lt;- rnorm(100)
boot.out &lt;- mboot(data, shorth, m = sqrt(length(data)))
basic.ci &lt;- mboot.ci(boot.out, conf =0.95, tau = function(n) return(n^(1/3)), types = "basic")$basic

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
