<!DOCTYPE html><html><head><title>Help for package jagshelper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jagshelper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asdf_jags_out'><p>Example data: asdf jags out</p></a></li>
<li><a href='#asdf_prior_jags_out'><p>Example data: asdf prior jags out</p></a></li>
<li><a href='#caterpillar'><p>Caterpillar plot</p></a></li>
<li><a href='#chaindens_df'><p>By-chain kernel density of each column of a <code>data.frame</code>.</p></a></li>
<li><a href='#chaindens_jags'><p>By-chain kernel densities of <code>jagsUI</code> object</p></a></li>
<li><a href='#chaindens_line'><p>Simple by-chain kernel density plot</p></a></li>
<li><a href='#check_neff'><p>Quick summary of n.eff values by parameter name</p></a></li>
<li><a href='#check_Rhat'><p>Quick summary of Rhat values by parameter name</p></a></li>
<li><a href='#comparecat'><p>Compare Caterpillar Plots</p></a></li>
<li><a href='#comparedens'><p>Compare Density</p></a></li>
<li><a href='#comparepriors'><p>Compare Priors</p></a></li>
<li><a href='#cor_jags'><p>Correlation matrix from a JAGS object</p></a></li>
<li><a href='#envelope'><p>Envelope plot</p></a></li>
<li><a href='#expit'><p>Expit, or inverse logit</p></a></li>
<li><a href='#jags_df'><p>Extract data.frame</p></a></li>
<li><a href='#jags_plist'><p>Plist</p></a></li>
<li><a href='#jagshelper-package'>
<p>Functions for Extracting and Visualizing Output from 'jagsUI'</p></a></li>
<li><a href='#logit'><p>Logit</p></a></li>
<li><a href='#nbyname'><p>Number of parameter nodes by parameter name</p></a></li>
<li><a href='#nparam'><p>Number of parameters</p></a></li>
<li><a href='#overlayenvelope'><p>Overlay envelope plots</p></a></li>
<li><a href='#pairstrace_jags'><p>Pairs trace plot</p></a></li>
<li><a href='#plotcor_jags'><p>Plot a correlation matrix from a JAGS object</p></a></li>
<li><a href='#plotdens'><p>Plot kernel densities of single parameter nodes</p></a></li>
<li><a href='#plotRhats'><p>Plotting all Rhat values</p></a></li>
<li><a href='#pull_post'><p>Subset from posterior data.frame</p></a></li>
<li><a href='#qq_postpred'><p>Quantile-quantile plot from posterior predictive distribution</p></a></li>
<li><a href='#rcolors'><p>Random Colors</p></a></li>
<li><a href='#skeleton'><p>Skeleton</p></a></li>
<li><a href='#SS_data'><p>Example data: Time series associated with SS JAGS out</p></a></li>
<li><a href='#SS_out'><p>Example data: SS JAGS out</p></a></li>
<li><a href='#trace_df'><p>Trace plot of each column of a <code>data.frame</code>.</p></a></li>
<li><a href='#trace_jags'><p>Trace plot of jagsUI object</p></a></li>
<li><a href='#trace_line'><p>Simple trace plot</p></a></li>
<li><a href='#tracedens_jags'><p>Combination of trace plots and by-chain kernel densities of <code>jagsUI</code> object</p></a></li>
<li><a href='#traceworstRhat'><p>Trace plots corresponding to the worst values of Rhat</p></a></li>
<li><a href='#ts_postpred'><p>Time series plot of centered posterior predictive distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extracting and Visualizing Output from 'jagsUI'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Tyers [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Tyers &lt;matttyersstat@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools are provided to streamline Bayesian analyses in 'JAGS' using 
    the 'jagsUI' package.  Included are functions for extracting output in 
    simpler format, functions for streamlining assessment of convergence, and 
    functions for producing summary plots of output.  Also included is a 
    function that provides a simple template for running 'JAGS' from 'R'.
    Referenced materials can be found at &lt;<a href="https://doi.org/10.1214%2Fss%2F1177011136">doi:10.1214/ss/1177011136</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>jagsUI, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbtyers/jagshelper">https://github.com/mbtyers/jagshelper</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbtyers/jagshelper/issues">https://github.com/mbtyers/jagshelper/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 22:28:16 UTC; mbtyers</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='asdf_jags_out'>Example data: asdf jags out</h2><span id='topic+asdf_jags_out'></span>

<h3>Description</h3>

<p>A simple model, equivalent to that produced by the output produced by <code style="white-space: pre;">&#8288;\link{skeleton}&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asdf_jags_out
</code></pre>


<h3>Format</h3>

<p>An object of class <code>jagsUI</code> of length 24.
</p>

<hr>
<h2 id='asdf_prior_jags_out'>Example data: asdf prior jags out</h2><span id='topic+asdf_prior_jags_out'></span>

<h3>Description</h3>

<p>A simple model, equivalent to that produced by the output produced by <code style="white-space: pre;">&#8288;\link{skeleton}&#8288;</code>,
with the addition of prior samples for all parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asdf_prior_jags_out
</code></pre>


<h3>Format</h3>

<p>An object of class <code>jagsUI</code> of length 24.
</p>

<hr>
<h2 id='caterpillar'>Caterpillar plot</h2><span id='topic+caterpillar'></span>

<h3>Description</h3>

<p>Caterpillar plot of the posterior densities of a vector of parameter nodes,
in which the sequential order of nodes might not be important, such as vector of random effects.
</p>
<p>This produces a set of overlayed interval bars (default values are 50 percent and 95 percent),
with overlayed median markings, for each of a vector of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caterpillar(
  df,
  p = NULL,
  x = NA,
  row = NULL,
  column = NULL,
  median = TRUE,
  mean = FALSE,
  ci = c(0.5, 0.95),
  lwd = 1,
  col = 4,
  add = FALSE,
  xlab = "",
  ylab = "",
  main = NULL,
  ylim = NULL,
  xax = NA,
  transform = c("none", "exp", "expit"),
  medlwd = lwd,
  medwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caterpillar_+3A_df">df</code></td>
<td>
<p>Output object returned from <code>jagsUI::jags()</code>; or alternately,
two-dimensional <code>data.frame</code> or matrix in which parameter node element is
given by column and MCMC iteration is given by row.  A vector may also be used,
that expresses MCMC iterations of a single parameter node.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_p">p</code></td>
<td>
<p>Parameter name, if input to <code>df</code> is a <code>jagsUI</code> output object.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_x">x</code></td>
<td>
<p>Vector of X-coordinates for plotting.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_row">row</code></td>
<td>
<p>Row to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_column">column</code></td>
<td>
<p>Column to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_median">median</code></td>
<td>
<p>Whether to include medians</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_mean">mean</code></td>
<td>
<p>Whether to include means</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_ci">ci</code></td>
<td>
<p>Vector of intervals to overlay.  Defaults to 50 percent and 95 percent.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_lwd">lwd</code></td>
<td>
<p>Base line width for plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_col">col</code></td>
<td>
<p>Color for plotting</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_add">add</code></td>
<td>
<p>Whether to add to existing plot</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_main">main</code></td>
<td>
<p>Plot title.  If the default (<code>NULL</code>) is accepted and argument <code>p</code> is used, <code>p</code> will be used for the title.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits.  If the default (<code>NULL</code>) is accepted, the limits will be determined automatically.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_xax">xax</code></td>
<td>
<p>Vector of possible x-axis tick labels.  Defaults to the <code>data.frame</code> column names.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_transform">transform</code></td>
<td>
<p>Should the y-axis be (back)transformed?  Options are <code>"exp"</code>,
indicating exponential, or <code>"expit"</code>, indicating inverse-logit. Defaults to
<code>"none"</code>, indicating no transformation.  Note: if <code>transform="exp"</code>is used, consider
adding additional plotting argument <code>log="y"</code>.</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_medlwd">medlwd</code></td>
<td>
<p>Line width of median line</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_medwd">medwd</code></td>
<td>
<p>Relative width of median line.  Defaults to 1, perhaps smaller numbers will look better?</p>
</td></tr>
<tr><td><code id="caterpillar_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+envelope">envelope</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## usage with input data.frame
a &lt;- jags_df(asdf_jags_out, p="a")

caterpillar(a)
caterpillar(a, ci=seq(.1,.9,by=.1))
caterpillar(a, lwd=2)
caterpillar(a, xax=c("effect 1", "effect 2", "effect 3"))


## usage with input as jagsUI object
caterpillar(asdf_jags_out, p="a")
caterpillar(SS_out, p="rate")

## usage with a 2-d parameter matrix
caterpillar(SS_out, p="cycle_s", column=1)
caterpillar(SS_out, p="cycle_s", column=2)

## usage with an exponential transformation
caterpillar(SS_out, p="trend", transform="exp", ylab="exp transform")
caterpillar(SS_out, p="trend", transform="exp", ylab="exp transform", log="y")
caterpillar(SS_out, p="trend", transform="expit", ylab="expit (inv logit) transform")
</code></pre>

<hr>
<h2 id='chaindens_df'>By-chain kernel density of each column of a <code>data.frame</code>.</h2><span id='topic+chaindens_df'></span>

<h3>Description</h3>

<p>By-chain kernel density plot of each column of a posterior <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaindens_df(df, nline, parmfrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaindens_df_+3A_df">df</code></td>
<td>
<p>Posterior <code>data.frame</code></p>
</td></tr>
<tr><td><code id="chaindens_df_+3A_nline">nline</code></td>
<td>
<p>Number of chains</p>
</td></tr>
<tr><td><code id="chaindens_df_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="chaindens_df_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+trace_jags">trace_jags</a>, <a href="#topic+trace_line">trace_line</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- jags_df(asdf_jags_out, p="a")

chaindens_df(a, nline=3, parmfrow=c(3,1))
</code></pre>

<hr>
<h2 id='chaindens_jags'>By-chain kernel densities of <code>jagsUI</code> object</h2><span id='topic+chaindens_jags'></span>

<h3>Description</h3>

<p>By-chain kernel densities of a whole <code>jagsUI</code> object, or optional subset of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaindens_jags(x, p = NULL, exact = FALSE, parmfrow = NULL, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaindens_jags_+3A_x">x</code></td>
<td>
<p>Posterior <code>jagsUI</code> object</p>
</td></tr>
<tr><td><code id="chaindens_jags_+3A_p">p</code></td>
<td>
<p>Parameter name for subsetting: if this is specified, only parameters with names beginning with this string will be plotted.</p>
</td></tr>
<tr><td><code id="chaindens_jags_+3A_exact">exact</code></td>
<td>
<p>Whether <code>p</code> should be an exact match (<code>TRUE</code>) or just match the
beginning of the string (<code>FALSE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chaindens_jags_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="chaindens_jags_+3A_lwd">lwd</code></td>
<td>
<p>Line width for plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="chaindens_jags_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+trace_jags">trace_jags</a>, <a href="#topic+chaindens_line">chaindens_line</a>, <a href="#topic+chaindens_df">chaindens_df</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chaindens_jags(asdf_jags_out, parmfrow=c(4,2))
chaindens_jags(x=asdf_jags_out, p="a", parmfrow=c(3,1))
</code></pre>

<hr>
<h2 id='chaindens_line'>Simple by-chain kernel density plot</h2><span id='topic+chaindens_line'></span>

<h3>Description</h3>

<p>By-chain kernel density plot of a single parameter node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaindens_line(x, nline, lwd = 1, main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaindens_line_+3A_x">x</code></td>
<td>
<p>Posterior vector</p>
</td></tr>
<tr><td><code id="chaindens_line_+3A_nline">nline</code></td>
<td>
<p>Number of chains</p>
</td></tr>
<tr><td><code id="chaindens_line_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="chaindens_line_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="chaindens_line_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+chaindens_jags">chaindens_jags</a>, <a href="#topic+chaindens_df">chaindens_df</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- jags_df(asdf_jags_out, p="b1")

chaindens_line(b1, nline=3, main="b1")
</code></pre>

<hr>
<h2 id='check_neff'>Quick summary of n.eff values by parameter name</h2><span id='topic+check_neff'></span>

<h3>Description</h3>

<p>Returns the mean number of <code>n.eff</code> values (by each parameter) that are greater than a specified threshold criterion.
</p>
<p><code>n.eff</code> is calculated within 'JAGS', and may be interpreted as a crude measure of
effective sample size for a given parameter node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_neff(x, thresh = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_neff_+3A_x">x</code></td>
<td>
<p>Output object from <code>jagsUI::jags()</code></p>
</td></tr>
<tr><td><code id="check_neff_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value (defaults to 500)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric (named) giving the proportion of <code>n.eff</code> values above the given threshold.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+check_Rhat">check_Rhat</a>, <a href="#topic+traceworstRhat">traceworstRhat</a>, <a href="#topic+plotRhats">plotRhats</a>, <a href="#topic+qq_postpred">qq_postpred</a>, <a href="#topic+ts_postpred">ts_postpred</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_neff(SS_out)
</code></pre>

<hr>
<h2 id='check_Rhat'>Quick summary of Rhat values by parameter name</h2><span id='topic+check_Rhat'></span>

<h3>Description</h3>

<p>Returns the mean number of <code>Rhat</code> values for each parameter (by each parameter)
that are less than a specified threshold criterion.
</p>
<p><code>Rhat</code> (Gelman-Rubin Convergence Diagnostic, or Potential Scale Reduction Factor)
is calculated within 'JAGS', and is
commonly used as a measure of convergence for a given parameter node.  Values close
to 1 are seen as evidence of adequate convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_Rhat(x, thresh = 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_Rhat_+3A_x">x</code></td>
<td>
<p>Output object from <code>jagsUI::jags()</code></p>
</td></tr>
<tr><td><code id="check_Rhat_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value (defaults to 1.1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric (named) giving the proportion of Rhat values below the given threshold.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>References</h3>

<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from Iterative Simulation
Using Multiple Sequences. <em>Statistical Science, 7</em>(4), 457â€“472. http://www.jstor.org/stable/2246093
</p>


<h3>See Also</h3>

<p><a href="#topic+check_neff">check_neff</a>, <a href="#topic+traceworstRhat">traceworstRhat</a>, <a href="#topic+plotRhats">plotRhats</a>, <a href="#topic+qq_postpred">qq_postpred</a>, <a href="#topic+ts_postpred">ts_postpred</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_Rhat(SS_out)
</code></pre>

<hr>
<h2 id='comparecat'>Compare Caterpillar Plots</h2><span id='topic+comparecat'></span>

<h3>Description</h3>

<p>Interleaved caterpillar plots for all parameters (or a specified subset) from a list of <code>jagsUI</code>
output objects or <code>data.frame</code>s.  The intent of this function is easy comparison of inferences from multiple comparable models.
</p>
<p>Here a <a href="#topic+caterpillar">caterpillar</a> plot is defined as a set of overlayed interval bars (default values are 50 percent and 95 percent),
with overlayed median markings, for each of a vector of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparecat(
  x,
  p = NULL,
  ci = c(0.5, 0.95),
  ylim = NULL,
  col = NULL,
  xlab = "",
  ylab = "",
  transform = c("none", "exp", "expit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparecat_+3A_x">x</code></td>
<td>
<p>List of output objects returned from <code>jagsUI</code> or <code>data.frame</code>s</p>
</td></tr>
<tr><td><code id="comparecat_+3A_p">p</code></td>
<td>
<p>Optional vector of parameters to subset.  All parameters with names matching the beginning of the
string supplied will be returned.  If the default (<code>NULL</code>) is accepted, all parameters will be plotted.</p>
</td></tr>
<tr><td><code id="comparecat_+3A_ci">ci</code></td>
<td>
<p>Credible intervals widths to plot.  Defaults to 50% and 95%.</p>
</td></tr>
<tr><td><code id="comparecat_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for plotting.  If the default (<code>NULL</code>) is accepted, limits will be automatically determined.</p>
</td></tr>
<tr><td><code id="comparecat_+3A_col">col</code></td>
<td>
<p>Vector of colors for plotting.  If the default (<code>NULL</code>) is accepted, colors will be automatically drawn.</p>
</td></tr>
<tr><td><code id="comparecat_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="comparecat_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="comparecat_+3A_transform">transform</code></td>
<td>
<p>Should the y-axis be (back)transformed?  Options are <code>"exp"</code>,
indicating exponential, or <code>"expit"</code>, indicating inverse-logit. Defaults to
<code>"none"</code>, indicating no transformation.  Note: if <code>transform="exp"</code>is used, consider
adding additional plotting argument <code>log="y"</code>.</p>
</td></tr>
<tr><td><code id="comparecat_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+caterpillar">caterpillar</a>, <a href="#topic+comparedens">comparedens</a>, <a href="#topic+comparepriors">comparepriors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This is the same output object three times, but shows functionality.
comparecat(x=list(asdf_jags_out, asdf_jags_out, asdf_jags_out),
           p=c("a","b","sig"))

## Transformed
comparecat(x=list(asdf_jags_out, asdf_jags_out, asdf_jags_out),
           p=c("sig"), transform="exp")
comparecat(x=list(asdf_jags_out, asdf_jags_out, asdf_jags_out),
           p=c("sig"), transform="exp", log="y")
</code></pre>

<hr>
<h2 id='comparedens'>Compare Density</h2><span id='topic+comparedens'></span>

<h3>Description</h3>

<p>Side-by-side kernel density plots for all parameters (or a specified subset) from two <code>jagsUI</code>
output objects or <code>data.frame</code>s.  The intent of this function is easy comparison of inferences from two comparable models.
</p>
<p>Kernel densities are plotted vertically, either left- or right-facing.  Parameters with the same name are
plotted facing one another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparedens(
  x1,
  x2,
  p = NULL,
  minCI = 0.99,
  ylim = NULL,
  legendnames = NULL,
  legendpos = "topleft",
  col = c(4, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparedens_+3A_x1">x1</code></td>
<td>
<p>Output object returned from <code>jagsUI</code>; or alternately a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="comparedens_+3A_x2">x2</code></td>
<td>
<p>Second output object returned from <code>jagsUI</code>; or alternately a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="comparedens_+3A_p">p</code></td>
<td>
<p>Optional vector of parameters to subset.  All parameters with names matching the beginning of the
string supplied will be returned.  If the default (<code>NULL</code>) is accepted, all parameters will be plotted.</p>
</td></tr>
<tr><td><code id="comparedens_+3A_minci">minCI</code></td>
<td>
<p>Minimum CI width for plotting.  This is intended as a method for excluding far-outlying MCMC
samples when determining the appropriate y-axis limits for plotting.  Defaults to 99%.</p>
</td></tr>
<tr><td><code id="comparedens_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for plotting.  If the default (<code>NULL</code>) is accepted, limits will be automatically determined.</p>
</td></tr>
<tr><td><code id="comparedens_+3A_legendnames">legendnames</code></td>
<td>
<p>Names for optional legend.  If the default <code>NULL</code> is accepted, no legend will be drawn.</p>
</td></tr>
<tr><td><code id="comparedens_+3A_legendpos">legendpos</code></td>
<td>
<p>Position for optional legend.  Defaults to <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="comparedens_+3A_col">col</code></td>
<td>
<p>Colors for kernel density plots.  Defaults to colors <code>4</code> and <code>2</code> (blue and red).</p>
</td></tr>
<tr><td><code id="comparedens_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+comparecat">comparecat</a>, <a href="#topic+comparepriors">comparepriors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This is the same output object twice, but shows functionality.
comparedens(x1=asdf_jags_out, x2=asdf_jags_out, p=c("a","b","sig"),
            legendnames=c("Model 1", "Model 2"))
</code></pre>

<hr>
<h2 id='comparepriors'>Compare Priors</h2><span id='topic+comparepriors'></span>

<h3>Description</h3>

<p>Side-by-side kernel density plots for all parameters with parameter
names ending in <code>"_prior"</code>, and corresponding parameters without.  It should
be noted that these parameters must be specified in JAGS as well as the
corresponding parameters, and this is left to the user.
</p>
<p>This function is a wrapper of <a href="#topic+comparedens">comparedens</a>.
</p>
<p>Kernel densities are plotted vertically, either left- or right-facing.  Parameters with the same name are
plotted facing one another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparepriors(x, parmfrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparepriors_+3A_x">x</code></td>
<td>
<p>Output object returned from jagsUI::jags()</p>
</td></tr>
<tr><td><code id="comparepriors_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="comparepriors_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="#topic+comparedens">comparedens</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+comparecat">comparecat</a>, <a href="#topic+comparedens">comparedens</a>, <a href="#topic+plotdens">plotdens</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a look at what parameters exist in the input object
nbyname(asdf_prior_jags_out)

## then, showing the function usage
comparepriors(asdf_prior_jags_out, parmfrow=c(2, 3))
</code></pre>

<hr>
<h2 id='cor_jags'>Correlation matrix from a JAGS object</h2><span id='topic+cor_jags'></span>

<h3>Description</h3>

<p>Computes a correlation matrix of all MCMC samples from an object
returned by 'jagsUI', or an optional subset of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_jags(x, p = NULL, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_jags_+3A_x">x</code></td>
<td>
<p>Output object returned from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="cor_jags_+3A_p">p</code></td>
<td>
<p>Optional string to begin posterior names.  If <code>NULL</code> is used, all parameters will be used</p>
</td></tr>
<tr><td><code id="cor_jags_+3A_exact">exact</code></td>
<td>
<p>Whether name must be an exact match (<code>TRUE</code>) or with initial sub-string matching only supplied characters (<code>FALSE</code>).
Defaults to <code>FALSE.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional correlation matrix (n X n, where n is the number of parameter nodes)
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+plotcor_jags">plotcor_jags</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_jags(asdf_jags_out)
</code></pre>

<hr>
<h2 id='envelope'>Envelope plot</h2><span id='topic+envelope'></span>

<h3>Description</h3>

<p>Envelope plot of the posterior densities of a vector of parameter nodes,
in which the sequential order of nodes is important, such as a time series.
</p>
<p>This produces a plot of overlayed shaded strips, each corresponding to a given
interval width (defaults to 50 percent and 95 percent), with an overlayed
median line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelope(
  df,
  p = NULL,
  x = NA,
  row = NULL,
  column = NULL,
  median = TRUE,
  ci = c(0.5, 0.95),
  col = 4,
  add = FALSE,
  dark = 0.3,
  outline = FALSE,
  xlab = "",
  ylab = "",
  main = NULL,
  ylim = NULL,
  transform = c("none", "exp", "expit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_df">df</code></td>
<td>
<p>Output object returned from <code>jagsUI::jags()</code>; or alternately,
two-dimensional <code>data.frame</code> or matrix in which parameter node element is
given by column and MCMC iteration is given by row.</p>
</td></tr>
<tr><td><code id="envelope_+3A_p">p</code></td>
<td>
<p>Parameter name, if input to <code>df</code> is a <code>jagsUI</code> output object.</p>
</td></tr>
<tr><td><code id="envelope_+3A_x">x</code></td>
<td>
<p>Vector of X-coordinates for plotting.</p>
</td></tr>
<tr><td><code id="envelope_+3A_row">row</code></td>
<td>
<p>Row to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="envelope_+3A_column">column</code></td>
<td>
<p>Column to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="envelope_+3A_median">median</code></td>
<td>
<p>Whether to include median line</p>
</td></tr>
<tr><td><code id="envelope_+3A_ci">ci</code></td>
<td>
<p>Vector of intervals to overlay.  Defaults to 50 percent and 95 percent.</p>
</td></tr>
<tr><td><code id="envelope_+3A_col">col</code></td>
<td>
<p>Color for plotting</p>
</td></tr>
<tr><td><code id="envelope_+3A_add">add</code></td>
<td>
<p>Whether to add to existing plot</p>
</td></tr>
<tr><td><code id="envelope_+3A_dark">dark</code></td>
<td>
<p>Opacity (0-1) for envelopes.  Note that multiple overlapping intervals will darken the envelope.</p>
</td></tr>
<tr><td><code id="envelope_+3A_outline">outline</code></td>
<td>
<p>Whether to just envelope outlines</p>
</td></tr>
<tr><td><code id="envelope_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="envelope_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="envelope_+3A_main">main</code></td>
<td>
<p>Plot title.  If the default (<code>NULL</code>) is accepted and argument p is used, p will be used for the title.</p>
</td></tr>
<tr><td><code id="envelope_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for plotting.  If the default (<code>NULL</code>) is accepted, these will be determined automatically.</p>
</td></tr>
<tr><td><code id="envelope_+3A_transform">transform</code></td>
<td>
<p>Should the y-axis be (back)transformed?  Options are <code>"exp"</code>,
indicating exponential, or <code>"expit"</code>, indicating inverse-logit. Defaults to
<code>"none"</code>, indicating no transformation.  Note: if <code>transform="exp"</code>is used, consider
adding additional plotting argument <code>log="y"</code>.</p>
</td></tr>
<tr><td><code id="envelope_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments to <code>lines()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+overlayenvelope">overlayenvelope</a>, <a href="#topic+caterpillar">caterpillar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## usage with input data.frame
trend &lt;- jags_df(SS_out, p="trend")
envelope(trend, x=SS_data$x)

## usage with jagsUI object
envelope(SS_out, p="trend")

## usage with 2-d jagsUI object
envelope(SS_out, p="cycle_s", column=1, main="cycle")
envelope(SS_out, p="cycle_s", column=2, col=2, add=TRUE)  ## overlay

## scale transformation
envelope(SS_out, p="trend", transform="exp", ylab="exp transform")
envelope(SS_out, p="trend", transform="exp", ylab="exp transform", log="y")
</code></pre>

<hr>
<h2 id='expit'>Expit, or inverse logit</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p>Inverse logit, where logit is defined as log(x/(1-x)).
</p>
<p>Expit (inverse logit) is defined as exp(x)/(1+exp(x)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+logit">logit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expit(0)
</code></pre>

<hr>
<h2 id='jags_df'>Extract data.frame</h2><span id='topic+jags_df'></span>

<h3>Description</h3>

<p>Extracts the posterior samples from <code>jagsUI</code> output in the form of
a <code>data.frame</code>.  This simpler construction has a few benefits: operations may
be more straightforward, and posterior objects will be smaller files and can be
written to an external table or .csv, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_df(x, p = NULL, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags_df_+3A_x">x</code></td>
<td>
<p>Output object from <code>jagsUI::jags()</code></p>
</td></tr>
<tr><td><code id="jags_df_+3A_p">p</code></td>
<td>
<p>Optional string to begin posterior names.  If <code>NULL</code> is used, all parameters will be returned.</p>
</td></tr>
<tr><td><code id="jags_df_+3A_exact">exact</code></td>
<td>
<p>Whether name must be an exact match (<code>TRUE</code>) or with initial sub-string matching only supplied characters (<code>FALSE</code>).
Defaults to <code>FALSE.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a column associated with each parameter and a row
associated with each MCMC iteration.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+pull_post">pull_post</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out_df &lt;- jags_df(asdf_jags_out)
</code></pre>

<hr>
<h2 id='jags_plist'>Plist</h2><span id='topic+jags_plist'></span>

<h3>Description</h3>

<p>Extracts a list of matrices, one for each saved parameter node.  Each
list element will be all posterior samples from that parameter node, arranged in
a matrix with a column associated with each MCMC chain and a row for
each MCMC iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_plist(x, p = NULL, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags_plist_+3A_x">x</code></td>
<td>
<p><code>jagsUI</code> output object</p>
</td></tr>
<tr><td><code id="jags_plist_+3A_p">p</code></td>
<td>
<p>String to subset parameter names, if a subset is desired</p>
</td></tr>
<tr><td><code id="jags_plist_+3A_exact">exact</code></td>
<td>
<p>Whether <code>p</code> should be an exact match (<code>TRUE</code>) or just match the
beginning of the string (<code>FALSE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with an element associated with each parameter.  Each element
will be a matrix with a column associated with each MCMC chain and a row for
each MCMC iteration.
</p>


<h3>Note</h3>

<p>It is unlikely that a user will need this function; it is included
primarily as a helper function used by other functions in this package.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out_plist &lt;- jags_plist(asdf_jags_out)
str(out_plist)

a_plist &lt;- jags_plist(asdf_jags_out, p=c("a","sig_a"))
str(a_plist)
</code></pre>

<hr>
<h2 id='jagshelper-package'>
Functions for Extracting and Visualizing Output from 'jagsUI'
</h2><span id='topic+jagshelper-package'></span><span id='topic+jagshelper'></span>

<h3>Description</h3>

<p>Functions are provided to help run Bayesian analyses in JAGS using
the 'jagsUI' package.  Included are functions for extracting output in
simpler format, functions for streamlining assessment of convergence, and
functions for producing summary plots of output.  Also included is a
function that provides a simple template for running JAGS from R.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> jagshelper</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The jagshelper package is intended to extend and streamline Bayesian analysis using the 'jagsUI' package.
</p>
<p>The <a href="#topic+skeleton">skeleton</a> function prints a template JAGS model with associated R code to the console, which can easily be copied &amp; pasted to an R script and modified as needed.
</p>
<p>Functions are also provided for visually assessing model convergence.  In particular, <a href="#topic+tracedens_jags">tracedens_jags</a> gives a relatively simple syntax for trace plots of a collection or subset of parameter nodes, and overlays by-chain kernel densities for visual assessment of marginal posterior shapes as well as overlap between MCMC chains.  Another function that could be particularly useful to users is <a href="#topic+plotRhats">plotRhats</a>, which gives a visual representation of the values of the Gelman-Rubin convergence diagnostic <code>Rhat</code> (or alternately effective sample size <code>n.eff</code>) for all saved parameters.  This may be particularly useful in the case where a model has many saved parameters.  Additionally, function <a href="#topic+traceworstRhat">traceworstRhat</a> is a wrapper for <a href="#topic+tracedens_jags">tracedens_jags</a>, but only produces trace plots for the parameter nodes with the worst (largest) values of <code>Rhat</code> or <code>n.eff</code>.  Functions <a href="#topic+qq_postpred">qq_postpred</a> and <a href="#topic+ts_postpred">ts_postpred</a> provide some posterior predictive checks of a vector of data and corresponding vector (matrix, in output form) of posterior predictive samples.
</p>
<p>Functions are also provided for visualizing posterior densities; in particular, the case of a vector of parameter nodes (one-dimensional in the JAGS model, giving a two-dimensional matrix of MCMC iterations).  Notably, the <a href="#topic+envelope">envelope</a> function is intended for a sequence of nodes (as in a time series), and the <a href="#topic+caterpillar">caterpillar</a> function is intended for cases in which order may not matter (as in a collection of random effects).
</p>
<p>Wrapper functions are also given for overlay of multiple such plots, as <a href="#topic+overlayenvelope">overlayenvelope</a> and <a href="#topic+comparecat">comparecat</a>, and <a href="#topic+comparedens">comparedens</a> giving plots as vertically-oriented left- and right-facing kernel densities.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>
<p>Maintainer: Matt Tyers &lt;matttyersstat@gmail.com&gt;
</p>

<hr>
<h2 id='logit'>Logit</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit log(x/(1-x))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+expit">expit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.5)
</code></pre>

<hr>
<h2 id='nbyname'>Number of parameter nodes by parameter name</h2><span id='topic+nbyname'></span>

<h3>Description</h3>

<p>Returns a list of the numbers of parameter nodes saved in <code>jagsUI</code> output, by parameter name.
As a default, what is returned for each list element is a vector of the array dimensions within the JAGS model
(that is, excluding the dimension associated with the number of MCMC samples for each parameter node),
or alternately, just the total number of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbyname(x, justtotal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbyname_+3A_x">x</code></td>
<td>
<p>Output object from <code>jagsUI::jags()</code></p>
</td></tr>
<tr><td><code id="nbyname_+3A_justtotal">justtotal</code></td>
<td>
<p>Whether to just report the total number of parameters, as opposed to dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with an element associated with each parameter.  Each element
can be interpreted as the vector length or array dimension associated with the
given parameter.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+nparam">nparam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(jags_df(asdf_jags_out))

nbyname(asdf_jags_out)

nparam(SS_out)
nbyname(SS_out)
</code></pre>

<hr>
<h2 id='nparam'>Number of parameters</h2><span id='topic+nparam'></span>

<h3>Description</h3>

<p>Total number of individual parameter nodes saved in <code>jagsUI</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nparam(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nparam_+3A_x">x</code></td>
<td>
<p>Output object from <code>jagsUI::jags()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value giving the number of parameter nodes.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+nbyname">nbyname</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(jags_df(asdf_jags_out))

nparam(asdf_jags_out)
</code></pre>

<hr>
<h2 id='overlayenvelope'>Overlay envelope plots</h2><span id='topic+overlayenvelope'></span>

<h3>Description</h3>

<p>Overlays multiple envelope plots of posterior <code>data.frames</code>, or outputs returned from <code>jagsUI</code>.
This would be best suited to a set of posterior <code>data.frames</code> or 2-d matrices representing sequential vectors of parameter nodes.
</p>
<p>Here a single <a href="#topic+envelope">envelope</a> plot is defined as a set of overlayed shaded strips, each corresponding to a given
interval width (defaults to 50 percent and 95 percent), with an overlayed
median line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlayenvelope(
  df,
  p = NULL,
  x = NA,
  row = NULL,
  column = NULL,
  median = TRUE,
  ci = c(0.5, 0.95),
  col = NULL,
  add = FALSE,
  dark = 0.3,
  outline = FALSE,
  xlab = "",
  ylab = "",
  main = NULL,
  ylim = NULL,
  legend = TRUE,
  legendnames = NULL,
  legendpos = "topleft",
  transform = c("none", "exp", "expit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlayenvelope_+3A_df">df</code></td>
<td>
<p>Primary input can be specified in a number of ways: either a <code>list()</code> of posterior <code>data.frame</code>s or matrices,
a <code>list</code> of output objects returned from <code>jagsUI::jags()</code>, a 3-dimensional <code>array</code> in which the input matrices to plot
are separated according to the 3rd array dimension, or a single output object returned from <code>jagsUI::jags()</code> with multiple
arguments passed to <code>p</code>, following.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_p">p</code></td>
<td>
<p>Parameter name, if input to <code>df</code> is a list of <code>jagsUI</code> output objects; or a vector of parameter names, if
input to <code>df</code> is a single <code>jagsUI</code> output object.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_x">x</code></td>
<td>
<p>Optional vector of X-coordinates for plotting.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_row">row</code></td>
<td>
<p>Row to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_column">column</code></td>
<td>
<p>Column to subset, in the case of a 2-d matrix of parameter nodes in-model.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_median">median</code></td>
<td>
<p>Whether to include median line</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_ci">ci</code></td>
<td>
<p>Vector of intervals to overlay.  Defaults to 50 percent and 95 percent.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_col">col</code></td>
<td>
<p>Vector of colors for plotting</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_add">add</code></td>
<td>
<p>Whether to add to existing plot</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_dark">dark</code></td>
<td>
<p>Opacity (0-1) for envelopes.  Note that multiple overlapping intervals will darken the envelope.  Defaults to 0.3.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_outline">outline</code></td>
<td>
<p>Whether to just envelope outlines</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_main">main</code></td>
<td>
<p>Plot title.  If the default (<code>NULL</code>) is accepted and argument <code style="white-space: pre;">&#8288;p=&#8288;</code> is used, <code>p</code> will be used for the title.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for plotting.  If the default (<code>NULL</code>) is accepted, these will be determined automatically.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_legend">legend</code></td>
<td>
<p>Whether to automatically try to add a legend.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_legendnames">legendnames</code></td>
<td>
<p>Optional vector of names for a legend.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_legendpos">legendpos</code></td>
<td>
<p>Position for optional legend.  Defaults to <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_transform">transform</code></td>
<td>
<p>Should the y-axis be (back)transformed?  Options are <code>"exp"</code>,
indicating exponential, or <code>"expit"</code>, indicating inverse-logit. Defaults to
<code>"none"</code>, indicating no transformation.  Note: if <code>transform="exp"</code>is used, consider
adding additional plotting argument <code>log="y"</code>.</p>
</td></tr>
<tr><td><code id="overlayenvelope_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments to <code>lines()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+envelope">envelope</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## usage with list of input data.frames
overlayenvelope(df=list(SS_out$sims.list$cycle_s[,,1],
                            SS_out$sims.list$cycle_s[,,2]))

## usage with a 3-d input array
overlayenvelope(df=SS_out$sims.list$cycle_s)

## usage with a jagsUI output object and parameter name (2-d parameter)
overlayenvelope(df=SS_out, p="cycle_s")

## usage with a single jagsUI output object and multiple parameters
overlayenvelope(df=SS_out, p=c("trend","rate"))

## exponential transformation
overlayenvelope(df=SS_out, p="cycle_s", transform="exp",
                ylab="exp transform")
overlayenvelope(df=SS_out, p="cycle_s", transform="exp",
                ylab="exp transform", log="y")
</code></pre>

<hr>
<h2 id='pairstrace_jags'>Pairs trace plot</h2><span id='topic+pairstrace_jags'></span>

<h3>Description</h3>

<p>Two-dimensional trace plots (or alternately, scatter plots or contour plots) of each possible pair of
parameters from a possible subset.  May be useful in assessing correlation between parameter nodes, or problematic
posterior surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairstrace_jags(
  x,
  p = NULL,
  points = FALSE,
  contour = FALSE,
  lwd = 1,
  alpha = 0.2,
  parmfrow = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairstrace_jags_+3A_x">x</code></td>
<td>
<p>Output object returned from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_p">p</code></td>
<td>
<p>Optional vector of parameters to subset</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_points">points</code></td>
<td>
<p>Whether to plot as scatter plots instead.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_contour">contour</code></td>
<td>
<p>Whether to plot as contour plots instead.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_lwd">lwd</code></td>
<td>
<p>Line width for trace plots.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_alpha">alpha</code></td>
<td>
<p>Opacity of lines (or points, when <code>points=TRUE</code>).  Defaults to 0.2.</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="pairstrace_jags_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments to <code>tracedens_jags()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairstrace_jags(SS_out, p="sig", parmfrow=c(2,3), lwd=2)
pairstrace_jags(SS_out, p="sig", parmfrow=c(2,3), points=TRUE)
pairstrace_jags(SS_out, p="sig", parmfrow=c(2,3), contour=TRUE)

pairstrace_jags(asdf_jags_out, parmfrow=c(3,3))
pairstrace_jags(asdf_jags_out, parmfrow=c(3,3), points=TRUE)
pairstrace_jags(asdf_jags_out, parmfrow=c(3,3), contour=TRUE)
</code></pre>

<hr>
<h2 id='plotcor_jags'>Plot a correlation matrix from a JAGS object</h2><span id='topic+plotcor_jags'></span>

<h3>Description</h3>

<p>Plots a correlation matrix of all MCMC samples from an object
returned by 'jagsUI', or an optional subset of parameter nodes.  Correlation is
plotted as shades of red (positive) or blue (negative).
</p>
<p>In the case of vectors or arrays of nodes for each parameter name, a single axis
tick will be used for all nodes with a single name.  This has the effect of
giving greater visual weight to single parameters, and reducing plot clutter.
</p>
<p>Values of correlation are overlayed for all parameters with few nodes, with
character size scaled according to the absolute correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcor_jags(
  x,
  p = NULL,
  exact = FALSE,
  mincor = 0,
  maxn = 4,
  maxcex = 1,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotcor_jags_+3A_x">x</code></td>
<td>
<p>Output object returned from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_p">p</code></td>
<td>
<p>Optional string to begin posterior names.  If <code>NULL</code> is used, all parameters will be used</p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_exact">exact</code></td>
<td>
<p>Whether name must be an exact match (<code>TRUE</code>) or with initial sub-string matching only supplied characters (<code>FALSE</code>).
Defaults to <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_mincor">mincor</code></td>
<td>
<p>Minimum (absolute) correlation to use for text labels.  Defaults to 0 (all will be plotted)</p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_maxn">maxn</code></td>
<td>
<p>Maximum number of nodes per parameter name for text labels, to prevent plot clutter.  Defaults to 4.</p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_maxcex">maxcex</code></td>
<td>
<p>Maximum character expansion factor for text labels.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_legend">legend</code></td>
<td>
<p>Whether to produce a plot legend.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotcor_jags_+3A_...">...</code></td>
<td>
<p>Optional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+plotcor_jags">plotcor_jags</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotcor_jags(asdf_jags_out, maxcex=0.7)

plotcor_jags(SS_out, p=c("trend","rate","sig"))
</code></pre>

<hr>
<h2 id='plotdens'>Plot kernel densities of single parameter nodes</h2><span id='topic+plotdens'></span>

<h3>Description</h3>

<p>Produces a kernel density plot of a single or multiple parameter nodes (overlayed).
</p>
<p>Input can be of multiple possible formats: either a single or list of output objects
from <code>jagsUI</code> with an associated vector of parameter names, or a vector or <code>data.frame</code>
of posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdens(
  df,
  p = NULL,
  exact = FALSE,
  add = FALSE,
  col = NULL,
  shade = TRUE,
  lwd = 2,
  minCI = 0.99,
  legend = TRUE,
  legendpos = "topleft",
  legendnames = NULL,
  main = NULL,
  xlab = "",
  ylab = "Density",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdens_+3A_df">df</code></td>
<td>
<p>Input object for plotting.  See examples below.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_p">p</code></td>
<td>
<p>Vector of parameter names, if <code>df</code> is given as a single or list of output objects
from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="plotdens_+3A_exact">exact</code></td>
<td>
<p>Whether the <code style="white-space: pre;">&#8288;p=&#8288;</code> argument should match the parameter name exactly.  See
<a href="#topic+jags_df">jags_df</a> for details.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_add">add</code></td>
<td>
<p>Whether to add to an existing plot (<code>TRUE</code>) or produce a new plot.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_col">col</code></td>
<td>
<p>Vector of colors for plotting.  If the default (<code>NULL</code>) is accepted,
colors will be automatically selected.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_shade">shade</code></td>
<td>
<p>Whether to shade the regions below the kernel density curve(s).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_lwd">lwd</code></td>
<td>
<p>Line width for kernel density curves.  Defaults to <code>2</code>.  Note: setting
this to <code>0</code> (or <code>FALSE</code>) will suppress lines.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_minci">minCI</code></td>
<td>
<p>Minimum CI width to include for all density curves.  Defaults to 99%.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_legend">legend</code></td>
<td>
<p>Whether to plot a legend.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_legendpos">legendpos</code></td>
<td>
<p>Position for automatic legend.  Defaults to <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_legendnames">legendnames</code></td>
<td>
<p>Names for legend</p>
</td></tr>
<tr><td><code id="plotdens_+3A_main">main</code></td>
<td>
<p>Plot title.  Defaults to &quot;&quot;.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.  Defaults to &quot;&quot;.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.  Defaults to &quot;Density&quot;.</p>
</td></tr>
<tr><td><code id="plotdens_+3A_...">...</code></td>
<td>
<p>Optional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+comparedens">comparedens</a>, <a href="#topic+comparecat">comparecat</a>, <a href="#topic+comparepriors">comparepriors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## jagsUI object with a single parameter
plotdens(asdf_jags_out, p="b1")

## jagsUI object with multiple nodes of a parameter
plotdens(asdf_jags_out, p="a")

## jagsUI object with multiple parameter nodes
plotdens(asdf_jags_out, p=c("a[1]","a[2]","a[3]"))

## data.frame with multiple columns
plotdens(jags_df(asdf_jags_out, p="a"))

## list of jagsUI objects with a single parameter name
plotdens(list(asdf_jags_out,asdf_jags_out,asdf_jags_out), p="b1")

## list of jagsUI objects with a vector of parameter names
plotdens(list(asdf_jags_out,asdf_jags_out,asdf_jags_out), p=c("a[1]","a[2]","a[3]"))
</code></pre>

<hr>
<h2 id='plotRhats'>Plotting all Rhat values</h2><span id='topic+plotRhats'></span>

<h3>Description</h3>

<p>Plotting all values of <code>Rhat</code> (or alternately <code>n.eff</code>) from an output object returned by <code>jagsUI</code>, or perhaps a subset of parameters.
This function is intended as a quick graphical check of which parameters have adequately converged.
</p>
<p><code>Rhat</code> (Gelman-Rubin Convergence Diagnostic, or Potential Scale Reduction Factor)
is calculated within 'JAGS', and is
commonly used as a measure of convergence for a given parameter node.  Values close
to 1 are seen as evidence of adequate convergence.  <code>n.eff</code> is also calculated within 'JAGS', and may be interpreted as a crude measure of
effective sample size for a given parameter node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRhats(
  x,
  p = NULL,
  n.eff = FALSE,
  fence = NULL,
  plotsequence = FALSE,
  splitarr = FALSE,
  margin = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRhats_+3A_x">x</code></td>
<td>
<p>Output object returned from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="plotRhats_+3A_p">p</code></td>
<td>
<p>Optional vector of parameters to subset</p>
</td></tr>
<tr><td><code id="plotRhats_+3A_n.eff">n.eff</code></td>
<td>
<p>Optionally, whether to plot <code>n.eff</code> instead of <code>Rhat</code>.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotRhats_+3A_fence">fence</code></td>
<td>
<p>Value of horizontal lines to overlay as reference.  Accepting the default value (<code>NULL</code>) will give <code>fence</code> values
of 1.1 (a commonly used value) and 1.01 for Rhat, or 100 and 500 for <code>n.eff.</code></p>
</td></tr>
<tr><td><code id="plotRhats_+3A_plotsequence">plotsequence</code></td>
<td>
<p>Whether to plot parameter vectors (or matrices) in a sequence, running left to right, which may
be useful for time series models, etc.  If the default (<code>FALSE</code>) is used, a vertical cluster will be plotted
for each parameter, resulting in a simpler plot if there are many parameters.  Note that the <code>Rhat</code> values will still be
plotted in sequence if the default (<code>FALSE</code>) is used.</p>
</td></tr>
<tr><td><code id="plotRhats_+3A_splitarr">splitarr</code></td>
<td>
<p>Whether to split 2+ dimensional parameter arrays by a given dimension, rather than plotting the full
array in one vertical cluster or continuous sequence.  This may be recommended in the case of large arrays.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotRhats_+3A_margin">margin</code></td>
<td>
<p>If <code style="white-space: pre;">&#8288;splitarr=&#8288;</code> is set to <code>TRUE</code>, which array margin to split by.  In the case of a 2-dimensional array, setting
<code>margin=2</code> will separate the array by column.  If the default (<code>NULL</code>) is accepted, the function will split by the smallest dimension,
therefore splitting into the fewest groups.</p>
</td></tr>
<tr><td><code id="plotRhats_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>References</h3>

<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from Iterative Simulation
Using Multiple Sequences. <em>Statistical Science, 7</em>(4), 457â€“472. http://www.jstor.org/stable/2246093
</p>


<h3>See Also</h3>

<p><a href="#topic+traceworstRhat">traceworstRhat</a>, <a href="#topic+check_Rhat">check_Rhat</a>, <a href="#topic+qq_postpred">qq_postpred</a>, <a href="#topic+ts_postpred">ts_postpred</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plotting everything
plotRhats(SS_out)
str(SS_out$Rhat)  # the associated values

plotRhats(SS_out, n.eff=TRUE)
str(SS_out$n.eff)  # the associated values

## behavior of splitarr and margin are shown
plotRhats(SS_out)
plotRhats(SS_out, splitarr=TRUE)
str(SS_out$Rhat) # the associated values

## plotsequence may be useful in the case of a sequence of values
plotRhats(SS_out, p=c("trend", "cycle_s"), splitarr=TRUE, plotsequence=TRUE)
</code></pre>

<hr>
<h2 id='pull_post'>Subset from posterior data.frame</h2><span id='topic+pull_post'></span>

<h3>Description</h3>

<p>Extracts a subset vector or <code>data.frame</code> from a <code>data.frame</code> consisting of more columns,
such that column names match a name given in the <code style="white-space: pre;">&#8288;p=&#8288;</code> argument.  This may be useful
in creating smaller objects consisting of MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_post(x, p = NULL, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_post_+3A_x">x</code></td>
<td>
<p>Posterior <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pull_post_+3A_p">p</code></td>
<td>
<p>String to begin posterior names.  If <code>NULL</code> is used, all parameters will be returned.</p>
</td></tr>
<tr><td><code id="pull_post_+3A_exact">exact</code></td>
<td>
<p>Whether name must be an exact match (<code>TRUE</code>) or with initial sub-string matching only supplied characters (<code>FALSE</code>).
Defaults to <code>FALSE.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a column associated with each (subsetted) parameter and a row
associated with each MCMC iteration.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+jags_df">jags_df</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out_df &lt;- jags_df(asdf_jags_out)

b &lt;- pull_post(out_df, p="b")
str(b)
a &lt;- pull_post(out_df, p=c("a","sig_a"))
str(a)
sigs &lt;- pull_post(out_df, p="sig")
str(sigs)
justsig &lt;- pull_post(out_df, p="sig", exact=TRUE)
str(justsig)
</code></pre>

<hr>
<h2 id='qq_postpred'>Quantile-quantile plot from posterior predictive distribution</h2><span id='topic+qq_postpred'></span>

<h3>Description</h3>

<p>Produces a quantile-quantile plot, calculated from the quantiles of
a vector of data (most likely a time series), with respect to the matrix of associated posterior
predictive distributions.
</p>
<p>While not an omnibus posterior predictive check, this plot can be useful
for detecting an overparameterized model, or else improper specification
of observation error.  Like a traditional Q-Q plot, a well-specified model
will have points that lie close to the x=y line.  In the case of this
function, an overparametrized model will typically produce a plot with a
much shallower slope, possibly with many associated posterior predictive quantiles close
to 0.5.
</p>
<p>It should be noted that this function will only produce meaningful results
with a vector of data, as opposed to a single value.
</p>
<p>The posterior predictive distribution can be specified in two possible ways:
either a single output object from <code>jagsUI</code> with an associated parameter
name, or as a matrix or <code>data.frame</code> of posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq_postpred(ypp, y, p = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_postpred_+3A_ypp">ypp</code></td>
<td>
<p>Either a matrix or <code>data.frame</code> of posterior samples, or an
output object returned from <code>jagsUI</code> and a supplied parameter name</p>
</td></tr>
<tr><td><code id="qq_postpred_+3A_y">y</code></td>
<td>
<p>The associated data vector</p>
</td></tr>
<tr><td><code id="qq_postpred_+3A_p">p</code></td>
<td>
<p>A character name, if a <code>jagsUI</code> object is passed to <code>ypp</code></p>
</td></tr>
<tr><td><code id="qq_postpred_+3A_add">add</code></td>
<td>
<p>Whether to add the plot to an existing plot.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qq_postpred_+3A_...">...</code></td>
<td>
<p>Optional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Note</h3>

<p>This function assumes the existence of a matrix of posterior predictive
samples corresponding to a data vector, the construction of which must be
left to the user.  This can be accomplished within JAGS, or using appropriate
simulation from the posterior samples.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+ts_postpred">ts_postpred</a>, <a href="#topic+check_Rhat">check_Rhat</a>, <a href="#topic+check_neff">check_neff</a>, <a href="#topic+traceworstRhat">traceworstRhat</a>, <a href="#topic+plotRhats">plotRhats</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first, a quick look at the example data...
str(SS_data)
str(SS_out$sims.list$ypp)

# plotting the example posterior predictive distribution with the data
# points overlayed.  Note the overdispersion in the posterior predictive.
caterpillar(SS_out, p="ypp")
points(SS_data$y)

# using a jagsUI object as ypp input
qq_postpred(ypp=SS_out, p="ypp", y=SS_data$y)

# using a matrix as ypp input
qq_postpred(ypp=SS_out$sims.list$ypp, y=SS_data$y)
</code></pre>

<hr>
<h2 id='rcolors'>Random Colors</h2><span id='topic+rcolors'></span>

<h3>Description</h3>

<p>Creates a vector of randomly-generated colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcolors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcolors_+3A_n">n</code></td>
<td>
<p>Vector length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
cols &lt;- rcolors(n)
x &lt;- runif(n)
y &lt;- runif(n)
plot(x,y, col=cols, pch=16)
</code></pre>

<hr>
<h2 id='skeleton'>Skeleton</h2><span id='topic+skeleton'></span>

<h3>Description</h3>

<p>Prints an example 'JAGS' model and associated 'jagsUI' code to
the console, along with code to simulate a corresponding dataset.  This is
intended to serve as a template that can be altered as needed by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeleton(NAME = "NAME")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeleton_+3A_name">NAME</code></td>
<td>
<p>Name to append to JAGS model object, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Note</h3>

<p>The printed code will use the <code>cat()</code> function to write the model code to an
external text file.  It may be desirable to use a call to <code style="white-space: pre;">&#8288;\link{tempfile}()&#8288;</code>
instead, to eliminate creation of unneeded files.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton("asdf")
</code></pre>

<hr>
<h2 id='SS_data'>Example data: Time series associated with SS JAGS out</h2><span id='topic+SS_data'></span>

<h3>Description</h3>

<p>The time series and time measurements associated with the time series model <code style="white-space: pre;">&#8288;\link{SS_out}&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 41 rows and 2 columns.
</p>

<hr>
<h2 id='SS_out'>Example data: SS JAGS out</h2><span id='topic+SS_out'></span>

<h3>Description</h3>

<p>A time series model with multiple observations of a single time series, and with two stochastic cycle components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS_out
</code></pre>


<h3>Format</h3>

<p>An object of class <code>jagsUI</code> of length 24.
</p>


<h3>Details</h3>

<p>This model is included partly to show a model with vectors or 2-dimensional
matrices of parameter nodes, and also to give an example of poor model convergence.
</p>

<hr>
<h2 id='trace_df'>Trace plot of each column of a <code>data.frame</code>.</h2><span id='topic+trace_df'></span>

<h3>Description</h3>

<p>Trace plot of each column of a posterior 'data.frame'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_df(df, nline, parmfrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_df_+3A_df">df</code></td>
<td>
<p>Posterior data.frame</p>
</td></tr>
<tr><td><code id="trace_df_+3A_nline">nline</code></td>
<td>
<p>Number of chains</p>
</td></tr>
<tr><td><code id="trace_df_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="trace_df_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments to <code>trace_line()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+trace_jags">trace_jags</a>, <a href="#topic+trace_line">trace_line</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- jags_df(asdf_jags_out, p="a")

trace_df(a, nline=3, parmfrow=c(3,1))
</code></pre>

<hr>
<h2 id='trace_jags'>Trace plot of jagsUI object</h2><span id='topic+trace_jags'></span>

<h3>Description</h3>

<p>Trace plot of a whole <code>jagsUI</code> object, or optional subset of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_jags(x, p = NULL, exact = FALSE, parmfrow = NULL, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_jags_+3A_x">x</code></td>
<td>
<p>Posterior <code>jagsUI</code> object</p>
</td></tr>
<tr><td><code id="trace_jags_+3A_p">p</code></td>
<td>
<p>Parameter name for subsetting: if this is specified, only parameters with names beginning with this string will be plotted.</p>
</td></tr>
<tr><td><code id="trace_jags_+3A_exact">exact</code></td>
<td>
<p>Whether <code>p</code> should be an exact match (<code>TRUE</code>) or just match the
beginning of the string (<code>FALSE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="trace_jags_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="trace_jags_+3A_lwd">lwd</code></td>
<td>
<p>Line width for plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="trace_jags_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+pairstrace_jags">pairstrace_jags</a>, <a href="#topic+trace_df">trace_df</a>, <a href="#topic+trace_line">trace_line</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trace_jags(asdf_jags_out, parmfrow=c(4,2))
trace_jags(asdf_jags_out, p="a", parmfrow=c(3,1))
</code></pre>

<hr>
<h2 id='trace_line'>Simple trace plot</h2><span id='topic+trace_line'></span>

<h3>Description</h3>

<p>Trace plot of a single parameter node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_line(x, nline, lwd = 1, main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_line_+3A_x">x</code></td>
<td>
<p>Posterior vector</p>
</td></tr>
<tr><td><code id="trace_line_+3A_nline">nline</code></td>
<td>
<p>Number of MCMC chains</p>
</td></tr>
<tr><td><code id="trace_line_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="trace_line_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="trace_line_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+tracedens_jags">tracedens_jags</a>, <a href="#topic+trace_jags">trace_jags</a>, <a href="#topic+trace_df">trace_df</a>, <a href="#topic+chaindens_line">chaindens_line</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- jags_df(asdf_jags_out, p="b1")

trace_line(b1, nline=3, main="b1")
</code></pre>

<hr>
<h2 id='tracedens_jags'>Combination of trace plots and by-chain kernel densities of <code>jagsUI</code> object</h2><span id='topic+tracedens_jags'></span>

<h3>Description</h3>

<p>Combination of trace plots and by-chain kernel densities of a whole <code>jagsUI</code> object, or optional subset of parameter nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracedens_jags(
  x,
  p = NULL,
  exact = FALSE,
  parmfrow = NULL,
  lwd = 1,
  shade = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracedens_jags_+3A_x">x</code></td>
<td>
<p>Posterior <code>jagsUI</code> object</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_p">p</code></td>
<td>
<p>Parameter name for subsetting: if this is specified, only parameters with names beginning with this string will be plotted.</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_exact">exact</code></td>
<td>
<p>Whether <code>p</code> should be an exact match (<code>TRUE</code>) or just match the
beginning of the string (<code>FALSE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_lwd">lwd</code></td>
<td>
<p>Line width for plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_shade">shade</code></td>
<td>
<p>Whether to add semi-transparent shading to by-chain kernel densities.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tracedens_jags_+3A_...">...</code></td>
<td>
<p>additional plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+trace_jags">trace_jags</a>, <a href="#topic+chaindens_jags">chaindens_jags</a>, <a href="#topic+pairstrace_jags">pairstrace_jags</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tracedens_jags(asdf_jags_out, parmfrow=c(4,2))
tracedens_jags(asdf_jags_out, p="a", parmfrow=c(3,1))
</code></pre>

<hr>
<h2 id='traceworstRhat'>Trace plots corresponding to the worst values of Rhat</h2><span id='topic+traceworstRhat'></span>

<h3>Description</h3>

<p>Trace plots with kernel densities will be created for parameters with the largest (worst) associated values of <code>Rhat</code>.
This function is primarily intended for parameters with a vector (or array) of values.
</p>
<p><code>Rhat</code> (Gelman-Rubin Convergence Diagnostic, or Potential Scale Reduction Factor)
is calculated within 'JAGS', and is
commonly used as a measure of convergence for a given parameter node.  Values close
to 1 are seen as evidence of adequate convergence.  <code>n.eff</code> is also calculated within 'JAGS', and may be interpreted as a crude measure of
effective sample size for a given parameter node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceworstRhat(x, p = NULL, n.eff = FALSE, margin = NULL, parmfrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceworstRhat_+3A_x">x</code></td>
<td>
<p>Output object returned from <code>jagsUI</code></p>
</td></tr>
<tr><td><code id="traceworstRhat_+3A_p">p</code></td>
<td>
<p>Optional vector of parameters to subset</p>
</td></tr>
<tr><td><code id="traceworstRhat_+3A_n.eff">n.eff</code></td>
<td>
<p>Whether to plot parameters with the smallest associated values of <code>n.eff</code> instead.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="traceworstRhat_+3A_margin">margin</code></td>
<td>
<p>In the case of a 2+ dimensional array associated with a given parameter, this will have the effect
of plotting the worst <code>Rhat</code> corresponding to each margin specified.  For example, specifying <code>margin=2</code> (column)
will plot the parameter with the worst <code>Rhat</code> value from each column.  In contrast, specifying <code>margin=NULL</code> (the default)
will cause the function to plot the single array element with the largest Rhat value.</p>
</td></tr>
<tr><td><code id="traceworstRhat_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional call to <code>par(mfrow)</code> for the number of rows &amp; columns of plot window.  Returns the graphics device to previous state afterward.</p>
</td></tr>
<tr><td><code id="traceworstRhat_+3A_...">...</code></td>
<td>
<p>additional plotting arguments or arguments to <code>tracedens_jags()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>References</h3>

<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from Iterative Simulation
Using Multiple Sequences. <em>Statistical Science, 7</em>(4), 457â€“472. http://www.jstor.org/stable/2246093
</p>


<h3>See Also</h3>

<p><a href="#topic+plotRhats">plotRhats</a>, <a href="#topic+check_Rhat">check_Rhat</a>, <a href="#topic+qq_postpred">qq_postpred</a>, <a href="#topic+ts_postpred">ts_postpred</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plotting everything
traceworstRhat(SS_out, parmfrow=c(3,2))
SS_out$Rhat  # the associated values

traceworstRhat(SS_out, parmfrow=c(3,2), n.eff=TRUE)
SS_out$n.eff  # the associated values

## in the case of a 2-D array, setting margin=2 gives the max Rhat
## associated with each column, rather than the global max
traceworstRhat(x=SS_out, p="cycle_s", margin=2, parmfrow=c(2,2))
SS_out$Rhat
traceworstRhat(x=SS_out, p="cycle_s", margin=2, parmfrow=c(2,2), n.eff=TRUE)
SS_out$n.eff
</code></pre>

<hr>
<h2 id='ts_postpred'>Time series plot of centered posterior predictive distribution</h2><span id='topic+ts_postpred'></span>

<h3>Description</h3>

<p>Produces a plot of centered posterior predictive distributions
associated with a vector of data (most likely a time series),
defined as the difference between posterior predictive and posterior predictive
median.
</p>
<p>Also overlays the posterior predictive residuals, defined as the differences
between data values and their respective posterior predictive medians.
</p>
<p>While not an omnibus posterior predictive check, this plot can be useful
for detecting an overparameterized model, or else improper specification
of observation error.
</p>
<p>It should be noted that this function will only produce meaningful results
with a vector of data, as opposed to a single value.
</p>
<p>The posterior predictive distribution can be specified in two possible ways:
either a single output object from <code>jagsUI</code> with an associated parameter
name, or as a matrix or <code>data.frame</code> of posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_postpred(
  ypp,
  y,
  p = NULL,
  x = NULL,
  lines = FALSE,
  transform = c("none", "exp", "expit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_postpred_+3A_ypp">ypp</code></td>
<td>
<p>Either a matrix or <code>data.frame</code> of posterior samples, or an
output object returned from <code>jagsUI</code> and a supplied parameter name</p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_y">y</code></td>
<td>
<p>The associated data vector</p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_p">p</code></td>
<td>
<p>A character name, if a <code>jagsUI</code> object is passed to <code>ypp</code></p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_x">x</code></td>
<td>
<p>The time measurements associated with time series <code>y</code>.  If the default
<code>NULL</code> is accepted, equally-spaced integer values will be used.</p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_lines">lines</code></td>
<td>
<p>Whether to add a line linking data time series points.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_transform">transform</code></td>
<td>
<p>Should the y-axis be (back)transformed?  Options are <code>"exp"</code>,
indicating exponential, or <code>"expit"</code>, indicating inverse-logit. Defaults to
<code>"none"</code>, indicating no transformation.  Note: if <code>transform="exp"</code>is used, consider
adding additional plotting argument <code>log="y"</code>.</p>
</td></tr>
<tr><td><code id="ts_postpred_+3A_...">...</code></td>
<td>
<p>Additional arguments to <a href="#topic+envelope">envelope</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Note</h3>

<p>This function assumes the existence of a matrix of posterior predictive
samples corresponding to a data vector, the construction of which must be
left to the user.  This can be accomplished within JAGS, or using appropriate
simulation from the posterior samples.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+qq_postpred">qq_postpred</a>, <a href="#topic+check_Rhat">check_Rhat</a>, <a href="#topic+check_neff">check_neff</a>, <a href="#topic+traceworstRhat">traceworstRhat</a>, <a href="#topic+plotRhats">plotRhats</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first, a quick look at the example data...
str(SS_data)
str(SS_out$sims.list$ypp)

# plotting the example posterior predictive distribution with the data
# points overlayed.  Note the overdispersion in the posterior predictive.
caterpillar(SS_out, p="ypp")
points(SS_data$y)

# using a jagsUI object as ypp input
ts_postpred(ypp=SS_out, p="ypp", y=SS_data$y)

# using a matrix as ypp input
ts_postpred(ypp=SS_out$sims.list$ypp, y=SS_data$y)

# exp transformation
ts_postpred(ypp=SS_out, p="ypp", y=SS_data$y, transform="exp")
ts_postpred(ypp=SS_out, p="ypp", y=SS_data$y, transform="exp", log="y")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
