<!DOCTYPE html><html><head><title>Help for package metaSDTreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metaSDTreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.metaSDTreg'><p>Coefficients method for metaSDTreg</p></a></li>
<li><a href='#lines.predict_roc'><p>Lines of predicted ROC curve</p></a></li>
<li><a href='#logLik.metaSDTreg'><p>Log-likelihood of metaSDTreg</p></a></li>
<li><a href='#metaSDT.loglik'><p>Meta-SDT log-likelihood</p></a></li>
<li><a href='#metaSDTcontrol'><p>Control for metaSDTreg</p></a></li>
<li><a href='#metaSDTdata'><p>Construct metaSDTdata</p></a></li>
<li><a href='#metaSDTreg'><p>Meta-SDT regression</p></a></li>
<li><a href='#plot.predict_roc'><p>Plot predicted ROC curve</p></a></li>
<li><a href='#points.predict_roc'><p>Points from predicted ROC curve</p></a></li>
<li><a href='#predict_roc'><p>Generic predict_roc method</p></a></li>
<li><a href='#predict_roc.metaSDTdata'><p>Observed ROC points</p></a></li>
<li><a href='#predict_roc.metaSDTreg'><p>Predicted ROC curve</p></a></li>
<li><a href='#print.metaSDTdata'><p>Print method for metaSDT data</p></a></li>
<li><a href='#print.metaSDTreg'><p>Print method for metaSDTreg</p></a></li>
<li><a href='#print.summary.metaSDTdata'><p>Print method for a summary.metaSDTdata object</p></a></li>
<li><a href='#print.summary.metaSDTreg'><p>Print summary method for metaSDTreg</p></a></li>
<li><a href='#ROCcoords'><p>Extract coordinates for predicted ROC curve</p></a></li>
<li><a href='#simMetaData'><p>Simulated metacognition experiment</p></a></li>
<li><a href='#starting.vals.PPO'><p>Starting values from PPO</p></a></li>
<li><a href='#summary.metaSDTdata'><p>Summarise a metaSDTdata object as a cognitive experiment.</p></a></li>
<li><a href='#summary.metaSDTreg'><p>Summary method for metaSDTreg</p></a></li>
<li><a href='#vcov.metaSDTreg'><p>Variance-covariance method for metaSDTreg</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression Models for Meta Signal Detection Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Regression methods for the meta-SDT model. The package implements methods for cognitive experiments of metacognition as described in Kristensen, S. B., Sandberg, K., &amp; Bibby, B. M. (2020). Regression methods for metacognitive sensitivity. Journal of Mathematical Psychology, 94. &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2019.102297">doi:10.1016/j.jmp.2019.102297</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2), ordinal (&ge; 2022.11-16),</td>
</tr>
<tr>
<td>Imports:</td>
<td>maxLik (&ge; 1.5-2), truncnorm (&ge; 1.0-8), Matrix (&ge; 1.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-22 09:29:50 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Bang Kristensen [aut, cre],
  Kristian Sandberg [aut],
  Bo Martin Bibby [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Bang Kristensen &lt;simonbk@ph.au.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.metaSDTreg'>Coefficients method for metaSDTreg</h2><span id='topic+coef.metaSDTreg'></span>

<h3>Description</h3>

<p>Coefficients method for metaSDTreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.metaSDTreg_+3A_object">object</code></td>
<td>
<p>An object of class metaSDTreg.</p>
</td></tr>
<tr><td><code id="coef.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)
coef(fit)

</code></pre>

<hr>
<h2 id='lines.predict_roc'>Lines of predicted ROC curve</h2><span id='topic+lines.predict_roc'></span>

<h3>Description</h3>

<p>Plot lines method for objects of class 'predict_roc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_roc'
lines(x, thr = seq(-10, 10, length = 1000), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.predict_roc_+3A_x">x</code></td>
<td>
<p>A 'predict_roc' object to plot.</p>
</td></tr>
<tr><td><code id="lines.predict_roc_+3A_thr">thr</code></td>
<td>
<p>The sequence of thresholds parametrising the ROC curve, if this is a function. Default to a length 1000 sequence from -10 to 10.</p>
</td></tr>
<tr><td><code id="lines.predict_roc_+3A_...">...</code></td>
<td>
<p>Addtional arguments passed to <code>lines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)

## Plot observed type 1 ROC points
plot(predict_roc(metadata, type = '1'), xlim = 0:1, ylim = 0:1)

## Add Model-predicted ROC curve (estimated from subset of data)
lines(predict_roc(fit, type = '1'))

</code></pre>

<hr>
<h2 id='logLik.metaSDTreg'>Log-likelihood of metaSDTreg</h2><span id='topic+logLik.metaSDTreg'></span>

<h3>Description</h3>

<p>Extract the log-likelihood from a metaSDTreg object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.metaSDTreg_+3A_object">object</code></td>
<td>
<p>Object of class 'metaSDTreg'.</p>
</td></tr>
<tr><td><code id="logLik.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For further methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, the likelihood at the maximum found by the optimisation procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)
logLik(fit)

</code></pre>

<hr>
<h2 id='metaSDT.loglik'>Meta-SDT log-likelihood</h2><span id='topic+metaSDT.loglik'></span>

<h3>Description</h3>

<p>Meta SDT log-likelihood function, internal function. Used by <code>metaSDTreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaSDT.loglik(parm, df, A, X, X.n = NULL, X.s = NULL, L0, K0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metaSDT.loglik_+3A_parm">parm</code></td>
<td>
<p>Parameters of the model, c(intercepts^T,d.n,d,d.s,beta^T)^T, where length(intercepts)=K0-1 and lenght(beta)=ncol(X).</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_df">df</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_a">A</code></td>
<td>
<p>Matrix of responses</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_x">X</code></td>
<td>
<p>Matrix of covariates</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_x.n">X.n</code></td>
<td>
<p>Presently not in use</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_x.s">X.s</code></td>
<td>
<p>Presently not in use</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_l0">L0</code></td>
<td>
<p>Levels of the type 2 task</p>
</td></tr>
<tr><td><code id="metaSDT.loglik_+3A_k0">K0</code></td>
<td>
<p>Levels of the ordinal variable A</p>
</td></tr>
</table>

<hr>
<h2 id='metaSDTcontrol'>Control for metaSDTreg</h2><span id='topic+metaSDTcontrol'></span>

<h3>Description</h3>

<p>Control function for metaSDTreg.
The function allows passing arguments to the maxLik and clm procedure used for optimisation and starting values, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaSDTcontrol(
  meth = "BFGS",
  start.vals = NULL,
  hessianMeth = TRUE,
  returnMaxLik = FALSE,
  loglikUse = c("R", "C++"),
  scoreFun = FALSE,
  c.maxLik = list(),
  c.clm = list(maxIter = 1000, maxModIter = 20),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metaSDTcontrol_+3A_meth">meth</code></td>
<td>
<p>Method used by maxLik to perform maximisation, which must support constrained optimisation, see <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>. Defaults to 'BFGS'.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_start.vals">start.vals</code></td>
<td>
<p>Starting values for the maximisation algorithm. Any NA entries will be set to zero. Defaults to NULL, in which case starting values will be obtained from the partial proportional odds model as implemented in the package <span class="pkg">ordinal</span> using <code><a href="ordinal.html#topic+clm">clm</a></code>.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_hessianmeth">hessianMeth</code></td>
<td>
<p>Method to compute the Hessian of the optimisation. Passed to the argument finalHessian in <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_returnmaxlik">returnMaxLik</code></td>
<td>
<p>Should the function return the fit object from <code><a href="maxLik.html#topic+maxLik">maxLik</a></code> rather that the <code><a href="#topic+metaSDTreg">metaSDTreg</a></code> object? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_loglikuse">loglikUse</code></td>
<td>
<p>For testing purposes. The C++ option is not presently included. Should the procedure use the log-likelihood implemented in R (default), or that in C++? Option will be dropped in future versions.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_scorefun">scoreFun</code></td>
<td>
<p>For testing purposes. Should the optimisation procedure use the analytic score function? If FALSE (and 'meth' relies on gradients) numerical methods are used. Presently, only numerical methods are implemented. Defaults to FALSE. Option default may change in future versions.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_c.maxlik">c.maxLik</code></td>
<td>
<p>A list that is passed to the 'MaxControl' object in <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>. The list should contain control arguments to be passed to the maximisation method used by maxLik (the default being maxBFGS). In particular, 'iterlim' is the number of iterations (default 200) and a larger number of 'printlevel' (default 0) prints more information from the maximisation procedure.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_c.clm">c.clm</code></td>
<td>
<p>A list that is passed to clm.control containing controls to be used by <code><a href="ordinal.html#topic+clm">clm</a></code>. The clm is used to determine starting values. By default, maxIter is set to 1000 and maxModIter is set to 20.</p>
</td></tr>
<tr><td><code id="metaSDTcontrol_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'metaSDTcontrol' containing the control arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(metaSDTcontrol())

</code></pre>

<hr>
<h2 id='metaSDTdata'>Construct metaSDTdata</h2><span id='topic+metaSDTdata'></span>

<h3>Description</h3>

<p>Constructor function for a metaSDTdata object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaSDTdata(data, type1, type2, signal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metaSDTdata_+3A_data">data</code></td>
<td>
<p>Data frame to be converted. Data should be in long format with one row corresponding to a single response.</p>
</td></tr>
<tr><td><code id="metaSDTdata_+3A_type1">type1</code></td>
<td>
<p>A string naming the variable containing the type 1 response, which should be an ordered factor with two levels where the first level corresponds to 'noise',</p>
</td></tr>
<tr><td><code id="metaSDTdata_+3A_type2">type2</code></td>
<td>
<p>A string naming the variable containing the ordinal type 2 response, which should be an ordered factor.</p>
</td></tr>
<tr><td><code id="metaSDTdata_+3A_signal">signal</code></td>
<td>
<p>A string naming the variable containing the signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type1 or type 2 is not an ordered factor, the function returns a warning. The function constructs a data frame containing variables named c('type1','type2','A','signal') along with any other variable in 'data' that is not given as an argument to the function. Because of this a warning is issued when the names c('type1','type2','A','signal') are present in 'data'.
</p>


<h3>Value</h3>

<p>A data object of class 'metaSDTdata'. This has attributes 'L', the number of levels in the ordinal type 2 rating, and 'K' which is two times L (the number of levels of the ordinal variable 'A').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

summary(metadata)
summary.data.frame(metadata)

</code></pre>

<hr>
<h2 id='metaSDTreg'>Meta-SDT regression</h2><span id='topic+metaSDTreg'></span>

<h3>Description</h3>

<p>Fit the meta SDT regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaSDTreg(
  formula,
  data,
  subset,
  na.action = na.fail,
  control = metaSDTcontrol()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metaSDTreg_+3A_formula">formula</code></td>
<td>
<p>Formula specifying the regression model. Presently, the left-hand side should be the ordinal variable A, while the right-hand side must contain the signal variable from the metaSDTdata object. Note that the variable 'signal' has a special interpretation in the model, see 'Details' below.</p>
</td></tr>
<tr><td><code id="metaSDTreg_+3A_data">data</code></td>
<td>
<p>Data frame to fit the model on. Should be declared as metaSDTdata using the <code><a href="#topic+metaSDTdata">metaSDTdata</a></code> function.</p>
</td></tr>
<tr><td><code id="metaSDTreg_+3A_subset">subset</code></td>
<td>
<p>Optional argument specifying a subset of the data to be used. A logical statement, which is evaluated in 'data'. Only rows with TRUE are used in the analysis.</p>
</td></tr>
<tr><td><code id="metaSDTreg_+3A_na.action">na.action</code></td>
<td>
<p>Method for handling missing values, see na.action. Default is na.fail which stops the function with an error in the presence of missing values among variables entering 'formula'.</p>
</td></tr>
<tr><td><code id="metaSDTreg_+3A_control">control</code></td>
<td>
<p>Optimisation control, see <code><a href="#topic+metaSDTcontrol">metaSDTcontrol</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data frame should be of class 'metaSDTdata' as constructed by the function <code><a href="#topic+metaSDTdata">metaSDTdata</a></code>. This will contain a variable, 'signal' which presently must be included on the right-hand side of the formula. The left hand side must be the ordinal variable 'A' also contained in the metaSDTdata object.
The 'signal' variable has a special interpretation as its coefficients are the signal sensitivities (type 1 d-prime and the two response specific type 2 sensitivities meta-d-prime). Presently all other variables, as determined by <code>all.vars(update(formula, . ~ . - signal ))</code>, enter proportionally in the model, i.e. they share cofficients across response scale levels. See Kristensen &amp; al. (2020) for details.
This can be written formally as follows (in the notation of Kristensen &amp; al. (2020)): 
</p>
<p style="text-align: center;"><code class="reqn">    V_{\mathcal{N}} = V_{\mathcal{S}} = V ,  </code>
</p>

<p>and <code class="reqn"> \beta_{\mathcal{N}} </code>, <code class="reqn"> \beta_{\mathcal{S}} </code> and <code class="reqn"> \beta </code> agree on all but the first entrance which is the signal sensitivities <code class="reqn"> d_{mathcal{N}} </code>, <code class="reqn"> d_{mathcal{S}} </code> and <code class="reqn"> d </code>, respectively.
Note that 'formula' specifies the mean of the latent variables and not the threshold model. Accordingly, attemps to remove the intercept in 'formula' will be ignored with a warning.
The function fails when the left-hand side of 'formula' is not the ordinal variable 'A' and when 'data' is not a 'metaSDTdata' object. Future versions may be less defensive and simply issue a warning in these cases.
Note that constrained optimisation is used to maximise the likelihood under ordinality of the thresholds. The variance-covariance matrix is not adjusted following the constrained estimation, cf. documentation of <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.
When interpreting results from <code>summary.metaSDTreg()</code> care should be taken regarding the z-testor and associated p-value for threshold parameters, as the distribution of the statistic depends on the null hypothesis which will only be reasonable under special circumstances as in other types of ordinal models.
</p>


<h3>Value</h3>

<p>An object of class 'metaSDTreg'. This is a list object containing,
</p>

<ul>
<li><p> logLik: The log likelihood after optimisation.
</p>
</li>
<li><p> coefficients: Estimated coefficients.
</p>
</li>
<li><p> vcov: Variance-covariance matrix of the maxLik object.
</p>
</li>
<li><p> call: The call issued to metaSDTreg.
</p>
</li>
<li><p> na.act: The NA action.
</p>
</li></ul>



<h3>References</h3>

<p>Kristensen, S. B., Sandberg, K., &amp; Bibby, B. M. (2020). Regression
methods for metacognitive sensitivity. Journal of Mathematical
Psychology, 94. &lt;doi:10.1016/j.jmp.2019.102297&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit function to data of first 20 replications per subject
fit_sub &lt;- metaSDTreg(A ~ signal,
                      data=metadata,
                      subset = m &lt;= 20)
summary(fit_sub)


## Fit model to estimate thresholds and sensitivities
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata)

## True values are
## c(tau.n.2=-0.5, tau.n.1=-0.2, theta=0,
##   tau.s.1=0.8, tau.s.2=1, d.n=0.5, d=1, d.s=0.75)
coef(fit)



</code></pre>

<hr>
<h2 id='plot.predict_roc'>Plot predicted ROC curve</h2><span id='topic+plot.predict_roc'></span>

<h3>Description</h3>

<p>Plot method for objects of class 'predict_roc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_roc'
plot(x, thr = seq(-10, 10, length = 1000), rline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict_roc_+3A_x">x</code></td>
<td>
<p>A 'predict_roc' object to plot.</p>
</td></tr>
<tr><td><code id="plot.predict_roc_+3A_thr">thr</code></td>
<td>
<p>The sequence of thresholds parametrising the ROC curve, if this is a function. Default to a length 1000 sequence from -10 to 10.</p>
</td></tr>
<tr><td><code id="plot.predict_roc_+3A_rline">rline</code></td>
<td>
<p>Logical, should the line of random discrimination be added to the plot? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.predict_roc_+3A_...">...</code></td>
<td>
<p>Addtional arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If neither 'xlab' nor 'ylab' is passed to <code>plot</code> the function supplies default x- and y-axis labels based on the type of ROC curve.
</p>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)

## Model-predicted signal-specific ROC curve
signalROC &lt;- predict_roc(fit, type = 's')
plot(signalROC, type = 'l')

</code></pre>

<hr>
<h2 id='points.predict_roc'>Points from predicted ROC curve</h2><span id='topic+points.predict_roc'></span>

<h3>Description</h3>

<p>Plot points method for objects of class 'predict_roc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict_roc'
points(x, thr = seq(-10, 10, length = 1000), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.predict_roc_+3A_x">x</code></td>
<td>
<p>A 'predict_roc' object to plot.</p>
</td></tr>
<tr><td><code id="points.predict_roc_+3A_thr">thr</code></td>
<td>
<p>The sequence of thresholds parametrising the ROC curve, if this is a function. Default to a length 1000 sequence from -10 to 10.</p>
</td></tr>
<tr><td><code id="points.predict_roc_+3A_...">...</code></td>
<td>
<p>Addtional arguments passed to <code>lines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)

## Plot observed type 1 ROC points
plot(predict_roc(metadata, type = '1'), xlim = 0:1, ylim = 0:1, pch = 'x')

## Add Model-predicted ROC curve (estimated from subset of data)
points(predict_roc(fit, type = '1'))

</code></pre>

<hr>
<h2 id='predict_roc'>Generic predict_roc method</h2><span id='topic+predict_roc'></span>

<h3>Description</h3>

<p>Predict ROC curve from signal detection theory model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_roc(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_roc_+3A_object">object</code></td>
<td>
<p>Signal detection theory model.</p>
</td></tr>
<tr><td><code id="predict_roc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'predict_roc'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_roc.metaSDTreg">predict_roc.metaSDTreg</a></code>, <code><a href="#topic+predict_roc.metaSDTdata">predict_roc.metaSDTdata</a></code>.
</p>

<hr>
<h2 id='predict_roc.metaSDTdata'>Observed ROC points</h2><span id='topic+predict_roc.metaSDTdata'></span>

<h3>Description</h3>

<p>The observed points of the ROC curve from a 'metaSDTdata' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTdata'
predict_roc(object, type = c("1", "n", "s"), s0 = 0, s1 = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_roc.metaSDTdata_+3A_object">object</code></td>
<td>
<p>A 'metaSDTdata' object from which to calculate observed ROC points.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTdata_+3A_type">type</code></td>
<td>
<p>The type of ROC curve to predict. A character string, where '1' requests the type 1 ROC curve, 'n' requests the type 2 noise-specific and 's' the type 2 signal-specific ROC curve.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTdata_+3A_s0">s0</code></td>
<td>
<p>Numeric, the value of object$signal to regard as 'noise'. Defaults to 0.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTdata_+3A_s1">s1</code></td>
<td>
<p>Numeric, the value of object$signal to regard as 'signal'. Defaults to 1.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTdata_+3A_...">...</code></td>
<td>
<p>For future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the type 1 ROC points arise by using each criterion in turn to decide between 'signal' and 'noise'. Since this involves also the type 2 thresholds, such a curve is also sometimes referred to as a 'pseudo' ROC curve.
</p>


<h3>Value</h3>

<p>A matrix two-column matrix of class 'predict_roc' with one row of c(FA, HR) per threshold (FA: False Alarm rate, HR: Hit Rate).
</p>


<h3>References</h3>

<p>Maniscalco, B., &amp; Lau, H. (2014).
Signal Detection Theory Analysis of Type 1 and Type 2 Data: Meta-d , Response-Specific Meta-d , and the Unequal Variance SDT Model.
In S. M. Fleming, &amp; C. D. Frith (Eds.), The Cognitive Neuroscience of Metacognition
(pp. 25 66). : Springer Berlin Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Observed signal-specific ROC curve
signalROC &lt;- predict_roc(metadata, type = 's')

</code></pre>

<hr>
<h2 id='predict_roc.metaSDTreg'>Predicted ROC curve</h2><span id='topic+predict_roc.metaSDTreg'></span>

<h3>Description</h3>

<p>Predict ROC curves from metaSDTreg object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
predict_roc(object, type = c("1", "n", "s"), s0 = 0, s1 = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_roc.metaSDTreg_+3A_object">object</code></td>
<td>
<p>An object of class <code>metaSDTreg</code>.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTreg_+3A_type">type</code></td>
<td>
<p>The type of ROC curve to predict. A character string, where '1' requests the type 1 ROC curve (the default), 'n' requests the type 2 noise-specific and 's' the type 2 signal-specific ROC curve.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTreg_+3A_s0">s0</code></td>
<td>
<p>Numeric, the value of 'signal' to regard as 'noise'. Defaults to 0.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTreg_+3A_s1">s1</code></td>
<td>
<p>Numeric, the value of 'signal' to regard as 'signal'. Defaults to 1.</p>
</td></tr>
<tr><td><code id="predict_roc.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'metaSDTreg' object given to the function must have named coefficients with names as they would be if <code>metaSDTreg</code> is run without user-supplied starting values.
</p>
<p>A ROC curve is a 2-D curve parametrised by some x given by c(FA(x), HR(x)) where FA is the false alarm rate and HR is the hit rate. For example, for type 1 ROC,
</p>
<p style="text-align: center;"><code class="reqn">FA(x) = 1 - pnorm(x - s0*d),</code>
</p>
 
<p style="text-align: center;"><code class="reqn">HR(x) = 1 - pnorm(x - s1*d),</code>
</p>

<p>where <code class="reqn">d</code> is the signal sensitivity.
</p>
<p>Note that the predicted ROC curve is for a reference individual in the regression, i.e. additional covariates are not entered into the ROC so that reparametrisation of the 'metaSDTreg' model is needed to change predictions.
</p>


<h3>Value</h3>

<p>A function of class 'predict_roc' containing the appropriate ROC curve. This is a function of x which returns c(FA,HR), where FA is the false alarm rate and HR is the hit rate.
</p>


<h3>References</h3>

<p>Maniscalco, B., &amp; Lau, H. (2014).
Signal Detection Theory Analysis of Type 1 and Type 2 Data: Meta-d , Response-Specific Meta-d , and the Unequal Variance SDT Model.
In S. M. Fleming, &amp; C. D. Frith (Eds.), The Cognitive Neuroscience of Metacognition
(pp. 25 66). : Springer Berlin Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)

## Model-predicted signal-specific ROC curve
signalROC &lt;- predict_roc(fit, type = 's')

</code></pre>

<hr>
<h2 id='print.metaSDTdata'>Print method for metaSDT data</h2><span id='topic+print.metaSDTdata'></span>

<h3>Description</h3>

<p>Print method for metaSDT data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.metaSDTdata_+3A_x">x</code></td>
<td>
<p>The metaSDTdata object.</p>
</td></tr>
<tr><td><code id="print.metaSDTdata_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to print.data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')
print(metadata)

</code></pre>

<hr>
<h2 id='print.metaSDTreg'>Print method for metaSDTreg</h2><span id='topic+print.metaSDTreg'></span>

<h3>Description</h3>

<p>Print method for metaSDTreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.metaSDTreg_+3A_x">x</code></td>
<td>
<p>An object of class metaSDTreg.</p>
</td></tr>
<tr><td><code id="print.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
(fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20))

</code></pre>

<hr>
<h2 id='print.summary.metaSDTdata'>Print method for a summary.metaSDTdata object</h2><span id='topic+print.summary.metaSDTdata'></span>

<h3>Description</h3>

<p>Print method for a summary.metaSDTdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.metaSDTdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.metaSDTdata_+3A_x">x</code></td>
<td>
<p>A metaSDTdata object.</p>
</td></tr>
<tr><td><code id="print.summary.metaSDTdata_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')
summary(metadata)

</code></pre>

<hr>
<h2 id='print.summary.metaSDTreg'>Print summary method for metaSDTreg</h2><span id='topic+print.summary.metaSDTreg'></span>

<h3>Description</h3>

<p>Print summary method for metaSDTreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.metaSDTreg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.metaSDTreg_+3A_x">x</code></td>
<td>
<p>An object of class summary.metaSDTreg.</p>
</td></tr>
<tr><td><code id="print.summary.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)
summary(fit)

</code></pre>

<hr>
<h2 id='ROCcoords'>Extract coordinates for predicted ROC curve</h2><span id='topic+ROCcoords'></span>

<h3>Description</h3>

<p>Extract coordinates for predicted ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCcoords(x, thr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCcoords_+3A_x">x</code></td>
<td>
<p>A 'predict_roc' object to plot.</p>
</td></tr>
<tr><td><code id="ROCcoords_+3A_thr">thr</code></td>
<td>
<p>The sequence of thresholds parametrising the ROC curve, if this is a function.</p>
</td></tr>
</table>

<hr>
<h2 id='simMetaData'>Simulated metacognition experiment</h2><span id='topic+simMetaData'></span>

<h3>Description</h3>

<p>Data is simulated from the meta-SDT model, formula (3)-(4) in Kristensen, Sandberg and Bibby (2020).
The true values of the simulation parameters are
c(tau.n.2=-0.5, tau.n.1=-0.2, theta=0,
tau.s.1=0.8, tau.s.2=1, d.n=0.5, d=1, d.s=0.75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMetaData
</code></pre>


<h3>Format</h3>

<p>A data frame with 25000 obs. of  5 variables:
</p>

<dl>
<dt>id</dt><dd><p>Subject id.</p>
</dd>
<dt>m</dt><dd><p>Observation id, within subject.</p>
</dd>
<dt>S</dt><dd><p>Signal indicator (0 or 1).</p>
</dd>
<dt>resp</dt><dd><p>Type 1 response (0 or 1).</p>
</dd>
<dt>conf</dt><dd><p>Type 2 response, ordered (1, 2 or 3).</p>
</dd> 
</dl>



<h3>References</h3>

<p>Kristensen, S. B., Sandberg, K., &amp; Bibby, B. M. (2020). Regression
methods for metacognitive sensitivity. Journal of Mathematical
Psychology, 94. &lt;doi:10.1016/j.jmp.2019.102297&gt;.
</p>

<hr>
<h2 id='starting.vals.PPO'>Starting values from PPO</h2><span id='topic+starting.vals.PPO'></span>

<h3>Description</h3>

<p>Used by <code>metaSDTreg</code> to calculate starting values using the partial proportional odds model as implemented in <span class="pkg">ordinal</span>. Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starting.vals.PPO(formula0, data0, control0, L0, K0, n.covar0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starting.vals.PPO_+3A_formula0">formula0</code></td>
<td>
<p>See <code><a href="#topic+metaSDTreg">metaSDTreg</a></code>.</p>
</td></tr>
<tr><td><code id="starting.vals.PPO_+3A_data0">data0</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="starting.vals.PPO_+3A_control0">control0</code></td>
<td>
<p>See <code><a href="#topic+metaSDTcontrol">metaSDTcontrol</a></code>.</p>
</td></tr>
<tr><td><code id="starting.vals.PPO_+3A_l0">L0</code></td>
<td>
<p>Number of levels in ordinal type 2 response.</p>
</td></tr>
<tr><td><code id="starting.vals.PPO_+3A_k0">K0</code></td>
<td>
<p>Number of levels of ordinal response 'A'.</p>
</td></tr>
<tr><td><code id="starting.vals.PPO_+3A_n.covar0">n.covar0</code></td>
<td>
<p>Number of covariates aside from the 'signal' variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls the <code><a href="ordinal.html#topic+clm">clm</a></code> function using <code>all.vars(update(formula0, . ~ . - signal))</code> as the formula argument and using <code>~ signal</code> as the nominal argument (also see <code><a href="#topic+metaSDTreg">metaSDTreg</a></code> for the meaning of the signal variable).
The coefficients of the signal variable are weighted together within the noise- and signal-specific type 2 responses using their inverse standard errors as weights.
</p>


<h3>Value</h3>

<p>A named vector of starting values.
</p>

<hr>
<h2 id='summary.metaSDTdata'>Summarise a metaSDTdata object as a cognitive experiment.</h2><span id='topic+summary.metaSDTdata'></span>

<h3>Description</h3>

<p>Summarise a metaSDTdata object as a cognitive experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.metaSDTdata_+3A_object">object</code></td>
<td>
<p>The metaSDTdata object.</p>
</td></tr>
<tr><td><code id="summary.metaSDTdata_+3A_...">...</code></td>
<td>
<p>Additional arguments. Presently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'summary.metaSDTdata' containing summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')
summary(metadata)

</code></pre>

<hr>
<h2 id='summary.metaSDTreg'>Summary method for metaSDTreg</h2><span id='topic+summary.metaSDTreg'></span>

<h3>Description</h3>

<p>Summary method for metaSDTreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.metaSDTreg_+3A_object">object</code></td>
<td>
<p>An object of class metaSDTreg.</p>
</td></tr>
<tr><td><code id="summary.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'summary.metaSDTreg' containing summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)
summary(fit)

</code></pre>

<hr>
<h2 id='vcov.metaSDTreg'>Variance-covariance method for metaSDTreg</h2><span id='topic+vcov.metaSDTreg'></span>

<h3>Description</h3>

<p>Variance-covariance method for metaSDTreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metaSDTreg'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.metaSDTreg_+3A_object">object</code></td>
<td>
<p>An object of class metaSDTreg.</p>
</td></tr>
<tr><td><code id="vcov.metaSDTreg_+3A_...">...</code></td>
<td>
<p>For future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of variances and covariances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare simulated data as metaSDTdata
metadata &lt;- metaSDTdata(simMetaData, type1='resp', type2='conf', signal='S')

## Fit model to subset of data
fit &lt;- metaSDTreg(A ~ signal,
            data=metadata,
            subset = m &lt;= 20)

## Standard errors
sqrt(diag(vcov(fit)))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
