<!DOCTYPE html><html lang="en"><head><title>Help for package popkin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {popkin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#popkin-package'><p>A package for estimating kinship and FST under arbitrary population structure</p></a></li>
<li><a href='#admix_label_cols'><p>Label ancestries based on best match to individual labels</p></a></li>
<li><a href='#admix_order_cols'><p>Reorder admixture matrix columns</p></a></li>
<li><a href='#avg_kinship_subpops'><p>Calculate a kinship matrix between subpopulations by averaging individual data</p></a></li>
<li><a href='#fst'><p>Calculate FST from a population-level kinship matrix or vector of inbreeding coefficients</p></a></li>
<li><a href='#hgdp_subset'><p>HGDP subset</p></a></li>
<li><a href='#inbr'><p>Extract inbreeding coefficients from a kinship matrix</p></a></li>
<li><a href='#inbr_diag'><p>Replace kinship diagonal with inbreeding coefficients</p></a></li>
<li><a href='#mean_kinship'><p>Calculate the weighted mean kinship</p></a></li>
<li><a href='#n_eff'><p>Calculates the effective sample size of the data</p></a></li>
<li><a href='#plot_admix'><p>Make a structure/admixture plot</p></a></li>
<li><a href='#plot_phylo'><p>Plot a <code>phylo</code> tree object</p></a></li>
<li><a href='#plot_popkin'><p>Visualize one or more kinship matrices and other related objects</p></a></li>
<li><a href='#popkin'><p>Estimate kinship from a genotype matrix and subpopulation assignments</p></a></li>
<li><a href='#popkin_A'><p>Compute popkin's <code>A</code> and <code>M</code> matrices from genotypes</p></a></li>
<li><a href='#popkin_A_min_subpops'><p>Estimate the minimum expected value of a matrix <code>A</code> using subpopulations</p></a></li>
<li><a href='#popkin_af'><p>Estimate coancestry from an allele frequency matrix and subpopulation assignments</p></a></li>
<li><a href='#pwfst'><p>Estimate the individual-level pairwise FST matrix</p></a></li>
<li><a href='#rescale_popkin'><p>Rescale kinship matrix to set a given kinship value to zero.</p></a></li>
<li><a href='#validate_kinship'><p>Validate a kinship matrix</p></a></li>
<li><a href='#weights_subpops'><p>Get weights for individuals that balance subpopulations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate Kinship and FST under Arbitrary Population Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.23</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate the kinship matrix of individuals from a large set of biallelic SNPs, and extract inbreeding coefficients and the generalized FST (Wright's fixation index).  Method described in Ochoa and Storey (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1009241">doi:10.1371/journal.pgen.1009241</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RColorBrewer, graphics, grDevices, ape</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BEDMatrix, testthat, knitr, rmarkdown, bnpsd</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/StoreyLab/popkin/">https://github.com/StoreyLab/popkin/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/StoreyLab/popkin/issues">https://github.com/StoreyLab/popkin/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 23:37:19 UTC; viiia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Ochoa <a href="https://orcid.org/0000-0003-4928-3403"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  John D. Storey <a href="https://orcid.org/0000-0001-5992-402X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Ochoa &lt;alejandro.ochoa@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-07 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='popkin-package'>A package for estimating kinship and FST under arbitrary population structure</h2><span id='topic+popkin-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The heart of this package is the <code><a href="#topic+popkin">popkin()</a></code> function, which estimates the kinship matrix of all individual pairs from their genotype matrix.
Inbreeding coefficients, the generalized <code>FST</code>, and the individual-level pairwise <code>FST</code> matrix are extracted from the kinship matrix using <code><a href="#topic+inbr">inbr()</a></code>, <code><a href="#topic+fst">fst()</a></code>, and <code><a href="#topic+pwfst">pwfst()</a></code>, respectively.
<code><a href="#topic+fst">fst()</a></code> accepts weights for individuals to balance subpopulations obtained with <code><a href="#topic+weights_subpops">weights_subpops()</a></code>.
Kinship matrices can be renormalized (to change the most recent common ancestor population or MRCA) using <code><a href="#topic+rescale_popkin">rescale_popkin()</a></code>.
Coancestry matrices can be estimated from allele frequency matrices using <code><a href="#topic+popkin_af">popkin_af()</a></code>.
Lastly, kinship, coancestry, and pairwise FST matrices can be visualized using <code><a href="#topic+plot_popkin">plot_popkin()</a></code> (with the help of <code><a href="#topic+inbr_diag">inbr_diag()</a></code> for kinship matrices only).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alejandro Ochoa <a href="mailto:alejandro.ochoa@duke.edu">alejandro.ochoa@duke.edu</a> (<a href="https://orcid.org/0000-0003-4928-3403">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> John D. Storey <a href="mailto:jstorey@princeton.edu">jstorey@princeton.edu</a> (<a href="https://orcid.org/0000-0001-5992-402X">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/StoreyLab/popkin/">https://github.com/StoreyLab/popkin/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/StoreyLab/popkin/issues">https://github.com/StoreyLab/popkin/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># estimate and visualize kinship and FST from a genotype matrix

# Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow = 3, byrow = TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals
subpops2 &lt;- 1:3 # alternate labels treat every individual as a different subpop

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix from the genotypes "X"!
# all downstream analysis require "kinship", none use "X" after this
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels

# plot the kinship matrix, marking the subpopulations
# note inbr_diag replaces the diagonal of kinship with inbreeding coefficients
plot_popkin( inbr_diag(kinship), labs = subpops )

# extract inbreeding coefficients from kinship
inbreeding &lt;- inbr(kinship)

# estimate FST
weights &lt;- weights_subpops(subpops) # weigh individuals so subpopulations are balanced
Fst &lt;- fst(kinship, weights) # use kinship matrix and weights to calculate fst
Fst &lt;- fst(inbreeding, weights) # estimate more directly from inbreeding vector (same result)

# estimate and visualize the pairwise FST matrix
pairwise_fst &lt;- pwfst(kinship) # estimated matrix
leg_title &lt;- expression(paste('Pairwise ', F[ST])) # fancy legend label
# NOTE no need for inbr_diag() here!
plot_popkin(pairwise_fst, labs = subpops, leg_title = leg_title)

# rescale the kinship matrix using different subpopulations (implicitly changes the MRCA)
kinship2 &lt;- rescale_popkin(kinship, subpops2)

# toy allele frequency data
P &lt;- matrix( runif( 9 ), nrow = 3 )

# estimate coancestry from allele frequency matrix
# (useful from P matrices from admixture models)
coancestry &lt;- popkin_af( P )

</code></pre>

<hr>
<h2 id='admix_label_cols'>Label ancestries based on best match to individual labels</h2><span id='topic+admix_label_cols'></span>

<h3>Description</h3>

<p>Returns labels for each ancestry (columns) of an admixture matrix which is the best matching label among the average individual (rows) of each subpopulation.
More specifically, each ancestry is associated to the subpopulation label in which its admixture proportion was the highest averaging over all individuals from that subpopulation.
If there are two or more ancestries that match to the same label, these are made unique by appending its order of appearance (if the label is &quot;A&quot;, then the first column that matches to it is labeled &quot;A1&quot;, the next one &quot;A2&quot;, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_label_cols(Q, labs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_label_cols_+3A_q">Q</code></td>
<td>
<p>The admixture proportions matrix.</p>
</td></tr>
<tr><td><code id="admix_label_cols_+3A_labs">labs</code></td>
<td>
<p>Subpopulation labels for individuals (rows of <code>Q</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The best label assignments for the ancestries (columns of <code>Q</code>), made unique by indexes if there are overlaps.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+admix_order_cols">admix_order_cols()</a></code> to automatically order ancestries given ordered individuals.
</p>
<p><code><a href="#topic+plot_admix">plot_admix()</a></code> for plotting admixture matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy admixture matrix with labels for individuals/rows that match well with ancestry/columns
Q &lt;- matrix(
    c(
        0.1, 0.8, 0.1,
        0.1, 0.7, 0.2,
        0.0, 0.4, 0.6,
        0.0, 0.3, 0.7,
        0.9, 0.0, 0.1
    ),
    nrow = 5,
    ncol = 3,
    byrow = TRUE
)
labs &lt;- c('X', 'X', 'Y', 'Y', 'Z')

# to calculate matches and save as column names, do this:
colnames( Q ) &lt;- admix_label_cols( Q, labs )

# expected column names: c('Z', 'X', 'Y')

</code></pre>

<hr>
<h2 id='admix_order_cols'>Reorder admixture matrix columns</h2><span id='topic+admix_order_cols'></span>

<h3>Description</h3>

<p>Returns the order of the columns (ancestries) of an admixture matrix so that they are in their average order of appearance in rows (individuals).
More specifically, for each ancestry it calculates its mean row (expected row number weighted by this ancestry's proportion distribution among rows), and returns the order in which these mean row values are increasing.
In datasets where the rows/individuals are already ordered in a meaningful way (for example, by distance from the species' geographical origin, and generally grouping the most similar individuals together), this function can lead to a more pleasing automated visualization of the admixture proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_order_cols(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_order_cols_+3A_q">Q</code></td>
<td>
<p>The admixture proportions matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The desired order of the columns (a vector of indexes).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+admix_label_cols">admix_label_cols()</a></code> to automatically assign labels to ancestries given labels to individuals.
</p>
<p><code><a href="#topic+plot_admix">plot_admix()</a></code> for plotting admixture matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here is a toy admixture proportions matrix with columns in no meaningful order
Q &lt;- matrix(
    c(
        0.1, 0.8, 0.1,
        0.1, 0.7, 0.2,
        0.0, 0.4, 0.6,
        0.0, 0.3, 0.7,
        0.9, 0.0, 0.1
    ),
    nrow = 5,
    ncol = 3,
    byrow = TRUE
)
# get nicer order
indexes &lt;- admix_order_cols( Q )
# apply reordering to columns
Q &lt;- Q[ , indexes ]

# notice that now the first columns takes on the highest values initially,
# followed by the second column, and lastly the third column.

</code></pre>

<hr>
<h2 id='avg_kinship_subpops'>Calculate a kinship matrix between subpopulations by averaging individual data</h2><span id='topic+avg_kinship_subpops'></span>

<h3>Description</h3>

<p>This function calculates a kinship matrix between subpopulations, whose values are the average kinship values between all individual pairs where one individual is in the first subpopulation and the other individual is in the second subpopulation.
To estimate coancestry instead of kinship, which is recommended to get more interpretable diagonal values, the input kinship matrix should be transformed using <code><a href="#topic+inbr_diag">inbr_diag()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_kinship_subpops(kinship, subpops, subpop_order = unique(subpops))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avg_kinship_subpops_+3A_kinship">kinship</code></td>
<td>
<p>A symmetric <code>n</code>-by-<code>n</code> kinship matrix.</p>
</td></tr>
<tr><td><code id="avg_kinship_subpops_+3A_subpops">subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.</p>
</td></tr>
<tr><td><code id="avg_kinship_subpops_+3A_subpop_order">subpop_order</code></td>
<td>
<p>The optional order of subpopulations in the output matrix.
<code>subpop_order</code> must contain every unique subpopulation in <code>subpops</code>.
Any additional subpopulations in <code>subpop_order</code> (missing in <code>subpops</code>) are ignored.
By default, subpopulations are in the order of first appearance in <code>subpops</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The symmetric <code>K</code>-by-<code>K</code> kinship matrix between subpopulations, where <code>K</code> is the number of unique subpopulations in <code>subpops</code>, ordered as in <code>subpop_order</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a toy kinship matrix with 5 individuals belonging to 2 subpopulations
kinship &lt;- matrix(
    c(
        0.7, 0.4, 0.4, 0.1, 0.0,
        0.4, 0.7, 0.4, 0.2, 0.1,
        0.4, 0.4, 0.7, 0.2, 0.0,
        0.1, 0.2, 0.2, 0.6, 0.1,
        0.0, 0.1, 0.0, 0.1, 0.6
    ),
    nrow = 5,
    ncol = 5
)
subpops &lt;- c(1, 1, 1, 2, 2)

# calculate mean kinship between (and within) subpopulations
# a 2x2 matrix
avg_kinship_subpops( kinship, subpops )

# calculate coancestry estimate instead (difference is diagonal)
avg_kinship_subpops( inbr_diag( kinship ), subpops )

</code></pre>

<hr>
<h2 id='fst'>Calculate FST from a population-level kinship matrix or vector of inbreeding coefficients</h2><span id='topic+fst'></span>

<h3>Description</h3>

<p>This function simply returns the weighted mean inbreeding coefficient.
If weights are <code>NULL</code> (default), the regular mean is calculated.
If a kinship matrix is provided, then the inbreeding coefficients are extracted from its diagonal using <code><a href="#topic+inbr">inbr()</a></code> (requires the diagonal to contains self-kinship values as <code><a href="#topic+popkin">popkin()</a></code> returns, and not inbreeding coefficients as <code><a href="#topic+inbr_diag">inbr_diag()</a></code> returns).
If there is local inbreeding and it can be estimated (from known pedigrees, for example), it can be subtracted from the total inbreeding coefficients, resulting in a vector of structural inbreeding that correctly averages into FST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fst(x, weights = NULL, x_local = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fst_+3A_x">x</code></td>
<td>
<p>The vector of inbreeding coefficients, or the kinship matrix if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="fst_+3A_weights">weights</code></td>
<td>
<p>Weights for individuals (optional, defaults to uniform weights)</p>
</td></tr>
<tr><td><code id="fst_+3A_x_local">x_local</code></td>
<td>
<p>An optional vector of inbreeding coefficients, or a local kinship matrix if <code>x_local</code> is a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned weighted mean inbreeding coefficient equals the generalized FST if all individuals are &quot;locally outbred&quot; (i.e. if the self-relatedness of every individual stems entirely from the population structure rather than due partly to having unusually closely related parents, such as first or second cousins).
Note most individuals in population-scale human data are locally outbred.
If there are locally-inbred individuals, but their local inbreeding cannot be estimated, then the returned value will overestimate FST.
Good estimates of local inbreeding can be passed (parameter <code>x_local</code>), in which case the code will subtract their effect and FST will be more accurate.
</p>


<h3>Value</h3>

<p>FST
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get FST from a genotype matrix

# Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow = 3, byrow = TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix "kinship" from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels
weights &lt;- weights_subpops(subpops) # can weigh individuals so subpopulations are balanced
Fst &lt;- fst(kinship, weights) # use kinship matrix and weights to calculate fst

Fst &lt;- fst(kinship) # no (or NULL) weights implies uniform weights

inbr &lt;- inbr(kinship) # if you extracted inbr for some other analysis...
Fst &lt;- fst(inbr, weights) # ...use this inbreeding vector as input too!

</code></pre>

<hr>
<h2 id='hgdp_subset'>HGDP subset</h2><span id='topic+hgdp_subset'></span>

<h3>Description</h3>

<p>Subset of the HGDP dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgdp_subset
</code></pre>


<h3>Format</h3>

<p>a matrix of 0's, 1's and 2's.
</p>


<h3>Value</h3>

<p>genotype matrix
</p>


<h3>Source</h3>

<p>Stanford HGDP <a href="http://www.hagsc.org/hgdp/files.html">http://www.hagsc.org/hgdp/files.html</a>
</p>

<hr>
<h2 id='inbr'>Extract inbreeding coefficients from a kinship matrix</h2><span id='topic+inbr'></span>

<h3>Description</h3>

<p>The kinship matrix contains transformed inbreeding coefficients along the diagonal.
This function extracts the vector of inbreeding values from the input kinship matrix, by transforming the diagonal using the formula <code>2 * x - 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbr(kinship)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inbr_+3A_kinship">kinship</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> kinship matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length-<code>n</code> vector of inbreeding coefficient for each individual.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inbr_diag">inbr_diag()</a></code> to replace kinship diagonal with inbreeding values (better for plots)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########
# illustrate the main transformation on a 2x2 kinship matrix:
# same inbreeding values for both individuals
inbr &lt;- 0.2
# corresponding self kinship (diagonal values) for both individuals
kinship_self &lt;- (1 + inbr)/2
# actual kinship matrix (zero kinship between individuals)
kinship &lt;- matrix(c(kinship_self, 0, 0, kinship_self), nrow=2)
# expected output of inbr (extracts inbreeding coefficients)
inbr_exp &lt;- c(inbr, inbr)
# actual output from this function
inbr_obs &lt;- inbr(kinship)
# verify that they match (up to machine precision)
stopifnot( all( abs(inbr_obs - inbr_exp) &lt; .Machine$double.eps ) )

#########
# Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels

# extract inbreeding coefficients from Kinship
inbr &lt;- inbr(kinship)

</code></pre>

<hr>
<h2 id='inbr_diag'>Replace kinship diagonal with inbreeding coefficients</h2><span id='topic+inbr_diag'></span>

<h3>Description</h3>

<p>The usual kinship matrix contains self-kinship values along their diagonal given by <code>diag(kinship) = ( 1 + inbr ) / 2</code>, where <code>inbr</code> is the vector of inbreeding coefficient.
This function returns a modified kinship matrix with diagonal values replaced with <code>inbr</code> (off-diagonal values stay the same).
The resulting matrix is better for visualization, but is often not appropriate for modeling (e.g. in mixed-effects models for association or heritability estimation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbr_diag(kinship)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inbr_diag_+3A_kinship">kinship</code></td>
<td>
<p>A kinship matrix with self-kinship values along the diagonal.
Can pass multiple kinship matrices contained in a list.
If <code>NULL</code>, it is returned as-is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified kinship matrix, with inbreeding coefficients along the diagonal, preserving column and row names.
If the input was a list of kinship matrices, the output is the corresponding list of transformed matrices.
<code>NULL</code> inputs are preserved without causing errors.
</p>


<h3>See Also</h3>

<p>The inverse function is given by <code><a href="bnpsd.html#topic+coanc_to_kinship">bnpsd::coanc_to_kinship()</a></code>.
</p>
<p><code><a href="#topic+inbr">inbr()</a></code> to extract the vector of inbreeding values from a kinship matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########
# illustrate the main transformation on a 2x2 kinship matrix:
# same inbreeding values for both individuals
inbr &lt;- 0.2
# corresponding self kinship (diagonal values) for both individuals
kinship_self &lt;- (1 + inbr)/2
# kinship between the two individuals
kinship_between &lt;- 0.1
# actual kinship matrix
kinship &lt;- matrix(c(kinship_self, kinship_between, kinship_between, kinship_self), nrow=2)
# expected output of inbr_diag (replaces self kinship with inbreeding)
kinship_inbr_diag_exp &lt;- matrix(c(inbr, kinship_between, kinship_between, inbr), nrow=2)
# actual output from this function
kinship_inbr_diag_obs &lt;- inbr_diag(kinship)
# verify that they match (up to machine precision)
stopifnot( all( abs(kinship_inbr_diag_obs - kinship_inbr_diag_exp) &lt; .Machine$double.eps ) )

# for a list of matrices, returns list of transformed matrices:
inbr_diag( list(kinship, kinship) )

# a list with NULL values also works
inbr_diag( list(kinship, NULL, kinship) )

#########
# Construct toy data (to more closely resemble real data analysis)
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels

# lastly, replace diagonal of kinship matrix with inbreeding coefficients
kinship_inbr_diag &lt;- inbr_diag(kinship)

</code></pre>

<hr>
<h2 id='mean_kinship'>Calculate the weighted mean kinship</h2><span id='topic+mean_kinship'></span>

<h3>Description</h3>

<p>This function computes a particular weighted mean kinship that arises in the context of kinship and FST estimators and in the definition of the effective sample size.
This function allows for weights to be zero or even negative, but they are internally normalized to sum to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_kinship(kinship, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_kinship_+3A_kinship">kinship</code></td>
<td>
<p>The kinship matrix</p>
</td></tr>
<tr><td><code id="mean_kinship_+3A_weights">weights</code></td>
<td>
<p>Weights for individuals (optional).
If <code>NULL</code> (default), uniform weights are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weighted mean kinship matrix, equivalent to <code>drop( weights %*% kinship %*% weights )</code> after normalizing weights to sum to one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a dummy kinship matrix
kinship &lt;- matrix(c(0.5, 0, 0, 0.6), nrow=2)

# this is the ordinary mean
mean_kinship(kinship)

# weighted mean with twice as much weight on the second individual
# (weights are internally normalized to sum to one)
weights &lt;- c(1, 2)
mean_kinship(kinship, weights)

</code></pre>

<hr>
<h2 id='n_eff'>Calculates the effective sample size of the data</h2><span id='topic+n_eff'></span>

<h3>Description</h3>

<p>The effective sample size <code>n_eff</code> is the equivalent number of independent haplotypes that gives the same variance as that observed under the given population.
The variance in question is for the weighted sample mean ancestral allele frequency estimator.
It follows that <code>n_eff</code> equals the inverse of the weighted mean kinship.
If <code>max = TRUE</code>, a calculation is performed that implicitly uses optimal weights which maximize <code>n_eff</code>, which equals the sum of the elements of the inverse kinship matrix.
However, if <code>nonneg = TRUE</code> and if the above solution has negative weights (common), optimal non-negative weights are found instead (there are three algorithms available, see <code>algo</code>).
If <code>max = FALSE</code>, then the input weights are used in this calculation, and if weights are <code>NULL</code>, uniform weights are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_eff(
  kinship,
  max = TRUE,
  weights = NULL,
  nonneg = TRUE,
  algo = c("gradient", "newton", "heuristic"),
  tol = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_eff_+3A_kinship">kinship</code></td>
<td>
<p>An <code>n</code>-by-<code>n</code> kinship matrix.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_max">max</code></td>
<td>
<p>If <code>TRUE</code>, returns the maximum <code>n_eff</code> value among those computed using all possible vectors of weights that sum to one (and which are additionally non-negative if <code>nonneg = TRUE</code>).
If <code>FALSE</code>, <code>n_eff</code> is computed using the specific weight vector provided.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_weights">weights</code></td>
<td>
<p>Weights for individuals (optional).
If <code>NULL</code>, uniform weights are used.
This parameter is ignored if <code>max = TRUE</code>.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_nonneg">nonneg</code></td>
<td>
<p>If <code>TRUE</code> (default) and <code>max = TRUE</code>, non-negative weights that maximize <code>n_eff</code> are found.
See <code>algo</code>.
This has no effect if <code>max = FALSE</code>.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_algo">algo</code></td>
<td>
<p>Algorithm for finding optimal non-negative weights (applicable only if <code>nonneg = TRUE</code> and <code>max = TRUE</code> and the weights found by matrix inversion are non-negative).
May be abbreviated.
If &quot;gradient&quot; (default), an optimized gradient descent algorithm is used (fastest; recommended).
If &quot;newton&quot;, the exact multivariate newton's Method is used (slowest since <code>(n+1)</code>-by-<code>(n+1)</code> Hessian matrix needs to be inverted at every iteration; use if possible to confirm that &quot;gradient&quot; gives the best answer).
If &quot;heuristic&quot;, if the optimal solution by the inverse matrix method contains negative weights, the most negative weight in an iteration is forced to be zero in all subsequent iterations and the rest of the weights are solved for using the inverse matrix method, repeating until all resulting weights are non-negative (also slow, since inversion of large matrices is required; least likely to find optimal solution).</p>
</td></tr>
<tr><td><code id="n_eff_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for &quot;gradient&quot; and &quot;newton&quot; algorithms.
The algorithms converge when the norm of the step vector is smaller than this tolerance value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum <code>n_eff</code> possible is <code>2 * n</code>, where <code>n</code> is the number of individuals; this value is attained only when all haplotypes are independent (a completely unstructured population in Hardy-Weinberg equilibrium).
The minimum <code>n_eff</code> possible is 1, which is attained in an extremely structured population with FST of 1, where every individual has exactly the same haplotype at every locus (no heterozygotes).
Moreover, for <code>K</code> extremely-differentiated subpopulations (FST = 1 per subpopulation) <code>n_eff = K</code>.
In this way, <code>n_eff</code> is smaller than the ideal value of <code>2 * n</code> depending on the amount of kinship (covariance) in the data.
</p>
<p>Occasionally, depending on the quality of the input kinship matrix, the estimated <code>n_eff</code> may be outside the theoretical [<code>1</code>, <code>2*n</code>] range, in which case the return value is set to the closest boundary value.
The quality of the results depends on the success of matrix inversion (which for numerical reasons may incorrectly contain negative eigenvalues, for example) or of the gradient optimization.
</p>


<h3>Value</h3>

<p>A list containing <code>n_eff</code> and <code>weights</code> (optimal weights if <code>max = TRUE</code>, input weights otherwise).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get n_eff from a genotype matrix

# Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix "kinship" from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels
weights &lt;- weights_subpops(subpops) # can weigh individuals so subpopulations are balanced

# use kinship matrix to calculate n_eff
# default mode returns maximum n_eff possible across all non-negative weights that sum to one
# also returns the weights that were optimal
obj &lt;- n_eff(kinship)
n_eff_max &lt;- obj$n_eff
w_max &lt;- obj$weights

# version that uses weights provided
obj &lt;- n_eff(kinship, max = FALSE, weights = weights)
n_eff_w &lt;- obj$n_eff
w &lt;- obj$weights # returns input weights renormalized for good measure

# no (or NULL) weights implies uniform weights
obj &lt;- n_eff(kinship, max = FALSE)
n_eff_u &lt;- obj$n_eff
w &lt;- obj$weights # uniform weights

</code></pre>

<hr>
<h2 id='plot_admix'>Make a structure/admixture plot</h2><span id='topic+plot_admix'></span>

<h3>Description</h3>

<p>This function facilitates structure plots with options that resemble those of <code><a href="#topic+plot_popkin">plot_popkin()</a></code> in name and results.
The biggest difference is this function plots single panels (technically 2 panels including the legend, unless it is omitted), whereas <code><a href="#topic+plot_popkin">plot_popkin()</a></code> can plot multiple kinship matrices with a shared legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_admix(
  Q,
  col = RColorBrewer::brewer.pal(max(ncol(Q), 3), "Paired"),
  mar_pad = 0.2,
  panel_letters = NA,
  panel_letters_cex = 1.5,
  panel_letters_adj = -0.1,
  axis_lab_cex = 1,
  xlab = "Individuals",
  xlab_line = 1,
  xlab_cex = axis_lab_cex,
  ylab = "Ancestry",
  ylab_line = 2,
  ylab_side = 2,
  ylab_cex = axis_lab_cex,
  leg_title = "Ancestries",
  leg_title_cex = axis_lab_cex,
  leg_title_line = 2,
  leg_cex = 1,
  leg_mar = leg_title_line + 1,
  leg_width = 0.2,
  leg_las = 0,
  leg_omit = FALSE,
  layout_add = !leg_omit,
  names = FALSE,
  names_cex = 1,
  names_line = NA,
  names_las = 2,
  labs = NULL,
  labs_cex = 1,
  labs_las = 0,
  labs_line = 0,
  labs_sep = TRUE,
  labs_lwd = 1,
  labs_col = "black",
  labs_ticks = FALSE,
  labs_text = TRUE,
  labs_even = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_admix_+3A_q">Q</code></td>
<td>
<p>The admixture proportions matrix, with <code>n</code> individuals along rows and <code>K</code> ancestries along columns.
Rows should sum to 1, but this is not enforced.
There must be at least 2 ancestries.
The ancestry labels used by the legend must be the column names, which are unlabeled if the column names are missing.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_col">col</code></td>
<td>
<p>A vector of at least <code>K</code> colors for the ancestries (extra colors are ignored).
By default uses the &quot;Paired&quot; palette of <code>RColorBrewer</code>, which has at most 12 colors, so please provide colors if <code>K &gt; 12</code>.
Since the minimum number of colors for &quot;Paired&quot; is 3, when <code>K = 2</code> we ask for 3 colors, then remove the middle color internally.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_mar_pad">mar_pad</code></td>
<td>
<p>Margin padding used for legend panel only (margins for first/main panel are not altered by this function).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_panel_letters">panel_letters</code></td>
<td>
<p>Panel letter to include in first/main panel (default <code>NA</code> is no letter).
Despite name (matches <code><a href="#topic+plot_popkin">plot_popkin()</a></code>), must be scalar.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_panel_letters_cex">panel_letters_cex</code></td>
<td>
<p>Scaling factor of panel letter (default 1.5).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_panel_letters_adj">panel_letters_adj</code></td>
<td>
<p>X-axis adjustment for panel letter (default -0.1).
Negative values place the letter into the left margin area.
Might need adjustment depending on the size of the left margin.
</p>
<p>AXIS LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_axis_lab_cex">axis_lab_cex</code></td>
<td>
<p>Scaling factor for x-axis, y-axis, and legend title labels (which can also be set individually, see below).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label (default &quot;Individuals&quot;).
Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_xlab_line">xlab_line</code></td>
<td>
<p>The value of <code>line</code> for <code>xlab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_xlab_cex">xlab_cex</code></td>
<td>
<p>Scaling factor for x-axis label.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label (default &quot;Ancestry&quot;).
Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_ylab_line">ylab_line</code></td>
<td>
<p>The value of <code>line</code> for <code>ylab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_ylab_side">ylab_side</code></td>
<td>
<p>The value of <code>side</code> for <code>ylab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> (2 is y-axis, 1 is x-axis, can also place on top (3) or right (4)).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_ylab_cex">ylab_cex</code></td>
<td>
<p>Scaling factor for y-axis label.
</p>
<p>LEGEND (COLOR KEY) OPTIONS</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_title">leg_title</code></td>
<td>
<p>The name of the categorical ancestry variable (default &quot;Ancestries&quot;).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_title_cex">leg_title_cex</code></td>
<td>
<p>Scaling factor for legend title label.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_title_line">leg_title_line</code></td>
<td>
<p>The value of <code>line</code> for <code>leg_title</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_cex">leg_cex</code></td>
<td>
<p>Scaling factor for ancestry labels.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_mar">leg_mar</code></td>
<td>
<p>Margin values for the kinship legend panel only.
A length-4 vector (in <code>c( bottom, left, top, right )</code> format that <code><a href="graphics.html#topic+par">graphics::par()</a></code> 'mar' expects) specifies the full margins, to which <code>mar_pad</code> is added.
Otherwise, the margins used in the last panel are preserved with the exception that the left margin is set to <code>mar_pad</code>, and if <code>leg_mar</code> is length-1 (default), it is added to <code>mar_pad</code> to specify the right margin.
By default the right margin is large enough to accommodate <code>leg_title</code> for the given value of <code>leg_title_line</code>.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_width">leg_width</code></td>
<td>
<p>The width of the legend panel, relative to the width of the main panel.
This value is passed to <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> (ignored if <code>layout_add = FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_las">leg_las</code></td>
<td>
<p>The ancestry label orientations (in format that <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> expects).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_leg_omit">leg_omit</code></td>
<td>
<p>If <code>TRUE</code>, no legend (second panel) is produced (default <code>FALSE</code> is to include legend).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_layout_add">layout_add</code></td>
<td>
<p>If <code>TRUE</code> (default) then <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> is called internally to create two panels: the main panel and the color key legend.
The original layout is reset when plotting is complete and if <code>layout_add = TRUE</code>.
If a non-standard layout or additional panels (beyond those provided by this function) are desired, set to <code>FALSE</code> and call <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> yourself beforehand.
</p>
<p>INDIVIDUAL LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_names">names</code></td>
<td>
<p>If <code>TRUE</code>, the row (individual) names are plotted in the structure barplot.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_names_cex">names_cex</code></td>
<td>
<p>Scaling factor for the individual names.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_names_line">names_line</code></td>
<td>
<p>Line where individual names are placed.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_names_las">names_las</code></td>
<td>
<p>Orientation of labels relative to axis.
Default (2) makes labels perpendicular to axis.
</p>
<p>SUBPOPULATION LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs">labs</code></td>
<td>
<p>Subpopulation labels for individuals in the admixture matrix.
Use a matrix of labels to show groupings at more than one level (for a hierarchy or otherwise).</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_cex">labs_cex</code></td>
<td>
<p>A vector of label scaling factors for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_las">labs_las</code></td>
<td>
<p>A vector of label orientations (in format that <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> expects) for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_line">labs_line</code></td>
<td>
<p>A vector of lines where labels are placed (in format that <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> expects) for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_sep">labs_sep</code></td>
<td>
<p>A vector of logicals that specify whether lines separating the subpopulations are drawn for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_lwd">labs_lwd</code></td>
<td>
<p>A vector of line widths for the lines that divide subpopulations (if <code>labs_sep = TRUE</code>) for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_col">labs_col</code></td>
<td>
<p>A vector of colors for the lines that divide subpopulations (if <code>labs_sep = TRUE</code>) for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_ticks">labs_ticks</code></td>
<td>
<p>A vector of logicals that specify whether ticks separating the subpopulations are drawn for each level of labs.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_text">labs_text</code></td>
<td>
<p>A vector of logicals that specify whether the subpopulation labels are shown for each level of labs.
Useful for including separating lines or ticks without text.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_labs_even">labs_even</code></td>
<td>
<p>A vector of logicals that specify whether the subpopulations labels are drawn with equal spacing for each level of labs.
When <code>TRUE</code>, lines mapping the equally-spaced labels to the unequally-spaced subsections of the heatmap are also drawn.</p>
</td></tr>
<tr><td><code id="plot_admix_+3A_...">...</code></td>
<td>
<p>Additional options passed to <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+admix_order_cols">admix_order_cols()</a></code> to automatically order ancestries given ordered individuals.
</p>
<p><code><a href="#topic+admix_label_cols">admix_label_cols()</a></code> to automatically assign labels to ancestries given labels to individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create random proportions for two ancestries
Q &lt;- runif( 10 )
Q &lt;- cbind( Q, 1 - Q )
# add ancestry names
colnames( Q ) &lt;- c('A1', 'A2')

# plot this data!
plot_admix( Q )

# See vignette for more elaborate examples!

</code></pre>

<hr>
<h2 id='plot_phylo'>Plot a <code>phylo</code> tree object</h2><span id='topic+plot_phylo'></span>

<h3>Description</h3>

<p>This is a wrapper around <code><a href="ape.html#topic+plot.phylo">ape::plot.phylo()</a></code> that makes several adjustments so plots agree more with accompanying kinship matrices.
In particular, tree is reversed on the y-axis to match matrix orientation, y-axis spacing is more padded for small trees, and an x-axis scale is always added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phylo(
  tree,
  xlab = "Coancestry",
  xmax = NULL,
  leg_n = 5,
  edge_width = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_phylo_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot_phylo_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label (default &quot;Coancestry&quot;).</p>
</td></tr>
<tr><td><code id="plot_phylo_+3A_xmax">xmax</code></td>
<td>
<p>X-axis maximum limit.</p>
</td></tr>
<tr><td><code id="plot_phylo_+3A_leg_n">leg_n</code></td>
<td>
<p>The desired number of ticks in the x-axis (input to <code><a href="base.html#topic+pretty">pretty()</a></code>, see that for more details).</p>
</td></tr>
<tr><td><code id="plot_phylo_+3A_edge_width">edge_width</code></td>
<td>
<p>The width of the tree edges (passed to <code><a href="ape.html#topic+plot.phylo">ape::plot.phylo()</a></code> as <code>edge.width</code>).</p>
</td></tr>
<tr><td><code id="plot_phylo_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="ape.html#topic+plot.phylo">ape::plot.phylo()</a></code>.
However, these parameters cannot be passed: <code>x.lim</code> (controlled via <code>xmax</code>), <code>y.lim</code> (a better default for small trees is passed and cannot be changed) and <code>font</code> (takes the value of <code>par('font')</code> instead of <code>ape</code>'s default of 3 (italic)).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot_popkin">plot_popkin()</a></code> can create multipanel figures including kinship matrices and trees (calling the present function in the process).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a small random tree
library(ape)
tree &lt;- rtree( 3 )

# plot it!
plot_phylo( tree )

</code></pre>

<hr>
<h2 id='plot_popkin'>Visualize one or more kinship matrices and other related objects</h2><span id='topic+plot_popkin'></span>

<h3>Description</h3>

<p>This function plots one or more kinship matrices, trees (class <code>phylo</code> objects, see <code>ape</code> package), and arbitrary functions, and a shared legend for the kinship color key.
Many options allow for fine control of individual or subpopulation labeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_popkin(
  kinship,
  titles = NULL,
  col = NULL,
  col_n = 100,
  mar = NULL,
  mar_pad = 0.2,
  oma = 1.5,
  diag_line = FALSE,
  panel_letters = toupper(letters),
  panel_letters_cex = 1.5,
  panel_letters_adj = -0.1,
  ylab = "Individuals",
  ylab_adj = NA,
  ylab_line = 0,
  ylab_side = 2,
  ylab_per_panel = FALSE,
  layout_add = TRUE,
  layout_rows = 1,
  leg_per_panel = FALSE,
  leg_title = "Kinship",
  leg_cex = 1,
  leg_n = 5,
  leg_mar = 3,
  leg_width = 0.3,
  leg_column = NA,
  names = FALSE,
  names_cex = 1,
  names_line = NA,
  names_las = 2,
  labs = NULL,
  labs_cex = 1,
  labs_las = 0,
  labs_line = 0,
  labs_sep = TRUE,
  labs_lwd = 1,
  labs_col = "black",
  labs_ticks = FALSE,
  labs_text = TRUE,
  labs_even = FALSE,
  null_panel_data = FALSE,
  weights = NULL,
  raster = is.null(weights),
  sym = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_popkin_+3A_kinship">kinship</code></td>
<td>
<p>A numeric kinship matrix, a <code>phylo</code> or <code>function</code> object, or a list of any such objects (at least one kinship matrix is expected).
This list may contain <code>NULL</code> elements (makes blank panels with titles; good for placeholders or non-existent data)
<code>phylo</code> objects are plotted with <code><a href="#topic+plot_phylo">plot_phylo()</a></code>, which is a wrapper around <code><a href="ape.html#topic+plot.phylo">ape::plot.phylo()</a></code> that makes some adjustments so resulting plots are more consistent with accompanying kinship matrices.
<code>function</code> elements are executed without arguments, and are expected to produce single arbitrary plot panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_titles">titles</code></td>
<td>
<p>Titles to add to each matrix panel (default is no titles).
Applied to kinship and phylo panels only.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_col">col</code></td>
<td>
<p>Colors for kinship heatmap (default is a red-white-blue palette symmetric about zero constructed using <code>RColorBrewer</code>).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_col_n">col_n</code></td>
<td>
<p>The number of colors to use in the heatmap (applies if <code>col = NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_mar">mar</code></td>
<td>
<p>Margins shared by all panels (if a vector) or for each panel (if a list of such vectors).
If the vector has length 1, <code>mar</code> corresponds to the shared lower and left margins, while the top and right margins are set to zero.
If this length is 2, <code>mar[1]</code> is the same as above, while <code>mar[2]</code> is the top margin.
If this length is 4, then <code>mar</code> is a fully-specified margin vector in the standard format <code>c(bottom, left, top, right)</code> that <code><a href="graphics.html#topic+par">graphics::par()</a></code> 'mar' expects.
Vectors of invalid lengths produce a warning.
Note the padding <code>mar_pad</code> below is added to every margin if set.
If <code>NULL</code>, the original margin values are used without change, and are reset for every panel that has a <code>NULL</code> value.
The original margins are also reset after plotting is complete.
Applied to panels of all types (kinship, phylo, and function).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_mar_pad">mar_pad</code></td>
<td>
<p>Margin padding added to all panels (<code>mar</code> above and <code>leg_mar</code> below).
Default 0.2.
Must be a scalar or a vector of length 4 to match <code><a href="graphics.html#topic+par">graphics::par()</a></code> 'mar'.
Applied to panels of all types (kinship, phylo, and function).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_oma">oma</code></td>
<td>
<p>Outer margin vector.
If length 1, the value of <code>oma</code> is applied to the left outer margin only (so <code>ylab</code> below displays correctly) and zero outer margins elsewhere.
If length 4, all outer margins are expected in standard format <code><a href="graphics.html#topic+par">graphics::par()</a></code> 'mar' expects (see <code>mar</code> above).
<code>mar_pad</code> above is never added to outer margins.
If <code>NULL</code>, no outer margins are set (previous settings are preserved).
Vectors of invalid lengths produce a warning.
Note: if <code>layout_add = FALSE</code>, this function still (re)sets the outer margins if <code>oma</code> is not <code>NULL</code>, which can be convenient if <code>plot_popkin</code> generates the first few panels, but otherwise a partial multipanel figure will be reset unless <code>oma = NULL</code> is also set!</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_diag_line">diag_line</code></td>
<td>
<p>If <code>TRUE</code> adds a line along the kinship diagonal (default no line).
May also be a vector of logicals to set per panel (lengths must agree).
Has no effect on non-kinship panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_panel_letters">panel_letters</code></td>
<td>
<p>Vector of strings for labeling panels (default A-Z).
No labels are added if <code>NULL</code>, or when there is only one panel except if its set to a single letter in that case (this behavior is useful if goal is to have multiple external panels but popkin only creates one of these panels).
Applied to panels of all types (kinship, phylo, and function).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_panel_letters_cex">panel_letters_cex</code></td>
<td>
<p>Scaling factor of panel letters (default 1.5).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_panel_letters_adj">panel_letters_adj</code></td>
<td>
<p>X-axis adjustment for panel letters (default -0.1).
Negative values place the letter into the left margin area.
Might need adjustment depending on the size of the left margin.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label (default &quot;Individuals&quot;).
If <code>length(ylab) == 1</code>, the label is placed in the outer margin (shared across panels);
otherwise <code>length(ylab)</code> must equal the number of panels and each label is placed in the inner margin of the respective panel.
Applied to panels of all types (kinship, phylo, and function).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_ylab_adj">ylab_adj</code></td>
<td>
<p>The value of <code>adj</code> for <code>ylab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code>.
If <code>length(ylab) == 1</code>, only the first value is used, otherwise <code>length(ylab_adj)</code> must equal the number of panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_ylab_line">ylab_line</code></td>
<td>
<p>The value of <code>line</code> for <code>ylab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code>.
If <code>length(ylab) == 1</code>, only the first value is used, otherwise <code>length(ylab_line)</code> must equal the number of panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_ylab_side">ylab_side</code></td>
<td>
<p>The value of <code>side</code> for <code>ylab</code> passed to <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> (2 is y-axis, 1 is x-axis, can also place on top (3) or right (4)).
If <code>length(ylab) == 1</code>, only the first value is used, otherwise <code>length(ylab_side)</code> must equal the number of panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_ylab_per_panel">ylab_per_panel</code></td>
<td>
<p>Forces y-axis labels to appear for each panel, in the inner margins.
Most useful to cover the case where there is a single panel but no outer margins (<code>oma = NULL</code>).
</p>
<p>LAYOUT OPTIONS</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_layout_add">layout_add</code></td>
<td>
<p>If <code>TRUE</code> (default) then <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> is called internally with appropriate values for the required number of panels for each matrix, the desired number of rows (see <code>layout_rows</code> below) plus the color key legend.
The original layout is reset when plotting is complete if <code>layout_add = TRUE</code>.
If a non-standard layout or additional panels (beyond those provided by <code>plot_popkin</code>) are desired, set to <code>FALSE</code> and call <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> yourself beforehand; in this case you may want to set <code>oma = NULL</code> (above) as well!</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_layout_rows">layout_rows</code></td>
<td>
<p>Number of rows in layout, used only if <code>layout_add = TRUE</code>.
</p>
<p>LEGEND (COLOR KEY) OPTIONS</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_per_panel">leg_per_panel</code></td>
<td>
<p>If <code>TRUE</code>, every kinship matrix get its own legend/color key (best for matrices with very different scales), and each phylo tree has its own x-axis range.
If <code>FALSE</code> (default), a single legend/color key is shared by all kinship matrix panels, and also every tree has the same x-axis range (different from the kinship range).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_title">leg_title</code></td>
<td>
<p>The name of the variable that the kinship heatmap colors measure (default &quot;Kinship&quot;), or a vector of such values if they vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_cex">leg_cex</code></td>
<td>
<p>Scaling factor for <code>leg_title</code> (default 1), or a vector of such values if they vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_n">leg_n</code></td>
<td>
<p>The desired number of ticks in the kinship legend y-axis, and phylo x-axis (input to <code><a href="base.html#topic+pretty">pretty()</a></code>, see that for more details), or a vector of such values if they vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_mar">leg_mar</code></td>
<td>
<p>Margin values for the kinship legend panel only, or a list of such values if they vary per panel.
A length-4 vector (in <code>c( bottom, left, top, right )</code> format that <code><a href="graphics.html#topic+par">graphics::par()</a></code> 'mar' expects) specifies the full margins, to which <code>mar_pad</code> is added.
Otherwise, the margins used in the last panel are preserved with the exception that the left margin is set to <code>mar_pad</code>, and if <code>leg_mar</code> is length-1, it is added to <code>mar_pad</code> to specify the right margin.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_width">leg_width</code></td>
<td>
<p>The width of the legend panel, relative to the width of a single main panel.
This value is passed to <code><a href="graphics.html#topic+layout">graphics::layout()</a></code> (ignored if <code>layout_add = FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_leg_column">leg_column</code></td>
<td>
<p>The column number in which to place the kinship legend (default <code>NA</code> is for last column).
Ignored if <code>leg_per_panel = TRUE</code>.
</p>
<p>INDIVIDUAL LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_names">names</code></td>
<td>
<p>If <code>TRUE</code>, the column and row names are plotted in the kinship heatmap, or a vector of such values if they vary per panel.
(<code>names</code> has no effect on <code>phylo</code> panels, whose tip labels are always plotted, or other panel types.)</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_names_cex">names_cex</code></td>
<td>
<p>Scaling factor for the column and row names of a kinship matrix, or the tip labels of a <code>phylo</code> object, or a vector of such values if they vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_names_line">names_line</code></td>
<td>
<p>Line where kinship column and row names are placed, or a vector of such values if they vary per panel.
Has no effect on non-kinship panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_names_las">names_las</code></td>
<td>
<p>Orientation of labels relative to axis.
Default (2) makes labels perpendicular to axis.
Has no effect on non-kinship panels.
</p>
<p>SUBPOPULATION LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs">labs</code></td>
<td>
<p>Subpopulation labels for individuals in kinship matrices.
Use a matrix of labels (individuals along rows, levels along columns) to show groupings at more than one level (for a hierarchy or otherwise).
If input is a vector or a matrix, the same subpopulation labels are shown for every kinship matrix; the input must be a list of such vectors or matrices if the labels vary per panel.
Has no effect on non-kinship panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_cex">labs_cex</code></td>
<td>
<p>A vector of label scaling factors for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_las">labs_las</code></td>
<td>
<p>A vector of label orientations (in format that <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> expects) for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_line">labs_line</code></td>
<td>
<p>A vector of lines where labels are placed (in format that <code><a href="graphics.html#topic+mtext">graphics::mtext()</a></code> expects) for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_sep">labs_sep</code></td>
<td>
<p>A vector of logicals that specify whether lines separating the subpopulations are drawn for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_lwd">labs_lwd</code></td>
<td>
<p>A vector of line widths for the lines that divide subpopulations (if <code>labs_sep = TRUE</code>) for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_col">labs_col</code></td>
<td>
<p>A vector of colors for the lines that divide subpopulations (if <code>labs_sep = TRUE</code>) for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_ticks">labs_ticks</code></td>
<td>
<p>A vector of logicals that specify whether ticks separating the subpopulations are drawn for each level of labs, or a list of such vectors if labels vary per panel.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_text">labs_text</code></td>
<td>
<p>A vector of logicals that specify whether the subpopulation labels are shown for each level of labs, or a list of such vectors if labels vary per panel.
Useful for including separating lines or ticks without text.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_labs_even">labs_even</code></td>
<td>
<p>A vector of logicals that specify whether the subpopulations labels are drawn with equal spacing for each level of labs, or a list of such vectors if labels vary per panel.
When <code>TRUE</code>, lines mapping the equally-spaced labels to the unequally-spaced subsections of the heatmap are also drawn.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_null_panel_data">null_panel_data</code></td>
<td>
<p>If <code>FALSE</code> (default), panels with <code>NULL</code> kinship matrices must not have titles or other parameters set, and no panel letters are used in these cases.
If <code>TRUE</code>, panels with <code>NULL</code> kinship matrices must have titles and other parameters set.
In the latter case, these <code>NULL</code> panels also get panel letters.
The difference is important when checking that lengths of non-singleton parameters agree.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_weights">weights</code></td>
<td>
<p>A vector with weights for every individual, or a list of such vectors if they vary per panel.
The width of every individual in the kinship matrix becomes proportional to their weight.
Individuals with zero or negative weights are omitted.
Has no effect on non-kinship panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_raster">raster</code></td>
<td>
<p>A logical equivalent to <code>useRaster</code> option in the <code>image</code> function used internally, or a vector of such logicals if the choice varies per panel.
If <code>weights</code> are non-<code>NULL</code> in a given panel, <code>raster = FALSE</code> is forced (this is necessary to plot images where columns and rows have variable width).
If <code>weights</code> are <code>NULL</code>, the default is <code>raster = TRUE</code>, but in this case the user may override (for example, so panels are visually coherent when some use weights while others do not, as there are small differences in rendering implementation for each value of <code>raster</code>).
Note that a multipanel figure with a list of <code>weights</code> sets <code>raster = FALSE</code> to all panels by default, even if the weights were only applied to a subset of panels.
Has no effect on non-kinship panels.</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_sym">sym</code></td>
<td>
<p>If <code>FALSE</code> (default), plots non-symmetric (but square) kinship matrices without issues.  If <code>TRUE</code>, stops if any input kinship matrices (excluding <code>phylo</code> or <code>function</code> objects) are not symmetric.
</p>
<p>AXIS LABEL OPTIONS</p>
</td></tr>
<tr><td><code id="plot_popkin_+3A_...">...</code></td>
<td>
<p>Additional options passed to <code><a href="graphics.html#topic+image">graphics::image()</a></code>.
These are shared across kinship panels.
Have no effect on non-kinship panels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_popkin</code> plots the input kinship matrices as-is.
For best results, a standard kinship matrix (such as the output of <code><a href="#topic+popkin">popkin()</a></code>) should have its diagonal rescaled to contain inbreeding coefficients using <code><a href="#topic+inbr_diag">inbr_diag()</a></code> before <code>plot_popkin</code> is used.
</p>
<p>This function permits the labeling of individuals (from row and column names when <code>names = TRUE</code>) and of subpopulations (passed through <code>labs</code>).
The difference is that the labels passed through <code>labs</code> are assumed to be shared by many individuals, and lines (or other optional visual aids) are added to demarcate these subgroups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow = 3, byrow = TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels

# simple plot of the kinship matrix, marking the subpopulations only
# note inbr_diag replaces the diagonal of kinship with inbreeding coefficients
# (see vignette for more elaborate examples)
plot_popkin( inbr_diag(kinship), labs = subpops )

</code></pre>

<hr>
<h2 id='popkin'>Estimate kinship from a genotype matrix and subpopulation assignments</h2><span id='topic+popkin'></span>

<h3>Description</h3>

<p>Given the biallelic genotypes of <code>n</code> individuals, this function returns the <code>n</code>-by-<code>n</code> kinship matrix such that the kinship estimate between the most distant subpopulations is zero on average (this sets the ancestral population to the most recent common ancestor population).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popkin(
  X,
  subpops = NULL,
  n = NA,
  loci_on_cols = FALSE,
  mean_of_ratios = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  want_M = FALSE,
  m_chunk_max = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popkin_+3A_x">X</code></td>
<td>
<p>Genotype matrix, <code>BEDMatrix</code> object, or a function <code>X(m)</code> that returns the genotypes of all individuals at <code>m</code> successive locus blocks each time it is called, and <code>NULL</code> when no loci are left.
If a regular matrix, <code>X</code> must have values only in <code>c(0, 1, 2, NA)</code>, encoded to count the number of reference alleles at the locus, or <code>NA</code> for missing data.</p>
</td></tr>
<tr><td><code id="popkin_+3A_subpops">subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.
If <code>NULL</code>, every individual is effectively treated as a different population.</p>
</td></tr>
<tr><td><code id="popkin_+3A_n">n</code></td>
<td>
<p>Number of individuals (required only when <code>X</code> is a function, ignored otherwise).
If <code>n</code> is missing but <code>subpops</code> is not, <code>n</code> is taken to be the length of <code>subpops</code>.</p>
</td></tr>
<tr><td><code id="popkin_+3A_loci_on_cols">loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>X</code> has loci on columns and individuals on rows; if <code>FALSE</code> (default), loci are on rows and individuals on columns.
Has no effect if <code>X</code> is a function.
If <code>X</code> is a <code>BEDMatrix</code> object, <code>loci_on_cols</code> is ignored (set automatically to <code>TRUE</code> internally).</p>
</td></tr>
<tr><td><code id="popkin_+3A_mean_of_ratios">mean_of_ratios</code></td>
<td>
<p>Chose how to weigh loci.
If <code>FALSE</code> (default) loci have equal weights (in terms of variance, rare variants contribute less than common variants; also called the &quot;ratio-of-means&quot; version, this has known asymptotic behavior).
If <code>TRUE</code>, rare variant loci are upweighed (in terms of variance, contributions are approximately the same across variant frequencies; also called the &quot;mean-of-ratios&quot; version, its asymptotic behavior is less well understood but performs better for association testing).</p>
</td></tr>
<tr><td><code id="popkin_+3A_mem_factor">mem_factor</code></td>
<td>
<p>Proportion of available memory to use loading and processing data.
Ignored if <code>mem_lim</code> is not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="popkin_+3A_mem_lim">mem_lim</code></td>
<td>
<p>Memory limit in GB, used to break up data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux is <code>mem_factor</code> times the free system memory, otherwise it is 1GB (Windows, OSX and other systems).</p>
</td></tr>
<tr><td><code id="popkin_+3A_want_m">want_M</code></td>
<td>
<p>If <code>TRUE</code>, includes the matrix <code>M</code> of non-missing pair counts in the return value, which are sample sizes that can be useful in modeling the variance of estimates.
Default <code>FALSE</code> is to return the relatedness matrix only.</p>
</td></tr>
<tr><td><code id="popkin_+3A_m_chunk_max">m_chunk_max</code></td>
<td>
<p>Sets the maximum number of loci to process at the time.
Actual number of loci loaded may be lower if memory is limiting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subpopulation assignments are only used to estimate the baseline kinship (the zero value).
If the user wants to re-estimate the kinship matrix using different subpopulation labels,
it suffices to rescale it using <code><a href="#topic+rescale_popkin">rescale_popkin()</a></code>
(as opposed to starting from the genotypes again, which gives the same answer but more slowly).
</p>


<h3>Value</h3>

<p>If <code>want_M = FALSE</code>, returns the estimated <code>n</code>-by-<code>n</code> kinship matrix only.
If <code>X</code> has names for the individuals, they will be copied to the rows and columns of this kinship matrix.
If <code>want_M = TRUE</code>, a named list is returned, containing:
</p>

<ul>
<li> <p><code>kinship</code>: the estimated <code>n</code>-by-<code>n</code> kinship matrix
</p>
</li>
<li> <p><code>M</code>: the <code>n</code>-by-<code>n</code> matrix of non-missing pair counts (see <code>want_M</code> option).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+popkin_af">popkin_af()</a></code> for coancestry estimation from allele frequency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(
    c(0, 1, 2,
      1, 0, 1,
      1, 0, 2),
    nrow = 3,
    byrow = TRUE
) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

kinship &lt;- popkin(X, subpops) # calculate kinship from genotypes and subpopulation labels

</code></pre>

<hr>
<h2 id='popkin_A'>Compute popkin's <code>A</code> and <code>M</code> matrices from genotypes</h2><span id='topic+popkin_A'></span>

<h3>Description</h3>

<p>This function returns lower-level, intermediate calculations for the main <code>popkin</code> function.
These are not intended for most users, but rather for researchers studying the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popkin_A(
  X,
  n = NA,
  loci_on_cols = FALSE,
  mean_of_ratios = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  m_chunk_max = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popkin_A_+3A_x">X</code></td>
<td>
<p>Genotype matrix, <code>BEDMatrix</code> object, or a function <code>X(m)</code> that returns the genotypes of all individuals at <code>m</code> successive locus blocks each time it is called, and <code>NULL</code> when no loci are left.
If a regular matrix, <code>X</code> must have values only in <code>c(0, 1, 2, NA)</code>, encoded to count the number of reference alleles at the locus, or <code>NA</code> for missing data.</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_n">n</code></td>
<td>
<p>Number of individuals (required only when <code>X</code> is a function, ignored otherwise).
If <code>n</code> is missing but <code>subpops</code> is not, <code>n</code> is taken to be the length of <code>subpops</code>.</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_loci_on_cols">loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>X</code> has loci on columns and individuals on rows; if <code>FALSE</code> (default), loci are on rows and individuals on columns.
Has no effect if <code>X</code> is a function.
If <code>X</code> is a <code>BEDMatrix</code> object, <code>loci_on_cols</code> is ignored (set automatically to <code>TRUE</code> internally).</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_mean_of_ratios">mean_of_ratios</code></td>
<td>
<p>Chose how to weigh loci.
If <code>FALSE</code> (default) loci have equal weights (in terms of variance, rare variants contribute less than common variants; also called the &quot;ratio-of-means&quot; version, this has known asymptotic behavior).
If <code>TRUE</code>, rare variant loci are upweighed (in terms of variance, contributions are approximately the same across variant frequencies; also called the &quot;mean-of-ratios&quot; version, its asymptotic behavior is less well understood but performs better for association testing).</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_mem_factor">mem_factor</code></td>
<td>
<p>Proportion of available memory to use loading and processing data.
Ignored if <code>mem_lim</code> is not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_mem_lim">mem_lim</code></td>
<td>
<p>Memory limit in GB, used to break up data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux is <code>mem_factor</code> times the free system memory, otherwise it is 1GB (Windows, OSX and other systems).</p>
</td></tr>
<tr><td><code id="popkin_A_+3A_m_chunk_max">m_chunk_max</code></td>
<td>
<p>Sets the maximum number of loci to process at the time.
Actual number of loci loaded may be lower if memory is limiting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing:
</p>

<ul>
<li> <p><code>A</code>: n-by-n matrix, for individuals <code>j</code> and <code>k</code>, of average <code>w_i * ( ( x_ij - 1 ) * ( x_ik - 1 ) - 1)</code> values across all loci <code>i</code> in <code>X</code>; if <code>mean_of_ratios = FALSE</code>, <code>w_i = 1</code>, otherwise <code>w_i = 1 / (p_est_i * (1 - p_est_i) )</code> where <code>p_est_i</code> is the reference allele frequency.
</p>
</li>
<li> <p><code>M</code>: n-by-n matrix of sample sizes (number of loci with non-missing individual <code>j</code> and <code>k</code> pairs, used to normalize <code>A</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>The main <code><a href="#topic+popkin">popkin()</a></code> function (a wrapper of this <code>popkin_A</code> function and <code><a href="#topic+popkin_A_min_subpops">popkin_A_min_subpops()</a></code> to estimate the minimum <code>A</code> value).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow = 3, byrow = TRUE) # genotype matrix

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
# library(BEDMatrix)
# X &lt;- BEDMatrix(file) # load genotype matrix object

obj &lt;- popkin_A(X) # calculate A and M from genotypes
A &lt;- obj$A
M &lt;- obj$M

</code></pre>

<hr>
<h2 id='popkin_A_min_subpops'>Estimate the minimum expected value of a matrix <code>A</code> using subpopulations</h2><span id='topic+popkin_A_min_subpops'></span>

<h3>Description</h3>

<p>This function averages the values of a square matrix <code>A</code> between every subpopulation pair and returns the minimum of these averages.
If no subpopulation partition is provided, the function returns the minimum value of <code>A</code> excluding the diagonal, to agree when the code treats each individual as a subpopulation.
The return value can be used to adjust an <code>A</code> matrix to yield the kinship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popkin_A_min_subpops(A, subpops = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popkin_A_min_subpops_+3A_a">A</code></td>
<td>
<p>A symmetric <code>n</code>-by-<code>n</code> matrix with values between every individual pair, including self comparisons.</p>
</td></tr>
<tr><td><code id="popkin_A_min_subpops_+3A_subpops">subpops</code></td>
<td>
<p>A length-<code>n</code> vector of subpopulation assignments for each individual.
If missing, every individual is treated as a different subpopulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimum of the average between-subpopulation <code>A</code> values, which estimates the minimum expected value of <code>A</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popkin_A">popkin_A()</a></code> to generate the <code>A</code> matrix usually inputted into this function (<code>popkin_A_min_subpops</code>).
<code><a href="#topic+popkin">popkin()</a></code> is the wrapper function around both of these.
</p>
<p><code><a href="#topic+avg_kinship_subpops">avg_kinship_subpops()</a></code> for the full matrix of mean kinship values between subpopulations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# calculate A from genotypes
A &lt;- popkin_A(X)$A

# the recommended form using appropriate subpopulation labels
A_min_est &lt;- popkin_A_min_subpops( A, subpops )

# this recovers the popkin estimate
kinship &lt;- 1 - A / A_min_est
stopifnot( kinship == popkin( X, subpops ) )

# a simple default for exploratory analysis, equals min( A ) for correctly-calculated A
A_min_est &lt;- popkin_A_min_subpops( A )
stopifnot( A_min_est == min( A ) )

</code></pre>

<hr>
<h2 id='popkin_af'>Estimate coancestry from an allele frequency matrix and subpopulation assignments</h2><span id='topic+popkin_af'></span>

<h3>Description</h3>

<p>Given the individual-specific allele frequencies of <code>n</code> individuals, this function returns the <code>n</code>-by-<code>n</code> coancestry matrix.
This function is the analog of <code><a href="#topic+popkin">popkin()</a></code> for allele frequencies rather than genotypes, and as a consequence estimates coancestry instead of kinship.
These coancestry estimates are unbiased if the true allele frequencies are provided, but may be less accurate when the allele frequencies themselves are estimated.
This function is intended for cases where allele frequencies, but not individual genotypes, are available; otherwise it is best to use the individual genotypes and <code><a href="#topic+popkin">popkin()</a></code>.
An application of interest is the allele frequency matrices from admixture models, in which case the columns correspond to subpopulations rather than individuals, and <code>subpops = NULL</code> is an acceptable choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popkin_af(
  P,
  subpops = NULL,
  loci_on_cols = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  want_M = FALSE,
  m_chunk_max = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popkin_af_+3A_p">P</code></td>
<td>
<p><code>m</code>-by-<code>n</code> matrix of individual-specific allele frequencies, which should have values between <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> (range is not strictly required) or <code>NA</code> for missing data.</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_subpops">subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.
If <code>NULL</code>, every individual is effectively treated as a different population.</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_loci_on_cols">loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>P</code> has loci on columns and individuals on rows; if <code>FALSE</code> (default), loci are on rows and individuals on columns.</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_mem_factor">mem_factor</code></td>
<td>
<p>Proportion of available memory to use loading and processing data.
Ignored if <code>mem_lim</code> is not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_mem_lim">mem_lim</code></td>
<td>
<p>Memory limit in GB, used to break up data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux is <code>mem_factor</code> times the free system memory, otherwise it is 1GB (Windows, OSX and other systems).</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_want_m">want_M</code></td>
<td>
<p>If <code>TRUE</code>, includes the matrix <code>M</code> of non-missing pair counts in the return value, which are sample sizes that can be useful in modeling the variance of estimates.
Default <code>FALSE</code> is to return the relatedness matrix only.</p>
</td></tr>
<tr><td><code id="popkin_af_+3A_m_chunk_max">m_chunk_max</code></td>
<td>
<p>Sets the maximum number of loci to process at the time.
Actual number of loci loaded may be lower if memory is limiting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>want_M = FALSE</code>, returns the estimated <code>n</code>-by-<code>n</code> coancestry matrix only.
If <code>P</code> has names for the individuals, they will be copied to the rows and columns of this coancestry matrix.
If <code>want_M = TRUE</code>, a named list is returned, containing:
</p>

<ul>
<li> <p><code>coancestry</code>: the estimated <code>n</code>-by-<code>n</code> coancestry matrix
</p>
</li>
<li> <p><code>M</code>: the <code>n</code>-by-<code>n</code> matrix of non-missing pair counts (see <code>want_M</code> option).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+popkin">popkin()</a></code> for kinship estimation from genotype matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a matrix of random uniform allele frequencies
# (unstructured, unlike real data)
P &lt;- matrix( runif( 9 ), nrow = 3 )

coancestry &lt;- popkin_af( P )

</code></pre>

<hr>
<h2 id='pwfst'>Estimate the individual-level pairwise FST matrix</h2><span id='topic+pwfst'></span>

<h3>Description</h3>

<p>This function construct the individual-level pairwise FST matrix implied by the input kinship matrix.
If the input is the true kinship matrix, the return value corresponds to the true pairwise FST matrix.
On the other hand, if the input is the estimated kinship returned by <code><a href="#topic+popkin">popkin()</a></code>, the same code results in the return value being the pairwise FST estimates described in our paper.
In all cases the diagonal of the pairwise FST matrix is zero by definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwfst(kinship)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwfst_+3A_kinship">kinship</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> kinship matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code>-by-<code>n</code> pairwise FST matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# estimate the kinship matrix from the genotypes "X"!
kinship &lt;- popkin(X, subpops) # calculate kinship from X and optional subpop labels

# lastly, compute pairwise FST matrix from the kinship matrix
pwF &lt;- pwfst(kinship)
 
</code></pre>

<hr>
<h2 id='rescale_popkin'>Rescale kinship matrix to set a given kinship value to zero.</h2><span id='topic+rescale_popkin'></span>

<h3>Description</h3>

<p>If you already have a population kinship matrix, and you desire to estimate the kinship matrix in a subset of the individuals, you could do it the slow way (reestimating starting from the genotypes of the subset of individuals) or you can do it the fast way: first subset the kinship matrix to only contain the individuals of interest, then use this function to rescale this kinship matrix so that the minimum kinship is zero.
This rescaling is required when subsetting results in a more recent Most Recent Common Ancestor (MRCA) population compared to the original dataset (for example, if the original data had individuals from across the world but the subset only contains individuals from a single continent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_popkin(kinship, subpops = NULL, min_kinship = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_popkin_+3A_kinship">kinship</code></td>
<td>
<p>An <code>n</code>-by-<code>n</code> kinship matrix.</p>
</td></tr>
<tr><td><code id="rescale_popkin_+3A_subpops">subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.</p>
</td></tr>
<tr><td><code id="rescale_popkin_+3A_min_kinship">min_kinship</code></td>
<td>
<p>A scalar kinship value to define the new zero kinship.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rescales the input <code>kinship</code> matrix so that the value <code>min_kinship</code> in the original kinship matrix becomes zero, using the formula
<code>kinship_rescaled = ( kinship - min_kinship ) / ( 1 - min_kinship )</code>.
This is equivalent to changing the ancestral population of the data.
If subpopulation labels <code>subpops</code> are provided (recommended), they are used to estimate <code>min_kinship</code> using the function <code><a href="#topic+popkin_A_min_subpops">popkin_A_min_subpops()</a></code>, which is the recommended way to set the MRCA population correctly.
If both <code>subpops</code> and <code>min_kinship</code> are provided, only <code>min_kinship</code> is used.
If both <code>subpops</code> and <code>min_kinship</code> are omitted, the function sets <code>min_kinship = min( kinship )</code>.
</p>


<h3>Value</h3>

<p>The rescaled <code>n</code>-by-<code>n</code> kinship matrix, with the desired level of relatedness set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(c(0,1,2,1,0,1,1,0,2), nrow=3, byrow=TRUE) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals
subpops2 &lt;- 1:3 # alternate labels treat every individual as a different subpop

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

# suppose we first estimate kinship without subpopulations, which will be more biased
kinship &lt;- popkin(X) # calculate kinship from genotypes, WITHOUT subpops
# then we visualize this matrix, figure out a reasonable subpopulation partition

# now we can adjust the kinship matrix!
kinship2 &lt;- rescale_popkin(kinship, subpops)
# prev is faster but otherwise equivalent to re-estimating kinship from scratch with subpops:
# kinship2 &lt;- popkin(X, subpops) 

# can also manually set the level of relatedness min_kinship we want to be zero:
min_kinship &lt;- min(kinship) # a naive choice for example
kinship2 &lt;- rescale_popkin(kinship, min_kinship = min_kinship)

# lastly, omiting both subpops and min_kinship sets the minimum value in kinship to zero
kinship3 &lt;- rescale_popkin(kinship2)
# equivalent to both of:
# kinship3 &lt;- popkin(X)
# kinship3 &lt;- rescale_popkin(kinship2, min_kinship = min(kinship))

</code></pre>

<hr>
<h2 id='validate_kinship'>Validate a kinship matrix</h2><span id='topic+validate_kinship'></span>

<h3>Description</h3>

<p>Tests that the input is a valid kinship matrix (a numeric, square, and optionally symmetric R matrix).
Intended for matrices to plot and for other uses, including biased estimates, so there is flexibility as to what constitutes a valid kinship matrix.
Throws errors if the input is not as above.
Can instead return <code>TRUE</code>/<code>FALSE</code> if <code>logical = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_kinship(kinship, sym = TRUE, name = "kinship", logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_kinship_+3A_kinship">kinship</code></td>
<td>
<p>The kinship matrix to validate.</p>
</td></tr>
<tr><td><code id="validate_kinship_+3A_sym">sym</code></td>
<td>
<p>If <code>TRUE</code> (default), the matrix is required to be symmetric.  Otherwise this particular test is skipped.</p>
</td></tr>
<tr><td><code id="validate_kinship_+3A_name">name</code></td>
<td>
<p>Default &quot;kinship&quot;.
Change to desired variable name for more informative error messages (i.e. &quot;A&quot; when used to validate the <code>A</code> matrix inside <code>popkin_A_min_subpops</code>).</p>
</td></tr>
<tr><td><code id="validate_kinship_+3A_logical">logical</code></td>
<td>
<p>If <code>FALSE</code> (default), function stops with an error message if the input is not a kinship matrix.
If <code>TRUE</code>, function instead returns <code>TRUE</code> if the input passed all tests (appears to be a valid kinship matrix) or <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>True kinship matrices have values strictly between 0 and 1, and diagonal values strictly between 0.5 and 1.
However, estimated matrices may contain values slightly out of range.
For greater flexibility, this function does not check for out-of-range values.
</p>


<h3>Value</h3>

<p>If <code>logical = FALSE</code> (default), nothing.
If <code>logical = TRUE</code>, returns <code>TRUE</code> if the input is a valid kinship matrix, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this is a valid (positive) example
kinship &lt;- matrix(c(0.5, 0, 0, 0.6), nrow=2)
# this will run without errors or warnings
validate_kinship(kinship)

# negative examples

# dies if input is missing
try( validate_kinship() )

# and if input is not a matrix
try( validate_kinship( 1:5 ) )

# and for non-numeric matrices
char_mat &lt;- matrix(c('a', 'b', 'c', 'd'), nrow=2)
try( validate_kinship( char_mat ) )

# and non-square matrices
non_kinship &lt;- matrix(1:2, nrow=2)
try( validate_kinship( non_kinship ) )

# and non-symmetric matrices
non_kinship &lt;- matrix(1:4, nrow=2)
try( validate_kinship( non_kinship ) )
# but example passes if we drop symmetry requirement this way
validate_kinship( non_kinship, sym = FALSE )

# instead of stopping, can get a logical value
# this returns FALSE
validate_kinship( non_kinship, logical = TRUE )

</code></pre>

<hr>
<h2 id='weights_subpops'>Get weights for individuals that balance subpopulations</h2><span id='topic+weights_subpops'></span>

<h3>Description</h3>

<p>This function returns positive weights that sum to one for individuals using subpopulation labels, such that every subpopulation receives equal weight.
In particular, if there are <code>K</code> subpopulations, then the sum of weights for every individuals of a given subpopulation will equal <code>1 / K</code>.
The weight of every individual is thus inversely proportional to the number of individuals in its subpopulation.
If the optional sub-subpopulation labels are also provided, then each sub-subpopulation within a given subpopulation is also weighted equally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_subpops(subpops, subsubpops = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_subpops_+3A_subpops">subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.</p>
</td></tr>
<tr><td><code id="weights_subpops_+3A_subsubpops">subsubpops</code></td>
<td>
<p>The optional length-<code>n</code> vector of sub-subpopulation assignments for each individual.
Each sub-subpopulation must belong to a single subpopulation (a nested hierarchy) or an error is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length-<code>n</code> vector of weights for each individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># if every individual has a different subpopulation, weights are uniform:
subpops &lt;- 1:10
weights &lt;- weights_subpops( subpops )
stopifnot( all( weights == rep.int( 1/10, 10 ) ) )

# subpopulations can be strings too
subpops &lt;- c('a', 'b', 'c')
weights &lt;- weights_subpops( subpops )
stopifnot( all( weights == rep.int( 1/3, 3 ) ) )

# if there are two subpopulations
# and the first has twice as many individuals as the second
# then the individuals in this first subpopulation weight half as much 
# as the ones in the second subpopulation
subpops &lt;- c(1, 1, 2)
weights &lt;- weights_subpops( subpops )
stopifnot( all( weights == c( 1/4, 1/4, 1/2 ) ) )

# 2-level hierarchy example
subpops &lt;- c(1, 1, 1, 2, 2)
subsubpops &lt;- c('a', 'b', 'b', 'c', 'd')
weights &lt;- weights_subpops( subpops, subsubpops )
stopifnot( all( weights == c( 1/4, 1/8, 1/8, 1/4, 1/4 ) ) )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
