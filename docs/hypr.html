<!DOCTYPE html><html><head><title>Help for package hypr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hypr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+,hypr,hypr-method'><p>Combining hypr objects by addition or interaction</p></a></li>
<li><a href='#add_intercept'><p>Intercept checks</p></a></li>
<li><a href='#centered_contrasts'><p>Contrast centering</p></a></li>
<li><a href='#cmat'><p>Retrieve or set contrast matrix</p></a></li>
<li><a href='#conversions'><p>Shorthand versions for simple hypothesis translation</p></a></li>
<li><a href='#filler_contrasts'><p>Generate filler contrasts</p></a></li>
<li><a href='#formula&lt;-'><p>Manipulate the formulas of an S4 object</p></a></li>
<li><a href='#ginv2'><p>Enhanced generalized inverse function</p></a></li>
<li><a href='#hmat'><p>Retrieve and set hypothesis matrix</p></a></li>
<li><a href='#hypr'><p>Create a hypr object</p></a></li>
<li><a href='#hypr-class'><p>S4 class “hypr” and its methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hypothesis Matrix Translation</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://maxrabe.com/hypr">https://maxrabe.com/hypr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mmrabe/hypr/issues">https://github.com/mmrabe/hypr/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Translation between experimental null hypotheses, hypothesis matrices, and contrast matrices as used in linear regression models. The package is based on the method described in Schad et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jml.2019.104038">doi:10.1016/j.jml.2019.104038</a>&gt; and Rabe et al. (2020) &lt;<a href="https://doi.org/10.21105%2Fjoss.02134">doi:10.21105/joss.02134</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, pracma, methods, cli, magrittr, Matrix,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'equations.R' 'hypr.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-09 10:33:20 UTC; max</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian M. Rabe
    <a href="https://orcid.org/0000-0002-2556-5644"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Shravan Vasishth <a href="https://orcid.org/0000-0003-2027-1994"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sven Hohenstein <a href="https://orcid.org/0000-0002-9708-1593"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Reinhold Kliegl <a href="https://orcid.org/0000-0002-0180-8488"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel J. Schad <a href="https://orcid.org/0000-0003-2586-6823"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian M. Rabe &lt;maximilian.rabe@uni-potsdam.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B+2Chypr+2Chypr-method'>Combining hypr objects by addition or interaction</h2><span id='topic++2B+2Chypr+2Chypr-method'></span><span id='topic++2A+2Chypr+2Chypr-method'></span><span id='topic++26+2Chypr+2Chypr-method'></span><span id='topic++2F+2Chypr+2Chypr-method'></span>

<h3>Description</h3>

<p>You can combine one or more <code>hypr</code> objects, i.e. combine their hypothesis to a single <code>hypr</code> object, by adding them with the <code>+</code> or <code>\*</code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hypr,hypr'
e1 + e2

## S4 method for signature 'hypr,hypr'
e1 * e2

## S4 method for signature 'hypr,hypr'
e1 &amp; e2

## S4 method for signature 'hypr,hypr'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B+2B2Chypr+2B2Chypr-method_+3A_e1">e1</code>, <code id="+2B2B+2B2Chypr+2B2Chypr-method_+3A_e2">e2</code></td>
<td>
<p><code>hypr</code> objects to concatenate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined <code>hypr</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>e1 * e2</code>: Interaction of <code>e1</code> and <code>e2</code>
</p>
</li>
<li> <p><code>e1 &amp; e2</code>: Interaction and main contrasts of <code>e1</code> and <code>e2</code>
</p>
</li>
<li> <p><code>e1 / e2</code>: Nesting levels of <code>e2</code> within <code>e1</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
(h1 &lt;- hypr(a~i, b~i)) # a hypr object of two treatments

(h2 &lt;- hypr(i~0)) # an intercept-only hypr object

hc &lt;- h1 + h2

hc

interaction &lt;- h1 &amp; h2

interaction_and_main &lt;- h1 * h2

</code></pre>

<hr>
<h2 id='add_intercept'>Intercept checks</h2><span id='topic+add_intercept'></span><span id='topic+remove_intercept'></span><span id='topic+is_intercept'></span><span id='topic+which_intercept'></span><span id='topic+has_intercept'></span>

<h3>Description</h3>

<p>Non-centered contrasts require an intercept for correct specification of experimental hypotheses. These functions enable the user to check for existance of intercepts and to add or remove intercept columns as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_intercept(x)

remove_intercept(x)

is_intercept(x)

which_intercept(x)

has_intercept(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_intercept_+3A_x">x</code></td>
<td>
<p>A hypr object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are functions available to check whether a <code>hypr</code> object contains an intercept (<code>has_intercept</code>) or which contrast is the intercept (<code>is_intercept</code>, <code>which_intercept</code>). Moreover, if needed, the user can add (<code>add_intercept</code>) or remove (<code>remove_intercept</code>) an intercept column to/from a hypr object. <code>add_intercept</code> and <code>remove_intercept</code> do not throw an error if the user attempts to remove a non-existing intercept or add an intercept if there already is one.
</p>


<h3>Value</h3>

<p>A single logical value (<code>has_intercept</code>), a logical vector (<code>is_intercept</code>), an integer index vector (<code>which_intercept</code>), or a modified hypr object (<code>add_intercept</code>, <code>remove_intercept</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add_intercept()</code>: Add an intercept column if there is none
</p>
</li>
<li> <p><code>remove_intercept()</code>: Remove the intercept column if there is one
</p>
</li>
<li> <p><code>which_intercept()</code>: Return indices, not a logical vector of intercept columns
</p>
</li>
<li> <p><code>has_intercept()</code>: Check whether any of the contrasts is an intercept
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
h1 &lt;- hypr(mu1~0, mu2~mu1)
h2 &lt;- hypr(mu2~mu1, mu3~mu1)

stopifnot(has_intercept(h1))
stopifnot(!has_intercept(h2))
stopifnot(which_intercept(h1) == 1)
stopifnot(is_intercept(h1) == c(TRUE,FALSE))

</code></pre>

<hr>
<h2 id='centered_contrasts'>Contrast centering</h2><span id='topic+centered_contrasts'></span><span id='topic+is_centered'></span><span id='topic+all_centered'></span><span id='topic+which_centered'></span>

<h3>Description</h3>

<p>Centeredness of contrasts is critical for the interpretation of interactions and intercepts. There are functions available to check for centered contrasts and to realign contrasts so that they are centered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centered_contrasts(x)

is_centered(x)

all_centered(x, ignore_intercept = TRUE)

which_centered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centered_contrasts_+3A_x">x</code></td>
<td>
<p>A hypr object</p>
</td></tr>
<tr><td><code id="centered_contrasts_+3A_ignore_intercept">ignore_intercept</code></td>
<td>
<p>If <code>TRUE</code>, the intercept is ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>centered_contrasts(x)</code> will return a copy of <code>x</code> where all contrasts were centered to a zero mean.
</p>
<p>The functions <code>is_centered(x)</code> and <code>which_centered()</code> indicate which contrasts of <code>x</code>, are centered. <code>all_centered(x)</code> will return <code>TRUE</code> if all contrasts in <code>x</code> are centered or <code>FALSE</code> if at least one contrast is not.
</p>


<h3>Value</h3>

<p>A centered set of hypr contrasts (<code>centered_contrasts</code>), a single logical value (<code>all_centered</code>), a logical vector (<code>is_centered</code>), or an integer index vector (<code>which_centered</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is_centered()</code>: Check which contrasts of <code>x</code> are centered
</p>
</li>
<li> <p><code>all_centered()</code>: Check whether all contrasts of <code>x</code> are centered
</p>
</li>
<li> <p><code>which_centered()</code>: Check which contrasts of <code>x</code> are centered
</p>
</li></ul>

<hr>
<h2 id='cmat'>Retrieve or set contrast matrix</h2><span id='topic+cmat'></span><span id='topic+cmat+3C-'></span><span id='topic+contr.hypothesis'></span><span id='topic+contrasts+3C-+2Cfactor+2CANY+2Chypr-method'></span><span id='topic+contrasts+3C-+2Cfactor+2CANY+2Chypr_cmat-method'></span><span id='topic+contr.hypothesis+3C-'></span>

<h3>Description</h3>

<p>Use these functions to retrieve or set a <code>hypr</code> object’s contrast matrix. If used for updating, the hypothesis matrix and equations are derived automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmat(x, add_intercept = FALSE, remove_intercept = FALSE, as_fractions = TRUE)

cmat(x, add_intercept = FALSE, remove_intercept = FALSE) &lt;- value

contr.hypothesis(
  ...,
  add_intercept = FALSE,
  remove_intercept = NULL,
  as_fractions = FALSE
)

## S4 replacement method for signature 'factor,ANY,hypr'
contrasts(x, how.many = NULL) &lt;- value

## S4 replacement method for signature 'factor,ANY,hypr_cmat'
contrasts(x, how.many = NULL) &lt;- value

contr.hypothesis(
  x,
  add_intercept = NULL,
  remove_intercept = FALSE,
  as_fractions = FALSE
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmat_+3A_x">x</code></td>
<td>
<p>A hypr object</p>
</td></tr>
<tr><td><code id="cmat_+3A_add_intercept">add_intercept</code></td>
<td>
<p>Add additional intercept column to contrast matrix</p>
</td></tr>
<tr><td><code id="cmat_+3A_remove_intercept">remove_intercept</code></td>
<td>
<p>If <code>TRUE</code>, tries to find an intercept column (all codes equal) and removes it from the matrix. If <code>NULL</code>, does the same but does not throw an exception if no intercept is found. <code>FALSE</code> explicitly disables this functionality. A numeric argument explicitly identifies the index of the column to be removed.</p>
</td></tr>
<tr><td><code id="cmat_+3A_as_fractions">as_fractions</code></td>
<td>
<p>Should the returned matrix be formatted as fractions (using <code><a href="MASS.html#topic+as.fractions">MASS::as.fractions()</a></code>)?</p>
</td></tr>
<tr><td><code id="cmat_+3A_value">value</code></td>
<td>
<p>contrast matrix</p>
</td></tr>
<tr><td><code id="cmat_+3A_...">...</code></td>
<td>
<p>A list of hypothesis equations for which to retrieve a contrast matrix</p>
</td></tr>
<tr><td><code id="cmat_+3A_how.many">how.many</code></td>
<td>
<p>see <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic specification of contrasts in R is accomplished with basic R functions <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code> and <code><a href="stats.html#topic+C">stats::C()</a></code> (Chambers &amp; Hastie, 1992). Other relevant packages for this topic are <code>multcomp</code> (Bretz et al., 2010), <code>contrast</code> (Kuhn et al., 2016), and, including also various vignettes, <code>emmeans</code> (Lenth, 2019).
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of contrast codes with contrasts as columns and levels as rows.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cmat(x, add_intercept = FALSE, remove_intercept = FALSE) &lt;- value</code>: Set contrast matrix
</p>
</li>
<li> <p><code>contr.hypothesis()</code>: Retrieve contrast matrix with sensible intercept default to override factor contrasts
</p>
</li>
<li> <p><code>contrasts(x = factor, how.many = ANY) &lt;- value</code>: Update factor contrasts
</p>
</li>
<li> <p><code>contrasts(x = factor, how.many = ANY) &lt;- value</code>: Update factor contrasts
</p>
</li>
<li> <p><code>contr.hypothesis(
  x,
  add_intercept = NULL,
  remove_intercept = FALSE,
  as_fractions = FALSE
) &lt;- value</code>: Update contrast matrix with sensible intercept default
</p>
</li></ul>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical models</em>. Chapter 2 of <em>Statistical Models</em> in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>Frank Bretz, Torsten Hothorn and Peter Westfall (2010), <em>Multiple Comparisons Using R</em>, CRC Press, Boca Raton.
</p>
<p>Max Kuhn, contributions from Steve Weston, Jed Wing, James Forester and Thorn Thaler (2016). <em>contrast: A Collection of Contrast Methods</em>. R package version 0.21. <a href="https://CRAN.R-project.org/package=contrast">https://CRAN.R-project.org/package=contrast</a>
</p>
<p>Lenth, R. (2019). <em>emmeans: Estimated Marginal Means, aka Least-Squares Means</em>. R package version 1.4.1. <a href="https://CRAN.R-project.org/package=emmeans">https://CRAN.R-project.org/package=emmeans</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypr">hypr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- hypr(mu1~0, mu2~mu1)
cmat(h) # retrieve the contrast matrix

contr.hypothesis(h) # by default without intercept (removes first column)
contr.hypothesis(mu1~0, mu2~mu1)

</code></pre>

<hr>
<h2 id='conversions'>Shorthand versions for simple hypothesis translation</h2><span id='topic+conversions'></span><span id='topic+eqs2hmat'></span><span id='topic+eqs2cmat'></span><span id='topic+hmat2cmat'></span><span id='topic+cmat2hmat'></span><span id='topic+hmat2eqs'></span><span id='topic+cmat2eqs'></span>

<h3>Description</h3>

<p>These functions can be used to translate between null hypothesis equations, hypothesis matrices, and contrast matrices without defining a <code>hypr</code> object. Note that some of these functions do generate a <code>hypr</code> object internally but they never return one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqs2hmat(
  eqs,
  levels = NULL,
  order_levels = missing(levels),
  as_fractions = TRUE
)

eqs2cmat(eqs, as_fractions = TRUE)

hmat2cmat(hmat, as_fractions = TRUE)

cmat2hmat(cmat, as_fractions = TRUE)

hmat2eqs(hmat, as_fractions = TRUE)

cmat2eqs(cmat, as_fractions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversions_+3A_eqs">eqs</code></td>
<td>
<p>A <code>list</code> of equations</p>
</td></tr>
<tr><td><code id="conversions_+3A_levels">levels</code></td>
<td>
<p>(optional) A <code>character</code> vector of variables to be expected (if not provided, automatically generated from all terms occurring in the equations list)</p>
</td></tr>
<tr><td><code id="conversions_+3A_order_levels">order_levels</code></td>
<td>
<p>(optional) Whether to alphabetically order appearance of levels (rows in transposed hypothesis matrix or contrast matrix). Default is <code>TRUE</code> if <code>levels</code> were not explicitly provided.</p>
</td></tr>
<tr><td><code id="conversions_+3A_as_fractions">as_fractions</code></td>
<td>
<p>(optional) Whether to output matrix using fractions formatting (via <code><a href="MASS.html#topic+as.fractions">MASS::as.fractions</a></code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conversions_+3A_hmat">hmat</code></td>
<td>
<p>Hypothesis matrix</p>
</td></tr>
<tr><td><code id="conversions_+3A_cmat">cmat</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of equations (<code>hmat2eqs</code> and <code>cmat2eqs</code>), a contrast matrix (<code>hmat2cmat</code>, <code>eqs2cmat</code>), or a hypothesis matrix (<code>cmat2hmat</code>, <code>eqs2hmat</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>eqs2hmat()</code>: Convert null hypothesis equations to hypothesis matrix
</p>
</li>
<li> <p><code>eqs2cmat()</code>: Convert null hypothesis equations to contrast matrix
</p>
</li>
<li> <p><code>hmat2cmat()</code>: Convert hypothesis matrix to contrast matrix
</p>
</li>
<li> <p><code>cmat2hmat()</code>: Convert contrast matrix to hypothesis matrix
</p>
</li>
<li> <p><code>hmat2eqs()</code>: Convert hypothesis matrix to null hypothesis equations
</p>
</li>
<li> <p><code>cmat2eqs()</code>: Convert contrast matrix to null hypothesis equations
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following examples are based on a 2-level treatment contrast (i.e., baseline and treatment).
hypotheses &lt;- list(baseline = mu1~0, treatment = mu2~mu1)
hypothesis_matrix &lt;- matrix(
    c(c(1, -1), c(0, 1)), ncol = 2, dimnames = list(c("baseline","treatment"), c("mu1", "mu2")))
contrast_matrix &lt;- matrix(
    c(c(1, 1), c(0, 1)), ncol = 2, dimnames = list(c("mu1","mu2"), c("baseline", "treatment")))

# Convert a list of null hypothesis equations to ...
# ... a hypothesis matrix:
eqs2hmat(hypotheses)
# ... a contrast matrix:
eqs2cmat(hypotheses)

# Convert a hypothesis matrix to...
# ... a list of null hypothesis equations:
hmat2eqs(hypothesis_matrix)
# ... a contrast matrix:
hmat2cmat(hypothesis_matrix)

# Convert a contrast matrix to...
# ... a list of null hypothesis equations:
cmat2eqs(contrast_matrix)
# ... a hypothesis matrix:
cmat2hmat(contrast_matrix)


# Are all functions returning the expected results?
stopifnot(all.equal(eqs2hmat(hypotheses, as_fractions = FALSE), hypothesis_matrix))
stopifnot(all.equal(eqs2cmat(hypotheses, as_fractions = FALSE), contrast_matrix))
stopifnot(all.equal(hmat2cmat(hypothesis_matrix, as_fractions = FALSE), contrast_matrix))
stopifnot(all.equal(cmat2hmat(contrast_matrix, as_fractions = FALSE), hypothesis_matrix))

</code></pre>

<hr>
<h2 id='filler_contrasts'>Generate filler contrasts</h2><span id='topic+filler_contrasts'></span><span id='topic+which_filler'></span><span id='topic+which_target'></span><span id='topic+filler_names'></span><span id='topic+target_names'></span>

<h3>Description</h3>

<p>Fill free degrees of freedom with orthogonal filler contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filler_contrasts(x, how.many = nlevels(x), rescale = FALSE)

which_filler(x)

which_target(x)

filler_names(x)

target_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filler_contrasts_+3A_x">x</code></td>
<td>
<p>A hypr object</p>
</td></tr>
<tr><td><code id="filler_contrasts_+3A_how.many">how.many</code></td>
<td>
<p>The total number of contrasts for the new hypr object</p>
</td></tr>
<tr><td><code id="filler_contrasts_+3A_rescale">rescale</code></td>
<td>
<p>If <code>TRUE</code>, the contrast weights will be rescaled</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>which_filler()</code>: Return indices of filler contrasts
</p>
</li>
<li> <p><code>which_target()</code>: Return indices of filler contrasts
</p>
</li>
<li> <p><code>filler_names()</code>: Return names of filler contrasts
</p>
</li>
<li> <p><code>target_names()</code>: Return names of target contrasts
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# A complete Helmert contrast matrix for 4 levels:
h1 &lt;- hypr(~ (mu2-mu1)/2,
          ~ (mu3-(mu1+mu2)/2)/3,
          ~ (mu4-(mu1+mu2+mu3)/3)/4,
          levels = c("mu1", "mu2", "mu3", "mu4")
          )
cmat(h1)

# An incomplete Helmer contrast matrix (2nd contrast dropped)
h2 &lt;- hypr(~ (mu2-mu1)/2,
           ~ (mu4-(mu1+mu2+mu3)/3)/4,
           levels = c("mu1", "mu2", "mu3", "mu4")
           )
cmat(h2)

# Filling the remaining degree of freedom retrieves the contrast
h3 &lt;- filler_contrasts(h2, rescale = TRUE)
cmat(h3)

stopifnot(all.equal(cmat(h3)[,3], cmat(h1)[,2], check.attributes = FALSE))

</code></pre>

<hr>
<h2 id='formula+26lt+3B-'>Manipulate the formulas of an S4 object</h2><span id='topic+formula+3C-'></span>

<h3>Description</h3>

<p>This is a generic function for setting an S4 object’s formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>The object to manipulate</p>
</td></tr>
<tr><td><code id="formula+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the method</p>
</td></tr>
<tr><td><code id="formula+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The new formula</p>
</td></tr>
</table>

<hr>
<h2 id='ginv2'>Enhanced generalized inverse function</h2><span id='topic+ginv2'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>MASS::ginv</code> and calculates the generalized inverse of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginv2(x, as_fractions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ginv2_+3A_x">x</code></td>
<td>
<p>The original matrix</p>
</td></tr>
<tr><td><code id="ginv2_+3A_as_fractions">as_fractions</code></td>
<td>
<p>Whether to format the matrix as fractions (MASS package)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to <code>MASS::ginv</code>, this function rounds values, formats the matrix as fractions and copies dimension names from the original matrix.
</p>


<h3>Value</h3>

<p>Generalized inverse of <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- hypr(mu1~0, mu2~mu1)
hmat(h)

ginv2(hmat(h))
cmat(h)

# cmat is effectively the generalized inverse of hmat
stopifnot(all.equal(
`class&lt;-`(ginv2(hmat(h)), "matrix"),
`class&lt;-`(cmat(h), "matrix"), check.attributes = FALSE))

</code></pre>

<hr>
<h2 id='hmat'>Retrieve and set hypothesis matrix</h2><span id='topic+hmat'></span><span id='topic+thmat'></span><span id='topic+hmat+3C-'></span><span id='topic+thmat+3C-'></span>

<h3>Description</h3>

<p>Use these functions to retrieve or set a hypr object's hypothesis matrix. If used for updating, the contrast matrix and equations are derived automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmat(x, as_fractions = TRUE)

thmat(x, as_fractions = TRUE)

hmat(x) &lt;- value

thmat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmat_+3A_x">x</code></td>
<td>
<p>A hypr object</p>
</td></tr>
<tr><td><code id="hmat_+3A_as_fractions">as_fractions</code></td>
<td>
<p>Whether to format matrix as fractions (via <code><a href="MASS.html#topic+as.fractions">MASS::as.fractions</a></code>)</p>
</td></tr>
<tr><td><code id="hmat_+3A_value">value</code></td>
<td>
<p>Hypothesis matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hypothesis matrix of <code>x</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>thmat()</code>: Retrieve transposed hypothesis matrix
</p>
</li>
<li> <p><code>hmat(x) &lt;- value</code>: Set hypothesis matrix
</p>
</li>
<li> <p><code>thmat(x) &lt;- value</code>: Set transposed hypothesis matrix
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- hypr(mu1~0, mu2~mu1)

# To retrieve the hypothesis matrix of `h`:
hmat(h)

# To retrieve the transposed hypothesis matrix of `h`:
thmat(h)

# Setting the hypothesis matrix of `h`:
hmat(h) &lt;- matrix(c(1,-1,0,1), ncol=2, dimnames=list(NULL, c("mu1","mu2")))
h

h2 &lt;- hypr() # an empty hypr object
thmat(h2) &lt;- matrix(c(1,0,-1,1), ncol=2, dimnames=list(c("mu1","mu2"), NULL))
h2

# `h` and `h2` should be identical:
stopifnot(all.equal(hmat(h), hmat(h2)))
stopifnot(all.equal(cmat(h), cmat(h2)))

</code></pre>

<hr>
<h2 id='hypr'>Create a hypr object</h2><span id='topic+hypr'></span>

<h3>Description</h3>

<p>Use this function to create hypr objects from null hypothesis equations. Each argument should be one equation. For example, a null hypothesis for the grand mean (GM), often used as the intercept, is usually coded as <code>mu~0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypr(
  ...,
  levels = NULL,
  add_intercept = FALSE,
  remove_intercept = FALSE,
  order_levels = missing(levels)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypr_+3A_...">...</code></td>
<td>
<p>A list of null hypothesis equations</p>
</td></tr>
<tr><td><code id="hypr_+3A_levels">levels</code></td>
<td>
<p>(Optional) A list of terms/levels to use. If supplied, matrix rows/columns will be in this order. An error will be thrown if an equation contains a level that is not in this vector.</p>
</td></tr>
<tr><td><code id="hypr_+3A_add_intercept">add_intercept</code></td>
<td>
<p>If <code>TRUE</code>, an intercept will be added</p>
</td></tr>
<tr><td><code id="hypr_+3A_remove_intercept">remove_intercept</code></td>
<td>
<p>If <code>TRUE</code>, an intercept will be dropped</p>
</td></tr>
<tr><td><code id="hypr_+3A_order_levels">order_levels</code></td>
<td>
<p>(Optional) Whether to order the rows/columns of the hypothesis/contrast matrices alphabetically. Default is <code>TRUE</code> if <code>levels</code> were not explicitly provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You may call the function without any arguments. In that case, an empty hypr object is returned. This is useful if you want to derive equations from a known hypothesis matrix or contrast matrix.
</p>
<p>Basic specification of contrasts in R is accomplished with basic R functions <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code> and <code><a href="stats.html#topic+C">stats::C()</a></code> (Chambers &amp; Hastie, 1992). Other relevant packages for this topic are <code>multcomp</code> (Bretz et al., 2010), <code>contrast</code> (Kuhn et al., 2016), and, including also various vignettes, <code>emmeans</code> (Lenth, 2019).
</p>


<h3>Value</h3>

<p>A <code>hypr</code> object
</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical models</em>. Chapter 2 of <em>Statistical Models</em> in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>Frank Bretz, Torsten Hothorn and Peter Westfall (2010), <em>Multiple Comparisons Using R</em>, CRC Press, Boca Raton.
</p>
<p>Max Kuhn, contributions from Steve Weston, Jed Wing, James Forester and Thorn Thaler (2016). <em>contrast: A Collection of Contrast Methods</em>. R package version 0.21. <a href="https://CRAN.R-project.org/package=contrast">https://CRAN.R-project.org/package=contrast</a>
</p>
<p>Lenth, R. (2019). <em>emmeans: Estimated Marginal Means, aka Least-Squares Means</em>. R package version 1.4.1. <a href="https://CRAN.R-project.org/package=emmeans">https://CRAN.R-project.org/package=emmeans</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contrasts">contrasts</a></code> and <code><a href="stats.html#topic+C">C</a></code> for basic specification of contrasts in R, S4 class <code><a href="#topic+hypr-class">hypr</a></code>, <code><a href="#topic+cmat">cmat</a></code>, <code><a href="#topic+contr.hypothesis">contr.hypothesis</a></code> for retrieval of contrast matrices from <code>hypr</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an empty hypr object (no hypotheses):
h &lt;- hypr()

# Treatment contrast:
h &lt;- hypr(mu1~0, mu2~mu1, mu3~mu1, mu4~mu1)

# Identical version:
h &lt;- hypr(~mu1, ~mu2-mu1, ~mu3-mu1, ~mu4-mu1)

contr.hypothesis(h)


# Generate a dataset
set.seed(123)
M &lt;- c(mu1 = 10, mu2 = 20, mu3 = 10, mu4 = 40) # condition means
N &lt;- 5 # number of observations per condition
SD &lt;- 10 # residual SD
simdat &lt;- do.call(rbind, lapply(names(M), function(x) {
  data.frame(X = x, DV = as.numeric(MASS::mvrnorm(N, unname(M[x]), SD^2, empirical = TRUE)))
}))
simdat$X &lt;- factor(simdat$X, levels=levels(h))
simdat

# Check agreement of hypothesis levels and factor levels
stopifnot(levels(h) == levels(simdat$X))

# Linear regression
contrasts(simdat$X) &lt;- contr.hypothesis(h)

round(coef(summary(lm(DV ~ X, data=simdat))),3)

</code></pre>

<hr>
<h2 id='hypr-class'>S4 class “hypr” and its methods</h2><span id='topic+hypr-class'></span><span id='topic+show+2Chypr-method'></span><span id='topic+levels+2Chypr-method'></span><span id='topic+nlevels+2Chypr-method'></span><span id='topic+names+2Chypr-method'></span><span id='topic+as.call+2Chypr-method'></span><span id='topic+names+3C-+2Chypr-method'></span><span id='topic+levels+3C-+2Chypr-method'></span><span id='topic+formula+2Chypr-method'></span><span id='topic+formula+3C-+2Chypr-method'></span>

<h3>Description</h3>

<p>A <code>hypr</code> object contains equations, a hypothesis matrix and a contrast matrix, all of which are related to each other. See below for methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hypr'
show(object)

## S4 method for signature 'hypr'
levels(x)

## S4 method for signature 'hypr'
nlevels(x)

## S4 method for signature 'hypr'
names(x)

## S4 method for signature 'hypr'
as.call(x)

## S4 replacement method for signature 'hypr'
names(x) &lt;- value

## S4 replacement method for signature 'hypr'
levels(x) &lt;- value

## S4 method for signature 'hypr'
formula(x, ...)

## S4 replacement method for signature 'hypr'
formula(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypr-class_+3A_object">object</code>, <code id="hypr-class_+3A_x">x</code></td>
<td>
<p>a hypr object</p>
</td></tr>
<tr><td><code id="hypr-class_+3A_value">value</code></td>
<td>
<p>New value (<code>list</code> of equations for <code>formula</code>, <code>character</code> vector for <code>levels</code> and <code>names</code>)</p>
</td></tr>
<tr><td><code id="hypr-class_+3A_...">...</code></td>
<td>
<p>(ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate a hypr object, use the <code><a href="#topic+hypr">hypr</a></code> function.
</p>


<h3>Value</h3>

<p>A character vector of level names
</p>
<p>An integer denoting the number of levels
</p>
<p>A character vector of contrast names
</p>
<p>A <code>call</code> object that reproduces the <code>hypr</code> object
</p>
<p>A <code>list</code> of null hypothesis equations
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(hypr)</code>: Show summary of hypr object, including contrast equations, the (transposed) hypothesis matrix and the derived contrast matrix.
</p>
</li>
<li> <p><code>levels(hypr)</code>: Retrieve the levels (variable names) used in a <code>hypr</code> object
</p>
</li>
<li> <p><code>nlevels(hypr)</code>: Retrieve the number of levels (variable names) used in a <code>hypr</code> object
</p>
</li>
<li> <p><code>names(hypr)</code>: Retrieve the contrast names used in a <code>hypr</code> object
</p>
</li>
<li> <p><code>as.call(hypr)</code>: Transform <code>hypr</code> object to a reproducible function call
</p>
</li>
<li> <p><code>names(hypr) &lt;- value</code>: Set the contrast names used in a <code>hypr</code> object
</p>
</li>
<li> <p><code>levels(hypr) &lt;- value</code>: Set the levels used in a <code>hypr</code> object
</p>
</li>
<li> <p><code>formula(hypr)</code>: Retrieve a <code>hypr</code> object’s null hypothesis equations.
</p>
</li>
<li> <p><code>formula(hypr) &lt;- value</code>: Modify a <code>hypr</code> object’s null hypothesis equations
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>eqs</code></dt><dd><p>List of null hypotheses</p>
</dd>
<dt><code>hmat</code></dt><dd><p>Hypothesis matrix</p>
</dd>
<dt><code>cmat</code></dt><dd><p>Contrast matrix</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+hypr">hypr</a></code>, <code><a href="#topic+cmat">cmat</a></code>, <code><a href="#topic+hmat">hmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Equations and matrices in a hypr object are always congruent
# Therefore creating a hypr object h and then copying ...
h &lt;- hypr(mu1~0, mu2~mu1)

# ... its equations, ...
h2 &lt;- hypr()
formula(h2) &lt;- formula(h)

# ... its hypothesis matrix, ...
h3 &lt;- hypr()
hmat(h3) &lt;- hmat(h)

# ... or its contast matrix ...
h4 &lt;- hypr()
cmat(h4) &lt;- cmat(h)

# ... over to another hypr object is the same as copying the object:
h5 &lt;- h

# check that hypr objects are equal by comparing hmat() and cmat()
stopifnot(all.equal(hmat(h), hmat(h2)))
stopifnot(all.equal(cmat(h), cmat(h2)))
stopifnot(all.equal(hmat(h), hmat(h3)))
stopifnot(all.equal(cmat(h), cmat(h3)))
stopifnot(all.equal(hmat(h), hmat(h4)))
stopifnot(all.equal(cmat(h), cmat(h4)))
stopifnot(all.equal(hmat(h), hmat(h5)))
stopifnot(all.equal(cmat(h), cmat(h5)))


h &lt;- hypr(mu1~0, mu2~mu1)
formula(h)

h2 &lt;- hypr()
formula(h2) &lt;- formula(h)
h2
formula(h2)

# After updating, matrices should be equal
stopifnot(all.equal(hmat(h), hmat(h2)))
stopifnot(all.equal(cmat(h), cmat(h2)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
