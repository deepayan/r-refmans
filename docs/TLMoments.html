<!DOCTYPE html><html><head><title>Help for package TLMoments</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TLMoments}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.parameters'><p>Converting to parameters-objects</p></a></li>
<li><a href='#as.PWMs'><p>Convert to PWMs-object</p></a></li>
<li><a href='#as.TLMoments'><p>Convert to TLMoments-object</p></a></li>
<li><a href='#est_cov'><p>Covariance matrix of PWMs, TLMoments, parameters, or quantiles</p></a></li>
<li><a href='#est_paramcov'><p>Estimate the covariance matrix of parameter estimations</p></a></li>
<li><a href='#est_pwmcov'><p>Estimate the covariance matrix of PWM estimations</p></a></li>
<li><a href='#est_quancov'><p>Estimate the covariance matrix of quantile estimations</p></a></li>
<li><a href='#est_tlmcov'><p>Estimate the covariance matrix of TL-moments estimations</p></a></li>
<li><a href='#parameters'><p>Converting TL-moments to distribution parameters</p></a></li>
<li><a href='#pgev'><p>Generalized Extreme Value distribution</p></a></li>
<li><a href='#pgpd'><p>Generalized Pareto distribution</p></a></li>
<li><a href='#pgum'><p>Gumbel distribution</p></a></li>
<li><a href='#pln3'><p>Three-parameter lognormal distribution</p></a></li>
<li><a href='#plot.TLMoments'><p>L-Moment-ratio diagram</p></a></li>
<li><a href='#PWM'><p>Probability weighted moments</p></a></li>
<li><a href='#PWMs'><p>Probability weighted moments</p></a></li>
<li><a href='#quantiles'><p>Calculating quantiles from distribution parameters</p></a></li>
<li><a href='#regionalize'><p>Calculation of regionalized TL-moments</p></a></li>
<li><a href='#returnParameters'><p>returnParameters</p></a></li>
<li><a href='#returnPWMs'><p>returnPWMs</p></a></li>
<li><a href='#returnQuantiles'><p>returnQuantiles</p></a></li>
<li><a href='#returnTLMoments'><p>returnTLMoments</p></a></li>
<li><a href='#summary.parameters'><p>Summary parameters</p></a></li>
<li><a href='#summary.PWMs'><p>Summary PWMs</p></a></li>
<li><a href='#summary.quantiles'><p>Summary quantiles</p></a></li>
<li><a href='#summary.TLMoments'><p>Summary TLMoments</p></a></li>
<li><a href='#TLMoment'><p>Trimmed L Moments</p></a></li>
<li><a href='#TLMoments'><p>Trimmed L-moments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate TL-Moments and Convert Them to Distribution Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Jona Lilienthal</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jona Lilienthal &lt;lilienthal@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates empirical TL-moments (trimmed L-moments) of arbitrary 
    order and trimming, and converts them to distribution parameters. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), Rcpp (&ge; 0.12.12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>hypergeo, ggplot2, stats, lmomco</td>
</tr>
<tr>
<td>Suggests:</td>
<td>evd, knitr, magrittr, lmom, Lmoments, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-27 12:53:31 UTC; jona</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-27 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.parameters'>Converting to parameters-objects</h2><span id='topic+as.parameters'></span><span id='topic+as.parameters.numeric'></span><span id='topic+as.parameters.matrix'></span><span id='topic+as.parameters.list'></span><span id='topic+as.parameters.data.frame'></span>

<h3>Description</h3>

<p>Convert vector, matrix, list, or data.frame to parameters-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.parameters(..., distr = NULL)

## S3 method for class 'numeric'
as.parameters(..., distr)

## S3 method for class 'matrix'
as.parameters(x, distr, ...)

## S3 method for class 'list'
as.parameters(x, distr, ...)

## S3 method for class 'data.frame'
as.parameters(x, formula, distr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.parameters_+3A_...">...</code></td>
<td>
<p>parameters of distribution. This can be named vectors or lists, matrices, or data.frames. See examples below.</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_distr">distr</code></td>
<td>
<p>character giving the distribution. Function of name
q\&quot;distr\&quot; has to be available.</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_x">x</code></td>
<td>
<p>numeric vector, matrix, list, or data.frame of parameters.</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_formula">formula</code></td>
<td>
<p>if <code>x</code> is data.frame a formula has to be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class parameters, see parameters help page.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: as.parameters for numeric data vectors
</p>
</li>
<li> <p><code>matrix</code>: as.parameters for numeric data matrices
</p>
</li>
<li> <p><code>list</code>: as.parameters for numeric data lists
</p>
</li>
<li> <p><code>data.frame</code>: as.parameters for numeric data.frames
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+parameters">parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vector input:
as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev")
as.parameters(c(loc = 3, scale = 2, shape = .4), distr = "gev")

# Names can be shortened if unambiguous:
as.parameters(l = 3, sc = 2, sh = .4, distr = "gev")
as.parameters(m = 3, s = 1, distr = "norm")

# Wrong or ambiguous names lead to errors!
## Not run: 
as.parameters(l = 3, s = 2, s = .4, distr = "gev")
as.parameters(loc2 = 3, scale = 2, shape = .4, distr = "gev")

## End(Not run)

# If no names are given, a warning is given and they are guessed for gev, gpd, gum, and ln3.
as.parameters(3, 2, .4, distr = "gev")
as.parameters(c(3, 2, .4), distr = "gev")
## Not run: 
as.parameters(3, 2, .2, .4, distr = "gev") #=&gt; doesn't work

## End(Not run)

# Matrix input:
# Parameters in matrices must have either matching rownames or colnames!
as.parameters(cbind(loc = 10, scale = 4, shape = seq(0, .4, .1)), distr = "gev")
as.parameters(rbind(loc = 10, scale = 4, shape = seq(0, .4, .1)), distr = "ln3")

# If no names are given, a guess is made based on number of rows
# or cols according to distribution (and a warning is given).
as.parameters(matrix(1:9, nr = 3), distr = "gev")
as.parameters(matrix(1:8, nc = 2), distr = "gum")


# The same principles apply for list input and data.frames:

# List input:
as.parameters(list(list(mean = 2, sd = 1), list(mean = 0, sd = 1)), distr = "norm")
as.parameters(list(c(m = 2, s = 1), c(m = 0, s = 1)), distr = "norm")
as.parameters(list(c(loc = 2, scale = 1), c(0, 1)), distr = "gum")
## Not run: 
as.parameters(list(c(loc = 2, scale = 1), c(0, 1, 2)), distr = "gum")

## End(Not run)

# Dataframe input:
xdat &lt;- data.frame(station = c(1, 2), mean = c(2, 0), sd = c(1, 1))
as.parameters(xdat, cbind(mean, sd) ~ station, distr = "norm")
as.parameters(xdat, . ~ station, distr = "norm")
as.parameters(xdat, cbind(mean, sd) ~ ., distr = "norm")

xdat &lt;- data.frame(station = c(1, 2), m = c(2, 0), s = c(1, 1))
as.parameters(xdat, cbind(m, s) ~ station, distr = "norm")
## Not run: 
as.parameters(xdat, cbind(m, s) ~ station, distr = "gev")

## End(Not run)

###

# Results of as.parameters can be used in the normal TLMoments-scheme:
# they can be transfered to quantiles or to TLMoments.

xdat &lt;- data.frame(station = c(1, 2), mean = c(2, 0), sd = c(1, 1))
quantiles(as.parameters(xdat, cbind(mean, sd) ~ ., distr = "norm"), c(.99))

# quantile estimation
p &lt;- as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev")
quantiles(p, c(.9, .95))
p &lt;- as.parameters(cbind(loc = 10, scale = 4, shape = seq(0, .4, .1)), distr = "gev")
quantiles(p, c(.9, .95))
p &lt;- as.parameters(list(list(mean = 2, sd = 1), list(mean = 0, sd = 1)), distr = "norm")
quantiles(p, c(.95, .975))

# With magrittr
library(magrittr)
as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev") %&gt;% quantiles(c(.9, .99))
</code></pre>

<hr>
<h2 id='as.PWMs'>Convert to PWMs-object</h2><span id='topic+as.PWMs'></span><span id='topic+as.PWMs.numeric'></span><span id='topic+as.PWMs.matrix'></span><span id='topic+as.PWMs.list'></span><span id='topic+as.PWMs.data.frame'></span>

<h3>Description</h3>

<p>Convert vector, matrix, list, or data.frame to PWMs-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PWMs(x, ..., order = NULL)

## S3 method for class 'numeric'
as.PWMs(x, order = seq_along(x) - 1, ...)

## S3 method for class 'matrix'
as.PWMs(x, order = row(x)[, 1] - 1, ...)

## S3 method for class 'list'
as.PWMs(x, order = seq_along(x[[1]]) - 1, ...)

## S3 method for class 'data.frame'
as.PWMs(x, formula, order = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.PWMs_+3A_x">x</code></td>
<td>
<p>vector or matrix of PWMs.</p>
</td></tr>
<tr><td><code id="as.PWMs_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="as.PWMs_+3A_order">order</code></td>
<td>
<p>integer, corresponding order to given PWMs. If NULL, order is set to 0:(length(x)-1).</p>
</td></tr>
<tr><td><code id="as.PWMs_+3A_formula">formula</code></td>
<td>
<p>if <code>x</code> is data.frame. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class PWMs, see PWMs help page.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: as.PWMs for numeric data vectors
</p>
</li>
<li> <p><code>matrix</code>: as.PWMs for numeric data matrices
</p>
</li>
<li> <p><code>list</code>: as.PWMs for numeric data lists
</p>
</li>
<li> <p><code>data.frame</code>: as.PWMs for numeric data.frames
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmat &lt;- cbind(c(0.12, .41, .38, .33), c(.05, 0.28, .25, .22))
xvec &lt;- xmat[, 1]
xlist &lt;- lapply(1:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = letters[1:3],
 season = c("S", "W", "S"),
 b0 = c(.12, .15, .05),
 b1 = c(.41, .33, .28),
 b2 = c(.38, .18, .25)
)

as.PWMs(xvec)
as.PWMs(xvec[-2], order = c(0, 2, 3))

as.PWMs(xmat)
as.PWMs(xmat[-2, ], order = c(0, 2, 3))

as.PWMs(xlist)

as.PWMs(xdat, cbind(b0, b1, b2) ~ station)
as.PWMs(xdat, . ~ station + season)
as.PWMs(xdat, cbind(b0, b2) ~ station, order = c(0, 2))

p &lt;- as.PWMs(xdat, cbind(b0, b1, b2) ~ station)
TLMoments(p)

(p &lt;- as.PWMs(xdat, cbind(b0, b1) ~ station))
#parameters(TLMoments(p), "gev") # =&gt; error
#parameters(TLMoments(p), "gpd") # =&gt; error
parameters(TLMoments(p), "gpd", u = 10)

(p &lt;- as.PWMs(xdat, cbind(b0, b2) ~ station, order = c(0, 2)))
#TLMoments(p) # =&gt; error

</code></pre>

<hr>
<h2 id='as.TLMoments'>Convert to TLMoments-object</h2><span id='topic+as.TLMoments'></span><span id='topic+as.TLMoments.numeric'></span><span id='topic+as.TLMoments.matrix'></span><span id='topic+as.TLMoments.list'></span><span id='topic+as.TLMoments.data.frame'></span>

<h3>Description</h3>

<p>Convert vector, matrix, list, or data.frame of TL-moments
or TL-moment ratios or a PWMs-object to a TLMoments-object in order
to be used with TLMoments-functions.
The first position of a vector or the first row of a matrix is
always used as the L1-moment. The <code>ratios</code> argument determines if the
following positions or rows are used as TL-moments oder TL-moments ratios.
The trimming has to be given using the <code>leftrim</code> and <code>rightrim</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.TLMoments(x, ..., leftrim, rightrim, ratios)

## S3 method for class 'numeric'
as.TLMoments(x, leftrim = 0L, rightrim = 0L, ratios = FALSE, ...)

## S3 method for class 'matrix'
as.TLMoments(x, leftrim = 0L, rightrim = 0L, ratios = FALSE, ...)

## S3 method for class 'list'
as.TLMoments(x, leftrim = 0L, rightrim = 0L, ratios = FALSE, ...)

## S3 method for class 'data.frame'
as.TLMoments(x, formula, leftrim = 0L, rightrim = 0L, ratios = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.TLMoments_+3A_x">x</code></td>
<td>
<p>vector or matrix of TL-moments (or TL-moment ratios if ratios is TRUE) or a PWMs-object.
The first position or row is always used as the L1-moment, if vector or matrix are given.</p>
</td></tr>
<tr><td><code id="as.TLMoments_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="as.TLMoments_+3A_leftrim">leftrim</code>, <code id="as.TLMoments_+3A_rightrim">rightrim</code></td>
<td>
<p>integer, order of trimmed L-moments.</p>
</td></tr>
<tr><td><code id="as.TLMoments_+3A_ratios">ratios</code></td>
<td>
<p>boolean, if TRUE the non-first positions or rows of x give
L-moment ratios, if FALSE (default) they give L-moments.
If ratios are used and the first position or row is NA, L1 is assumed to be 1!</p>
</td></tr>
<tr><td><code id="as.TLMoments_+3A_formula">formula</code></td>
<td>
<p>if <code>x</code> is data.frame. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class TLMoments, see PWMs help page.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: as.TLMoments for numeric data vectors
</p>
</li>
<li> <p><code>matrix</code>: as.TLMoments for numeric data matrices
</p>
</li>
<li> <p><code>list</code>: as.TLMoments for numeric data lists
</p>
</li>
<li> <p><code>data.frame</code>: as.TLMoments for numeric data.frames
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+TLMoments">TLMoments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Vector or matrix as input
xmat &lt;- cbind(c(1, .2, .05), c(1, .2, NA), c(1.3, NA, .1))
xvec &lt;- xmat[, 1]
xlist &lt;- lapply(1:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:3], each = 1),
 season = c("S", "W", "S"),
 L1 = c(1, 1, 1.3),
 L2 = c(.2, .2, .3),
 L3 = c(.05, .04, .1)
)

as.TLMoments(xvec, rightrim = 1)
as.TLMoments(xmat, rightrim = 1)
as.TLMoments(xlist, rightrim = 1)
as.TLMoments(xdat, cbind(L1, L2, L3) ~ station)
as.TLMoments(xdat, .~station+season)
as.TLMoments(xdat, cbind(L1, L2, L3) ~ .)

parameters(as.TLMoments(xvec, rightrim = 0), "gev")
#lmomco::lmom2par(lmomco::vec2lmom(c(1, .2, .25)), "gev")$para

xmat &lt;- cbind(c(NA, .2, -.05), c(NA, .2, .2))
xvec &lt;- xmat[, 1]

as.TLMoments(xvec, ratios = TRUE)
as.TLMoments(xmat, ratios = TRUE)
parameters(as.TLMoments(xvec, ratios = TRUE), "gev")
#lmomco::lmom2par(lmomco::vec2lmom(c(1, .2, -.05)), "gev")$para

xmat &lt;- cbind(c(10, .2, -.05), c(10, .2, .2))
xvec &lt;- xmat[, 1]

as.TLMoments(xvec, ratios = TRUE)
as.TLMoments(xmat, ratios = TRUE)
parameters(as.TLMoments(xvec, ratios = TRUE), "gev")
#lmomco::lmom2par(lmomco::vec2lmom(c(10, .2, -.05)), "gev")$para

</code></pre>

<hr>
<h2 id='est_cov'>Covariance matrix of PWMs, TLMoments, parameters, or quantiles</h2><span id='topic+est_cov'></span><span id='topic+est_cov.PWMs'></span><span id='topic+est_cov.TLMoments'></span><span id='topic+est_cov.parameters'></span><span id='topic+est_cov.quantiles'></span>

<h3>Description</h3>

<p>Calculation of the empirical or theoretical covariance matrix of objects
of the classes <code>PWMs</code>, <code>TLMoments</code>, <code>parameters</code>, or <code>quantiles</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_cov(x, ...)

## S3 method for class 'PWMs'
est_cov(x, select = attr(x, "order"), ...)

## S3 method for class 'TLMoments'
est_cov(x, select = attr(x, "order"), ...)

## S3 method for class 'parameters'
est_cov(x, select = c("loc", "scale", "shape"), ...)

## S3 method for class 'quantiles'
est_cov(x, select = attr(x, "p"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_cov_+3A_x">x</code></td>
<td>
<p>object of <code>PWMs</code>, <code>TLMoments</code>, <code>parameters</code>,
or <code>quantiles</code> constructed using the same-named functions.</p>
</td></tr>
<tr><td><code id="est_cov_+3A_...">...</code></td>
<td>
<p>additional arguments given to the sub-functions: <code>distr</code> and <code>np.cov</code> (see details).</p>
</td></tr>
<tr><td><code id="est_cov_+3A_select">select</code></td>
<td>
<p>numeric oder character vector specifying a subset of the covariance matrix. If
not specified the full covariance matrix is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance matrices of <code>PWMs</code> and <code>TLMoments</code> are calculated without parametric
assumption by default. Covariance matrices of <code>parameters</code> and <code>quantiles</code> use
parametric assumption based on their stored distribution attribute (only GEV at the moment).
Parametric (GEV) calculation can be enforced by specifying <code>distr=\"gev\"</code>, non-parametric
calculation by using <code>np.cov=TRUE</code>.
</p>


<h3>Value</h3>

<p>numeric matrix (if <code>x</code> is of class <code>PWMs</code>, <code>parameters</code>, or
<code>quantiles</code>) or a list of two matrices (<code>lambdas</code> and <code>ratios</code>, if
<code>x</code> is of class <code>TLMoments</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>, <code><a href="#topic+TLMoments">TLMoments</a></code>, <code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+quantiles">quantiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 1: PWMs:

xvec &lt;- rgev(100, shape = .1)
xmat &lt;- cbind(rgev(100, shape = .1), rgev(100, shape = .3))

# Covariance estimation of PWMs normally without parametric assumption:
est_cov(PWMs(xvec))
est_cov(PWMs(xvec), select = 0:1)
est_cov(PWMs(xmat))
est_cov(PWMs(xmat), select = 3)
est_cov(PWMs(xmat[, 1, drop = FALSE]), select = 2:3)

# Parametric assumptions (only GEV by now) can be used:
est_cov(PWMs(xvec), distr = "gev")
est_cov(PWMs(xvec), distr = "gev", select = c(1, 3))

## Not run: 
cov(t(replicate(100000,
  as.vector(PWMs(cbind(rgev(100, shape = .1), rgev(100, shape = .3)), max.order = 1)))
))

## End(Not run)


### 2. TLMoments:

xvec &lt;- rgev(100, shape = .1)
xmat &lt;- cbind(rgev(100, shape = .1), rgev(100, shape = .3))

# Covariance estimation of TLMoments normally without parametric assumption:
est_cov(TLMoments(xvec))
est_cov(TLMoments(xvec, rightrim = 1))
est_cov(TLMoments(xvec), select = 3:4)

# Parametric assumptions (only GEV by now) can be used:
est_cov(TLMoments(xvec), distr = "gev")

# Matrix inputs
est_cov(TLMoments(xmat))
est_cov(TLMoments(xmat), select = 3:4)
est_cov(TLMoments(xmat[, 1, drop = FALSE]), select = 3:4)

# Covariance of theoretical TLMoments only with parametric assumption:
est_cov(as.TLMoments(c(14, 4, 1)), distr = "gev", set.n = 100)
est_cov(as.TLMoments(c(14, 4, 1), rightrim = 1), distr = "gev", set.n = 100)

# Regionalized TLMoments
est_cov(regionalize(TLMoments(xmat), c(.75, .25)))
est_cov(regionalize(TLMoments(xmat), c(.75, .25)), distr = "gev", select = 3:4)


### 3. Parameters:

xvec &lt;- rgev(100, shape = .1)
xmat &lt;- cbind(rgev(100, shape = .1), rgev(100, shape = .3))

# Covariance estimation of parameters normally with parametric assumption:
est_cov(parameters(TLMoments(xvec), "gev"))
est_cov(parameters(TLMoments(xvec, rightrim = 1), "gev"))
est_cov(parameters(TLMoments(xvec, rightrim = 1), "gev"), select = c("scale", "shape"))

# A nonparametric estimation can be enforced with np.cov:
est_cov(parameters(TLMoments(xvec), "gev"), np.cov = TRUE)
est_cov(parameters(TLMoments(xvec, rightrim = 1), "gev"), np.cov = TRUE)

# Matrix inputs
est_cov(parameters(TLMoments(xmat), "gev"))
est_cov(parameters(TLMoments(xmat), "gev"), select = "shape")
est_cov(parameters(TLMoments(xmat[, 1]), "gev"), select = "shape")

# Theoretical values (leftrim and/or rightrim have to be specified)
para &lt;- as.parameters(loc = 10, scale = 5, shape = .2, distr = "gev")
est_cov(para, set.n = 100)
est_cov(para, rightrim = 1, set.n = 100)

## Not run: 
var(t(replicate(10000, parameters(TLMoments(rgev(100, 10, 5, .2)), "gev"))))

## End(Not run)
## Not run: 
var(t(replicate(10000, parameters(TLMoments(rgev(100, 10, 5, .2), rightrim = 1), "gev"))))

## End(Not run)

# Parameter estimates from regionalized TLMoments:
est_cov(parameters(regionalize(TLMoments(xmat), c(.75, .25)), "gev"))


### 4. Quantiles:

xvec &lt;- rgev(100, shape = .2)
xmat &lt;- cbind(rgev(100, shape = .1), rgev(100, shape = .3))

# Covariance estimation of parameters normally with parametric assumption:
q &lt;- quantiles(parameters(TLMoments(xvec), "gev"), c(.9, .95, .99))
est_cov(q)
est_cov(q, select = c("0.9", "0.99"))
est_cov(q, select = .95)

# A nonparametric estimation can be enforced with np.cov:
est_cov(q, np.cov = TRUE)

# Matrix inputs
param &lt;- parameters(TLMoments(xmat, 0, 1), "gev")
q &lt;- quantiles(param, c(.9, .95, .99))
est_cov(q)
est_cov(q, select = .99)
param &lt;- parameters(TLMoments(xmat[, 1, drop = FALSE], 0, 1), "gev")
q &lt;- quantiles(param, c(.9, .95, .99))
est_cov(q, select = .99)

# Theoretical values
q &lt;- quantiles(as.parameters(loc = 10, scale = 5, shape = .3, distr = "gev"), c(.9, .99))
est_cov(q)
est_cov(q, leftrim = 0, rightrim = 1)
est_cov(q, leftrim = 0, rightrim = 1, set.n = 100)

# Quantile estimates from regionalized TLMoments:
param &lt;- parameters(regionalize(TLMoments(xmat), c(.75, .25)), "gev")
est_cov(quantiles(param, c(.9, .99)))


</code></pre>

<hr>
<h2 id='est_paramcov'>Estimate the covariance matrix of parameter estimations</h2><span id='topic+est_paramcov'></span><span id='topic+est_paramcov.numeric'></span><span id='topic+est_paramcov.matrix'></span><span id='topic+est_paramcov.parameters'></span>

<h3>Description</h3>

<p>Internal function. Use <a href="#topic+est_cov">est_cov</a>. Description not done yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_paramcov(x, distr = "", leftrim = 0L, rightrim = 0L, ...)

## S3 method for class 'numeric'
est_paramcov(x, distr, leftrim = 0L, rightrim = 0L, np.cov = FALSE, ...)

## S3 method for class 'matrix'
est_paramcov(
  x,
  distr,
  leftrim = 0L,
  rightrim = 0L,
  np.cov = FALSE,
  reg.weights = NULL,
  ...
)

## S3 method for class 'parameters'
est_paramcov(
  x,
  distr = attr(x, "distribution"),
  leftrim = attr(x, "source")$trimmings[1],
  rightrim = attr(x, "source")$trimmings[2],
  set.n = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_paramcov_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix containing data OR an object of parameters.</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_distr">distr</code></td>
<td>
<p>character indicating the distribution from which the parameters are calculated. If x is parameters-object, distr does not need to be specified.</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_leftrim">leftrim</code>, <code id="est_paramcov_+3A_rightrim">rightrim</code></td>
<td>
<p>lower and upper trimming parameter used for parameter calculation, have to be non-negative integers.</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_np.cov">np.cov</code></td>
<td>
<p>boolean, if TRUE no parametric assumptions are used to calculate the covariance matrix (default FALSE).</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_reg.weights">reg.weights</code></td>
<td>
<p>numeric vector of weights for regionalized TLMoments.</p>
</td></tr>
<tr><td><code id="est_paramcov_+3A_set.n">set.n</code></td>
<td>
<p>hypothetical data length n if theoretical values are given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Numeric vectors
x &lt;- rgev(500, shape = .2)

parameters(TLMoments(x), "gev")
est_paramcov(x, "gev", 0, 0)
#cov(t(replicate(10000, parameters(TLMoments(rgev(500, shape = .2)), "gev"))))

parameters(TLMoments(x, rightrim = 1), "gev")
est_paramcov(x, "gev", 0, 1)
#cov(t(replicate(10000,
#   parameters(TLMoments(rgev(500, shape = .2), rightrim = 1), "gev")
#)))

parameters(TLMoments(x, rightrim = 2), "gev")
est_paramcov(x, "gev", 0, 2)
#cov(t(replicate(10000,
#  parameters(TLMoments(rgev(500, shape = .2), rightrim = 2), "gev")
#)))

### Numeric matrices
x &lt;- matrix(rgev(600, shape = .2), nc = 3)

parameters(TLMoments(x), "gev")
est_paramcov(x, "gev", 0, 0)
#cov(t(replicate(5000,
#  as.vector(parameters(TLMoments(matrix(rgev(600, shape = .2), nc = 3)), "gev")))
#))

### parameters-object
x &lt;- as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev")
est_paramcov(x)
est_paramcov(x, leftrim = 0, rightrim = 0)
est_paramcov(x, leftrim = 0, rightrim = 0, set.n = 100)
# distr-argument can be neglected

</code></pre>

<hr>
<h2 id='est_pwmcov'>Estimate the covariance matrix of PWM estimations</h2><span id='topic+est_pwmcov'></span><span id='topic+est_pwmcov.numeric'></span><span id='topic+est_pwmcov.matrix'></span>

<h3>Description</h3>

<p>Internal function. Use <a href="#topic+est_cov">est_cov</a>. Description not done yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_pwmcov(x, order = 0:3, distr = NULL, distr.trim = c(0, 0))

## S3 method for class 'numeric'
est_pwmcov(x, order = 0:3, distr = NULL, distr.trim = c(0, 0))

## S3 method for class 'matrix'
est_pwmcov(x, order = 0:3, distr = NULL, distr.trim = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_pwmcov_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix of data.</p>
</td></tr>
<tr><td><code id="est_pwmcov_+3A_order">order</code></td>
<td>
<p>numeric vector giving the orders that are returned.</p>
</td></tr>
<tr><td><code id="est_pwmcov_+3A_distr">distr</code></td>
<td>
<p>character of length 1 which indicates a distribution if a
parametric assumption should be used.</p>
</td></tr>
<tr><td><code id="est_pwmcov_+3A_distr.trim">distr.trim</code></td>
<td>
<p>integer vector of length 2 indicating the trimming used
to calculate parameters if a parametric assumption is used (i.e. <code>distr</code> is set).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Numeric vectors
x &lt;- rgev(500, shape = .2)
est_pwmcov(x)
est_pwmcov(x, distr = "gev")

### Numeric matrices
x &lt;- matrix(rgev(600, shape = .2), nc = 3)
est_pwmcov(x, order = 0:2)
est_pwmcov(x, order = 0:2, distr = "gev")

</code></pre>

<hr>
<h2 id='est_quancov'>Estimate the covariance matrix of quantile estimations</h2><span id='topic+est_quancov'></span><span id='topic+est_quancov.numeric'></span><span id='topic+est_quancov.matrix'></span><span id='topic+est_quancov.quantiles'></span>

<h3>Description</h3>

<p>Internal function. Use <a href="#topic+est_cov">est_cov</a>. Description not done yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_quancov(x, distr = "", p = NULL, leftrim = 0L, rightrim = 0L, ...)

## S3 method for class 'numeric'
est_quancov(x, distr, p, leftrim = 0L, rightrim = 0L, np.cov = FALSE, ...)

## S3 method for class 'matrix'
est_quancov(
  x,
  distr,
  p,
  leftrim = 0L,
  rightrim = 0L,
  np.cov = FALSE,
  reg.weights = NULL,
  ...
)

## S3 method for class 'quantiles'
est_quancov(
  x,
  distr = attr(x, "distribution"),
  p = attr(x, "p"),
  leftrim = attr(x, "source")$trimmings[1],
  rightrim = attr(x, "source")$trimmings[2],
  set.n = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_quancov_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix containing data.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_distr">distr</code></td>
<td>
<p>character of length 1 giving the distribution if parametric assumption should be used.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_p">p</code></td>
<td>
<p>quantile levels from which the covariance should be calculated.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_leftrim">leftrim</code>, <code id="est_quancov_+3A_rightrim">rightrim</code></td>
<td>
<p>lower and upper trimming parameter used for parameter calculation, have to be non-negative integers.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_np.cov">np.cov</code></td>
<td>
<p>boolean, if TRUE no parametric assumptions are used to calculate the covariance matrix (default FALSE).</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_reg.weights">reg.weights</code></td>
<td>
<p>numeric vector of weights for regionalized TLMoments.</p>
</td></tr>
<tr><td><code id="est_quancov_+3A_set.n">set.n</code></td>
<td>
<p>hypothetical data length n if theoretical values are given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Numeric vectors
x &lt;- rgev(500, shape = .2)

quantiles(parameters(TLMoments(x), "gev"), c(.9, .95, .99))
est_quancov(x, "gev", c(.9, .95, .99), 0, 0)
#cov(t(replicate(5000,
#  quantiles(parameters(TLMoments(rgev(500, shape = .2)), "gev"), c(.9, .95, .99))
#)))

quantiles(parameters(TLMoments(x, rightrim = 1), "gev"), c(.9, .95, .99))
est_quancov(x, "gev", c(.9, .95, .99), 0, 1)
#cov(t(replicate(5000,
#  quantiles(
#    parameters(TLMoments(rgev(500, shape = .2), rightrim = 1), "gev"),
#    c(.9, .95, .99)
#  )
#)))

### Numeric matrices
x &lt;- matrix(rgev(600, shape = .2), nc = 3)

quantiles(parameters(TLMoments(x), "gev"), c(.9, .95, .99))
est_quancov(x, "gev", c(.9, .95, .99), 0, 0)

est_quancov(x, "gev", .9, 0, 0)
#cov(t(replicate(5000,
# quantiles(
#   parameters(TLMoments(matrix(rgev(600, shape = .2), nc = 3)),
#  "gev"), .9)
#  )
#))

### quantiles object
q &lt;- quantiles(as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev"), c(.9, .99))
est_quancov(q)
est_quancov(q, leftrim = 0, rightrim = 0)
est_quancov(q, leftrim = 0, rightrim = 0, set.n = 10)

</code></pre>

<hr>
<h2 id='est_tlmcov'>Estimate the covariance matrix of TL-moments estimations</h2><span id='topic+est_tlmcov'></span><span id='topic+est_tlmcov.numeric'></span><span id='topic+est_tlmcov.matrix'></span><span id='topic+est_tlmcov.TLMoments'></span>

<h3>Description</h3>

<p>Internal function. Use <a href="#topic+est_cov">est_cov</a>. Description not done yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_tlmcov(
  x,
  leftrim = 0L,
  rightrim = 0L,
  order = 1:3,
  distr = NULL,
  lambda.cov = TRUE,
  ratio.cov = TRUE,
  ...
)

## S3 method for class 'numeric'
est_tlmcov(
  x,
  leftrim = 0L,
  rightrim = 0L,
  order = 1:3,
  distr = NULL,
  lambda.cov = TRUE,
  ratio.cov = TRUE,
  ...
)

## S3 method for class 'matrix'
est_tlmcov(
  x,
  leftrim = 0L,
  rightrim = 0L,
  order = 1:3,
  distr = NULL,
  lambda.cov = TRUE,
  ratio.cov = TRUE,
  reg.weights = NULL,
  ...
)

## S3 method for class 'TLMoments'
est_tlmcov(
  x,
  leftrim = attr(x, "leftrim"),
  rightrim = attr(x, "rightrim"),
  order = attr(x, "order"),
  distr = NULL,
  lambda.cov = TRUE,
  ratio.cov = TRUE,
  set.n = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_tlmcov_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix containing data OR an object of TLMoments.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_leftrim">leftrim</code>, <code id="est_tlmcov_+3A_rightrim">rightrim</code></td>
<td>
<p>integer indicating lower and upper trimming parameters, have to be non-negative integers.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_order">order</code></td>
<td>
<p>numeric vector giving the orders that are returned (default is first three L-moments).</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_distr">distr</code></td>
<td>
<p>character of length 1 giving the distribution if parametric assumption should be used.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_lambda.cov">lambda.cov</code></td>
<td>
<p>boolean, if TRUE (default) TL-moment estimation covariance matrix is calculated.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_ratio.cov">ratio.cov</code></td>
<td>
<p>boolean, if TRUE (default) TL-moment-ratio estimation covariance matrix is calculated.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_reg.weights">reg.weights</code></td>
<td>
<p>numeric vector of weights for regionalized TLMoments.</p>
</td></tr>
<tr><td><code id="est_tlmcov_+3A_set.n">set.n</code></td>
<td>
<p>hypothetical data length n if theoretical values are given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of numeric matrices (if <code>lambda.cov</code> and <code>ratio.cov</code> are TRUE (default)), or a single matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Numeric vectors
x &lt;- rgev(500, loc = 10, scale = 5, shape = .1)

est_tlmcov(x)
est_tlmcov(x, order = 2:3)
est_tlmcov(x, rightrim = 1, order = 4:5)
# cov(t(replicate(10000,
#   TLMoments(rgev(500, loc = 10, scale = 5, shape = .1))$lambdas)
# ))
# cov(t(replicate(10000,
#   TLMoments(rgev(500, loc = 10, scale = 5, shape = .1))$ratios)
# ))

est_tlmcov(x, ratio.cov = FALSE)
est_tlmcov(x, lambda.cov = FALSE)

est_tlmcov(x, distr = "gev")

est_tlmcov(x, leftrim = 0, rightrim = 1)
# cov(t(replicate(10000,
#  TLMoments(rgev(500, loc = 10, scale = 5, shape = .1), 0, 1, 3)$lambdas
# )))
# cov(t(replicate(10000,
#  TLMoments(rgev(500, loc = 10, scale = 5, shape = .1), 0, 1, 3)$ratios
# )))

### Numeric matrices
x &lt;- matrix(rgev(600), nc = 3)

est_tlmcov(x)
est_tlmcov(x, order = 3:4)
# cov(t(replicate(10000,
#   as.vector(TLMoments(matrix(rgev(600), nc = 3))$lambdas[3:4, ])
# )))
# cov(t(replicate(10000,
#   as.vector(TLMoments(matrix(rgev(600), nc = 3))$ratios[3:4, ])
# )))

est_tlmcov(x, ratio.cov = FALSE)
est_tlmcov(x, lambda.cov = FALSE)

TLMoments:::est_tlmcov(x, order = 2:3, distr = "gev")
# cov(t(replicate(10000,
#   as.vector(TLMoments(matrix(rgev(600), nc = 3))$lambdas[2:3, ])
# )))
# cov(t(replicate(10000,
#   as.vector(TLMoments(matrix(rgev(600), nc = 3))$ratios[2:3, ])
# )))

### TLMoments-object (theoretical calculation)
tlm &lt;- TLMoments(as.parameters(loc = 10, scale = 5, shape = .1, distr = "gev"), 0, 1)
est_tlmcov(tlm, distr = "gev", set.n = 100)
est_tlmcov(tlm, distr = "gev", set.n = 100, ratio.cov = FALSE)
est_tlmcov(tlm, distr = "gev", set.n = 100, lambda.cov = FALSE)

</code></pre>

<hr>
<h2 id='parameters'>Converting TL-moments to distribution parameters</h2><span id='topic+parameters'></span><span id='topic+parameters.PWMs'></span><span id='topic+parameters.TLMoments'></span>

<h3>Description</h3>

<p>Converts TL-moments (or PWMs) to distribution parameters. By now, conversions for gev, gumbel, gpd, and ln3
are available. Important trimming options are calculated through known formulas (see references for
some of them), other options are calculated through a numerical optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(x, distr, ...)

## S3 method for class 'PWMs'
parameters(x, distr, ...)

## S3 method for class 'TLMoments'
parameters(x, distr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_x">x</code></td>
<td>
<p>object returned by TLMoments (or PWMs, in which case TLMoments with no trimming is used).</p>
</td></tr>
<tr><td><code id="parameters_+3A_distr">distr</code></td>
<td>
<p>character object defining the distribution. Supported types are
&quot;gev&quot;, &quot;gum&quot;, &quot;gpd&quot;, and &quot;ln3&quot;.</p>
</td></tr>
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, matrix, list, or data.frame of parameter estimates with
class <code>parameters</code>. The object contains the following attributes: </p>

<ul>
<li> <p><code>distribution</code>: a character indicating the used distribution
</p>
</li>
<li> <p><code>source</code>: a list with background information (used function, data, n, formula, trimmings; mainly for internal purposes)
</p>
</li></ul>

<p>The attributes are hidden in the print-function for a clearer presentation.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>PWMs</code>: parameters for PWMs-object
</p>
</li>
<li> <p><code>TLMoments</code>: parameters for TLMoments-object
</p>
</li></ul>


<h3>References</h3>

<p>Elamir, E. A. H. (2010). Optimal choices for trimming in trimmed L-moment method. Applied Mathematical Sciences, 4(58), 2881-2890.
</p>
<p>Fischer, S., Fried, R., &amp; Schumann, A. (2015). Examination for robustness of parametric estimators for flood statistics in the context of extraordinary extreme events. Hydrology and Earth System Sciences Discussions, 12, 8553-8576.
</p>
<p>Hosking, J. R. (1990). L-moments: analysis and estimation of distributions using linear combinations of order statistics. Journal of the Royal Statistical Society. Series B (Methodological), 105-124.
</p>
<p>Hosking, J. R. M. (2007). Some theory and practical uses of trimmed L-moments. Journal of Statistical Planning and Inference, 137(9), 3024-3039.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>, <code><a href="#topic+TLMoments">TLMoments</a></code>, <code><a href="#topic+quantiles">quantiles</a></code>, <code><a href="#topic+summary.parameters">summary.parameters</a></code>, <code><a href="#topic+as.parameters">as.parameters</a></code>. Built-in distributions: <code><a href="#topic+pgev">pgev</a></code>, <code><a href="#topic+pgum">pgum</a></code>, <code><a href="#topic+pgpd">pgpd</a></code>, <code><a href="#topic+pln3">pln3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmat &lt;- matrix(rgev(100, shape = .2), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:2], each = 50),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

# TLMoments-objects or PWMs-objects can be used. However, in case of PWMs
# simply the TLMoments(., leftrim = 0, rightrim = 0)-variant is used.

parameters(PWMs(xvec), "gev")
tlm &lt;- TLMoments(xvec, leftrim = 0, rightrim = 0)
parameters(tlm, "gev")

tlm &lt;- TLMoments(xmat, leftrim = 1, rightrim = 1)
parameters(tlm, "gum")

tlm &lt;- TLMoments(xlist)
parameters(tlm, "gpd")

tlm &lt;- TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 2)
parameters(tlm, "gev")

tlm &lt;- TLMoments(xdat, hq ~ station + season, leftrim = 0, rightrim = 2)
parameters(tlm, "gev")


# If no explicit formula is implemented, it is tried to calculate
# parameters numerically. The attribute source$param.computation.method
# indicates if this is the case.

tlm &lt;- TLMoments(rgum(200, loc = 5, scale = 2), leftrim = 1, rightrim = 4)
parameters(tlm, "gum")

tlm &lt;- TLMoments(rgev(200, loc = 10, scale = 5, shape = .4), leftrim = 2, rightrim = 2)
parameters(tlm, "gev")

tlm &lt;- TLMoments(rln3(200, loc = 3, scale = 1.5, shape = 2), leftrim = 0, rightrim = 1)
parameters(tlm, "ln3")

# Numerical calculation is A LOT slower:
## Not run: 
system.time(replicate(500,
  parameters(TLMoments(rgum(100, loc = 5, scale = 2), 1, 1), "gum")
))[3]
system.time(replicate(500,
  parameters(TLMoments(rgum(100, loc = 5, scale = 2), 1, 2), "gum")
))[3]

## End(Not run)

# Using magrittr
library(magrittr)

TLMoments(rgpd(500, loc = 10, scale = 3, shape = .3), rightrim = 0) %&gt;%
 parameters("gpd")

TLMoments(rgpd(500, loc = 10, scale = 3, shape = .3), rightrim = 0) %&gt;%
 parameters("gpd", u = 10)

TLMoments(rgpd(500, loc = 10, scale = 3, shape = .3), rightrim = 1) %&gt;%
 parameters("gpd")

TLMoments(rgpd(500, loc = 10, scale = 3, shape = .3), rightrim = 2) %&gt;%
 parameters("gpd")

</code></pre>

<hr>
<h2 id='pgev'>Generalized Extreme Value distribution</h2><span id='topic+pgev'></span><span id='topic+dgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span>

<h3>Description</h3>

<p>Cumulative distribution function, density function, quantile function and
generation of random variates of the generalized extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgev(q, loc = 0, scale = 1, shape = 0)

dgev(x, loc = 0, scale = 1, shape = 0)

qgev(p, loc = 0, scale = 1, shape = 0)

rgev(n, loc = 0, scale = 1, shape = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgev_+3A_loc">loc</code>, <code id="pgev_+3A_scale">scale</code>, <code id="pgev_+3A_shape">shape</code></td>
<td>
<p>location, scale, and shape parameter of the generalized extreme value distribution. All must be of length one.</p>
</td></tr>
<tr><td><code id="pgev_+3A_x">x</code>, <code id="pgev_+3A_q">q</code>, <code id="pgev_+3A_p">p</code></td>
<td>
<p>numeric vector of values, quantiles, or probabilites.</p>
</td></tr>
<tr><td><code id="pgev_+3A_n">n</code></td>
<td>
<p>numeric, number of random variates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pgum">pgum</a></code>, <code><a href="#topic+pgpd">pgpd</a></code>, <code><a href="#topic+pln3">pln3</a></code>
</p>

<hr>
<h2 id='pgpd'>Generalized Pareto distribution</h2><span id='topic+pgpd'></span><span id='topic+dgpd'></span><span id='topic+qgpd'></span><span id='topic+rgpd'></span>

<h3>Description</h3>

<p>Cumulative distribution function, density function, quantile function and
generation of random variates of the generalized Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgpd(q, loc = 0, scale = 1, shape = 0)

dgpd(x, loc = 0, scale = 1, shape = 0)

qgpd(p, loc = 0, scale = 1, shape = 0)

rgpd(n, loc = 0, scale = 1, shape = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgpd_+3A_loc">loc</code>, <code id="pgpd_+3A_scale">scale</code>, <code id="pgpd_+3A_shape">shape</code></td>
<td>
<p>location, scale, and shape parameter of the generalized Pareto distribution. All must be of length one.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_x">x</code>, <code id="pgpd_+3A_q">q</code>, <code id="pgpd_+3A_p">p</code></td>
<td>
<p>numeric vector of values, quantiles, or probabilites.</p>
</td></tr>
<tr><td><code id="pgpd_+3A_n">n</code></td>
<td>
<p>numeric, number of random variates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pgev">pgev</a></code>, <code><a href="#topic+pgum">pgum</a></code>, <code><a href="#topic+pln3">pln3</a></code>
</p>

<hr>
<h2 id='pgum'>Gumbel distribution</h2><span id='topic+pgum'></span><span id='topic+dgum'></span><span id='topic+qgum'></span><span id='topic+rgum'></span>

<h3>Description</h3>

<p>Cumulative distribution function, density function, quantile function and
generation of random variates of the Gumbel distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgum(q, loc = 0, scale = 1)

dgum(x, loc = 0, scale = 1)

qgum(p, loc = 0, scale = 1)

rgum(n, loc = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgum_+3A_loc">loc</code>, <code id="pgum_+3A_scale">scale</code></td>
<td>
<p>location and scale parameter of the Gumbel distribution. All must be of length one.</p>
</td></tr>
<tr><td><code id="pgum_+3A_x">x</code>, <code id="pgum_+3A_q">q</code>, <code id="pgum_+3A_p">p</code></td>
<td>
<p>numeric vector of values, quantiles, or probabilites.</p>
</td></tr>
<tr><td><code id="pgum_+3A_n">n</code></td>
<td>
<p>numeric, number of random variates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pgev">pgev</a></code>, <code><a href="#topic+pgpd">pgpd</a></code>, <code><a href="#topic+pln3">pln3</a></code>
</p>

<hr>
<h2 id='pln3'>Three-parameter lognormal distribution</h2><span id='topic+pln3'></span><span id='topic+dln3'></span><span id='topic+qln3'></span><span id='topic+rln3'></span>

<h3>Description</h3>

<p>Cumulative distribution function, density function, quantile function and
generation of random variates of the three-parameter lognormal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pln3(q, loc = 0, scale = 1, shape = 1)

dln3(x, loc = 0, scale = 1, shape = 1)

qln3(p, loc = 0, scale = 1, shape = 1)

rln3(n, loc = 0, scale = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pln3_+3A_loc">loc</code>, <code id="pln3_+3A_scale">scale</code>, <code id="pln3_+3A_shape">shape</code></td>
<td>
<p>location, scale, and shape parameter of the three-parameter lognormal distribution. All must be of length one.</p>
</td></tr>
<tr><td><code id="pln3_+3A_x">x</code>, <code id="pln3_+3A_q">q</code>, <code id="pln3_+3A_p">p</code></td>
<td>
<p>numeric vector of values, quantiles, or probabilites.</p>
</td></tr>
<tr><td><code id="pln3_+3A_n">n</code></td>
<td>
<p>numeric, number of random variates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pgev">pgev</a></code>, <code><a href="#topic+pgum">pgum</a></code>, <code><a href="#topic+pgpd">pgpd</a></code>
</p>

<hr>
<h2 id='plot.TLMoments'>L-Moment-ratio diagram</h2><span id='topic+plot.TLMoments'></span><span id='topic+plot.TLMoments.numeric'></span><span id='topic+plot.TLMoments.matrix'></span><span id='topic+plot.TLMoments.list'></span><span id='topic+plot.TLMoments.data.frame'></span>

<h3>Description</h3>

<p>Generates a ggplot2 object containing a scatterplot of TL skewness and TL kurtosis
as well as the theoretical curves and points of several distributions (for now: GEV, GPD,
LN3, GUM, EXP, NORM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TLMoments'
plot(x, ...)

## S3 method for class 'numeric'
plot.TLMoments(x, distr = "all", add_center = FALSE, use_internal = TRUE, ...)

## S3 method for class 'matrix'
plot.TLMoments(x, distr = "all", add_center = TRUE, use_internal = TRUE, ...)

## S3 method for class 'list'
plot.TLMoments(x, distr = "all", add_center = TRUE, use_internal = TRUE, ...)

## S3 method for class 'data.frame'
plot.TLMoments(x, distr = "all", add_center = TRUE, use_internal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TLMoments_+3A_x">x</code></td>
<td>
<p>object of TLMoments.</p>
</td></tr>
<tr><td><code id="plot.TLMoments_+3A_...">...</code></td>
<td>
<p>additional arguments, not used at the moment.</p>
</td></tr>
<tr><td><code id="plot.TLMoments_+3A_distr">distr</code></td>
<td>
<p>character indicating the plotted theoretical distributions, see details.</p>
</td></tr>
<tr><td><code id="plot.TLMoments_+3A_add_center">add_center</code></td>
<td>
<p>boolean, if TRUE (default, except for vector TLMoments) the center
of all TL-moment ratios is printed as a cross.</p>
</td></tr>
<tr><td><code id="plot.TLMoments_+3A_use_internal">use_internal</code></td>
<td>
<p>boolean, if TRUE (default) internal pre-calculated values (if available)
are used to print curves and points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distr</code>: this can either be a vector containing the abbreviations of the
theoretical distributions (gev, gpd, ln3, pe3, glo, gum, exp, or norm) or one of the
shortcuts \&quot;all\&quot; (default), \&quot;only-lines\&quot;, or \&quot;only-points\&quot; that indicate
all distributions, all distributions displayed as lines (i.e. gev, gpd, ln3, pe3, glo),
or all distributions displayed as points (ie. gum, exp, norm), respectively.
</p>
<p>Values of theoretical distributions are pre-calculated for several trimmings.
If other trimmings are selected this results in a (small) delay for calculation.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: plot.TLMoments for numeric vector
</p>
</li>
<li> <p><code>matrix</code>: plot.TLMoments for numeric matrix
</p>
</li>
<li> <p><code>list</code>: plot.TLMoments for numeric list
</p>
</li>
<li> <p><code>data.frame</code>: plot.TLMoments for numeric data.frame
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xmat &lt;- matrix(rgev(1000, shape = .1), nc = 10)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:10], each = 100),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

library(ggplot2)
plot(TLMoments(xvec))
plot(TLMoments(xlist), distr = c("gev", "gum"), add_center = FALSE)
plot(TLMoments(xmat), distr = "only-points")
plot(TLMoments(xmat), distr = "only-lines") + scale_colour_viridis_d()
plot(TLMoments(xmat, 0, 1))
plot(TLMoments(xmat, 0, 1)) + coord_cartesian(xlim = c(-.05, .4), ylim = c(.05, .2))
plot(TLMoments(xdat, hq ~ station, 1, 0))

plot(TLMoments(xmat), add_center = FALSE)
plot(TLMoments(xmat), use_internal = FALSE)
plot(TLMoments(xmat, 2, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='PWM'>Probability weighted moments</h2><span id='topic+PWM'></span>

<h3>Description</h3>

<p>Calculates empirical probability weighted moments of specific order(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PWM(x, order = 0, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PWM_+3A_x">x</code></td>
<td>
<p>numeric vector of data.</p>
</td></tr>
<tr><td><code id="PWM_+3A_order">order</code></td>
<td>
<p>integer, order of probability weighted moment, can be a set of {0,1,...}.</p>
</td></tr>
<tr><td><code id="PWM_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates if NAs should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, empirical PWM of orders <code>order</code> of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PWM(rnorm(25))
PWM(rnorm(25), order = 2)
PWM(rnorm(25), order = c(0, 2, 4))
</code></pre>

<hr>
<h2 id='PWMs'>Probability weighted moments</h2><span id='topic+PWMs'></span><span id='topic+PWMs.numeric'></span><span id='topic+PWMs.matrix'></span><span id='topic+PWMs.list'></span><span id='topic+PWMs.data.frame'></span><span id='topic+PWMs.TLMoments'></span>

<h3>Description</h3>

<p>Calculates probability weighted moments up to a specific order. Note that PWMs start with
order 0. Acceptable input types are numeric vectors, matrices, lists, and data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PWMs(x, ...)

## S3 method for class 'numeric'
PWMs(x, max.order = 4L, na.rm = FALSE, ...)

## S3 method for class 'matrix'
PWMs(x, max.order = 4L, na.rm = FALSE, ...)

## S3 method for class 'list'
PWMs(x, max.order = 4L, na.rm = FALSE, ...)

## S3 method for class 'data.frame'
PWMs(x, formula, max.order = 4L, na.rm = FALSE, ...)

## S3 method for class 'TLMoments'
PWMs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PWMs_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix, list, or data.frame of data OR an object of TLMoments.</p>
</td></tr>
<tr><td><code id="PWMs_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="PWMs_+3A_max.order">max.order</code></td>
<td>
<p>integer, maximal order of PWMs.</p>
</td></tr>
<tr><td><code id="PWMs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates if NAs should be removed.</p>
</td></tr>
<tr><td><code id="PWMs_+3A_formula">formula</code></td>
<td>
<p>if x is of type data.frame a formula has to be submitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, matrix, list, or data.frame consisting of the PWMs and
with class <code>PWMs</code>.
The object contains the following attributes: </p>

<ul>
<li> <p><code>order</code>: a integer vector with corresponding PWM orders
</p>
</li>
<li> <p><code>source</code>: a list with background information (used function, data, n, formula;
mainly for internal purposes)
</p>
</li></ul>

<p>The attributes are hidden in the print-function for a clearer presentation.
</p>


<h3>References</h3>

<p>Greenwood, J. A., Landwehr, J. M., Matalas, N. C., &amp; Wallis, J. R. (1979). Probability weighted moments: definition and relation to parameters of several distributions expressable in inverse form. Water Resources Research, 15(5), 1049-1054.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data sets:
xmat &lt;- matrix(rnorm(100), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:2], each = 50),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

# Calculating PWMs from data:
PWMs(xvec)
PWMs(xmat)
PWMs(xlist)
PWMs(xdat, formula = hq ~ station)
PWMs(xdat, formula = hq ~ season)
PWMs(xdat, formula = hq ~ .)
PWMs(xdat, formula = . ~ station + season)

# Calculating PWMs from L-moments:
PWMs(TLMoments(xvec))
PWMs(TLMoments(xmat))
PWMs(TLMoments(xlist))
PWMs(TLMoments(xdat, hq ~ station))
PWMs(TLMoments(xdat, hq ~ season))
PWMs(TLMoments(xdat, hq ~ .))
PWMs(TLMoments(xdat, . ~ station + season))

# In data.frame-mode invalid names are preceded by "."
xdat &lt;- data.frame(
 beta0 = rep(letters[1:2], each = 50),
 beta1 = as.vector(xmat)
)
PWMs(xdat, formula = beta1 ~ beta0)

</code></pre>

<hr>
<h2 id='quantiles'>Calculating quantiles from distribution parameters</h2><span id='topic+quantiles'></span>

<h3>Description</h3>

<p>Calculates quantiles from distribution parameters received by parameters or
from a named vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantiles(x, p, distr = attr(x, "distribution"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantiles_+3A_x">x</code></td>
<td>
<p>object returned by parameters or a named vector. In the latter
you have to specify the <code>distr</code>-argument.</p>
</td></tr>
<tr><td><code id="quantiles_+3A_p">p</code></td>
<td>
<p>numeric vector giving the quantiles to calculate.</p>
</td></tr>
<tr><td><code id="quantiles_+3A_distr">distr</code></td>
<td>
<p>character object defining the distribution. Supported types are
&quot;gev&quot;, &quot;gum&quot; and &quot;gpd&quot;. You do not need to set this, if <code>x</code> is from parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, matrix, list, or data.frame of the quantiles and with class
<code>quantiles</code>. The object contains the following attributes: </p>

<ul>
<li> <p><code>distribution</code>: a character indicating the used distribution
</p>
</li>
<li> <p><code>p</code>: a vector with the calculated quantiles
</p>
</li>
<li> <p><code>source</code>: a list with background information (used function, data, n,
formula, trimmings; mainly for internal purposes)
</p>
</li></ul>

<p>The attributes are hidden in the print-function for a clearer presentation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>, <code><a href="#topic+TLMoments">TLMoments</a></code>, <code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+summary.quantiles">summary.quantiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data sets:
xmat &lt;- matrix(rnorm(100), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:2], each = 50),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

# Calculating quantiles from parameters-object
tlm &lt;- TLMoments(xvec, leftrim = 0, rightrim = 1)
quantiles(parameters(tlm, "gev"), c(.9, .99))
tlm &lt;- TLMoments(xmat, leftrim = 1, rightrim = 1)
quantiles(parameters(tlm, "gum"), c(.9, .95, .999))
tlm &lt;- TLMoments(xlist)
quantiles(parameters(tlm, "gpd"), .999)
tlm &lt;- TLMoments(xdat, hq ~ station, leftrim = 2, rightrim = 3)
quantiles(parameters(tlm, "gev"), seq(.1, .9, .1))
tlm &lt;- TLMoments(xdat, hq ~ station + season, leftrim = 0, rightrim = 2)
quantiles(parameters(tlm, "gum"), seq(.1, .9, .1))

# Distribution can be overwritten (but parameters have to fit)
tlm &lt;- TLMoments(xvec, leftrim = 0, rightrim = 1)
params &lt;- parameters(tlm, "gev")
quantiles(params, c(.9, .99))
quantiles(params[1:2], c(.9, .99), distr = "gum")
evd::qgumbel(c(.9, .99), loc = params[1], scale = params[2])


# Using magrittr
library(magrittr)
rgev(50, shape = .3) %&gt;%
  TLMoments(leftrim = 0, rightrim = 1) %&gt;%
  parameters("gev") %&gt;%
  quantiles(c(.99, .999))

# Calculating quantiles to given parameters for arbitrary functions
quantiles(c(mean = 10, sd = 3), c(.95, .99), "norm")
qnorm(c(.95, .99), mean = 10, sd = 3)

# These give errors:
#quantiles(c(loc = 10, scale = 5, shape = .3), c(.95, .99), "notexistingdistribution")
#quantiles(c(loc = 10, scale = 5, shpe = .3), c(.95, .99), "gev") # wrong arguments
</code></pre>

<hr>
<h2 id='regionalize'>Calculation of regionalized TL-moments</h2><span id='topic+regionalize'></span><span id='topic+regionalize.numeric'></span><span id='topic+regionalize.matrix'></span><span id='topic+regionalize.data.frame'></span><span id='topic+regionalize.list'></span>

<h3>Description</h3>

<p>regionalize takes the result of TLMoments and calculates a weighted mean
of TL-moments and TL-moment ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regionalize(x, ...)

## S3 method for class 'numeric'
regionalize(x, ...)

## S3 method for class 'matrix'
regionalize(x, w = attr(x, "source")$n, reg.lambdas = TRUE, ...)

## S3 method for class 'data.frame'
regionalize(x, w = attr(x, "source")$n, reg.lambdas = TRUE, ...)

## S3 method for class 'list'
regionalize(x, w = attr(x, "source")$n, reg.lambdas = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regionalize_+3A_x">x</code></td>
<td>
<p>object returned by TLMoments.</p>
</td></tr>
<tr><td><code id="regionalize_+3A_...">...</code></td>
<td>
<p>additional arguments, not used at the moment.</p>
</td></tr>
<tr><td><code id="regionalize_+3A_w">w</code></td>
<td>
<p>numeric vector giving the weights. Default: Sample lengths of corresponding
data. Internally scaled so that it adds up to 1.</p>
</td></tr>
<tr><td><code id="regionalize_+3A_reg.lambdas">reg.lambdas</code></td>
<td>
<p>logical, if TRUE (default) regionalization is
based upon TL-moments. If false it's based on TL-moment-ratios.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two dimensions: <code>lambdas</code>/<code>ratios</code> are numeric vectors
consisting of the regionalized TL-moments/TL-moment-ratios. The list has
the class <code>TLMoments</code>. The object contains the following attributes: </p>

<ul>
<li> <p><code>leftrim</code>: a numeric giving the used leftrim-argument
</p>
</li>
<li> <p><code>rightrim</code>: a numeric giving the used rightrim-argument
</p>
</li>
<li> <p><code>order</code>: a integer vector with corresponding TL-moment orders
</p>
</li>
<li> <p><code>source</code>: a list with background information (used function, data,
n, formula, computation.method; mainly for internal purposes)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>xmat &lt;- matrix(rgev(100), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:2], each = 50),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

regionalize(TLMoments(xmat))
regionalize(TLMoments(xlist))
regionalize(TLMoments(xdat, hq ~ station))
# For numeric vector TLMoments, nothing happens:
regionalize(TLMoments(xvec))

tlm &lt;- TLMoments(xmat)
regionalize(tlm)
regionalize(tlm, reg.lambdas = FALSE)

parameters(regionalize(tlm), "gev")
parameters(regionalize(tlm, reg.lambdas = FALSE), "gev")

quantiles(parameters(regionalize(tlm), "gev"), c(.99, .999))
quantiles(parameters(regionalize(tlm, reg.lambdas = FALSE), "gev"), c(.99, .999))


# With magrittr
library(magrittr)
matrix(rgev(200, shape = .3), nc = 5) %&gt;%
 TLMoments(rightrim = 1) %&gt;%
 regionalize %&gt;%
 parameters("gev") %&gt;%
 quantiles(c(.99, .999))
</code></pre>

<hr>
<h2 id='returnParameters'>returnParameters</h2><span id='topic+returnParameters'></span>

<h3>Description</h3>

<p>Sets attributions to parameters objects and returns them. This function is for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnParameters(out, distribution, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnParameters_+3A_out">out</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnParameters_+3A_distribution">distribution</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnParameters_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class parameters.
</p>

<hr>
<h2 id='returnPWMs'>returnPWMs</h2><span id='topic+returnPWMs'></span>

<h3>Description</h3>

<p>Sets attributes to PWMs objects and returns them. This function is for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnPWMs(out, order, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnPWMs_+3A_out">out</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnPWMs_+3A_order">order</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnPWMs_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PWMs.
</p>

<hr>
<h2 id='returnQuantiles'>returnQuantiles</h2><span id='topic+returnQuantiles'></span>

<h3>Description</h3>

<p>Sets attributions to quantiles objects and returns them. This function is for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnQuantiles(out, distribution, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnQuantiles_+3A_out">out</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnQuantiles_+3A_distribution">distribution</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnQuantiles_+3A_p">p</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnQuantiles_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class quantiles.
</p>

<hr>
<h2 id='returnTLMoments'>returnTLMoments</h2><span id='topic+returnTLMoments'></span>

<h3>Description</h3>

<p>Sets attributions to TLMoments objects and returns them. This function is for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnTLMoments(out, leftrim, rightrim, order, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnTLMoments_+3A_out">out</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnTLMoments_+3A_leftrim">leftrim</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnTLMoments_+3A_rightrim">rightrim</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnTLMoments_+3A_order">order</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="returnTLMoments_+3A_...">...</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class TLMoments.
</p>

<hr>
<h2 id='summary.parameters'>Summary parameters</h2><span id='topic+summary.parameters'></span>

<h3>Description</h3>

<p>Calculating and printing of summary statistics to a given parameters-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parameters'
summary(object, ci.level = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.parameters_+3A_object">object</code></td>
<td>
<p>object of parameters.</p>
</td></tr>
<tr><td><code id="summary.parameters_+3A_ci.level">ci.level</code></td>
<td>
<p>numeric vector of length 1 giving the confidence level (default is 0.9).</p>
</td></tr>
<tr><td><code id="summary.parameters_+3A_...">...</code></td>
<td>
<p>additional arguments submitted to <code>est_cov</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.parameters</code>-object, a list with dimensions </p>

<ul>
<li> <p><code>param</code>
</p>
</li>
<li> <p><code>ci.level</code>
</p>
</li>
<li> <p><code>ci</code>
</p>
</li>
<li> <p><code>cov</code>
</p>
</li></ul>

<p>It is printed with <code>print.summary.parameters</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+est_cov">est_cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(rgev(100, shape = .2), rgev(100, shape = .2))

p &lt;- parameters(TLMoments(x[, 1]), "gev")
summary(p)
summary(p, select = c("scale", "shape"))

p &lt;- parameters(TLMoments(x[, 1], rightrim = 1), "gev")
summary(p)

p &lt;- parameters(TLMoments(x), "gev")
summary(p)
summary(p, select = "shape")

p &lt;- as.parameters(loc = 10, scale = 5, shape = .3, distr = "gev")
summary(p)
summary(p, rightrim = 1, set.n = 250)

</code></pre>

<hr>
<h2 id='summary.PWMs'>Summary PWMs</h2><span id='topic+summary.PWMs'></span>

<h3>Description</h3>

<p>Calculating and printing of summary statistics to a given PWMs-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PWMs'
summary(object, ci.level = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PWMs_+3A_object">object</code></td>
<td>
<p>object of PWMs.</p>
</td></tr>
<tr><td><code id="summary.PWMs_+3A_ci.level">ci.level</code></td>
<td>
<p>numeric vector of length 1 giving the confidence level (default is 0.9).</p>
</td></tr>
<tr><td><code id="summary.PWMs_+3A_...">...</code></td>
<td>
<p>additional arguments submitted to <code>est_cov</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.PWMs</code>-object, a list with dimensions </p>

<ul>
<li> <p><code>pwm</code>
</p>
</li>
<li> <p><code>ci.level</code>
</p>
</li>
<li> <p><code>ci</code>
</p>
</li>
<li> <p><code>cov</code>
</p>
</li></ul>

<p>It is printed with <code>print.summary.PWMs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>, <code><a href="#topic+est_cov">est_cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(rgev(100, shape = .2), rgev(100, shape = .2))

summary(PWMs(x[, 1]))
summary(PWMs(x[, 1]), distr = "gev")
summary(PWMs(x[, 1]), distr = "gev", select = 1:2)

summary(PWMs(x))
summary(PWMs(x), select = 1:2)

## Not run: 
summary(as.PWMs(c(15, 4, .5)))

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.quantiles'>Summary quantiles</h2><span id='topic+summary.quantiles'></span>

<h3>Description</h3>

<p>Calculating and printing of summary statistics to a given quantiles-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quantiles'
summary(object, ci.level = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.quantiles_+3A_object">object</code></td>
<td>
<p>object of quantiles.</p>
</td></tr>
<tr><td><code id="summary.quantiles_+3A_ci.level">ci.level</code></td>
<td>
<p>numeric vector of length 1 giving the confidence level (default is 0.9).</p>
</td></tr>
<tr><td><code id="summary.quantiles_+3A_...">...</code></td>
<td>
<p>additional arguments submitted to <code>est_cov</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.quantiles</code>-object, a list with dimensions </p>

<ul>
<li> <p><code>q</code>
</p>
</li>
<li> <p><code>ci.level</code>
</p>
</li>
<li> <p><code>ci</code>
</p>
</li>
<li> <p><code>cov</code>
</p>
</li></ul>

<p>It is printed with <code>print.summary.quantiles</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantiles">quantiles</a></code>, <code><a href="#topic+est_cov">est_cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(rgev(100, shape = .2), rgev(100, shape = .2))

q &lt;- quantiles(parameters(TLMoments(x[, 1]), "gev"), c(.9, .95, .99))
summary(q)
summary(q, select = c(.9, .99))

q &lt;- quantiles(parameters(TLMoments(x[, 1], rightrim = 1), "gev"), .95)
summary(q)

q &lt;- quantiles(parameters(TLMoments(x), "gev"), c(.9, .95, .99))
summary(q)
summary(q, select = .95)

q &lt;- quantiles(as.parameters(loc = 10, scale = 5, shape = .3, distr = "gev"), c(.9, .99))
summary(q)
summary(q, rightrim = 1, set.n = 250)

</code></pre>

<hr>
<h2 id='summary.TLMoments'>Summary TLMoments</h2><span id='topic+summary.TLMoments'></span>

<h3>Description</h3>

<p>Calculating and printing of summary statistics to a given TLMoments-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TLMoments'
summary(object, ci.level = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.TLMoments_+3A_object">object</code></td>
<td>
<p>object of TLMoments.</p>
</td></tr>
<tr><td><code id="summary.TLMoments_+3A_ci.level">ci.level</code></td>
<td>
<p>numeric vector of length 1 giving the confidence level (default is 0.9).</p>
</td></tr>
<tr><td><code id="summary.TLMoments_+3A_...">...</code></td>
<td>
<p>additional arguments submitted to <code>est_cov</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.TLMoments</code>-object, a list with dimensions </p>

<ul>
<li> <p><code>tlm</code>
</p>
</li>
<li> <p><code>ci.level</code>
</p>
</li>
<li> <p><code>lambda.ci</code>
</p>
</li>
<li> <p><code>lambda.cov</code>
</p>
</li>
<li> <p><code>ratio.ci</code>
</p>
</li>
<li> <p><code>ratio.cov</code>
</p>
</li></ul>

<p>It is printed with <code>print.summary.TLMoments</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLMoments">TLMoments</a></code>, <code><a href="#topic+est_cov">est_cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tlm &lt;- TLMoments(rgev(100, shape = .2))
summary(tlm)

tlm &lt;- TLMoments(rgev(100, shape = .2), rightrim = 1)
summary(tlm, select = 3:4)

tlm &lt;- TLMoments(rgev(100, shape = .2), max.order = 2, rightrim = 1)
summary(tlm)

tlm &lt;- TLMoments(matrix(rgev(100, shape = .2), nc = 2))
summary(tlm, select = 3:4)

tlm &lt;- TLMoments(matrix(rgev(100, shape = .2), nc = 2), max.order = 3)
summary(tlm, ci = .95, distr = "gev")

tlm &lt;- as.TLMoments(c(15, 5, 1.3))
summary(tlm, distr = "gev", set.n = 100)

</code></pre>

<hr>
<h2 id='TLMoment'>Trimmed L Moments</h2><span id='topic+TLMoment'></span>

<h3>Description</h3>

<p>Calculates empirical Trimmed L-moments of specific order(s) and trimming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TLMoment(
  x,
  order = 1L,
  leftrim = 0L,
  rightrim = 0L,
  na.rm = FALSE,
  computation.method = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TLMoment_+3A_x">x</code></td>
<td>
<p>numeric vector of data.</p>
</td></tr>
<tr><td><code id="TLMoment_+3A_order">order</code></td>
<td>
<p>integer, order of Trimmed Moment, has to be greater than 1.</p>
</td></tr>
<tr><td><code id="TLMoment_+3A_leftrim">leftrim</code>, <code id="TLMoment_+3A_rightrim">rightrim</code></td>
<td>
<p>integer indicating trimming parameters, have to be greater than 0.</p>
</td></tr>
<tr><td><code id="TLMoment_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates if NAs should be removed.</p>
</td></tr>
<tr><td><code id="TLMoment_+3A_computation.method">computation.method</code></td>
<td>
<p>character, indicating if the computation is performed via
PWMs, direct, recursive, or recurrence (see References Hosking &amp; Balakrishnan, 2015).
Possible values are <code>auto</code> (default, automatically choose appropriate method), <code>pwm</code>,
<code>direct</code>, <code>recursive</code>, or <code>recurrence</code>. Only if empirical moments are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, empirical TL(<code>leftrim</code>,<code>rightrim</code>)-moments of orders <code>order</code> of <code>x</code>
</p>


<h3>References</h3>

<p>Elamir, E. A., &amp; Seheult, A. H. (2003). Trimmed L-moments. Computational Statistics &amp; Data Analysis, 43(3), 299-314.
</p>
<p>Hosking, J. R. (1990). L-moments: analysis and estimation of distributions using linear combinations of order statistics. Journal of the Royal Statistical Society. Series B (Methodological), 105-124.
</p>
<p>Hosking, J. R. M. (2007). Some theory and practical uses of trimmed L-moments. Journal of Statistical Planning and Inference, 137(9), 3024-3039.
</p>
<p>Hosking, J. R. M., &amp; Balakrishnan, N. (2015). A uniqueness result for L-estimators, with applications to L-moments. Statistical Methodology, 24, 69-80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLMoments">TLMoments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
TLMoment(x, order = 1)
TLMoment(x, order = 2, leftrim = 0, rightrim = 1)
TLMoment(x, order = c(1, 2, 3), leftrim = 2, rightrim = 2)
TLMoment(x, order = c(1, 3, 2), leftrim = 2, rightrim = 2)
</code></pre>

<hr>
<h2 id='TLMoments'>Trimmed L-moments</h2><span id='topic+TLMoments'></span><span id='topic+TLMoments.numeric'></span><span id='topic+TLMoments.matrix'></span><span id='topic+TLMoments.list'></span><span id='topic+TLMoments.data.frame'></span><span id='topic+TLMoments.PWMs'></span><span id='topic+TLMoments.parameters'></span>

<h3>Description</h3>

<p>Calculates empirical or theoretical Trimmed L-moments and -ratios up to a specific order.
If empirical moments should be calculated, acceptable input types are numeric vectors,
matrices, lists, data.frames. TLMoments is type-preservative, so the input type is also
the output type. If theoretical moments should be calculated, the input type has to be
of class parameters or PWMs, so an object returned by parameters, as.parameters or
PWMs, as.PWMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TLMoments(x, ...)

## S3 method for class 'numeric'
TLMoments(
  x,
  leftrim = 0L,
  rightrim = 0L,
  max.order = 4L,
  na.rm = FALSE,
  computation.method = "auto",
  ...
)

## S3 method for class 'matrix'
TLMoments(
  x,
  leftrim = 0L,
  rightrim = 0L,
  max.order = 4L,
  na.rm = FALSE,
  computation.method = "auto",
  ...
)

## S3 method for class 'list'
TLMoments(
  x,
  leftrim = 0L,
  rightrim = 0L,
  max.order = 4L,
  na.rm = FALSE,
  computation.method = "auto",
  ...
)

## S3 method for class 'data.frame'
TLMoments(
  x,
  formula,
  leftrim = 0L,
  rightrim = 0L,
  max.order = 4L,
  na.rm = FALSE,
  computation.method = "auto",
  ...
)

## S3 method for class 'PWMs'
TLMoments(x, leftrim = 0L, rightrim = 0L, ...)

## S3 method for class 'parameters'
TLMoments(
  x,
  leftrim = attr(x, "source")$trimmings[1],
  rightrim = attr(x, "source")$trimmings[2],
  max.order = 4L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TLMoments_+3A_x">x</code></td>
<td>
<p>numeric data in form of vector, matrix, list, or data.frame OR an object
of class parameters or PWMs.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_leftrim">leftrim</code></td>
<td>
<p>integer indicating lower trimming parameter, has to be greater than 0.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_rightrim">rightrim</code></td>
<td>
<p>integer indicating upper trimming parameter, has to be greater than 0.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_max.order">max.order</code></td>
<td>
<p>integer, maximum order of Trimmed L-moments/ratios, has to be
greater than 1.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates if NAs should be removed. Only if empirical moments
are calculated.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_computation.method">computation.method</code></td>
<td>
<p>character, indicating if the computation is performed via
PWMs, direct, recursive, or recurrence (see References Hosking &amp; Balakrishnan, 2015).
Possible values are <code>auto</code> (default, automatically choose appropriate method), <code>pwm</code>,
<code>direct</code>, <code>recursive</code>, or <code>recurrence</code>. Only if empirical moments are calculated.</p>
</td></tr>
<tr><td><code id="TLMoments_+3A_formula">formula</code></td>
<td>
<p>if <code>x</code> is data.frame. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two dimensions: <code>lambdas</code>/<code>ratios</code> are a numeric vector, matrix,
list, or data.frame consisting of the TL-moments/TL-moment-ratios. The list has the class
<code>TLMoments</code>.
The object contains the following attributes: </p>

<ul>
<li> <p><code>leftrim</code>: a numeric giving the used leftrim-argument
</p>
</li>
<li> <p><code>rightrim</code>: a numeric giving the used rightrim-argument
</p>
</li>
<li> <p><code>order</code>: a integer vector with corresponding TL-moment orders
</p>
</li>
<li> <p><code>source</code>: a list with background information (used function, data, n, formula, computation method;
mainly for internal purposes)
</p>
</li></ul>

<p>The attributes are hidden in the print-function for a clearer presentation.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: TLMoments for numeric vector of data
</p>
</li>
<li> <p><code>matrix</code>: TLMoments for numeric matrix of data
</p>
</li>
<li> <p><code>list</code>: TLMoments for numeric list of data
</p>
</li>
<li> <p><code>data.frame</code>: TLMoments for numeric data.frame of data
</p>
</li>
<li> <p><code>PWMs</code>: TLMoments for PWMs-object
</p>
</li>
<li> <p><code>parameters</code>: TLMoments for parameters-object
</p>
</li></ul>


<h3>References</h3>

<p>Elamir, E. A., &amp; Seheult, A. H. (2003). Trimmed L-moments. Computational Statistics &amp; Data Analysis, 43(3), 299-314.
</p>
<p>Hosking, J. R. M. (1990). L-moments: analysis and estimation of distributions using linear combinations of order statistics. Journal of the Royal Statistical Society. Series B (Methodological), 105-124.
</p>
<p>Hosking, J. R. M. (2007). Some theory and practical uses of trimmed L-moments. Journal of Statistical Planning and Inference, 137(9), 3024-3039.
</p>
<p>Hosking, J. R. M., &amp; Balakrishnan, N. (2015). A uniqueness result for L-estimators, with applications to L-moments. Statistical Methodology, 24, 69-80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PWMs">PWMs</a></code>, <code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+quantiles">quantiles</a></code>, <code><a href="#topic+summary.TLMoments">summary.TLMoments</a></code>, <code><a href="#topic+as.TLMoments">as.TLMoments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data sets:
xmat &lt;- matrix(rnorm(100), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(
 station = rep(letters[1:2], each = 50),
 season = rep(c("S", "W"), 50),
 hq = as.vector(xmat)
)

# Calculating TL-moments from data:
TLMoments(xvec, leftrim = 0, rightrim = 1)
TLMoments(xmat, leftrim = 1, rightrim = 1)
TLMoments(xlist, max.order = 7)
TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 2)
TLMoments(xdat, hq ~ season, leftrim = 0, rightrim = 2)
TLMoments(xdat, hq ~ ., leftrim = 0, rightrim = 2)

# Calculating TL-moments from PWMs:
TLMoments(PWMs(xvec))
TLMoments(PWMs(xmat), rightrim = 1)
TLMoments(PWMs(xlist), leftrim = 1, rightrim = 1)
TLMoments(PWMs(xdat, hq ~ station), leftrim = 0, rightrim = 2)
TLMoments(PWMs(xdat, hq ~ station + season), leftrim = 0, rightrim = 2)
TLMoments(as.PWMs(cbind(c(0.12, .41, .38, .33), c(.05, 0.28, .25, .22))), 0, 1)

# Calculating TL-moments from parameters:
(tlm &lt;- TLMoments(xmat, leftrim = 0, rightrim = 1))
TLMoments(parameters(tlm, "gev"))

(tlm &lt;- TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 2))
TLMoments(parameters(tlm, "gev"))

p &lt;- as.parameters(loc = 3, scale = 2, shape = .4, distr = "gev")
TLMoments(p, rightrim = 1)

p &lt;- as.parameters(cbind(loc = 10, scale = 4, shape = seq(0, .4, .1)), distr = "gev")
TLMoments(p, max.order = 6)

p &lt;- as.parameters(list(
 list(loc = 3, scale = 2, shape = .4),
 list(loc = 3, scale = 2, shape = .2)
), distr = "gev")
TLMoments(p)

p &lt;- as.parameters(data.frame(
 station = letters[1:2],
 loc = c(2, 3),
 scale = c(2, 2),
 shape = c(.4, .2)
), .~station, distr = "gev")
TLMoments(p)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
