<!DOCTYPE html><html lang="en"><head><title>Help for package luajr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {luajr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#luajr-package'><p>luajr: LuaJIT Scripting</p></a></li>
<li><a href='#lua'><p>Run Lua code</p></a></li>
<li><a href='#lua_func'><p>Make a Lua function callable from R</p></a></li>
<li><a href='#lua_open'><p>Create a new Lua state</p></a></li>
<li><a href='#lua_parallel'><p>Run Lua code in parallel</p></a></li>
<li><a href='#lua_reset'><p>Reset the default Lua state</p></a></li>
<li><a href='#lua_shell'><p>Run an interactive Lua shell</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'LuaJIT' Scripting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to 'LuaJIT' <a href="https://luajit.org">https://luajit.org</a>, a just-in-time 
    compiler for the 'Lua' scripting language <a href="https://www.lua.org">https://www.lua.org</a>. Allows 
    users to run 'Lua' code from 'R'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nicholasdavies/luajr">https://github.com/nicholasdavies/luajr</a>,
<a href="https://nicholasdavies.github.io/luajr/">https://nicholasdavies.github.io/luajr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nicholasdavies/luajr/issues">https://github.com/nicholasdavies/luajr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rcpp, crayon, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 14:30:03 UTC; nick</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Pall [aut, cph] (Author of the embedded LuaJIT compiler),
  Lua.org, PUC-Rio [cph] (Copyright holders over portions of Lua source
    code included in LuaJIT),
  Nicholas Davies <a href="https://orcid.org/0000-0002-1740-1412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb, cph] (Author of the R package wrapper)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Davies &lt;nicholas.davies@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='luajr-package'>luajr: LuaJIT Scripting</h2><span id='topic+luajr'></span><span id='topic+luajr-package'></span>

<h3>Description</h3>

<p>'luajr' provides an interface to <a href="https://luajit.org">LuaJIT</a>, a
just-in-time compiler for the <a href="https://www.lua.org">Lua scripting language</a>.
It allows users to run Lua code from R.
</p>


<h3>The R API</h3>


<ul>
<li> <p><code><a href="#topic+lua">lua()</a></code>: run Lua code
</p>
</li>
<li> <p><code><a href="#topic+lua_func">lua_func()</a></code>: make a Lua function callable from R
</p>
</li>
<li> <p><code><a href="#topic+lua_shell">lua_shell()</a></code>: run an interactive Lua shell
</p>
</li>
<li> <p><code><a href="#topic+lua_open">lua_open()</a></code>: create a new Lua state
</p>
</li>
<li> <p><code><a href="#topic+lua_reset">lua_reset()</a></code>: reset the default Lua state
</p>
</li>
<li> <p><code><a href="#topic+lua_parallel">lua_parallel()</a></code>: run Lua code in parallel
</p>
</li></ul>



<h3>Further reading</h3>

<p>For an introduction to 'luajr', see <code>vignette("luajr")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicholas Davies <a href="mailto:nicholas.davies@lshtm.ac.uk">nicholas.davies@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0002-1740-1412">ORCID</a>) (Author of the R package wrapper) [contributor, copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Mike Pall (Author of the embedded LuaJIT compiler) [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Lua.org, PUC-Rio (Copyright holders over portions of Lua source code included in LuaJIT) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nicholasdavies/luajr">https://github.com/nicholasdavies/luajr</a>
</p>
</li>
<li> <p><a href="https://nicholasdavies.github.io/luajr/">https://nicholasdavies.github.io/luajr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nicholasdavies/luajr/issues">https://github.com/nicholasdavies/luajr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='lua'>Run Lua code</h2><span id='topic+lua'></span>

<h3>Description</h3>

<p>Runs the specified Lua code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua(code, filename = NULL, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lua_+3A_code">code</code></td>
<td>
<p>Lua code block to run.</p>
</td></tr>
<tr><td><code id="lua_+3A_filename">filename</code></td>
<td>
<p>If non-<code>NULL</code>, name of file to run.</p>
</td></tr>
<tr><td><code id="lua_+3A_l">L</code></td>
<td>
<p><a href="#topic+lua_open">Lua state</a> in which to run the code. <code>NULL</code> (default)
uses the default Lua state for <span class="pkg">luajr</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lua value(s) returned by the code block converted to R object(s).
Only a subset of all Lua types can be converted to R objects at present.
If multiple values are returned, these are packaged in a <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twelve &lt;- lua("return 3*4")
print(twelve)
</code></pre>

<hr>
<h2 id='lua_func'>Make a Lua function callable from R</h2><span id='topic+lua_func'></span>

<h3>Description</h3>

<p>Takes any Lua expression that evaluates to a function and provides an R
function that can be called to invoke the Lua function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua_func(func, argcode = "s", L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lua_func_+3A_func">func</code></td>
<td>
<p>Lua expression evaluating to a function.</p>
</td></tr>
<tr><td><code id="lua_func_+3A_argcode">argcode</code></td>
<td>
<p>How to wrap R arguments for the Lua function.</p>
</td></tr>
<tr><td><code id="lua_func_+3A_l">L</code></td>
<td>
<p><a href="#topic+lua_open">Lua state</a> in which to run the code. <code>NULL</code> (default)
uses the default Lua state for <span class="pkg">luajr</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The R types that can be passed to Lua are: <code>NULL</code>, logical vector,
integer vector, numeric vector, string vector, list, external pointer, and
raw.
</p>
<p>The parameter <code>argcode</code> is a string with one character for each argument of
the Lua function, recycled as needed (e.g. so that a single character would
apply to all arguments regardless of how many there are).
</p>
<p>In the following, the corresponding character of <code>argcode</code> for a specific
argument is referred to as its argcode.
</p>
<p>For <code>NULL</code> or any argument with length 0, the result in Lua is <strong>nil</strong>
regardless of the corresponding argcode.
</p>
<p>For logical, integer, double, and character vectors, if the corresponding
argcode is <code>'s'</code> (simplify), then if the R vector has length one, it is
supplied as a Lua primitive (boolean, number, number, or string,
respectively), and if length &gt; 1, as an array, i.e. a table with integer
indices starting at 1. If the code is <code>'a'</code>, the vector is always supplied as
an array, even if it only has length 1. If the argcode is the digit <code>'1'</code>
through <code>'9'</code>, this is the same as <code>'s'</code>, but the vector is required to have
that specific length, otherwise an error message is emitted.
</p>
<p>Still focusing on the same vector types, if the argcode is <code>'r'</code>, then the
vector is passed <em>by reference</em> to Lua, adopting the type <code>luajr.logical_r</code>,
<code>luajr.integer_r</code>, <code>luajr.numeric_r</code>, or <code>luajr.character_r</code> as appropriate.
If the argcode is <code>'v'</code>, the vector is passed <em>by value</em> to Lua,
adopting the type <code>luajr.logical</code>, <code>luajr.integer</code>, <code>luajr.numeric</code>, or
<code>luajr.character</code> as appropriate.
</p>
<p>For a raw vector, only the <code>'s'</code> type is accepted and the result in Lua is
a string (potentially with embedded nulls).
</p>
<p>For lists, if the argcode is <code>'s'</code> (simplify), the list is passed as a Lua
table. Any entries of the list with non-blank names are named in the table,
while unnamed entries have the associated integer key in the table. Note that
Lua does not preserve the order of entries in tables. This means that an R
list with names will often go &quot;out of order&quot; when passed into Lua with <code>'s'</code>
and then returned back to R. This is avoided with argcode <code>'r'</code> or <code>'v'</code>.
</p>
<p>If a list is passed in with the argcode <code>'r'</code> or <code>'v'</code>, the list is
passed to Lua as type <code>luajr.list</code>, and all vector elements of the list are
passed by reference or by value, respectively.
</p>
<p>For external pointers, the argcode is ignored and the external pointer is
passed to Lua as type <strong>userdata</strong>.
</p>
<p>When the function is called and Lua values are returned from the function,
the Lua return values are converted to R values as follows.
</p>
<p>If nothing is returned, the function returns <code>invisible()</code> (i.e. <code>NULL</code>).
</p>
<p>If multiple arguments are returned, a list with all arguments is returned.
</p>
<p>Reference types (e.g. <code>luajr.logical_r</code>) and vector types (e.g.
<code>luajr.logical</code>) are returned to R as such. A <code>luajr.list</code> is returned as an
R list. Reference and list types respect R attributes set within Lua code.
</p>
<p>A <strong>table</strong> is returned as a list. In the list, any table entries with a
number key come first (with indices 1 to n, i.e. the original number key's
value is discarded), followed by any table entries with a string key
(named accordingly). This may well scramble the order of keys, so beware.
Note in particular that Lua does not guarantee that it will traverse a table
in ascending order of keys. Entries with non-number, non-string keys are
discarded. It is probably best to avoid returning a <strong>table</strong> with anything
other than string keys, or to use <code>luajr.list</code>.
</p>
<p>A Lua string with embedded nulls is returned as an R raw type.
</p>


<h3>Value</h3>

<p>An R function which can be called to invoke the Lua function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>squared &lt;- lua_func("function(x) return x^2 end")
print(squared(7))
</code></pre>

<hr>
<h2 id='lua_open'>Create a new Lua state</h2><span id='topic+lua_open'></span>

<h3>Description</h3>

<p>Creates a new, empty Lua state and returns an external pointer wrapping that
state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua_open()
</code></pre>


<h3>Details</h3>

<p>All Lua code is executed within a given Lua state. A Lua state is similar to
the global environment in R, in that it is where all variables and functions
are defined. <span class="pkg">luajr</span> automatically maintains a &quot;default&quot; Lua state, so
most users of <span class="pkg">luajr</span> will not need to use <code><a href="#topic+lua_open">lua_open()</a></code>.
</p>
<p>However, if for whatever reason you want to maintain multiple different Lua
states at a time, each with their own independent global variables and
functions, <code><a href="#topic+lua_open">lua_open()</a></code> can be used to create a new Lua state which can then
be passed to <code><a href="#topic+lua">lua()</a></code>, <code><a href="#topic+lua_func">lua_func()</a></code> and <code><a href="#topic+lua_shell">lua_shell()</a></code> via the <code>L</code> parameter.
These functions will then operate within that Lua state instead of the
default one. The default Lua state can be specified explicitly with
<code>L = NULL</code>.
</p>
<p>Note that there is currently no way (provided by <span class="pkg">luajr</span>) of saving a
Lua state to disk so that the state can be restarted later. Also, there is
no <code>lua_close</code> in <span class="pkg">luajr</span> because Lua states are closed automatically
when they are garbage collected in R.
</p>


<h3>Value</h3>

<p>External pointer wrapping the newly created Lua state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1 &lt;- lua_open()
lua("a = 2")
lua("a = 4", L = L1)
lua("print(a)") # 2
lua("print(a)", L = L1) # 4
</code></pre>

<hr>
<h2 id='lua_parallel'>Run Lua code in parallel</h2><span id='topic+lua_parallel'></span>

<h3>Description</h3>

<p>Runs a Lua function multiple times, with function runs divided among
multiple threads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua_parallel(func, n, threads, pre = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lua_parallel_+3A_func">func</code></td>
<td>
<p>Lua expression evaluating to a function.</p>
</td></tr>
<tr><td><code id="lua_parallel_+3A_n">n</code></td>
<td>
<p>Number of function executions.</p>
</td></tr>
<tr><td><code id="lua_parallel_+3A_threads">threads</code></td>
<td>
<p>Number of threads to create, or a list of existing Lua states
(e.g. as created by <code><a href="#topic+lua_open">lua_open()</a></code>), all different, one for each thread.</p>
</td></tr>
<tr><td><code id="lua_parallel_+3A_pre">pre</code></td>
<td>
<p>Lua code block to run once for each thread at creation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is experimental. Its interface and behaviour are likely to
change in subsequent versions of luajr.
</p>
<p><code><a href="#topic+lua_parallel">lua_parallel()</a></code> works as follows. A number <code>threads</code> of new Lua states is
created with the standard Lua libraries and the <code>luajr</code> module opened in
each (i.e. as though the states were created using <code><a href="#topic+lua_open">lua_open()</a></code>). Then, a
thread is launched for each state. Within each thread, the code in <code>pre</code> is
run in the corresponding Lua state. Then, <code>func(i)</code> is called for each <code>i</code>
in <code>1:n</code>, with the calls spread across the states. Finally, the Lua states
are closed and the results are returned in a list.
</p>
<p>Instead of an integer, <code>threads</code> can be a list of Lua states, e.g. <code>NULL</code>
for the default Lua state or a state returned by <code><a href="#topic+lua_open">lua_open()</a></code>. This saves
the time needed to open the new states, which takes a few milliseconds.
</p>


<h3>Value</h3>

<p>List of <code>n</code> values returned from the Lua function <code>func</code>.
</p>


<h3>Safety and performance</h3>

<p>Note that <code>func</code> has to be thread-safe. All pure Lua code and built-in Lua
library functions are thread-safe, except for certain functions in the
built-in <strong>os</strong> and <strong>io</strong> libraries (search for &quot;thread safe&quot; in the
<a href="https://www.lua.org/manual/5.2/manual.html">Lua 5.2 reference manual</a>).
</p>
<p>Additionally, use of luajr reference types is <strong>not</strong> thread-safe because
these use R to allocate and manage memory, and R is not thread-safe. This
means that you cannot safely use <code>luajr.logical_r</code>, <code>luajr.integer_r</code>,
<code>luajr.numeric_r</code>, <code>luajr.character_r</code>, or other reference types within
<code>func</code>. <code>luajr.list</code> and <code>luajr.dataframe</code> are fine, provided the list
entries / dataframe columns are value types.
</p>
<p>There is overhead associated with creating new Lua states and with gathering
all the function results in an R list. It is advisable to check whether
running your Lua code in parallel actually gives a substantial speed
increase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lua_parallel("function(i) return i end", n = 4, threads = 2)
</code></pre>

<hr>
<h2 id='lua_reset'>Reset the default Lua state</h2><span id='topic+lua_reset'></span>

<h3>Description</h3>

<p>Clears out all variables from the default Lua state, freeing up the
associated memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua_reset()
</code></pre>


<h3>Details</h3>

<p>This resets the default <a href="#topic+lua_open">Lua state</a> only. To reset a non-default
Lua state <code>L</code> returned by <code><a href="#topic+lua_open">lua_open()</a></code>, just do <code>L &lt;- lua_open()</code> again. The
memory previously used will be cleaned up at the next garbage collection.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lua("a = 2")
lua_reset()
lua("print(a)") # nil
</code></pre>

<hr>
<h2 id='lua_shell'>Run an interactive Lua shell</h2><span id='topic+lua_shell'></span>

<h3>Description</h3>

<p>When in interactive mode, provides a basic read-eval-print loop with LuaJIT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lua_shell(L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lua_shell_+3A_l">L</code></td>
<td>
<p><a href="#topic+lua_open">Lua state</a> in which to run the code. <code>NULL</code> (default)
uses the default Lua state for <span class="pkg">luajr</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enter an empty line to return to R.
</p>
<p>As a convenience, lines starting with an equals sign have the <code>"="</code> replaced
with <code>"return "</code>, so that e.g. entering <code style="white-space: pre;">&#8288;=x&#8288;</code> will show the value of <code>x</code> as
returned to R.
</p>


<h3>Value</h3>

<p>None.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
