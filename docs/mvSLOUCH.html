<!DOCTYPE html><html lang="en"><head><title>Help for package mvSLOUCH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvSLOUCH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvSLOUCH-package'><p>Multivariate Ornstein-Uhlenbeck type stochastic differential equation models</p>
for phylogenetic comparative data.</a></li>
<li><a href='#BrownianMotionModel'><p>Estimate parameters under a Brownian motion model of evolution</p></a></li>
<li><a href='#drawPhylProcess'><p>Plots the realization of a process evolving on a phylogenetic tree</p></a></li>
<li><a href='#estimate.evolutionary.model'>
<p>Wrapper function to find best (out of BM, OU, OUOU, OUBM) fitting evolutionary model and</p>
estimate its parameters.</a></li>
<li><a href='#fitch.mvsl'><p>Unordered Fitch parsimony reconstruction of discrete character states</p></a></li>
<li><a href='#generate.model.setups'><p>Generate a list of model setups for the function</p>
<code>estimate.evolutionary.model</code>.</a></li>
<li><a href='#mvSLOUCH-internal'><p>Internal mvSLOUCH objects</p></a></li>
<li><a href='#mvslouchModel'>
<p>Estimate parameters under a (multivariate) OUBM model of evolution</p></a></li>
<li><a href='#OU_phylreg'>
<p>Performs a phylogenetic regression under a given OU model of evolution</p></a></li>
<li><a href='#OU_RSS'>
<p>Calculates the RSS under a (multivariate) phylogenetic OU model of evolution</p></a></li>
<li><a href='#OU_xVz'>
<p>Performs a vector matrix vector multiplcation under a (multivariate) phylogenetic OU model of evolution</p></a></li>
<li><a href='#ouchModel'>
<p>Estimate parameters under a (multivariate) OU model of evolution</p></a></li>
<li><a href='#parametric.bootstrap'><p>Parametric bootstrap for confidence intervals</p></a></li>
<li><a href='#phyltree_paths'><p>Extract path information from a phylogenetic tree</p></a></li>
<li><a href='#plot.clustered_phylo'><p>Plots a clustered_phylo object.</p></a></li>
<li><a href='#simulate_clustered_phylogeny'>
<p>Simulate a phylogenetic tree with a specified number of clades.</p></a></li>
<li><a href='#simulBMProcPhylTree'>
<p>Simulate data on a phylogeny under a (multivariate) Brownian motion model</p></a></li>
<li><a href='#simulMVSLOUCHProcPhylTree'>
<p>Simulate data on a phylogeny under a (multivariate) OUBM model</p></a></li>
<li><a href='#simulOUCHProcPhylTree'>
<p>Simulate data on a phylogeny under a (multivariate) OU model</p></a></li>
<li><a href='#SummarizeBM'><p>Summarize parameters estimated under a Brownian motion model</p></a></li>
<li><a href='#SummarizeMVSLOUCH'>
<p>Summarize parameters estimated under a multivariate OUBM motion model</p></a></li>
<li><a href='#SummarizeOUCH'>
<p>Summarize parameters estimated under a (multivariate) OU motion model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Stochastic Linear Ornstein-Uhlenbeck Models for
Phylogenetic Comparative Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Bartoszek &lt;krzbar@protonmail.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits multivariate Ornstein-Uhlenbeck types of models to continues trait data from species related by a common evolutionary history. See K. Bartoszek, J, Pienaar, P. Mostad, S. Andersson, T. F. Hansen (2012) &lt;<a href="https://doi.org/10.1016%2Fj.jtbi.2012.08.005">doi:10.1016/j.jtbi.2012.08.005</a>&gt;. The suggested PCMBaseCpp package (which significantly speeds up the likelihood calculations) can be obtained from <a href="https://github.com/venelin/PCMBaseCpp/">https://github.com/venelin/PCMBaseCpp/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), abind</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>bootstrap.R evolmodelest.R matrixexps.R phylgls.R
sdecovariancephyl.R wrappers.R ci.R fitch.mvsl.R
calls_to_matrixcalc.R matrixparametrizations.R PhyloSDEestim.R
sdemoments.R estimBM.R getESS.R modelparams.R phyltree_paths.R
simulVasicekprocphyl.R estimGLSGC.R loglik.R
modelparamssummary.R precalcs.R simulVasicekproc.R
estimMAXLIK.R make.states.mvsl.R modelparamstransform.R
regimes.R trees2slouch.mvsl.R simulclustphyl.R
OUphylregression.R sdemeanphyl.R</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 5.3), graphics, methods, mvtnorm, Matrix, ouch,
PCMBase (&ge; 1.2.10), stats, matrixcalc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PCMBaseCpp (&ge; 0.1.9), ggplot2, knitr, rmarkdown, mvMORPH,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 17:41:37 UTC; kbart</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Bartoszek [cre, aut],
  John Clarke [ctb],
  Jesualdo Fuentes-Gonzalez [ctb],
  Jason Pienaar [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 18:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvSLOUCH-package'>Multivariate Ornstein-Uhlenbeck type stochastic differential equation models 
for phylogenetic comparative data.
</h2><span id='topic+mvSLOUCH-package'></span><span id='topic+mvSLOUCH'></span>

<h3>Description</h3>

<p>The package allows for  maximum likelihood estimation, simulation and study of properties 
of multivariate Brownian motion </p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}dX(t) &amp; = &amp; \Sigma dB(t),\end{array}</code>
</p>

<p>OU </p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}dY(t) &amp; = &amp; -A(Y(t)-\Psi(t))dt + \Sigma dB(t)\end{array}</code>
</p>

<p>and OUBM  
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
dY(t) &amp; = &amp; -A(Y(t)-(\Psi(t)- A^{-1}BX(t)))dt + \Sigma_{yy} dB(t) \\ dX(t) &amp; = &amp; \Sigma_{xx} dB(t)
\end{array}
</code>
</p>

<p>models that evolve on a phylogenetic tree.
</p>
<p>This software comes AS IS in the hope that it will be useful WITHOUT ANY WARRANTY, 
NOT even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
Please understand that there may still be bugs and errors. Use it at your own risk. 
We take no responsibility for any errors or omissions in this package or for any misfortune 
that may befall you or others as a result of its use. Please send comments and report 
bugs to Krzysztof Bartoszek at krzbar@protonmail.ch .
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mvSLOUCH</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.7.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-11-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package allows for  maximum likelihood estimation, simulation and study of properties 
of multivariate Brownian motion 
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}dX(t) &amp; = &amp; \Sigma dB(t),\end{array}</code>
</p>

<p>OU </p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}dY(t) &amp; = &amp; -A(Y(t)-\Psi(t))dt + \Sigma dB(t)\end{array}</code>
</p>

<p>and OUBM  
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
dY(t) &amp; = &amp; -A(Y(t)-\Psi(t)- A^{-1}BX(t))dt + \Sigma_{yy} dB(t) \\ dX(t) &amp; = &amp; \Sigma_{xx} dB(t)
\end{array}
</code>
</p>

<p>models that evolve on a phylogenetic tree.
</p>
<p>The estimation functions are <code>BrownianMotionModel</code>, <code>ouchModel</code> (OUOU) and 
<code>mvslouchModel</code> (mvOUBM). They rely on a combination of least squares and numerical 
optimization techniques. A wrapper function for all of them is <code>estimate.evolutionary.model</code>, 
it tries all three models with different matrix parameter classes and then returns the best model 
based on the AICc.
</p>
<p>The simulation functions are simulBMProcPhylTree, simulOUCHProcPhylTree, 
simulMVSLOUCHProcPhylTree.
</p>
<p>The phylogeny provided to them should be of the <code>phylo</code> (package <span class="pkg">ape</span>) format.
</p>
<p>The package uses the functions <code>.sym.par()</code> and <code>.sym.unpar()</code> from the 
<span class="pkg">ouch</span> package to parametrize symmetric matrices. 
</p>
<p>In the case the mvOUBM model with a single response trait the package <span class="pkg">slouch</span> is a 
recommended alternative.
</p>
<p>The package uses <span class="pkg">PCMBase</span>'s <code>PCMLik()</code> function as the engine to do calculate
the likelihood and phylogenetic least squares. If the <span class="pkg">PCMBaseCpp</span> package is 
installed <span class="pkg">mvSLOUCH</span> can take advantage of it to significantly decrease
the running time. The <span class="pkg">PCMBaseCpp</span> package is available from 
<a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek
Maintainer: &lt;krzbar@protonmail.ch&gt;
</p>


<h3>References</h3>

<p>Bartoszek, K. and Fuentes-Gonzalez, J. and Mitov, V. and Pienaar, J. and Piwczynski, M.
and Puchalka, R. and Spalik, K. and Voje, K. L. (2023) 
Model Selection Performance in Phylogenetic Comparative Methods Under Multivariate 
Ornstein-Uhlenbeck Models of Trait Evolution, Systematic Biology 72(2):275-293.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Felsenstein, J. (1985) 
Phylogenies and the comparative method.
American Naturalist 125:1-15.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>
<p>Labra, A., Pienaar, J. &amp; Hansen, T.F. (2009) 
Evolution of thermophysiology in Liolaemus lizards: adaptation, phylogenetic inertia and 
niche tracking. 
The American Naturalist 174:204-220.
</p>
<p>Mitov, V. and Bartoszek, K. and Asimomitis, G. and Stadler, T. (2020) 
Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts
Theoretical Population Biology 131:66-78.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set the version of the random number generator
## so that the results are always reproducible
RNGversion(min(as.character(getRversion()),"3.6.1"))
## Set the random seed, and random number generator
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, 
## e.g. sim.bd.taxa from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed.
## It enhances the phylo object with multiple additional fields, e.g.,
## the lineage for each tip, that are used by subsequent mvSLOUCH functions.
phyltree&lt;-phyltree_paths(phyltree)

## Define a vector of regimes. There are two of them: small and large;
## their layout is random.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the different models.
### There is no particular meaning attached to these parameters.
### BM parameters
BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))
### OUOU parameters
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),
"large"=c(-1,1,0.5)),Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))
### OUBM parameters
OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))

### Now simulate the data under 3D BM, OUOU and OUBM (the third variable is the
### BM one) models of evolution.
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
### extract just the values at the tips of the phylogeny
BMdata&lt;-BMdata[phyltree$tip.label,,drop=FALSE]
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
### extract just the values at the tips of the phylogeny
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
### extract just the values at the tips of the phylogeny
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

### Recover the parameters of the SDEs.
### Recover under the BM model.
BMestim&lt;-BrownianMotionModel(phyltree,BMdata)
### reset to the original version of the random number generator.
RNGversion(as.character(getRversion()))
## Not run:  
### It takes too long to run this from this point.
### We do not reduce the number of iterations of the optimier
### (as we did in other manual page examples, so the running
### times will be as with default settings.
### Recover under the OUOU model.
OUOUestim&lt;-ouchModel(phyltree,OUOUdata,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive")
### Recover under the OUBM model.
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,2,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive")

### Usage of the wrapper function that allows for estimation under multiple 
### models in one call, here we use the default collection of models offered 
### by mvSLOUCH. This includes BM, a number of OUOU and OUBM models.
### For data simulated under BM.
estimResultsBM&lt;-estimate.evolutionary.model(phyltree,BMdata,regimes=NULL,
root.regime=NULL,M.error=NULL,repeats=3,model.setups=NULL,predictors=c(3),
kY=2,doPrint=TRUE)
### For data simulated under OUOU.
estimResultsOUOU&lt;-estimate.evolutionary.model(phyltree,OUOUdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=3,model.setups=NULL,predictors=c(3),
kY=2,doPrint=TRUE)
### For data simulated under OUBM.
estimResultsOUBM&lt;-estimate.evolutionary.model(phyltree,OUBMdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=3,model.setups=NULL,predictors=c(3),
kY=2,doPrint=TRUE)
## In the wrapper function the resulting best found model parameters are in
## estimResultsBM$BestModel$ParamsInModel
## estimResultsOUOU$BestModel$ParamsInModel
## estimResultsOUBM$BestModel$ParamsInModel

### Summarize the best found models.
### Under the BM model for BM data. One needs to check whether the 
### model in BMestim$ParamsInModel corresponds to a BM model (here it does).
BM.summary&lt;-SummarizeBM(phyltree,BMdata,BMestim$ParamsInModel,t=c(1),
dof=BMestim$ParamSummary$dof)
### Under the OUOU model for OUOU data. One needs to check whether the 
### model in OUOUestim$ParamsInModel corresponds to an OUOU model (here it does).
OUOU.summary&lt;-SummarizeOUCH(phyltree,OUOUdata,OUOUestim$FinalFound$ParamsInModel,
regimes,t=c(1),dof=OUOUestim$FinalFound$ParamSummary$dof)
### Under the OUBM model for OUBM data. One needs to check whether the 
### model in OUBMestim$ParamsInModel corresponds to a OUBM model (here it does).
OUBM.summary&lt;-SummarizeMVSLOUCH(phyltree,OUBMdata,OUBMestim$FinalFound$ParamsInModel,
regimes,t=c(1),dof=OUBMestim$FinalFound$ParamSummary$dof)


### Now run the parametric bootstrap to obtain confidence intervals for some parameters.
### For the BM model, we want CIs for the ancestral state, and the "sqaure" of the 
### diffusion (evolutionary rate) matrix. The number of bootstrap replicates
### is very small, 5 (to reduce running times). In reality it should be much more, e.g.,
### 100 or more if the computational budget allows.
BMbootstrap&lt;-parametric.bootstrap(estimated.model=BMestim,phyltree=phyltree,
values.to.bootstrap=c("vX0","StS"),M.error=NULL,numboot=5)
### For the OUOU model, we want a CI for the evolutionary regression coefficient vector.
### The number of bootstrap replicates is very small, 5 (to reduce running times). 
### In reality it should be much more, e.g., 100 or more if the 
### computational budget allows.
OUOUbootstrap&lt;-parametric.bootstrap(estimated.model=estimResultsOUOU,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression"),regimes=regimes,root.regime="small",
M.error=NULL,predictors=c(3),kY=NULL,numboot=5,Atype=NULL,Syytype=NULL,diagA=NULL)
### For the OUBM model, we want CIs for the evolutionary and optimal regression 
### coefficient vectors. The number of bootstrap replicates is very small, 
### 5 (to reduce running times). In reality it should be much more, e.g.,
### 100 or more if the computational budget allows.
OUBMbootstrap&lt;-parametric.bootstrap(estimated.model=OUBMestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression","optimal.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=2,
numboot=5,Atype="DecomposablePositive",Syytype="UpperTri",diagA="Positive")

## End(Not run)
</code></pre>

<hr>
<h2 id='BrownianMotionModel'>Estimate parameters under a Brownian motion model of evolution</h2><span id='topic+BrownianMotionModel'></span>

<h3>Description</h3>

<p>The <code>BrownianMotionModel</code> function uses maximum likelihood to fit parameters of a Brownian
motion model evolving on the phylogeny. The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrownianMotionModel(phyltree, mData, predictors = NULL, M.error = NULL, 
min_bl = 0.0003)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BrownianMotionModel_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="BrownianMotionModel_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="BrownianMotionModel_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from
<code>data</code> which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided, then none will be considered to 
be predictors.
</p>
</td></tr>
<tr><td><code id="BrownianMotionModel_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix,
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="BrownianMotionModel_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span> about singularities during the likelihood calculations. 
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>This function estimates the parameters of a multivariate Brownian motion model defined by the SDE,
</p>
<p style="text-align: center;"><code class="reqn">dX(t) = \Sigma dB(t), X(0)=X_{0}</code>
</p>
<p> evolving on a phylogenetic tree. 
</p>
<p>Without measurement error the parameters are obtained analytically via a GLS procedure.
If measurement error is present, then the parameters are optimized over using <code>optim()</code>.
The initial conditions for the optimization are motivated by Bartoszek <code class="reqn">\&amp;</code> Sagitov (2015)'s 
univariate results.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>The <code>phyltree_paths()</code> function enhances the tree for usage by <code>mvSLOUCH</code>. 
Hence, to save time, it is advisable to first do <code>phyltree&lt;-mvSLOUCH::phyltree_paths(phyltree)</code> 
and only then use it with <code>BrownianMotionModel()</code>.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ParamsInModel</code></td>
<td>

<p>A list with estimated model parameters. The elements are <code>vX0</code> : the ancestral trait, and <code>Sxx</code> 
where <code class="reqn">t\Sigma_{xx}\Sigma_{xx}^{T}</code> is the Brownian motion's covariance matrix at time <code>t</code>.
</p>
</td></tr>
<tr><td><code>ParamSummary</code></td>
<td>

<p>A list with summary statistics with elements,
<code>StS</code> the infinitesimal covariance matrix <code class="reqn">\Sigma_{xx}\Sigma_{xx}^{T}</code>,
<code>LogLik</code> the log&ndash;likelihood, <code>dof</code> the degrees of freedom, <code>m2loglik</code> is <code class="reqn">-2</code>log&ndash;likelihood,
<code>aic</code> is the Akaike information criterion, <code>aic.c</code> is the Akaike information criterion corrected for small
sample size, <code>sic</code> is the Schwarz information criterion, <code>bic</code> is the Bayesian information criterion
(which is the same as the Schwarz information criterion) and <code>RSS</code> is the residual sum of squares.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Bartoszek, K. and Sagitov S. (2015) 
A consistent estimator of the evolutionary rate. 
Journal of Theoretical Biology 371:69-78.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.
American Naturalist 164:683-695.
</p>
<p>Felsenstein, J. (1985) 
Phylogenies and the comparative method.
American Naturalist 125:1-15.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Mitov, V. and Bartoszek, K. and Asimomitis, G. and Stadler, T. (2020) 
Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts
Theoretical Population Biology 131:66-78.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="ouch.html#topic+brown">brown</a></code>,<code><a href="mvMORPH.html#topic+mvBM">mvBM</a></code>, <code><a href="PCMBase.html#topic+PCMLik">PCMLik</a></code>,
<code><a href="#topic+SummarizeBM">SummarizeBM</a></code>, <code><a href="#topic+simulBMProcPhylTree">simulBMProcPhylTree</a></code>, <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree  using functions from ape. 
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define Brownian motion parameters to be able to simulate data under 
### the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))

### Now simulate the data.
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
BMdata&lt;-BMdata[phyltree$tip.label,,drop=FALSE]

### Recover the parameters of the Brownian motion.
BMestim&lt;-BrownianMotionModel(phyltree,BMdata)

## Not run: 
### And finally obtain bootstrap confidence intervals for some parameters
BMbootstrap&lt;-parametric.bootstrap(estimated.model=BMestim,phyltree=phyltree,
values.to.bootstrap=c("vX0","StS"),M.error=NULL,numboot=2)

## End(Not run)
RNGversion(as.character(getRversion()))
</code></pre>

<hr>
<h2 id='drawPhylProcess'>Plots the realization of a process evolving on a phylogenetic tree</h2><span id='topic+drawPhylProcess'></span>

<h3>Description</h3>

<p>The function takes the output of the simulation functions
and based on it plots the realization of the process on the tree.
Can handle multiple traits, in this case each trait is plotted separately.
The function does draw anything else (like axes) but the realization
of the process. Any additions are up to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawPhylProcess(PhylTraitProcess, vTraitsToPlot=NULL, vColours = "black", 
plotlayout = c(1, 1), additionalfigs = FALSE, modelParams = NULL, 
EvolModel = NULL, xlimits = NULL, ylimits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawPhylProcess_+3A_phyltraitprocess">PhylTraitProcess</code></td>
<td>

<p>The simulated realization of the process, the direct output of one of the package's simulation 
function or a matrix (if <code>fullTrajectory</code> is <code>TRUE</code>).
In the second case the matrix consists of k+1 columns, where k is the number of traits. The first column
are the time instances, the next k the values of the traits at that instance. Since evolution
takes place on a phylogenetic tree - there should be multiple copies of the same time moment, i.e.
one for each branch of the tree.
</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_vtraitstoplot">vTraitsToPlot</code></td>
<td>
<p>A vector providing the column numbers of the traits to plot. If <code>NULL</code>, then all
traits are plotted. The column numbers have to be obtained from the <br /> <code>PhylTraitProcess</code> object,
the matrix <code>$trajectory</code> for each branch. Notice that the first column is time! The same trait
may be plotted multiple times (but a warning will be raised).</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_vcolours">vColours</code></td>
<td>
<p>A vector of colours to be used for each trait. If length is less than the number of 
traits then colours are recycled</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_plotlayout">plotlayout</code></td>
<td>
<p>How many plots per page if more than one trait, i.e. <code>par(mfrow=plotlayout))</code>.</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_additionalfigs">additionalfigs</code></td>
<td>
<p>Should additional items be plotted on each figure, the ancestral state and 
deterministic, 
<code class="reqn">\Psi</code> when appropriate. If there are many regime levels then only the first column of 
<code class="reqn">\Psi</code> is used.</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_modelparams">modelParams</code></td>
<td>
<p>List of model parameters.</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_evolmodel">EvolModel</code></td>
<td>
<p>The evolutionary model.</p>
</td></tr>
<tr><td><code id="drawPhylProcess_+3A_xlimits">xlimits</code></td>
<td>
<p>The x limits of the plot. Can be useful to fix if one wants to have a number of graphs
on the same scale. This can be either a vector of length 2 (minimum and maximum value of the x-axis),
or a list of length equalling the number of traits with each entry being a vector of length 2 or 
a matrix with two columns and rows equalling the number of traits. If not provided then the value
is just the minimum and maximum from the data.</p>
</td></tr> 
<tr><td><code id="drawPhylProcess_+3A_ylimits">ylimits</code></td>
<td>
<p>The y limits of the plot. Can be useful to fix if one wants to have a number of graphs
on the same scale. This can be either a vector of length 2 (minimum and maximum value of the x-axis),
or a list of length equalling the number of traits with each entry being a vector of length 2 or 
a matrix with two columns and rows equalling the number of traits. If not provided then the value
is just the minimum and maximum from the data.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a meaningless NA value.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(3)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
#regimes&lt;-c("small","small","large","small","small","large","large","large")
#regimes&lt;-c("small","small","large","small","small","large")
regimes&lt;-c("small","small","large","small")

### Define SDE parameters to be able to simulate data under the OUOU model.
## 3D model
## OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
## A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),
## "large"=c(-1,1,0.5)),Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

## 2D model for speed on CRAN
OUOUparameters&lt;-list(vY0=matrix(c(1,-1),nrow=2,ncol=1),
A=rbind(c(9,0),c(0,5)),mPsi=cbind("small"=c(1,-1),
"large"=c(-1,1)),Syy=rbind(c(1,0.25),c(0,1)))


### Now simulate the data keeping the whole trajectory
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL,fullTrajectory=TRUE)
drawPhylProcess(PhylTraitProcess=OUOUdata,plotlayout=c(1,3))
RNGversion(as.character(getRversion()))

</code></pre>

<hr>
<h2 id='estimate.evolutionary.model'>
Wrapper function to find best (out of BM, OU, OUOU, OUBM) fitting evolutionary model and 
estimate its parameters.
</h2><span id='topic+estimate.evolutionary.model'></span>

<h3>Description</h3>

<p>The <code>estimate.evolutionary.model</code> function calls the
<code>BrownianMotionModel</code>,  <code>ouchModel</code> and <code>mvslouchModel</code>
functions with different classes of evolutionary model parameters.
It then compares the resulting estimates by the AICc (or BIC if AICc fails) and 
returns the best overall model. The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.evolutionary.model(phyltree, mData, regimes = NULL, 
root.regime = NULL, M.error = NULL, repeats = 5, model.setups = NULL, 
predictors = NULL, kY = NULL, doPrint = FALSE, pESS=NULL, 
estimate.root.state=FALSE, min_bl = 0.0003, maxiter=c(10,50,100))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.evolutionary.model_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>.If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the root's daughter lineages and is the most frequent one in the <code>regimes</code> vector. If more
than one regime has the same maximum frequency, then alphabetically first one of the maximum ones
is taken.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_repeats">repeats</code></td>
<td>

<p>How many starting points for the numerical maximum likelihood procedure should be tried for 
each model setup. On the first repeat for OUOU and OUBM modes the functions takes as the starting
point (for <code>A</code> and <code>Syy</code>) values based on the sample covariance matrix estimate, 
motivated by Bartoszek <code class="reqn">\&amp;</code> Sagitov (2015)'s univariate results.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_model.setups">model.setups</code></td>
<td>

<p>What models to try when searching for the best evolutionary model. 
This field may remain <code>NULL</code>, in this situation the function
generates using 
</p>
<p><code>.generate.basic.model.setups()</code> a basic list of models.
Allowed values are 
</p>

<dl>
<dt><code>"basic"</code> </dt><dd><p>A basic list of models to try out is generated, defined using 
</p>
<p><code>.generate.basic.model.setups()</code>. This list should be usually enough.</p>
</dd>
<dt><code>"fundamental"</code> </dt><dd><p>A slightly extended list of models to try out is generated, 
defined using <code>.generate.fund.model.setups()</code>. Compared to <code>"basic"</code> a few more 
models are added.</p>
</dd>
<dt><code>"extended"</code> </dt><dd><p>An extension of the <code>"fundamental"</code> list of models to try out. 
Defined using <code>.generate.ext.model.setups()</code> which at the moment calls <br />
<code>generate.model.setups()</code>.</p>
</dd>
<dt><code>"all"</code> </dt><dd><p>All possible models are generated, using 
<br /> <code>.generate.all.model.setups()</code>. Running it will take an intolerable <br /> amount of time.</p>
</dd>
</dl>

<p>Alternatively the user is also free to provide their own list of models in this variable. 
Each element of the list is a list with fields.
</p>

<dl>
<dt><code>evolmodel</code> </dt><dd><p>The evolutionary model, it may take one of the three values <code>"bm"</code> 
(Brownian motion model), <code>"ouch"</code> (OUOU model), <code>"mvslouch"</code> <br /> (OUBM model).</p>
</dd>
<dt><code>Atype</code> </dt><dd><p>The class of the <code>A</code> matrix, ignored if <code>evolmodel</code> equals 
<code>"bm"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>, <code>"SymmetricPositiveDefinite"</code>,
<code>"Symmetric"</code>, <code>"DecomposablePositive"</code>, <code>"DecomposableNegative"</code>, <br />
<code>"DecomposableReal"</code>, <code>"Invertible"</code>, <code>"Any"</code>.
</p>
</dd>
<dt><code>Syytype</code> </dt><dd><p>The class of the <code>Syy</code> matrix, ignored if <code>evolmodel</code> equals 
<code>"bm"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>,  <code>"Symmetric"</code>, <code>"Any"</code>. 
</p>
</dd>
<dt><code>diagA</code> </dt><dd><p>Should the diagonal of <code>A</code> be forced to be positive (<code>"Positive"</code>),
negative (<code>"Negative"</code>) or the sign free to vary (<code>NULL</code>). However, setting this to
a non-<code>NULL</code> value when <code>evolmodel</code> is <code>"mvslouch"</code> might be 
(but simulations concerning this are not conclusive) slightly detrimental to the optimization process 
if <code>Atype</code> is <code>"DecomposablePositive"</code>, <code>"DecomposableNegative"</code>, or
<code>"DecomposableReal"</code>. In these cases <code>A</code> is parametrized by its eigendecomposition.
Additional exponentiation of the diagonal, to ensure positivity, could (but this is uncertain)
make the exploration of the likelihood surface more difficult. The user is advised to
also try <code>diag=NULL</code>. In the case of <code>Atype</code> being <code>"SymmetricPositiveDefinite"</code>,
the diagonal is always guaranteed to be positive.
</p>
</dd>
<dt><code>signsA</code> </dt><dd><p>WARNING: ONLY use this if you know what you are doing. Ignored if <code>evolmodel</code> 
equals <code>"bm"</code>. This allows the user to specify which elements of <code>A</code> are to be positive, negative 
or equal to specific values.See <code><a href="#topic+ouchModel">ouchModel</a></code>  and <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for a more specific 
description and important warnings.</p>
</dd>
<dt><code>signsSyy</code> </dt><dd><p>WARNING: ONLY use this if you know what you are doing. Ignored if <code>evolmodel</code> 
equals <code>"bm"</code>. This allows the user to specify which elements of <code>Syy</code> are to be positive, negative 
or equal to specific values. See <code><a href="#topic+ouchModel">ouchModel</a></code>  and <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for a more specific 
description and important warnings.</p>
</dd>
<dt><code>signsB</code> </dt><dd><p>WARNING: ONLY use this if you know what you are doing. Ignored if <code>evolmodel</code> 
does not equals <code>"mvslouch"</code>. This allows the user to specify which elements of <code>B</code> are to be 
positive, negative or equal to specific values. See <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> 
for a more specific description and important warnings.</p>
</dd>
<dt><code>signsmPsi</code> </dt><dd><p>WARNING: ONLY use this if you know what you are doing. Ignored if <code>evolmodel</code> 
equals <code>"bm"</code>. This allows the user to specify which elements of <code>mPsi</code> are to be positive, negative 
or equal to specific values.See <code><a href="#topic+ouchModel">ouchModel</a></code> and <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for a more specific 
description and important warnings.</p>
</dd>
<dt><code>signsvY0</code> </dt><dd><p>WARNING: ONLY use this if you know what you are doing. Ignored if <code>evolmodel</code> 
equals <code>"bm"</code>. This allows the user to specify which elements of <code>vY0</code> are to be positive, negative 
or equal to specific values.See <code><a href="#topic+ouchModel">ouchModel</a></code>  and <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for a more specific 
description and important warnings.</p>
</dd>
<dt>start_point_for_optim</dt><dd>
<p>A named list with starting parameters for of the parameters for be optimized by <code>optim()</code>, currently 
only <code>A</code> and <code>Syy</code> for <br /> <code>evolmodel</code> equalling <code>"ouch"</code> or <code>"mvslouch"</code>. 
One may provide both or only one of them.
Make sure that the parameter is consistent with the other parameter restrictions as no check is done and this 
can result in undefined behaviour. For example one may provide this as (provided dimensions and other
parameter restrictions agree) </p>
<pre>start_point_for_optim=list(A=rbind(c(2,0),(0,4)), 
Syy=rbind(c(1,0.5),c(0,2))).</pre>
</dd>
<dt>parscale</dt><dd>
<p>A vector to calculate the <code>parscale</code> argument for <code>optim</code>. It is a named
vector with 3 entries, e.g. <br /> <code>c("parscale_A"=3,"logparscale_A"=5,"logparscale_other"=1)</code>.
<br /> The entry <code>parscale_A</code> is the scale for entries of the <code>A</code> matrix, <br />
<code>logparscale_A</code> is the scale for entries of the <code>A</code> matrix that are 
optimized over on the logarithmic scale, e.g. if eigenvalues are assumed to be positive,
then optimization is done over <code>log(eigenvalue)</code> for <code>A</code>'s eigendecomposition
and <code>logparscale_other</code> is the scale for entries other then of <code>A</code>
that are done on the logarithmic scale (e.g. <code>Syy</code>'s diagonal, or other entries
indicated as positive via <code>parameter_signs</code>). If not provided (or if a name of the vector
is misspelled), then made equal  to the example value provided above. For other elements, then 
mentioned above, that are optimized over by <code>optim()</code>, <code>1</code> is used for <code>optim()</code>'s 
<code>parscale</code>. It is advised that the user experiments with a couple of different values and 
reads <code><a href="stats.html#topic+optim">optim</a></code>'s man page. 
</p>
</dd>
<dt>estimateBmethod</dt><dd><p>Only relevant for the OUBM models (optional), should <code>B</code> be estimated by maximum likelihood 
(default if not provided) value <code>"ML"</code> or generalized least squares (value <code>"GLS"</code>).
</p>
</dd>
</dl>

<p>A minimum example list is <code>list(list(evolmodel="bm"))</code>. The functions that automatically generate
different types of models do NOT use any of the &quot;signs&quot; parameters. Hence, in these models 
all parameters (under the appropriate parametrization) will be free to vary.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from
<code>dfdata</code> which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. 
A vector giving the numbers of the columns from <code>mData</code> matrix which are to be considered predictor ones, 
<em>i.e.</em> conditioned on in the program output. If not provided then in for the OUBM model the columns <code>(kY+1):ncol(mData)</code>, i.e. the 
&quot;BM&quot; ones, are treated as predictors. Otherwise, none will be considered to be predictors.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_ky">kY</code></td>
<td>

<p>Number of &quot;Y&quot; (response) variables, for the OUBM models.
The first <code>kY</code>
columns of <code>mY</code> are the &quot;OU&quot; ones, while the rest the &quot;BM&quot; ones.
In more detail this value determines the number of columns of the <code>mData</code> matrix to treat as response variables (&quot;OU&quot; ones). For example, a 
value of 1 means that only the first column is treated as a response variable, while a value of 3 means the first three 
columns are treated as response variables. Any predictor variables (&quot;BM&quot; ones) the user is interested in setting for a particular model 
should therefore be placed in the final columns of the <code>mData</code> matrix, allowing for selecting select <code>kY</code> columns before 
this as response variables (&quot;OU&quot; ones).
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_doprint">doPrint</code></td>
<td>

<p>Should the function print out information on what it is doing (TRUE) or keep silent 
(default FALSE).
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_pess">pESS</code></td>
<td>

<p>Should the function also find the best model taking into account the phylogenetic effective sample size
and it so what method. If <code>NULL</code>, then do not take this into account. Otherwise one
of <code>"reg"</code> (&quot;regression&quot; effective sample size that takes into account all of the 
correlations between species explicitly),
<code>"mean"</code> (mean value effective sample size <code class="reqn">1^{T}R^{-1}1</code>, where <code class="reqn">R</code> 
is the interspecies correlation matrix),
<code>"MI"</code> (mutual information effective sample size), 
<code>"mvreg"</code>(multivariate version of &quot;regression&quot; effective sample size when each species is 
described by a suite of traits) , 
<code>"mvMI"</code> (multivariate mutual information effective sample size when each species is described by 
a suite of traits) indicating
the way to calculate the pESS. The default (<code>NULL</code>) is not to do any pESS calculations as these will be slow. 
They require the construction of the between-species-between-traits variance covariance matrix and
hence do not fully take advantage of the speed-up offered by <span class="pkg">PCMBase</span>. If <code>pESS="only_calculate"</code>,
then all possible pESS values are calculated but no model selection is done based on them.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_estimate.root.state">estimate.root.state</code></td>
<td>

<p>Should the root state be estimate <code>TRUE</code> (not recommended) or set at the optimum 
<code>FALSE</code> (recommended). Root state estimation is usually unreliable hence
if fossil measurements are available prediction based on them and the estimated
model will probably be more accurate. If there is only one regime, then 
estimation of the root state separately is impossible and will not be allowed.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
Furthermore, <span class="pkg">mvSLOUCH</span> sets all branches in the tree shorter than <code>min_bl</code> to <code>min_bl</code>.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
<tr><td><code id="estimate.evolutionary.model_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations for different components of the estimation
algorithm. A vector of three integers. The first is the number of iterations for phylogenetic
GLS evaluations, i.e. conditional on the other parameters, the regime optima, perhaps <code>B</code>, and perhaps
initial state are estimated by a phylogenetic GLS procedure. After this the other (except of <code>B</code> 
in OUBM model case) parameters are optimized over by <code>optim()</code>. This first
entry controls the number of iterations of this procedure.   The second is the number of iterations inside
the iterated GLS for the OUBM model. In the first step regime optima and <code>B</code> (and perhaps initial state) 
are estimated conditional on the other parameters and current estimate of <code>B</code>, then the estimate of <code>B</code>
is update and the same phylogenetic GLS is repeated (second entry of <code>maxiter</code> number of times).  
Finally, the third is the value of <code>maxiter</code>  passed to <code>optim()</code>, apart from the optimization 
in the Brownian motion and measurement error case.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If the estimation algorithm hits a defective <code>A</code>, then it sets the log-likelihood at
the minimum value and will try to get out of this dip.
</p>
<p>If <code>model.setups</code> is left at the default value the 
function will take a long time to run, as it performs estimation for each model 
(<code>generate.model.setups</code> generates 90 setups) times the value in repeats. 
Therefore if the user has particular hypotheses in mind then it is advisable to
prepare their own list.
If the <code>Syy</code> matrix is assumed to be upper-triangular and the starting conditions
based on Bartoszek <code class="reqn">\&amp;</code> Sagitov (2015)'s results are used then the factorization
of <code class="reqn">\Sigma=\Sigma_{yy} \Sigma_{yy}^{T}</code> into <code class="reqn">\Sigma_{yy}</code> is 
done using the procedure described in 
<a href="https://math.stackexchange.com/questions/2039477/cholesky-decompostion-upper-triangular-or-lower-triangular">https://math.stackexchange.com/questions/2039477/cholesky-decompostion-upper-triangular-or-lower-triangular</a>.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>If AICc fails, then the function will use BIC to select between models. This is extremely 
unlikely essentially only when AICc is infinite, i.e. the model is saturated 
(number of observations equals number of data points).
</p>


<h3>Value</h3>

<p>A list is returned that describes the results of the search. See the help for
<code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code>, <code><a href="#topic+ouchModel">ouchModel</a></code> and
<code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for the description of the lower level entries.
The elements of this list are the following
</p>
<table role = "presentation">
<tr><td><code>BestModel</code></td>
<td>
<p>The resulting best model found. Included are the model parameters, 
a &quot;first-glance&quot; qualitative description of the model, the most important parameters of the 
process (half-lives and regressions in the case of OU models) and what to call to obtain 
standard errors. It takes a long time to obtain them so calculating them is not part of the 
standard procedure.</p>
</td></tr>
<tr><td><code>BestModelESS</code></td>
<td>
<p>Only if <code>pESS</code> was <code>TRUE</code>. The resulting best model found
taking into account the phylogenetic essential sample size. Included are the model parameters, 
a &quot;first-glance&quot; qualitative description of the model, the most important parameters of the 
process (half-lives and regressions in the case of OU models) and what to call to obtain 
bootstrap confidence intervals. It takes a long time to obtain them so calculating them is not part of the 
standard procedure.</p>
</td></tr>
<tr><td><code>testedModels</code></td>
<td>
<p>A list of results for each tried model.</p>
</td></tr>
<tr><td><code>model.setups</code></td>
<td>
<p>A list of models tried.</p>
</td></tr>
<tr><td><code>repeats</code></td>
<td>
<p>How many starting points were tried per model.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>The engine behind the likelihood calculations is called from <span class="pkg">PCMBase</span>.
The <code>slouch</code> package is a recommended alternative if one has a OUBM models and 
only a single response (Y) trait. 
The <code>mvMORPH</code>, <code>ouch</code> and <code>Rphylpars</code> packages consider multivariate OU models 
and looking at them could be helpful.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Ane, C. (2008) 
Analysis of comparative data with hierarchical autocorrelation. 
Annals of Applied Statistics 2:1078-1102.
</p>
<p>Bartoszek, K. (2016)
Phylogenetic effective sample size.
Journal of Theoretical Biology 407:371-386.
</p>
<p>Bartoszek, K. and Fuentes-Gonzalez, J. and Mitov, V. and Pienaar, J. and Piwczynski, M.
and Puchalka, R. and Spalik, K. and Voje, K. L. (2023) 
Model Selection Performance in Phylogenetic Comparative Methods Under Multivariate 
Ornstein-Uhlenbeck Models of Trait Evolution, Systematic Biology 72(2):275-293.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Bartoszek, K. and Sagitov, S. (2015) 
Phylogenetic confidence intervals for the optimal trait value. 
Journal of Applied Probability 52(4):1115-1132.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>
<p>Mitov, V. and Bartoszek, K. and Asimomitis, G. and Stadler, T. (2020) 
Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts
Theoretical Population Biology 131:66-78.
</p>
<p>Xiao, H and Bartoszek, K. and Lio P. (2018)
Multi&ndash;omic analysis of signalling factors in inflammatory comorbidities. 
BMC Bioinformatics, Proceedings from the 12th International BBCC conference 
19:439.  
</p>


<h3>See Also</h3>

<p><code><a href="ouch.html#topic+brown">brown</a></code>, <code><a href="mvMORPH.html#topic+mvBM">mvBM</a></code><code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code>, <code><a href="#topic+SummarizeBM">SummarizeBM</a></code>, 
<code><a href="#topic+simulBMProcPhylTree">simulBMProcPhylTree</a></code>, <code><a href="ouch.html#topic+hansen">hansen</a></code>, <code><a href="mvMORPH.html#topic+mvOU">mvOU</a></code>, <br /> <code><a href="#topic+ouchModel">ouchModel</a></code>, 
<code><a href="#topic+SummarizeOUCH">SummarizeOUCH</a></code>, <code><a href="#topic+simulOUCHProcPhylTree">simulOUCHProcPhylTree</a></code>,
<code>slouch::model.fit</code>, <code><a href="PCMBase.html#topic+PCMLik">PCMLik</a></code>, <br /> <code><a href="#topic+mvslouchModel">mvslouchModel</a></code>,
<code><a href="#topic+SummarizeMVSLOUCH">SummarizeMVSLOUCH</a></code>, <code><a href="#topic+simulMVSLOUCHProcPhylTree">simulMVSLOUCHProcPhylTree</a></code>,<br />  <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(4)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","large","small")

### Define SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

## set up for a trivial, single model setup case (for running time)
## in a real analysis you should carefully choose between what models
## you want to do model selection
model_setups&lt;-list(list(evolmodel="bm"))

### Try to recover the parameters of the OUOU model.
### maxiter here set to minimal working possibility, in reality it should be larger
### e.g. default of c(10,50,100)
estimResults&lt;-estimate.evolutionary.model(phyltree,OUOUdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=1,model.setups=model_setups,predictors=c(3),
kY=2,doPrint=TRUE,pESS=NULL,maxiter=c(1,1,1))

### After this step you can look at the best estimated model and use the
### parametric.bootstrap() function to obtain bootstrap confidence intervals
RNGversion(as.character(getRversion()))

## Not run:  ##It takes too long to run this
## take a less trivial setup
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

## set up for two very simple (for example usage) models to compare between
## in a real analysis you should carefully choose between what models
## you want to do model selection, the default 
## model_setups&lt;-NULL provides a wide selection of models

model_setups&lt;-list(list(evolmodel="bm"),list(evolmodel="ouch",
"Atype"="SingleValueDiagonal","Syytype"="SingleValueDiagonal","diagA"="Positive"))

### Try to recover the parameters of the OUOU model.
estimResults&lt;-estimate.evolutionary.model(phyltree,OUOUdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=3,model.setups=model_setups,predictors=c(3),
kY=2,doPrint=TRUE,pESS=NULL,maxiter=c(10,50,100))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitch.mvsl'>Unordered Fitch parsimony reconstruction of discrete character states</h2><span id='topic+fitch.mvsl'></span>

<h3>Description</h3>

<p>Implements an unordered Fitch parsimony reconstruction of discrete niche variables 
for use in the OU models where optima are modeled on discrete, categorical niche encodings. 
Allows for delayed and accelerated transformations to deal with ambiguities. 
Function was originally the <code>fitch()</code> function from the <span class="pkg">slouch</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitch.mvsl(phyltree, niche, deltran = FALSE, acctran = FALSE, root = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitch.mvsl_+3A_phyltree">phyltree</code></td>
<td>
<p>The phylogenetic tree in <span class="pkg">ape</span> (<code>phylo</code>).
For a phylogeny in <code>phylo</code> format the &quot;standard&quot; <span class="pkg">ape</span> node indexing is assumed: 
for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> and the 
root index <code>n+1</code>.
</p>
</td></tr>
<tr><td><code id="fitch.mvsl_+3A_niche">niche</code></td>
<td>
<p>The specific niche variable in the <span class="pkg">slouch</span> data.frame to be 
reconstructed, entered as data.frame<code>$</code>niche . The order of the niche's regimes
has to correspond to the order of the tip nodes in <code>phyltree</code>. </p>
</td></tr>
<tr><td><code id="fitch.mvsl_+3A_deltran">deltran</code></td>
<td>
<p>Implements a delayed transformation algorithm in order to 
deal with ambiguous nodes</p>
</td></tr>
<tr><td><code id="fitch.mvsl_+3A_acctran">acctran</code></td>
<td>
<p>Implements an accelerated transformation algorithm to deal 
with ambiguous nodes</p>
</td></tr>
<tr><td><code id="fitch.mvsl_+3A_root">root</code></td>
<td>
<p>An optional argument allowing the user to define a character 
state for the root (useful if the root node is ambiguously reconstructed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fitch.mvsl</code> function is meant to be interactive, where the user acts on the advice 
given in the returned messages whilst attempting to reconstruct ancestral states. 
If the root node is ambiguous after an initial reconstruction (a message will be printed to 
the screen if this is the case), this needs to be set by the user using the <code>root = "state"</code> 
argument in the function call. Any remaining ambiguous nodes can then be dealt with by specifying 
<code>deltran</code> or <code>acctran ="TRUE"</code> in the function call 
</p>


<h3>Value</h3>

<p>The <code>fitch.mvsl</code> function returns a list with two or three elements. The first, 
<code>$branch_regimes</code> is a vector of reconstructed character states. Each entry of
the vector corresponds to the respective edge in the <code>$edge</code> field in the provided tree.
Notice that entries correspond to edges and not to nodes. If you require correspondence
with nodes, then you can treat the given edge entry as the value for the node ending the edge.
Actually, this is what the algorithm in the function estimates. 
The second field of the output object, <code>$root_regime</code>s is the regime at the root of the tree.
If the provided tree was a raw <code>phylo</code> object, then the function will also return 
an enhanced version of it (field <code>$phyltree</code>). This is the tree that results from calling
<span class="pkg">mvSLOUCH</span><code>::phyltree_paths(phyltree)</code> on the originally provided tree. This
enhanced version is returns as calculating it is costly and the user might want to re-use
it in some downstream analysis with <span class="pkg">mvSLOUCH</span>. All <span class="pkg">mvSLOUCH</span> user-level functions
first enhance the provided phylogeny by <span class="pkg">mvSLOUCH</span><code>::phyltree_paths()</code>, but they
first check if it is not already enhanced. 
</p>


<h3>Author(s)</h3>

<p>Jason Pienaar <a href="mailto:jasonpienaar@gmail.com">jasonpienaar@gmail.com</a></p>


<h3>References</h3>

 
<p>Fitch, M.W. (1971) Defining the course of Evolution: Minimum change for a specific tree topology. 
<em>Systematic Zoology</em> <b>20</b>:406&ndash;416.
</p>
<p>Swofford, D. L. and W.P. Maddison (1987) Reconstructing ancestral character states under 
Wagner parsimony. <em>Mathematical Biosciences</em> <b>87</b>: 199&ndash;229. 
</p>


<h3>See Also</h3>

<p><code>slouch::fitch</code>, <code>slouch::slouchtree.plot</code>, <code>slouch::model.fit</code>, 
<code>slouch::ouch2slouch</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
phyltree&lt;-ape::rtree(5)

regimes&lt;-c("A","B","B","C","C")
regimesFitch&lt;-fitch.mvsl(phyltree,regimes,root=1,deltran=TRUE)
RNGversion(as.character(getRversion()))
</code></pre>

<hr>
<h2 id='generate.model.setups'>Generate a list of model setups for the function
<code><a href="#topic+estimate.evolutionary.model">estimate.evolutionary.model</a></code>.
</h2><span id='topic+generate.model.setups'></span>

<h3>Description</h3>

<p>The function generates a list of models that will be used by the 
function <br /> <code><a href="#topic+estimate.evolutionary.model">estimate.evolutionary.model</a></code>. A minimum
example list will be <code>list(list(evolmodel="bm"))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.model.setups()
</code></pre>


<h3>Details</h3>

<p>The function should really be a hidden one but is left available for the user as an
example how such a list of models should be generated.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If <code>A</code> is defective, then the output will be erroneous.
</p>
<p>None of the &quot;signs&quot; options for the model is generated, see the description of 
<code>mvslouchModel</code> and <code>ouchModel</code>.
</p>


<h3>Value</h3>

<p>A list with different models is returned. Each element of the list is a list with the following 
fields.
</p>

<dl>
<dt><code>evolmodel</code> </dt><dd><p>The evolutionary model, it may take one of the three values <code>"BM"</code> 
(Brownian motion model), <code>"ouch"</code> (OUOU model), <code>"mvslouch"</code> (OUBM model).</p>
</dd>
<dt><code>Atype</code> </dt><dd><p>The class of the <code>A</code> matrix, ignored if <code>evolmodel</code> equals 
<code>"BM"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>, <code>"SymmetricPositiveDefinite"</code>,
<code>"Symmetric"</code>, <code>"DecomposablePositive"</code>, <br /> <code>"DecomposableNegative"</code>, 
<code>"DecomposableReal"</code>, <code>"Invertible"</code>,  <code>"TwoByTwo"</code>, <code>"Any"</code>.
</p>
</dd>
<dt><code>Syytype</code> </dt><dd><p>The class of the <code>A</code> matrix, ignored if <code>evolmodel</code> equals 
<code>"BM"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>,  <code>"Symmetric"</code>, <code>"Any"</code>. 
</p>
</dd>
<dt><code>diagA</code> </dt><dd><p>Should the diagonal of <code>A</code> be forced to be positive (<code>TRUE</code>),
negative (<code>FALSE</code>) or the sign free to vary (<code>NULL</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.evolutionary.model">estimate.evolutionary.model</a></code>, <code><a href="#topic+mvslouchModel">mvslouchModel</a></code>, <code><a href="#topic+ouchModel">ouchModel</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_setups&lt;-generate.model.setups()
</code></pre>

<hr>
<h2 id='mvSLOUCH-internal'>Internal mvSLOUCH objects</h2><span id='topic+.ape2slouch.mvsl'></span><span id='topic+.beginEstimationParams'></span><span id='topic+.bm.estim'></span><span id='topic+.bm.phyl.cov'></span><span id='topic+.bm.sim.est'></span><span id='topic+.bm.simulate'></span><span id='topic+.boot.cleanup'></span><span id='topic+.boot.extract'></span><span id='topic+.boot.extract.model.components'></span><span id='topic+.boot.getval'></span><span id='topic+.calc_species_covariance'></span><span id='topic+.calc_species_mean'></span><span id='topic+.calc.cov.bm.mv'></span><span id='topic+.calc.cov.ouch.mv'></span><span id='topic+.calc.cov.slouch.mv'></span><span id='topic+.calc.exptA'></span><span id='topic+.calc.exptA.2dim'></span><span id='topic+.calc.integral.evAStevA'></span><span id='topic+.calc.integral.evAStevA.2dim'></span><span id='topic+.calc.mean.bm.mv'></span><span id='topic+.calc.mean.ouch.mv'></span><span id='topic+.calc.mean.slouch.mv'></span><span id='topic+.calc.phyl.cov'></span><span id='topic+.calc.phyl.halflife'></span><span id='topic+.calc.phyl.LogLik.traits'></span><span id='topic+.calc.vec.dist'></span><span id='topic+.calcCI'></span><span id='topic+.calcESSanalytical'></span><span id='topic+.calcESSsim'></span><span id='topic+.calculate_Tree_dists_forCovariance'></span><span id='topic+.CalcVlq'></span><span id='topic+.CalcVlq2'></span><span id='topic+.CalcVlqStat'></span><span id='topic+.callPCMBase_mvlik'></span><span id='topic+.changeSigmatoSyy'></span><span id='topic+.check_is_better'></span><span id='topic+.CheckSanityRegimes'></span><span id='topic+.cleanUpModelParams'></span><span id='topic+.col.rot'></span><span id='topic+.correct_npar0'></span><span id='topic+.correct_for_diagonalSigns_parscale'></span><span id='topic+.correct_phylGLS_response_by_intercept'></span><span id='topic+.correct.names'></span><span id='topic+.createMeasurementError'></span><span id='topic+.createRegimes'></span><span id='topic+.createStartPointsASyyB'></span><span id='topic+.decompEigenA.S'></span><span id='topic+.describe.best.model'></span><span id='topic+.design_matrix_bm'></span><span id='topic+.design_matrix_construction'></span><span id='topic+.design_matrix_mvslouch'></span><span id='topic+.design_matrix_ouch'></span><span id='topic+.detV'></span><span id='topic+.do_phylGLSestimation'></span><span id='topic+.draw.bm'></span><span id='topic+.draw.mvslouch'></span><span id='topic+.draw.ouch'></span><span id='topic+.drawOneLineage'></span><span id='topic+.dzeta.matrix.t'></span><span id='topic+.dzeta.matrix.t1t2'></span><span id='topic+.dzeta.matrix.t1t2v2'></span><span id='topic+.dzeta.matrix.tv2'></span><span id='topic+.dzetaIJ.matrix'></span><span id='topic+.dzetaKappa.intercept'></span><span id='topic+.dzetaKappa.matrix'></span><span id='topic+.dzetaKappa.matrix.simp.t'></span><span id='topic+.dzetaKappa.matrix2'></span><span id='topic+.dzetaKappa.simp.intercept'></span><span id='topic+.EvaluatePoint'></span><span id='topic+.extract_from_signs'></span><span id='topic+.extract_GLS_results'></span><span id='topic+.extract_GLS_results_bm'></span><span id='topic+.extract_GLS_results_mvslouch'></span><span id='topic+.extract_GLS_results_ouch'></span><span id='topic+.extract.model.key.properties'></span><span id='topic+.generate.all.model.setups'></span><span id='topic+.generate.basic.model.setups'></span><span id='topic+.generate.ext.model.setups'></span><span id='topic+.generate.fund.model.setups'></span><span id='topic+.generate.list.of.model.setups'></span><span id='topic+.generate.model.description'></span><span id='topic+.generate.model.se'></span><span id='topic+.generate.univ.model.setups'></span><span id='topic+.generatenames'></span><span id='topic+.getESScriteria'></span><span id='topic+.getMVSLphylCovMatrix'></span><span id='topic+.get_fullGLSintercept'></span><span id='topic+.get_fullGLSintercept_mvslouch'></span><span id='topic+.getMVSLproc_size'></span><span id='topic+.givens.mult.M'></span><span id='topic+.givens.real'></span><span id='topic+.glsgc.estim'></span><span id='topic+.InitialRegimeSetup'></span><span id='topic+.internal_BrownianMotionModel'></span><span id='topic+.internal_mvslouchModel'></span><span id='topic+.internal_ouchModel'></span><span id='topic+.inv.rho.givens.real'></span><span id='topic+.is0_Merror'></span><span id='topic+.Kappa.matrix'></span><span id='topic+.Kappa.matrix.NA'></span><span id='topic+.M.mult.givens'></span><span id='topic+.make.states.mvsl'></span><span id='topic+.maxlik.estim'></span><span id='topic+.MinusPhylLogLikFunc'></span><span id='topic+.MinusPhylLogLikFuncMVslouch'></span><span id='topic+.MinusPhylLogLikFuncouch'></span><span id='topic+.ModelSetupPCMBase'></span><span id='topic+.mvslouch_to_ouch_model'></span><span id='topic+.mvslouch.phyl.cov'></span><span id='topic+.mvslouch.simulate'></span><span id='topic+.norm.max'></span><span id='topic+.num.inv.transform.positive'></span><span id='topic+.num.transform.positive'></span><span id='topic+.oubm.sim.est'></span><span id='topic+.ouch.phyl.cov'></span><span id='topic+.ouch.simulate'></span><span id='topic+.ouch2slouch.mvsl'></span><span id='topic+.ouou.sim.est'></span><span id='topic+.OUtoBM_pcmbase_model_box'></span><span id='topic+.packageName'></span><span id='topic+.par_transform_withPCMBase'></span><span id='topic+.par.inv.transform'></span><span id='topic+.par.inv.transform.decomp.matrix'></span><span id='topic+.par.inv.transform.decomp.neg.real.matrix'></span><span id='topic+.par.inv.transform.decomp.pos.real.matrix'></span><span id='topic+.par.inv.transform.decomp.real.matrix'></span><span id='topic+.par.inv.transform.decomp.sym.matrix'></span><span id='topic+.par.inv.transform.invert.matrix'></span><span id='topic+.par.inv.transform.invert.qr.matrix'></span><span id='topic+.par.inv.transform.invert.svd.matrix'></span><span id='topic+.par.inv.transform.lowertri.matrix'></span><span id='topic+.par.inv.transform.orth.matrix.cayley'></span><span id='topic+.par.inv.transform.orth.matrix.givens'></span><span id='topic+.par.inv.transform.symmetric.matrix'></span><span id='topic+.par.inv.transform.twobytwo.matrix'></span><span id='topic+.par.inv.transform.uppertri.matrix'></span><span id='topic+.par.transform'></span><span id='topic+.par.transform.decomp.matrix'></span><span id='topic+.par.transform.decomp.neg.real.matrix'></span><span id='topic+.par.transform.decomp.pos.real.matrix'></span><span id='topic+.par.transform.decomp.real.matrix'></span><span id='topic+.par.transform.decomp.sym.matrix'></span><span id='topic+.par.transform.invert.matrix'></span><span id='topic+.par.transform.invert.qr.matrix'></span><span id='topic+.par.transform.invert.svd.matrix'></span><span id='topic+.par.transform.lowertri.matrix'></span><span id='topic+.par.transform.orth.matrix.cayley'></span><span id='topic+.par.transform.orth.matrix.givens'></span><span id='topic+.par.transform.symmetric.matrix'></span><span id='topic+.par.transform.twobytwo.matrix'></span><span id='topic+.par.transform.uppertri.matrix'></span><span id='topic+.Params.summary'></span><span id='topic+.params.summary.bm'></span><span id='topic+.params.summary.mvslouch'></span><span id='topic+.params.summary.ouch'></span><span id='topic+.pcmbaseDphylGaussian_RSS'></span><span id='topic+.pcmbaseDphylOU_GLS'></span><span id='topic+.PhyloSDEestim'></span><span id='topic+.phyltree_remove_path_fields'></span><span id='topic+.phyltree_remove_tips'></span><span id='topic+.postproc_estres'></span><span id='topic+.return_best_model'></span><span id='topic+.row.rot'></span><span id='topic+.set_1var_pcmbase_model_box'></span><span id='topic+.set_mean0_pcmbase_model_box'></span><span id='topic+.set.estimparams'></span><span id='topic+.set.maxiter'></span><span id='topic+.set.paramatrizationnames'></span><span id='topic+.set_parscale'></span><span id='topic+.set.tol'></span><span id='topic+.simulVasicekProcPhylTree'></span><span id='topic+.SummarizeFullPoint'></span><span id='topic+.sym.par'></span><span id='topic+.sym.unpar'></span><span id='topic+.update_pcmbase_box_params'></span><span id='topic+.update_pcmbase_box_params_bm'></span><span id='topic+.update_pcmbase_box_params_mvslouch'></span><span id='topic+.update_pcmbase_box_params_ouch'></span><span id='topic+.internal_phyltree_paths_BL'></span><span id='topic+.check_input_trait_data'></span><span id='topic+.is_det0'></span><span id='topic+.my_cov2cor'></span><span id='topic+.my_stop'></span><span id='topic+.my_message'></span><span id='topic+.my_warning'></span><span id='topic+.set_sing_bl_threshold'></span><span id='topic+.my_chol'></span><span id='topic+.set_pcmbase_model_box_X0'></span><span id='topic+.matrixcalc_is.diagonal.matrix'></span><span id='topic+.matrixcalc_is.positive.definite'></span><span id='topic+.matrixcalc_is.positive.semi.definite'></span><span id='topic+.matrixcalc_is.singular.matrix'></span><span id='topic+.matrixcalc_is.square.matrix'></span><span id='topic+.matrixcalc_is.symmetric.matrix'></span><span id='topic+.calc.phyl.mean'></span><span id='topic+.bm.phyl.mean'></span><span id='topic+.ouch.phyl.mean'></span><span id='topic+.mvslouch.phyl.mean'></span><span id='topic+.get_phyl_mean'></span><span id='topic+.OUphylreg_internal'></span><span id='topic+.id_evolmodel'></span><span id='topic+.f_warningsA'></span>

<h3>Description</h3>

<p>Internal mvSLOUCH objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user. They are located in the code files as follows
.ape2slouch.mvsl: trees2slouch.mvsl.R
.beginEstimationParams: modelparams.R
.bm.estim: estimBM.R
.bm.phyl.cov: sdecovariancephyl.R
.bm.sim.est: bootstrap.R
.bm.simulate: simulVasicekproc.R
.boot.cleanup: bootstrap.R
.boot.extract: bootstrap.R
.boot.extract.model.components: bootstrap.R
.boot.getval: bootstrap.R
.calc_species_covariance: sdemoments.R
.calc_species_mean: sdemoments.R
.calc.cov.bm.mv: sdemoments.R
.calc.cov.ouch.mv: sdemoments.R
.calc.cov.slouch.mv: sdemoments.R
.calc.exptA: matrixexps.R
.calc.exptA.2dim: matrixexps.R
.calc.integral.evAStevA: matrixexps.R
.calc.integral.evAStevA.2dim: matrixexps.R
.calc.mean.bm.mv: sdemoments.R
.calc.mean.ouch.mv: sdemoments.R
.calc.mean.slouch.mv: sdemoments.R
.calc.phyl.cov: sdecovariancephyl.R
.calc.phyl.halflife: modelparamssummary.R
.calc.phyl.LogLik.traits: loglik.R
.calc.vec.dist: phylgls.R
.calcCI: ci.R
.calcESSanalytical: getESS.R
.calcESSsim: getESS.R
.calculate_Tree_dists_forCovariance: getESS.R
.CalcVlq: precalcs.R
.CalcVlq2: precalcs.R
.CalcVlqStat: precalcs.R
.callPCMBase_mvlik: loglik.R
.changeSigmatoSyy: evolmodelest.R
.CheckSanityRegimes: regimes.R
.check_is_better: evolmodelest.R
.cleanUpModelParams: modelparamssummary.R
.col.rot: matrixparametrizations.R
.correct_npar0: modelparamssummary.R
.correct_for_diagonalSigns_parscale: PhyloSDEestim.R
.correct_phylGLS_response_by_intercept: phylgls.R
.correct.names: PhyloSDEestim.R
.createMeasurementError: PhyloSDEestim.R
.createRegimes: regimes.R
.createStartPointsASyyB: evolmodelest.R
.decompEigenA.S: precalcs.R
.describe.best.model: evolmodelest.R
.design_matrix_bm: phylgls.R
.design_matrix_construction: phylgls.R
.design_matrix_mvslouch: phylgls.R
.design_matrix_ouch: phylgls.R
.detV: phylgls.R
.do_phylGLSestimation: phylgls.R
.draw.bm: simulVasicekproc.R
.draw.mvslouch: simulVasicekproc.R
.draw.ouch: simulVasicekproc.R
.drawOneLineage: simulVasicekproc.R
.dzeta.matrix.t: precalcs.R
.dzeta.matrix.t1t2: precalcs.R
.dzeta.matrix.t1t2v2: precalcs.R
.dzeta.matrix.tv2: precalcs.R
.dzetaIJ.matrix: precalcs.R
.dzetaKappa.intercept: precalcs.R
.dzetaKappa.matrix: precalcs.R
.dzetaKappa.matrix.simp.t: precalcs.R
.dzetaKappa.matrix2: precalcs.R
.dzetaKappa.simp.intercept: precalcs.R
.EvaluatePoint: modelparams.R
.extract_from_signs: phylgls.R
.extract_GLS_results: phylgls.R
.extract_GLS_results_bm: phylgls.R
.extract_GLS_results_mvslouch: phylgls.R
.extract_GLS_results_ouch: phylgls.R
.extract.model.key.properties: evolmodelest.R
.generate.all.model.setups: evolmodelest.R
.generate.basic.model.setups: evolmodelest.R
.generate.ext.model.setups: evolmodelest.R
.generate.fund.model.setups: evolmodelest.R
.generate.list.of.model.setups: evolmodelest.R
.generate.model.description: evolmodelest.R
.generate.model.se: evolmodelest.R
.generate.univ.model.setups: evolmodelest.R
.generatenames: PhyloSDEestim.R
.getESScriteria: getESS.R
.getMVSLphylCovMatrix: getESS.R
.getMVSLproc_size: getESS.R
.get_fullGLSintercept: phylgls.R
.get_fullGLSintercept_mvslouch: phylgls.R
.givens.mult.M: matrixparametrizations.R
.givens.real: matrixparametrizations.R
.glsgc.estim: estimGLSGC.R
.InitialRegimeSetup: regimes.R
.internal_BrownianMotionModel: wrappers.R
.internal_mvslouchModel: wrappers.R
.internal_ouchModel: wrappers.R
.inv.rho.givens.real: matrixparametrizations.R
.is0_Merror: estimBM.R
.Kappa.matrix: precalcs.R
.Kappa.matrix.NA: precalcs.R
.M.mult.givens: matrixparametrizations.R
.make.states.mvsl: make.states.mvsl.R
.maxlik.estim: estimMAXLIK.R
.MinusPhylLogLikFunc: loglik.R
.MinusPhylLogLikFuncMVslouch: loglik.R
.MinusPhylLogLikFuncouch: loglik.R
.ModelSetupPCMBase: regimes.R
.mvslouch_to_ouch_model: modelparamstransform.R
.mvslouch.phyl.cov: sdecovariancephyl.R
.mvslouch.simulate: simulVasicekproc.R
.norm.max: modelparamssummary.R
.num.inv.transform.positive: matrixparametrizations.R
.num.transform.positive: matrixparametrizations.R
.oubm.sim.est: bootstrap.R
.ouch.phyl.cov: sdecovariancephyl.R
.ouch.simulate: simulVasicekproc.R
.ouch2slouch.mvsl: trees2slouch.mvsl.R
.ouou.sim.est: bootstrap.R
.OUtoBM_pcmbase_model_box: estimBM.R
.packageName:                              
.par_transform_withPCMBase: modelparamstransform.R
.par.inv.transform: modelparamstransform.R
.par.inv.transform.decomp.matrix: matrixparametrizations.R
.par.inv.transform.decomp.neg.real.matrix: matrixparametrizations.R
.par.inv.transform.decomp.pos.real.matrix: matrixparametrizations.R
.par.inv.transform.decomp.real.matrix: matrixparametrizations.R
.par.inv.transform.decomp.sym.matrix: matrixparametrizations.R
.par.inv.transform.invert.matrix: matrixparametrizations.R
.par.inv.transform.invert.qr.matrix matrixparametrizations.R
.par.inv.transform.invert.svd.matrix: matrixparametrizations.R
.par.inv.transform.lowertri.matrix: matrixparametrizations.R
.par.inv.transform.orth.matrix.cayley: matrixparametrizations.R
.par.inv.transform.orth.matrix.givens: matrixparametrizations.R
.par.inv.transform.symmetric.matrix: matrixparametrizations.R
.par.inv.transform.twobytwo.matrix: matrixparametrizations.R
.par.inv.transform.uppertri.matrix: matrixparametrizations.R
.par.transform: modelparamstransform.R
.par.transform.decomp.matrix: matrixparametrizations.R
.par.transform.decomp.neg.real.matrix: matrixparametrizations.R
.par.transform.decomp.pos.real.matrix: matrixparametrizations.R
.par.transform.decomp.real.matrix: matrixparametrizations.R
.par.transform.decomp.sym.matrix: matrixparametrizations.R
.par.transform.invert.matrix: matrixparametrizations.R
.par.transform.invert.qr.matrix: matrixparametrizations.R
.par.transform.invert.svd.matrix: matrixparametrizations.R
.par.transform.lowertri.matrix: matrixparametrizations.R
.par.transform.orth.matrix.cayley: matrixparametrizations.R
.par.transform.orth.matrix.givens: matrixparametrizations.R
.par.transform.symmetric.matrix: matrixparametrizations.R
.par.transform.twobytwo.matrix: matrixparametrizations.R
.par.transform.uppertri.matrix: matrixparametrizations.R
.Params.summary: modelparamssummary.R
.params.summary.bm: modelparamssummary.R
.params.summary.mvslouch: modelparamssummary.R
.params.summary.ouch: modelparamssummary.R
.pcmbaseDphylGaussian_RSS: phylgls.R
.pcmbaseDphylOU_GLS: phylgls.R
.PhyloSDEestim: PhyloSDEestim.R
.phyltree_remove_path_fields: phyltree_paths.R
.phyltree_remove_tips: phyltree_paths.R
.postproc_estres: evolmodelest.R
.return_best_model: evolmodelest.R
.row.rot: matrixparametrizations.R
.set_mean0_pcmbase_model_box: phygls.R
.set_1var_pcmbase_model_box: estimBM.R
.set.estimparams: PhyloSDEestim.R
.set.maxiter: PhyloSDEestim.R
.set.paramatrizationnames: PhyloSDEestim.R
.set_parscale: PhyloSDEestim.R
.set.tol: PhyloSDEestim.R
.simulVasicekProcPhylTree: simulVasicekprocphyl.R
.SummarizeFullPoint: modelparamssummary.R
.sym.par: matrixparametrizations.R
.sym.unpar: matrixparametrizations.R
.update_pcmbase_box_params: modelparamstransform.R
.update_pcmbase_box_params_bm: modelparamstransform.R
.update_pcmbase_box_params_mvslouch: modelparamstransform.R
.update_pcmbase_box_params_ouch: modelparamstransform.R
.internal_phyltree_paths_BL: phyltree_paths.R
.check_input_trait_data: PhyloSDEestim.R
.is_det0: matrixexps.R
.my_cov2cor: matrixexps.R
.my_stop: loglik.R
.my_message: loglik.R
.my_warning: loglik.R
.set_sing_bl_threshold: wrappers.R
.my_chol: evolmodelest.R
.set_pcmbase_model_box_X0: estimBM.R
.matrixcalc_is.diagonal.matrix: from_matrixcalc_1_0_3_matrixcalculations.R
.matrixcalc_is.positive.definite: from_matrixcalc_1_0_3_matrixcalculations.R
.matrixcalc_is.positive.semi.definite: from_matrixcalc_1_0_3_matrixcalculations.R
.matrixcalc_is.singular.matrix: from_matrixcalc_1_0_3_matrixcalculations.R
.matrixcalc_is.square.matrix: from_matrixcalc_1_0_3_matrixcalculations.R
.matrixcalc_is.symmetric.matrix: from_matrixcalc_1_0_3_matrixcalculations.R
.calc.phyl.mean: sdemeanphyl.R
.bm.phyl.mean: sdemeanphyl.R
.ouch.phyl.mean: sdemeanphyl.R
.mvslouch.phyl.mean: sdemeanphyl.R
.get_phyl_mean: OUphylregression.R
.OUphylreg_internal: OUphylregression.R
.id_evolmodel: OUphylregression.R
.f_warningsA: wrappers.R
</p>

<hr>
<h2 id='mvslouchModel'>
Estimate parameters under a (multivariate) OUBM model of evolution
</h2><span id='topic+mvslouchModel'></span>

<h3>Description</h3>

<p>The <code>mvslouchModel</code> function uses maximum likelihood to fit parameters of a multivariate 
OUBM model evolving on the phylogeny. The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvslouchModel(phyltree, mData, kY, regimes = NULL, regimes.times = NULL, 
root.regime = NULL, predictors = NULL, M.error = NULL, Atype = "Invertible", 
Syytype = "UpperTri", diagA = "Positive", estimate.root.state=FALSE, 
parameter_signs=NULL, start_point_for_optim = NULL, parscale = NULL, 
min_bl = 0.0003, maxiter = c(10,50,100), estimateBmethod="ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvslouchModel_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_ky">kY</code></td>
<td>
<p>Number of &quot;Y&quot; (response) variables.
The first <code>kY</code>
columns of <code>mY</code> are the &quot;OU&quot; ones, while the rest the &quot;BM&quot; ones.
In more detail this value determines the number of columns of the <code>mData</code> matrix to treat as response variables (&quot;OU&quot; ones). For example, a 
value of 1 means that only the first column is treated as a response variable, while a value of 3 means the first three 
columns are treated as response variables. Any predictor variables (&quot;BM&quot; ones) the user is interested in setting for a particular model 
should therefore be placed in the final columns of the <code>mData</code> matrix, allowing for selecting select <code>kY</code> columns before 
this as response variables (&quot;OU&quot; ones).
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with 0 and ends with the current time 
of the species. In between are the times where the regimes (niches) changed. If <code>NULL</code> 
then each branch is considered to be a regime.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the root's daughter lineages and is the most frequent one in the <code>regimes</code> vector. If more
than one regime has the same maximum frequency, then alphabetically first one of the maximum ones
is taken.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from <code>mData</code> matrix which are to be considered predictor ones, 
<em>i.e.</em> conditioned on in the program output. If not provided then columns <code>(kY+1):ncol(mData)</code>, i.e. the 
&quot;BM&quot; ones, are treated as predictors.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_atype">Atype</code></td>
<td>

<p>What class does the A matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>"Symmetric"</code>, <code>"SymmetricPositiveDefinite"</code>, <br />
<code>"DecomposablePositive"</code>,  <code>"DecomposableNegative"</code>, <br />
<code>"DecomposableReal"</code>, <code>"Invertible"</code>, <code>"TwoByTwo"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_syytype">Syytype</code></td>
<td>

<p>What class does the Syy matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>"Symmetric"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_diaga">diagA</code></td>
<td>

<p>Whether the values on <code>A</code>'s diagonal are to be <code>"Positive"</code>, <code>"Negative"</code> 
or sign allowed to vary, <code>NULL</code>. However, setting this to
a non-<code>NULL</code> value might be (but simulations concerning this are not conclusive) 
slightly detrimental to the optimization process if <code>Atype</code> is
<code>"DecomposablePositive"</code>, <code>"DecomposableNegative"</code>, or
<code>"DecomposableReal"</code>. In these cases <code>A</code> is parametrized by its eigendecomposition.
Additional exponentiation of the diagonal, to ensure positivity, could (but this is uncertain)
make the exploration of the likelihood surface more difficult. The user is advised to
also try <code>diag=NULL</code>. In the case of <code>Atype</code> being <code>"SymmetricPositiveDefinite"</code>,
the diagonal is always guaranteed to be positive.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_estimate.root.state">estimate.root.state</code></td>
<td>

<p>Should the root state be estimate <code>TRUE</code> (not recommended) or set at the optimum 
<code>FALSE</code> (recommended). Root state estimation is usually unreliable hence
if fossil measurements are available prediction based on them and the estimated
model will probably be more accurate. If there is only one regime, then 
estimation of the root state separately is impossible and will not be allowed.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_parameter_signs">parameter_signs</code></td>
<td>

<p>WARNING: ONLY use this option if you understand what you are doing! This option
is still in an experimental stage so some setups might not work (please report).
A list allowing the user to control whether specific entries for each model parameter
should be positive, negative, zero or set to a specific (other) value.  The entries
of the list have to be named, the admissible names are <code>"signsA"</code> (for <code>A</code>
matrix), <code>"signsB"</code> (for <code>B</code> matrix), <code>"signsSyy"</code> (for <code>Syy</code>
matrix) and <code>"signsmPsi"</code> (for <code>mPsi</code> matrix) and <code>"signsvY0"</code> (for <code>vY0</code>
matrix). Any other entry in this list will be ignored. Each entry of the list has to
be a matrix of appropriate size, i.e. of the size of the parameter to which it corresponds.
Inside this matrix the possible values are <code>"+"</code> if the given entry is to be positive,
<code>"-"</code> if the given entry is to be negative, <code>x</code>, where <code>x</code> is a number,
if the entry is to be set to specified value or <code>NA</code> if the entry is to be freely 
estimated. See Details for an example, further description and important warnings! 
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_start_point_for_optim">start_point_for_optim</code></td>
<td>

<p>A name list with starting parameters for of the parameters for be optimized by <code>optim()</code>,
in this case <code>A</code> and <code>Syy</code>. One may provide both or only one of them.
Make sure that the parameter is consistent with the other parameter restrictions
as no check is done and this can result in undefined behaviour.
For example one may provide this as (provided dimensions and other parameter restrictions agree) </p>
<pre>
start_point_for_optim=list(A=rbind(c(2,0),(0,4)), 
Syy=rbind(c(1,0.5),c(0,2))).</pre>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_parscale">parscale</code></td>
<td>

<p>A vector to calculate the <code>parscale</code> argument for <code>optim</code>. It is a named
vector with 3 entries, e.g. <br /> <code>c("parscale_A"=3,"logparscale_A"=5,"logparscale_other"=1)</code>.
The entry <code>parscale_A</code> is the scale for entries of the <code>A</code> matrix,
<code>logparscale_A</code> is the scale for entries of the <code>A</code> matrix that are 
optimized over on the logarithmic scale, e.g. if eigenvalues are assumed to be positive,
then optimization is done over <code>log(eigenvalue)</code> for <code>A</code>'s eigendecomposition
and <code>logparscale_other</code> is the scale for entries other then of <code>A</code>
that are done on the logarithmic scale (e.g. <code>Syy</code>'s diagonal, or other entries
indicated as positive via <code>parameter_signs</code>). If not provided (or if a name of the vector
is misspelled), then made equal  to the example value provided above.  For other elements, then 
mentioned above, that are optimized over by <code>optim()</code>, <code>1</code> is used for <code>optim()</code>'s 
<code>parscale</code>. It is advised that  the user experiments with a couple of different values and 
reads <code><a href="stats.html#topic+optim">optim</a></code>'s  man page.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations for different components of the estimation
algorithm. A vector of three integers. The first is the number of iterations for phylogenetic
GLS evaluations, i.e. conditional on the other parameters, the regime optima, <code>B</code> and perhaps
initial state are estimated by a phylogenetic GLS procedure. After this the other (except of <code>B</code>) 
parameters are optimized over by <code>optim()</code>. This first entry controls the number of iterations of this 
procedure.  The second is the number of iterations inside the iterated GLS. In the first step regime optima 
and <code>B</code> (and perhaps initial state) are estimated conditional on the other parameters and current estimate 
of <code>B</code>, then the estimate of <code>B</code> is update and the same phylogenetic GLS is repeated 
(second entry of <code>maxiter</code> number of times). Finally, the third is the value of <code>maxiter</code>  
passed to <code>optim()</code>, apart from the optimization in the Brownian motion and measurement error case.
</p>
</td></tr>
<tr><td><code id="mvslouchModel_+3A_estimatebmethod">estimateBmethod</code></td>
<td>
<p>Should <code>B</code> be estimated by maximum likelihood (default 
value <code>"ML"</code>) or generalized least squares (value <code>"GLS"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>This function estimates the parameters of the following multivariate SDE,
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rclccl}
dY(t) &amp; = &amp; -A(Y(t)-(\Psi(t)- A^{-1}BX(t)))dt + \Sigma_{yy} dB(t) &amp; Y(0) &amp; = &amp; Y_{0}, 
\\ dX(t) &amp; = &amp; \Sigma_{xx} dB(t) &amp; X(0) &amp; = &amp; X_{0}
\end{array}
</code>
</p>

<p>on a phylogenetic tree. It uses a numerical optimization over <code>A</code> (parametrized by its 
eigenvalues and eigenvectors or its QR decomposition) and <code>S</code> (parametrized by its values) 
and conditional on <code>A</code> and <code>S</code> estimates the values of <code>Psi</code> corresponding
to the different regimes by a GLS estimate. <code>Y(0)</code> is assumed to be equal to 
<code>- solve(A)BX(0)</code> plus the root value of <code>Psi</code>. This assumes that <code>A</code> is invertible. 
If not, then <code>Y(0)</code> will be set at the root value of <code>Psi</code>. This is unless 
<code>estimate.root.state=TRUE</code>, in such a case <code>Y(0)</code> will be estimated by least squares.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If the estimation algorithm hits a defective <code>A</code>, then it sets the log-likelihood at
the minimum value and will try to get out of this dip.
</p>
<p>The function parameter <code>parameter_signs</code> is special in the sense that it can give 
the user great control over the estimation procedure but can also make the output
very inconsistent with what the user provides. If we have two response traits (OU ones)
and two predictor traits (BM ones), then an EXAMPLE setting of this can be:
<br />
<code>parameter_signs=list(signsA=rbind(c("+","-"),c(0,"+")),</code> <br />
<code>signsSyy=rbind(c(NA,0),c(0,NA)), signsB=rbind(c(NA,0),c(0,NA)))</code>. 
This means that <code>A</code> is upper triangular with positive
values on the diagonal and a negative value on the off-diagonal, <code>Syy</code> is diagonal
and <code>B</code> is also diagonal. It is advisable to set now <code>Atype="Any"</code> and
<code>Syytype="Any"</code> (see further description).
</p>
<p>If the given model parameter is to be estimated
by a generalized least squares (currently <code>B</code>, <code>mPsi</code> and <code>vY0</code>), then the 
sign specifications are ignored. However, it is possible to set specific values.
Furthermore, the package does not check (for <code>A</code>
and <code>Syy</code>) if the specifications here agree with the <code>Atype</code>, <code>Syytype</code>
and <code>diagA</code>. The settings in <code>signsA</code> and <code>signsSyy</code> will override
the other settings. Hence, it is up to the user to make sure that the settings of 
<code>signsA</code> and <code>signsSyy</code> are consistent with <code>Atype</code>, <code>Syytype</code>
and <code>diagA</code>. It is advisable to use <code>signsA</code> with <code>"+"</code>
on the diagonal and have <code>diagA=NULL</code>. The diagonal of <code>Syy</code> is forced to
be positive (unless <code>"-"</code> is used on the diagonal of <code>signsSyy</code>
but this is strongly discouraged) so it is advisable to keep <code>NA</code> 
on the diagonal of <code>signsSyy</code> and not put there <code>"+"</code> there.
Hence, in particular using the signs mechanism result in a wrong class of the matrix
<br /> 
(e.g. <code>Atype="SymmetricPositiveDefinite"</code>, but after corrections for the provided entries in
<code>signsA</code> one obtains a non-symmetric <code>A</code> with complex, negative-real-part eigenvalues). 
Lastly, using <code>signsA</code> and <code>signsSyy</code> can result in
a wrong amount of <code>dof</code> and in turn incorrect <code>AICc</code> and <code>BIC</code> values.
What the code does is subtracts the amount of fixed values in <code>signsA</code> and <code>signsSyy</code>
from the amount of free parameters used to estimate <code>A</code> and <code>Syy</code>. For example
if one sets <br /> <code>Atype="SingleValueDiagonal"</code> (estimated by one free parameter) 
but specified two off-diagonal values, then the amount of dofs from <code>A</code> will be <code>-1</code>!!
The ONLY fail-safe way to use this is to set <code>Atype="Any"</code> (if <code>signsA</code> used) and 
<code>Syytype="Any"</code> (if <code>signsSyy</code> used). If using <code>Syytype="Any"</code> and <code>signsSyy</code> 
the it is strongly advisable to set the entries either below or above <code>Syy</code>'s diagonal to <code>0</code>.
The reason is that <code class="reqn">\Sigma_{yy}\Sigma_{yy}^{T}</code> enters the likelihood and not the 
given value of <code class="reqn">\Sigma_{yy}</code>. Hence, having values below (or respectively above) the diagonal
results in an overparameterized model. The package has the option of mixing different matrix types
with specifying values in it but this is only for advanced users who need to dig into the code
to see what the <code>dof</code>'s should be and  if it is possible to find a correspondence between the 
parametrization and settings. If entries of <code>mPsi</code>, <code>vY0</code> and <code>B</code> are pre-specified,
then the <code>dof</code> are correctly adjusted for this. The estimation procedures currently ignore any
pre-specified values for <code>vX0</code> and <code>Sxx</code>!
</p>
<p>The found point is described by a list containing four fields. 
The first field <br /> <code>HeuristicSearchPointFinalFind</code> is the parametrization of the model 
parameters at the considered
point with the value of the log&ndash;likelihood.
The field <code>ParamsInModel</code> is the point estimate of the parameters of the SDE. 
The field <code>ParamSummary</code> are different composite (evaluated at the tree's height) and summary statistics,
The field <code>phylhalflife</code> are the eigenvalues, eigenvectors and phylogenetic half lives
associated with the <code class="reqn">A</code> matrix of, <code>expmtA</code> is <code class="reqn">exp(-A*(tree height))</code>, 
optimal regression is the <code class="reqn">A^{-1}B</code> matrix (if <code class="reqn">A</code> is invertible, otherwise this will not exist),
<code>mPsi.rotated</code> is each of the regime effects multiplied by <code class="reqn">1-\exp(-A*(tree height))</code>, 
<code>cov.matrix</code> is the trait vector covariance matrix at the tree's height, 
<code>corr.matrix</code> is the trait vector correlation matrix at the tree's height, 
<code>conditional.cov.matrix</code> is the conditional covariance matrix of the OU type variables 
on the Brownian motion type at the tree's height, i.e. Cov[Y|X](tree height),
<code>conditional.corr.matrix</code> is the conditional correlation matrix of the OU type variables 
on the Brownian motion type at the tree's height, i.e. Corr[Y|X](tree height),
<code>stationary.cov.matrix</code> is the limit of the <code>conditional.cov.matrix</code>, <br />
<code>stationary.corr.matrix</code> is the limit of the <code>conditional.corr.matrix</code>, 
<code>optima.cov.matrix</code>
is the covariance matrix of the optimal process at the tree's height 
equalling <br /> 
<code class="reqn">(tree height)* A^{-1}B\Sigma_{xx}\Sigma_{xx}^{T}B^{T}A^{-T}</code>,
<code>optima.corr.matrix</code>
is the correlation matrix of the optimal process at time the tree's height,
<code>cov.with.optima</code> is the covariance matrix between the optimal process and the Y type variables process,
<code>corr.with.optima</code> is the correlation matrix between the optimal process and the Y type variables process, <br />
<code>evolutionary.regression</code> is the regression coefficient of E[Y|X](tree height).
Everything concerning the optimal process assumes A has positive real-part eigenvalues (in particular
it is invertible). Otherwise these will not exist.
<code>StS</code> is the infinitesimal covariance matrix,
<code>LogLik</code> the log&ndash;likelihood, dof the degrees of freedom, <code>m2loglik</code> is <code class="reqn">-2</code>log&ndash;likelihood,
<code>aic</code> is the Akaike information criterion, <code>aic.c</code> is the Akaike information criterion corrected for small
sample size, sic is the Schwarz information criterion, <code>bic</code> is the Bayesian information criterion
(which is the same as the Schwarz information criterion) and <code>RSS</code> is the residual sum of squares.
The field <code>RSS_non_phylogenetic</code> is a residual sum of squares calculated without correcting
for the phylogeny&ndash;induced between species correlations, while the extension
conditional_on_predictors indicates that we consider the RSS for the variables
labelled as responses conditioned on the remaining variables. The <code>R2_phylaverage</code> field is
R2, where the alternative model is the phylogenetically weighted sample average 
(see <code><a href="#topic+OU_phylreg">OU_phylreg</a></code>).
The last field <code>LogLik</code> is the log&ndash;likelihood at the point.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>FinalFound</code></td>
<td>
<p>The point where the search procedure stopped. See Details for the description.</p>
</td></tr>
<tr><td><code>MaxLikFound</code></td>
<td>
<p>The point with the highest likelihood found by the search procedure, 
if it is the same as the final point then this field equals &quot;Same as final found&quot;. </p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The estimation can take a long time and should be repeated a couple of times 
so that it is run from different starting positions.
The function can produce (a lot of) warnings and errors during the search procedure, 
this is nothing to worry about.
</p>


<h3>Note</h3>

<p>The slouch package is a recommended alternative if one has only a single response (Y) trait.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and 
biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>
<p>Labra, A., Pienaar, J. &amp; Hansen, T.F. (2009) 
Evolution of thermophysiology in Liolaemus lizards: adaptation, phylogenetic inertia and niche tracking. 
The American Naturalist 174:204-220.
</p>
<p>Mitov, V. and Bartoszek, K. and Asimomitis, G. and Stadler, T. (2020) 
Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts
Theoretical Population Biology 131:66-78.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="PCMBase.html#topic+PCMLik">PCMLik</a></code>, <code>slouch::model.fit</code>, <code><a href="#topic+SummarizeMVSLOUCH">SummarizeMVSLOUCH</a></code>, 
<code><a href="#topic+simulMVSLOUCHProcPhylTree">simulMVSLOUCHProcPhylTree</a></code>, <br /> <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>, 
<code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape. 
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(3)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

## 2 regimes
### Define a vector of regimes.
## regimes&lt;-c("small","small","large","small")
## OUBMparameters&lt;-list(vY0=matrix(1,ncol=1,nrow=1),A=matrix(0.5,ncol=1,nrow=1),
## B=matrix(2,ncol=1,nrow=1),mPsi=cbind("small"=1,"large"=-1),
## Syy=matrix(2,ncol=1,nrow=1),vX0=matrix(0,ncol=1,nrow=1),Sxx=diag(2,1,1),
## Syx=matrix(0,ncol=1,nrow=1),Sxy=matrix(0,ncol=1,nrow=1))
## single regime for speed on CRAN
regimes&lt;-c("small","small","small","small")
OUBMparameters&lt;-list(vY0=matrix(1,ncol=1,nrow=1),A=matrix(0.5,ncol=1,nrow=1),
B=matrix(2,ncol=1,nrow=1),mPsi=cbind("small"=1),
Syy=matrix(2,ncol=1,nrow=1),vX0=matrix(0,ncol=1,nrow=1),Sxx=diag(2,1,1),
Syx=matrix(0,ncol=1,nrow=1),Sxy=matrix(0,ncol=1,nrow=1))


### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the mvOUBM model.
### maxiter here set to minimal working possibility, in reality it should be larger
### e.g. default of c(10,50,100)
### Also the Atype and Syytype variables should be changed, here set as simplest
### for speed of evaluation, e.g. Atype="DecomposablePositive", Syytype="UpperTri"
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,1,regimes,Atype="SingleValueDiagonal",
Syytype="SingleValueDiagonal",diagA="Positive",maxiter=c(1,2,1))
RNGversion(as.character(getRversion()))

## Not run:  ##It takes too long to run this
## take a less trivial setup
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the mvOUBM model.

OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))


### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the mvOUBM model.
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,2,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive",maxiter=c(10,50,100))

### And finally bootstrap with particular interest in the evolutionary and optimal
### regressions
OUBMbootstrap&lt;-parametric.bootstrap(estimated.model=OUBMestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression","optimal.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=2,
numboot=5,Atype="DecomposablePositive",Syytype="UpperTri",diagA="Positive")

## End(Not run)
</code></pre>

<hr>
<h2 id='OU_phylreg'>
Performs a phylogenetic regression under a given OU model of evolution
</h2><span id='topic+OU_phylreg'></span>

<h3>Description</h3>

<p>The <code>OU_phylreg</code> function does a phylogenetic regression
for given response and design matrices under a multivariate OU model evolving on the phylogeny. 
The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OU_phylreg(mY, mD, phyltree, modelParams, regimes = NULL, kY = NULL, M.error = NULL,
signif_level = 0.05, regimes.times = NULL, root.regime = NULL, b_GLSB = FALSE, 
b_GLSX0 = FALSE, signsB = NULL, signsvX0 = NULL, estimate.root.state = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OU_phylreg_+3A_my">mY</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_md">mD</code></td>
<td>

<p>A design matrix with the rows corresponding to the traits in the tips species while the columns correspond to 
the unknown regression variables. The number or rows have to correspond to the number of elements in
<code>mY</code>, the data are assumed to be stacked by species. If <code>NA</code> it is assumed to be the 
design matrix to estimate regression parameters under the given model of evolution, see Details.
If it is <code>"phylaverage"</code>, then a phylogenetically weighted average is calculated, see Details.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_modelparams">modelParams</code></td>
<td>

<p>List of model parameters of the BM/OUOU/OUBM model as <code>ParamsInModel</code> part of output of 
<code>BrownianMotionModel</code>/<code>ouchModel</code>/<code>mvslouchModel</code>. Some of them can be <code>NA</code>
in order to be estimated by the regression procedure, see Details.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of the branches of <code>phyltree</code>,
i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_ky">kY</code></td>
<td>
<p>Number of &quot;Y&quot; (response) variables if the considered model is an OUBM one. The first <code>kY</code>
columns of <code>mY</code> are the &quot;OU&quot; ones, while the rest the &quot;BM&quot; ones.
In more detail this value determines the number of columns of the <code>mY</code> matrix to treat as response variables (&quot;OU&quot; ones). For example, a 
value of 1 means that only the first column is treated as a response variable, while a value of 3 means the first three 
columns are treated as response variables. Any predictor variables (&quot;BM&quot; ones) the user is interested in setting for a particular model 
should therefore be placed in the final columns of the <code>mY</code> matrix, allowing for selecting select <code>kY</code> columns before 
this as response variables (&quot;OU&quot; ones).
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_signif_level">signif_level</code></td>
<td>

<p>The significance level to be taken when calculating regression confidence intervals, i.e. 
<code class="reqn">(1-signif_level)\cdot 100</code> percent confidence intervals are returned.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with <code class="reqn">0</code> and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the daughter lineages stemming from the root and is the most frequent one in the <code>regimes</code> 
vector. If more than one regime has the same maximum frequency, then alphabetically first one of 
the maximum ones is taken.
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_b_glsb">b_GLSB</code></td>
<td>

<p>If the evolutionary model is an OUBM one (and <code>mD</code> is <code>NA</code>), then should the <code class="reqn">B</code>
matrix be also estimated. If <code class="reqn">B</code> is completely provided in <code>modelParams</code>, then that 
value is taken as an initial guess for the regression estimation procedure (as the 
between-species-between-traits variance-covariance matrix depends on <code>B</code>).
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_b_glsx0">b_GLSX0</code></td>
<td>

<p>If the evolutionary model is an OUBM or BM one (and <code>mD</code> is <code>NA</code>), then should the <code class="reqn">X_{0}</code>
ancestral vector  also be estimated. If <code class="reqn">X_{0}</code> is completely provided in <code>modelParams</code>, then that 
value is taken as an initial guess for the regression estimation procedure (as in the OUBM the design matrix
depends on <code>vX0</code>, in the BM case this value is ignored).
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_signsb">signsB</code></td>
<td>

<p>A matrix of constraints on the estimation of <code>B</code>, with the same dimensions as <code>B</code>, 
if <code>b_GLBS</code> is <code>TRUE</code>.  Inside this matrix the possible values are <code>"+"</code> 
if the given entry is to be positive,  <code>"-"</code> if the given entry is to be negative, 
<code>x</code>, where <code>x</code> is a number, if the entry is to be set to specified value or <code>NA</code> if the entry is 
to be freely estimated.  This option  is still in an experimental stage so some setups might not work (please report).
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_signsvx0">signsvX0</code></td>
<td>

<p>A matrix of constraints on the estimation of <code>vX0</code>, with the same dimensions as <code>vX0</code>, 
if <code>b_GLBX0</code> is <code>TRUE</code>.  Inside this matrix the possible values are <code>"+"</code> 
if the given entry is to be positive,  <code>"-"</code> if the given entry is to be negative, 
<code>x</code>, where <code>x</code> is a number, if the entry is to be set to specified value or <code>NA</code> if the entry is 
to be freely estimated.  This option  is still in an experimental stage so some setups might not work (please report).
</p>
</td></tr>
<tr><td><code id="OU_phylreg_+3A_estimate.root.state">estimate.root.state</code></td>
<td>

<p>Should the root state be estimate <code>TRUE</code> (not recommended) or set at the optimum 
<code>FALSE</code> (recommended). Root state estimation is usually unreliable hence
if fossil measurements are available prediction based on them and the estimated
model will probably be more accurate. If there is only one regime, then 
estimation of the root state separately is impossible and will not be allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix algebra calculations are done using the likelihood function offerred by the <span class="pkg">PCMBase</span> package. 
However, there is a C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>For a given input data matrix, <code>mY</code>, the function considers the stacking of it by rows
(i.e. stacking species by species). Let Y = vec(<code>mY</code>), i.e. <code>Y&lt;-c(t(mY))</code>,
V be the between-species-between-traits variance-covariance matrix (under the parameters passed
in <code>modelParams</code>). The function calculates the value of the generalized least squares 
estimator (not directly, but as a transformation of the likelihood provided by <span class="pkg">PCMBase</span>)
</p>
<p style="text-align: center;"><code class="reqn">v=(D^{T}V^{-1}D)^{-1}D^{T}V^{-1}Y.</code>
</p>

<p>The user can provide the design matrix directly or if <code>mD</code> is <code>NA</code>, then the design matrix
induced by the evolutionary model in <code>modelParams</code> is assumed. The following parameters
can be estimated: <code>vX0</code> (if <code>b_GLSX0</code> is <code>TRUE</code>, BM model); <code>mPsi</code>, 
<code>vY0</code> (if <code>estimate.root.state</code> is <code>TRUE</code>, otherwise set at optimum) for OUOU model; 
<code>vX0</code> (if <code>b_GLSX0</code> is <code>TRUE</code>) <code>mPsi</code>, <code>vY0</code> (if <code>estimate.root.state</code> 
is <code>TRUE</code>, otherwise set at optimum), <code>B</code> (if <code>b_GLSB</code> is <code>TRUE</code>). One can
constrain (some of) the elements of the matrices to be estimated to be postive, negative or 
equal to some value. For <code>B</code> and <code>vX0</code> this was described in the description of the 
arguments of <code>signsB</code> and <code>signsvX0</code>. For <code>mPsi</code> and <code>vY0</code> one does this
in the respective entries of <code>modelParams</code>. There matrix entries can be set to <code>"+"</code>,
<code>"-"</code>, <code>NA</code> or some specific value. In the OUBM case the model specfic design matrix
is not derived from the conditional expectation of all of the responses on all of the predictors,
but from the conditional expectations of each tip species independently (as if V were block
diagonal). This is as the joint condtional expecation design matrix cannot be calculated 
at the moment in an efficient manner and would cause a serious computational bottleneck.
However this only makes a difference if <code>B</code> is to be estimated inside the GLS. 
</p>
<p>Special support is given if one wants to compute a phylogenetically weighted mean.
If <code>mD</code> is set to <code>"phylaverage"</code>, then it is calculated as 
</p>
<p style="text-align: center;"><code class="reqn">D_p=1_{n}\otimes Id_{k}, </code>
</p>

<p>where <code class="reqn">1_{n}</code> is a column vector of n ones and <code class="reqn">Id_{k}</code> is
the identity matrix with rows and columns equalling the number or columns of <code>mY</code>.
</p>


<h3>Value</h3>

<p>A list with the following entries
</p>

<dl>
<dt>vGLSest </dt><dd><p>The regression estimates</p>
</dd>
<dt>regression.covariance.matrix </dt><dd><p>The covariance matrix between regression estimates.</p>
</dd>
<dt>regression.confidence.intervals </dt><dd><p>The confidence intervals for each estimated parameter.</p>
</dd>
<dt>modelParams </dt><dd><p>The model parameters updated if anything was estimated from them in the procedure.</p>
</dd>
<dt>mD </dt><dd><p>The used or calculated design matrix.</p>
</dd>
<dt>RSS </dt><dd><p>The residual sum of squares.</p>
</dd>
<dt>R2_average </dt><dd><p>R2, where the alternative model is the sample average.</p>
</dd>
<dt>R2_phylaverage </dt><dd><p>R2, where the alternative model is the phylogenetically weighted sample average, i.e. the design matrix
is <code class="reqn">D_p </code>.</p>
</dd>
<dt>RSS_average </dt><dd><p>The RSS with respect to the sample average.</p>
</dd>
<dt>RSS_phylaverage </dt><dd><p>The RSS with respect to the phylogenetically weighted sample average.</p>
</dd>
<dt>phyltree </dt><dd><p>The phylogeny used, returned as in the estimation procedure some additional fields are calculated. This could 
help in a speed up if the <code>OU_phylreg</code> is used in some iterative procedure.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and 
biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
## 3D model
## OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
## A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
## Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))
## 2D model used to reduce running time on CRAN
OUOUparameters&lt;-list(vY0=matrix(c(1,-1),nrow=2,ncol=1),
A=rbind(c(9,0),c(0,5)),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

OUOUparameters_reg&lt;-OUOUparameters
OUOUparameters_reg$mPsi&lt;-apply(OUOUparameters_reg$mPsi,c(1,2),function(x){NA})
OUOUparameters_reg$vY0&lt;-apply(OUOUparameters_reg$vY0,c(1,2),function(x){NA})
## estimate parameters under OUOU model
OU_phylreg(OUOUdata, NA, phyltree, OUOUparameters_reg, regimes=regimes, 
kY=NULL, M.error=NULL)

</code></pre>

<hr>
<h2 id='OU_RSS'>
Calculates the RSS under a (multivariate) phylogenetic OU model of evolution
</h2><span id='topic+OU_RSS'></span>

<h3>Description</h3>

<p>The <code>OU_RSS</code> function calculates the residual sum of squares (RSS)
for given data under a multivariate OU model evolving on the phylogeny. 
The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OU_RSS(mY, phyltree, modelParams, M.error = NULL, do_centre = NA,
regimes = NULL, regimes.times = NULL, root.regime = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OU_RSS_+3A_my">mY</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_modelparams">modelParams</code></td>
<td>

<p>List of model parameters of the BM/OUOU/OUBM model as <code>ParamsInModel</code> part of output of 
<code>BrownianMotionModel</code>/<code>ouchModel</code>/<code>mvslouchModel</code>.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_do_centre">do_centre</code></td>
<td>

<p>Should the data, <code>mY</code>, be centred (admissable values are <code>"average"</code>, <code>"phylaverage"</code> or 
<code>"evolutionary_model"</code>) or not (<code>NA</code>). If <code>"average"</code>, then each column (trait)
is centred by its arithmetic average, if <code>"evolutionary_model"</code>, then <code>mY</code> is centred
by the expectation under the evolutoniary model (inferred from <code>modelParams</code>) and if
<code>"phylaverage"</code>, then <code>mY</code> is centred by a phylogenetically weighted arithmetic
average (see Details).
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of the branches of <code>phyltree</code>,
i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with <code class="reqn">0</code> and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="OU_RSS_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the daughter lineages stemming from the root and is the most frequent one in the <code>regimes</code> 
vector. If more than one regime has the same maximum frequency, then alphabetically first one of 
the maximum ones is taken.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix algebra calculations are done using the likelihood function offerred by the <span class="pkg">PCMBase</span> package. 
However, there is a C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>For a given input data matrix, <code>mY</code>, the function considers the stacking of it by rows
(i.e. stacking species by species). Let Y = vec(<code>mY</code>), i.e. <code>Y&lt;-c(t(mY))</code>,
V be the between-species-between-traits variance-covariance matrix (under the parameters passed
in <code>modelParams</code>) and <code>v</code> a centring vector (if <code>do_centre</code> is <code>NA</code>, then
<code class="reqn">v=0</code>). The function calculates the value of the quadratic form
</p>
<p style="text-align: center;"><code class="reqn">(Y-v)^{T}V^{-1}(Y-v).</code>
</p>

<p>A special centring is when <code>do_centre</code> equals <code>"phylaverage"</code>. In this situation
the centring vector is a phylogenetically weighted average, i.e.
</p>
<p style="text-align: center;"><code class="reqn">v=(D^{T}V^{-1}D)^{-1}D^{T}V^{-1}Y ,</code>
</p>

<p>where denoting <code class="reqn">1_{n}</code> as a column vector of n ones and <code class="reqn">Id_{k}</code> as 
the identity matrix with rows and columns equalling the number or columns of <code>mY</code>,
</p>
<p style="text-align: center;"><code class="reqn">D=1_{n}\otimes Id_{k}.</code>
</p>



<h3>Value</h3>

<p>The value of the residual sum of squares, quadratic form with respect to the 
between-species-between-traits precision matrix. Also the used phylogeny is returned.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
## 3D model
## OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
## A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
## Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))
## 2D model used to reduce running time on CRAN
OUOUparameters&lt;-list(vY0=matrix(c(1,-1),nrow=2,ncol=1),
A=rbind(c(9,0),c(0,5)),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

## below will return the RSS under the assumed OUOU model of evolution
OU_RSS(OUOUdata, phyltree, OUOUparameters, M.error=NULL, 
do_centre="evolutionary_model", regimes = regimes)
</code></pre>

<hr>
<h2 id='OU_xVz'>
Performs a vector matrix vector multiplcation under a (multivariate) phylogenetic OU model of evolution
</h2><span id='topic+OU_xVz'></span>

<h3>Description</h3>

<p>The <code>OU_xVz</code> function performs a vector matrix vector multiplcation
for given data under a multivariate OU model evolving on the phylogeny. 
The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OU_xVz(mX, mZ, phyltree, modelParams, M.error = NULL, do_centre = NA,
regimes = NULL, regimes.times = NULL, root.regime = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OU_xVz_+3A_mx">mX</code></td>
<td>

<p>The first data matrix for the vector matrix vector multiplication.
A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_mz">mZ</code></td>
<td>

<p>The second data matrix for the vector matrix vector multiplication.
A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_modelparams">modelParams</code></td>
<td>

<p>List of model parameters of the BM/OUOU/OUBM model as <code>ParamsInModel</code> part of output of 
<code>BrownianMotionModel</code>/<code>ouchModel</code>/<code>mvslouchModel</code>. Same model is assumed for
both <code>mX</code> and <code>mZ</code>.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_do_centre">do_centre</code></td>
<td>

<p>Should the data, <code>mX</code>, <code>mZ</code>, be centred (admissable values are <code>"average"</code>, <code>"phylaverage"</code> or 
<code>"evolutionary_model"</code>) or not (<code>NA</code>). If <code>"average"</code>, then each column (trait)
is centred by its arithmetic average, if <code>"evolutionary_model"</code>, then <code>mX</code> and <code>mZ</code> are centred
by the expectation under the evolutoniary model (inferred from <code>modelParams</code>) and if
<code>"phylaverage"</code>, then <code>mX</code> and <code>mZ</code> are centred by phylogenetically weighted arithmetic
averages (see Details).
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of the branches of <code>phyltree</code>,
i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with <code class="reqn">0</code> and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="OU_xVz_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the daughter lineages stemming from the root and is the most frequent one in the <code>regimes</code> 
vector. If more than one regime has the same maximum frequency, then alphabetically first one of 
the maximum ones is taken.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix algebra calculations are done using the likelihood function offerred by the <span class="pkg">PCMBase</span> package. 
However, there is a C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>For given input data matrices, <code>mX</code> and <code>mZ</code>, the function considers the stacking of them by rows
(i.e. stacking species by species). Let X = vec(<code>mX</code>), i.e. <code>X&lt;-c(t(mX))</code>,
Z = vec(<code>mZ</code>), i.e. <code>Z&lt;-c(t(mZ))</code>, V be the between-species-between-traits variance-covariance 
matrix (under the parameters passed in <code>modelParams</code>) and <code>vx</code>, <code>vz</code> be centring vectors
(if <code>do_centre</code> is <code>NA</code>, then
<code class="reqn">vx=vz=0</code>). The function calculates the value of the vector matrix vector multiplication
</p>
<p style="text-align: center;"><code class="reqn">(X-vx)^{T}V^{-1}(Z-vz).</code>
</p>

<p>A special centring is when <code>do_centre</code> equals <code>"phylaverage"</code>. In this situation
the centring vector is a phylogenetically weighted average, i.e.
</p>
<p style="text-align: center;"><code class="reqn">vx=(D^{T}V^{-1}D)^{-1}D^{T}V^{-1}X, vz=(D^{T}V^{-1}D)^{-1}D^{T}V^{-1}Z, </code>
</p>

<p>where denoting <code class="reqn">1_{n}</code> as a column vector of n ones and <code class="reqn">Id_{k}</code> as 
the identity matrix with rows and columns equalling the number or columns of <code>mY</code>,
</p>
<p style="text-align: center;"><code class="reqn">D=1_{n}\otimes Id_{k}.</code>
</p>



<h3>Value</h3>

<p>The value of the vector matrix vector multiplication with respect to the 
between-species-between-traits precision matrix. Also the used phylogeny is returned.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
## 3D model
## OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
## A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
## Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))
## 2D model used to reduce running time on CRAN
OUOUparameters&lt;-list(vY0=matrix(c(1,-1),nrow=2,ncol=1),
A=rbind(c(9,0),c(0,5)),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)))

### Now simulate the data.
OUOUdata1&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata1&lt;-OUOUdata1[phyltree$tip.label,,drop=FALSE]

OUOUdata2&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata2&lt;-OUOUdata2[phyltree$tip.label,,drop=FALSE]

OU_xVz(OUOUdata1, OUOUdata2, phyltree, OUOUparameters, M.error=NULL, 
do_centre="evolutionary_model", regimes = regimes)

</code></pre>

<hr>
<h2 id='ouchModel'>
Estimate parameters under a (multivariate) OU model of evolution
</h2><span id='topic+ouchModel'></span>

<h3>Description</h3>

<p>The <code>ouchModel</code> function uses maximum likelihood to fit parameters of a multivariate OU  
model evolving on the phylogeny. The user is recommended to install the suggested package 
<span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ouchModel(phyltree, mData, regimes = NULL, regimes.times = NULL, 
root.regime = NULL, predictors = NULL, M.error = NULL, Atype = "Invertible", 
Syytype = "UpperTri", diagA = "Positive", estimate.root.state = FALSE, 
parameter_signs = NULL, start_point_for_optim = NULL, parscale = NULL, 
min_bl = 0.0003, maxiter = c(10,100))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ouchModel_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of the branches of <code>phyltree</code>,
i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with <code class="reqn">0</code> and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the root's daughter lineages and is the most frequent one in the <code>regimes</code> vector. If more
than one regime has the same maximum frequency, then alphabetically first one of the maximum ones
is taken.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from
<code>data</code> which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided, then none will be treated as predictors.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_atype">Atype</code></td>
<td>

<p>What class does the A matrix in the multivariate OUOU model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>"Symmetric"</code>, <code>"SymmetricPositiveDefinite"</code>,  <br />
<code>"DecomposablePositive"</code>, 
<code>"DecomposableNegative"</code>, <br /> <code>"DecomposableReal"</code>, <code>"Invertible"</code>,
<code>"TwoByTwo"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_syytype">Syytype</code></td>
<td>

<p>What class does the Syy matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>"Symmetric"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_diaga">diagA</code></td>
<td>

<p>Whether the values on <code>A</code>'s diagonal are to be <code>"Positive"</code>, <code>"Negative"</code> or 
sign allowed to vary, <code>NULL</code>.  However, setting this to
a non-<code>NULL</code> value might be detrimental to the optimization process if 
<code>Atype</code> is <code>"SymmetricPositiveDefinite"</code>. In this case the diagonal is always 
guaranteed to be positive.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_estimate.root.state">estimate.root.state</code></td>
<td>

<p>Should the root state be estimate <code>TRUE</code> (not recommended) or set at the optimum 
<code>FALSE</code> (recommended). Root state estimation is usually unreliable hence
if fossil measurements are available prediction based on them and the estimated
model will probably be more accurate. If there is only one regime, then 
estimation of the root state separately is impossible and will not be allowed.
</p>
</td></tr>  
<tr><td><code id="ouchModel_+3A_parameter_signs">parameter_signs</code></td>
<td>

<p>WARNING: ONLY use this option if you understand what you are doing! This option
is still in an experimental stage so some setups might not work (please report).
A list allowing the user to control whether specific entries for each model parameter
should be positive, negative, zero or set to a specific (other) value.  The entries
of the list have to be named, the admissible names are <code>"signsA"</code> (for <code>A</code>
matrix), <code>"signsSyy"</code> (for <code>Syy</code> matrix) and <code>"signsmPsi"</code> 
(for <code>mPsi</code> matrix) and <code>"signsvY0"</code> (for <code>vY0</code> matrix). Any other entry 
in this list will be ignored. Each entry of the list has to  be a matrix of appropriate size, 
i.e. of the size of the parameter to which it corresponds.  Inside this matrix the possible values 
are <code>"+"</code> if the given entry is to be positive,  <code>"-"</code> if the given entry is to be negative, 
<code>x</code>, where <code>x</code> is a number,  if the entry is to be set to specified value or <code>NA</code> 
if the entry is to be freely estimated. See Details for an example, further description 
and important warnings! 
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_start_point_for_optim">start_point_for_optim</code></td>
<td>

<p>A named list with starting parameters for of the parameters for be optimized by <code>optim()</code>,
in this case <code>A</code> and <code>Syy</code>. One may provide both or only one of them.
Make sure that the parameter is consistent with the other parameter restrictions
as no check is done and this can result in undefined behaviour.  
For example one may provide this as (provided dimensions and other parameter restrictions agree) 
</p>
<pre>start_point_for_optim=list(A=rbind(c(2,0),(0,4)), 
Syy=rbind(c(1,0.5),c(0,2))).</pre>
</td></tr>
<tr><td><code id="ouchModel_+3A_parscale">parscale</code></td>
<td>

<p>A vector to calculate the <code>parscale</code> argument for <code>optim</code>. It is a named
vector with 3 entries, e.g. <br /> <code>c("parscale_A"=3,"logparscale_A"=5,"logparscale_other"=1)</code>.
The entry <code>parscale_A</code> is the scale for entries of the <code>A</code> matrix,
<code>logparscale_A</code> is the scale for entries of the <code>A</code> matrix that are 
optimized over on the logarithmic scale, e.g. if eigenvalues are assumed to be positive,
then optimization is done over <code>log(eigenvalue)</code> for <code>A</code>'s eigendecomposition
and <code>logparscale_other</code> is the scale for entries other then of <code>A</code>
that are done on the logarithmic scale (e.g. <code>Syy</code>'s diagonal, or other entries
indicated as positive via <code>parameter_signs</code>). If not provided (or if a name of the vector
is misspelled), then made equal  to the example value provided above. For other elements, then 
mentioned above, that are optimized over by <code>optim()</code>, <code>1</code> is used for <code>optim()</code>'s 
<code>parscale</code>. It is advised that the user experiments with a couple of different values and 
reads <code><a href="stats.html#topic+optim">optim</a></code>'s  man page. 
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
<tr><td><code id="ouchModel_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations for different components of the estimation
algorithm. A vector of two integers. The first is the number of iterations for phylogenetic
GLS evaluations, i.e. conditional on the other parameters, the regime optima and perhaps
initial state are estimated by a phylogenetic GLS procedure. After this the other parameters are optimized over 
by <code>optim()</code>. This first   entry controls the number of iterations of this procedure.   
Finally, the second is the value of <code>maxiter</code>  passed to <code>optim()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>This function estimates the parameters of the following multivariate SDE,
</p>
<p style="text-align: center;"><code class="reqn">dY(t) = -A(Y-\Psi(t))dt + \Sigma dW(t), Y(0)=Y_{0}</code>
</p>
 
<p>on a phylogenetic tree. It uses a numerical optimization over <code>A</code> (parametrized by its eigenvalues and 
eigenvectors or its QR decomposition) and <code>S</code> (parametrized by its values) and conditional on 
<code>A</code> and <code>S</code> estimates the values of Psi corresponding to the different regimes by a GLS estimate. 
<code>Y(0)</code> is assumed to be equal to the root value of <code>Psi</code> (unless <code>estimate.root.state=TRUE</code>), 
then <code>Y(0)</code> is estimated is estimated by least squares).
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If the estimation algorithm hits a defective <code>A</code>, then it sets the log-likelihood at
the minimum value and will try to get out of this dip. 
</p>
<p>The function parameter <code>parameter_signs</code> is special in the sense that it can give 
the user great control over the estimation procedure but can also make the output
very inconsistent with what the user provides. If we have two traits, 
then an EXAMPLE setting of this can be:
<br /> 
<code>parameter_signs=list(signsA=rbind(c("+","-"),c(0,"+")),</code><br /> <code>signsSyy=rbind(c(NA,0),c(0,NA))</code>. 
This means that <code>A</code> is upper triangular with positive
values on the diagonal and a negative value on the off-diagonal, <code>Syy</code> is diagonal
and <code>A</code> is also diagonal. It is advisable to set now <code>Atype="Any"</code> and
<code>Syytype="Any"</code> (see further description). 
</p>
<p>If the given model parameter is to be estimated
by a generalized least squares (currently <code>mPsi</code> and <code>vY0</code>), then the 
sign specifications are ignored. However, it is possible to set specific values. 
Furthermore, the package does not check (for <code>A</code>
and <code>Syy</code>) if the specifications here agree with the <code>Atype</code>, <code>Syytype</code>
and <code>diagA</code>. The settings in <code>signsA</code> and <code>signsSyy</code> will override
the other settings. Hence, it is up to the user to make sure that the settings of 
<code>signsA</code> and <code>signsSyy</code> are consistent with <code>Atype</code>, <code>Syytype</code>
and <code>diagA</code>. It is advisable to use <code>signsA</code> with <code>"+"</code>
on the diagonal and have <code>diagA=NULL</code>. The diagonal of <code>Syy</code> is forced to
be positive (unless <code>"-"</code> is used on the diagonal of <code>signsSyy</code>
but this is strongly discouraged) so it is advisable to keep <code>NA</code> 
on the diagonal of <code>signsSyy</code> and not put there <code>"+"</code> there.
Hence, in particular using the signs mechanism result in a wrong class of the matrix
<br />
(e.g. <code>Atype="SymmetricPositiveDefinite"</code>, but after corrections for the provided entries in
<code>signsA</code> one obtains a non-symmetric <code>A</code> with complex, negative-real-part eigenvalues). 
Lastly, using <code>signsA</code> and <code>signsSyy</code> can result in
a wrong amount of <code>dof</code> and in turn incorrect <code>AICc</code> and <code>BIC</code> values.
What the code does is subtracts the amount of fixed values in <code>signsA</code> and <code>signsSyy</code>
from the amount of free parameters used to estimate <code>A</code> and <code>Syy</code>. For example
if one sets <br /> <code>Atype="SingleValueDiagonal"</code> (estimated by one free parameter) 
but specified two off-diagonal values, then the amount of dofs from <code>A</code> will be <code>-1</code>!!
The ONLY fail-safe way to use this is to set <code>Atype="Any"</code> (if <code>signsA</code> used) and 
<code>Syytype="Any"</code> (if <code>signsSyy</code> used). If using <code>Syytype="Any"</code> and <code>signsSyy</code> 
the it is strongly advisable to set the entries either below or above the diagonal of<code>Syy</code> to <code>0</code>.
The reason is that <code class="reqn">\Sigma_{yy}\Sigma_{yy}^{T}</code> enters the likelihood and not the 
given value of <code class="reqn">\Sigma_{yy}</code>. Hence, having values below (or respectively above) the diagonal
results in an overparameterized model. The package has the option of mixing different matrix types
with specifying values in it but this is only for advanced users who need to dig into the code
to see what the <code>dof</code> should be and  if it is possible to find a correspondence between the 
parametrization and settings. If entries of <code>mPsi</code> and <code>vY0</code> are pre-specified,
then the <code>dof</code> are correctly adjusted for this. 
</p>
<p>The found point is described by a list containing four fields. 
The first field <br /> <code>HeuristicSearchPointFinalFind</code> is the parametrization of the model parameters 
at the considered point with the value of the log-likelihood. The field <code>ParamsInModel</code> is the point 
estimate of the parameters of the SDE. 
The field <code>ParamSummary</code> are different composite (evaluated at the tree's height) and summary statistics,
The field <code>phylhalflife</code> are the eigenvalues, eigenvectors and phylogenetic half lives
associated with the A matrix, <code>expmtA</code> is <code class="reqn">\exp(-A*(tree height))</code>, 
<code>mPsi.rotated</code> is each of the 
regime effects multiplied by <code class="reqn">(1-\exp(-A*(tree height)))</code>,
<code>cov.matrix</code> is the trait vector covariance matrix at the tree's height, 
<code>corr.matrix</code> is the trait vector correlation matrix at the tree's height,
<code>trait.regression</code> is a list consisting of regression coefficients when taking each trait in turn and
calculating its conditional expectation on all of the other trait, <code>stationary.cov.matrix</code> 
is the stationary covariance matrix of process if it exists (i.e. the eigenvalues have positive real part), 
<code>stationary.corr.matrix</code> is the stationary correlation matrix of process if it exists
(i.e. the eigenvalues have positive real part), <code>StS</code> the infinitesimal covariance matrix 
<code class="reqn">\Sigma_{yy}\Sigma_{yy}^{T}</code>,
<code>LogLik</code> the log-likelihood, dof the degrees of freedom, <code>m2loglik</code> is <code class="reqn">-2</code>log&ndash;likelihood,
<code>aic</code> is the Akaike information criterion, <code>aic.c</code> is the Akaike information criterion corrected for small
sample size, <code>sic</code> is the Schwarz information criterion, <code>bic</code> is the Bayesian information criterion
(which is the same as the Schwarz information criterion) and <code>RSS</code> is the residual sum of squares.
The field <code>RSS_non_phylogenetic</code> is a residual sum of squares calculated without correcting
for the phylogeny&ndash;induced between species correlations, while the extension
conditional_on_predictors indicates that we consider the RSS for the variables
labelled as responses conditioned on the remaining variables. The <code>R2_phylaverage</code> field is
R2, where the alternative model is the phylogenetically weighted sample average 
(see <code><a href="#topic+OU_phylreg">OU_phylreg</a></code>).
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>FinalFound</code></td>
<td>
<p>The point where the search procedure stopped. See Details for the description.</p>
</td></tr>
<tr><td><code>MaxLikFound</code></td>
<td>
<p>The point with the highest likelihood found by the search procedure, if it is 
the same as the final point then this field equals &quot;Same as final found&quot;. </p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The estimation can take a long time and should be repeated 
a couple of times so that it is run from different starting positions.
The function can produce (a lot of) warnings and errors during the search procedure, 
this is nothing to worry about.
</p>


<h3>Note</h3>

<p>The <span class="pkg">ouch</span> package considers a similar model and looking at it could be helpful.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Mitov, V. and Bartoszek, K. and Asimomitis, G. and Stadler, T. (2020) 
Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts
Theoretical Population Biology 131:66-78.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.  
</p>


<h3>See Also</h3>

<p><code><a href="PCMBase.html#topic+PCMLik">PCMLik</a></code>, <code><a href="ouch.html#topic+hansen">hansen</a></code>, <code><a href="#topic+SummarizeOUCH">SummarizeOUCH</a></code>, 
<code><a href="#topic+simulOUCHProcPhylTree">simulOUCHProcPhylTree</a></code>, <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
## 3D model
## OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
## A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
## Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))
## 2D model used to reduce running time on CRAN
OUOUparameters&lt;-list(vY0=matrix(c(1,-1),nrow=2,ncol=1),
A=rbind(c(9,0),c(0,5)),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the OUOU model.
### maxiter here set to minimal working possibility, in reality it should be larger
### e.g. default of c(10,100)
### Also the Atype and Syytype variables should be changed, here set as simplest
### for speed of evaluation, e.g. Atype="DecomposablePositive", Syytype="UpperTri"
OUOUestim&lt;-ouchModel(phyltree,OUOUdata,regimes,Atype="SingleValueDiagonal",
Syytype="SingleValueDiagonal",diagA="Positive",maxiter=c(1,1))
RNGversion(as.character(getRversion()))

## Not run:  ##It takes too long to run this
### And finally bootstrap with particular interest in the evolutionary regression
OUOUbootstrap&lt;-parametric.bootstrap(estimated.model=OUOUestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression"),regimes=regimes,root.regime="small",
M.error=NULL,predictors=c(2),kY=NULL,numboot=5,Atype=NULL,Syytype=NULL,diagA=NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='parametric.bootstrap'>Parametric bootstrap for confidence intervals</h2><span id='topic+parametric.bootstrap'></span>

<h3>Description</h3>

<p>The function performs a parametric bootstrap for confidence
intervals for estimates of the evolutionary model. 
The user may specify what parameters are to have 
their confidence intervals returned. The user is recommended to install 
the suggested package  <span class="pkg">PCMBaseCpp</span> which significantly speeds up the 
calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric.bootstrap(estimated.model, phyltree, 
values.to.bootstrap = NULL, regimes = NULL, 
root.regime = NULL, M.error = NULL, predictors = NULL, 
kY = NULL, numboot = 100, Atype = NULL, Syytype = NULL, 
diagA = NULL, parameter_signs = NULL, start_point_for_optim = NULL,
parscale = NULL, min_bl = 0.0003, maxiter = c(10,50,100), estimateBmethod="ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametric.bootstrap_+3A_estimated.model">estimated.model</code></td>
<td>

<p>An estimated by evolutionary model. It can be e.g. the output of <br />
<code>BrownianMotionModel()</code>, <code>ouchModel()</code>, <code>mvslouchModel()</code> <br />
or <code>estimate.evolutionary.model()</code>. 
In the last case the model under <code>BestModel</code> is analyzed. 
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_values.to.bootstrap">values.to.bootstrap</code></td>
<td>

<p>A vector of parameter/composite statistic names that the user is interested in. They
are extracted from the bootstrapped elements for easy access.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_root.regime">root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the root's daughter lineages and is the most frequent one in the <code>regimes</code> vector. If more
than one regime has the same maximum frequency, then alphabetically first one of the maximum ones
is taken.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix,
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version 2.0.0 of mvSLOUCH it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from the original data
which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided then the &quot;X&quot; variables 
are treated as predictors, but this only for the OUBM models (for the others in this case 
none are treated as predictors).
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_ky">kY</code></td>
<td>

<p>Number of &quot;Y&quot; (response) variables, for the OUBM models. 
The first <code>kY</code>
columns of <code>mY</code> are the &quot;OU&quot; ones, while the rest the &quot;BM&quot; ones.
In more detail this value determines the number of columns of the (simulated) data matrix to treat as response variables (&quot;OU&quot; ones). For example, a 
value of 1 means that only the first column is treated as a response variable, while a value of 3 means the first three 
columns are treated as response variables. Any predictor variables (&quot;BM&quot; ones) the user is interested in setting for a particular model 
should therefore be placed in the final columns of the data matrix, allowing for selecting select <code>kY</code> columns before 
this as response variables (&quot;OU&quot; ones).
If <code>NULL</code> then
it is extracted from the provided model parameters in <code>estimated.model</code>.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_numboot">numboot</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_atype">Atype</code></td>
<td>

<p>The class of the <code>A</code> matrix. It can take one of the following values: 
<br /> <code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>, <br /> <code>"SymmetricPositiveDefinite"</code>,
<code>"Symmetric"</code>, <code>"DecomposablePositive"</code>, <br /> <code>"DecomposableNegative"</code>, 
<code>"DecomposableReal"</code>, <code>"Invertible"</code>, <code>"Any"</code>. If <code>NULL</code> then
it is extracted from the provided model parameters in <code>estimated.model</code>.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_syytype">Syytype</code></td>
<td>

<p>The class of the Syy matrix, ignored if <code>evolmodel</code> equals 
<code>"BM"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>,  <code>"Symmetric"</code>, <code>"Any"</code>. 
If <code>NULL</code> then it is extracted from the provided model parameters 
in <code>estimated.model</code>.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_diaga">diagA</code></td>
<td>

<p>Should the diagonal of <code>A</code> be forced to be positive (<code>"Positive"</code>), <br />
negative (<code>"Negative"</code>) or the sign free to vary (<code>NULL</code>). 
However, setting this to
a non-<code>NULL</code> value when <code>evolmodel</code> is <code>"mvslouch"</code> might be 
(but simulations concerning this are not conclusive) slightly detrimental to the optimization process 
if <code>Atype</code> is <code>"DecomposablePositive"</code>, <code>"DecomposableNegative"</code>, or
<code>"DecomposableReal"</code>. In these cases <code>A</code> is parametrized by its eigendecomposition.
Additional exponentiation of the diagonal, to ensure positivity, could (but this is uncertain)
make the exploration of the likelihood surface more difficult. 
In the case of <code>Atype</code> being <code>"SymmetricPositiveDefinite"</code>,
the diagonal is always guaranteed to be positive.
If <code>NULL</code> then the function checks if it is not in the provided model parameters 
in <code>estimated.model</code>.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_parameter_signs">parameter_signs</code></td>
<td>

<p>WARNING: ONLY use this option if you understand what you are doing! This option
is still in an experimental stage so some setups might not work (please report).
A list allowing the user to control whether specific entries for each model parameter
should be positive, negative, zero or set to a specific (other) value.  The entries
of the list have to be named, the admissible names are <code>"signsA"</code> (for <code>A</code>
matrix), <code>"signsB"</code> (for <code>B</code> matrix), <code>"signsSyy"</code> (for <code>Syy</code>
matrix) and <code>"signsmPsi"</code> (for <code>mPsi</code> matrix) and <code>"signsvY0"</code> (for <code>vY0</code>
matrix). Any other entry in this list will be ignored. Each entry of the list has to
be a matrix of appropriate size, i.e. of the size of the parameter to which it corresponds.
Inside this matrix the possible values are <code>"+"</code> if the given entry is to be positive,
<code>"-"</code> if the given entry is to be negative, <code>x</code>, where <code>x</code> is a number,
if the entry is to be set to specified value or <code>NA</code> if the entry is to be freely 
estimated. See <code>estimate.evolutionary.model</code>, <code>ouchModel</code> and <code>mvslouchModel</code>
for further details, examples and important warnings!
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_start_point_for_optim">start_point_for_optim</code></td>
<td>

<p>A named list with starting parameters for of the parameters for be optimized by <code>optim()</code>, currently 
only <code>A</code> and <code>Syy</code> for OUOU and OUBM models, i.e. will not work with BM model. 
One may provide both or only one of them.
Make sure that the parameter is consistent with the other parameter restrictions as no check is done and this 
can result in undefined behaviour. For example one may provide this as (provided dimensions and other
parameter restrictions agree) 
</p>
<pre>start_point_for_optim=list(A=rbind(c(2,0),(0,4)), 
Syy=rbind(c(1,0.5),c(0,2))).</pre>
<p>This starting point is always jittered in each bootstrap replicate as the employed
<code>"Nelder-Mead"</code> method in <code>optim()</code> is deterministic.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_parscale">parscale</code></td>
<td>

<p>A vector to calculate the <code>parscale</code> argument for <code>optim</code>. It is a named
vector with 3 entries, e.g. <br /> <code>c("parscale_A"=3,"logparscale_A"=5,"logparscale_other"=1)</code>.
The entry <code>parscale_A</code> is the scale for entries of the <code>A</code> matrix,
<code>logparscale_A</code> is the scale for entries of the <code>A</code> matrix that are 
optimized over on the logarithmic scale, e.g. if eigenvalues are assumed to be positive,
then optimization is done over <code>log(eigenvalue)</code> for <code>A</code>'s eigendecomposition
and <code>logparscale_other</code> is the scale for entries other then of <code>A</code>
that are done on the logarithmic scale (e.g. <code>Syy</code>'s diagonal, or other entries
indicated as positive via <code>parameter_signs</code>). If not provided (or if a name of the vector
is misspelled), then made equal  to the example value provided above.  For other elements, then 
mentioned above, that are optimized over by <code>optim()</code>, <code>1</code> is used for <code>optim()</code>'s 
<code>parscale</code>. It is advised that  the user experiments with a couple of different values and 
reads <code><a href="stats.html#topic+optim">optim</a></code>'s  man page.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
Furthermore, <span class="pkg">mvSLOUCH</span> sets all branches in the tree shorter than <code>min_bl</code> to <code>min_bl</code>.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations for different components of the estimation
algorithm. A vector of three integers. The first is the number of iterations for phylogenetic
GLS evaluations, i.e. conditional on the other parameters, the regime optima, perhaps <code>B</code>, and perhaps
initial state are estimated by a phylogenetic GLS procedure. After this the other (except of <code>B</code> 
in OUBM model case) parameters are optimized over by <code>optim()</code>. This first
entry controls the number of iterations of this procedure.   The second is the number of iterations inside
the iterated GLS for the OUBM model. In the first step regime optima and <code>B</code> (and perhaps initial state) 
are estimated conditional on the other parameters and current estimate of <code>B</code>, then the estimate of <code>B</code>
is update and the same phylogenetic GLS is repeated (second entry of <code>maxiter</code> number of times).  
Finally, the third is the value of <code>maxiter</code>  passed to <code>optim()</code>, apart from the optimization 
in the Brownian motion and measurement error case. If the bootstrapped model is a Brownian motion one,
then this parameter is ignored, if OUOU, then the second entry is ignored.
</p>
</td></tr>
<tr><td><code id="parametric.bootstrap_+3A_estimatebmethod">estimateBmethod</code></td>
<td>
<p>Only relevant for OUBM models, should <code>B</code> be estimated by maximum likelihood (default 
value <code>"ML"</code>) or generalized least squares (value <code>"GLS"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If the estimation algorithm hits a defective <code>A</code>, then it sets the log-likelihood at
the minimum value and will try to get out of this dip.
</p>


<h3>Value</h3>

<p>A list with all the bootstrap simulations is returned. The elements of the
list are the following.
</p>
<table role = "presentation">
<tr><td><code>paramatric.bootstrap.estimation.replicates</code></td>
<td>
<p>A list of length
equalling <code>numboot</code>. Each element is the result of the bootstrap
replicate - the estimation results in the format of the output
of <span class="pkg">mvSLOUCH</span> functions, with an additional field <code>data</code>, 
the simulated data.</p>
</td></tr>
<tr><td><code>bootstrapped.parameters</code></td>
<td>
<p>If <code>values.to.bootstrap</code> is not <code>NULL</code>
then a list of length equalling length of <code>values.to.bootstrap</code>. Each
element corresponds to the respective element of <code>values.to.bootstrap</code>
and contains a list of the bootstrapped values of this element.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The estimation can take a long time and hence many bootstrap
replicates will take even more time.The code can produce (a lot of) warnings and 
errors during the search procedure, this is nothing to worry about.
</p>


<h3>Note</h3>

<p>The <span class="pkg">ouch</span> package implements a parametric bootstrap and reading about 
it could be helpful.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code>, <code><a href="#topic+estimate.evolutionary.model">estimate.evolutionary.model</a></code>,
<code><a href="#topic+mvslouchModel">mvslouchModel</a></code>, <code><a href="#topic+ouchModel">ouchModel</a></code>, <code><a href="ouch.html#topic+bootstrap">bootstrap</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape. 
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))

### Now simulate the data.
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
BMdata&lt;-BMdata[phyltree$tip.label,,drop=FALSE]

### Recover the parameters of the Brownian motion.
BMestim&lt;-BrownianMotionModel(phyltree,BMdata)

### And finally obtain bootstrap confidence intervals for some parameters
BMbootstrap&lt;-parametric.bootstrap(estimated.model=BMestim,phyltree=phyltree,
values.to.bootstrap=c("vX0","StS"),M.error=NULL,numboot=2)
RNGversion(as.character(getRversion()))

## Not run: ##It takes too long to run this
### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the mvOUBM model.
OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))

### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the mvOUBM model.
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,2,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive",maxiter=c(10,50,100))

### And finally bootstrap with particular interest in the evolutionary and optimal
### regressions

OUBMbootstrap&lt;-parametric.bootstrap(estimated.model=OUBMestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression","optimal.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=2,
numboot=5,Atype="DecomposablePositive",Syytype="UpperTri",diagA="Positive",
maxiter=c(10,50,100))


### We now demonstrate an alternative setup
### Define SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the OUOU model.
estimResults&lt;-estimate.evolutionary.model(phyltree,OUOUdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=3,model.setups=NULL,predictors=c(3),kY=2,
doPrint=TRUE,pESS=NULL,maxiter=c(10,50,100))

### And finally bootstrap with particular interest in the evolutionary regression
OUOUbootstrap&lt;-parametric.bootstrap(estimated.model=estimResults,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=NULL,
numboot=5,Atype=NULL,Syytype=NULL,diagA=NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyltree_paths'>Extract path information from a phylogenetic tree</h2><span id='topic+phyltree_paths'></span>

<h3>Description</h3>

<p>The function computes for each node its path to the root and
its distance to the root. It returns an &ldquo;enhanced&rdquo; 
<code>phylo</code> type tree.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyltree_paths(phyltree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phyltree_paths_+3A_phyltree">phyltree</code></td>
<td>
<p>The phylogeny - an object of class <code>phylo</code>, i.e. tree in <span class="pkg">ape</span> format.
The &quot;standard&quot; <span class="pkg">ape</span> node indexing is assumed: for a tree with <code class="reqn">n</code> tips, 
the tips should have indices <code>1:n</code> and the root index <code>n+1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes a root edge, i.e. <code>$root.edge</code>
if one is present.
</p>


<h3>Value</h3>

<p>The function returns a <code>phylo</code> type tree with the below additional
fields.
</p>
<table role = "presentation">
<tr><td><code>Ntips</code></td>
<td>
<p>Number of tips on the tree.</p>
</td></tr>
<tr><td><code>path.from.root</code></td>
<td>
<p>A list of length equalling the number of nodes. Each 
entry is a list made up of two fields <code>nodes</code> and <code>edges</code>. 
<code>nodes</code> are the nodes on the path to the root and <code>edges</code> the edges.</p>
</td></tr>
<tr><td><code>time.of.nodes</code></td>
<td>
<p>A vector of length equalling the number of nodes. Each 
entry is the node's distance from the root. This is only calculated if the input
tree has the <code>$edge.length</code> field.</p>
</td></tr>
<tr><td><code>tree_height</code></td>
<td>
<p>The height of the tree if it is ultrametric, otherwise the 
length of the longest path from root to tip.</p>
</td></tr>
<tr><td><code>tip_species_index</code></td>
<td>
<p>The node numbers corresponding to tip nodes, should equal <code>1:n</code>.</p>
</td></tr>
<tr><td><code>internal_nodes_index</code></td>
<td>
<p>The node numbers corresponding to internal nodes, should equal
<code>(n+1):(2n-1)</code>.</p>
</td></tr>
<tr><td><code>root_index</code></td>
<td>
<p>The node number corresponding to the root, should equal <code>n+1</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>ape</code> and <code>phangorn</code> packages include related tree manipulation functions.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+ape">ape</a></code>, <code>phangorn</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    RNGversion(min(as.character(getRversion()),"3.6.1"))
    set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
    phyltree&lt;-ape::rtree(5)
    phyltree_augmented&lt;-phyltree_paths(phyltree)
    RNGversion(as.character(getRversion()))
</code></pre>

<hr>
<h2 id='plot.clustered_phylo'>Plots a clustered_phylo object.</h2><span id='topic+plot.clustered_phylo'></span>

<h3>Description</h3>

<p>The function plots a clustered_phylo object allowing the user to differently
visualize the different clades/clusters on the phylogeny and also the
joining them subtree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustered_phylo'
plot(x, clust_cols = NULL, clust_edge.width = NULL, 
clust_edge.lty = NULL, clust_tip.color = "black", joiningphylo_col = "black", 
joiningphylo_edge.width = 1, joiningphylo_edge.lty = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.clustered_phylo_+3A_x">x</code></td>
<td>
<p>A phylogenetic tree of class <code>clustered_phylo</code>, i.e. output of 
<code>mvSLOUCH::simulate_clustered_phylogeny()</code></p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_clust_cols">clust_cols</code></td>
<td>
<p>Vector of colours of edges inside each cluster. Default <code>NULL</code>, corresponding to
<code>"black"</code>. If length of this vector does not equal to the number of clusters, then it is recycled.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_clust_edge.width">clust_edge.width</code></td>
<td>
<p>Numeric vector of widths of edges inside each cluster. Default <code>NULL</code>, corresponding to
<code>1</code>. If length of this vector does not equal to the number of clusters, then it is recycled.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_clust_edge.lty">clust_edge.lty</code></td>
<td>
<p>Vector of an edge's type inside each cluster. Default <code>NULL</code>, corresponding to
<code>1</code>. If length of this vector does not equal to the number of clusters, then it is recycled.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_clust_tip.color">clust_tip.color</code></td>
<td>
<p>Vector of colours of tips' labels inside each cluster. Default <code>NULL</code>, corresponding to
<code>"black"</code>. If length of this vector does not equal to the number of clusters, then it is recycled.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_joiningphylo_col">joiningphylo_col</code></td>
<td>
<p>Colour of edges inside the subtree joining the clusters.</p>
</td></tr> 
<tr><td><code id="plot.clustered_phylo_+3A_joiningphylo_edge.width">joiningphylo_edge.width</code></td>
<td>
<p>Width of edges inside the subtree joining the clusters.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_joiningphylo_edge.lty">joiningphylo_edge.lty</code></td>
<td>
<p>Edges' type inside the subtree joining the clusters.</p>
</td></tr>
<tr><td><code id="plot.clustered_phylo_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>plot.phylo()</code>. Notice that here we cannot have
<code>edge.color</code>, <code>edge.width</code> and <code>edge.lty</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>plot.phylo()</code>.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")

phyltree&lt;-simulate_clustered_phylogeny(v_sizeclusts=c(5,5,5),f_simclustphyl="sim.bd.taxa_Yule1",
b_change_joining_branches=TRUE, joining_branchlengths=c(20,NA),joining="sim.bd.taxa_Yule1")

plot(phyltree,clust_cols=c("red","green","blue"),clust_edge.width=3,clust_edge.lty=c(1,2,3),
clust_tip.color=c("red","blue","green"),joiningphylo_col="black",joiningphylo_edge.width=3,
joiningphylo_edge.lty=1)

## and not plot without tip labels
plot(phyltree,clust_cols=c("red","green","blue"),clust_edge.width=3,clust_edge.lty=c(1,2,3),
joiningphylo_col="black",joiningphylo_edge.width=3,joiningphylo_edge.lty=1,show.tip.label=FALSE)

RNGversion(as.character(getRversion()))
</code></pre>

<hr>
<h2 id='simulate_clustered_phylogeny'>
Simulate a phylogenetic tree with a specified number of clades.
</h2><span id='topic+simulate_clustered_phylogeny'></span>

<h3>Description</h3>

<p>Simulate a phylogenetic tree that has a given number of clades, each
with a given number of tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_clustered_phylogeny(v_sizeclusts, joining_branchlengths = NULL, 
f_simclustphyl = "sim.bd.taxa_Yule1", joiningphyl = NULL, 
b_change_joining_branches = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_clustered_phylogeny_+3A_v_sizeclusts">v_sizeclusts</code></td>
<td>
<p>A vector with the sizes of the clades/clusters.</p>
</td></tr>
<tr><td><code id="simulate_clustered_phylogeny_+3A_joining_branchlengths">joining_branchlengths</code></td>
<td>
<p>Default <code>NULL</code>, if <code>joiningphyl</code> is <code>NULL</code>, 
then has to be provided. A vector of two numbers. The first element are the lengths of the 
branches of the cluster joining phylogeny leading to the clusters. The second element will be the 
lengths of the &quot;internal&quot; branches of the cluster joining phylogeny. If only a single number is provided, 
then all the branches of the joining phylogeny will have their lengths equal to this value.</p>
</td></tr>
<tr><td><code id="simulate_clustered_phylogeny_+3A_f_simclustphyl">f_simclustphyl</code></td>
<td>
<p>What function to use to simulate the phylogeny inside each cluster. 
The default value of &quot;sim.bd.taxa_Yule1&quot; corresponds to a pure birth tree generated by
<code>ape::rphylo(n=clade_size,birth=1,death=0)</code>, without a root branch
otherwise the user should pass an object of class <code>function</code> and its parameters in place of the 
<code>...</code> . The first parameter must be the number of contemporary leaves and be called <code>n</code>.
The function has to return a valid <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="simulate_clustered_phylogeny_+3A_joiningphyl">joiningphyl</code></td>
<td>
<p>By what phylogeny are the clades to be joined by. Either <code>NULL</code> (default), 
a <code>phylo</code> object, the character string <code>"sim.bd.taxa_Yule1"</code> or an object of class <code>function</code>. 
If <code>NULL</code>, then they are joined by a caterpillar (comb/pectinate) phylogeny with the branch lengths as 
provided by the <code>joining_branchlengths</code> parameter. If it is a <code>phylo</code> object, 
then they will be joined by it. Importantly the number of tips of this phylogeny has to equal the number 
of clusters. If <code>"sim.bd.taxa_Yule1"</code>,  then the joining phylogeny is simulated as a pure birth tree with 
tips equalling the number of clusters by <code>ape::rphylo()</code>. If it is a function, then this is 
used and its parameters are passed through <code>...</code> . The first parameter must be the number of 
contemporary leaves and be called <code>n</code>. The function has to return a valid <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="simulate_clustered_phylogeny_+3A_b_change_joining_branches">b_change_joining_branches</code></td>
<td>
<p>Logical, if joining phylogeny (parameter <code>joiningphyl</code>) was provided or 
simulated, should its branches be changed according to what was provided in <code>joining_branchlengths</code> 
(if it was not <code>NULL</code>). By default <code>FALSE</code> and the branch lengths are not changed.</p>
</td></tr>
<tr><td><code id="simulate_clustered_phylogeny_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to user provided <code>f_simclustphyl</code> and <code>joiningphyl</code> functions. 
Unless one knows exactly what one is doing they should be passed by name. If there is a conflict of names, 
then one should pass wrapper functions around these functions where the names conflict is resolved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting object is a <code>clustered_phylo</code> object which inherits from the <code>phylo</code> class and enhances it. 
Apart from the standard <code>phylo</code> fields it has two additional ones:
</p>

<dl>
<dt>edges_clusters</dt><dd><p>a named list with length equalling the number of clades/clusters plus 1. The first element
of the list is called <code>joining_tree</code> and contains the indices (row numbers of the <code>edge</code> matrix, 
indices of the <code>edge_length</code> vector) of the edges inside the subtree joining the clusters. 
Afterwords element (i+1) is named cluster_i and contains a numeric vector with the indices of the edges 
inside clade i.</p>
</dd>
<dt>tips_clusters</dt><dd><p>a named list with length equalling the number of clades/clusters. Each field of the list 
is a numeric vector containing the indices of the tips inside the clade. The names of element i of the list 
is cluster_i.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek K. and Vasterlund A. (2020) 
&quot;Old Techniques for New Times&quot;: the RMaCzek package for producing Czekanowski's diagrams 
Biometrical Letters 57(2):89-118.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
## We use a wrapper function for illustration
## a single phylo object
my_sim.bd.taxa&lt;-function(n,...){
    ape::rphylo(n=n,...)
}
phyltree1&lt;-simulate_clustered_phylogeny(v_sizeclusts=c(5,5,5),f_simclustphyl=my_sim.bd.taxa,
b_change_joining_branches=TRUE, joining_branchlengths=c(20,NA),joining=my_sim.bd.taxa,
birth=1,death=0)

RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
## The below code should return the same tree as above
phyltree2&lt;-simulate_clustered_phylogeny(v_sizeclusts=c(5,5,5),f_simclustphyl="sim.bd.taxa_Yule1",
b_change_joining_branches=TRUE, joining_branchlengths=c(20,NA),joining="sim.bd.taxa_Yule1")

## The resulting phylogeny is not ultrametric, if ultrametricity is required, then some procedure 
## has to be employed, e.g.
## phyltree1_u&lt;-phytools::force.ultrametric(phyltree1, method="extend")
RNGversion(as.character(getRversion()))
</code></pre>

<hr>
<h2 id='simulBMProcPhylTree'>
Simulate data on a phylogeny under a (multivariate) Brownian motion model
</h2><span id='topic+simulBMProcPhylTree'></span>

<h3>Description</h3>

<p>Simulate data on a phylogeny under a (multivariate) Brownian motion model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulBMProcPhylTree(phyltree, X0, Sigma, dropInternal = TRUE, M.error=NULL, 
fullTrajectory=FALSE, jumpsetup=NULL, keep_tree = FALSE, step=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulBMProcPhylTree_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a 
<code>nexus</code> file by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. 
The &quot;standard&quot; <span class="pkg">ape</span> node indexing is assumed: for a tree with <code class="reqn">n</code> tips, 
the tips should have indices <code>1:n</code> and the root index <code>n+1</code>.
The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_x0">X0</code></td>
<td>
<p>The ancestral, root state.</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_sigma">Sigma</code></td>
<td>
<p>The diffusion matrix of the Brownian motion.</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_dropinternal">dropInternal</code></td>
<td>
<p>Logical whether the simulated values at the internal nodes should be 
dropped.</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_fulltrajectory">fullTrajectory</code></td>
<td>
<p>Should the full realization of the process or only node and tip values 
be returned</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_jumpsetup">jumpsetup</code></td>
<td>
<p>Either <code>NULL</code> or list describing the jump at speciation. In the second 
case:
</p>

<dl>
<dt><code>jumptype</code></dt><dd><p>In what way does the jump take place. Possible values are <br />
<code>"ForBoth"</code> the jump occurs at speciation and is common to both daughter lineages,
<code>"RandomLineage"</code> the jump occurs just after speciation affecting exactly one
daughter lineage, both descending branches have the same chance of being affected,
<code>"JumpWithProb"</code> the jump occurs with probability <code>jumpprob</code>
just after speciation independently on each daughter lineage independently.
</p>
</dd>
<dt><code>jumpprob</code></dt><dd><p>A value in <code class="reqn">[0,1]</code> indicating the probability of a 
jump taking place, only matters if <code>jumptype</code> is <code>"JumpWithProb"</code> 
or <code>"JumpWithProb"</code>.</p>
</dd>
<dt><code>jumpdistrib</code></dt><dd><p>The distribution of the jump, currently only can take
value <code>"Normal"</code>.</p>
</dd>
<dt><code>vMean</code></dt><dd><p>The expected value of the jump, a vector of appropriate
length if the trait is multivariate.</p>
</dd>
<dt><code>mCov</code></dt><dd><p>The variance of the jump, a matrix of appropriate
dimensions if the trait is multivariate.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_keep_tree">keep_tree</code></td>
<td>
<p>Logical whether the used tree should be saved inside the output object.
Useful for any future reference, but as the tree is enhanced for <span class="pkg">mvSLOUCH</span>'s needs
the resulting output object may be very large (it the number of tips is large).</p>
</td></tr>
<tr><td><code id="simulBMProcPhylTree_+3A_step">step</code></td>
<td>
<p>The step size of the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fullTrajectory</code> is <code>FALSE</code> then 
returns a matrix with each row corresponding to a tree node and each column to a trait. 
Otherwise returns a more complex object describing the full realization of the process on the tree.
If <code>dropInternal</code> is <code>TRUE</code>, then the entries for the internal nodes are changed to 
<code>NA</code>s. The ordering of the rows corresponds to the order of the nodes (their indices) in 
the <code>phylo</code> object. Hence, the first <code>n</code> rows will be the tip rows 
(by common <code>phylo</code> convention).
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. (2014) 
Quantifying the effects of anagenetic and cladogenetic evolution. 
Mathematical Biosciences 254:42-57.
</p>
<p>Bartoszek, K. (2016) 
A Central Limit Theorem for punctuated equilibrium.
arXiv:1602.05189.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Felsenstein, J. (1985) 
Phylogenies and the comparative method.
American Naturalist 125:1-15.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code>, <code><a href="#topic+SummarizeBM">SummarizeBM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define Brownian motion parameters to be able to simulate data 
### under the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))

### Now simulate the data.
jumpobj&lt;-list(jumptype="RandomLineage",jumpprob=0.5,jumpdistrib="Normal",
vMean=rep(0,3),mCov=diag(1,3,3))
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx,
jumpsetup=jumpobj)
RNGversion(as.character(getRversion()))

</code></pre>

<hr>
<h2 id='simulMVSLOUCHProcPhylTree'>
Simulate data on a phylogeny under a (multivariate) OUBM model
</h2><span id='topic+simulMVSLOUCHProcPhylTree'></span>

<h3>Description</h3>

<p>Simulate data on a phylogeny under a (multivariate) OUBM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulMVSLOUCHProcPhylTree(phyltree, modelParams, regimes = NULL, 
regimes.times = NULL, dropInternal = TRUE, M.error=NULL, fullTrajectory=FALSE, 
jumpsetup=NULL,keep_tree=FALSE, step=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node 
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_modelparams">modelParams</code></td>
<td>

<p>List of model parameters of mvOUBM model as <code>ParamsInModel</code> part of output of <code>mvslouchModel</code>.
</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>.If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with 0 and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_dropinternal">dropInternal</code></td>
<td>
<p>Logical whether the simulated values at the internal nodes should be dropped.</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognizes the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_fulltrajectory">fullTrajectory</code></td>
<td>
<p>should the full realization of the process or only node and tip values 
be returned</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_jumpsetup">jumpsetup</code></td>
<td>
<p>Either <code>NULL</code> or list describing the jump at speciation. In the second 
case:
</p>

<dl>
<dt><code>jumptype</code></dt><dd><p>In what way does the jump take place. Possible values are <br />
<code>"ForBoth"</code> the jump occurs at speciation and is common to both daughter lineages,
<code>"RandomLineage"</code> the jump occurs just after speciation affecting exactly one
daughter lineage, both descending branches have the same chance of being affected,
<code>"JumpWithProb"</code> the jump occurs with probability <code>jumpprob</code>
just after speciation independently on each daughter lineage independently.
</p>
</dd>
<dt><code>jumpprob</code></dt><dd><p>A value in <code class="reqn">[0,1]</code> indicating the probability of a jump 
taking place, only matters if <code>jumptype</code> is <code>"JumpWithProb"</code>
or <code>"JumpWithProb"</code>.</p>
</dd>
<dt><code>jumpdistrib</code></dt><dd><p>The distribution of the jump, currently only can take
value <code>"Normal"</code>.</p>
</dd>
<dt><code>vMean</code></dt><dd><p>The expected value of the jump, a vector of appropriate
length if the trait is multivariate.</p>
</dd>
<dt><code>mCov</code></dt><dd><p>The variance of the jump, a matrix of appropriate
dimensions if the trait is multivariate.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_keep_tree">keep_tree</code></td>
<td>
<p>Logical whether the used tree should be saved inside the output object.
Useful for any future reference, but as the tree is enhanced for <span class="pkg">mvSLOUCH</span>'s needs
the resulting output object may be very large (it the number of tips is large).</p>
</td></tr>
<tr><td><code id="simulMVSLOUCHProcPhylTree_+3A_step">step</code></td>
<td>
<p>The step size of the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fullTrajectory</code> is <code>FALSE</code> then 
returns a matrix with each row corresponding to a tree node and each column to a trait. 
Otherwise returns a more complex object describing the full realization of the process on the tree.
If <code>dropInternal</code> is <code>TRUE</code>, then the entries for the internal nodes are changed to 
<code>NA</code>s. The ordering of the rows corresponds to the order of the nodes (their indices) in the 
<code>phylo</code> object. Hence, the first <code>n</code> rows will be the tip rows 
(by common <code>phylo</code> convention).
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. (2014) 
Quantifying the effects of anagenetic and cladogenetic evolution. 
Mathematical Biosciences 254:42-57.
</p>
<p>Bartoszek, K. (2016) 
A Central Limit Theorem for punctuated equilibrium.
arXiv:1602.05189.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and 
biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>
<p>Labra, A., Pienaar, J. &amp; Hansen, T.F. (2009) 
Evolution of thermophysiology in Liolaemus lizards: adaptation, phylogenetic 
inertia and niche tracking. 
The American Naturalist 174:204-220.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvslouchModel">mvslouchModel</a></code>, <code><a href="#topic+SummarizeMVSLOUCH">SummarizeMVSLOUCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the mvOUBM model.
OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))

### Now simulate the data.
jumpobj&lt;-list(jumptype="RandomLineage",jumpprob=0.5,jumpdistrib="Normal",
vMean=rep(0,3),mCov=diag(1,3,3))
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL,
jumpsetup=jumpobj)
RNGversion(as.character(getRversion()))

</code></pre>

<hr>
<h2 id='simulOUCHProcPhylTree'>
Simulate data on a phylogeny under a (multivariate) OU model
</h2><span id='topic+simulOUCHProcPhylTree'></span>

<h3>Description</h3>

<p>Simulate data on a phylogeny under a (multivariate) OU model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulOUCHProcPhylTree(phyltree, modelParams, regimes = NULL, 
regimes.times = NULL, dropInternal = TRUE, M.error=NULL, fullTrajectory=FALSE,
jumpsetup=NULL,keep_tree=FALSE,step=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulOUCHProcPhylTree_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node indexing 
is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> and the root 
index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_modelparams">modelParams</code></td>
<td>

<p>List of model parameters of OUOU model as <code>ParamsInModel</code> part of output of <code>ouchModel</code>.
</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>.If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with <code class="reqn">0</code> and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code> then each branch is
considered to be a regime.
</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_dropinternal">dropInternal</code></td>
<td>
<p>Logical whether the simulated values at the internal nodes should be dropped.</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_fulltrajectory">fullTrajectory</code></td>
<td>
<p>should the full realization of the process or only node and tip values 
be returned</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_jumpsetup">jumpsetup</code></td>
<td>
<p>Either <code>NULL</code> or list describing the jump at speciation. In the second 
case:
</p>

<dl>
<dt><code>jumptype</code></dt><dd><p>In what way does the jump take place. Possible values are <br />
<code>"ForBoth"</code> the jump occurs at speciation and is common to both daughter lineages,
<code>"RandomLineage"</code> the jump occurs just after speciation affecting exactly one
daughter lineage, both descending branches have the same chance of being affected,
<code>"JumpWithProb"</code> the jump occurs with probability <code>jumpprob</code>
just after speciation independently on each daughter lineage independently.
</p>
</dd>
<dt><code>jumpprob</code></dt><dd><p>A value in <code class="reqn">[0,1]</code> indicating the probability of a jump
taking place, only matters if <code>jumptype</code> is <code>"JumpWithProb"</code>
or <code>"JumpWithProb"</code>.</p>
</dd>
<dt><code>jumpdistrib</code></dt><dd><p>The distribution of the jump, currently only can take
value <code>"Normal"</code>.</p>
</dd>
<dt><code>vMean</code></dt><dd><p>The expected value of the jump, a vector of appropriate
length if the trait is multivariate.</p>
</dd>
<dt><code>mCov</code></dt><dd><p>The variance of the jump, a matrix of appropriate
dimensions if the trait is multivariate.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_keep_tree">keep_tree</code></td>
<td>
<p>Logical whether the used tree should be saved inside the output object.
Useful for any future reference, but as the tree is enhanced for <span class="pkg">mvSLOUCH</span>'s needs
the resulting output object may be very large (it the number of tips is large).</p>
</td></tr>
<tr><td><code id="simulOUCHProcPhylTree_+3A_step">step</code></td>
<td>
<p>The step size of the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fullTrajectory</code> is <code>FALSE</code> then 
returns a matrix with each row corresponding to a tree node and each column to a trait. 
Otherwise returns a more complex object describing the full realization of the process on the tree.
If <code>dropInternal</code> is <code>TRUE</code>, then the entries for the internal nodes are changed to 
<code>NA</code>s. The ordering of the rows corresponds to the order of the nodes (their indices) 
in the <code>phylo</code> object. Hence, the first <code>n</code> rows will be the tip rows 
(by common <code>phylo</code> convention).
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. (2014) 
Quantifying the effects of anagenetic and cladogenetic evolution. 
Mathematical Biosciences 254:42-57.
</p>
<p>Bartoszek, K. (2016) 
A Central Limit Theorem for punctuated equilibrium.
arXiv:1602.05189.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and 
biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="ouch.html#topic+hansen">hansen</a></code>, <code><a href="#topic+ouchModel">ouchModel</a></code>, <code><a href="#topic+simulOUCHProcPhylTree">simulOUCHProcPhylTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),
"large"=c(-1,1,0.5)),Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
jumpobj&lt;-list(jumptype="RandomLineage",jumpprob=0.5,jumpdistrib="Normal",
vMean=rep(0,3),mCov=diag(1,3,3))
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL,jumpsetup=jumpobj)
RNGversion(as.character(getRversion()))

</code></pre>

<hr>
<h2 id='SummarizeBM'>Summarize parameters estimated under a Brownian motion model</h2><span id='topic+SummarizeBM'></span>

<h3>Description</h3>

<p>Compiles a summary (appropriate moments, conditional moments, information criteria)
of parameters of a Brownian motion model at a given time point. The user is recommended to install 
suggested package <span class="pkg">PCMBaseCpp</span> which significantly speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SummarizeBM(phyltree, mData, modelParams, t = c(1), dof = NULL, M.error = NULL, 
predictors = NULL, min_bl = 0.0003)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SummarizeBM_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_modelparams">modelParams</code></td>
<td>

<p>A list of model parameters, as returned in <code>ParamsInModel</code> part of 
<br /> <code>BrownianMotionModel</code>'s output.
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_t">t</code></td>
<td>
<p>A vector of time points at which the summary is to be calculated. This allows for
one to study (and plot) the (conditional) mean and covariance as functions of time.
The function additionally returns the parameter summary at the tree's height.  
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_dof">dof</code></td>
<td>
<p>Number of unknown parameters in the model, can be extracted from the output of 
<code>BrownianMotionModel()</code>. If not provided all parameters are assumed unknown.
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from
<code>data</code> which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided, then none will be treated as predictors.
</p>
</td></tr>
<tr><td><code id="SummarizeBM_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The <code>phyltree_paths()</code> function enhances the tree for usage by <code>mvSLOUCH</code>. 
Hence, to save time, it is advisable to first do <code>phyltree&lt;-mvSLOUCH::phyltree_paths(phyltree)</code> 
and only then use it with <code>BrownianMotionModel()</code>.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<p>A list for each provided time point. See the help of <code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code> for 
what the summary at each time point is.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Felsenstein, J. (1985) 
Phylogenies and the comparative method.
American Naturalist 125:1-15.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BrownianMotionModel">BrownianMotionModel</a></code>, <code><a href="#topic+simulBMProcPhylTree">simulBMProcPhylTree</a></code>, <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define Brownian motion parameters to be able to simulate data 
### under the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))

### Now simulate the data.
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
BMdata&lt;-BMdata[phyltree$tip.label,,drop=FALSE]

### Recover the parameters of the Brownian motion.
BMestim&lt;-BrownianMotionModel(phyltree,BMdata)

### Summarize them.
BM.summary&lt;-SummarizeBM(phyltree,BMdata,BMestim$ParamsInModel,t=c(1),
dof=BMestim$ParamSummary$dof)
RNGversion(as.character(getRversion()))
#\dontrun
{ ##It takes too long to run this
### Now obtain bootstrap confidence intervals for some parameters.
BMbootstrap&lt;-parametric.bootstrap(estimated.model=BMestim,phyltree=phyltree,
values.to.bootstrap=c("vX0","StS"),,M.error=NULL,numboot=5)
}
</code></pre>

<hr>
<h2 id='SummarizeMVSLOUCH'>
Summarize parameters estimated under a multivariate OUBM motion model
</h2><span id='topic+SummarizeMVSLOUCH'></span>

<h3>Description</h3>

<p>Compiles a summary (appropriate moments, conditional moments, information criteria)
of parameters of a multivariate OUBM model at a given time point. The user is 
recommended to install the suggested package <span class="pkg">PCMBaseCpp</span> which significantly 
speeds up the calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SummarizeMVSLOUCH(phyltree, mData, modelParams, regimes = NULL, 
regimes.times = NULL, t = c(1), dof = NULL, M.error = NULL, predictors = NULL, 
Atype = "Invertible", Syytype = "UpperTri", min_bl = 0.0003, maxiter = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SummarizeMVSLOUCH_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_modelparams">modelParams</code></td>
<td>

<p>A list of model parameters, as returned in <code>ParamsInModel</code> part of <br /> <code>mvslouchModel</code>'s output.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>.If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with 0 and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code>, then each branch is
considered to be constant a regime.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_t">t</code></td>
<td>

<p>A vector of time points at which the summary is to be calculated. This allows for
one to study (and plot) the (conditional) mean and covariance as functions of time.
The function additionally returns the parameter summary at the tree's height.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_dof">dof</code></td>
<td>

<p>Number of unknown parameters in the model, can be extracted from the output of
<code>mvslouchModel()</code>. If not provided all parameters are assumed unknown.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_predictors">predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from
<code>data</code> which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided then columns <code>(kY+1):ncol(mData)</code>, i.e. the 
&quot;BM&quot; ones, are treated as predictors.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_atype">Atype</code></td>
<td>

<p>What class does the A matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>, 
<code>Symmetric</code>, <code>SymmetricPositiveDefinite</code>, <br />
<code>"DecomposablePositive"</code>, 
<code>"DecomposableNegative"</code>, <br />
<code>"DecomposableReal"</code>, <code>"Invertible"</code>,
<code>"TwoByTwo"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_syytype">Syytype</code></td>
<td>

<p>What class does the Syy matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>, 
<code>"Symmetric"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
<tr><td><code id="SummarizeMVSLOUCH_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations inside the GLS estimation procedure. In the first step 
regime optima and <code>B</code> (and perhaps initial state) are estimated conditional on the other parameters 
and current estimate   of <code>B</code>, then the estimate of <code>B</code> is update and the same phylogenetic GLS 
is repeated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If <code>A</code> is defective, then the output will be erroneous.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<p>A list for each provided time point. See the help of <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for what the 
summary at each time point is.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>
<p>Labra, A., Pienaar, J. &amp; Hansen, T.F. (2009) 
Evolution of thermophysiology in Liolaemus lizards: adaptation, phylogenetic inertia and niche tracking. 
The American Naturalist 174:204-220.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.
</p>


<h3>See Also</h3>

<p><code>slouch::model.fit</code>, <code><a href="#topic+mvslouchModel">mvslouchModel</a></code>, <code><a href="#topic+simulMVSLOUCHProcPhylTree">simulMVSLOUCHProcPhylTree</a></code>, 
<code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(3)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small")

### Define SDE parameters to be able to simulate data under the mvOUBM model.
OUBMparameters&lt;-list(vY0=matrix(1,ncol=1,nrow=1),A=matrix(0.5,ncol=1,nrow=1),
B=matrix(c(2),ncol=1,nrow=1),mPsi=cbind("small"=1,"large"=-1),
Syy=matrix(2,ncol=1,nrow=1),vX0=matrix(0,ncol=1,nrow=1),Sxx=diag(1,1,1),
Syx=matrix(0,ncol=1,nrow=1),Sxy=matrix(0,ncol=1,nrow=1))

### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

## Here we do not do any recovery step
OUBM.summary&lt;-SummarizeMVSLOUCH(phyltree,OUBMdata,OUBMparameters,
regimes,t=c(1),dof=7,maxiter=2)

RNGversion(as.character(getRversion()))
## Not run:  ##It takes too long to run this
## now less trivial simulation setup
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the mvOUBM model.
OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))

### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,]

### Try to recover the parameters of the mvOUBM model.
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,2,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive")

### Summarize them.
OUBM.summary&lt;-SummarizeMVSLOUCH(phyltree,OUBMdata,OUBMestim$FinalFound$ParamsInModel,
regimes,t=c(phyltree$tree_height),dof=OUBMestim$FinalFound$ParamSummary$dof,maxiter=50)

### And finally bootstrap with particular interest in the evolutionary and optimal
### regressions
OUBMbootstrap&lt;-parametric.bootstrap(estimated.model=OUBMestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression","optimal.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=2,
numboot=5,Atype="DecomposablePositive",Syytype="UpperTri",diagA="Positive")


## End(Not run)
</code></pre>

<hr>
<h2 id='SummarizeOUCH'>
Summarize parameters estimated under a (multivariate) OU motion model
</h2><span id='topic+SummarizeOUCH'></span>

<h3>Description</h3>

<p>Compiles a summary (appropriate moments, conditional moments, information criteria)
of parameters of a (multivariate) OU model at a given time point. The user is recommended 
to install the suggested package <span class="pkg">PCMBaseCpp</span> which significantly speeds up the 
calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SummarizeOUCH(phyltree, mData, modelParams, regimes = NULL, 
regimes.times = NULL, t = c(1), dof = NULL, M.error = NULL, 
predictors = NULL, Atype = "Invertible", Syytype = "UpperTri", min_bl = 0.0003)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SummarizeOUCH_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_mdata">mData</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be named by species <br /> (field <code>phyltree$tip.label</code>), if not, then a warning
is thrown and the order of the species is assumed to be the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). The columns should be named by traits, otherwise
a warning is thrown and generic names are generated.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_modelparams">modelParams</code></td>
<td>

<p>A list of model parameters, as returned in <code>ParamsInModel</code> part of <code>ouchModel</code>'s output.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_regimes">regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>.If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_regimes.times">regimes.times</code></td>
<td>

<p>A list of vectors for each tree node, it starts with 0 and ends with the current time of the species.
In between are the times where the regimes (niches) changed. If <code>NULL</code>, then each branch is
considered to be a regime.</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_t">t</code></td>
<td>

<p>A vector of time points at which the summary is to be calculated. This allows for
one to study (and plot) the (conditional) mean and covariance as functions of time.
The function additionally returns the parameter summary at the tree's height.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_dof">dof</code></td>
<td>

<p>Number of unknown parameters in the model, can be extracted from the output of
<code>ouchModel()</code>. If not provided all parameters are assumed unknown.
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_m.error">M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li><p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li><p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li><p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li><p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix, 
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li><p>NULL no measurement error.
</p>
</li></ul>

<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_predictors">predictors</code></td>
<td>
<p>A vector giving the numbers of the columns from <code>data</code> which are to be considered
predictor ones, <em>i.e.</em> conditioned on in the program output. If not provided, then none will be treated as 
predictors.</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_atype">Atype</code></td>
<td>

<p>What class does the A matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>Symmetric</code>, <code>SymmetricPositiveDefinite</code>, <br /> <code>"DecomposablePositive"</code>, 
<code>"DecomposableNegative"</code>, <br /> <code>"DecomposableReal"</code>, <code>"Invertible"</code>, <code>"TwoByTwo"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_syytype">Syytype</code></td>
<td>

<p>What class does the Syy matrix in the multivariate OUBM model belong to, possible values :
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>, <code>"UpperTri"</code>, <code>"LowerTri"</code>,
<code>"Symmetric"</code>, <code>"Any"</code>
</p>
</td></tr>
<tr><td><code id="SummarizeOUCH_+3A_min_bl">min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If <code>A</code> is defective, then the output will be erroneous.
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the data has to be passed as a matrix.
To underline this the data parameter's name has been changed to <code>mData</code>. 
</p>
<p>From version <code>2.0.0</code> of <span class="pkg">mvSLOUCH</span> the parameter <code>calcCI</code> has been removed. 
The package now offers the possibility of bootstrap confidence intervals, see
function <code>parametric.bootstrap</code>.
</p>


<h3>Value</h3>

<p>A list for each provided time point. See the help of <code><a href="#topic+mvslouchModel">mvslouchModel</a></code> for what the 
summary at each time point is.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological 
errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Pienaar et al (in prep) An overview of comparative methods for
testing adaptation to external environments.  
</p>


<h3>See Also</h3>

<p><code><a href="ouch.html#topic+hansen">hansen</a></code>, <code><a href="#topic+ouchModel">ouchModel</a></code>, <code><a href="#topic+simulOUCHProcPhylTree">simulOUCHProcPhylTree</a></code>, <code><a href="#topic+parametric.bootstrap">parametric.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape.
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define the SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),
"large"=c(-1,1,0.5)),Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

## Here we do not do any recovery step
OUOU.summary&lt;-SummarizeOUCH(phyltree,OUOUdata,OUOUparameters,
regimes,t=c(1),dof=15)
RNGversion(as.character(getRversion()))

## Not run:  ##It takes too long to run this
## Now we take a less trivial simulation setup
### Recover the parameters of the OUOU model.
OUOUestim&lt;-ouchModel(phyltree,OUOUdata,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive",maxiter=c(10,100))

### Summarize them.
OUOU.summary&lt;-SummarizeOUCH(phyltree,OUOUdata,OUOUestim$FinalFound$ParamsInModel,
regimes,t=c(1),dof=OUOUestim$FinalFound$ParamSummary$dof)


### And finally bootstrap with particular interest in the evolutionary regression
OUOUbootstrap&lt;-parametric.bootstrap(estimated.model=OUOUestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression"),regimes=regimes,root.regime="small",
M.error=NULL,predictors=c(3),kY=NULL,numboot=5,Atype=NULL,Syytype=NULL,diagA=NULL)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
