<!DOCTYPE html><html><head><title>Help for package ARGOS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ARGOS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alasso'><p>Adaptive Lasso</p></a></li>
<li><a href='#argos'><p>Automatic Regression for Governing Equations (ARGOS)</p></a></li>
<li><a href='#build_design_matrix'><p>Build Design Matrix</p></a></li>
<li><a href='#cubic2d_system'><p>Cubic 2D System</p></a></li>
<li><a href='#duffing_oscillator'><p>Duffing Oscillator</p></a></li>
<li><a href='#lasso'><p>Lasso</p></a></li>
<li><a href='#linear2d_system'><p>Linear 2D System</p></a></li>
<li><a href='#linear3d_system'><p>Linear 3D System</p></a></li>
<li><a href='#lorenz_system'><p>Lorenz Chaotic System</p></a></li>
<li><a href='#lotka_volterra'><p>Lotka-Volterra System</p></a></li>
<li><a href='#rossler_system'><p>Rossler Chaotic System</p></a></li>
<li><a href='#sg_optimal_combination'><p>Optimal Savitzky-Golay Filter Parameters Finder</p></a></li>
<li><a href='#vdp_oscillator'><p>Van der Pol Oscillator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Regression for Governing Equations (ARGOS)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Egan &lt;kevin.egan@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Comprehensive set of tools for performing system identification of both linear and nonlinear dynamical systems directly from data. The Automatic Regression for Governing Equations (ARGOS) simplifies the complex task of constructing mathematical models of dynamical systems from observed input and output data, supporting various types of systems, including those described by ordinary differential equations. It employs optimal numerical derivatives for enhanced accuracy and employs formal variable selection techniques to help identify the most relevant variables, thereby enabling the development of predictive models for system behavior analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, glmnet, Metrics, boot, tidyverse, magrittr, tidyr,
signal, parallel, deSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, devtools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/kevinegan31/ARGOS-Package&amp;gt;">https://github.com/kevinegan31/ARGOS-Package&gt;</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>Please report bugs and other issues to
&lt;kevin.egan@durham.ac.uk&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 15:30:03 UTC; kevinegan</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Egan [aut, cre],
  Weizhen Li [aut],
  Rui Carvalho [aut],
  Yuzheng Zhang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alasso'>Adaptive Lasso</h2><span id='topic+alasso'></span>

<h3>Description</h3>

<p>This function performs adaptive lasso regression using the cv.glmnet function,
then refits the model using ordinary least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alasso(data, index, weights_method = c("ols", "ridge"), ols_ps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alasso_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the predictors and response.
The response must be in the first column.</p>
</td></tr>
<tr><td><code id="alasso_+3A_index">index</code></td>
<td>
<p>A numeric vector of indices indicating the rows of 'data' to use
for the adaptive lasso regression.</p>
</td></tr>
<tr><td><code id="alasso_+3A_weights_method">weights_method</code></td>
<td>
<p>A character string specifying the method to calculate
the weights. Can be either &quot;ols&quot; or &quot;ridge&quot;. Default
is &quot;ols&quot;.</p>
</td></tr>
<tr><td><code id="alasso_+3A_ols_ps">ols_ps</code></td>
<td>
<p>A logical scalar. If TRUE (default), the function returns the
coefficients from the OLS fit. If FALSE, it returns the
coefficients from the lasso fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of coefficients. If 'ols_ps' is TRUE, these are the
coefficients from the OLS fit. If 'ols_ps' is FALSE, these are the
coefficients from the lasso fit. If an error occurs during the lasso
or OLS fit, the function returns a vector of NAs.
</p>

<hr>
<h2 id='argos'>Automatic Regression for Governing Equations (ARGOS)</h2><span id='topic+argos'></span>

<h3>Description</h3>

<p>This function performs sparse regression on a data set to identify the
governing equations of the system. It takes a list of data from
'build_design_matrix' then applies the Lasso or Adaptive Lasso for variable
selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argos(
  design_matrix,
  library_type = c("poly", "four", "poly_four"),
  state_var_deriv = 1,
  alpha_level = 0.05,
  num_samples = 2000,
  sr_method = c("lasso", "alasso"),
  weights_method = NULL,
  ols_ps = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncpus = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argos_+3A_design_matrix">design_matrix</code></td>
<td>
<p>A list containing data frame, vector of predictor
variable orders for 'theta', and derivative matrix.</p>
</td></tr>
<tr><td><code id="argos_+3A_library_type">library_type</code></td>
<td>
<p>A character vector (default: c(&quot;poly&quot;, &quot;four&quot;,
&quot;poly_four&quot;)) specifying the type of library being used.</p>
</td></tr>
<tr><td><code id="argos_+3A_state_var_deriv">state_var_deriv</code></td>
<td>
<p>An integer. The index of the state variable for which
the derivative is calculated. Default is 1.</p>
</td></tr>
<tr><td><code id="argos_+3A_alpha_level">alpha_level</code></td>
<td>
<p>A numeric scalar. The level of significance for
confidence intervals. Default is 0.05.</p>
</td></tr>
<tr><td><code id="argos_+3A_num_samples">num_samples</code></td>
<td>
<p>An integer. The number of bootstrap samples. Default is
2000.</p>
</td></tr>
<tr><td><code id="argos_+3A_sr_method">sr_method</code></td>
<td>
<p>A character string. The sparse regression method to be used,
either &quot;lasso&quot; or &quot;alasso&quot;. Default is &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="argos_+3A_weights_method">weights_method</code></td>
<td>
<p>A string or NULL. The method for calculating weights in
the Adaptive Lasso. If NULL, ridge regression pilot
estimates are used. Default is NULL.</p>
</td></tr>
<tr><td><code id="argos_+3A_ols_ps">ols_ps</code></td>
<td>
<p>A logical. If TRUE, post-selection OLS is performed after the
Lasso or Adaptive Lasso. Default is TRUE.</p>
</td></tr>
<tr><td><code id="argos_+3A_parallel">parallel</code></td>
<td>
<p>A character string. The type of parallel computation to be
used, either &quot;no&quot;, &quot;multicore&quot; or &quot;snow&quot;. Default is &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="argos_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer or NULL. The number of cores to be used in parallel
computation. If NULL, the function will try to detect the
number of cores. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements:
- point_estimates: a vector of point estimates for the coefficients.
- ci: a matrix where each column represents the lower and upper bounds of
the confidence interval for a coefficient.
- identified_model: a matrix of coefficients of the identified model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Identify the x1 equation of the Duffing Oscillator with ARGOS.
# Output provides point estimates, confidence intervals, and identified model.
x_t &lt;- duffing_oscillator(n=1000, dt = 0.01,
                          init_conditions = c(1, 0),
                          gamma_value = 0.1, kappa_value = 1,
                          epsilon_value = 5, snr = 49)
duffing_design_matrix &lt;-
       build_design_matrix(x_t, dt = 0.01, sg_poly_order = 4,
                           library_degree = 5, library_type = "poly")
design_matrix &lt;- duffing_design_matrix
state_var_deriv = 1 # Denotes first equation/derivative to be identified
alpha_level = 0.05
num_samples = 10
sr_method = "lasso"
weights_method = NULL
ols_ps = TRUE
parallel = "no"
ncpus = NULL
library_type &lt;- "poly"
perform_argos &lt;- argos(design_matrix = design_matrix,
                       library_type = library_type,
                       state_var_deriv = state_var_deriv,
                       alpha_level = alpha_level,
                       num_samples = num_samples,
                       sr_method = "lasso",
                       weights_method = NULL,
                       ols_ps = TRUE,
                       parallel = "no",
                       ncpus = NULL)
perform_argos$point_estimates
perform_argos$ci
perform_argos$identified_model
</code></pre>

<hr>
<h2 id='build_design_matrix'>Build Design Matrix</h2><span id='topic+build_design_matrix'></span>

<h3>Description</h3>

<p>This function first smooths the data and approximates the
derivative before building the design matrix to include monomial and fourier
terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_design_matrix(
  x_t,
  dt = 1,
  sg_poly_order = 4,
  library_degree = 5,
  library_type = c("poly", "four", "poly_four")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_design_matrix_+3A_x_t">x_t</code></td>
<td>
<p>Matrix of observations.</p>
</td></tr>
<tr><td><code id="build_design_matrix_+3A_dt">dt</code></td>
<td>
<p>Time step (default is 1).</p>
</td></tr>
<tr><td><code id="build_design_matrix_+3A_sg_poly_order">sg_poly_order</code></td>
<td>
<p>Polynomial order for Savitzky-Golay Filter.</p>
</td></tr>
<tr><td><code id="build_design_matrix_+3A_library_degree">library_degree</code></td>
<td>
<p>Degree of polynomial library (default is 5).</p>
</td></tr>
<tr><td><code id="build_design_matrix_+3A_library_type">library_type</code></td>
<td>
<p>Type of library to use. Can be one of &quot;poly&quot;,
&quot;four&quot;, or &quot;poly_four&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>sorted_theta</code> - A matrix with sorted polynomial/trigonometric
terms.
</p>
</li>
<li> <p><code>monomial_orders</code> - A vector indicating the order of each
polynomial term.
</p>
</li>
<li> <p><code>xdot_filtered</code> - A matrix with derivative terms
(dependent variable).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Build a design matrix using the Duffing Oscillator as the state-space.
# Output provides matrix, and derivative matrix monomial orders
# (needed for running `argos`).
x_t &lt;- duffing_oscillator(n=5000, dt = 0.01,
                          init_conditions = c(1, 0),
                          gamma_value = 0.1, kappa_value = 1,
                          epsilon_value = 5, snr = 49)
duffing_design_matrix &lt;-
         build_design_matrix(x_t, dt = 0.01, sg_poly_order = 4,
                             library_degree = 5, library_type = "poly")
head(duffing_design_matrix$sorted_theta)
</code></pre>

<hr>
<h2 id='cubic2d_system'>Cubic 2D System</h2><span id='topic+cubic2d_system'></span>

<h3>Description</h3>

<p>Simulates a two-dimensional damped oscillator with cubic dynamics and optional
noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubic2d_system(n, init_conditions, dt, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubic2d_system_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="cubic2d_system_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="cubic2d_system_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="cubic2d_system_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a two-dimensional damped oscillator with cubic dynamics.
It uses the specified time step and initial conditions to compute the system's
state over time. If a non-Infinite SNR is provided, Gaussian noise is added to
the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a 2D cubic system with 100 time points and no noise
data &lt;- cubic2d_system(n = 100, init_conditions = c(1, 2), dt = 0.01, snr = Inf)

</code></pre>

<hr>
<h2 id='duffing_oscillator'>Duffing Oscillator</h2><span id='topic+duffing_oscillator'></span>

<h3>Description</h3>

<p>Simulates the Duffing oscillator with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duffing_oscillator(
  n,
  dt,
  init_conditions,
  gamma_value,
  kappa_value,
  epsilon_value,
  snr = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duffing_oscillator_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_gamma_value">gamma_value</code></td>
<td>
<p>Value of gamma parameter.</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_kappa_value">kappa_value</code></td>
<td>
<p>Value of kappa parameter.</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_epsilon_value">epsilon_value</code></td>
<td>
<p>Value of epsilon parameter.</p>
</td></tr>
<tr><td><code id="duffing_oscillator_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a Duffing oscillator with the specified parameters.
It uses the specified time step and initial conditions to compute the system's
state over time. If a non-Infinite SNR is provided, Gaussian noise is added to
the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Duffing oscillator with 100 time points and no noise
data &lt;- duffing_oscillator(
  n = 100,
  dt = 0.01,
  init_conditions = c(2, 6),
  gamma_value = 0.1,
  kappa_value = 1,
  epsilon_value = 5,
  snr = Inf
)

</code></pre>

<hr>
<h2 id='lasso'>Lasso</h2><span id='topic+lasso'></span>

<h3>Description</h3>

<p>This function performs lasso regression using the cv.glmnet function,
then refits the model using ordinary least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso(data, index, ols_ps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the predictors and response.
The response must be in the first column.</p>
</td></tr>
<tr><td><code id="lasso_+3A_index">index</code></td>
<td>
<p>A numeric vector of indices indicating the rows of 'data' to
use for the lasso regression.</p>
</td></tr>
<tr><td><code id="lasso_+3A_ols_ps">ols_ps</code></td>
<td>
<p>A logical scalar. If TRUE (default), the function returns the
coefficients from the OLS fit. If FALSE, it returns the
coefficients from the lasso fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of coefficients. If 'ols_ps' is TRUE, these are the
coefficients from the OLS fit. If 'ols_ps' is FALSE, these are the
coefficients from the lasso fit. If an error occurs during the lasso
or OLS fit, the function returns a vector of NAs.
</p>

<hr>
<h2 id='linear2d_system'>Linear 2D System</h2><span id='topic+linear2d_system'></span>

<h3>Description</h3>

<p>Simulates a two-dimensional damped oscillator with linear dynamics and optional
noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear2d_system(n, init_conditions, dt, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear2d_system_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="linear2d_system_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="linear2d_system_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="linear2d_system_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a two-dimensional damped oscillator with linear dynamics.
It uses the specified time step and initial conditions to compute the system's
state over time. If a non-Infinite SNR is provided, Gaussian noise is added to
the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a 2D linear system with 100 time points and no noise
data &lt;- linear2d_system(n = 100, init_conditions = c(-1, 1), dt = 0.01, snr = Inf)

</code></pre>

<hr>
<h2 id='linear3d_system'>Linear 3D System</h2><span id='topic+linear3d_system'></span>

<h3>Description</h3>

<p>Simulates a three-dimensional linear dynamical system with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear3d_system(n, init_conditions, dt, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear3d_system_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="linear3d_system_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 3.</p>
</td></tr>
<tr><td><code id="linear3d_system_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="linear3d_system_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a three-dimensional linear dynamical system.
It uses the specified time step and initial conditions to compute the system's
state over time. If a non-Infinite SNR is provided, Gaussian noise is added to
the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a 3D linear system with 100 time points and no noise
data &lt;- linear3d_system(n = 100, init_conditions = c(1, 2, 3), dt = 0.01, snr = Inf)

</code></pre>

<hr>
<h2 id='lorenz_system'>Lorenz Chaotic System</h2><span id='topic+lorenz_system'></span>

<h3>Description</h3>

<p>Simulates the Lorenz chaotic system with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenz_system(n, init_conditions, dt, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenz_system_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="lorenz_system_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 3 (X, Y, Z).</p>
</td></tr>
<tr><td><code id="lorenz_system_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="lorenz_system_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the Lorenz chaotic system with the specified
parameters. It uses the specified time step and initial conditions to compute
the system's state over time. If a non-Infinite SNR is provided, Gaussian noise
is added to the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable (X, Y, Z).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Lorenz system with 1000 time points and no noise
data &lt;- lorenz_system(
  n = 1000,
  dt = 0.01,
  init_conditions = c(-8, 7, 27),
  snr = Inf
)

</code></pre>

<hr>
<h2 id='lotka_volterra'>Lotka-Volterra System</h2><span id='topic+lotka_volterra'></span>

<h3>Description</h3>

<p>Simulates the Lotka-Volterra predator-prey system with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lotka_volterra(n, init_conditions, dt, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lotka_volterra_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="lotka_volterra_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="lotka_volterra_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="lotka_volterra_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the Lotka-Volterra predator-prey system with the
specified parameters. It uses the specified time step and initial conditions
to compute the system's state over time. If a non-Infinite SNR is provided,
Gaussian noise is added to the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Lotka-Volterra system with 100 time points and no noise
data &lt;- lotka_volterra(
  n = 100,
  dt = 0.01,
  init_conditions = c(2, 1),
  snr = Inf
)

</code></pre>

<hr>
<h2 id='rossler_system'>Rossler Chaotic System</h2><span id='topic+rossler_system'></span>

<h3>Description</h3>

<p>Simulates the Rossler chaotic system with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rossler_system(n, dt, init_conditions, a, b, c, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rossler_system_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 3 (X, Y, Z).</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_a">a</code></td>
<td>
<p>Rossler parameter 1</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_b">b</code></td>
<td>
<p>Rossler parameter 2</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_c">c</code></td>
<td>
<p>Rossler parameter 3</p>
</td></tr>
<tr><td><code id="rossler_system_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the Rossler chaotic system with the specified
parameters. It uses the specified time step and initial conditions to compute
the system's state over time. If a non-Infinite SNR is provided, Gaussian noise
is added to the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable (X, Y, Z).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Rossler system with 1000 time points and no noise
data &lt;- rossler_system(
  n = 1000,
  dt = 0.01,
  init_conditions = c(0, 2, 0),
  a = 0.2, b = 0.2, c = 5.7,
  snr = Inf
)

</code></pre>

<hr>
<h2 id='sg_optimal_combination'>Optimal Savitzky-Golay Filter Parameters Finder</h2><span id='topic+sg_optimal_combination'></span>

<h3>Description</h3>

<p>This function finds the optimal parameters for the Savitzky-Golay filter
by evaluating combinations of polynomial orders and window lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_optimal_combination(x_t, dt = 1, polyorder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_optimal_combination_+3A_x_t">x_t</code></td>
<td>
<p>A numeric vector or one-column matrix. The data to be smoothed.</p>
</td></tr>
<tr><td><code id="sg_optimal_combination_+3A_dt">dt</code></td>
<td>
<p>A numeric scalar. The time-step interval of the data. Default is 1.</p>
</td></tr>
<tr><td><code id="sg_optimal_combination_+3A_polyorder">polyorder</code></td>
<td>
<p>A numeric scalar. The order of the polynomial to be used in
the Savitzky-Golay filter. If not specified, 4 will be used
by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements:
- sg_combinations: a matrix where each row represents a combination of
polynomial order and window length tried.
- sg_order_wl: a vector of length 2 with the optimal polynomial order and
window length.
- f_dist: a data frame with the mean squared error of the differences
between the original data and the smoothed data for each
combination.
</p>

<hr>
<h2 id='vdp_oscillator'>Van der Pol Oscillator</h2><span id='topic+vdp_oscillator'></span>

<h3>Description</h3>

<p>Simulates the Van der Pol oscillator with optional noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdp_oscillator(n, dt, init_conditions, mu, snr = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdp_oscillator_+3A_n">n</code></td>
<td>
<p>Number of time points (rounded to the nearest integer).</p>
</td></tr>
<tr><td><code id="vdp_oscillator_+3A_dt">dt</code></td>
<td>
<p>Time step between observations.</p>
</td></tr>
<tr><td><code id="vdp_oscillator_+3A_init_conditions">init_conditions</code></td>
<td>
<p>Initial conditions as a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="vdp_oscillator_+3A_mu">mu</code></td>
<td>
<p>Parameter controlling the nonlinear damping level of the system.</p>
</td></tr>
<tr><td><code id="vdp_oscillator_+3A_snr">snr</code></td>
<td>
<p>Signal-to-noise ratio (in dB). Use Inf for no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates a Van der Pol oscillator with the specified parameters.
It uses the specified time step and initial conditions to compute the system's
state over time. If a non-Infinite SNR is provided, Gaussian noise is added to
the system.
</p>


<h3>Value</h3>

<p>A numeric matrix representing the system's state over time. Each row
corresponds to a time point, and each column represents a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Van der Pol oscillator with 100 time points and no noise
data &lt;- vdp_oscillator(
  n = 100,
  dt = 0.01,
  init_conditions = c(-1, 1),
  mu = 1.2,
  snr = Inf
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
