<!DOCTYPE html><html><head><title>Help for package simex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simex-package'><p>Error or misclassification correction in models using (MC)SIMEX</p></a></li>
<li><a href='#diag.block'><p>Constructs a block diagonal matrix</p></a></li>
<li><a href='#mc.matrix'><p>Build and check misclassification matrices from empirical estimations</p></a></li>
<li><a href='#mcsimex'><p>Misclassification in models using MCSIMEX</p></a></li>
<li><a href='#misclass'><p>Generates misclassified data</p></a></li>
<li><a href='#simex'><p>Measurement error in models using SIMEX</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-28</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mgcv, nlme, MASS, survival</td>
</tr>
<tr>
<td>Title:</td>
<td>SIMEX- And MCSIMEX-Algorithm for Measurement Error Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the SIMEX-Algorithm by Cook &amp; Stefanski (1994) &lt;<a href="https://doi.org/10.1080%2F01621459.1994.10476871">doi:10.1080/01621459.1994.10476871</a>&gt; and
    MCSIMEX by Küchenhoff, Mwalili &amp; Lesaffre (2006) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2005.00396.x">doi:10.1111/j.1541-0420.2005.00396.x</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://wolfganglederer.github.io/simex/">http://wolfganglederer.github.io/simex/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wolfganglederer/simex/issues">https://github.com/wolfganglederer/simex/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ZipData:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-30 23:54:30 UTC; Wolfgang</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Lederer [cre, aut],
  Heidi Seibold [aut],
  Helmut Küchenhoff [ctb],
  Chris Lawrence [ctb],
  Rasmus Froberg Brøndum [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wolfgang Lederer &lt;Wolfgang.Lederer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-31 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simex-package'>Error or misclassification correction in models using (MC)SIMEX</h2><span id='topic+simex-package'></span>

<h3>Description</h3>

<p>Package <code>simex</code> is an implementation of the SIMEX&ndash;algorithm by Cook
and Stephanski and the MCSIMEX&ndash;Algorithm by Küchenhoff, Mwalili and Lesaffre.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> simex</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.8</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2019-07-28</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL 2 or above</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The package includes first of all the implementation for the SIMEX&ndash; and
MCSIMEX&ndash;Algorithms. Jackknife and asymptotic variance estimation are
implemented. Various methods and analytic tools are provided for a simple and
fast access to the SIMEX&ndash; and MCSIMEX&ndash;Algorithm.
</p>
<p>Functions <code>simex()</code> and <code>mcsimex()</code> can be used on models issued
from <code>lm()</code>, <code>glm()</code> with asymtotic estimation.
Models from <code>nls()</code>, <code>gam()</code> (package <span class="pkg">mgcv</span>),
<code>polr()</code> (package <span class="pkg">MASS</span>),
<code>lme()</code>, <code>nlme()</code> (package <span class="pkg">nlme</span>) and <code>coxph()</code> (package <span class="pkg">survival</span>) can also be corrected with
these algorithms, but without asymptotic estimations.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Lederer, Heidi Seibold, Helmut Küchenhoff
</p>
<p>Maintainer: Wolfgang Lederer,<a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>


<h3>References</h3>

<p>Lederer, W. and Küchenhoff, H. (2006) A short introduction to the SIMEX and
MCSIMEX. <em>R News</em>, <b>6/4</b>, 26 &ndash; 31
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simex">simex</a></code>, <code><a href="#topic+mcsimex">mcsimex</a></code>, <code><a href="#topic+misclass">misclass</a></code>
</p>
<p>and for functions generating the initial naive models:
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code>nls</code>,
<code>gam</code>, <code>lme</code>, <code>nlme</code>, <code>polr</code>, <code>coxph</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example(simex) and example(mcsimex)
## Seed
set.seed(49494)

## simulating the measurement error standard deviations
sd_me1 &lt;- 0.3
sd_me2 &lt;- 0.4
temp &lt;- runif(100, min = 0, max = 0.6)
sd_me_het1 &lt;- sort(temp)
temp2 &lt;- rnorm(100, sd = 0.1)
sd_me_het2 &lt;- abs(sd_me_het1 + temp2)

## simulating the independent variables x (real and with measurement error):
x_real1 &lt;- rnorm(100)
x_real2 &lt;- rpois(100, lambda = 2)
x_real3 &lt;- -4*x_real1 + runif(100, min = -2, max = 2)  # correlated to x_real

x_measured1 &lt;- x_real1 + sd_me1 * rnorm(100)
x_measured2 &lt;- x_real2 + sd_me2 * rnorm(100)
x_het1 &lt;- x_real1 + sd_me_het1 * rnorm(100)
x_het2 &lt;- x_real3 + sd_me_het2 * rnorm(100)

## calculating dependent variable y:
y1  &lt;- x_real1 + rnorm(100, sd = 0.05)
y2 &lt;- x_real1 + 2*x_real2 + rnorm(100, sd = 0.08)
y3 &lt;- x_real1 + 2*x_real3 + rnorm(100, sd = 0.08)


### one variable with homoscedastic measurement error
(model_real &lt;- lm(y1  ~ x_real1))

(model_naiv &lt;- lm(y1  ~ x_measured1, x = TRUE))

(model_simex &lt;- simex(model_naiv, SIMEXvariable = "x_measured1", measurement.error = sd_me1))
plot(model_simex)


### two variables with homoscedastic measurement errors
(model_real2 &lt;- lm(y2 ~ x_real1 + x_real2))

(model_naiv2 &lt;- lm(y2 ~ x_measured1 + x_measured2, x = TRUE))

(model_simex2 &lt;- simex(model_naiv2, SIMEXvariable = c("x_measured1", "x_measured2"),
                       measurement.error = cbind(sd_me1, sd_me2)))

plot(model_simex2)


### one variable with increasing heteroscedastic measurement error
model_real

(mod_naiv1 &lt;- lm(y1  ~ x_het1, x = TRUE))

(mod_simex1 &lt;- simex(mod_naiv1, SIMEXvariable = "x_het1",
     measurement.error = sd_me_het1, asymptotic = FALSE))

plot(mod_simex1)

## Not run: 
### two correlated variables with heteroscedastic measurement errors
(model_real3 &lt;- lm(y3 ~ x_real1 + x_real3))

(mod_naiv2 &lt;- lm(y3 ~ x_het1 + x_het2, x = TRUE))

(mod_simex2 &lt;- simex(mod_naiv2, SIMEXvariable = c("x_het1", "x_het2"),
                     measurement.error = cbind(sd_me_het1, sd_me_het2), asymptotic = FALSE))
plot(mod_simex2)


### two variables, one with homoscedastic, one with heteroscedastic measurement error
model_real2

(mod_naiv3 &lt;- lm(y2 ~ x_measured1 + x_het2, x = TRUE))

(mod_simex3 &lt;- simex(mod_naiv3, SIMEXvariable = c("x_measured1", "x_het2"),
                     measurement.error = cbind(sd_me1, sd_me_het2), asymptotic = FALSE))


### glm: two variables, one with homoscedastic, one with heteroscedastic measurement error
t &lt;- x_real1 + 2*x_real2
g &lt;- 1 / (1 + exp(-t))
u &lt;- runif(100)
ybin &lt;- as.numeric(u &lt; g)


(logit_real &lt;- glm(ybin ~ x_real1 + x_real2, family = binomial))

(logit_naiv &lt;- glm(ybin ~ x_measured1 + x_het2, x = TRUE, family = binomial))

(logit_simex &lt;- simex(logit_naiv, SIMEXvariable = c("x_measured1", "x_het2"),
                      measurement.error = cbind(sd_me1, sd_me_het2), asymptotic = FALSE))
summary(logit_simex)
print(logit_simex)
plot(logit_simex)

## End(Not run)
</code></pre>

<hr>
<h2 id='diag.block'>Constructs a block diagonal matrix</h2><span id='topic+diag.block'></span>

<h3>Description</h3>

<p>The function takes a <code>list</code> and constructs a block diagonal matrix with
the elements of the list on the diagonal. If <code>d</code> is not a list then
<code>d</code> will be repeated <code>n</code> times and written on the diagonal (a wrapper for <code>kronecker()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.block(d, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag.block_+3A_d">d</code></td>
<td>
<p>a <code>list</code> of matrices or vectors, or a matrix or vector</p>
</td></tr>
<tr><td><code id="diag.block_+3A_n">n</code></td>
<td>
<p>number of repetitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix with the elements of the list or the repetitions of the supplied matrix or vector on the diagonal.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Lederer, <a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>, <code><a href="base.html#topic+kronecker">kronecker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(rep(1, 4), nrow = 2)
b &lt;- matrix(rep(2, 6), nrow = 2)
e &lt;- c(3, 3, 3, 3)
f &lt;- t(e)
d &lt;- list(a, b, e, f)
diag.block(d)
diag.block(a, 3)

</code></pre>

<hr>
<h2 id='mc.matrix'>Build and check misclassification matrices from empirical estimations</h2><span id='topic+mc.matrix'></span><span id='topic+build.mc.matrix'></span><span id='topic+check.mc.matrix'></span>

<h3>Description</h3>

<p>Empirical misclassification matrices to the power of lambda may not exist for
small values of lambda. These functions provide methods to estimate the nearest
version of the misclassification matrix that satisfies the conditions a
misclassification matrix has to fulfill, and to check it (existance for exponents
smaller than 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.mc.matrix(mc.matrix, method = "series",
  tuning = sqrt(.Machine$double.eps), diag.cor = FALSE,
  tol = .Machine$double.eps, max.iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.matrix_+3A_mc.matrix">mc.matrix</code></td>
<td>
<p>an empirical misclassification matrix</p>
</td></tr>
<tr><td><code id="mc.matrix_+3A_method">method</code></td>
<td>
<p>method used to estimate the generator for the misclassification matrix. One of &quot;series&quot;, &quot;log&quot; or &quot;jlt&quot; (see Details)</p>
</td></tr>
<tr><td><code id="mc.matrix_+3A_tuning">tuning</code></td>
<td>
<p>security parameter for numerical reasons</p>
</td></tr>
<tr><td><code id="mc.matrix_+3A_diag.cor">diag.cor</code></td>
<td>
<p>should corrections be substracted from the diagonal or from all values corresponding to the size?</p>
</td></tr>
<tr><td><code id="mc.matrix_+3A_tol">tol</code></td>
<td>
<p>tolerance level for series method for convegence</p>
</td></tr>
<tr><td><code id="mc.matrix_+3A_max.iter">max.iter</code></td>
<td>
<p>maximal number of iterations for the series method to converge.
Ignored if method is not &quot;series&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method &quot;series&quot; constructs a generator via the series
</p>
<p><code class="reqn">(Pi-I) - (Pi-I)^2/2 + (Pi-I)^3/3 - \dots</code>
</p>
<p>Method &quot;log&quot; constructs the generator via taking the log of the misclassification matrix. Small negative off-diagonal values are corrected and set to (0 + tuning).
The amount used to correct for negative values is added to the diagonal element if <code>diag.cor = TRUE</code> and distributed among all values if <code>diag.cor = FALSE</code>.
</p>
<p>Method &quot;jlt&quot; uses the method described by Jarrow et al. (see Israel et al.).
</p>


<h3>Value</h3>

<p><code>build.mc.matrix()</code> returns a misclassification matrix that is the closest estimate for a working misclassification matrix.
</p>
<p><code>check.mc.matrix()</code> returns a vector of logicals.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Lederer, <a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>


<h3>References</h3>

<p>Israel, R.B., Rosenthal, J.S., Wei, J.Z., Finding generators for Markov Chains via empirical transition matrices, with applications to credit ratings,<em>Mathematical Finance</em>, <b>11</b>, 245&ndash;265
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcsimex">mcsimex</a></code>, <code><a href="#topic+misclass">misclass</a></code>, <code><a href="#topic+diag.block">diag.block</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pi &lt;- matrix(data = c(0.989, 0.01, 0.001, 0.17, 0.829, 0.001, 0.001, 0.18, 0.819),
nrow = 3, byrow = FALSE)
check.mc.matrix(list(Pi))
check.mc.matrix(list(build.mc.matrix(Pi)))
build.mc.matrix(Pi)

Pi3 &lt;- matrix(c(0.8, 0.2, 0, 0, 0, 0.8, 0.1, 0.1, 0, 0.1, 0.8, 0.1, 0, 0, 0.3, 0.7), nrow = 4)
check.mc.matrix(list(Pi3))
build.mc.matrix(Pi3)
check.mc.matrix(list(build.mc.matrix(Pi3)))
P1 &lt;- matrix(c(1, 0, 0, 1), nrow = 2)
P2 &lt;- matrix(c(0.8, 0.15, 0, 0.2, 0.7, 0.2, 0, 0.15, 0.8), nrow = 3, byrow = TRUE)
P3 &lt;- matrix(c(0.4, 0.6, 0.6, 0.4), nrow = 2)
mc.matrix &lt;- list(P1, P2, P3)
check.mc.matrix(mc.matrix) # TRUE FALSE FALSE

</code></pre>

<hr>
<h2 id='mcsimex'>Misclassification in models using MCSIMEX</h2><span id='topic+mcsimex'></span><span id='topic+print.mcsimex'></span><span id='topic+summary.mcsimex'></span><span id='topic+print.summary.mcsimex'></span><span id='topic+plot.mcsimex'></span><span id='topic+predict.mcsimex'></span><span id='topic+refit.mcsimex'></span>

<h3>Description</h3>

<p>Implementation of the misclassification MCSIMEX algorithm as described by Küchenhoff, Mwalili and Lesaffre.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcsimex(model, SIMEXvariable, mc.matrix, lambda = c(0.5, 1, 1.5, 2),
  B = 100, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE)

## S3 method for class 'mcsimex'
plot(x, xlab = expression((1 + lambda)),
  ylab = colnames(b)[-1], ask = FALSE, show = rep(TRUE, NCOL(b) - 1),
  ...)

## S3 method for class 'mcsimex'
predict(object, newdata, ...)

## S3 method for class 'mcsimex'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'summary.mcsimex'
print(x, digits = max(3, getOption("digits") -
  3), ...)

## S3 method for class 'mcsimex'
summary(object, ...)

## S3 method for class 'mcsimex'
refit(object, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcsimex_+3A_model">model</code></td>
<td>
<p>the naive model, the misclassified variable must be a factor</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_simexvariable">SIMEXvariable</code></td>
<td>
<p>vector of names of the variables for which the MCSIMEX-method should be applied</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_mc.matrix">mc.matrix</code></td>
<td>
<p>if one variable is misclassified it can be a matrix. If more
than one variable is misclassified it must be a list of the misclassification
matrices, names must match with the SIMEXvariable names, column- and row-names
must match with the factor levels. If a special misclassification is desired,
the name of a function can be specified (see details)</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_lambda">lambda</code></td>
<td>
<p>vector of exponents for the misclassification matrix (without 0)</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_b">B</code></td>
<td>
<p>number of iterations for each lambda</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_fitting.method">fitting.method</code></td>
<td>
<p><code>linear</code>, <code>quadratic</code> and <code>loglinear</code>
are implemented (first 4 letters are enough)</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_jackknife.estimation">jackknife.estimation</code></td>
<td>
<p>specifying the extrapolation method for jackknife
variance estimation. Can be set to <code>FALSE</code> if it should not be performed</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_asymptotic">asymptotic</code></td>
<td>
<p>logical, indicating if asymptotic variance estimation should
be done, the option <code>x = TRUE</code> must be enabled in the naive model</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_x">x</code></td>
<td>
<p>object of class 'mcsimex'</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_xlab">xlab</code></td>
<td>
<p>optional name for the X-Axis</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_ylab">ylab</code></td>
<td>
<p>vector containing the names for the Y-Axis</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_ask">ask</code></td>
<td>
<p>ogical. If <code>TRUE</code>, the user is asked for input, before a new figure is drawn</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_show">show</code></td>
<td>
<p>vector of logicals indicating for which variables a plot should be produced</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_object">object</code></td>
<td>
<p>object of class 'mcsimex'</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the fitted linear predictors are used</p>
</td></tr>
<tr><td><code id="mcsimex_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mc.matrix</code> is a function the first argument of that function must
be the whole dataset used in the naive model, the second argument must be
the exponent (lambda) for the misclassification. The function must return
a <code>data.frame</code> containing the misclassified <code>SIMEXvariable</code>. An
example can be found below.
</p>
<p>Asymptotic variance estimation is only implemented for <code>lm</code> and <code>glm</code>
</p>
<p>The loglinear fit has the form <code>g(lambda, GAMMA) = exp(gamma0 + gamma1 * lambda)</code>.
It is realized via the <code>log()</code> function. To avoid negative values the
minimum +1 of the dataset is added and after the prediction later substracted
<code>exp(predict(...)) - min(data) - 1</code>.
</p>
<p>The 'log2' fit is fitted via the <code>nls()</code> function for direct fitting of
the model <code>y ~ exp(gamma.0 + gamma.1 * lambda)</code>. As starting values the
results of a LS-fit to a linear model with a log transformed response are used.
If <code>nls</code> does not converge, the model with the starting values is returned.
</p>
<p><code>refit()</code> refits the object with a different extrapolation function.
</p>


<h3>Value</h3>

<p>An object of class 'mcsimex' which contains:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>corrected coefficients of the MCSIMEX model,</p>
</td></tr>
<tr><td><code>SIMEX.estimates</code></td>
<td>
<p>the MCSIMEX-estimates of the coefficients for each lambda,</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the values of lambda,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the naive model,</p>
</td></tr>
<tr><td><code>mc.matrix</code></td>
<td>
<p>the misclassification matrix,</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the number of iterations,</p>
</td></tr>
<tr><td><code>extrapolation</code></td>
<td>
<p>the model object of the extrapolation step,</p>
</td></tr>
<tr><td><code>fitting.method</code></td>
<td>
<p>the fitting method used in the extrapolation step,</p>
</td></tr>
<tr><td><code>SIMEXvariable</code></td>
<td>
<p>name of the SIMEXvariables,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call,</p>
</td></tr>
<tr><td><code>variance.jackknife</code></td>
<td>
<p>the jackknife variance estimates,</p>
</td></tr>
<tr><td><code>extrapolation.variance</code></td>
<td>
<p>the model object of the variance extrapolation,</p>
</td></tr>
<tr><td><code>variance.jackknife.lambda</code></td>
<td>
<p>the data set for the extrapolation,</p>
</td></tr>
<tr><td><code>variance.asymptotic</code></td>
<td>
<p>the asymptotic variance estimates,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>all estimated coefficients for each lambda and B,</p>
</td></tr>
</table>
<p>...
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot</code>: Plots of the simulation and extrapolation
</p>
</li>
<li> <p><code>predict</code>: Predict with mcsimex correction
</p>
</li>
<li> <p><code>print</code>: Nice printing
</p>
</li>
<li> <p><code>print</code>: Print summary nicely
</p>
</li>
<li> <p><code>summary</code>: Summary for mcsimex
</p>
</li>
<li> <p><code>refit</code>: Refits the model with a different extrapolation function
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Wolfgang Lederer, <a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>


<h3>References</h3>

<p>Küchenhoff, H., Mwalili, S. M.  and Lesaffre, E. (2006) A general method for
dealing with misclassification in regression: The Misclassification SIMEX.
<em>Biometrics</em>, <b>62</b>, 85 &ndash; 96
</p>
<p>Küchenhoff, H., Lederer, W. and E. Lesaffre. (2006) Asymptotic Variance Estimation
for the Misclassification SIMEX.
<em>Computational Statistics and Data Analysis</em>, <b>51</b>, 6197 &ndash; 6211
</p>
<p>Lederer, W. and Küchenhoff, H. (2006) A short introduction to the SIMEX and MCSIMEX. <em>R News</em>, <b>6(4)</b>, 26&ndash;31
</p>


<h3>See Also</h3>

<p><code><a href="#topic+misclass">misclass</a></code>, <code><a href="#topic+simex">simex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200, 0, 1.142)
z &lt;- rnorm(200, 0, 2)
y &lt;- factor(rbinom(200, 1, (1 / (1 + exp(-1 * (-2 + 1.5 * x -0.5 * z))))))
Pi &lt;- matrix(data = c(0.9, 0.1, 0.3, 0.7), nrow = 2, byrow = FALSE)
dimnames(Pi) &lt;- list(levels(y), levels(y))
ystar &lt;- misclass(data.frame(y), list(y = Pi), k = 1)[, 1]
naive.model &lt;- glm(ystar ~ x + z, family = binomial, x = TRUE, y = TRUE)
true.model  &lt;- glm(y ~ x + z, family = binomial)
simex.model &lt;- mcsimex(naive.model, mc.matrix = Pi, SIMEXvariable = "ystar")

op &lt;- par(mfrow = c(2, 3))
invisible(lapply(simex.model$theta, boxplot, notch = TRUE, outline = FALSE,
                 names = c(0.5, 1, 1.5, 2)))
                 plot(simex.model)
simex.model2 &lt;- refit(simex.model, "line")
plot(simex.model2)
par(op)

# example using polr from the MASS package
## Not run: 
if(require(MASS)) {
  yord &lt;- cut((1 / (1 + exp(-1 * (-2 + 1.5 * x -0.5 * z)))), 3, ordered=TRUE)
  Pi3 &lt;- matrix(data = c(0.8, 0.1, 0.1, 0.2, 0.7, 0.1, 0.1, 0.2, 0.7), nrow = 3, byrow = FALSE)
  dimnames(Pi3) &lt;- list(levels(yord), levels(yord))
  ystarord &lt;- misclass(data.frame(yord), list(yord = Pi3), k = 1)[, 1]
  naive.ord.model &lt;- polr(ystarord ~ x + z, Hess = TRUE)
  simex.ord.model &lt;- mcsimex(naive.ord.model, mc.matrix = Pi3,
      SIMEXvariable = "ystarord", asymptotic=FALSE)
}

## End(Not run)

# example for a function which can be supplied to the function mcsimex()
# "ystar" is the variable which is to be misclassified
# using the example above
## Not run: 
my.misclass &lt;- function (datas, k) {
    ystar &lt;- datas$"ystar"
    p1 &lt;- matrix(data = c(0.75, 0.25, 0.25, 0.75), nrow = 2, byrow = FALSE)
    colnames(p1) &lt;- levels(ystar)
    rownames(p1) &lt;- levels(ystar)
    p0 &lt;- matrix(data = c(0.8, 0.2, 0.2, 0.8), nrow = 2, byrow = FALSE)

    colnames(p0) &lt;- levels(ystar)
    rownames(p0) &lt;- levels(ystar)
    ystar[datas$x &lt; 0] &lt;-
    misclass(data.frame(ystar = ystar[datas$x &lt; 0]), list(ystar = p1), k = k)[, 1]
    ystar[datas$x &gt; 0] &lt;-
    misclass(data.frame(ystar = ystar[datas$x &gt; 0]), list(ystar = p0), k = k)[, 1]
    ystar &lt;- factor(ystar)
    return(data.frame(ystar))}

simex.model.differential &lt;- mcsimex(naive.model, mc.matrix = "my.misclass", SIMEXvariable = "ystar")

## End(Not run)

</code></pre>

<hr>
<h2 id='misclass'>Generates misclassified data</h2><span id='topic+misclass'></span>

<h3>Description</h3>

<p>Takes a <code>data.frame</code> and produces misclassified data.
Probabilities for the missclassification are given in <code>mc.matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misclass(data.org, mc.matrix, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misclass_+3A_data.org">data.org</code></td>
<td>
<p><code>data.frame</code> containing the factor variables. Must be <code>factor</code>s.</p>
</td></tr>
<tr><td><code id="misclass_+3A_mc.matrix">mc.matrix</code></td>
<td>
<p>a <code>list</code> of matrices giving the probabilities for the
misclassification. Names of the <code>list</code> must correspond to the variable
names in <code>data.org</code>. The <code>colnames</code> must be named according to the factor levels.</p>
</td></tr>
<tr><td><code id="misclass_+3A_k">k</code></td>
<td>
<p>the exponent for the misclassification matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the misclassified variables
</p>


<h3>Author(s)</h3>

<p>Wolfgang Lederer, <a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcsimex">mcsimex</a></code>, <code><a href="#topic+mc.matrix">mc.matrix</a></code>, <code><a href="#topic+diag.block">diag.block</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- factor(rbinom(100, 1, 0.5))
x2 &lt;- factor(rbinom(100, 2, 0.5))

p1 &lt;- matrix(c(1, 0, 0, 1), nrow = 2)
p2 &lt;- matrix(c(0.8, 0.1, 0.1, 0.1, 0.8, 0.1, 0.1, 0.1, 0.8), nrow = 3)

colnames(p1) &lt;- levels(x1)
colnames(p2) &lt;- levels(x2)

x &lt;- data.frame(x1 = x1, x2 = x2)
mc.matrix &lt;- list(x1 = p1, x2 = p2)

x.mc &lt;- misclass(data.org = x, mc.matrix = mc.matrix, k = 1)

identical(x[, 1], x.mc[, 1]) # TRUE
identical(x[, 2], x.mc[, 2]) # FALSE


</code></pre>

<hr>
<h2 id='simex'>Measurement error in models using SIMEX</h2><span id='topic+simex'></span><span id='topic+print.simex'></span><span id='topic+summary.simex'></span><span id='topic+print.summary.simex'></span><span id='topic+plot.simex'></span><span id='topic+predict.simex'></span><span id='topic+refit'></span><span id='topic+refit.simex'></span>

<h3>Description</h3>

<p>Implementation of the SIMEX algorithm for measurement error models according to Cook and Stefanski
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simex(model, SIMEXvariable, measurement.error, lambda = c(0.5, 1, 1.5,
  2), B = 100, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE)

## S3 method for class 'simex'
plot(x, xlab = expression((1 + lambda)),
  ylab = colnames(b)[-1], ask = FALSE, show = rep(TRUE, NCOL(b) - 1),
  ...)

## S3 method for class 'simex'
predict(object, newdata, ...)

## S3 method for class 'simex'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'summary.simex'
print(x, digits = max(3, getOption("digits") -
  3), ...)

## S3 method for class 'simex'
refit(object, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE, ...)

## S3 method for class 'simex'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simex_+3A_model">model</code></td>
<td>
<p>the naive model</p>
</td></tr>
<tr><td><code id="simex_+3A_simexvariable">SIMEXvariable</code></td>
<td>
<p>character or vector of characters containing the names of the variables with measurement error</p>
</td></tr>
<tr><td><code id="simex_+3A_measurement.error">measurement.error</code></td>
<td>
<p>given standard deviations of measurement errors. In
case of homoskedastic measurement error it is a matrix with dimension
1x<code>length(SIMEXvariable)</code>. In case of heteroskedastic error for at least one
SIMEXvariable it is a matrix of dimension nx</p>
</td></tr>
<tr><td><code id="simex_+3A_lambda">lambda</code></td>
<td>
<p>vector of lambdas for which the simulation step should be done (without 0)</p>
</td></tr>
<tr><td><code id="simex_+3A_b">B</code></td>
<td>
<p>number of iterations for each lambda</p>
</td></tr>
<tr><td><code id="simex_+3A_fitting.method">fitting.method</code></td>
<td>
<p>fitting method for the extrapolation. <code>linear</code>, <code>quadratic</code>,
<code>nonlinear</code> are implemented. (first 4 letters are enough)</p>
</td></tr>
<tr><td><code id="simex_+3A_jackknife.estimation">jackknife.estimation</code></td>
<td>
<p>specifying the extrapolation method for jackknife
variance estimation. Can be set to <code>FALSE</code> if it should not be performed</p>
</td></tr>
<tr><td><code id="simex_+3A_asymptotic">asymptotic</code></td>
<td>
<p>logical, indicating if asymptotic variance estimation should
be done, in the naive model the option <code>x = TRUE</code> has to be set</p>
</td></tr>
<tr><td><code id="simex_+3A_x">x</code></td>
<td>
<p>object of class 'simex'</p>
</td></tr>
<tr><td><code id="simex_+3A_xlab">xlab</code></td>
<td>
<p>optional name for the X-Axis</p>
</td></tr>
<tr><td><code id="simex_+3A_ylab">ylab</code></td>
<td>
<p>vector containing the names for the Y-Axis</p>
</td></tr>
<tr><td><code id="simex_+3A_ask">ask</code></td>
<td>
<p>logical. If <code>TRUE</code>, the user is asked for input, before a new figure is drawn</p>
</td></tr>
<tr><td><code id="simex_+3A_show">show</code></td>
<td>
<p>vector of logicals indicating for wich variables a plot should be produced</p>
</td></tr>
<tr><td><code id="simex_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions</p>
</td></tr>
<tr><td><code id="simex_+3A_object">object</code></td>
<td>
<p>of class 'simex'</p>
</td></tr>
<tr><td><code id="simex_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for
variables with which to predict. If omitted, the fitted linear predictors are used</p>
</td></tr>
<tr><td><code id="simex_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonlinear is implemented as described in Cook and Stefanski, but is numerically
instable. It is not advisable to use this feature. If a nonlinear extrapolation
is desired please use the <code>refit()</code> method.
</p>
<p>Asymptotic is only implemented for naive models of class <code>lm</code> or <code>glm</code> with homoscedastic measurement error.
</p>
<p><code>refit()</code> refits the object with a different extrapolation function.
</p>


<h3>Value</h3>

<p>An object of class 'simex' which contains:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the corrected coefficients of the SIMEX model,</p>
</td></tr>
<tr><td><code>SIMEX.estimates</code></td>
<td>
<p>the estimates for every lambda,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the naive model,</p>
</td></tr>
<tr><td><code>measurement.error</code></td>
<td>
<p>the known error standard deviations,</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the number of iterations,</p>
</td></tr>
<tr><td><code>extrapolation</code></td>
<td>
<p>the model object of the extrapolation step,</p>
</td></tr>
<tr><td><code>fitting.method</code></td>
<td>
<p>the fitting method used in the extrapolation step,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the main model,</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values of the main model,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call,</p>
</td></tr>
<tr><td><code>variance.jackknife</code></td>
<td>
<p>the jackknife variance estimate,</p>
</td></tr>
<tr><td><code>extrapolation.variance</code></td>
<td>
<p>the model object of the variance extrapolation,</p>
</td></tr>
<tr><td><code>variance.jackknife.lambda</code></td>
<td>
<p>the data set for the extrapolation,</p>
</td></tr>
<tr><td><code>variance.asymptotic</code></td>
<td>
<p>the asymptotic variance estimates,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the estimates for every B and lambda,</p>
</td></tr>
</table>
<p>...
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot</code>: Plot the simulation and extrapolation step
</p>
</li>
<li> <p><code>predict</code>: Predict using simex correction
</p>
</li>
<li> <p><code>print</code>: Print simex nicely
</p>
</li>
<li> <p><code>print</code>: Print summary nicely
</p>
</li>
<li> <p><code>refit</code>: Refits the model with a different extrapolation function
</p>
</li>
<li> <p><code>summary</code>: Summary of simulation and extrapolation
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Wolfgang Lederer,<a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>
<p>Heidi Seibold,<a href="mailto:heidi.bold@gmail.com">heidi.bold@gmail.com</a>
</p>


<h3>References</h3>

<p>Cook, J.R. and Stefanski, L.A. (1994) Simulation-extrapolation estimation in
parametric measurement error models. <em>Journal of the American Statistical
Association</em>, <b>89</b>, 1314 &ndash; 1328
</p>
<p>Carroll, R.J., Küchenhoff, H., Lombard, F. and Stefanski L.A. (1996) Asymptotics
for the SIMEX estimator in nonlinear measurement error models. <em>Journal
of the American Statistical Association</em>, <b>91</b>, 242 &ndash; 250
</p>
<p>Carrol, R.J., Ruppert, D., Stefanski, L.A. and Crainiceanu, C. (2006).
<em>Measurement error in nonlinear models: A modern perspective.</em>, Second
Edition. London: Chapman and Hall.
</p>
<p>Lederer, W. and Küchenhoff, H. (2006) A short introduction to the SIMEX and MCSIMEX. <em>R News</em>, <b>6(4)</b>, 26&ndash;31
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcsimex">mcsimex</a></code> for discrete data with misclassification,
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Seed
set.seed(49494)

## simulating the measurement error standard deviations
sd_me &lt;- 0.3
sd_me2 &lt;- 0.4
temp &lt;- runif(100, min = 0, max = 0.6)
sd_me_het1 &lt;- sort(temp)
temp2 &lt;- rnorm(100, sd = 0.1)
sd_me_het2 &lt;- abs(sd_me_het1 + temp2)

## simulating the independent variables x (real and with measurement error):

x_real &lt;- rnorm(100)
x_real2 &lt;- rpois(100, lambda = 2)
x_real3 &lt;- -4*x_real + runif(100, min = -10, max = 10)  # correlated to x_real

x_measured &lt;- x_real + sd_me * rnorm(100)
x_measured2 &lt;- x_real2 + sd_me2 * rnorm(100)
x_het1 &lt;- x_real + sd_me_het1 * rnorm(100)
x_het2 &lt;- x_real3 + sd_me_het2 * rnorm(100)

## calculating dependent variable y:
y &lt;- x_real + rnorm(100, sd = 0.05)
y2 &lt;- x_real + 2*x_real2 + rnorm(100, sd = 0.08)
y3 &lt;- x_real + 2*x_real3 + rnorm(100, sd = 0.08)

### one variable with homoscedastic measurement error
(model_real &lt;- lm(y ~ x_real))

(model_naiv &lt;- lm(y ~ x_measured, x = TRUE))

(model_simex &lt;- simex(model_naiv, SIMEXvariable = "x_measured", measurement.error = sd_me))
plot(model_simex)

### two variables with homoscedastic measurement errors
(model_real2 &lt;- lm(y2 ~ x_real + x_real2))
(model_naiv2 &lt;- lm(y2 ~ x_measured + x_measured2, x = TRUE))
(model_simex2 &lt;- simex(model_naiv2, SIMEXvariable = c("x_measured", "x_measured2"),
         measurement.error = cbind(sd_me, sd_me2)))

plot(model_simex2)

## Not run: 
### one variable with increasing heteroscedastic measurement error
model_real

(mod_naiv1 &lt;- lm(y ~ x_het1, x = TRUE))
(mod_simex1 &lt;- simex(mod_naiv1, SIMEXvariable = "x_het1",
                measurement.error = sd_me_het1, asymptotic = FALSE))

plot(mod_simex1)

### two correlated variables with heteroscedastic measurement errors
(model_real3 &lt;- lm(y3 ~ x_real + x_real3))
(mod_naiv2 &lt;- lm(y3 ~ x_het1 + x_het2, x = TRUE))
(mod_simex2 &lt;- simex(mod_naiv2, SIMEXvariable = c("x_het1", "x_het2"),
              measurement.error = cbind(sd_me_het1, sd_me_het2), asymptotic = FALSE))

plot(mod_simex2)

### two variables, one with homoscedastic, one with heteroscedastic measurement error
model_real2
(mod_naiv3 &lt;- lm(y2 ~ x_measured + x_het2, x = TRUE))
(mod_simex3 &lt;- simex(mod_naiv3, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

### glm: two variables, one with homoscedastic, one with heteroscedastic measurement error
t &lt;- x_real + 2*x_real2 + rnorm(100, sd = 0.01)
g &lt;- 1 / (1 + exp(t))
u &lt;- runif(100)
ybin &lt;- as.numeric(u &lt; g)

(logit_real &lt;- glm(ybin ~ x_real + x_real2, family = binomial))
(logit_naiv &lt;- glm(ybin ~ x_measured + x_het2, x = TRUE, family = binomial))
(logit_simex &lt;- simex(logit_naiv, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

summary(logit_simex)
print(logit_simex)
plot(logit_simex)

### polr: two variables, one with homoscedastic, one with heteroscedastic measurement error

if(require("MASS")) {# Requires MASS
yerr &lt;- jitter(y, amount=1)
yfactor &lt;- cut(yerr, 3, ordered_result=TRUE)

(polr_real &lt;- polr(yfactor ~ x_real + x_real2))
(polr_naiv &lt;- polr(yfactor ~ x_measured + x_het2, Hess = TRUE))
(polr_simex &lt;- simex(polr_naiv, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

summary(polr_simex)
print(polr_simex)
plot(polr_simex)
}

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
