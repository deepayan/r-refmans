<!DOCTYPE html><html><head><title>Help for package fgeo.tool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fgeo.tool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fgeo.tool-package'><p>fgeo.tool: Import and Manipulate 'ForestGEO' Data</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_status_tree'><p>Add column <code>status_tree</code> based on the status of all stems of each tree.</p></a></li>
<li><a href='#add_subquad'><p>Add column <code>subquadrat</code> based on <code>QX</code> and <code>QY</code> coordinates.</p></a></li>
<li><a href='#add_var'><p>Add columns <code>lx/ly</code>, <code>QX/QY</code>, <code>index</code>, <code>col/row</code>, <code>hectindex</code>, <code>quad</code>, <code>gx/gy</code>.</p></a></li>
<li><a href='#assert_is_installed'><p>Assert a package is installed.</p></a></li>
<li><a href='#check_crucial_names'><p>Check if an object contains specific names.</p></a></li>
<li><a href='#drop_if_na'><p>Drop if missing values.</p></a></li>
<li><a href='#extract_from_habitat'><p>Extract plot dimensions from habitat data.</p></a></li>
<li><a href='#extract_insensitive'><p>Detect and extract matching strings &ndash; ignoring case.</p></a></li>
<li><a href='#fgeo_elevation'><p>Create elevation data.</p></a></li>
<li><a href='#flag_if'><p>Flag if a vector or dataframe-column meets a condition.</p></a></li>
<li><a href='#flag_if_group'><p>Detect and flag based on a predicate applied to a variable by groups.</p></a></li>
<li><a href='#from_var_to_var'><p>Functions to get variables from other variables.</p></a></li>
<li><a href='#guess_plotdim'><p>Guess plot dimensions.</p></a></li>
<li><a href='#is_multiple'><p>Predicates to detect and flag duplicated and multiple values of a variable.</p></a></li>
<li><a href='#nms_try_rename'><p>Try to rename an object.</p></a></li>
<li><a href='#pick_drop'><p>Pick and drop rows from <em>ViewFullTable</em>, <em>tree</em>, and <em>stem</em> tables.</p></a></li>
<li><a href='#pick_main_stem'><p>Pick the main stem or main stemid(s) of each tree in each census.</p></a></li>
<li><a href='#read_vft'><p>Import <em>ViewFullTable</em> or <em>ViewTaxonomy</em> data from a .tsv or .csv file.</p></a></li>
<li><a href='#recode_subquad'><p>Recode subquadrat.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rename_matches'><p>Rename an object based on case-insensitive match of the names of a reference.</p></a></li>
<li><a href='#sanitize_vft'><p>Fix common problems in <em>ViewFullTable</em> and <em>ViewTaxonomy</em> data.</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#type_ensure'><p>Ensure the specific columns of a dataframe have a particular type.</p></a></li>
<li><a href='#type_vft'><p>Help to read ForestGEO data safely, with consistent columns type.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Import and Manipulate 'ForestGEO' Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.9</td>
</tr>
<tr>
<td>Description:</td>
<td>To help you access, transform, analyze, and visualize
    'ForestGEO' data, we developed a collection of R packages
    (<a href="https://forestgeo.github.io/fgeo/">https://forestgeo.github.io/fgeo/</a>). This package, in particular,
    helps you to easily import, filter, and modify 'ForestGEO' data. To
    learn more about 'ForestGEO' visit <a href="https://forestgeo.si.edu/">https://forestgeo.si.edu/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://forestgeo.github.io/fgeo.tool/">https://forestgeo.github.io/fgeo.tool/</a>,
<a href="https://github.com/forestgeo/fgeo.tool">https://github.com/forestgeo/fgeo.tool</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/forestgeo/fgeo.tool/issues">https://github.com/forestgeo/fgeo.tool/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.0.1), glue (&ge; 1.3.1), magrittr (&ge; 1.5), purrr
(&ge; 0.3.2), readr (&ge; 1.3.1), rlang (&ge; 0.4.11), tibble (&ge;
2.1.1), tidyselect (&ge; 0.2.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.2.1), fgeo.x (&ge; 1.1.3), knitr (&ge; 1.22), roxygen2
(&ge; 6.1.1), spelling (&ge; 2.1), stringr (&ge; 1.4.0), testthat (&ge;
2.1.1), tidyr (&ge; 0.8.3)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 19:28:21 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Mauro Lepore <a href="https://orcid.org/0000-0002-1986-7988"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctr, cre],
  Richard Condit [aut],
  Suzanne Lao [aut],
  Anudeep Singh [aut],
  CTFS-ForestGEO [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mauro Lepore &lt;maurolepore@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fgeo.tool-package'>fgeo.tool: Import and Manipulate 'ForestGEO' Data</h2><span id='topic+fgeo.tool'></span><span id='topic+fgeo.tool-package'></span>

<h3>Description</h3>

<p>To help you access, transform, analyze, and visualize 'ForestGEO' data, we developed a collection of R packages (<a href="https://forestgeo.github.io/fgeo/">https://forestgeo.github.io/fgeo/</a>). This package, in particular, helps you to easily import, filter, and modify 'ForestGEO' data. To learn more about 'ForestGEO' visit <a href="https://forestgeo.si.edu/">https://forestgeo.si.edu/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mauro Lepore <a href="mailto:maurolepore@gmail.com">maurolepore@gmail.com</a> (<a href="https://orcid.org/0000-0002-1986-7988">ORCID</a>) [contractor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Richard Condit <a href="mailto:richardcondit@gmail.com">richardcondit@gmail.com</a>
</p>
</li>
<li><p> Suzanne Lao <a href="mailto:laoz@si.edu">laoz@si.edu</a>
</p>
</li>
<li><p> Anudeep Singh <a href="mailto:anudeep7@gmail.com">anudeep7@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> CTFS-ForestGEO <a href="mailto:ForestGEO@si.edu">ForestGEO@si.edu</a> [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://forestgeo.github.io/fgeo.tool/">https://forestgeo.github.io/fgeo.tool/</a>
</p>
</li>
<li> <p><a href="https://github.com/forestgeo/fgeo.tool">https://github.com/forestgeo/fgeo.tool</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/forestgeo/fgeo.tool/issues">https://github.com/forestgeo/fgeo.tool/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_status_tree'>Add column <code>status_tree</code> based on the status of all stems of each tree.</h2><span id='topic+add_status_tree'></span>

<h3>Description</h3>

<p>Add column <code>status_tree</code> based on the status of all stems of each tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_status_tree(data, status_a = "A", status_d = "D")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_status_tree_+3A_data">data</code></td>
<td>
<p>A ForestGEO-like dataframe: A <em>ViewFullTable</em>, <em>tree</em> or <em>stem</em>
table.</p>
</td></tr>
<tr><td><code id="add_status_tree_+3A_status_a">status_a</code>, <code id="add_status_tree_+3A_status_d">status_d</code></td>
<td>
<p>Sting to match alive and dead stems; it corresponds
to the values of the variable <code>status</code> (in census tables) or <code>Status</code> (with
capital &quot;S&quot; in ViewFull tables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data set with the additional variable <code>status_tree</code>.
</p>


<h3>See Also</h3>

<p>Other functions to add columns to dataframes: 
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>
</p>
<p>Other functions for ForestGEO data: 
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>
</p>
<p>Other functions for fgeo census: 
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>
<p>Other functions for fgeo vft: 
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># styler: off
stem &lt;- tribble(
  ~CensusID, ~treeID, ~stemID, ~status,
          1,       1,       1,     "A",
          1,       1,       2,     "D",

          1,       2,       3,     "D",
          1,       2,       4,     "D",



          2,       1,       1,     "A",
          2,       1,       2,     "G",

          2,       2,       3,     "D",
          2,       2,       4,     "G"
)
# styler: on

add_status_tree(stem)

</code></pre>

<hr>
<h2 id='add_subquad'>Add column <code>subquadrat</code> based on <code>QX</code> and <code>QY</code> coordinates.</h2><span id='topic+add_subquad'></span>

<h3>Description</h3>

<p>Add column <code>subquadrat</code> based on <code>QX</code> and <code>QY</code> coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_subquad(data, x_q, y_q = x_q, x_sq, y_sq = x_sq, subquad_offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_subquad_+3A_data">data</code></td>
<td>
<p>A dataframe with quadrat coordinates <code>QX</code> and <code>QY</code> (e.g. a
<em>ViewFullTable</em>).</p>
</td></tr>
<tr><td><code id="add_subquad_+3A_x_q">x_q</code>, <code id="add_subquad_+3A_y_q">y_q</code></td>
<td>
<p>Size in meters of a quadrat's side. For ForestGEO sites, a
common value is 20.</p>
</td></tr>
<tr><td><code id="add_subquad_+3A_x_sq">x_sq</code>, <code id="add_subquad_+3A_y_sq">y_sq</code></td>
<td>
<p>Size in meters of a subquadrat's side. For ForestGEO sites,
a common value is 5.</p>
</td></tr>
<tr><td><code id="add_subquad_+3A_subquad_offset">subquad_offset</code></td>
<td>
<p>Either <code>-1</code> or <code>1</code>, to rest or add one unit to the
digit of each subquadrat that represents the column number.
</p>
<div class="sourceCode R"><pre>First column is 0    First column is 1
-----------------    -----------------
   04 14 24 34          14 24 34 44
   03 13 23 33          13 23 33 43
   02 12 22 32          12 22 32 42
   01 11 21 31          11 21 31 41
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data</code> with the additional variable <code>subquadrat</code>.
</p>


<h3>Author(s)</h3>

<p>Anudeep Singh and Mauro Lepore.
</p>


<h3>See Also</h3>

<p>Other functions to add columns to dataframes: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>
</p>
<p>Other functions for ForestGEO data: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>
</p>
<p>Other functions for fgeo vft: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># styler: off
vft &lt;- tribble(
   ~QX,  ~QY,
  17.9,    0,
   4.1,   15,
   6.1, 17.3,
   3.8,  5.9,
   4.5, 12.4,
   4.9,  9.3,
   9.8,  3.2,
  18.6,  1.1,
  17.3,  4.1,
   1.5, 16.3
)
# styler: on

add_subquad(vft, 20, 20, 5, 5)

add_subquad(vft, 20, 20, 5, 5, subquad_offset = -1)

</code></pre>

<hr>
<h2 id='add_var'>Add columns <code>lx/ly</code>, <code>QX/QY</code>, <code>index</code>, <code>col/row</code>, <code>hectindex</code>, <code>quad</code>, <code>gx/gy</code>.</h2><span id='topic+add_var'></span><span id='topic+add_lxly'></span><span id='topic+add_qxqy'></span><span id='topic+add_index'></span><span id='topic+add_col_row'></span><span id='topic+add_hectindex'></span><span id='topic+add_quad'></span><span id='topic+add_gxgy'></span>

<h3>Description</h3>

<p>These functions add columns to position trees in a forest plot. They work
with <em>ViewFullTable</em>, <em>tree</em> and <em>stem</em> tables. From the input table, most
functions use only the <code>gx</code> and <code>gy</code> columns (or equivalent columns). The
exception is the function <code>add_gxgy()</code> which inputs quadrat information. If
your data lacks some important column, an error message will inform you which
column is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lxly(data, gridsize = 20, plotdim = NULL)

add_qxqy(data, gridsize = 20, plotdim = NULL)

add_index(data, gridsize = 20, plotdim = NULL)

add_col_row(data, gridsize = 20, plotdim = NULL)

add_hectindex(data, gridsize = 20, plotdim = NULL)

add_quad(data, gridsize = 20, plotdim = NULL, start = NULL, width = 2)

add_gxgy(data, gridsize = 20, start = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_var_+3A_data">data</code></td>
<td>
<p>A ForestGEO-like dataframe: A <em>ViewFullTable</em>, <em>tree</em> or <em>stem</em>
table.</p>
</td></tr>
<tr><td><code id="add_var_+3A_gridsize">gridsize</code></td>
<td>
<p>The gridsize of the census plot (commonly 20 m).</p>
</td></tr>
<tr><td><code id="add_var_+3A_plotdim">plotdim</code></td>
<td>
<p>The global dimensions of the census plot (i.e. the
maximum possible values of <code>gx</code> and <code>gy</code>).</p>
</td></tr>
<tr><td><code id="add_var_+3A_start">start</code></td>
<td>
<p>Defaults to label the first quadrat as &quot;0101&quot;. Use <code>0</code> to
label it as &quot;0000&quot; instead.</p>
</td></tr>
<tr><td><code id="add_var_+3A_width">width</code></td>
<td>
<p>Number; width to pad the labels of plot-columns and -rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are adapted from the <a href="https://forestgeo.si.edu/explore-data/r-package-0">CTFS R Package</a>.
</p>


<h3>Value</h3>

<p>For any given <code>var</code>, a function <code>add_var()</code> returns a modified
version of the input dataframe, with the additional variable(s) <code>var</code>.
</p>


<h3>See Also</h3>

<p>Other functions to add columns to dataframes: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_subquad">add_subquad</a>()</code>
</p>
<p>Other functions for ForestGEO data: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_subquad">add_subquad</a>()</code>
</p>
<p>Other functions for fgeo census: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>
<p>Other functions for fgeo vft: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># styler: off
x &lt;- tribble(
    ~gx,    ~gy,
      0,      0,
     50,     25,
  999.9, 499.95,
   1000,    500
)
# styler: on

# `gridsize` has a common default; `plotdim` is guessed from the data
add_lxly(x)

gridsize &lt;- 20
plotdim &lt;- c(1000, 500)

add_qxqy(x, gridsize, plotdim)

add_index(x, gridsize, plotdim)

add_hectindex(x, gridsize, plotdim)

add_quad(x, gridsize, plotdim)

add_quad(x, gridsize, plotdim, start = 0)

# `width` gives the nuber of digits to pad the label of plot-rows and
# plot-columns, e.g. 3 pads plot-rows with three zeros and plot-columns with
# an extra trhree zeros, resulting in a total of 6 zeros.
add_quad(x, gridsize, plotdim, start = 0, width = 3)

add_col_row(x, gridsize, plotdim)


# From `quadrat` or `QuadratName` --------------------------------------
# styler: off
x &lt;- tribble(
  ~QuadratName,
        "0001",
        "0011",
        "0101",
        "1001"
)
# styler: on

# Output `gx` and `gy` ---------------

add_gxgy(x)

assert_is_installed("fgeo.x")
# Warning: The data may already have `gx` and `gx` columns
gxgy &lt;- add_gxgy(fgeo.x::tree5)
select(gxgy, matches("gx|gy"))

# Output `col` and `row` -------------

# Create columns `col` and `row` from `QuadratName` with `tidyr::separate()`
# The argument `sep` lets you separate `QuadratName` at any positon
## Not run: 
tidyr_is_installed &lt;- requireNamespace("tidyr", quietly = TRUE)
stringr_is_installed &lt;- requireNamespace("stringr", quietly = TRUE)

if (tidyr_is_installed &amp;&amp; stringr_is_installed) {
  library(tidyr)
  library(stringr)

  vft &lt;- tibble(QuadratName = c("0001", "0011"))
  vft

  separate(
    vft,
    QuadratName,
    into = c("col", "row"),
    sep = 2
  )

  census &lt;- select(fgeo.x::tree5, quadrat)
  census

  census$quadrat &lt;- str_pad(census$quadrat, width = 4, pad = 0)

  separate(
    census,
    quadrat,
    into = c("col", "row"),
    sep = 2,
    remove = FALSE
  )
}

## End(Not run)

</code></pre>

<hr>
<h2 id='assert_is_installed'>Assert a package is installed.</h2><span id='topic+assert_is_installed'></span>

<h3>Description</h3>

<p>Assert a package is installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_is_installed(pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_is_installed_+3A_pkg">pkg</code></td>
<td>
<p>Character vector giving the name of a package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error if <code>pkg</code> is not installed or invisible <code>pkg</code> if it is.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("base")
## Not run: 
try(assert_is_installed("bad"))

## End(Not run)
</code></pre>

<hr>
<h2 id='check_crucial_names'>Check if an object contains specific names.</h2><span id='topic+check_crucial_names'></span>

<h3>Description</h3>

<p>Check if an object contains specific names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_crucial_names(x, nms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_crucial_names_+3A_x">x</code></td>
<td>
<p>A named object.</p>
</td></tr>
<tr><td><code id="check_crucial_names_+3A_nms">nms</code></td>
<td>
<p>String; names expected to be found in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>x</code>, or an error with informative message.
</p>


<h3>See Also</h3>

<p>Other functions to check inputs: 
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>
</p>
<p>Other functions for developers: 
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(x = 1)
check_crucial_names(v, "x")

dfm &lt;- data.frame(x = 1)
check_crucial_names(dfm, "x")
</code></pre>

<hr>
<h2 id='drop_if_na'>Drop if missing values.</h2><span id='topic+drop_if_na'></span>

<h3>Description</h3>

<p>Valuable mostly for its warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_if_na(dfm, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_if_na_+3A_dfm">dfm</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="drop_if_na_+3A_x">x</code></td>
<td>
<p>String giving a column name of <code>dfm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>See Also</h3>

<p><code>tidyr::drop_na()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfm &lt;- data.frame(a = 1, b = NA)
drop_if_na(dfm, "b")
drop_if_na(dfm, "a")
</code></pre>

<hr>
<h2 id='extract_from_habitat'>Extract plot dimensions from habitat data.</h2><span id='topic+extract_from_habitat'></span><span id='topic+extract_gridsize'></span><span id='topic+extract_plotdim'></span>

<h3>Description</h3>

<p>Extract plot dimensions from habitat data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_gridsize(habitats)

extract_plotdim(habitats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_from_habitat_+3A_habitats">habitats</code></td>
<td>
<p>Data frame giving the habitat designation for each 20x20
quadrat.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+extract_plotdim">extract_plotdim()</a></code>: <code>plotdim</code> (vector of length 2);
</p>
</li>
<li> <p><code><a href="#topic+extract_gridsize">extract_gridsize()</a></code>: <code>gridsize</code> (scalar).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")
habitat &lt;- fgeo.x::habitat
extract_plotdim(habitat)
extract_gridsize(habitat)
</code></pre>

<hr>
<h2 id='extract_insensitive'>Detect and extract matching strings &ndash; ignoring case.</h2><span id='topic+extract_insensitive'></span><span id='topic+detect_insensitive'></span>

<h3>Description</h3>

<p>Detect and extract matching strings &ndash; ignoring case.
</p>
<p>Return TRUE in position where name of x is in y; FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_insensitive(x, y)

detect_insensitive(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_insensitive_+3A_x">x</code></td>
<td>
<p>A string to be muted as in <code>y</code>, it a case insensitive match is
found.</p>
</td></tr>
<tr><td><code id="extract_insensitive_+3A_y">y</code></td>
<td>
<p>A string to use as a reference to match <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;detect_*&#8288;</code> and <code style="white-space: pre;">&#8288;extract_*&#8288;</code> return a logical vector and a string.
</p>


<h3>See Also</h3>

<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>
<p>Other general functions to deal with names: 
<code><a href="#topic+rename_matches">rename_matches</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("stemid", "n")
y &lt;- c("StemID", "treeID")
detect_insensitive(x, y)
extract_insensitive(x, y)

vft &lt;- data.frame(TreeID = 1, Status = 1)
extract_insensitive(tolower(names(vft)), names(vft))
extract_insensitive(names(vft), tolower(names(vft)))
</code></pre>

<hr>
<h2 id='fgeo_elevation'>Create elevation data.</h2><span id='topic+fgeo_elevation'></span>

<h3>Description</h3>

<p>This function constructs an object of class &quot;fgeo_elevation&quot;. It standardizes
the structure of elevation data to always output a dataframe with names <code>gx</code>,
<code>gy</code> and <code>elev</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgeo_elevation(elev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgeo_elevation_+3A_elev">elev</code></td>
<td>
<p>One of these:
</p>

<ul>
<li><p> A dataframe containing elevation data, with columns <code>gx</code>, <code>gy</code>, and
<code>elev</code>, or <code>x</code>, <code>y</code>, and <code>elev</code> (e.g. <code>fgeo.x::elevation$col</code>).
</p>
</li>
<li><p> A ForestGEO-like elevation list with elements <code>xdim</code> and <code>ydim</code> giving
plot dimensions, and element <code>col</code> containing a dataframe as described in
the previous item (e.g. <code>fgeo.x::elevation</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with names <code>x/gx</code>, <code>y/gy</code> and <code>elev</code>.
</p>


<h3>Acknowledgments</h3>

<p>This function was inspired by David Kenfack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

# Input: Elevation dataframe
elevation_df &lt;- fgeo.x::elevation$col
fgeo_elevation(elevation_df)

class(elevation_df)
class(fgeo_elevation(elevation_df))

names(elevation_df)
names(fgeo_elevation(elevation_df))

# Input: Elevation list
elevation_ls &lt;- fgeo.x::elevation
fgeo_elevation(elevation_ls)

class(elevation_ls)
class(fgeo_elevation(elevation_ls))

names(elevation_ls)
names(fgeo_elevation(elevation_ls))
</code></pre>

<hr>
<h2 id='flag_if'>Flag if a vector or dataframe-column meets a condition.</h2><span id='topic+flag_if'></span><span id='topic+flag_if.default'></span><span id='topic+flag_if.data.frame'></span>

<h3>Description</h3>

<p>This function returns a condition (error, warning, or message) and its first
argument, invisibly. It is a generic. If the first input is a vector, it
evaluates it directly; if it is is a dataframe, it evaluates a given column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_if(.data, ...)

## Default S3 method:
flag_if(.data, predicate, condition = warning, msg = NULL, ...)

## S3 method for class 'data.frame'
flag_if(.data, name, predicate, condition = warning, msg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_if_+3A_.data">.data</code></td>
<td>
<p>Vector.</p>
</td></tr>
<tr><td><code id="flag_if_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="flag_if_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function.</p>
</td></tr>
<tr><td><code id="flag_if_+3A_condition">condition</code></td>
<td>
<p>A condition function (e.g. <code><a href="base.html#topic+stop">stop()</a></code>, <code><a href="base.html#topic+warning">warning()</a></code>,
<code>rlang::inform()</code>).</p>
</td></tr>
<tr><td><code id="flag_if_+3A_msg">msg</code></td>
<td>
<p>String. An optional custom message.</p>
</td></tr>
<tr><td><code id="flag_if_+3A_name">name</code></td>
<td>
<p>String. The name of a column of a dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A condition (and <code>.data</code> invisibly).
</p>


<h3>See Also</h3>

<p>Other functions for internal use in other fgeo packages: 
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># WITH VECTORS
dupl &lt;- c(1, 1)
flag_if(dupl, is_duplicated)
# Silent
flag_if(dupl, is_multiple)

mult &lt;- c(1, 2)
flag_if(mult, is_multiple, message, "Custom")
# Silent
flag_if(mult, is_duplicated)

# Both silent
flag_if(c(1, NA), is_multiple)
flag_if(c(1, NA), is_duplicated)

# WITH DATAFRAMES
.df &lt;- data.frame(a = 1:3, b = 1, stringsAsFactors = FALSE)
flag_if(.df, "b", is_multiple)
flag_if(.df, "a", is_multiple)
flag_if(.df, "a", is_multiple, message, "Custom")
</code></pre>

<hr>
<h2 id='flag_if_group'>Detect and flag based on a predicate applied to a variable by groups.</h2><span id='topic+flag_if_group'></span><span id='topic+detect_if_group'></span>

<h3>Description</h3>

<p>These functions extend <code>flag_if()</code>] and <code>detect_if()</code> to
work by groups defined with <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_if_group(.data, name, predicate, condition = warn, msg = NULL)

detect_if_group(.data, name, predicate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_if_group_+3A_.data">.data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="flag_if_group_+3A_name">name</code></td>
<td>
<p>String. The name of a column of the dataframe.</p>
</td></tr>
<tr><td><code id="flag_if_group_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function, e.g. <code><a href="#topic+is_multiple">is_multiple()</a></code>.</p>
</td></tr>
<tr><td><code id="flag_if_group_+3A_condition">condition</code></td>
<td>
<p>A condition function, e.g. <code><a href="rlang.html#topic+abort">rlang::inform()</a></code> or
<code><a href="base.html#topic+stop">base::stop()</a></code>.</p>
</td></tr>
<tr><td><code id="flag_if_group_+3A_msg">msg</code></td>
<td>
<p>String to customize the returned message.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>flag_if_group()</code>: A condition and its first input, invisibly.
</p>
</li>
<li> <p><code>detect_if_group()</code>: Logical of length 1.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other functions to check inputs: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>
</p>
<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- tibble(CensusID = c(1, 2), treeID = c(1, 2))
detect_if_group(tree, "treeID", is_multiple)
flag_if_group(tree, "treeID", is_multiple)

by_censusid &lt;- group_by(tree, CensusID)
detect_if_group(by_censusid, "treeID", is_multiple)
flag_if_group(by_censusid, "treeID", is_multiple)
</code></pre>

<hr>
<h2 id='from_var_to_var'>Functions to get variables from other variables.</h2><span id='topic+from_var_to_var'></span><span id='topic+rowcol_to_index'></span><span id='topic+index_to_rowcol'></span><span id='topic+gxgy_to_index'></span><span id='topic+gxgy_to_lxly'></span><span id='topic+gxgy_to_qxqy'></span><span id='topic+gxgy_to_rowcol'></span><span id='topic+gxgy_to_hectindex'></span><span id='topic+index_to_gxgy'></span>

<h3>Description</h3>

<p>These functions wrap their corresponding functions from the CTFS R Package,
but these versions are stricter. The main differences are these:
</p>

<ul>
<li><p> names use &quot;_&quot; not &quot;.&quot;.
</p>
</li>
<li><p> argument gridsize defaults to missing to force the user to provide it.
</p>
</li>
<li><p> If the argument <code>plotdim</code> is missing from functions <code>gxgy_fun()</code>, its value
will be guessed and notified.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>rowcol_to_index(rowno, colno, gridsize, plotdim)

index_to_rowcol(index, gridsize, plotdim)

gxgy_to_index(gx, gy, gridsize, plotdim)

gxgy_to_lxly(gx, gy, gridsize, plotdim)

gxgy_to_qxqy(gx, gy, gridsize, plotdim)

gxgy_to_rowcol(gx, gy, gridsize, plotdim)

gxgy_to_hectindex(gx, gy, plotdim)

index_to_gxgy(index, gridsize, plotdim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_var_to_var_+3A_rowno">rowno</code>, <code id="from_var_to_var_+3A_colno">colno</code></td>
<td>
<p>Row and column number &ndash; as defined in a census plot.</p>
</td></tr>
<tr><td><code id="from_var_to_var_+3A_gridsize">gridsize</code></td>
<td>
<p>The gridsize of the census plot (commonly 20 m).</p>
</td></tr>
<tr><td><code id="from_var_to_var_+3A_plotdim">plotdim</code></td>
<td>
<p>The global dimensions of the census plot (i.e. the
maximum possible values of <code>gx</code> and <code>gy</code>).</p>
</td></tr>
<tr><td><code id="from_var_to_var_+3A_index">index</code></td>
<td>
<p>Index number as defined for a census plot.</p>
</td></tr>
<tr><td><code id="from_var_to_var_+3A_gx">gx</code>, <code id="from_var_to_var_+3A_gy">gy</code></td>
<td>
<p>A number; global x and y position in a census plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gxgy_to_qxqy()</code> didn't exist in the original CTFS R Package. Added for
consistency.
</p>


<h3>Value</h3>

<p>A vector or dataframe (see examples).
</p>


<h3>Author(s)</h3>

<p>Rick Condit, Suzanne Lao.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gxgy_to_index(c(0, 400, 990), c(0, 200, 490), gridsize = 20)

gridsize &lt;- 20
plotdim &lt;- c(1000, 500)

x &lt;- gxgy_to_hectindex(1:3, 1:3, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

x &lt;- gxgy_to_index(1:3, 1:3, gridsize, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

x &lt;- gxgy_to_lxly(1:3, 1:3, gridsize, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

x &lt;- gxgy_to_rowcol(1:3, 1:3, gridsize, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

x &lt;- index_to_rowcol(1:3, gridsize, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

x &lt;- rowcol_to_index(1:3, 1:3, gridsize, plotdim)
x
typeof(x)
is.data.frame(x)
is.vector(x)

index_to_gxgy(1:3, gridsize, plotdim)
</code></pre>

<hr>
<h2 id='guess_plotdim'>Guess plot dimensions.</h2><span id='topic+guess_plotdim'></span>

<h3>Description</h3>

<p>Guess plot dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_plotdim(x, accuracy = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_plotdim_+3A_x">x</code></td>
<td>
<p>A ForestGEO-like dataframe: A <em>ViewFullTable</em>, <em>tree</em> or <em>stem</em>
table.</p>
</td></tr>
<tr><td><code id="guess_plotdim_+3A_accuracy">accuracy</code></td>
<td>
<p>A number giving the accuracy with which to round <code>gx</code> and
<code>gy</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2.
</p>


<h3>See Also</h3>

<p>Other functions for fgeo census and vft: 
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>
<p>Other functions for fgeo census: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>
<p>Other functions for fgeo vft: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>
<p>Other functions for internal use in other fgeo packages: 
<code><a href="#topic+flag_if">flag_if</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  gx = c(0, 300, 979),
  gy = c(0, 300, 481)
)
guess_plotdim(x)
</code></pre>

<hr>
<h2 id='is_multiple'>Predicates to detect and flag duplicated and multiple values of a variable.</h2><span id='topic+is_multiple'></span><span id='topic+is_duplicated'></span>

<h3>Description</h3>

<p><code>is_multiple()</code> and <code>is_duplicated()</code> return <code>TRUE</code> if they detect,
respectively, multiple different values of a variable (e.g. c(1, 2)<code style="white-space: pre;">&#8288;), or duplicated values of a variable (e.g. c(1, 1)&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_multiple(.data)

is_duplicated(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_multiple_+3A_.data">.data</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>See Also</h3>

<p>Other functions for internal use in other fgeo packages: 
<code><a href="#topic+flag_if">flag_if</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>
</p>
<p>Other functions to check inputs: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>
</p>
<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_multiple(c(1, 2))
is_multiple(c(1, 1))
is_multiple(c(1, NA))

is_duplicated(c(1, 2))
is_duplicated(c(1, 1))
is_duplicated(c(1, NA))
</code></pre>

<hr>
<h2 id='nms_try_rename'>Try to rename an object.</h2><span id='topic+nms_try_rename'></span>

<h3>Description</h3>

<p>Given a name you want and a possible alternative, this function renames an
object as you want or errs with an informative message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nms_try_rename(x, want, try)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nms_try_rename_+3A_x">x</code></td>
<td>
<p>A named object.</p>
</td></tr>
<tr><td><code id="nms_try_rename_+3A_want">want</code></td>
<td>
<p>String of length 1 giving the name you want the object to have.</p>
</td></tr>
<tr><td><code id="nms_try_rename_+3A_try">try</code></td>
<td>
<p>String of length 1 giving the name the object might have.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>nms
</p>
<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nms_try_rename(c(a = 1), "A", "a")
nms_try_rename(data.frame(a = 1), "A", "a")

# Passes
nms_try_rename(c(a = 1, 1), "A", "a")
## Not run: 
# Errs
# nms_try_rename(1, "A", "A")

## End(Not run)

</code></pre>

<hr>
<h2 id='pick_drop'>Pick and drop rows from <em>ViewFullTable</em>, <em>tree</em>, and <em>stem</em> tables.</h2><span id='topic+pick_drop'></span><span id='topic+pick_dbh_min'></span><span id='topic+pick_dbh_max'></span><span id='topic+pick_dbh_under'></span><span id='topic+pick_dbh_over'></span><span id='topic+pick_status'></span><span id='topic+drop_status'></span>

<h3>Description</h3>

<p>These functions provide an expressive and convenient way to pick specific
rows from ForestGEO datasets. They allow you to remove missing values (with
<code>na.rm = TRUE</code>) but conservatively default to preserving them. This behavior
is similar to <code><a href="base.html#topic+subset">base::subset()</a></code> and unlike <code>dplyr::filter()</code>. This
conservative default is important because you want want to include missing
trees in your analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_dbh_min(data, value, na.rm = FALSE)

pick_dbh_max(data, value, na.rm = FALSE)

pick_dbh_under(data, value, na.rm = FALSE)

pick_dbh_over(data, value, na.rm = FALSE)

pick_status(data, value, na.rm = FALSE)

drop_status(data, value, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_drop_+3A_data">data</code></td>
<td>
<p>A ForestGEO-like dataframe: A <em>ViewFullTable</em>, <em>tree</em> or <em>stem</em>
table.</p>
</td></tr>
<tr><td><code id="pick_drop_+3A_value">value</code></td>
<td>
<p>An atomic vector; a single value against to compare each value
of the variable encoded in the function's name.</p>
</td></tr>
<tr><td><code id="pick_drop_+3A_na.rm">na.rm</code></td>
<td>
<p>Set to <code>TRUE</code> if you want to remove missing values from the
variable encoded in the function's name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe similar to .<code>data</code> but including only the rows with
matching conditions.
</p>


<h3>See Also</h3>

<p><code>dplyr::filter()</code>, <code>Extract</code> (<code>[</code>).
</p>
<p>Other functions for fgeo census and vft: 
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>
</p>
<p>Other functions for fgeo census: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>
</p>
<p>Other functions for fgeo vft: 
<code><a href="#topic+add_status_tree">add_status_tree</a>()</code>,
<code><a href="#topic+add_subquad">add_subquad</a>()</code>,
<code><a href="#topic+add_var">add_var</a>()</code>,
<code><a href="#topic+guess_plotdim">guess_plotdim</a>()</code>
</p>
<p>Other functions to pick or drop rows of a ForestGEO dataframe: 
<code><a href="#topic+pick_main_stem">pick_main_stem</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># styler: off
census &lt;- tribble(
  ~dbh, ~status,
     0,     "A",
    50,     "A",
   100,     "A",
   150,     "A",
    NA,     "M",
    NA,     "D",
    NA,      NA
  )
# styler: on

# &lt;=
pick_dbh_max(census, 100)
pick_dbh_max(census, 100, na.rm = TRUE)

# &gt;=
pick_dbh_min(census, 100)
pick_dbh_min(census, 100, na.rm = TRUE)

# &lt;
pick_dbh_under(census, 100)
pick_dbh_under(census, 100, na.rm = TRUE)

# &gt;
pick_dbh_over(census, 100)
pick_dbh_over(census, 100, na.rm = TRUE)
# Same, but `subset()` does not let you keep NAs.
subset(census, dbh &gt; 100)

# ==
pick_status(census, "A")
pick_status(census, "A", na.rm = TRUE)

# !=
drop_status(census, "D")
drop_status(census, "D", na.rm = TRUE)

# Compose
pick_dbh_over(
  drop_status(census, "D", na.rm = TRUE),
  100
)

# More readable as a pipiline
census %&gt;%
  drop_status("D", na.rm = TRUE) %&gt;%
  pick_dbh_over(100)

# Also works with ViewFullTables
# styler: off
vft &lt;- tribble(
  ~DBH,   ~Status,
     0,   "alive",
    50,   "alive",
   100,   "alive",
   150,   "alive",
    NA, "missing",
    NA,    "dead",
    NA,        NA
)
# styler: on

pick_dbh_max(vft, 100)

pick_status(vft, "alive", na.rm = TRUE)

</code></pre>

<hr>
<h2 id='pick_main_stem'>Pick the main stem or main stemid(s) of each tree in each census.</h2><span id='topic+pick_main_stem'></span><span id='topic+pick_main_stemid'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+pick_main_stem">pick_main_stem()</a></code> picks a unique row for each <code>treeID</code> per census.
</p>
</li>
<li> <p><code><a href="#topic+pick_main_stemid">pick_main_stemid()</a></code> picks a unique row for each <code>stemID</code> per census. It is
only useful when a single stem was measured twice in the same census, which
sometimes happens to correct for the effect of large buttresses.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pick_main_stem(data)

pick_main_stemid(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_main_stem_+3A_data">data</code></td>
<td>
<p>A ForestGEO-like dataframe: A <em>ViewFullTable</em>, <em>tree</em> or <em>stem</em>
table.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+pick_main_stem">pick_main_stem()</a></code> picks the main stem of each tree in each census. It
collapses data of multi-stem trees by picking a single stem per <code>treeid</code> per
<code>censusid</code>. From this group, it picks the stem at the top of a list sorted
first by descending order of <code>hom</code> and then by descending order of <code>dbh</code>.
This this corrects the effect of buttresses and picks the main stem. It
ignores groups of grouped data and rejects data with multiple plots.
</p>
</li>
<li> <p><code><a href="#topic+pick_main_stemid">pick_main_stemid()</a></code> does one step less than <code><a href="#topic+pick_main_stem">pick_main_stem()</a></code>. It only
picks the main stemid(s) of each tree in each census and keeps all stems per
treeid. This is useful when calculating the total basal area of a tree,
because you need to sum the basal area of each individual stem as well as sum
only one of the potentially multiple measurements of each buttressed stem per
census.
</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe with a single plotname, and one row per per treeid per
censusid.
</p>


<h3>Warning</h3>

<p>These functions may be considerably slow. They are fastest if the data
already has a single stem per treeid. They are slower with data containing
multiple stems per <code>treeid</code> (per <code>censusid</code>), which is the main reason for
using this function. The slowest scenario is when data also contains
duplicated values of <code>stemid</code> per <code>treeid</code> (per <code>censusid</code>). This may
happen if trees have buttresses, in which case these functions check
every stem for potential duplicates and pick the one with the largest <code>hom</code>
value.
</p>
<p>For example, in a windows computer with 32 GB of RAM, a dataset with 2
million rows with multiple stems and buttresses took about 3 minutes to run.
And a dataset with 2 million rows made up entirely of main stems took about
ten seconds to run.
</p>


<h3>See Also</h3>

<p>Other functions to pick or drop rows of a ForestGEO dataframe: 
<code><a href="#topic+pick_drop">pick_drop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One `treeID` with multiple stems.
# `stemID == 1.1` has two measurements (due to buttresses).
# `stemID == 1.2` has a single measurement.
# styler: off
census &lt;- tribble(
    ~sp, ~treeID, ~stemID,  ~hom, ~dbh, ~CensusID,
  "sp1",     "1",   "1.1",   140,   40,         1,  # main stemID (max `hom`)
  "sp1",     "1",   "1.1",   130,   60,         1,
  "sp1",     "1",   "1.2",   130,   55,         1   # main stemID (only one)
)
#' # styler: on

# Picks a unique row per unique `treeID`
pick_main_stem(census)

# Picks a unique row per unique `stemID`
pick_main_stemid(census)

</code></pre>

<hr>
<h2 id='read_vft'>Import <em>ViewFullTable</em> or <em>ViewTaxonomy</em> data from a .tsv or .csv file.</h2><span id='topic+read_vft'></span><span id='topic+read_taxa'></span>

<h3>Description</h3>

<p><code><a href="#topic+read_vft">read_vft()</a></code> and <code><a href="#topic+read_taxa">read_taxa()</a></code> help you to read <em>ViewFullTable</em> and
<em>ViewTaxonomy</em> data from text files delivered by the ForestGEO database.
These functions avoid common problems about column separators, missing
values, column names, and column types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vft(file, delim = NULL, na = c("", "NA", "NULL"), ...)

read_taxa(file, delim = NULL, na = c("", "NA", "NULL"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vft_+3A_file">file</code></td>
<td>
<p>A path to a file.</p>
</td></tr>
<tr><td><code id="read_vft_+3A_delim">delim</code></td>
<td>
<p>Single character used to separate fields within a record. The
default (<code>delim = NULL</code>) is to guess between comma or tab (<code>","</code> or <code>"\t"</code>).</p>
</td></tr>
<tr><td><code id="read_vft_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="read_vft_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a>.
</p>


<h3>Acknowledgments</h3>

<p>Thanks to Shameema Jafferjee Esufali for inspiring the feature that
automatically detects <code>delim</code> (issue 65).
</p>


<h3>See Also</h3>

<p><code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code>, <code><a href="#topic+type_vft">type_vft()</a></code>, <code><a href="#topic+type_taxa">type_taxa()</a></code>.
</p>
<p>Other functions to read text files delivered by ForestgGEO's database: 
<code><a href="#topic+type_vft">type_vft</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")
library(fgeo.x)

example_path()

file_vft &lt;- example_path("view/vft_4quad.csv")
read_vft(file_vft)

file_taxa &lt;- example_path("view/taxa.csv")
read_taxa(file_taxa)
</code></pre>

<hr>
<h2 id='recode_subquad'>Recode subquadrat.</h2><span id='topic+recode_subquad'></span>

<h3>Description</h3>

<p>Recode subquadrat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_subquad(data, offset = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_subquad_+3A_data">data</code></td>
<td>
<p>A dataframe with the variable <code>subquadrat</code>.</p>
</td></tr>
<tr><td><code id="recode_subquad_+3A_offset">offset</code></td>
<td>
<p>A number; either -1 or 1, to rest or add one unit to the number
of column of each subquadrat.
</p>
<div class="sourceCode R"><pre>First column is 0    First column is 1
-----------------    -----------------
   04 14 24 34          14 24 34 44
   03 13 23 33          13 23 33 43
   02 12 22 32          12 22 32 42
   01 11 21 31          11 21 31 41
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first_subquad_11 &lt;- tibble(subquadrat = c("11", "12", "22"))
first_subquad_11

first_subquad_01 &lt;- recode_subquad(first_subquad_11, offset = -1)
first_subquad_01

first_subquad_11 &lt;- recode_subquad(first_subquad_01, offset = 1)
first_subquad_11
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+7C+7C+25'></span><span id='topic+filter'></span><span id='topic+mutate'></span><span id='topic+select'></span><span id='topic+arrange'></span><span id='topic+summarize'></span><span id='topic+summarise'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+count'></span><span id='topic+add_count'></span><span id='topic+starts_with'></span><span id='topic+ends_with'></span><span id='topic+contains'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+tibble'></span><span id='topic+tribble'></span><span id='topic+as_tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+count">add_count</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+op-null-default">%||%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>, <code><a href="tibble.html#topic+tibble">tibble</a></code>, <code><a href="tibble.html#topic+tribble">tribble</a></code>, <code><a href="tibble.html#topic+tribble">tribble</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rename_matches'>Rename an object based on case-insensitive match of the names of a reference.</h2><span id='topic+rename_matches'></span>

<h3>Description</h3>

<p>Rename an object based on case-insensitive match of the names of a reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_matches(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_matches_+3A_x">x</code></td>
<td>
<p>x object which names to restored if they match the reference.</p>
</td></tr>
<tr><td><code id="rename_matches_+3A_y">y</code></td>
<td>
<p>Named object to use as reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is <code>x</code> with as many names changed as case-insensitive
matches there are with the reference.
</p>


<h3>See Also</h3>

<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>
<p>Other general functions to deal with names: 
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ref &lt;- data.frame(COL1 = 1, COL2 = 1)
x &lt;- data.frame(col1 = 5, col2 = 1, n = 5)
rename_matches(x, ref)
</code></pre>

<hr>
<h2 id='sanitize_vft'>Fix common problems in <em>ViewFullTable</em> and <em>ViewTaxonomy</em> data.</h2><span id='topic+sanitize_vft'></span><span id='topic+sanitize_taxa'></span>

<h3>Description</h3>

<p>These functions fix common problems of <em>ViewFullTable</em> and <em>ViewTaxonomy</em>
data:
</p>

<ul>
<li><p> Ensure that each column has the correct type.
</p>
</li>
<li><p> Ensure that missing values are represented with <code>NA</code>s &ndash; not with the
literal string &quot;NULL&quot;.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sanitize_vft(.data, na = c("", "NA", "NULL"), ...)

sanitize_taxa(.data, na = c("", "NA", "NULL"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_vft_+3A_.data">.data</code></td>
<td>
<p>A dataframe; either a ForestGEO <em>ViewFullTable</em>
(<code>sanitize_vft()</code>).
or <em>ViewTaxonomy</em> (<code>sanitize_vft()</code>).</p>
</td></tr>
<tr><td><code id="sanitize_vft_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="sanitize_vft_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="readr.html#topic+type_convert">readr::type_convert()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Acknowledgments</h3>

<p>Thanks to Shameema Jafferjee Esufali for motivating this functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_vft">read_vft()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

vft &lt;- fgeo.x::vft_4quad

# Introduce problems to show how to fix them
# Bad column types
vft[] &lt;- lapply(vft, as.character)
# Bad representation of missing values
vft$PlotName &lt;- "NULL"

# "NULL" should be replaced by `NA` and `DBH` should be numeric
str(vft[c("PlotName", "DBH")])

# Fix
vft_sane &lt;- sanitize_vft(vft)
str(vft_sane[c("PlotName", "DBH")])

taxa &lt;- read.csv(fgeo.x::example_path("taxa.csv"))
# E.g. inserting bad column types
taxa[] &lt;- lapply(taxa, as.character)
# E.g. inserting bad representation of missing values
taxa$SubspeciesID &lt;- "NULL"

# "NULL" should be replaced by `NA` and `ViewID` should be integer
str(taxa[c("SubspeciesID", "ViewID")])

# Fix
taxa_sane &lt;- sanitize_taxa(taxa)
str(taxa_sane[c("SubspeciesID", "ViewID")])
</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>

<p>This page lists the tidy eval tools reexported in this package from
rlang. To learn about using tidy eval in scripts and packages at a
high level, see the <a href="https://dplyr.tidyverse.org/articles/programming.html">dplyr programming vignette</a>
and the <a href="https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html">ggplot2 in packages vignette</a>.
The <a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a> may also be useful for a deeper dive.
</p>

<ul>
<li><p> The tidy eval operators <code style="white-space: pre;">&#8288;{{&#8288;</code>, <code style="white-space: pre;">&#8288;!!&#8288;</code>, and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are syntactic
constructs which are specially interpreted by tidy eval functions.
You will mostly need <code style="white-space: pre;">&#8288;{{&#8288;</code>, as <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are more advanced
operators which you should not have to use in simple cases.
</p>
<p>The curly-curly operator <code style="white-space: pre;">&#8288;{{&#8288;</code> allows you to tunnel data-variables
passed from function arguments inside other tidy eval functions.
<code style="white-space: pre;">&#8288;{{&#8288;</code> is designed for individual arguments. To pass multiple
arguments contained in dots, use <code>...</code> in the normal way.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  data %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>
</li>
<li> <p><code><a href="#topic+enquo">enquo()</a></code> and <code><a href="#topic+enquos">enquos()</a></code> delay the execution of one or several
function arguments. The former returns a single expression, the
latter returns a list of expressions. Once defused, expressions
will no longer evaluate on their own. They must be injected back
into an evaluation context with <code style="white-space: pre;">&#8288;!!&#8288;</code> (for a single expression) and
<code style="white-space: pre;">&#8288;!!!&#8288;</code> (for a list of expressions).
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  # Defuse
  var &lt;- enquo(var)
  dots &lt;- enquos(...)

  # Inject
  data %&gt;%
    group_by(!!!dots) %&gt;%
    summarise(mean = mean(!!var))
}
</pre></div>
<p>In this simple case, the code is equivalent to the usage of <code style="white-space: pre;">&#8288;{{&#8288;</code>
and <code>...</code> above. Defusing with <code>enquo()</code> or <code>enquos()</code> is only
needed in more complex cases, for instance if you need to inspect
or modify the expressions in some way.
</p>
</li>
<li><p> The <code>.data</code> pronoun is an object that represents the current
slice of data. If you have a variable name in a string, use the
<code>.data</code> pronoun to subset that variable with <code>[[</code>.
</p>
<div class="sourceCode"><pre>my_var &lt;- "disp"
mtcars %&gt;% summarise(mean = mean(.data[[my_var]]))
</pre></div>
</li>
<li><p> Another tidy eval operator is <code style="white-space: pre;">&#8288;:=&#8288;</code>. It makes it possible to use
glue and curly-curly syntax on the LHS of <code>=</code>. For technical
reasons, the R language doesn't support complex expressions on
the left of <code>=</code>, so we use <code style="white-space: pre;">&#8288;:=&#8288;</code> as a workaround.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  # Use `{{` to tunnel function arguments and the usual glue
  # operator `{` to interpolate plain strings.
  data %&gt;%
    summarise("{{ var }}_mean_{suffix}" := mean({{ var }}))
}
</pre></div>
</li>
<li><p> Many tidy eval functions like <code>dplyr::mutate()</code> or
<code>dplyr::summarise()</code> give an automatic name to unnamed inputs. If
you need to create the same sort of automatic names by yourself,
use <code>as_label()</code>. For instance, the glue-tunnelling syntax above
can be reproduced manually with:
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  var &lt;- enquo(var)
  prefix &lt;- as_label(var)
  data %&gt;%
    summarise("{prefix}_mean_{suffix}" := mean(!!var))
}
</pre></div>
<p>Expressions defused with <code>enquo()</code> (or tunnelled with <code style="white-space: pre;">&#8288;{{&#8288;</code>) need
not be simple column names, they can be arbitrarily complex.
<code>as_label()</code> handles those cases gracefully. If your code assumes
a simple column name, use <code>as_name()</code> instead. This is safer
because it throws an error if the input is not a name as expected.
</p>
</li></ul>


<hr>
<h2 id='type_ensure'>Ensure the specific columns of a dataframe have a particular type.</h2><span id='topic+type_ensure'></span>

<h3>Description</h3>

<p>Ensure the specific columns of a dataframe have a particular type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_ensure(df, ensure_nms, type = "numeric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_ensure_+3A_df">df</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="type_ensure_+3A_ensure_nms">ensure_nms</code></td>
<td>
<p>Character vector giving names of <code>df</code> to ensure <code>type</code></p>
</td></tr>
<tr><td><code id="type_ensure_+3A_type">type</code></td>
<td>
<p>A string giving the type to ensure in columns <code>ensure_nms</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>df</code>, with columns (specified in <code>ensure_nms</code>)
of type <code>type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+modify">purrr::modify_at()</a></code>.
</p>
<p>Other functions to operate on column types: 
<code><a href="#topic+type_vft">type_vft</a>()</code>
</p>
<p>Other functions for developers: 
<code><a href="#topic+check_crucial_names">check_crucial_names</a>()</code>,
<code><a href="#topic+extract_insensitive">extract_insensitive</a>()</code>,
<code><a href="#topic+flag_if_group">flag_if_group</a>()</code>,
<code><a href="#topic+is_multiple">is_multiple</a>()</code>,
<code><a href="#topic+nms_try_rename">nms_try_rename</a>()</code>,
<code><a href="#topic+rename_matches">rename_matches</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfm &lt;- tibble(
  w = c(NA, 1, 2),
  x = 1:3,
  y = as.character(1:3),
  z = letters[1:3]
)
dfm
type_ensure(dfm, c("w", "x", "y"), "numeric")
type_ensure(dfm, c("w", "x", "y", "z"), "character")
</code></pre>

<hr>
<h2 id='type_vft'>Help to read ForestGEO data safely, with consistent columns type.</h2><span id='topic+type_vft'></span><span id='topic+type_taxa'></span>

<h3>Description</h3>

<p>A common cause of problems is feeding functions with data which columns are
not all of the expected type. The problem often begins when reading data from
a text file with functions such as <code><a href="utils.html#topic+read.table">utils::read.csv()</a></code>,
<code><a href="utils.html#topic+read.table">utils::read.delim()</a></code>, and friends &ndash; which commonly guess wrongly the column
type that you more likely expect. These common offenders are strongly
discouraged; instead consider using <code>readr::read_csv()</code>, <code>readr::read_tsv()</code>,
and friends, which guess column types correctly much more often than their
analogs from the <strong>utils</strong> package.
</p>
<p><code>type_vft()</code> and <code>type_taxa()</code> help you to read data more safely by
explicitly specifying what type to expect from each column of known datasets.
These functions output the specification of column types used internally by
<code><a href="#topic+read_vft">read_vft()</a></code> and <code><a href="#topic+read_taxa">read_taxa()</a></code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;type_vft():&#8288;</code> Type specification for <em>ViewFullTable</em>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;type_taxa():&#8288;</code> Type specification for <em>ViewFullTaxonomy</em>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>type_vft()

type_taxa()
</code></pre>


<h3>Details</h3>

<p>Types reference (for more details see <code><a href="readr.html#topic+read_delim">read_delim()</a></code>):
</p>

<ul>
<li><p> c = character,
</p>
</li>
<li><p> i = integer,
</p>
</li>
<li><p> n = number,
</p>
</li>
<li><p> d = double,
</p>
</li>
<li><p> l = logical,
</p>
</li>
<li><p> D = date,
</p>
</li>
<li><p> T = date time,
</p>
</li>
<li><p> t = time,
</p>
</li>
<li><p> ? = guess,
</p>
</li>
<li><p> or _/- to skip the column.'.
</p>
</li></ul>



<h3>Value</h3>

<p>A list.
</p>


<h3>See Also</h3>

<p><code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code>.
</p>
<p>Other functions to operate on column types: 
<code><a href="#topic+type_ensure">type_ensure</a>()</code>
</p>
<p>Other functions to read text files delivered by ForestgGEO's database: 
<code><a href="#topic+read_vft">read_vft</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")
library(fgeo.x)
library(readr)

str(type_vft())

read_csv(example_path("view/vft_4quad.csv"), col_types = type_vft())

str(type_taxa())

read_csv(example_path("view/taxa.csv"), col_types = type_taxa())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
