<!DOCTYPE html><html><head><title>Help for package distillML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distillML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ale'><p>Constructs an ALE for a model.</p></a></li>
<li><a href='#build.grid'><p>Build grid used for weights in distilled surrogate model</p></a></li>
<li><a href='#center.preds'><p>Centers the predicted values for 1-d ICE and PDP plots or 2-d PDP plots</p></a></li>
<li><a href='#distill'><p>Builds surrogate model from an interpreter object based on the univariate</p>
PDP functions of the original model.</a></li>
<li><a href='#Interpreter'><p>Interpreter class description</p></a></li>
<li><a href='#localSurrogate'><p>Given a interpreter object with at least one pair of features,</p>
create a small surrogate model for the two features using the PDP function
as the output and the two features as the independent variables.</a></li>
<li><a href='#plot-Interpreter'><p>Plotting method for Interpretor model</p></a></li>
<li><a href='#predict_ALE'><p>Prediction function for the ALE plots</p></a></li>
<li><a href='#predict_ICE.Plotter'><p>Prediction Function for ICE Plots</p></a></li>
<li><a href='#predict_PDP.1D.Plotter'><p>Prediction Function for PDP Plots</p></a></li>
<li><a href='#predict_PDP.2D.Plotter'><p>Two Dimensional Prediction Curve for PDP Plots</p></a></li>
<li><a href='#predict-Predictor'><p>Predict method for Predictor class</p></a></li>
<li><a href='#predict-Surrogate'><p>Prediction method for the distilled surrogate model</p></a></li>
<li><a href='#Predictor'><p>Predictor class description</p></a></li>
<li><a href='#print-Predictor'><p>The Printing method for Predictor class</p></a></li>
<li><a href='#set.center.at'><p>Sets a new center in the PDP and ICE plots made by an Interpreter</p></a></li>
<li><a href='#set.grid.points'><p>Sets grid points used for plotting PDP and ICE plots</p></a></li>
<li><a href='#Surrogate'><p>Surrogate class description</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Distillation and Interpretability Methods for Machine
Learning Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0.13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theo Saarinen &lt;theo_s@berkeley.edu&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/forestry-labs/distillML/issues">https://github.com/forestry-labs/distillML/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/forestry-labs/distillML">https://github.com/forestry-labs/distillML</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several methods for model distillation and interpretability 
    for general black box machine learning models and treatment effect estimation
    methods. For details on the algorithms implemented, see <a href="https://forestry-labs.github.io/distillML/index.html">https://forestry-labs.github.io/distillML/index.html</a>
    Brian Cho, Theo F. Saarinen, Jasjeet S. Sekhon, Simon Walter.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, glmnet, Rforestry, dplyr, R6 (&ge; 2.0), checkmate,
purrr, tidyr, data.table, mltools, gridExtra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, mvtnorm</td>
</tr>
<tr>
<td>Collate:</td>
<td>'predictor.R' 'interpret.R' 'distiller.R' 'plotter.R'
'surrogate.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 18:59:47 UTC; theosaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian Cho [aut],
  Theo Saarinen [aut, cre],
  Jasjeet Sekhon [aut],
  Simon Walter [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-25 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ale'>Constructs an ALE for a model.</h2><span id='topic+ale'></span>

<h3>Description</h3>

<p>Constructs an ALE for a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ale(
  predict_function,
  num_grid_points,
  training_data,
  variable_names,
  center = "zero",
  grid_points,
  window_size
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ale_+3A_predict_function">predict_function</code></td>
<td>
<p>a function taking a single tibble argument and returning the model
predictions corresponding to that tibble.</p>
</td></tr>
<tr><td><code id="ale_+3A_num_grid_points">num_grid_points</code></td>
<td>
<p>the number of grid_points at which to construct the ALE</p>
</td></tr>
<tr><td><code id="ale_+3A_training_data">training_data</code></td>
<td>
<p>the training data used to fit the model</p>
</td></tr>
<tr><td><code id="ale_+3A_variable_names">variable_names</code></td>
<td>
<p>a vector of feature names in training data for which an ALE is required.</p>
</td></tr>
<tr><td><code id="ale_+3A_center">center</code></td>
<td>
<p>one of &quot;uncentered&quot; meaning the plots are not centered, &quot;mean&quot;
meaning the plots are centered at their mean and &quot;zero&quot; meaning the ALE
passes through the origin. When using center == &quot;zero&quot; we recommend setting
window_size because otherwise a smaller and possibly empty set will be used
to compute the ALE at zero.</p>
</td></tr>
<tr><td><code id="ale_+3A_grid_points">grid_points</code></td>
<td>
<p>The grid points to use for the AlE calculation.</p>
</td></tr>
<tr><td><code id="ale_+3A_window_size">window_size</code></td>
<td>
<p>the fraction of the data (between zero and one) used to compute each ALE point.</p>
</td></tr>
</table>

<hr>
<h2 id='build.grid'>Build grid used for weights in distilled surrogate model</h2><span id='topic+build.grid'></span>

<h3>Description</h3>

<p>A dataframe storing the true predictions and the PDP predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.grid(object, feat.ind = 1:length(object$features))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.grid_+3A_object">object</code></td>
<td>
<p>The Interpreter object</p>
</td></tr>
<tr><td><code id="build.grid_+3A_feat.ind">feat.ind</code></td>
<td>
<p>The indices of the features in the Interpreter's features that we want
to include as PDP functions in the distilled model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe used to find weights in regression (one-hot encoding for
categorical features)
</p>


<h3>Note</h3>

<p>This function is mainly used as a subroutine for the distill function. We include this
as a public function to allow users to create their own weights and surrogate functions
outside of our implemented method.
</p>

<hr>
<h2 id='center.preds'>Centers the predicted values for 1-d ICE and PDP plots or 2-d PDP plots</h2><span id='topic+center.preds'></span>

<h3>Description</h3>

<p>Given the specified 'center.at' values of the Interpreter object, this
function centers all of the plots in the Interpreter object
of the specified type of plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.preds(object, features = NULL, plot.type, feats.2d = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.preds_+3A_object">object</code></td>
<td>
<p>The Interpreter object to use</p>
</td></tr>
<tr><td><code id="center.preds_+3A_features">features</code></td>
<td>
<p>A vector of names for the 1-D features we want to center</p>
</td></tr>
<tr><td><code id="center.preds_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot that the user wants to center the predictions of.
should be one of either &quot;ICE&quot;, &quot;PDP.1D&quot;, or &quot;PDP.2D&quot;</p>
</td></tr>
<tr><td><code id="center.preds_+3A_feats.2d">feats.2d</code></td>
<td>
<p>A 2-column dataframe or matrix that gives the first variable in
in the first column, and the second variable in the next. The
number of rows is equal to the number of 2-D PDPs one would like
to center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>center.preds
</p>


<h3>Value</h3>

<p>A list of centered data frame/matrix of values for the plot
</p>


<h3>Note</h3>

<p>This function is mainly used to examine the exact values in the plot if the
plot is centered. Note that this function should only be called after calling
one of the various predict functions that matches the 'plot.type' parameter
with 'save' equal to TRUE.
</p>

<hr>
<h2 id='distill'>Builds surrogate model from an interpreter object based on the univariate
PDP functions of the original model.</h2><span id='topic+distill'></span>

<h3>Description</h3>

<p>Builds a surrogate model from the PDP functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distill(
  object,
  center.mean = TRUE,
  features = 1:length(object$features),
  cv = FALSE,
  snap.grid = TRUE,
  snap.train = TRUE,
  params.glmnet = list(),
  params.cv.glmnet = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distill_+3A_object">object</code></td>
<td>
<p>The Interpreter object</p>
</td></tr>
<tr><td><code id="distill_+3A_center.mean">center.mean</code></td>
<td>
<p>Boolean value that determines whether to center each column
of predictions by their respective means. Default is TRUE</p>
</td></tr>
<tr><td><code id="distill_+3A_features">features</code></td>
<td>
<p>The indices of the features in the Interpreter's features that we want
to include as PDP functions in the distilled model.</p>
</td></tr>
<tr><td><code id="distill_+3A_cv">cv</code></td>
<td>
<p>Boolean that indicates whether we want to cross-validate our fitted coefficients
with a regularizer. This should only be done when regularizing coefficients.</p>
</td></tr>
<tr><td><code id="distill_+3A_snap.grid">snap.grid</code></td>
<td>
<p>Boolean function that determines whether the model recalculates
each value predicted or uses an approximation from previous
calculations. When this parameter is set to TRUE, we approximate
the predicted values with prevoius calculations. Default is TRUE.</p>
</td></tr>
<tr><td><code id="distill_+3A_snap.train">snap.train</code></td>
<td>
<p>Boolean that determines whether we use the training data or the
equally spaced grid points. By default, this is true, which means
we snap to grid points as determined by the training data's marginal
distribution.</p>
</td></tr>
<tr><td><code id="distill_+3A_params.glmnet">params.glmnet</code></td>
<td>
<p>Optional list of parameters to pass to glmnet while fitting
PDP curves to resemble the original predictions. By specifying
parameters, one can do lasso or ridge regression.</p>
</td></tr>
<tr><td><code id="distill_+3A_params.cv.glmnet">params.cv.glmnet</code></td>
<td>
<p>Optional list of parameters to pass to cv.glmnet while fitting
PDP curves to resemble the original predictions. By specifying
parameters, one can do lasso or ridge regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A surrogate class object that can be used for predictions
</p>


<h3>Note</h3>

<p>For further details, please refer to the vignette for this method, which includes
usage examples.
</p>

<hr>
<h2 id='Interpreter'>Interpreter class description</h2><span id='topic+Interpreter'></span>

<h3>Description</h3>

<p>A wrapper class based on a predictor object for examining the
predictions of the model with respect to one or two features.
The two methods for interpreting a model based on one or two features are partial
dependence plots (PDP), which averages over the marginal distribution
of the predictions of the model, and accumulated local effects (ALE) functions
which averages over the conditional distribution of the predictions of the model.
</p>
<p>The only necessary argument is the Predictor object. The other arguments are
optional, but it may be useful to specify the number of samples or the specific
data points (data.points) if the training data is very large.
This can greatly reduce the time for computation.
</p>
<p>For the output, the model returns an interpreter object with two lists of
functions: one for interpreting a single feature's role in the black-box
model, and the other for intepreting a pair of features' role in the
black-box model. These interpretability functions are built for each
possible feature (or pair of features). Each of these functions return
a vector of averaged predictions equal in length to the number of
values (or number of rows) input into the function.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>predictor</code></dt><dd><p>The Predictor object that contains the model that the user wants
to query. This is the only parameter that is required to initialize an
Interpreter object. All entries in the vector must
match column names from the 'data' parameter of the Predictor object.</p>
</dd>
<dt><code>features</code></dt><dd><p>An optional list of single features that we want to create PDP functions for.</p>
</dd>
<dt><code>features.2d</code></dt><dd><p>A two column data frame that contains pairs of names that we
want to create 2D PDP functions for. All entries in the data frame must
match column names from the 'data' parameter of the Predictor object.</p>
</dd>
<dt><code>data.points</code></dt><dd><p>A vector of indices of data points in the training
data frame to be used as the observations for creating the PDP/ICE/ALE plots.
When the training data is large, it can greatly reduce the required computation
to pass only a downsampled subset of the training data to the pdp
function construction. Alternatively, if one is only interested understanding
the model predictions for a specific subgroup, the indices of the observations
in the given subgroup can be passed here.</p>
</dd>
<dt><code>pdp.1d</code></dt><dd><p>A List of functions giving single feature PDP interpretations of the model.</p>
</dd>
<dt><code>pdp.2d</code></dt><dd><p>A List of functions giving two-feature PDP interpretations of the model</p>
</dd>
<dt><code>feat.class</code></dt><dd><p>A vector that contains the class for each feature (categorical or continuous)</p>
</dd>
<dt><code>center.at</code></dt><dd><p>The value(s) to center the feature plots at. A list of equal length
to the length of the features.</p>
</dd>
<dt><code>grid.points</code></dt><dd><p>A list of vectors containing the grid points to use for
the predictions for PDP and ICE plots. For ALE plots, we
use quantile-based methods that depend on the distribution of
the training data.</p>
</dd>
<dt><code>grid.size</code></dt><dd><p>The number of grid points to plot for a continuous feature. This
parameter sets the number of grid points for PDP, ICE, and ALE plots.</p>
</dd>
<dt><code>saved</code></dt><dd><p>A list that caches the previous calculations for the 1-D ICE plots,
1-D PDP plots, 2-D PDP plots, and grid points for building the distilled model.
This saves the uncentered calculations.</p>
</dd>
<dt><code>ale.grid</code></dt><dd><p>A list that caches the saved predictions for the ALE plots</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Interpreter-new"><code>Interpreter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Interpreter-clone"><code>Interpreter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Interpreter-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Interpreter$new(
  predictor = NULL,
  samples = 1000,
  data.points = NULL,
  grid.size = 50
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>The Predictor object that contains the model that the user wants
to query. This is the only parameter that is required to initialize an
Interpreter object. All entries in the vector must
match column names from the 'data' parameter of the Predictor object.</p>
</dd>
<dt><code>samples</code></dt><dd><p>The number of observations used for the interpretability
method. If no number is given, the default set is the
minimum between 1000 and the number of rows in the
training data set. Rows with missing values are excluded from
being sampled.</p>
</dd>
<dt><code>data.points</code></dt><dd><p>The indices of the data points used for the PDP/ALE. This
overwrites the &quot;samples&quot; parameter above.</p>
</dd>
<dt><code>grid.size</code></dt><dd><p>The number of grid points used to create for the PDP, ICE, and ALE
plots for each feature.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An 'Interpreter' object.
</p>


<hr>
<a id="method-Interpreter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Interpreter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The class that wraps a Predictor object for application of different
interpretability methods. For usage examples, please refer to the README
document.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distillML)
library(Rforestry)
set.seed(491)
data &lt;- iris

test_ind &lt;- sample(1:nrow(data), nrow(data)%/%5)
train_reg &lt;- data[-test_ind,]
test_reg &lt;- data[test_ind,]


forest &lt;- forestry(x=data[,-1],
                   y=data[,1])

forest_predictor &lt;- Predictor$new(model = forest, data=train_reg,
                                  y="Sepal.Length", task = "regression")

forest_interpret &lt;- Interpreter$new(predictor = forest_predictor)

</code></pre>

<hr>
<h2 id='localSurrogate'>Given a interpreter object with at least one pair of features,
create a small surrogate model for the two features using the PDP function
as the output and the two features as the independent variables.</h2><span id='topic+localSurrogate'></span>

<h3>Description</h3>

<p>Plots and returns a Rforestry object with a single tree explaining
the PDP surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localSurrogate(
  object,
  features.2d = NULL,
  interact = FALSE,
  params.forestry = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localSurrogate_+3A_object">object</code></td>
<td>
<p>Interpreter object to make plots + surrogate for.</p>
</td></tr>
<tr><td><code id="localSurrogate_+3A_features.2d">features.2d</code></td>
<td>
<p>A two-column dataframe of pairs of features to make local surrogates for.
Each row represents a pair of features, with the names of features as the
entries.</p>
</td></tr>
<tr><td><code id="localSurrogate_+3A_interact">interact</code></td>
<td>
<p>An indicator specifying if the surrogate model should also be
given the interaction terms to create the surrogate models with.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="localSurrogate_+3A_params.forestry">params.forestry</code></td>
<td>
<p>Optional list of parameters to pass to the surrogate
model. Defaults to the standard Rforestry parameters with ntree = 1
and maxDepth = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two distinct lists: one list contains the local surrogate models,
and the other containing the 2-D PDP plots for the specified features.
</p>

<hr>
<h2 id='plot-Interpreter'>Plotting method for Interpretor model</h2><span id='topic+plot-Interpreter'></span><span id='topic+plot.Interpreter'></span>

<h3>Description</h3>

<p>Plots the PDP, ALE, or ICE plots for an Interpreter object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Interpreter'
plot(
  x,
  method = "pdp+ice",
  features = NULL,
  features.2d = NULL,
  clusters = NULL,
  clusterType = "preds",
  smooth = FALSE,
  smooth.bandwidth = NULL,
  smooth.kernel = "normal",
  smooth.npoints = 2 * x$grid.size,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-Interpreter_+3A_x">x</code></td>
<td>
<p>Interpreter object to generate plots from</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_method">method</code></td>
<td>
<p>The type of plot that we want to generate. Must be one of &quot;ice&quot;,
&quot;pdp+ice&quot;, &quot;pdp&quot;, or &quot;ale&quot;</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_features">features</code></td>
<td>
<p>a vector of feature names that we want to produce 1-D plots for.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_features.2d">features.2d</code></td>
<td>
<p>2-D features that we want to produce plots for arguments.
A two-column dataframe of pairs of features to make local
surrogates for. Each row represents a pair of features,
with the names of features as the entries.If
the 'method' parameter is set to &quot;ale&quot;, this argument should not
be used.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_clusters">clusters</code></td>
<td>
<p>A number of clusters to cluster the ICE predictions with.
If this is not NULL, one must use the method &quot;ice&quot;.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_clustertype">clusterType</code></td>
<td>
<p>An indicator specifying what method to use for the clustering.
The possible options are &quot;preds&quot;, and &quot;gradient&quot;. If &quot;preds&quot; is used, the clusters
will be determined by running K means on the predictions of the ICE functions.
If the &quot;gradient&quot; option is used, the clusters will be determined by running K
means on the numerical gradient of the predictions of the ICE functions. If
this is not NULL, one must use the method &quot;ice&quot;.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_smooth">smooth</code></td>
<td>
<p>A binary variable to determine whether to smoothen the plots of the
PDP, ICE, or ALE curves for continuous variables.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_smooth.bandwidth">smooth.bandwidth</code></td>
<td>
<p>The bandwidth for the kernels. They are scaled such that
their quartiles are at 0.25 * bandwidth. By default, this
is set as the maximum difference between the minimum and
maximum of the grid points.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_smooth.kernel">smooth.kernel</code></td>
<td>
<p>The type of kernel to be used. Users can input either strings &quot;box&quot;
or &quot;normal&quot;. The default is &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_smooth.npoints">smooth.npoints</code></td>
<td>
<p>The number of points returned when using the kernel method. By
default, this is twice the number of grid points for that
feature.</p>
</td></tr>
<tr><td><code id="plot-Interpreter_+3A_...">...</code></td>
<td>
<p>Additiional parameters to pass to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of plots with 1-d features and 2-d features. For 2-d features with
one continuous and one categorical feature, the plot is a linear plot of the
continuous feature with group colors representing the categorical feature.
For two continuous features, the plot is a heatmap with the shade representing
the value of the outcome.
</p>

<hr>
<h2 id='predict_ALE'>Prediction function for the ALE plots</h2><span id='topic+predict_ALE'></span>

<h3>Description</h3>

<p>Prediction function for the ALE plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_ALE(x, feature, training_data, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_ALE_+3A_x">x</code></td>
<td>
<p>An interpreter object</p>
</td></tr>
<tr><td><code id="predict_ALE_+3A_feature">feature</code></td>
<td>
<p>The feature to build the ALE for (must be continuous)</p>
</td></tr>
<tr><td><code id="predict_ALE_+3A_training_data">training_data</code></td>
<td>
<p>The training data to use in order to build the ALE</p>
</td></tr>
<tr><td><code id="predict_ALE_+3A_save">save</code></td>
<td>
<p>Boolean to save the ALE predictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble that contains the ALE predictions for the given values
</p>

<hr>
<h2 id='predict_ICE.Plotter'>Prediction Function for ICE Plots</h2><span id='topic+predict_ICE.Plotter'></span>

<h3>Description</h3>

<p>Gives predictions at each point on the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_ICE.Plotter(object, features = NULL, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_ICE.Plotter_+3A_object">object</code></td>
<td>
<p>The Interpeter object to use.</p>
</td></tr>
<tr><td><code id="predict_ICE.Plotter_+3A_features">features</code></td>
<td>
<p>A vector with the names of the features to predict ICE plots for</p>
</td></tr>
<tr><td><code id="predict_ICE.Plotter_+3A_save">save</code></td>
<td>
<p>A boolean indicator to indicate whether the calculations should be
saved in the interpreter object or not. This can help reduce
computation if the ICE functions are used many times, but requires
additional memory to store the predictions. By default, this is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, one for each feature. In each data frame, the first
column contains the grid values for the feature, and each subsequent
column has a single observation corresponding to the prediction of the model
when with the given feature set to that grid point value.
</p>


<h3>Note</h3>

<p>This method is meant to primarily be used to find the exact values for the ICE
curves plotted. Note that after the PDP curve is plotted, the returned
object of this function will be the saved predictions for plotting the curve, rather
than a recalculation of the values.
</p>

<hr>
<h2 id='predict_PDP.1D.Plotter'>Prediction Function for PDP Plots</h2><span id='topic+predict_PDP.1D.Plotter'></span>

<h3>Description</h3>

<p>Gives prediction curve for all specified features in the
plotter object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_PDP.1D.Plotter(object, features = NULL, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_PDP.1D.Plotter_+3A_object">object</code></td>
<td>
<p>The Interpreter object to plot PDP curves for.</p>
</td></tr>
<tr><td><code id="predict_PDP.1D.Plotter_+3A_features">features</code></td>
<td>
<p>A vector with the names of the features to predict ICE plots for</p>
</td></tr>
<tr><td><code id="predict_PDP.1D.Plotter_+3A_save">save</code></td>
<td>
<p>A boolean indicator to indicate whether the calculations should be
saved in the interpreter object or not. This can help reduce
computation if the PDP functions are used many times, but requires
additional memory to store the predictions. By default, this is set
to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>predict_PDP.1D.Plotter
</p>


<h3>Value</h3>

<p>A list of data frames with the grid points and PDP prediction values
for each feature in object
</p>


<h3>Note</h3>

<p>This method is meant to primarily be used to find the exact values for the 1-D PDP
curves plotted. Note that after the PDP curve is plotted, the returned
object of this function will be the saved predictions for plotting the curve, rather
than a recalculation of the values.
</p>

<hr>
<h2 id='predict_PDP.2D.Plotter'>Two Dimensional Prediction Curve for PDP Plots</h2><span id='topic+predict_PDP.2D.Plotter'></span>

<h3>Description</h3>

<p>Gives prediction surface for all specified feature pairs in the
interpreter object (features.2d)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_PDP.2D.Plotter(object, feat.2d, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_PDP.2D.Plotter_+3A_object">object</code></td>
<td>
<p>The Interpreter object to use.</p>
</td></tr>
<tr><td><code id="predict_PDP.2D.Plotter_+3A_feat.2d">feat.2d</code></td>
<td>
<p>A 2-column dataframe or matrix that gives the first variable in
in the first column, and the second variable in the next. The
number of rows is equal to the number of 2-D PDPs one would like.</p>
</td></tr>
<tr><td><code id="predict_PDP.2D.Plotter_+3A_save">save</code></td>
<td>
<p>A boolean indicator to indicate whether the calculations should be
saved in the interpreter object or not. This can help reduce
computation if the PDP functions are used many times, but requires
additional memory to store the predictions. By default, this is set
to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>predict_PDP.2D.Plotter
</p>


<h3>Value</h3>

<p>A list of data frames for each pair of features.2d. Each data frame
contains columns corresponding to the grid points for the two selected
features and a column corresponding to the predictions of the model
at the given combination of grid points.
</p>


<h3>Note</h3>

<p>This method is meant to primarily be used to find the exact values for the 2-D PDP
curves or heatmap plotted. Note that after the PDP curve is plotted, the returned
object of this function will be the saved predictions for plotting the curve, rather
than a recalculation of the values.
</p>

<hr>
<h2 id='predict-Predictor'>Predict method for Predictor class</h2><span id='topic+predict-Predictor'></span><span id='topic+predict.Predictor'></span>

<h3>Description</h3>

<p>Gives a single column of predictions from a model that
is wrapped by the Predictor object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Predictor'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict-Predictor_+3A_object">object</code></td>
<td>
<p>The Predictor object to use to make predictions.</p>
</td></tr>
<tr><td><code id="predict-Predictor_+3A_newdata">newdata</code></td>
<td>
<p>The data frame to use for the independent features in the prediction.</p>
</td></tr>
<tr><td><code id="predict-Predictor_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed to the model predict function.
For instance, these can be different aggregation options (aggregation = &quot;oob&quot;)
that are accepted by the prediction function of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a single column containing the predictions for each
row of the newdata data frame.
</p>

<hr>
<h2 id='predict-Surrogate'>Prediction method for the distilled surrogate model</h2><span id='topic+predict-Surrogate'></span><span id='topic+predict.Surrogate'></span>

<h3>Description</h3>

<p>Predicts outputs given new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Surrogate'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict-Surrogate_+3A_object">object</code></td>
<td>
<p>A surrogate object distilled from the interpreter</p>
</td></tr>
<tr><td><code id="predict-Surrogate_+3A_newdata">newdata</code></td>
<td>
<p>The dataframe to use for the predictions</p>
</td></tr>
<tr><td><code id="predict-Surrogate_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to predict</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-column dataframe of the surrogate model's predictions
</p>

<hr>
<h2 id='Predictor'>Predictor class description</h2><span id='topic+Predictor'></span>

<h3>Description</h3>

<p>A wrapper class for generic ML algorithms (xgboost, RF, BART, rpart, etc.)
in order to standardize the predictions given by different algorithms to be
compatible with the interpretability functions.
</p>
<p>The necessary variables are model, data, y. The other variables are
optional, and depend on the use cases. Type should be used only when
a prediction function is NOT specified.
</p>
<p>The outputs of the algorithm must be the values if it is regression, or
probabilities if classification. For classification problems with more than
two categories, the output comes out as vectors of probabilities for the
specified &quot;class&quot; category. Because this is for ML interpretability,
other types of predictions (ex: predictions that spit out the factor) are not allowed.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data</code></dt><dd><p>The training data that was used during training for the model. This should
be a data frame matching the data frame the model was given for training, which
includes the label or outcome.</p>
</dd>
<dt><code>model</code></dt><dd><p>The object corresponding to the trained model that we want to make a
Predictor object for. If this model doesn't have a generic predict method,
the user has to provide a custom predict function that accepts a data frame.</p>
</dd>
<dt><code>task</code></dt><dd><p>The prediction task the model is trained to perform ('classification' or 'regression').</p>
</dd>
<dt><code>class</code></dt><dd><p>The class for which we get predictions. We specify this to get the predictions
(such as probabilites) for an observation being in a specific class (e.g. Male or Female).
This parameter is necessary for classification predictions with more than a single vector
of predictions.</p>
</dd>
<dt><code>prediction.function</code></dt><dd><p>An optional parameter if the model doesn't have a
generic prediction function. This should take a data frame and return a
vector of predictions for each observation in the data frame.</p>
</dd>
<dt><code>y</code></dt><dd><p>The name of the outcome feature in the 'data' data frame.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Predictor-new"><code>Predictor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Predictor-clone"><code>Predictor$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Predictor-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Predictor$new(
  model = NULL,
  data = NULL,
  predict.func = NULL,
  y = NULL,
  task = NULL,
  class = NULL,
  type = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>The object corresponding to the trained model that we want to make a
Predictor object for. If this model doesn't have a generic predict method,
the user has to provide a custom predict function that accepts a data frame.</p>
</dd>
<dt><code>data</code></dt><dd><p>The training data that was used during training for the model. This should
be a data frame matching the data frame the model was given for training, including
the label or outcome.</p>
</dd>
<dt><code>predict.func</code></dt><dd><p>An optional parameter if the model doesn't have a
generic prediction function. This should take a data frame and return a
vector of predictions for each observation in the data frame.</p>
</dd>
<dt><code>y</code></dt><dd><p>The name of the outcome feature in the 'data' data frame.</p>
</dd>
<dt><code>task</code></dt><dd><p>The prediction task the model is trained to perform ('classification' or 'regression').</p>
</dd>
<dt><code>class</code></dt><dd><p>The class for which we get predictions. We specify this to get the predictions
(such as probabilites) for an observation being in a specific class (e.g. Male or Female).
This parameter is necessary for classification predictions with more than a single vector
of predictions.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of predictions done (i.e. 'response' for predicted probabliities for classification).
This feature should only be used if no predict.func is specified.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A 'Predictor' object.
</p>


<hr>
<a id="method-Predictor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Predictor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The class that wraps a machine learning model in order to provide a
standardized method for predictions for different models.
prediction method must be constructed, with optional argument of type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(distillML)
library(Rforestry)
set.seed(491)
data &lt;- iris

test_ind &lt;- sample(1:nrow(data), nrow(data)%/%5)
train_reg &lt;- data[-test_ind,]
test_reg &lt;- data[test_ind,]


forest &lt;- forestry(x=data[,-1],
                   y=data[,1])

forest_predictor &lt;- Predictor$new(model = forest, data=train_reg,
                                  y="Sepal.Length", task = "regression")

</code></pre>

<hr>
<h2 id='print-Predictor'>The Printing method for Predictor class</h2><span id='topic+print-Predictor'></span><span id='topic+print.Predictor'></span>

<h3>Description</h3>

<p>Prints the task of an instance of the Predictor class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Predictor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-Predictor_+3A_x">x</code></td>
<td>
<p>The Predictor object to print</p>
</td></tr>
<tr><td><code id="print-Predictor_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print function.</p>
</td></tr>
</table>

<hr>
<h2 id='set.center.at'>Sets a new center in the PDP and ICE plots made by an Interpreter</h2><span id='topic+set.center.at'></span>

<h3>Description</h3>

<p>Method for setting center value for a specific feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.center.at(object, feature, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.center.at_+3A_object">object</code></td>
<td>
<p>The Interpreter class that we want to recenter the plots of.</p>
</td></tr>
<tr><td><code id="set.center.at_+3A_feature">feature</code></td>
<td>
<p>The name of the feature to set grid points for.</p>
</td></tr>
<tr><td><code id="set.center.at_+3A_value">value</code></td>
<td>
<p>The new value to use for the plots of the specified feature to be centered at.
Must match the type of the feature (a factor level or continuous value in the range
of the specified feature).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Unlike the grid predictions, the center.at values do not modify any of the
previous saved calculations. Therefore, it does not change or remove any of the
previously calculated, saved data. These center values are simply for the plots
made by the interpreter object, rather than the distilled model.
</p>

<hr>
<h2 id='set.grid.points'>Sets grid points used for plotting PDP and ICE plots</h2><span id='topic+set.grid.points'></span>

<h3>Description</h3>

<p>Method for setting grid points for a specific feature plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.grid.points(object, feature, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.grid.points_+3A_object">object</code></td>
<td>
<p>The Interpreter class that we want to modify the grid points of.</p>
</td></tr>
<tr><td><code id="set.grid.points_+3A_feature">feature</code></td>
<td>
<p>The name of the feature to set grid points for.</p>
</td></tr>
<tr><td><code id="set.grid.points_+3A_values">values</code></td>
<td>
<p>The set of new values to be used as the grid points for the selected feature.
Must be a vector with entries in the range of the feature values in the training set
and must match the type of the given feature (either a vector of factor levels
or a vector of continuous feature values). Note that the center must be within
the range of new grid points for continuous features.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Because the grid points determine what calculations are performed for the
PDP/ICE functions, changing the grid points will remove any of the previously
calculated values in the 'Interpreter' object. For any 1-D ICE
or PDP plot, it will remove the previous calculations for the given feature. For any 2-D PDP
calcuations, it will remove plots that include the given feature as any of its features.
Note that these set grid points only apply to PDP and ICE plots, and ALE plots have their
own grid points determined by the distribution of the training data.
</p>

<hr>
<h2 id='Surrogate'>Surrogate class description</h2><span id='topic+Surrogate'></span>

<h3>Description</h3>

<p>The class for distilled surrogate models.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>interpreter</code></dt><dd><p>The interpreter object to use as a standardized wrapper for the model</p>
</dd>
<dt><code>features</code></dt><dd><p>The indices of the features in the data used in the surrogate model</p>
</dd>
<dt><code>weights</code></dt><dd><p>The weights used to recombine the PDPs into a surrogate for the original model</p>
</dd>
<dt><code>intercept</code></dt><dd><p>The intercept term we use for our predictions</p>
</dd>
<dt><code>feature.centers</code></dt><dd><p>The center value for the features determined in the model</p>
</dd>
<dt><code>center.mean</code></dt><dd><p>Boolean value that determines whether we use the mean-centered
data for our predictions</p>
</dd>
<dt><code>grid</code></dt><dd><p>A list of PDPS that determine our prediction.</p>
</dd>
<dt><code>snap.grid</code></dt><dd><p>Boolean that determines whether we use grid.points</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Surrogate-new"><code>Surrogate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-clone"><code>Surrogate$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Surrogate-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Surrogate$new(
  interpreter,
  features,
  weights,
  intercept,
  feature.centers,
  center.mean,
  grid,
  snap.grid
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interpreter</code></dt><dd><p>The interpreter object we want to build a surrogate model for.</p>
</dd>
<dt><code>features</code></dt><dd><p>The indices of features in the training data used for the surrogate model</p>
</dd>
<dt><code>weights</code></dt><dd><p>The weights for each given feature after the surrogate model is fit.</p>
</dd>
<dt><code>intercept</code></dt><dd><p>The baseline value. If uncentered, this is 0, and if centered,
this will be the mean of the predictions of the original model
on the training data.</p>
</dd>
<dt><code>feature.centers</code></dt><dd><p>The baseline value for the effect of each feature. If uncentered, this is 0.</p>
</dd>
<dt><code>center.mean</code></dt><dd><p>A boolean value that shows whether this model is a centered or uncentered model</p>
</dd>
<dt><code>grid</code></dt><dd><p>A list of dataframes containing the pre-calculated values used to generate predictions
if snap.grid is TRUE</p>
</dd>
<dt><code>snap.grid</code></dt><dd><p>Boolean that determines if we use previously calculated values
or re-predict using the functions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A surrogate model object that we can use for predictions
</p>


<hr>
<a id="method-Surrogate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>Do not initalize this class on its own. It is automatically created
by the distill function for the interpreter class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(distillML)
library(Rforestry)
set.seed(491)
data &lt;- iris

test_ind &lt;- sample(1:nrow(data), nrow(data)%/%5)
train_reg &lt;- data[-test_ind,]
test_reg &lt;- data[test_ind,]


forest &lt;- forestry(x=data[,-1],
                   y=data[,1])

forest_predictor &lt;- Predictor$new(model = forest, data=train_reg,
                                  y="Sepal.Length", task = "regression")

forest_interpret &lt;- Interpreter$new(predictor = forest_predictor)

# Both initializations of a surrogate class result in the same surrogate model
surrogate.model &lt;- distill(forest_interpret)
surrogate.model &lt;- distill(forest_interpret,
                           center.mean = TRUE,
                           features = 1:length(forest_interpret$features),
                           cv = FALSE,
                           snap.grid = TRUE,
                           snap.train = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
