<!DOCTYPE html><html><head><title>Help for package flexrsurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flexrsurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flexrsurv'><p>Fit Relative Survival Model</p></a></li>
<li><a href='#flexrsurv-internal.Rd'>
<p>Internal Objects and functions for the <span class="pkg">flexrsurv </span> package</p></a></li>
<li><a href='#flexrsurv-package'>
<p>Package for flexible relative survival analyses</p></a></li>
<li><a href='#flexrsurvclt'><p> Fit Relative Survival Model and Correct Life Tables</p></a></li>
<li><a href='#getBrassHazardFromTable'><p>Compute expected hazards with respect to a corrected reference life table</p></a></li>
<li><a href='#getHazardFromTable'><p> computes expected hazards with respect to a reference life table</p></a></li>
<li><a href='#getPseudoHazardFromTable'><p>Computes expected hazards with respect to a reference life table</p></a></li>
<li><a href='#logLik.flexrsurv'><p>Log-Likelihood and the number of observations for a <code>flexrsuv</code> fit.</p></a></li>
<li><a href='#NLL'><p>Non Log-Linear effect</p></a></li>
<li><a href='#NLLbeta'><p>Non Log-Linear effect and non proportional effect</p></a></li>
<li><a href='#NPH'><p>Non Proportional Hazard effect</p></a></li>
<li><a href='#NPHNLL'><p>Non Proportional Hazard and Non Log-Linear effect</p></a></li>
<li><a href='#predict.flexrsurv'><p>Predictions for a relative survival model</p></a></li>
<li><a href='#predictCLT'><p>Predictions for relational life table model</p></a></li>
<li><a href='#predictSpline'><p>Generic method for prediction of spline function</p></a></li>
<li><a href='#print.flexrsurv'><p> Print a Short Summary of a Relative Survival Model</p></a></li>
<li><a href='#summary.flexrsurv'><p> Summarizing Flexible Relative Survival Model Fits</p></a></li>
<li><a href='#WCEI'><p>Weighted cumulative exposure index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Relative Survival Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.18</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Isabelle Clerc-Urmès [aut],
  Michel Grzebyk [aut, cre],
  Guy Hédelin [ctb],
  CENSUR working survival group [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michel Grzebyk &lt;michel.grzebyk@inrs.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Package for parametric relative survival analyses. It allows to model non-linear and 
        non-proportional effects and both non proportional and non linear effects, using splines (B-spline and truncated power basis), Weighted Cumulative Index of Exposure effect, with correction model for 
        the life table. Both non proportional and non linear effects are described in 
			Remontet, L. et al. (2007) &lt;<a href="https://doi.org/10.1002%2Fsim.2656">doi:10.1002/sim.2656</a>&gt; and 
			Mahboubi, A. et al. (2011) &lt;<a href="https://doi.org/10.1002%2Fsim.4208">doi:10.1002/sim.4208</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>relsurv, mexhaz, ggplot2, date, lubridate</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, orthogonalsplinebasis, methods, stats, Epi, Formula,
formula.tools, splines, statmod, numDeriv, R.utils, Matrix</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 14:44:29 UTC; michel.grzebyk</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='flexrsurv'>Fit Relative Survival Model</h2><span id='topic+flexrsurv'></span><span id='topic+flexrsurv.ll'></span>

<h3>Description</h3>

<p><code>flexrsurv</code> is used to fit relative survival regression model. 
Time dependent variables, non-proportionnal (time dependent) effects,
non-linear effects are implemented using Splines (B-spline and truncated power basis).
Simultaneously non linear and non proportional effects are implemented
using approaches developed by Remontet et al.(2007) and Mahboubi et al. (2011). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexrsurv(formula=formula(data),
   data=parent.frame(), 
   knots.Bh,
   degree.Bh=3,
   Spline=c("b-spline", "tp-spline", "tpi-spline"), 
   log.Bh=FALSE,
   bhlink=c("log", "identity"),
   Min_T=0,
   Max_T=NULL,
   model=c("additive","multiplicative"),
   rate=NULL, 
   weights=NULL,
   na.action=NULL,
   int_meth=c("GL", "CAV_SIM", "SIM_3_8", "BOOLE", "BANDS"),
   npoints=20,   
   stept=NULL,              
   bands=NULL,
   init=NULL,
   initbyglm=TRUE,
   initbands=bands,
   optim.control=list(trace=100, REPORT=1, fnscale=-1, maxit=25), 
   optim_meth=c("BFGS", "CG", "Nelder-Mead", "L-BFGS-B", "SANN", "Brent"),
   control.glm=list(epsilon=1e-8, maxit=100, trace=FALSE, epsilon.glm=1e-1, maxit.glm=25),
   vartype =  c("oim", "opg", "none"),
   debug=FALSE
   )


flexrsurv.ll(formula=formula(data), 
   data=parent.frame(), 
   knots.Bh=NULL,   
   degree.Bh=3,
   Spline=c("b-spline", "tp-spline", "tpi-spline"), 
   log.Bh=FALSE,
   bhlink=c("log", "identity"),
   Min_T=0,
   Max_T=NULL,
   model=c("additive","multiplicative"),
   rate=NULL, 
   weights=NULL,
   na.action=NULL, 
   int_meth=c("GL", "CAV_SIM", "SIM_3_8", "BOOLE", "GLM", "BANDS"),
   npoints=20,   
   stept=NULL,
   bands=NULL,
   init=NULL,
   optim.control=list(trace=100, REPORT=1, fnscale=-1, maxit=25), 
   optim_meth=c("BFGS", "CG", "Nelder-Mead", "L-BFGS-B", "SANN", "Brent"),
   vartype =  c("oim", "opg", "none"),
   debug=FALSE
   )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexrsurv_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a ~ operator, and the terms on the
right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function. 
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the formula.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_knots.bh">knots.Bh</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the baseline hazard. 
Typical values are the mean or median for one knot, quantiles for more knots.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_degree.bh">degree.Bh</code></td>
<td>

<p>degree of the piecewise polynomial of the baseline hazard. Default is 3 for cubic splines.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_spline">Spline</code></td>
<td>
 
<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, 
&quot;tp-spline&quot; for truncated power basis and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_log.bh">log.Bh</code></td>
<td>

<p>logical value: if TRUE, an additional basis equal to log(time) is added to the spline bases of time.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_bhlink">bhlink</code></td>
<td>

<p>logical value: if TRUE, log of baseline hazard is modelled, if FALSE, the baseline hazard is out of the log.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_min_t">Min_T</code></td>
<td>

<p>minimum of time period which is analysed. Default is <code>max(0.0, min(bands) )</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_max_t">Max_T</code></td>
<td>

<p>maximum of time period which is analysed. Default is <code>max(c(bands, timevar))</code>
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_model">model</code></td>
<td>

<p>character string specifying the type of model for both non-proportionnal and non linear effects. 
The model <code>method=="additive"</code> assumes effects as explained in Remontet et al.(2007), 
the model <code>method=="multiplicative"</code> assumes effects as explained in Mahboubi et al. (2011).
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_rate">rate</code></td>
<td>

<p>an optional vector of the background rate for a relevant comparative population to be used in the fitting process. 
Should be a numeric vector (for relative survival model). 
<code>rate</code> is evaluated in the same way as variables in <code>formula</code>, that is first 
in <code>data</code> and then in the environment of <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
If not null, the total likelihood is the weighted sum of individual likelihood. 
</p>
</td></tr> 
<tr><td><code id="flexrsurv_+3A_na.action">na.action</code></td>
<td>

<p>a missing-data filter function, applied to the model.frame, after any subset argument has been used. 
Default is options()$na.action.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_int_meth">int_meth</code></td>
<td>

<p>character string specifying the the numerical integration method. Possible values are 
&quot;GL&quot; for Gauss-Legendre quadrature, 
&quot;CAV_SIM&quot; for Cavalieri-Simpson's rule, &quot;SIM_3_8&quot; for the Simpson's 3/8 rule, 
&quot;BOOLE&quot; for the Boole's rule, or &quot;BANDS&quot; for the midpoint rule with specified bands.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_npoints">npoints</code></td>
<td>

<p>number of points used in the Gauss-Legendre quadrature (when <code>int_meth="GL"</code>).
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_stept">stept</code></td>
<td>

<p>scalar value of the time-step in numerical integration. It is required only when  <code>int_meth="CAV_SIM"</code> or <code>"SIM_3_8"</code> or <code>"BOOLE"</code>. 
If no value is supplied,  <code>Max_T/500</code> is used.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_bands">bands</code></td>
<td>

<p>bands used to split data in the numerical integration when <code>int_meth="BANDS"</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_init">init</code></td>
<td>

<p>starting values of the parameters.  
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_initbyglm">initbyglm</code></td>
<td>

<p>a logical value indicating indicating how are found or refined init values. If TRUE, the fitting method described in Remontet 
et al.(2007) is ued to find or refine starting values. This may speedup the fit. If FALSE, the maximisation of the likelihood 
starts at values given in <code>init</code>. If <code>init=NULL</code>, the starting values correspond to a constant net hazard equal to 
the ratio of the number of event over the total number of person-time.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_initbands">initbands</code></td>
<td>

<p>bands used to split data when <code>initbyglm=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_optim.control">optim.control</code></td>
<td>

<p>a list of control parameters passed to the <code><a href="stats.html#topic+optim">optim()</a></code> function.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_optim_meth">optim_meth</code></td>
<td>

<p>method to be used to optimize the likelihood. 
See <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_control.glm">control.glm</code></td>
<td>

<p>a list of control parameters passed to the <code><a href="stats.html#topic+glm">glm()</a></code> function when <code>method="glm"</code>. 
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_vartype">vartype</code></td>
<td>

<p>character string specifying the type of variance matrix computed by <code>flexrsurv</code>: the inverse of the hessian matrix computed 
at the MLE estimate (ie. the inverse of the observed information matrix) if <code>vartype="oim"</code>, the inverse of the outer 
product of the gradients if <code>vartype="opg"</code>. The variance is not computed when <code>vartype="none"</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurv_+3A_debug">debug</code></td>
<td>

<p>control the volum of intermediate output
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A full description of the additive and the multiplicative both non-linear and non-proportional models is given respectively in Remontet (2007) and Mahboubi (2011).
</p>
<p><code>flexrsurv.ll</code> is the workhorse function: it is not normally called
directly.
</p>


<h3>Value</h3>

<p><code>flexrsurv</code> returns an object of class <code>"flexrsurv"</code>.
An object of class <code>"flexrsurv"</code> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>the log-likelihood
</p>
</td></tr>
<tr><td><code>var</code></td>
<td>

<p>estimated covariance matrix for the estimated coefficients
</p>
</td></tr>
<tr><td><code>informationMatrix</code></td>
<td>

<p>estimated information matrix
</p>
</td></tr>
<tr><td><code>bhlink</code></td>
<td>

<p>the linkk of baseline hazard:
if <code>"identity"</code> baseline = sum g0_i b_i(t);
if <code>"log"</code> log(baseline) = sum g0_i b_i(t); 
</p>
</td></tr>
<tr><td><code>init</code></td>
<td>

<p>vector of the starting values supplied
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>logical, Was the optimlizer algorithm judged to have converged? 
</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>

<p>the linear fit on link scale (not including the baseline hazard term if <code>bhlink = "identity"</code>)
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>the estimated value of the hazard rate at each event time, obtained by transforming the linear predictors by the inverse of the link function
</p>
</td></tr>
<tr><td><code>cumulative.hazard</code></td>
<td>

<p>the estimated value of the cumulative hazard in the time interval
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>the formula supplied
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>the <code>data</code> argument
</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>

<p>the rate vector used
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>the time vector used
</p>
</td></tr>
<tr><td><code>workingformula</code></td>
<td>

<p>the formula used by the fitter
</p>
</td></tr>
<tr><td><code>optim.control</code></td>
<td>

<p>the value of the <code>optim.control</code> argument supplied
</p>
</td></tr>
<tr><td><code>control.glm</code></td>
<td>

<p>the value of the <code>control.glm</code> argument supplied
</p>
</td></tr>   
<tr><td><code>method</code></td>
<td>

<p>the name of the fitter function used
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mahboubi, A., M. Abrahamowicz, et al. (2011). &quot;Flexible modeling of the effects of continuous prognostic factors in relative survival.&quot; Stat Med 30(12): 1351-1365. <a href="https://doi.org/10.1002/sim.4208">doi:10.1002/sim.4208</a>
</p>
<p>Remontet, L., N. Bossard, et al. (2007). &quot;An overall strategy based on regression models to estimate relative survival and model the effects of prognostic factors in cancer survival studies.&quot; Stat Med 26(10): 2214-2228. <a href="https://doi.org/10.1002/sim.2656">doi:10.1002/sim.2656</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.flexrsurv">print.flexrsurv</a></code>, 
<code><a href="#topic+summary.flexrsurv">summary.flexrsurv</a></code>, 
<code><a href="#topic+logLik.flexrsurv">logLik.flexrsurv</a></code>, 
<code><a href="#topic+predict.flexrsurv">predict.flexrsurv</a></code>, 

<code><a href="#topic+NPH">NPH</a></code>, 
<code><a href="#topic+NLL">NLL</a></code>, and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (requireNamespace("relsurv", quietly = TRUE)) {

	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	
	# get the death rate at event (or end of followup) from slopop for rdata
	rdata$iage &lt;- findInterval(rdata$age*365.24+rdata$time, attr(slopop, "cutpoints")[[1]])
	rdata$iyear &lt;- findInterval(rdata$year+rdata$time, attr(slopop, "cutpoints")[[2]])
	therate &lt;- rep(-1, dim(rdata)[1])
	for( i in 1:dim(rdata)[1]){
	  therate[i] &lt;- slopop[rdata$iage[i], rdata$iyear[i], rdata$sex[i]]
	}
	
	rdata$slorate &lt;- therate
	
	# change sex coding
	rdata$sex01 &lt;- rdata$sex -1
	
	# fit a relative survival model with a non linear effect of age
	fit &lt;- flexrsurv(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                 rate=slorate, data=rdata,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	summary(fit)
	
	# fit a relative survival model with a non linear &amp; non proportional effect of age
	fit2 &lt;- flexrsurv(Surv(time,cens)~sex01+NPHNLL(age, time, Knots=60,
	                                               Degree=3,
	                                               Knots.t = 1850, Degree.t = 3), 
	                 rate=slorate, data=rdata,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Spline = "b-spline",
	                 initbyglm=TRUE, 
	                 int_meth= "BOOLE",
	                 step=50
	                 )
	summary(fit2, correlation=TRUE)
	
}

</code></pre>

<hr>
<h2 id='flexrsurv-internal.Rd'>
Internal Objects and functions for the <span class="pkg">flexrsurv </span> package
</h2><span id='topic+flexrsurv-internal.Rd'></span><span id='topic+flexrsurv.ll.fromto.brass.wce.fit'></span><span id='topic+flexrsurv.ll.fromto.brass0.wceadd.fitCoptim'></span><span id='topic+flexrsurv.ll.fromto.brass0.wce.fitCoptim'></span><span id='topic+flexrsurv.ll.fromto.brass0.periode.wce.fitCoptim'></span><span id='topic+weighted_cummulative_exposure'></span><span id='topic+MSplineBasis-class'></span><span id='topic+MSplineBasis'></span><span id='topic+gradientwce'></span><span id='topic+predictwce'></span><span id='topic+ndf.flexrsurvclt'></span><span id='topic+.SplineBasis-class'></span><span id='topic+getDegree+2C.SplineBasis-method'></span><span id='topic+getKnots+2C.SplineBasis-method'></span><span id='topic+getLog+2C.SplineBasis-method'></span><span id='topic+getNBases+2C.SplineBasis-method'></span><span id='topic+getOrder+2C.SplineBasis-method'></span><span id='topic++2A-methods'></span><span id='topic++2A+2CMSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CMSplineBasis-method'></span><span id='topic++2A+2Cnumeric+2CSplineBasis-method'></span><span id='topic++2A+2Cnumeric+2CTPSplineBasis-method'></span><span id='topic++2A+2CSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2CTPSplineBasis+2Cnumeric-method'></span><span id='topic++2B-methods'></span><span id='topic++2B+2CMSplineBasis+2CMSplineBasis-method'></span><span id='topic++2B+2CMSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CMSplineBasis-method'></span><span id='topic++2B+2Cnumeric+2CSplineBasis-method'></span><span id='topic++2B+2Cnumeric+2CTPSplineBasis-method'></span><span id='topic++2B+2CSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2CSplineBasis+2CSplineBasis-method'></span><span id='topic++2B+2CTPSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2CTPSplineBasis+2CTPSplineBasis-method'></span><span id='topic+--methods'></span><span id='topic+-+2CMSplineBasis+2CMSplineBasis-method'></span><span id='topic+-+2CMSplineBasis+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CMSplineBasis-method'></span><span id='topic+-+2Cnumeric+2CSplineBasis-method'></span><span id='topic+-+2Cnumeric+2CTPSplineBasis-method'></span><span id='topic+-+2CSplineBasis+2Cnumeric-method'></span><span id='topic+-+2CSplineBasis+2CSplineBasis-method'></span><span id='topic+-+2CTPSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2CLEMSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CLEMSplineBasis-method'></span><span id='topic++2B+2CLEMSplineBasis+2CLEMSplineBasis-method'></span><span id='topic++2B+2CLEMSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CLEMSplineBasis-method'></span><span id='topic+-+2CLEMSplineBasis+2CLEMSplineBasis-method'></span><span id='topic+-+2CLEMSplineBasis+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CLEMSplineBasis-method'></span><span id='topic++25+2A+25+2CBSplineBasis+2Cmatrix-method'></span><span id='topic++25+2A+25+2CLEBSplineBasis+2Cmatrix-method'></span><span id='topic++25+2A+25+2CSplineBasis+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CBSplineBasis-method'></span><span id='topic++25+2A+25+2Cmatrix+2CLEBSplineBasis-method'></span><span id='topic++25+2A+25+2Cmatrix+2CSplineBasis-method'></span><span id='topic++2A+2CBSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2CLEBSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CBSplineBasis-method'></span><span id='topic++2A+2Cnumeric+2CLEBSplineBasis-method'></span><span id='topic++2A+2Cnumeric+2CBDSplineBasis-method'></span><span id='topic++2A+2CBDSplineBasis+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CMDSplineBasis-method'></span><span id='topic++2A+2CMDSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2CBSplineBasis+2CBSplineBasis-method'></span><span id='topic++2B+2CBSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2CLEBSplineBasis+2CLEBSplineBasis-method'></span><span id='topic++2B+2CLEBSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CBSplineBasis-method'></span><span id='topic++2B+2Cnumeric+2CLEBSplineBasis-method'></span><span id='topic++2B+2CBDSplineBasis+2CBDSplineBasis-method'></span><span id='topic++2B+2Cnumeric+2CBDSplineBasis-method'></span><span id='topic++2B+2CBDSplineBasis+2Cnumeric-method'></span><span id='topic++2B+2CMDSplineBasis+2CMDSplineBasis-method'></span><span id='topic++2B+2Cnumeric+2CMDSplineBasis-method'></span><span id='topic++2B+2CMDSplineBasis+2Cnumeric-method'></span><span id='topic+-+2CBSplineBasis+2CBSplineBasis-method'></span><span id='topic+-+2CBSplineBasis+2Cnumeric-method'></span><span id='topic+-+2CLEBSplineBasis+2CLEBSplineBasis-method'></span><span id='topic+-+2CLEBSplineBasis+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CBSplineBasis-method'></span><span id='topic+-+2Cnumeric+2CLEBSplineBasis-method'></span><span id='topic+-+2CBDSplineBasis+2CBDSplineBasis-method'></span><span id='topic+-+2Cnumeric+2CBDSplineBasis-method'></span><span id='topic+-+2CBDSplineBasis+2Cnumeric-method'></span><span id='topic+-+2CMDSplineBasis+2CMDSplineBasis-method'></span><span id='topic+-+2Cnumeric+2CMDSplineBasis-method'></span><span id='topic+-+2CMDSplineBasis+2Cnumeric-method'></span><span id='topic+dim+2CBSplineBasis-method'></span><span id='topic+dim+2CEBSplineBasis-method'></span><span id='topic+gradientwce+2C+20TPSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+gradientwce+2C+20MSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+gradientwce+2C+20MDSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+gradientwce+2C+20EMSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20TPSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20MSplineBasis+20+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20MDSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20EMSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20BSplineBasis+20+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictwce+2C+20BDSplineBasis+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+predictSpline+2CBDSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CBSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CEBSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CLEBSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CR2BSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CR2bBSplineBasis+2Cnumeric-method'></span><span id='topic+predictSpline+2CTPSplineBasis+2Cnumeric-method'></span>

<h3>Description</h3>

<p>These are not to be called by the user.
</p>


<h3>Author(s)</h3>

<p> Michel Grzebyk <a href="mailto:michel.grzebyk@inrs.fr">michel.grzebyk@inrs.fr</a></p>

<hr>
<h2 id='flexrsurv-package'>
Package for flexible relative survival analyses
</h2><span id='topic+flexrsurv-package'></span><span id='topic+flexrsurvpackage'></span>

<h3>Description</h3>

<p><code>flexrsurv</code> is a package for parametric relative survival analyses. The package implements non-linear, 
non-proportional effects and both non proportional and non linear effects, using splines (B-spline and truncated power basis), 
Weighted Cumulative Index of Exposure effect, with correction model for the life table. 
Both non proportional and non linear effects are described in Remontet et al. (2007) <a href="https://doi.org/10.1002/sim.2656">doi:10.1002/sim.2656</a> and 
Mahboubi et al. (2011) <a href="https://doi.org/10.1002/sim.4208">doi:10.1002/sim.4208</a>. 
</p>
<p>The main function is <code>flexrsurv()</code>
</p>


<h3>Author(s)</h3>

<p>Michel Grzebyk and Isabelle Clerc-Urmès, with contributions from the CENSUR working survival group. <br />
</p>
<p>Maintainer: &lt;michel.grzebyk@inrs.fr&gt;
</p>


<h3>References</h3>

<p>Mahboubi, A., M. Abrahamowicz, et al. (2011). &quot;Flexible modeling of
the effects of continuous prognostic factors in relative survival.&quot; Stat
Med 30(12): 1351-1365. <a href="https://doi.org/10.1002/sim.4208">doi:10.1002/sim.4208</a> <br />
</p>
<p>Remontet, L., N. Bossard, et al. (2007). &quot;An overall strategy based
on regression models to estimate relative survival and model the effects
of prognostic factors in cancer survival studies.&quot; Stat Med 26(10):
2214-2228. <a href="https://doi.org/10.1002/sim.2656">doi:10.1002/sim.2656</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexrsurv">flexrsurv</a></code>
</p>

<hr>
<h2 id='flexrsurvclt'> Fit Relative Survival Model and Correct Life Tables</h2><span id='topic+flexrsurvclt'></span><span id='topic+flexrsurvclt.ll'></span>

<h3>Description</h3>

<p><code>flexrsurvclt</code> is used to fit relative survival regression model. 
transition package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexrsurvclt(formula=formula(data),
	formula.table=NULL, 
	data=parent.frame(),
	Id,
	baselinehazard=TRUE,
	firstWCEIadditive=FALSE,
	knots.Bh,
	degree.Bh=3,
	intercept.Bh=TRUE,			
	Spline=c("b-spline", "tp-spline", "tpi-spline"), 
	log.Bh=FALSE,
	bhlink=c("log", "identity"),
	Min_T=0,
	Max_T=NULL,
	model=c("additive","multiplicative"),
	rate, 
	logit_start, 
	logit_end,
	logit_start_byperiod = NULL,
	logit_end_byperiod = NULL,
	weights_byperiod = NULL, 
	Id_byperiod = NULL,
	contrasts.table = NULL,
	knots.table=c(-2.5,0,2.5),   
	degree.table=3,
	Spline.table=c("restricted B-splines"), 
	Spline.CLT=R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3),
	model_correction = c("cohort", "period"),
	weights=NULL,
	na.action=NULL,
	datacontrol=NULL,
	Idcontrol,
	ratecontrol, 
	logit_startcontrol, 
	logit_endcontrol,
	logit_start_byperiodcontrol = NULL, 
	logit_end_byperiodcontrol = NULL, 
	weights_byperiodcontrol = NULL,
	Id_byperiodcontrol = NULL,	
	weightscontrol=NULL,
	int_meth=c("GL", "CAV_SIM", "SIM_3_8", "BOOLE", "GLM", "BANDS"),
	bands=NULL,
	npoints=20,
	stept=NULL,              
	init=NULL,
	initbyglm=TRUE,
	initbands=bands,
	optim.control=list(trace=100, REPORT=1, fnscale=-1, maxit=25), 
	optim_meth=c("BFGS", "CG", "Nelder-Mead", "L-BFGS-B", "SANN", "Brent"),
	Coptim.control=list(),
	lower = -Inf,
	upper = Inf,
	control.glm=list(epsilon=1e-8, maxit=100, trace=FALSE, 
					epsilon.glm=.1, maxit.glm=25),
	vartype =  c("oim", "opg", "none"),
	varmethod = c("optim", "numDeriv.hessian", "numDeriv.jacobian"),
	numDeriv.method.args=list(eps=5e-7, d=0.001, 
			zero.tol=sqrt(.Machine$double.eps/7e-4), r=4, v=2),
	debug=FALSE
   )

flexrsurvclt.ll(formula=formula(data),
	formula.table=NULL, 
	data=parent.frame(),
	Id,
	baselinehazard=TRUE,
	firstWCEIadditive=FALSE,
	knots.Bh,
	degree.Bh=3,
	Spline=c("b-spline", "tp-spline", "tpi-spline"), 
	log.Bh=FALSE,
	bhlink=c("log", "identity"),
	intercept.Bh=TRUE,
	Min_T=0,
	Max_T=NULL,
	model=c("additive","multiplicative"),
	rate, 
	logit_start, 
	logit_end,
	logit_start_byperiod = NULL,
	logit_end_byperiod = NULL,
	weights_byperiod = NULL, 
	Id_byperiod = NULL,
	contrasts.table = NULL,
	knots.table=c(-2.5,0,2.5),   
	degree.table=3,
	Spline.table=c("restricted B-splines"), 
	Spline.CLT=R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3),
	model_correction = c("cohort", "period"),
	weights=NULL,
	na.action=NULL,
	datacontrol=NULL,
	Idcontrol,
	ratecontrol, 
	logit_startcontrol, 
	logit_endcontrol,
	logit_start_byperiodcontrol = NULL, 
	logit_end_byperiodcontrol = NULL, 
	weights_byperiodcontrol = NULL,
	Id_byperiodcontrol = NULL,	
	weightscontrol=NULL,
	int_meth=c("GL", "CAV_SIM", "SIM_3_8", "BOOLE", "GLM", "BANDS"),
	bands=NULL,
	npoints=20,
	stept=NULL,              
	init=NULL,
	optim.control=list(trace=100, REPORT=1, fnscale=-1, maxit=25), 
	Coptim.control= list(),
	optim_meth=c("BFGS", "CG", "Nelder-Mead", "L-BFGS-B", "SANN", "Brent"),
	lower = -Inf,
	upper = Inf,
	vartype =  c("oim", "opg", "none"),
	varmethod = c("optim", "numDeriv.hessian", "numDeriv.jacobian"),
	numDeriv.method.args=list(eps=5e-7, d=0.001, 
	 		zero.tol=sqrt(.Machine$double.eps/7e-4), r=4, v=2),
	debug=FALSE
   )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexrsurvclt_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a ~ operator, and the terms on the
right. The response must be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function. 
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_formula.table">formula.table</code></td>
<td>

<p>a formula object, with empty left hand side, and the terms on the
right. This is the formula of the proportional part of the correction
model for the table table 
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the formulas.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_id">Id</code></td>
<td>

<p>vector whose unique values defines the Ids of the subjects.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_baselinehazard">baselinehazard</code></td>
<td>

<p>if FALSE, no baseline hazard in the model
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_firstwceiadditive">firstWCEIadditive</code></td>
<td>

<p>if TRUE, the first WCEI term in the formula is considered as the baseline
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_knots.bh">knots.Bh</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the baseline hazard. 
Typical values are the mean or median for one knot, quantiles for more knots.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_degree.bh">degree.Bh</code></td>
<td>

<p>degree of the piecewise polynomial of the baseline hazard. Default is 3 for cubic splines.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_intercept.bh">intercept.Bh</code></td>
<td>

<p>TRUE if the first bases is included in the baseline hazard. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_spline">Spline</code></td>
<td>
 
<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, 
&quot;tp-spline&quot; for truncated power basis and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_log.bh">log.Bh</code></td>
<td>

<p>logical value: if TRUE, an additional basis equal to log(time) is added to the spline bases of time.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_bhlink">bhlink</code></td>
<td>

<p>character string specifying the link function of the baseline hazard: 
Default is <code>bhlink="log"</code> for including the baseline in the exponential; 
if <code>bhlink="identity"</code>, the baseline hazard is out of the exponential.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_min_t">Min_T</code></td>
<td>

<p>minimum of time period which is analysed. Default is <code>max(0.0, min(bands) )</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_max_t">Max_T</code></td>
<td>

<p>maximum of time period which is analysed. Default is <code>max(c(bands, timevar))</code>
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_model">model</code></td>
<td>

<p>character string specifying the type of model for both non-proportional and non linear effects. 
The model <code>method=="additive"</code> assumes effects as explained in Remontet et al.(2007), the model <code>method=="multiplicative"</code> 
assumes effects as explained in Mahboubi et al. (2011).
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_rate">rate</code></td>
<td>

<p>a vector of the background rate for a relevant comparative population to be used in the fitting process. 
Should be a numeric vector (for relative survival model). 
<code>rate</code> is evaluated in the same way as variables in <code>formula</code>, that is first 
in <code>data</code> and then in the environment of <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_logit_start">logit_start</code></td>
<td>

<p>a vector of the logit of the cumulative hazard at the start of the
interval in the life table.
<code>logit_start</code> is evaluated in the same way as variables in <code>formula</code>, that is first 
in <code>data</code> and then in the environment of <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_logit_end">logit_end</code></td>
<td>

<p>a vector of the logit of the cumulative hazard at the end of the
interval in the life table.
<code>logit_end</code> is evaluated in the same way as variables in <code>formula</code>, that is first 
in <code>data</code> and then in the environment of <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_logit_start_byperiod">logit_start_byperiod</code>, <code id="flexrsurvclt_+3A_logit_end_byperiod">logit_end_byperiod</code>, <code id="flexrsurvclt_+3A_weights_byperiod">weights_byperiod</code>, <code id="flexrsurvclt_+3A_id_byperiod">Id_byperiod</code></td>
<td>

<p>A REMPLIR   
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_knots.table">knots.table</code></td>
<td>

<p>the internal breakpoints on the logit scale that define the knots
of the spline used to estimate the correction model of the life table. 
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_degree.table">degree.table</code></td>
<td>

<p>degree of the piecewise polynomial of the spline used to estimate
the correction model of the life table.
Default is 3 for cubic splines.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_contrasts.table">contrasts.table</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of  <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_spline.table">Spline.table</code></td>
<td>
 
<p>a character string specifying the type of spline basis of the the
correction model of the life table. In this version, only &quot;restricted B-splines&quot; is available. 
&quot;restricted B-splines&quot; are B-spline basis with linear extrapolation + 2nd derivative at boundaries == 0.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_spline.clt">Spline.CLT</code></td>
<td>
 
<p>a S4 object with method deriv() and evaluate().
The spline basis of the correction of the life table can be specified either by the parameters (<code>knots.table</code>, <code>degree.table</code>)
or an S4 object that ca be used for this purpose.
IMPORTANT : the coef of the first basis is constraints to one and <code>evaluate(deriv(spline_B), left_boundary_knots) == 1</code>  
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_model_correction">model_correction</code></td>
<td>

<p>character string specifying A COMPLETER.    
<code>method_correction="cohort"</code> when the provided logit are those of the survival of individuals;
<code>method_correction="period"</code> when the provided logit are those of the survival fuction of age distribution by period.
</p>
</td></tr>   <tr><td><code id="flexrsurvclt_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. 
If not null, the total likelihood is the weighted sum of individual likelihood. 
</p>
</td></tr> 
<tr><td><code id="flexrsurvclt_+3A_na.action">na.action</code></td>
<td>

<p>a missing-data filter function, applied to the model.frame. If <code>NULL</code>, default is <code>options()$na.action</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_datacontrol">datacontrol</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the formula for the control group.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_idcontrol">Idcontrol</code>, <code id="flexrsurvclt_+3A_ratecontrol">ratecontrol</code>, <code id="flexrsurvclt_+3A_logit_startcontrol">logit_startcontrol</code>, <code id="flexrsurvclt_+3A_logit_endcontrol">logit_endcontrol</code>, <code id="flexrsurvclt_+3A_weightscontrol">weightscontrol</code></td>
<td>

<p>Id, rate, logit of the cumulative hazard at the start and the end of
the intervalle in the life table, and weights for the control group
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_logit_start_byperiodcontrol">logit_start_byperiodcontrol</code>, <code id="flexrsurvclt_+3A_logit_end_byperiodcontrol">logit_end_byperiodcontrol</code>, <code id="flexrsurvclt_+3A_weights_byperiodcontrol">weights_byperiodcontrol</code>, <code id="flexrsurvclt_+3A_id_byperiodcontrol">Id_byperiodcontrol</code></td>
<td>

<p>A REMPLIR   
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_int_meth">int_meth</code></td>
<td>

<p>character string specifying the the numerical integration method. Possible values are 
&quot;GL&quot; for Gauss-Legendre method, &quot;CAV_SIM&quot; for Cavalieri-Simpson's rule, &quot;SIM_3_8&quot; for the Simpson's 3/8 rule, 
&quot;BOOLE&quot; for the Boole's rule, or &quot;BANDS&quot; for the midpoint rule with specified bands.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_bands">bands</code></td>
<td>

<p>bands used to split data in the numerical integration when <code>int_meth="BANDS"</code>).
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_npoints">npoints</code></td>
<td>

<p>number of points used in the numerical integration when <code>int_meth="GL"</code>).
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_stept">stept</code></td>
<td>

<p>scalar value of the time-step in numerical integration. It is required only when  <code>int_meth="CAV_SIM"</code> or <code>"SIM_3_8"</code> or <code>"BOOLE"</code>. 
If no value is supplied,  <code>Max_T/500</code> is used.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_init">init</code></td>
<td>

<p>starting values of the parameters.  
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_initbyglm">initbyglm</code></td>
<td>

<p>a logical value indicating indicating how are found or refined init values. If TRUE, the fitting method described in Remontet et al.(2007) 
is ued to find or refine starting values. This may speedup the fit. If FALSE, the maximisation of the likelihood starts at values 
given in <code>init</code>. If <code>init=NULL</code>, the starting values correspond to a constant net hazard equal to the ratio of the number 
of event over the total number of person-time.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_initbands">initbands</code></td>
<td>

<p>bands used to split data when <code>initbyglm=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_optim.control">optim.control</code></td>
<td>

<p>a list of control parameters passed to the <code><a href="stats.html#topic+optim">optim()</a></code> function.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_optim_meth">optim_meth</code></td>
<td>

<p>method to be used to optimize the likelihood. 
See <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_coptim.control">Coptim.control</code></td>
<td>

<p>a list of control parameters passed to the <code><a href="stats.html#topic+constrOptim">constrOptim()</a></code> function 
See <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_lower">lower</code>, <code id="flexrsurvclt_+3A_upper">upper</code></td>
<td>

<p>Bounds on the variables for the &quot;L-BFGS-B&quot; method, or bounds in which to search for method &quot;Brent&quot;. 
See <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_control.glm">control.glm</code></td>
<td>

<p>a list of control parameters passed to the <code><a href="stats.html#topic+glm">glm()</a></code> function when <code>method="glm"</code>. 
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_vartype">vartype</code></td>
<td>

<p>character string specifying the type of variance matrix computed by <code>flexrsurv</code>: the inverse of the hessian matrix computed 
at the MLE estimate (ie. the inverse of the observed information matrix) if <code>vartype="oim"</code>, the inverse of the outer product of 
the gradients if <code>vartype="opg"</code>. The variance is not computed when <code>vartype="none"</code>.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_varmethod">varmethod</code></td>
<td>

<p>character string specifying the method to compute the hessian matrix when <code>vartype="oim"</code>. If <code>varmethod="oim"</code>, 
the hessian matrixe is computed by <code><a href="stats.html#topic+optim">optim</a></code>. If <code>varmethod="numDeriv.hessian"</code>, 
the hessian matrix is computed by <code><a href="numDeriv.html#topic+hessian">numDeriv:hessian</a></code> with <code>method="Richardson"</code>. 
If <code>varmethod="numDeriv.jacobian"</code>, the hessian matrixe is computed by <code><a href="numDeriv.html#topic+jacobian">numDeriv:jacobian</a></code> 
with <code>method="Richardson"</code>. 
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_numderiv.method.args">numDeriv.method.args</code></td>
<td>

<p>arguments passed to <code><a href="numDeriv.html#topic+hessian">numDeriv:hessian</a></code> or <code><a href="numDeriv.html#topic+jacobian">numDeriv:jacobian</a></code> 
when <code>varmethod="numDeriv.hessian"</code> or <code>varmethod="numDeriv.jacobian"</code>. Arguments not specified remain with their 
default values as specified in details. See <code><a href="numDeriv.html#topic+grad">numDeriv:grad</a></code> for details about these parameters.
</p>
</td></tr>
<tr><td><code id="flexrsurvclt_+3A_debug">debug</code></td>
<td>

<p>control the volum of intermediate output
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A full description of the additive and the multiplicative both non-linear and non-proportional models is given respectively 
in Remontet (2007) and Mahboubi (2011).
</p>
<p><code>flexrsurv.ll</code> is the workhorse function: it is not normally called
directly.
</p>


<h3>Value</h3>

<p><code>flexrsurv</code> returns an object of class <code>"flexrsurv"</code>.
An object of class <code>"flexrsurv"</code> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of coefficients
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>the log-likelihood
</p>
</td></tr>
<tr><td><code>var</code></td>
<td>

<p>estimated covariance matrix for the estimated coefficients
</p>
</td></tr>
<tr><td><code>informationMatrix</code></td>
<td>

<p>estimated information matrix
</p>
</td></tr>
<tr><td><code>bhlink</code></td>
<td>

<p>the linkk of baseline hazard:
if <code>"identity"</code> baseline = sum g0_i b_i(t);
if <code>"log"</code> log(baseline) = sum g0_i b_i(t); 
</p>
</td></tr>
<tr><td><code>init</code></td>
<td>

<p>vector of the starting values supplied
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>logical, Was the optimlizer algorithm judged to have converged? 
</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>

<p>the linear fit on link scale (not including the baseline hazard term if <code>bhlink = "identity"</code>)
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>the estimated value of the hazard rate at each event time, obtained by transforming the linear predictors by the inverse of the link function
</p>
</td></tr>
<tr><td><code>cumulative.hazard</code></td>
<td>

<p>the estimated value of the cumulative hazard in the time interval
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>the formula supplied
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>the <code>data</code> argument
</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>

<p>the rate vector used
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>the time vector used
</p>
</td></tr>
<tr><td><code>workingformula</code></td>
<td>

<p>the formula used by the fitter
</p>
</td></tr>
<tr><td><code>optim.control</code></td>
<td>

<p>the value of the <code>optim.control</code> argument supplied
</p>
</td></tr>
<tr><td><code>control.glm</code></td>
<td>

<p>the value of the <code>control.glm</code> argument supplied
</p>
</td></tr>   
<tr><td><code>method</code></td>
<td>

<p>the name of the fitter function used
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mahboubi, A., M. Abrahamowicz, et al. (2011). &quot;Flexible modeling of the effects of continuous prognostic factors in relative survival.&quot; Stat Med 30(12): 1351-1365. <a href="https://doi.org/10.1002/sim.4208">doi:10.1002/sim.4208</a>
</p>
<p>Remontet, L., N. Bossard, et al. (2007). &quot;An overall strategy based on regression models to estimate relative survival and model the effects of prognostic factors in cancer survival studies.&quot; Stat Med 26(10): 2214-2228. <a href="https://doi.org/10.1002/sim.2656">doi:10.1002/sim.2656</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.flexrsurv">print.flexrsurv</a></code>, 
<code><a href="#topic+summary.flexrsurv">summary.flexrsurv</a></code>, 
<code><a href="#topic+logLik.flexrsurv">logLik.flexrsurv</a></code>, 
<code><a href="#topic+predict.flexrsurv">predict.flexrsurv</a></code>, 

<code><a href="#topic+NPH">NPH</a></code>, 
<code><a href="#topic+NLL">NLL</a></code>, and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("relsurv", quietly = TRUE) &amp; requireNamespace("date", quietly = TRUE)) {

	library(date)
	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	# get the death rate at event (or end of followup) from slopop for rdata
	rdata$iage &lt;- findInterval(rdata$age*365.24+rdata$time, attr(slopop, "cutpoints")[[1]])
	rdata$iyear &lt;- findInterval(rdata$year+rdata$time, attr(slopop, "cutpoints")[[2]])
	therate &lt;- rep(-1, dim(rdata)[1])
	for( i in 1:dim(rdata)[1]){
	  therate[i] &lt;- slopop[rdata$iage[i], rdata$iyear[i], rdata$sex[i]]
	}
	
	rdata$slorate &lt;- therate
	
	# get the logit_start and logit_end
	# logit start at age 18
	
	
	tmpsurv &lt;- Surv(rep(0, length(rdata$time)), rdata$time, rdata$cens)
	
	
	HH &lt;- getHazardFromTable(tmpsurv, startdate=rdata$year,
	       startage=rdata$age*365.25 , matchdata=rdata, ratetable=slopop,
	       age="age", year="year",
	       rmap=list(sex=sex),
	       agemin=18,
	       ratename = "poprate", cumrateendname ="cumrateend", cumrateentername ="cumrateenter"
	      ) 
	
	rdata$slorate &lt;- HH$poprate
	rdata$logit_start &lt;- log(exp(HH$cumrateenter)-1)
	rdata$logit_end &lt;- log(exp(HH$cumrateend)-1)
	
	rdata$Id &lt;- 1:dim(rdata)[1]
	
	
	
	
	# change sex coding
	rdata$sex01 &lt;- rdata$sex -1
	
	# fit a relative survival model with a non linear effect of age 
	#   without correction of life table
	#   partial likelihood
	fit00 &lt;- flexrsurvclt(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                      rate=slorate, 
			      data=rdata,
			      knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	summary(fit00)
	
	# fit a relative survival model with a non linear effect of age 
	#   without correction of life table
	#   full likelihood
	fit0 &lt;- flexrsurvclt(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                                           rate=slorate, 
					           logit_start=logit_start,
	                    logit_end=logit_end,
				data=rdata,
				Id=Id,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	summary(fit0)
	
	# fit a relative survival model with a non linear effect of age
	#   with correction of life table
	#   full likelihood
	fit1 &lt;- flexrsurvclt(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                 rate=slorate, 
					                     logit_start=logit_start,
	                    logit_end=logit_end,
				data=rdata,
				Id=Id,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	             Spline.CLT=flexrsurv:::R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3),
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	summary(fit1)
	
	print(coef(fit1))
	
	# fit a relative survival model with a non linear effect of age
	#   with correction of life table, strabified by sex
	#   full likelihood
	fit2 &lt;- flexrsurvclt(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
		    formula.table= ~sex,
	                 rate=slorate, 
					                     logit_start=logit_start,
	                    logit_end=logit_end,
				data=rdata,
				Id=Id,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	             Spline.CLT=flexrsurv:::R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3),
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	summary(fit2)
	
	AIC(fit0, fit1, fit2)
}

</code></pre>

<hr>
<h2 id='getBrassHazardFromTable'>Compute expected hazards with respect to a corrected reference life table
</h2><span id='topic+getBrassHazardFromTable'></span><span id='topic+getBrassPseudoHazardFromTable'></span>

<h3>Description</h3>

<p>returns the cumulative hazard and the hazard rate of subjects in a reference life table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBrassPseudoHazardFromTable(Y, startdate, startage, matchdata = NULL, 
        ratetable = survival::survexp.us, 
		age = 1, year = 2, rmap, 
		agemin = 16, scale = 365.25, 
		ratename = "rateend", 
		cumrateendname = "cumrateend", 
		cumrateentername = "cumrateenter", 
		idname = "Id_byperiod",
		origin = "01/01/1970", format="%d/%m/%Y",
		left.open = FALSE, 
		SplineBrass=R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3)*c(1, 0, 1),
		verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBrassHazardFromTable_+3A_y">Y</code></td>
<td>

<p>An object with interval data. It can be an object of class <code><a href="survival.html#topic+Surv">Surv</a></code> with arguments <code>time</code>, <code>time2</code> and <code>event</code> 
or a two-column matrix with starting time in the first column and ending time in the second column.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_startdate">startdate</code></td>
<td>

<p>a numeric vector such that <code>as.Date(startadate)</code> is interpreted as the date of the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_startage">startage</code></td>
<td>

<p>a numeric vector of age in days the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_matchdata">matchdata</code></td>
<td>

<p>an optional data.frame in which to interpret the additional variables to be mapped to the <code>ratetable</code> variables.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_ratetable">ratetable</code></td>
<td>

<p>an object of class <code><a href="survival.html#topic+ratetable">ratetable</a></code>, ie a table of event rates.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_age">age</code>, <code id="getBrassHazardFromTable_+3A_year">year</code></td>
<td>

<p>character values of the names of the age and period variables in the rate table.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_rmap">rmap</code></td>
<td>

<p>an optional list that maps data set names to the ratetable names. See <code><a href="survival.html#topic+survexp">survexp</a></code> an example bellow.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_agemin">agemin</code></td>
<td>

<p>numeric value of the age at which the cumulative hazard starts.
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_scale">scale</code></td>
<td>

<p>numeric value to scale <code>agemin</code>. 
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_ratename">ratename</code>, <code id="getBrassHazardFromTable_+3A_cumrateendname">cumrateendname</code>, <code id="getBrassHazardFromTable_+3A_cumrateentername">cumrateentername</code>, <code id="getBrassHazardFromTable_+3A_idname">idname</code></td>
<td>

<p>names of the returned variables
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_origin">origin</code>, <code id="getBrassHazardFromTable_+3A_format">format</code></td>
<td>

<p>passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_left.open">left.open</code></td>
<td>

<p>logical, passed to <code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_splinebrass">SplineBrass</code></td>
<td>

<p>Spline basis used to transform the rates
</p>
</td></tr>
<tr><td><code id="getBrassHazardFromTable_+3A_verbose">verbose</code></td>
<td>

<p>logical, if <code>true</code> the progression of the computation is output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative rates are computed using <code><a href="survival.html#topic+survexp">survexp</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 3 columns with the rate at the ending time, the cumulative rate from agemin up to the starting time and upt to the ending time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getHazardFromTable">getHazardFromTable</a></code> for the cumulative hazard and the hazard rate of subjects in a reference life table. 
<code><a href="survival.html#topic+survexp">survexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("relsurv", quietly = TRUE) &amp; requireNamespace("date", quietly = TRUE)) {

	library(date)
	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	tmpsurv &lt;- Surv(rep(0, length(rdata$time)), rdata$time, rdata$cens)
	
	HH &lt;- getPseudoHazardFromTable(tmpsurv, startdate=rdata$year,
	               startage=rdata$age*365.24 , matchdata=rdata, ratetable=slopop,
	               age="age", year="year",
	               rmap=list(sex=sex),
	               agemin=18, scale=365.24,
	               ratename = "poprate", 
	               cumrateendname ="cumrateend", 
	               cumrateentername ="cumrateenter", 
	               idname="Id_byperiod"
	               ) 
	summary(HH)
}	
					
</code></pre>

<hr>
<h2 id='getHazardFromTable'> computes expected hazards with respect to a reference life table
</h2><span id='topic+getHazardFromTable'></span>

<h3>Description</h3>

<p>returns the cumulative hazard and the hazard rate of subjects in a reference life table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHazardFromTable(Y, startdate, startage, matchdata = NULL, 
        ratetable = survival::survexp.us, 
		age = 1, year = 2, rmap, agemin = 16, scale = 365.25, 
		ratename = "rateend", 
		cumrateendname = "cumrateend", 
		cumrateentername = "cumrateenter", 
		origin = "01/01/1970", format = "%d/%m/%Y",
		left.open = FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHazardFromTable_+3A_y">Y</code></td>
<td>

<p>An object with interval data. It can be an object of class <code><a href="survival.html#topic+Surv">Surv</a></code> with arguments <code>time</code>, <code>time2</code> and <code>event</code> 
or a two-column matrix with starting time in the first column and ending time in the second column.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_startdate">startdate</code></td>
<td>

<p>a numeric vector such that <code>as.Date(startadate)</code> is interpreted as the date of the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_startage">startage</code></td>
<td>

<p>a numeric vector of age in days the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_matchdata">matchdata</code></td>
<td>

<p>an optional data.frame in which to interpret the additional variables to be mapped to the <code>ratetable</code> variables.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_ratetable">ratetable</code></td>
<td>

<p>an object of class <code><a href="survival.html#topic+ratetable">ratetable</a></code>, ie a table of event rates.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_age">age</code>, <code id="getHazardFromTable_+3A_year">year</code></td>
<td>

<p>character values of the names of the age and period variables in the rate table.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_rmap">rmap</code></td>
<td>

<p>an optional list that maps data set names to the ratetable names. See <code><a href="survival.html#topic+survexp">survexp</a></code> an example bellow.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_agemin">agemin</code></td>
<td>

<p>numeric value of the age at which the cumulative hazard starts.
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_scale">scale</code></td>
<td>

<p>numeric value to scale <code>agemin</code>. 
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_ratename">ratename</code>, <code id="getHazardFromTable_+3A_cumrateendname">cumrateendname</code>, <code id="getHazardFromTable_+3A_cumrateentername">cumrateentername</code></td>
<td>

<p>names of the returned variables
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_origin">origin</code>, <code id="getHazardFromTable_+3A_format">format</code></td>
<td>

<p>arguments passed <code><a href="base.html#topic+as.Date">as.Date</a></code>
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_left.open">left.open</code></td>
<td>

<p>logical, passed to <code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>
</td></tr>
<tr><td><code id="getHazardFromTable_+3A_verbose">verbose</code></td>
<td>

<p>logical, if <code>true</code> the progression of the computation is output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative rates are computed using <code><a href="survival.html#topic+survexp">survexp</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 3 columns with the rate at the ending time, the cumulative rate from agemin up to the starting time and upt to the ending time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPseudoHazardFromTable">getPseudoHazardFromTable</a></code> for the cumulative hazard in each period of a reference life table. 
<code><a href="#topic+getBrassHazardFromTable">getBrassHazardFromTable</a></code> for the cumulative hazard in a corrected reference life table. 
<code><a href="survival.html#topic+survexp">survexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("relsurv", quietly = TRUE) &amp; requireNamespace("date", quietly = TRUE)) {

	library(date)
	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	tmpsurv &lt;- Surv(rep(0, length(rdata$time)), rdata$time, rdata$cens)
	
	HH &lt;- getHazardFromTable(tmpsurv, startdate=rdata$year,
	               startage=rdata$age*365.24 , matchdata=rdata, ratetable=slopop,
	               age="age", year="year",
	               rmap=list(sex=sex),
	               agemin=18, scale=365.24,
	               ratename = "poprate", 
	               cumrateendname ="cumrateend", 
	               cumrateentername ="cumrateenter"
	               ) 
	summary(HH)
}
						
</code></pre>

<hr>
<h2 id='getPseudoHazardFromTable'>Computes expected hazards with respect to a reference life table
</h2><span id='topic+getPseudoHazardFromTable'></span>

<h3>Description</h3>

<p>return the cumulative pseudo hazard and the hazard rate of subjects in a reference life table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPseudoHazardFromTable(Y, startdate, startage, matchdata = NULL, 
        ratetable = survival::survexp.us, 
		age = 1, year = 2, rmap, 
		agemin = 16, scale = 365.25, 
		ratename = "rateend", 
		cumrateendname = "cumrateend", 
		cumrateentername = "cumrateenter", 
		idname = "Id_byperiod",
		origin = "01/01/1970", format="%d/%m/%Y",
		left.open = FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPseudoHazardFromTable_+3A_y">Y</code></td>
<td>

<p>An object with interval data. It can be an object of class <code><a href="survival.html#topic+Surv">Surv</a></code> with arguments <code>time</code>, <code>time2</code> and <code>event</code> 
or a two-column matrix with starting time in the first column and ending time in the second column.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_startdate">startdate</code></td>
<td>

<p>a numeric vector such that <code>as.Date(startadate)</code> is interpreted as the date of the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_startage">startage</code></td>
<td>

<p>a numeric vector of age in days the start (when Y[,]==0).
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_matchdata">matchdata</code></td>
<td>

<p>an optional data.frame in which to interpret the additional variables to be mapped to the <code>ratetable</code> variables.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_ratetable">ratetable</code></td>
<td>

<p>an object of class <code><a href="survival.html#topic+ratetable">ratetable</a></code>, ie a table of event rates.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_age">age</code>, <code id="getPseudoHazardFromTable_+3A_year">year</code></td>
<td>

<p>character values of the names of the age and period variables in the rate table.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_rmap">rmap</code></td>
<td>

<p>an optional list that maps data set names to the ratetable names. See <code><a href="survival.html#topic+survexp">survexp</a></code> an example bellow.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_agemin">agemin</code></td>
<td>

<p>numeric value of the age at which the cumulative hazard starts.
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_scale">scale</code></td>
<td>

<p>numeric value to scale <code>agemin</code>. 
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_ratename">ratename</code>, <code id="getPseudoHazardFromTable_+3A_cumrateendname">cumrateendname</code>, <code id="getPseudoHazardFromTable_+3A_cumrateentername">cumrateentername</code>, <code id="getPseudoHazardFromTable_+3A_idname">idname</code></td>
<td>

<p>names of the returned variables
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_origin">origin</code>, <code id="getPseudoHazardFromTable_+3A_format">format</code></td>
<td>

<p>passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_left.open">left.open</code></td>
<td>

<p>logical, passed to <code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>
</td></tr>
<tr><td><code id="getPseudoHazardFromTable_+3A_verbose">verbose</code></td>
<td>

<p>logical, if <code>true</code> the progression of the computation is output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative rates are computed using <code><a href="survival.html#topic+survexp">survexp</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 3 columns with the rate at the ending time, the cumulative rate from agemin up to the starting time and upt to the ending time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getHazardFromTable">getHazardFromTable</a></code> for the cumulative hazard and the hazard rate of subjects in a reference life table. 
<code><a href="survival.html#topic+survexp">survexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("relsurv", quietly = TRUE) &amp; requireNamespace("date", quietly = TRUE)) {

	library(date)
	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	tmpsurv &lt;- Surv(rep(0, length(rdata$time)), rdata$time, rdata$cens)
	
	HH &lt;- getPseudoHazardFromTable(tmpsurv, startdate=rdata$year,
	               startage=rdata$age*365.24 , matchdata=rdata, ratetable=slopop,
	               age="age", year="year",
	               rmap=list(sex=sex),
	               agemin=18, scale=365.24,
	               ratename = "poprate", 
	               cumrateendname ="cumrateend", 
	               cumrateentername ="cumrateenter", 
	               idname="Id_byperiod"
	               ) 
	summary(HH)
}
						
</code></pre>

<hr>
<h2 id='logLik.flexrsurv'>Log-Likelihood and the number of observations for a <code>flexrsuv</code> fit.</h2><span id='topic+logLik.flexrsurv'></span><span id='topic+nobs.flexrsurv'></span>

<h3>Description</h3>

<p>Function to extract Log-Likelihood and the number of observations from a <code>flexrsuv</code> or <code>flexrsuvclt</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexrsurv'
logLik(object, ...)

## S3 method for class 'flexrsurv'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.flexrsurv_+3A_object">object</code></td>
<td>
<p>any object of class <code>flexrsuv</code> results of a <code><a href="#topic+flexrsurv">flexrsurv</a></code> fit.</p>
</td></tr>
<tr><td><code id="logLik.flexrsurv_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logLik</code> returns a standard <code>logLik</code> object (see <code><a href="stats.html#topic+logLik">logLik</a></code>)
</p>
<p><code>nobs</code> returns a single number, normally an integer. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+nobs">nobs</a></code>.
</p>

<hr>
<h2 id='NLL'>Non Log-Linear effect</h2><span id='topic+NLL'></span>

<h3>Description</h3>

<p>Generate the spline basis matrix for non log-linear effect. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NLL(x, 
    Spline = c("b-spline", "tp-spline", "tpi-spline"), 
    Knots = NULL, 
    Degree = 3, 
    Intercept = FALSE,
    Boundary.knots = range(x), 
    Keep.duplicates = TRUE, 
    outer.ok = TRUE, 
    ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NLL_+3A_x">x</code></td>
<td>

<p>the predictor variable.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_spline">Spline</code></td>
<td>

<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, 
&quot;tp-spline&quot; for truncated power basis and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_knots">Knots</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NLL effect. By default there 
are none.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_degree">Degree</code></td>
<td>

<p>degree of splines which are considered.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_intercept">Intercept</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_boundary.knots">Boundary.knots</code></td>
<td>

<p>range of variable which is analysed.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_keep.duplicates">Keep.duplicates</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes
duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_outer.ok">outer.ok</code></td>
<td>

<p>logical indicating how are managed <code>x</code> values outside the knots. If <code>FALSE</code>,
return <code>NA</code>, if <code>TRUE</code>, return <code>0</code> for the corresponding <code>x</code> values.
</p>
</td></tr>
<tr><td><code id="NLL_+3A_...">...</code></td>
<td>

<p>not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NLL</code> is based on package <code><a href="orthogonalsplinebasis.html#topic+SplineBasis">orthogonalsplinebasis</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPH">NPH</a></code> and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>

<hr>
<h2 id='NLLbeta'>Non Log-Linear effect and non proportional effect</h2><span id='topic+NLLbeta'></span><span id='topic+NPHalpha'></span>

<h3>Description</h3>

<p>Internal functions not intended for users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
NLLbeta(y, x, 
    Spline = c("b-spline", "tp-spline", "tpi-spline"), 
    Knots = NULL, 
    Degree = 3, 
    Intercept = FALSE, 
    Boundary.knots = range(x), 
    Keep.duplicates = TRUE, 
    outer.ok = TRUE, 
    ...)

NPHalpha(x, 
    timevar, 
    Spline = c("b-spline", "tp-spline", "tpi-spline"),
    Knots.t = NULL, 
    Degree.t = 3, 
    Intercept.t = TRUE, 
    Boundary.knots.t = c(0, max(timevar)), 
    Keep.duplicates.t = TRUE, 
    outer.ok = TRUE, 
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NLLbeta_+3A_x">x</code></td>
<td>

<p>the predictor variable.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_timevar">timevar</code></td>
<td>

<p>the time variable.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_y">y</code></td>
<td>

<p>the name of variable for which tests NLL effect.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_spline">Spline</code></td>
<td>

<p>type of spline basis. &quot;b-spline&quot; for B-spline basis, &quot;tp-spline&quot; for truncated power basis 
and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_knots">Knots</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NLL effect. By default there 
are none.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_degree">Degree</code></td>
<td>

<p>degree of splines which are considered.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_intercept">Intercept</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_boundary.knots">Boundary.knots</code></td>
<td>

<p>range of variable which is analysed.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_keep.duplicates">Keep.duplicates</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes
duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_knots.t">Knots.t</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NPH effect. By default 
there are none.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_degree.t">Degree.t</code></td>
<td>

<p>degree of splines which are considered.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_intercept.t">Intercept.t</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_boundary.knots.t">Boundary.knots.t</code></td>
<td>

<p>range of time period which is analysed. By default it is <code>c(0, max(timevar))</code>.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_keep.duplicates.t">Keep.duplicates.t</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_outer.ok">outer.ok</code></td>
<td>

<p>logical indicating how are managed <code>timevar</code> or <code>x</code> values outside the knots. If <code>FALSE</code>,
return <code>NA</code>, if <code>TRUE</code>, return <code>0</code> for the corresponding <code>timevar</code> or <code>x</code> values.
</p>
</td></tr>
<tr><td><code id="NLLbeta_+3A_...">...</code></td>
<td>

<p>not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal functions.
</p>


<h3>Value</h3>

<p><code>NLLbeta(x, y, ...)</code> returns <code>y * NLL(x, ...)</code>. 
</p>
<p><code>NPH(x, timevar, ...)</code> is equal to <code>x * NPHalpha(x, timevar, ...)</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPH">NPH</a></code>, 
<code><a href="#topic+NLL">NLL</a></code>, and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>

<hr>
<h2 id='NPH'>Non Proportional Hazard effect</h2><span id='topic+NPH'></span>

<h3>Description</h3>

<p>Generate the design matrix of spline basis for non proportional effect. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPH(x, 
    timevar, 
    Spline = c("b-spline", "tp-spline", "tpi-spline"),
    Knots.t = NULL, 
    Degree.t = 3, 
    Intercept.t = TRUE, 
    Boundary.knots.t = c(0, max(timevar)), 
    Keep.duplicates.t = TRUE, 
    outer.ok = TRUE, 
    ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPH_+3A_x">x</code></td>
<td>

<p>the predictor variable.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_timevar">timevar</code></td>
<td>

<p>the time variable.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_spline">Spline</code></td>
<td>

<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, &quot;tp-spline&quot; for truncated power basis and 
&quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_knots.t">Knots.t</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NPH effect. By default 
there are none.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_degree.t">Degree.t</code></td>
<td>

<p>degree of splines which are considered.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_intercept.t">Intercept.t</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_boundary.knots.t">Boundary.knots.t</code></td>
<td>

<p>range of time period which is analysed. By default it is <code>c(0, max(timevar))</code>.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_keep.duplicates.t">Keep.duplicates.t</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_outer.ok">outer.ok</code></td>
<td>

<p>logical indicating how are managed <code>timevar</code> values outside the knots. If <code>FALSE</code>, return <code>NA</code>, if <code>TRUE</code>, return <code>0</code> for the corresponding <code>timevar</code> values.
</p>
</td></tr>
<tr><td><code id="NPH_+3A_...">...</code></td>
<td>

<p>not used
</p>
</td></tr></table>


<h3>Details</h3>

<p><code>NPH</code> is based on package <code><a href="orthogonalsplinebasis.html#topic+SplineBasis">orthogonalsplinebasis</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NLL">NLL</a></code>, and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>

<hr>
<h2 id='NPHNLL'>Non Proportional Hazard and Non Log-Linear effect</h2><span id='topic+NPHNLL'></span>

<h3>Description</h3>

<p>Generate the design matrix of spline basis for both non log-linear and non proportional effect. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPHNLL(x, 
       timevar, 
       model = c("additive", "multiplicative"), 
       Spline = c("b-spline", "tp-spline", "tpi-spline"), 
       Knots = NULL, 
       Degree = 3, 
       Intercept = FALSE, 
       Boundary.knots = range(x), 
       Knots.t = NULL, 
       Degree.t = 3,
       Intercept.t = (model == "multiplicative"), 
       Boundary.knots.t = c(0, max(timevar)), 
       outer.ok = TRUE, 
       Keep.duplicates = TRUE, 
       xdimnames = ":XxXxXXxXxX ", 
       tdimnames = ":TtTtTTtTtT ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPHNLL_+3A_x">x</code></td>
<td>

<p>the predictor variable.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_timevar">timevar</code></td>
<td>

<p>the time variable.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_model">model</code></td>
<td>

<p>character string specifying the type of model for both non-proportionnal and non linear effects.    
The model <code>method=="additive"</code> assumes effects as explained in Remontet et al.(2007), the model <code>method=="multiplicative"</code> assumes effects as explained in Mahboubi et al. (2011).
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_spline">Spline</code></td>
<td>

<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, 
&quot;tp-spline&quot; for truncated power basis and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_knots">Knots</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NLL part of effect. By default 
there are none.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_degree">Degree</code></td>
<td>

<p>degree of splines of variable which are considered.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_intercept">Intercept</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_boundary.knots">Boundary.knots</code></td>
<td>

<p>range of variable which is analysed.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_knots.t">Knots.t</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the NPH part of effect. By default 
there are none.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_degree.t">Degree.t</code></td>
<td>

<p>degree of splines of time variable which are considered.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_intercept.t">Intercept.t</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_boundary.knots.t">Boundary.knots.t</code></td>
<td>

<p>range of time period which is analysed.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_keep.duplicates">Keep.duplicates</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes
duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_outer.ok">outer.ok</code></td>
<td>

<p>logical indicating how are managed <code>timevar</code> or <code>x</code> values outside the knots. If <code>FALSE</code>,
return <code>NA</code>, if <code>TRUE</code>, return <code>0</code> for the corresponding <code>timevar</code> or <code>x</code> values.
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_xdimnames">xdimnames</code></td>
<td>

<p>string to build dimnames of <code>x</code> bases
</p>
</td></tr>
<tr><td><code id="NPHNLL_+3A_tdimnames">tdimnames</code></td>
<td>

<p>string to build dimnames of <code>timevar</code> bases
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NPHNLL</code> is based on package <code><a href="orthogonalsplinebasis.html#topic+SplineBasis">orthogonalsplinebasis</a></code>
</p>


<h3>References</h3>

<p>Mahboubi, A., M. Abrahamowicz, et al. (2011). &quot;Flexible modeling of the effects of continuous prognostic factors in relative survival.&quot; Stat Med 30(12): 1351-1365. <a href="https://doi.org/10.1002/sim.4208">doi:10.1002/sim.4208</a>
</p>
<p>Remontet, L., N. Bossard, et al. (2007). &quot;An overall strategy based on regression models to estimate relative survival and model the effects of prognostic factors in cancer survival studies.&quot; Stat Med 26(10): 2214-2228. <a href="https://doi.org/10.1002/sim.2656">doi:10.1002/sim.2656</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPH">NPH</a></code> and 
<code><a href="#topic+NLL">NLL</a></code>.
</p>

<hr>
<h2 id='predict.flexrsurv'>Predictions for a relative survival model</h2><span id='topic+predict.flexrsurv'></span><span id='topic+predict.flexrsurvclt'></span>

<h3>Description</h3>

<p>Predict linear predictors, hazard and cumulative
hazard for a model fitted by <code>flexrsuv</code> </p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'flexrsurv'
predict(object, newdata= NULL,
   type = c("lp", "link", "risk", "hazard", "hazardrate",
             "rate", "loghazard", "log", "lograte",
             "cumulative.rate", "cumulative.hazard", "cumulative", "cum",
             "survival", "surv", "netsurv"),
   se.fit=FALSE,  		
   ci.fit = FALSE,
   level = .95,
   na.action=na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.flexrsurv_+3A_object">object</code></td>
<td>

<p>the results of a flexrsurv fit. 
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_newdata">newdata</code></td>
<td>

<p>Optional new data at which to do predictions.
If absent predictions are for the data frame used in the original fit. 
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_type">type</code></td>
<td>

<p>the type of predicted value. 
Choices are the linear predictor (<code>"lp"</code>, <code>"log"</code>,
<code>"loghazard"</code>, <code>"lograte"</code>), the hazard (<code>"rate"</code>, <code>"hazard"</code>, <code>"hazardrate"</code>, <code>"risk"</code>) or the cumulative
hazard (<code>"cum"</code>, <code>"cumulative.hazard"</code>, <code>"cumulative"</code>). 
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_se.fit">se.fit</code></td>
<td>

<p>if TRUE, pointwise standard errors are produced for the predictions
(not available for cumulative hazard).
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_ci.fit">ci.fit</code></td>
<td>

<p>if TRUE, confidence intervale are produced for the predictions.
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_level">level</code></td>
<td>

<p>Confidence level.
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in
<code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.flexrsurv_+3A_...">...</code></td>
<td>
<p>For future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For cumulative hazard, the cumulative hazard is computed from 0 until
the given end time. The cumulative hazard is computed using the same numerical
integration method as the one used to fit the model. 
</p>


<h3>Value</h3>

<p>a vector or a list containing the predictions (element <code>"fit"</code>) and their
standard errors (element <code>"se.fit"</code>) if the se.fit option is TRUE. 
</p>


<h3>Note</h3>

<p>To work correctly, arguments <code>Boundary.knots</code> and
<code>Boundary.knots.t</code> must be included in the call to <code>NPH()</code>, <code>NLL()</code> and
<code>NPHNLL()</code> in the formula of <code>flexrsurv</code> 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+flexrsurv">flexrsurv</a></code>, <code><a href="#topic+flexrsurvclt">flexrsurvclt</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (requireNamespace("relsurv", quietly = TRUE)) {

	# data from package relsurv
	data(rdata, package="relsurv")
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	
	# get the death rate at event (or end of followup) from slopop for rdata
	rdata$iage &lt;- findInterval(rdata$age*365.24+rdata$time, attr(slopop, "cutpoints")[[1]])
	rdata$iyear &lt;- findInterval(rdata$year+rdata$time, attr(slopop, "cutpoints")[[2]])
	therate &lt;- rep(-1, dim(rdata)[1])
	for( i in 1:dim(rdata)[1]){
	  therate[i] &lt;- slopop[rdata$iage[i], rdata$iyear[i], rdata$sex[i]]
	}
	
	rdata$slorate &lt;- therate
	
	# change sex coding
	rdata$sex01 &lt;- rdata$sex -1
	# centering age
	rdata$agec &lt;- rdata$age- 60
	
	# fit a relative survival model with a non linear effect of age
	fit &lt;- flexrsurv(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                 rate=slorate, data=rdata,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Spline = "b-spline", 
	                 initbyglm=TRUE, 
	                 int_meth= "BOOLE",
	                 step=50
	                 )
	summary(fit, correlation=TRUE)
	
	
	
	newrdata &lt;- rdata
	newrdata$age &lt;- rep(60, length(rdata$age))
	newrdata$sex &lt;- factor(newrdata$sex, labels=c("m", "f"))
	
	linpred &lt;- predict(fit, newdata=newrdata, type="lp", ci.fit=TRUE)
	predhazard &lt;- predict(fit, newdata=newrdata, type="hazard" , ci.fit=TRUE)
	predcumhazard &lt;- predict(fit, newdata=newrdata, type="cum", ci.fit=TRUE)
	
	require(ggplot2)
	tmp &lt;- cbind(newrdata, linpred)
	glp &lt;- ggplot(tmp, aes(time, colour=sex))
	glp + geom_ribbon(aes(ymin = lwr, ymax = upr, fill=sex)) +
	   geom_line(aes(y=fit)) +
	   scale_fill_manual(values = alpha(c("blue", "red"), .3))
	
	
	tmp &lt;- cbind(newrdata, predhazard)
	glp &lt;- ggplot(tmp, aes(time, colour=sex))
	glp + geom_ribbon(aes(ymin = lwr, ymax = upr, fill=sex)) +
	   geom_line(aes(y=fit))  +
	   scale_fill_manual(values = alpha(c("blue", "red"), .3))
	
	
	tmp &lt;- cbind(newrdata, predcumhazard)
	glp &lt;- ggplot(tmp, aes(time, colour=sex))
	glp + geom_ribbon(aes(ymin = lwr, ymax = upr, fill=sex)) +
	   geom_line(aes(y=fit)) +
	   scale_fill_manual(values = alpha(c("blue", "red"), .3))
}

</code></pre>

<hr>
<h2 id='predictCLT'>Predictions for relational life table model</h2><span id='topic+predictCLT'></span><span id='topic+predictCLT.default'></span><span id='topic+predictCLT.flexrsurvclt'></span>

<h3>Description</h3>

<p>Predict the relational model for a life table correction model fitted by <code>flexrsuvclt</code> or for specified knots, degree and coefficients </p>


<h3>Usage</h3>

<pre><code class='language-R'>  predictCLT (...)

  ## S3 method for class 'flexrsurvclt'
predictCLT(object, newdata= NULL,
   type = c("clt", "correction"),
   se.fit=FALSE, na.action=na.pass, newcoef = NULL, ...)
   
   ## Default S3 method:
predictCLT(knots, degree, newdata, newcoef, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCLT_+3A_object">object</code></td>
<td>

<p>the results of a flexrsurvclt fit. 
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_newdata">newdata</code></td>
<td>

<p>Optional new vector of logarithm of the cumulative distribution odds (LCDO) at which to do predictions.
If absent predictions are for values of the LCDO used in the original fit (<code>logit_end</code> parameter in the call to <code>flexrsuvclt</code>)). 
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_newcoef">newcoef</code></td>
<td>

<p>Optional new coefficients for which to do predictions.
If absent predictions are for the coefficients of the fitted model in <code>object</code>. 
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_type">type</code></td>
<td>

<p>the type of predicted value. 
Choices are <code>"clt"</code> or <code>"correction"</code> to compute the corrected logarithm of the cumulative distribution odds. 
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_se.fit">se.fit</code></td>
<td>

<p>if TRUE, pointwise standard errors are produced for the predictions
(not yet implemented).
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_knots">knots</code>, <code id="predictCLT_+3A_degree">degree</code></td>
<td>

<p>knots and degree of the relational model.
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in
<code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predictCLT_+3A_...">...</code></td>
<td>
<p>For future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predictCLT</code> with <code>knots</code> and <code>degree</code> arguments computes corrected values of  . 
</p>


<h3>Value</h3>

<p>a vector or a list containing the predicted relational model (element <code>"fit"</code>) and their
standard errors (element <code>"se.fit"</code>) if the se.fit option is TRUE. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.flexrsurvclt">predict.flexrsurvclt</a></code>, <code><a href="#topic+flexrsurv">flexrsurv</a></code>, <code><a href="#topic+flexrsurvclt">flexrsurvclt</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (requireNamespace("relsurv", quietly = TRUE) &amp; requireNamespace("date", quietly = TRUE)) {

	library(date)
	# data from package relsurv
	data(rdata, package="relsurv")
	
	class(rdata$year)&lt;-"integer"
	
	
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	# get the death rate at event (or end of followup) from slopop for rdata
	rdata$iage &lt;- findInterval(rdata$age*365.24+rdata$time, attr(slopop, "cutpoints")[[1]])
	rdata$iyear &lt;- findInterval(rdata$year+rdata$time, attr(slopop, "cutpoints")[[2]])
	therate &lt;- rep(-1, dim(rdata)[1])
	for( i in 1:dim(rdata)[1]){
	  therate[i] &lt;- slopop[rdata$iage[i], rdata$iyear[i], rdata$sex[i]]
	}
	
	rdata$slorate &lt;- therate
	
	# get the logit_start and logit_end
	# logit start at age 18
	
	
	tmpsurv &lt;- Surv(rep(0, length(rdata$time)), rdata$time, rdata$cens)
	
	
	HH &lt;- getHazardFromTable(tmpsurv, startdate=rdata$year,
	       startage=rdata$age*365.25 , matchdata=rdata, ratetable=slopop,
	       age="age", year="year",
	       rmap=list(sex=sex),
	       agemin=18,
	       ratename = "poprate", cumrateendname ="cumrateend", cumrateentername ="cumrateenter"
	      ) 
	
	rdata$slorate &lt;- HH$poprate
	rdata$logit_start &lt;- log(exp(HH$cumrateenter)-1)
	rdata$logit_end &lt;- log(exp(HH$cumrateend)-1)
	
	rdata$Id &lt;- 1:dim(rdata)[1]
	
	# change sex coding
	rdata$sex01 &lt;- rdata$sex -1
	
	# fit a relative survival model with a non linear effect of age
	#   with correction of life table
	#   full likelihood
	fit1 &lt;- flexrsurvclt(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3,
	                                           Boundary.knots = c(24, 95)), 
	                 rate=slorate, 
					                     logit_start=logit_start,
	                    logit_end=logit_end,
				data=rdata,
				Id=Id,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Max_T=5400,
	                 Spline = "b-spline",
	             Spline.CLT=flexrsurv:::R2bBSplineBasis(knots=c(-2.5,0,2.5), degree=3),
	                 initbyglm=TRUE,
	                 initbands=seq(0, 5400, 100), 
	                 int_meth= "BANDS",
	                 bands=seq(0, 5400, 50)
	                 )
	
	
	
	
	corrected_logit_end &lt;- predictCLT(fit1)
	
	
	
	try_logit_end &lt;- predictCLT(knots=c(-2.5,0,2.5), degree=3, newcoef = c(0.5, 2), 
		newdata = rdata$logit_end  )
	
	plot(rdata$logit_end, corrected_logit_end)
	points(rdata$logit_end, try_logit_end, col = 2)
	

}

</code></pre>

<hr>
<h2 id='predictSpline'>Generic method for prediction of spline function</h2><span id='topic+predictSpline'></span><span id='topic+predictSpline.default'></span><span id='topic+predictSpline.character'></span><span id='topic+predictSpline+2Ccharacter+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Predict a spline function by specifying its type, knots, degree and coefficients </p>


<h3>Usage</h3>

<pre><code class='language-R'>  predictSpline (object, x, ...)
   
   ## Default S3 method:
predictSpline(object=c("b-spline", "tp-spline"), 
		x, knots, degree, keep.duplicates = FALSE, coef=1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSpline_+3A_object">object</code></td>
<td>

<p>the type of spline to be predicted (&quot;b-spline&quot;, the default, or &quot;tp-spline&quot;) 
</p>
</td></tr>
<tr><td><code id="predictSpline_+3A_x">x</code></td>
<td>

<p>Vector of values at wich to predict the spline function. 
</p>
</td></tr>
<tr><td><code id="predictSpline_+3A_knots">knots</code>, <code id="predictSpline_+3A_degree">degree</code></td>
<td>

<p>knots and degree of the relational model.
</p>
</td></tr>
<tr><td><code id="predictSpline_+3A_keep.duplicates">keep.duplicates</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes
duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="predictSpline_+3A_coef">coef</code></td>
<td>

<p>vector of coefficient of the spline function. 
</p>
</td></tr>
<tr><td><code id="predictSpline_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predictSpline</code>  . 
</p>


<h3>Value</h3>

<p>A vector the evaluated spline function with same length as x. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.flexrsurvclt">predict.flexrsurvclt</a></code>, <code><a href="#topic+flexrsurv">flexrsurv</a></code>, <code><a href="#topic+flexrsurvclt">flexrsurvclt</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>

	
	predspline &lt;- predictSpline("b-spline", 
		x= seq(from=-3, to = 3, by=.1), 
		coef = .5 * 1:5, 
		knots=c(-3,0,3), degree=3)
	plot(seq(from=-3, to = 3, by=.1), predspline)


</code></pre>

<hr>
<h2 id='print.flexrsurv'> Print a Short Summary of a Relative Survival Model</h2><span id='topic+print.flexrsurv'></span>

<h3>Description</h3>

<p>Print number of observations, number of events, the formula, the
estimated coeficients and the log likelihood. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'flexrsurv'
print(x, 
      digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.flexrsurv_+3A_x">x</code></td>
<td>

<p>the result of a call to the <code>flexrsuv</code> function.
</p>
</td></tr>
<tr><td><code id="print.flexrsurv_+3A_digits">digits</code></td>
<td>

<p>the minimum number of significant digits to be printed in values, see <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
<tr><td><code id="print.flexrsurv_+3A_...">...</code></td>
<td>

<p>other options 
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The default method <code><a href="base.html#topic+print.default">print.default</a></code>, and help for the
function <code><a href="#topic+flexrsurv">flexrsurv</a></code>, <code><a href="#topic+flexrsurvclt">flexrsurvclt</a></code>.
</p>

<hr>
<h2 id='summary.flexrsurv'> Summarizing Flexible Relative Survival Model Fits</h2><span id='topic+summary.flexrsurv'></span><span id='topic+print.summary.flexrsurv'></span>

<h3>Description</h3>

<p><code>summary</code> methods for class <code>flexrsurv</code>.
Produces and prints summaries of the results of a fitted Relative Survival Model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexrsurv'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)

## S3 method for class 'summary.flexrsurv'
print(x, digits = max(3L, getOption("digits") - 3L), 
      symbolic.cor = x$symbolic.cor,
      signif.stars = getOption("show.signif.stars"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flexrsurv_+3A_object">object</code></td>
<td>

<p>an object of class &quot;flexrsurv&quot;, usually, a result of a call to <code><a href="#topic+flexrsurv">flexrsurv</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.flexrsurv_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.flexrsurv"</code>, usually, a result of a call to <code>summary.flexrsurv</code>.</p>
</td></tr>    
<tr><td><code id="summary.flexrsurv_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of
the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.flexrsurv_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in
a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.flexrsurv_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use when printing.
</p>
</td></tr>
<tr><td><code id="summary.flexrsurv_+3A_signif.stars">signif.stars</code></td>
<td>

<p>logical. If TRUE,'significance stars' are printed for each coefficient.
</p>
</td></tr>
<tr><td><code id="summary.flexrsurv_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.glm</code> tries to be smart about formatting the coefficients, standard errors, etc. 
and additionally gives &lsquo;significance stars&rsquo; if <code>signif.stars</code> is <code>TRUE</code>. 
</p>
<p>Correlations are printed to two decimal places (or symbolically): to see the actual correlations 
print <code>summary(object)$correlation</code> directly.
</p>
<p>The dispersion of a GLM is not used in the fitting process, but it is needed to find standard 
errors. If dispersion is not supplied or NULL, the dispersion is taken as 1 for the binomial and
Poisson families, and otherwise estimated by the residual Chisquared statistic (calculated from 
cases with non-zero weights) divided by the residual degrees of freedom.
</p>


<h3>Value</h3>

<p>The function summary.flexrsurv computes and returns a list of summary statistics of the fitted flexible relative survival model given in <code>object</code>.
The returned value is an object of class &quot;<code>summary.flexrsurv</code>&quot;, which a list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the &quot;<code>call</code>&quot; component from <code>object</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the &quot;<code>terms</code>&quot; component from <code>object</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the estimated covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>(only if <code>correlation</code> is true.) the estimated correlations of the estimated coefficients.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>(only if <code>correlation</code> is true.) the value of the argument symbolic.cor.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the &quot;<code>loglik</code>&quot; component from object.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the &quot;<code>df.residual</code>&quot; component from object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+flexrsurv">flexrsurv</a></code>, <code><a href="#topic+flexrsurvclt">flexrsurvclt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("relsurv", quietly = TRUE)) {
	
	# data from package relsurv
	data(rdata, package="relsurv")
	# rate table from package relsurv
	data(slopop, package="relsurv")
	
	# get the death rate at event (or end of followup) from slopop for rdata
	rdata$iage &lt;- findInterval(rdata$age*365.24+rdata$time, attr(slopop, "cutpoints")[[1]])
	rdata$iyear &lt;- findInterval(rdata$year+rdata$time, attr(slopop, "cutpoints")[[2]])
	therate &lt;- rep(-1, dim(rdata)[1])
	for( i in 1:dim(rdata)[1]){
	  therate[i] &lt;- slopop[rdata$iage[i], rdata$iyear[i], rdata$sex[i]]
	}
	
	rdata$slorate &lt;- therate
	
	
	# change sex coding
	rdata$sex01 &lt;- rdata$sex -1
	
	# fit a relative survival model with a non linear effetc of age
	
	fit &lt;- flexrsurv(Surv(time,cens)~sex01+NLL(age, Knots=60, Degree=3), 
	                 rate=slorate, data=rdata,
	                 knots.Bh=1850,  # one interior knot at 5 years
	                 degree.Bh=3,
	                 Spline = "b-spline",
	                 initbyglm=TRUE, 
	                 initbands=seq(from=0, to=5400, by=200),
	                 int_meth= "CAV_SIM",
	                 step=50
	                 )
	
	summary(fit)
}

</code></pre>

<hr>
<h2 id='WCEI'>Weighted cumulative exposure index</h2><span id='topic+WCEI'></span>

<h3>Description</h3>

<p>Generate the spline basis matrix for Weighted cumulative exposure index. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WCEI(x, 
    timevar, 
    fromT=0,
    Spline.WCEI=NULL, 
    Spline = c("m-spline", "b-spline", "tp-spline", "tpi-spline"), 
    Knots.t = NULL, 
    Degree.t = 3, 
    Intercept.t = TRUE,
    Boundary.knots.t = range(c(timevar, fromT)),
    Keep.duplicates.t = TRUE, 
    outer.ok = TRUE, 
    ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WCEI_+3A_x">x</code></td>
<td>

<p>the exposure variable.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_timevar">timevar</code></td>
<td>

<p>the time variable.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_fromt">fromT</code></td>
<td>

<p>Time at which starts exposure
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_spline.wcei">Spline.WCEI</code></td>
<td>

<p>a S4 object with method deriv(), evaluate() and predict().
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_spline">Spline</code></td>
<td>

<p>a character string specifying the type of spline basis. &quot;b-spline&quot; for B-spline basis, 
&quot;tp-spline&quot; for truncated power basis and &quot;tpi-spline&quot; for monotone (increasing) truncated power basis.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_knots.t">Knots.t</code></td>
<td>

<p>the internal breakpoints that define the spline used to estimate the WCEI effect. By default there 
are none.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_degree.t">Degree.t</code></td>
<td>

<p>degree of splines which are considered.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_intercept.t">Intercept.t</code></td>
<td>

<p>a logical value indicating whether intercept/first basis of spline should be considered.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_boundary.knots.t">Boundary.knots.t</code></td>
<td>

<p>range of variable which is analysed.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_keep.duplicates.t">Keep.duplicates.t</code></td>
<td>

<p>Should duplicate interior knots be kept or removed. Defaults is <code>FALSE</code>, which removes
duplicate knots with a warning if duplicate interior knots are found.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_outer.ok">outer.ok</code></td>
<td>

<p>logical indicating how are managed <code>x</code> values outside the knots. If <code>FALSE</code>,
return <code>NA</code>, if <code>TRUE</code>, return <code>0</code> for the corresponding <code>x</code> values.
</p>
</td></tr>
<tr><td><code id="WCEI_+3A_...">...</code></td>
<td>

<p>not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>WCEI</code> is based on package <code><a href="orthogonalsplinebasis.html#topic+SplineBasis">orthogonalsplinebasis</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NLL">NLL</a></code> <code><a href="#topic+NPH">NPH</a></code> and 
<code><a href="#topic+NPHNLL">NPHNLL</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
