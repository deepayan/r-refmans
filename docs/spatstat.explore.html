<!DOCTYPE html><html><head><title>Help for package spatstat.explore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.explore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.ssf'>
<p>Subset of spatially sampled function</p></a></li>
<li><a href='#adaptive.density'><p>Adaptive Estimate of Intensity of Point Pattern</p></a></li>
<li><a href='#allstats'><p>Calculate four standard summary functions of a point pattern.</p></a></li>
<li><a href='#alltypes'><p>Calculate Summary Statistic for All Types in a Multitype Point Pattern</p></a></li>
<li><a href='#as.data.frame.envelope'><p>Coerce Envelope to Data Frame</p></a></li>
<li><a href='#as.function.fv'>
<p>Convert Function Value Table to Function</p></a></li>
<li><a href='#as.function.rhohat'>
<p>Convert Function Table to Function</p></a></li>
<li><a href='#as.fv'><p>Convert Data To Class fv</p></a></li>
<li><a href='#as.owin.quadrattest'><p>Convert Data To Class owin</p></a></li>
<li><a href='#as.tess'><p>Convert Data To Tessellation</p></a></li>
<li><a href='#auc'>
<p>Area Under ROC Curve</p></a></li>
<li><a href='#berman.test'><p>Berman's Tests for Point Process Model</p></a></li>
<li><a href='#bind.fv'>
<p>Combine Function Value Tables</p></a></li>
<li><a href='#bits.envelope'>
<p>Global Envelopes for Balanced Independent Two-Stage Test</p></a></li>
<li><a href='#bits.test'>
<p>Balanced Independent Two-Stage Monte Carlo Test</p></a></li>
<li><a href='#blur'><p>Apply Gaussian Blur to a Pixel Image</p></a></li>
<li><a href='#boyce'>
<p>Boyce Index</p></a></li>
<li><a href='#bw.abram'>
<p>Abramson's Adaptive Bandwidths</p></a></li>
<li><a href='#bw.abram.ppp'>
<p>Abramson's Adaptive Bandwidths For Spatial Point Pattern</p></a></li>
<li><a href='#bw.CvL'>
<p>Cronie and van Lieshout's Criterion for Bandwidth Selection for Kernel Density</p></a></li>
<li><a href='#bw.CvL.adaptive'>
<p>Select Adaptive Bandwidth for Kernel Estimation</p>
Using Cronie-Van Lieshout Criterion</a></li>
<li><a href='#bw.CvLHeat'>
<p>Bandwidth Selection for Diffusion Smoother by Cronie-van Lieshout Rule</p></a></li>
<li><a href='#bw.diggle'>
<p>Cross Validated Bandwidth Selection for Kernel Density</p></a></li>
<li><a href='#bw.frac'>
<p>Bandwidth Selection Based on Window Geometry</p></a></li>
<li><a href='#bw.optim.object'><p>Class of Optimized Bandwidths</p></a></li>
<li><a href='#bw.pcf'>
<p>Cross Validated Bandwidth Selection for Pair Correlation Function</p></a></li>
<li><a href='#bw.ppl'>
<p>Likelihood Cross Validation Bandwidth Selection for Kernel Density</p></a></li>
<li><a href='#bw.pplHeat'>
<p>Bandwidth Selection for Diffusion Smoother by Likelihood Cross-Validation</p></a></li>
<li><a href='#bw.relrisk'>
<p>Cross Validated Bandwidth Selection for Relative Risk Estimation</p></a></li>
<li><a href='#bw.scott'>
<p>Scott's Rule for Bandwidth Selection for Kernel Density</p></a></li>
<li><a href='#bw.smoothppp'>
<p>Cross Validated Bandwidth Selection for Spatial Smoothing</p></a></li>
<li><a href='#bw.stoyan'>
<p>Stoyan's Rule of Thumb for Bandwidth Selection</p></a></li>
<li><a href='#CDF'>
<p>Cumulative Distribution Function From Kernel Density Estimate</p></a></li>
<li><a href='#cdf.test'><p>Spatial Distribution Test for Point Pattern or Point Process Model</p></a></li>
<li><a href='#circdensity'>
<p>Density Estimation for Circular Data</p></a></li>
<li><a href='#clarkevans'><p>Clark and Evans Aggregation Index</p></a></li>
<li><a href='#clarkevans.test'><p>Clark and Evans Test</p></a></li>
<li><a href='#clusterset'>
<p>Allard-Fraley Estimator of Cluster Feature</p></a></li>
<li><a href='#collapse.fv'>
<p>Collapse Several Function Tables into One</p></a></li>
<li><a href='#compatible.fasp'><p>Test Whether Function Arrays Are Compatible</p></a></li>
<li><a href='#compatible.fv'><p>Test Whether Function Objects Are Compatible</p></a></li>
<li><a href='#compileCDF'>
<p>Generic Calculation of Cumulative Distribution Function of Distances</p></a></li>
<li><a href='#compileK'>
<p>Generic Calculation of K Function and Pair Correlation Function</p></a></li>
<li><a href='#cov.im'>
<p>Covariance and Correlation between Images</p></a></li>
<li><a href='#dclf.progress'>
<p>Progress Plot of Test of Spatial Pattern</p></a></li>
<li><a href='#dclf.sigtrace'>
<p>Significance Trace of Cressie-Loosmore-Ford or Maximum Absolute</p>
Deviation Test</a></li>
<li><a href='#dclf.test'>
<p>Diggle-Cressie-Loosmore-Ford and Maximum Absolute Deviation Tests</p></a></li>
<li><a href='#density.ppp'><p>Kernel Smoothed Intensity of Point Pattern</p></a></li>
<li><a href='#density.psp'><p>Kernel Smoothing of Line Segment Pattern</p></a></li>
<li><a href='#density.splitppp'><p>Kernel Smoothed Intensity of Split Point Pattern</p></a></li>
<li><a href='#densityAdaptiveKernel'><p>Adaptive Kernel Estimate of Intensity of Point Pattern</p></a></li>
<li><a href='#densityAdaptiveKernel.splitppp'><p>Adaptive Kernel Estimate of Intensity for Split Point Pattern</p></a></li>
<li><a href='#densityfun.ppp'>
<p>Kernel Estimate of Intensity as a Spatial Function</p></a></li>
<li><a href='#densityHeat'>
<p>Diffusion Estimate of Point Pattern Intensity</p></a></li>
<li><a href='#densityHeat.ppp'>
<p>Diffusion Estimate of Point Pattern Intensity</p></a></li>
<li><a href='#densityVoronoi'><p>Intensity Estimate of Point Pattern Using Voronoi-Dirichlet Tessellation</p></a></li>
<li><a href='#deriv.fv'>
<p>Calculate Derivative of Function Values</p></a></li>
<li><a href='#dg.envelope'>
<p>Global Envelopes for Dao-Genton Test</p></a></li>
<li><a href='#dg.progress'>
<p>Progress Plot of Dao-Genton Test of Spatial Pattern</p></a></li>
<li><a href='#dg.sigtrace'>
<p>Significance Trace of Dao-Genton Test</p></a></li>
<li><a href='#dg.test'>
<p>Dao-Genton Adjusted Goodness-Of-Fit Test</p></a></li>
<li><a href='#dimhat'>
<p>Estimate Dimension of Central Subspace</p></a></li>
<li><a href='#distcdf'><p>Distribution Function of Interpoint Distance</p></a></li>
<li><a href='#dkernel'><p>Kernel distributions and random generation</p></a></li>
<li><a href='#domain.quadrattest'>
<p>Extract the Domain of any Spatial Object</p></a></li>
<li><a href='#edge.Ripley'>
<p>Ripley's Isotropic Edge Correction</p></a></li>
<li><a href='#edge.Trans'>
<p>Translation Edge Correction</p></a></li>
<li><a href='#Emark'>
<p>Diagnostics for random marking</p></a></li>
<li><a href='#envelope'><p>Simulation Envelopes of Summary Function</p></a></li>
<li><a href='#envelope.envelope'>
<p>Recompute Envelopes</p></a></li>
<li><a href='#envelope.pp3'><p>Simulation Envelopes of Summary Function for 3D Point Pattern</p></a></li>
<li><a href='#envelopeArray'>
<p>Array of Simulation Envelopes of Summary Function</p></a></li>
<li><a href='#eval.fasp'><p>Evaluate Expression Involving Function Arrays</p></a></li>
<li><a href='#eval.fv'><p>Evaluate Expression Involving Functions</p></a></li>
<li><a href='#Extract.fasp'><p>Extract Subset of Function Array</p></a></li>
<li><a href='#Extract.fv'><p>Extract or Replace Subset of Function Values</p></a></li>
<li><a href='#F3est'>
<p>Empty Space Function of a Three-Dimensional Point Pattern</p></a></li>
<li><a href='#fasp.object'><p>Function Arrays for Spatial Patterns</p></a></li>
<li><a href='#Fest'><p>Estimate the Empty Space Function or its Hazard Rate</p></a></li>
<li><a href='#Finhom'>
<p>Inhomogeneous Empty Space Function</p></a></li>
<li><a href='#FmultiInhom'>
<p>Inhomogeneous Marked F-Function</p></a></li>
<li><a href='#formula.fv'>
<p>Extract or Change the Plot Formula for a Function Value Table</p></a></li>
<li><a href='#fryplot'><p>Fry Plot of Point Pattern</p></a></li>
<li><a href='#fv'>
<p>Create a Function Value Table</p></a></li>
<li><a href='#fv.object'><p>Function Value Table</p></a></li>
<li><a href='#fvnames'>
<p>Abbreviations for Groups of Columns in Function Value Table</p></a></li>
<li><a href='#G3est'>
<p>Nearest Neighbour Distance Distribution Function</p>
of a Three-Dimensional Point Pattern</a></li>
<li><a href='#Gcross'>
<p>Multitype Nearest Neighbour Distance Function (i-to-j)</p></a></li>
<li><a href='#Gcross.inhom'>
<p>Inhomogeneous Multitype G Cross Function</p></a></li>
<li><a href='#Gdot'>
<p>Multitype Nearest Neighbour Distance Function (i-to-any)</p></a></li>
<li><a href='#Gdot.inhom'>
<p>Inhomogeneous Multitype G Dot Function</p></a></li>
<li><a href='#Gest'>
<p>Nearest Neighbour Distance Function G</p></a></li>
<li><a href='#Gfox'>
<p>Foxall's Distance Functions</p></a></li>
<li><a href='#Ginhom'>
<p>Inhomogeneous Nearest Neighbour Function</p></a></li>
<li><a href='#Gmulti'>
<p>Marked Nearest Neighbour Distance Function</p></a></li>
<li><a href='#GmultiInhom'>
<p>Inhomogeneous Marked G-Function</p></a></li>
<li><a href='#harmonise.fv'><p>Make Function Tables Compatible</p></a></li>
<li><a href='#Hest'><p>Spherical Contact Distribution Function</p></a></li>
<li><a href='#hopskel'><p>Hopkins-Skellam Test</p></a></li>
<li><a href='#hotbox'>
<p>Heat Kernel for a Two-Dimensional Rectangle</p></a></li>
<li><a href='#idw'><p>Inverse-distance weighted smoothing of observations at irregular points</p></a></li>
<li><a href='#Iest'><p>Estimate the I-function</p></a></li>
<li><a href='#increment.fv'>
<p>Increments of a Function</p></a></li>
<li><a href='#integral.fv'>
<p>Compute Integral of Function Object</p></a></li>
<li><a href='#Jcross'>
<p>Multitype J Function (i-to-j)</p></a></li>
<li><a href='#Jcross.inhom'>
<p>Inhomogeneous Multitype J function (i-to-j)</p></a></li>
<li><a href='#Jdot'>
<p>Multitype J Function (i-to-any)</p></a></li>
<li><a href='#Jdot.inhom'>
<p>Inhomogeneous Multitype J function (i-to-any)</p></a></li>
<li><a href='#Jest'><p>Estimate the J-function</p></a></li>
<li><a href='#Jinhom'>
<p>Inhomogeneous J-function</p></a></li>
<li><a href='#Jmulti'>
<p>Marked J Function</p></a></li>
<li><a href='#Jmulti.inhom'>
<p>Inhomogeneous Marked J-Function</p></a></li>
<li><a href='#K3est'>
<p>K-function of a Three-Dimensional Point Pattern</p></a></li>
<li><a href='#kaplan.meier'><p>Kaplan-Meier Estimator using Histogram Data</p></a></li>
<li><a href='#Kcross'>
<p>Multitype K Function (Cross-type)</p></a></li>
<li><a href='#Kcross.inhom'>
<p>Inhomogeneous Cross K Function</p></a></li>
<li><a href='#Kdot'>
<p>Multitype K Function (i-to-any)</p></a></li>
<li><a href='#Kdot.inhom'>
<p>Inhomogeneous Multitype K Dot Function</p></a></li>
<li><a href='#kernel.factor'><p>Scale factor for density kernel</p></a></li>
<li><a href='#kernel.moment'><p>Incomplete Moment of Smoothing Kernel</p></a></li>
<li><a href='#kernel.squint'><p>Integral of Squared Kernel</p></a></li>
<li><a href='#Kest'><p>K-function</p></a></li>
<li><a href='#Kest.fft'><p>K-function using FFT</p></a></li>
<li><a href='#Kinhom'><p>Inhomogeneous K-function</p></a></li>
<li><a href='#km.rs'><p>Kaplan-Meier and Reduced Sample Estimator using Histograms</p></a></li>
<li><a href='#Kmark'><p>Mark-Weighted K Function</p></a></li>
<li><a href='#Kmeasure'><p>Reduced Second Moment Measure</p></a></li>
<li><a href='#Kmulti'>
<p>Marked K-Function</p></a></li>
<li><a href='#Kmulti.inhom'>
<p>Inhomogeneous Marked K-Function</p></a></li>
<li><a href='#Kscaled'><p>Locally Scaled K-function</p></a></li>
<li><a href='#Ksector'><p>Sector K-function</p></a></li>
<li><a href='#laslett'>
<p>Laslett's Transform</p></a></li>
<li><a href='#Lcross'><p>Multitype L-function (cross-type)</p></a></li>
<li><a href='#Lcross.inhom'>
<p>Inhomogeneous Cross Type L Function</p></a></li>
<li><a href='#Ldot'><p>Multitype L-function (i-to-any)</p></a></li>
<li><a href='#Ldot.inhom'>
<p>Inhomogeneous Multitype L Dot Function</p></a></li>
<li><a href='#Lest'><p>L-function</p></a></li>
<li><a href='#Linhom'><p>Inhomogeneous L-function</p></a></li>
<li><a href='#localK'><p>Neighbourhood density function</p></a></li>
<li><a href='#localKcross'><p>Local Multitype K Function (Cross-Type)</p></a></li>
<li><a href='#localKcross.inhom'><p>Inhomogeneous Multitype K Function</p></a></li>
<li><a href='#localKdot'><p>Local Multitype K Function (Dot-Type)</p></a></li>
<li><a href='#localKinhom'><p>Inhomogeneous Neighbourhood Density Function</p></a></li>
<li><a href='#localpcf'><p>Local pair correlation function</p></a></li>
<li><a href='#lohboot'><p>Bootstrap Confidence Bands for Summary Function</p></a></li>
<li><a href='#markconnect'>
<p>Mark Connection Function</p></a></li>
<li><a href='#markcorr'>
<p>Mark Correlation Function</p></a></li>
<li><a href='#markcrosscorr'>
<p>Mark Cross-Correlation Function</p></a></li>
<li><a href='#markmarkscatter'>
<p>Mark-Mark Scatter Plot</p></a></li>
<li><a href='#marktable'><p>Tabulate Marks in Neighbourhood of Every Point in a Point Pattern</p></a></li>
<li><a href='#markvario'><p>Mark Variogram</p></a></li>
<li><a href='#Math.fasp'><p>S3 Group Generic Methods for Function Arrays</p></a></li>
<li><a href='#Math.fv'><p>S3 Group Generic Methods for Function Tables</p></a></li>
<li><a href='#methods.rho2hat'>
<p>Methods for Intensity Functions of Two Spatial Covariates</p></a></li>
<li><a href='#methods.rhohat'>
<p>Methods for Intensity Functions of Spatial Covariate</p></a></li>
<li><a href='#methods.ssf'><p>Methods for Spatially Sampled Functions</p></a></li>
<li><a href='#miplot'><p>Morisita Index Plot</p></a></li>
<li><a href='#nnclean'>
<p>Nearest Neighbour Clutter Removal</p></a></li>
<li><a href='#nncorr'><p>Nearest-Neighbour Correlation Indices of Marked Point Pattern</p></a></li>
<li><a href='#nndensity.ppp'>
<p>Estimate Intensity of Point Pattern Using Nearest Neighbour Distances</p></a></li>
<li><a href='#nnorient'>
<p>Nearest Neighbour Orientation Distribution</p></a></li>
<li><a href='#pairMean'>
<p>Mean of a Function of Interpoint Distance</p></a></li>
<li><a href='#pairorient'>
<p>Point Pair Orientation Distribution</p></a></li>
<li><a href='#pairs.im'>
<p>Scatterplot Matrix for Pixel Images</p></a></li>
<li><a href='#panel.contour'>
<p>Panel Plots using Colour Image or Contour Lines</p></a></li>
<li><a href='#pcf'><p>Pair Correlation Function</p></a></li>
<li><a href='#pcf.fasp'><p>Pair Correlation Function obtained from array of K functions</p></a></li>
<li><a href='#pcf.fv'><p>Pair Correlation Function obtained from K Function</p></a></li>
<li><a href='#pcf.ppp'><p>Pair Correlation Function of Point Pattern</p></a></li>
<li><a href='#pcf3est'>
<p>Pair Correlation Function of a Three-Dimensional Point Pattern</p></a></li>
<li><a href='#pcfcross'><p>Multitype pair correlation function (cross-type)</p></a></li>
<li><a href='#pcfcross.inhom'>
<p>Inhomogeneous Multitype Pair Correlation Function (Cross-Type)</p></a></li>
<li><a href='#pcfdot'><p>Multitype pair correlation function (i-to-any)</p></a></li>
<li><a href='#pcfdot.inhom'>
<p>Inhomogeneous Multitype Pair Correlation Function (Type-i-To-Any-Type)</p></a></li>
<li><a href='#pcfinhom'>
<p>Inhomogeneous Pair Correlation Function</p></a></li>
<li><a href='#pcfmulti'>
<p>Marked pair correlation function</p></a></li>
<li><a href='#plot.bermantest'><p>Plot Result of Berman Test</p></a></li>
<li><a href='#plot.cdftest'><p>Plot a Spatial Distribution Test</p></a></li>
<li><a href='#plot.envelope'><p>Plot a Simulation Envelope</p></a></li>
<li><a href='#plot.fasp'><p>Plot a Function Array</p></a></li>
<li><a href='#plot.fv'><p>Plot Function Values</p></a></li>
<li><a href='#plot.laslett'>
<p>Plot Laslett Transform</p></a></li>
<li><a href='#plot.quadrattest'>
<p>Display the result of a quadrat counting test.</p></a></li>
<li><a href='#plot.scan.test'>
<p>Plot Result of Scan Test</p></a></li>
<li><a href='#plot.ssf'>
<p>Plot a Spatially Sampled Function</p></a></li>
<li><a href='#plot.studpermutest'>
<p>Plot a Studentised Permutation Test</p></a></li>
<li><a href='#pool'>
<p>Pool Data</p></a></li>
<li><a href='#pool.anylist'>
<p>Pool Data from a List of Objects</p></a></li>
<li><a href='#pool.envelope'>
<p>Pool Data from Several Envelopes</p></a></li>
<li><a href='#pool.fasp'>
<p>Pool Data from Several Function Arrays</p></a></li>
<li><a href='#pool.fv'><p>Pool Several Functions</p></a></li>
<li><a href='#pool.quadrattest'>
<p>Pool Several Quadrat Tests</p></a></li>
<li><a href='#pool.rat'>
<p>Pool Data from Several Ratio Objects</p></a></li>
<li><a href='#PPversion'>
<p>Transform a Function into its P-P or Q-Q Version</p></a></li>
<li><a href='#quadrat.test'><p>Dispersion Test for Spatial Point Pattern Based on</p>
Quadrat Counts</a></li>
<li><a href='#quadrat.test.splitppp'><p>Dispersion Test of CSR for Split Point Pattern Based on</p>
Quadrat Counts</a></li>
<li><a href='#quantile.density'>
<p>Quantiles of a Density Estimate</p></a></li>
<li><a href='#radcumint'>
<p>Radial Cumulative Integral</p></a></li>
<li><a href='#rat'>
<p>Ratio object</p></a></li>
<li><a href='#rectcontact'>
<p>Contact Distribution Function using Rectangular Structuring Element</p></a></li>
<li><a href='#reduced.sample'><p>Reduced Sample Estimator using Histogram Data</p></a></li>
<li><a href='#reload.or.compute'>
<p>Compute Unless Previously Saved</p></a></li>
<li><a href='#relrisk'>
<p>Estimate of Spatially-Varying Relative Risk</p></a></li>
<li><a href='#relrisk.ppp'>
<p>Nonparametric Estimate of Spatially-Varying Relative Risk</p></a></li>
<li><a href='#rho2hat'>
<p>Smoothed Relative Density of Pairs of Covariate Values</p></a></li>
<li><a href='#rhohat'>
<p>Nonparametric Estimate of Intensity as Function of a Covariate</p></a></li>
<li><a href='#roc'>
<p>Receiver Operating Characteristic</p></a></li>
<li><a href='#rose'><p>Rose Diagram</p></a></li>
<li><a href='#rotmean'>
<p>Rotational Average of a Pixel Image</p></a></li>
<li><a href='#scan.test'>
<p>Spatial Scan Test</p></a></li>
<li><a href='#scanLRTS'>
<p>Likelihood Ratio Test Statistic for Scan Test</p></a></li>
<li><a href='#sdr'>
<p>Sufficient Dimension Reduction</p></a></li>
<li><a href='#sdrPredict'>
<p>Compute Predictors from Sufficient Dimension Reduction</p></a></li>
<li><a href='#segregation.test'>
<p>Test of Spatial Segregation of Types</p></a></li>
<li><a href='#sharpen'><p>Data Sharpening of Point Pattern</p></a></li>
<li><a href='#Smooth'><p>Spatial smoothing of data</p></a></li>
<li><a href='#Smooth.fv'>
<p>Apply Smoothing to Function Values</p></a></li>
<li><a href='#Smooth.ppp'><p>Spatial smoothing of observations at irregular points</p></a></li>
<li><a href='#Smooth.ssf'>
<p>Smooth a Spatially Sampled Function</p></a></li>
<li><a href='#Smoothfun.ppp'>
<p>Smooth Interpolation of Marks as a Spatial Function</p></a></li>
<li><a href='#spatcov'>
<p>Estimate the Spatial Covariance Function of a Random Field</p></a></li>
<li><a href='#spatialcdf'>
<p>Spatial Cumulative Distribution Function</p></a></li>
<li><a href='#SpatialMedian.ppp'>
<p>Spatially Weighted Median of Values at Points</p></a></li>
<li><a href='#SpatialQuantile'>
<p>Spatially Weighted Median or Quantile</p></a></li>
<li><a href='#SpatialQuantile.ppp'>
<p>Spatially Weighted Quantile of Values at Points</p></a></li>
<li><a href='#spatstat.explore-deprecated'><p>Deprecated spatstat.explore functions</p></a></li>
<li><a href='#spatstat.explore-internal'><p>Internal spatstat.explore functions</p></a></li>
<li><a href='#spatstat.explore-package'><p>The spatstat.explore Package</p></a></li>
<li><a href='#ssf'>
<p>Spatially Sampled Function</p></a></li>
<li><a href='#stieltjes'><p>Compute Integral of Function Against Cumulative Distribution</p></a></li>
<li><a href='#stienen'>
<p>Stienen Diagram</p></a></li>
<li><a href='#studpermu.test'>
<p>Studentised Permutation Test</p></a></li>
<li><a href='#subspaceDistance'>
<p>Distance Between Linear Spaces</p></a></li>
<li><a href='#thresholdCI'>
<p>Confidence Interval for Threshold of Numerical Predictor</p></a></li>
<li><a href='#thresholdSelect'>
<p>Select Threshold to Convert Numerical Predictor to Binary Predictor</p></a></li>
<li><a href='#transect.im'>
<p>Pixel Values Along a Transect</p></a></li>
<li><a href='#Tstat'>
<p>Third order summary statistic</p></a></li>
<li><a href='#varblock'>
<p>Estimate Variance of Summary Statistic by Subdivision</p></a></li>
<li><a href='#Window.quadrattest'><p>Extract Window of Spatial Object</p></a></li>
<li><a href='#with.fv'><p>Evaluate an Expression in a Function Table</p></a></li>
<li><a href='#with.ssf'>
<p>Evaluate Expression in a Spatially Sampled Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploratory Data Analysis for the 'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0-4), spatstat.geom (&ge;
3.2-9), spatstat.random (&ge; 3.2-3), stats, graphics, grDevices,
utils, methods, nlme</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-4), spatstat.sparse (&ge; 3.0-3), goftest
(&ge; 1.2-2), Matrix, abind</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sm, gsl, locfit, spatial, fftwtools (&ge; 0.9-8),
spatstat.linnet (&ge; 3.1-4), spatstat.model (&ge; 3.2-10),
spatstat (&ge; 3.0-7)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for exploratory data analysis and nonparametric analysis of
	     spatial data, mainly spatial point patterns,
	     in the 'spatstat' family of packages.
	     (Excludes analysis of spatial data on a linear network,
	     which is covered by the separate package 'spatstat.linnet'.)
	     Methods include quadrat counts, K-functions and their simulation envelopes, nearest neighbour distance and empty space statistics, Fry plots, pair correlation function, kernel smoothed intensity, relative risk estimation with cross-validated bandwidth selection, mark correlation functions, segregation indices, mark dependence diagnostics, and kernel estimates of covariate effects. Formal hypothesis tests of random pattern (chi-squared, Kolmogorov-Smirnov, Monte Carlo, Diggle-Cressie-Loosmore-Ford, Dao-Genton, two-stage Monte Carlo) and tests for covariate effects (Cox-Berman-Waller-Lawson, Kolmogorov-Smirnov, ANOVA) are also supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.explore/issues">https://github.com/spatstat/spatstat.explore/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 02:38:56 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Kasper Klitgaard Berthelsen [ctb],
  Warick Brown [cph],
  Achmad Choiruddin [ctb],
  Jean-Francois Coeurjolly [ctb],
  Ottmar Cronie [ctb],
  Tilman Davies [ctb, cph],
  Julian Gilbey [ctb],
  Jonatan Gonzalez [ctb],
  Yongtao Guan [ctb],
  Ute Hahn [ctb],
  Kassel Hingee [ctb, cph],
  Abdollah Jalilian [ctb],
  Frederic Lavancier [ctb],
  Marie-Colette van Lieshout [ctb, cph],
  Greg McSwiggan [ctb],
  Robin K Milne [cph],
  Tuomas Rajala [ctb],
  Suman Rakshit [ctb, cph],
  Dominic Schuhmacher [ctb],
  Rasmus Plenge Waagepetersen [ctb],
  Hangsheng Wang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.ssf'>
Subset of spatially sampled function
</h2><span id='topic++5B.ssf'></span>

<h3>Description</h3>

<p>Extract a subset of the data for a spatially sampled function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ssf'
x[i, j, ..., drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.ssf_+3A_x">x</code></td>
<td>

<p>Object of class <code>"ssf"</code>.
</p>
</td></tr>  
<tr><td><code id="+2B5B.ssf_+3A_i">i</code></td>
<td>

<p>Subset index applying to the locations where the function is sampled.
</p>
</td></tr>
<tr><td><code id="+2B5B.ssf_+3A_j">j</code></td>
<td>

<p>Subset index applying to the columns (variables) measured at each location.
</p>
</td></tr>
<tr><td><code id="+2B5B.ssf_+3A_...">...</code>, <code id="+2B5B.ssf_+3A_drop">drop</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the subset operator for the class <code>"ssf"</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"ssf"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssf">ssf</a></code>, 
<code><a href="#topic+with.ssf">with.ssf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- ssf(cells, data.frame(d=nndist(cells), i=1:42))
  f
  f[1:10,]
  f[ ,1]
</code></pre>

<hr>
<h2 id='adaptive.density'>Adaptive Estimate of Intensity of Point Pattern</h2><span id='topic+adaptive.density'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of the intensity function of a point
pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive.density(X, ..., method=c("voronoi","kernel", "nearest"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive.density_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code> or
<code>"lpp"</code>).</p>
</td></tr>
<tr><td><code id="adaptive.density_+3A_method">method</code></td>
<td>
<p>Character string specifying the estimation method</p>
</td></tr>
<tr><td><code id="adaptive.density_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="#topic+densityVoronoi">densityVoronoi</a></code>, <code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code>
or <code><a href="#topic+nndensity">nndensity</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alternative to <code><a href="#topic+density.ppp">density.ppp</a></code>. It
computes an estimate of the intensity function of a point pattern
dataset. The result is a pixel image giving the estimated intensity.
</p>
<p>If <code>method="voronoi"</code> the data are passed to the function
<code><a href="#topic+densityVoronoi">densityVoronoi</a></code> which estimates the intensity using
the Voronoi-Dirichlet tessellation.
</p>
<p>If <code>method="kernel"</code> the data are passed to the function
<code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code> which estimates the intensity
using a variable-bandwidth kernel estimator.
</p>
<p>If <code>method="nearest"</code> the data are passed to the function
<code><a href="#topic+nndensity">nndensity</a></code> which estimates the intensity using the
distance to the <code>k</code>-th nearest data point. (This is not supported
when <code>X</code> has class <code>"lpp"</code>.)
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose values are
estimates of the intensity of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+densityVoronoi">densityVoronoi</a></code>,
<code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code>,
<code><a href="#topic+nndensity">nndensity</a></code>,
<code>im.object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(adaptive.density(nztrees, 1), main="Voronoi estimate")
</code></pre>

<hr>
<h2 id='allstats'>Calculate four standard summary functions of a point pattern.</h2><span id='topic+allstats'></span>

<h3>Description</h3>

<p>Calculates the <code class="reqn">F</code>, <code class="reqn">G</code>, <code class="reqn">J</code>, and <code class="reqn">K</code>
summary functions for an unmarked point pattern.
Returns them as a function array (of class <code>"fasp"</code>, see
<code><a href="#topic+fasp.object">fasp.object</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  allstats(pp, ..., dataname=NULL, verb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allstats_+3A_pp">pp</code></td>
<td>
<p>The observed point pattern, for which summary function
estimates are required.  An object of class <code>"ppp"</code>.
It must not be marked.
</p>
</td></tr>
<tr><td><code id="allstats_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to the summary functions
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>, <code><a href="#topic+Jest">Jest</a></code>
and <code><a href="#topic+Kest">Kest</a></code>.
</p>
</td></tr>
<tr><td><code id="allstats_+3A_dataname">dataname</code></td>
<td>
<p>A character string giving an optional (alternative)
name for the point pattern.
</p>
</td></tr>
<tr><td><code id="allstats_+3A_verb">verb</code></td>
<td>
<p>A logical value meaning &ldquo;verbose&rdquo;. If <code>TRUE</code>,
progress reports are printed during calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes four standard summary statistics for a
point pattern: the empty space function <code class="reqn">F(r)</code>,
nearest neighbour distance distribution function <code class="reqn">G(r)</code>,
van Lieshout-Baddeley function <code class="reqn">J(r)</code>
and Ripley's function <code class="reqn">K(r)</code>.
The real work is done by 
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>, <code><a href="#topic+Jest">Jest</a></code> and
<code><a href="#topic+Kest">Kest</a></code> respectively. Consult the help files for these functions
for further information about the statistical interpretation
of <code class="reqn">F</code>, <code class="reqn">G</code>, <code class="reqn">J</code> and <code class="reqn">K</code>.
</p>
<p>If <code>verb</code> is <code>TRUE</code>, then &ldquo;progress reports&rdquo;
(just indications of completion) are printed out when the
calculations are finished for each of the four function types.
</p>
<p>The overall title of the array of four functions
(for plotting by <code><a href="#topic+plot.fasp">plot.fasp</a></code>)
will be formed from the argument <code>dataname</code>.
If this is not given, it defaults to the expression
for <code>pp</code> given in the call to <code>allstats</code>.
</p>


<h3>Value</h3>

<p>A list of length 4 containing the <code class="reqn">F</code>, <code class="reqn">G</code>, <code class="reqn">J</code> and
<code class="reqn">K</code> functions respectively. 
</p>
<p>The list can be plotted directly using <code>plot</code> (which dispatches to
<code>plot.solist</code>). 
</p>
<p>Each list entry retains the format
of the output of the relevant estimating routine
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>, <code><a href="#topic+Jest">Jest</a></code> or
<code><a href="#topic+Kest">Kest</a></code>. Thus each entry in the list is
a function value table (object of class <code>"fv"</code>,
see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>The default formulae for plotting these functions are 
<code>cbind(km,theo) ~ r</code> for F, G, and J, and
<code>cbind(trans,theo) ~ r</code> for K.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>plot.solist</code>,
<code><a href="#topic+plot.fv">plot.fv</a></code>,
<code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>        a &lt;- allstats(swedishpines,dataname="Swedish Pines")
        if(interactive()) {
        plot(a)
        plot(a, subset=list("r&lt;=15","r&lt;=15","r&lt;=15","r&lt;=50"))
        }
</code></pre>

<hr>
<h2 id='alltypes'>Calculate Summary Statistic for All Types in a Multitype Point Pattern</h2><span id='topic+alltypes'></span>

<h3>Description</h3>

<p>Given a marked point pattern, this computes the estimates of
a selected summary function (<code class="reqn">F</code>,<code class="reqn">G</code>, <code class="reqn">J</code>, <code class="reqn">K</code> etc)
of the pattern, for all possible combinations of marks,
and returns these functions in an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  alltypes(X, fun="K", ...,
           dataname=NULL,verb=FALSE,envelope=FALSE,reuse=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alltypes_+3A_x">X</code></td>
<td>
<p>The observed point pattern, for which summary function
estimates are required.  An object of class <code>"ppp"</code> or <code>"lpp"</code>.
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_fun">fun</code></td>
<td>
<p>The summary function. Either an <span class="rlang"><b>R</b></span> function,
or a character string indicating the summary function
required.  Options for strings are
<code>"F"</code>, <code>"G"</code>, <code>"J"</code>, <code>"K"</code>, <code>"L"</code>, <code>"pcf"</code>,
<code>"Gcross"</code>, <code>"Jcross"</code>, <code>"Kcross"</code>, <code>"Lcross"</code>,
<code>"Gdot"</code>, <code>"Jdot"</code>, <code>"Kdot"</code>, <code>"Ldot"</code>.
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_...">...</code></td>
<td>

<p>Arguments passed to the summary function
(and to the function <code><a href="#topic+envelope">envelope</a></code> if appropriate)
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_dataname">dataname</code></td>
<td>
<p>Character string giving an optional (alternative)
name to the point pattern, different from what is given
in the call.  This name, if supplied, may be used by
<code><a href="#topic+plot.fasp">plot.fasp</a>()</code> in forming the title of the plot.
If not supplied it defaults to the parsing of the argument
supplied as <code>X</code> in the call.
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_verb">verb</code></td>
<td>

<p>Logical value.  If <code>verb</code> is
true then terse &ldquo;progress reports&rdquo; (just the values of the
mark indices) are printed out when the calculations for that
combination of marks are completed. 
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_envelope">envelope</code></td>
<td>

<p>Logical value. If <code>envelope</code> is true, then simulation envelopes
of the summary function will also be computed. See Details.
</p>
</td></tr>
<tr><td><code id="alltypes_+3A_reuse">reuse</code></td>
<td>

<p>Logical value indicating whether the envelopes in each panel
should be based on the same set of simulated patterns
(<code>reuse=TRUE</code>) or on different, independent sets of simulated
patterns (<code>reuse=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is a convenient way to analyse the dependence between
types in a multitype point pattern.
It computes the estimates of a selected summary function of the
pattern, for all possible combinations of marks.
It returns these functions in an array
(an object of class <code>"fasp"</code>) amenable to plotting
by <code><a href="#topic+plot.fasp">plot.fasp</a>()</code>.
</p>
<p>The argument <code>fun</code> specifies the summary function that will
be evaluated for each type of point, or for each pair of types.
It may be either an <span class="rlang"><b>R</b></span> function or a character string.
</p>
<p>Suppose that the points have possible types <code class="reqn">1,2,\ldots,m</code>
and let <code class="reqn">X_i</code> denote the pattern of points of type <code class="reqn">i</code> only.
</p>
<p>If <code>fun="F"</code> then this routine
calculates, for each possible type <code class="reqn">i</code>,
an estimate of the Empty Space Function <code class="reqn">F_i(r)</code> of
<code class="reqn">X_i</code>. See <code><a href="#topic+Fest">Fest</a></code>
for explanation of the empty space function.
The estimate is computed by applying <code><a href="#topic+Fest">Fest</a></code>
to <code class="reqn">X_i</code> with the optional arguments <code>...</code>.
</p>
<p>If <code>fun</code> is
<code>"Gcross"</code>, <code>"Jcross"</code>, <code>"Kcross"</code> or <code>"Lcross"</code>,
the routine calculates, for each pair of types <code class="reqn">(i,j)</code>,
an estimate of the &ldquo;<code>i</code>-to<code>j</code>&rdquo; cross-type function
<code class="reqn">G_{ij}(r)</code>,
<code class="reqn">J_{ij}(r)</code>,
<code class="reqn">K_{ij}(r)</code> or
<code class="reqn">L_{ij}(r)</code> respectively describing the
dependence between 
<code class="reqn">X_i</code> and <code class="reqn">X_j</code>.
See <code><a href="#topic+Gcross">Gcross</a></code>, <code><a href="#topic+Jcross">Jcross</a></code>, <code><a href="#topic+Kcross">Kcross</a></code>
or <code><a href="#topic+Lcross">Lcross</a></code> respectively for explanation of these
functions.
The estimate is computed by applying the relevant function
(<code><a href="#topic+Gcross">Gcross</a></code> etc)
to <code>X</code> using each possible value of the arguments <code>i,j</code>,
together with the optional arguments <code>...</code>.
</p>
<p>If <code>fun</code> is <code>"pcf"</code> the routine calculates
the cross-type pair correlation function <code><a href="#topic+pcfcross">pcfcross</a></code>
between each pair of types.
</p>
<p>If <code>fun</code> is 
<code>"Gdot"</code>, <code>"Jdot"</code>, <code>"Kdot"</code> or <code>"Ldot"</code>,
the routine calculates, for each type <code class="reqn">i</code>,
an estimate of the &ldquo;<code>i</code>-to-any&rdquo; dot-type function
<code class="reqn">G_{i\bullet}(r)</code>,
<code class="reqn">J_{i\bullet}(r)</code> or
<code class="reqn">K_{i\bullet}(r)</code> or
<code class="reqn">L_{i\bullet}(r)</code> respectively describing the
dependence between <code class="reqn">X_i</code> and <code class="reqn">X</code>.
See <code><a href="#topic+Gdot">Gdot</a></code>, <code><a href="#topic+Jdot">Jdot</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>
or <code><a href="#topic+Ldot">Ldot</a></code> respectively for explanation of these functions.
The estimate is computed by applying the relevant function
(<code><a href="#topic+Gdot">Gdot</a></code> etc)
to <code>X</code> using each possible value of the argument <code>i</code>,
together with the optional arguments <code>...</code>.
</p>
<p>The letters <code>"G"</code>, <code>"J"</code>, <code>"K"</code> and <code>"L"</code>
are interpreted as abbreviations for <code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Jcross">Jcross</a></code>, <code><a href="#topic+Kcross">Kcross</a></code> and <code><a href="#topic+Lcross">Lcross</a></code>
respectively, assuming the point pattern is
marked. If the point pattern is unmarked, the appropriate
function <code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code> or <code><a href="#topic+Lest">Lest</a></code> is invoked instead.
</p>
<p>If <code>envelope=TRUE</code>, then as well as computing the value of the
summary function for each combination of types, the algorithm also
computes simulation envelopes of the summary function for each
combination of types. The arguments <code>...</code> are passed to the function
<code><a href="#topic+envelope">envelope</a></code> to control the number of
simulations, the random process generating the simulations,
the construction of envelopes, and so on. 
</p>
<p>When <code>envelope=TRUE</code> it is possible that errors could occur
because the simulated point patterns do not satisfy the requirements
of the summary function (for example, because the simulated pattern
is empty and <code>fun</code> requires at least one point). If the number
of such errors exceeds the maximum permitted number <code>maxnerr</code>,
then the envelope algorithm will give up, and will return
the empirical summary function for the data point pattern,
<code>fun(X)</code>, in place of the envelope.
</p>


<h3>Value</h3>

<p>A function array (an object of class <code>"fasp"</code>,
see <code><a href="#topic+fasp.object">fasp.object</a></code>). This can be plotted
using <code><a href="#topic+plot.fasp">plot.fasp</a></code>.
</p>
<p>If the pattern is not marked, the resulting &ldquo;array&rdquo; has dimensions
<code class="reqn">1 \times 1</code>. Otherwise the following is true:
</p>
<p>If <code>fun="F"</code>,
the function array has dimensions <code class="reqn">m \times 1</code>
where <code class="reqn">m</code> is the number of different marks in the point pattern.
The entry at position <code>[i,1]</code> in this array
is the result of applying <code><a href="#topic+Fest">Fest</a></code> to the
points of type <code>i</code> only.
</p>
<p>If <code>fun</code> is <code>"Gdot"</code>, <code>"Jdot"</code>, <code>"Kdot"</code>
or <code>"Ldot"</code>, the function array
again has dimensions <code class="reqn">m \times 1</code>.
The entry at position <code>[i,1]</code> in this array
is the result of <code>Gdot(X, i)</code>, <code>Jdot(X, i)</code>
<code>Kdot(X, i)</code> or <code>Ldot(X, i)</code> respectively.
</p>
<p>If <code>fun</code> is <code>"Gcross"</code>, <code>"Jcross"</code>, <code>"Kcross"</code>
or <code>"Lcross"</code> 
(or their abbreviations <code>"G"</code>, <code>"J"</code>, <code>"K"</code> or <code>"L"</code>),
the function array has dimensions <code class="reqn">m \times m</code>.
The <code>[i,j]</code> entry of the function array
(for <code class="reqn">i \neq j</code>) is the
result of applying the function <code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Jcross">Jcross</a></code>, <code><a href="#topic+Kcross">Kcross</a></code> or<code><a href="#topic+Lcross">Lcross</a></code> to
the pair of types <code>(i,j)</code>. The diagonal
<code>[i,i]</code> entry of the function array is the result of
applying the univariate function <code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>, <code><a href="#topic+Kest">Kest</a></code> or <code><a href="#topic+Lest">Lest</a></code> to the
points of type <code>i</code> only.
</p>
<p>If <code>envelope=FALSE</code>, then
each function entry <code>fns[[i]]</code> retains the format
of the output of the relevant estimating routine
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>, <code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,  <code><a href="#topic+Lest">Lest</a></code>, <code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Jcross">Jcross</a></code> ,<code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Lcross">Lcross</a></code>,
<code><a href="#topic+Gdot">Gdot</a></code>, <code><a href="#topic+Jdot">Jdot</a></code>, <code><a href="#topic+Kdot">Kdot</a></code> or
<code><a href="#topic+Ldot">Ldot</a></code>
The default formulae for plotting these functions are 
<code>cbind(km,theo) ~ r</code> for F, G, and J functions, and
<code>cbind(trans,theo) ~ r</code> for K and L functions.
</p>
<p>If <code>envelope=TRUE</code>, then each function entry <code>fns[[i]]</code>
has the same format as the output of the <code><a href="#topic+envelope">envelope</a></code> command.
</p>


<h3>Note</h3>

<p>Sizeable amounts of memory may be needed during the calculation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fasp">plot.fasp</a></code>,
<code><a href="#topic+fasp.object">fasp.object</a></code>,
<code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Lest">Lest</a></code>,
<code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Jcross">Jcross</a></code>,
<code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Lcross">Lcross</a></code>,
<code><a href="#topic+Gdot">Gdot</a></code>,
<code><a href="#topic+Jdot">Jdot</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+envelope">envelope</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # bramblecanes (3 marks).
   bram &lt;- bramblecanes
   
   bF &lt;- alltypes(bram,"F",verb=TRUE)
   plot(bF)
   if(interactive()) {
     plot(alltypes(bram,"G"))
     plot(alltypes(bram,"Gdot"))
   }
   
   # Swedishpines (unmarked).
  swed &lt;- swedishpines
   
   plot(alltypes(swed,"K"))

   plot(alltypes(amacrine, "pcf"), ylim=c(0,1.3))

   # envelopes
   bKE &lt;- alltypes(bram,"K",envelope=TRUE,nsim=19)
   # global version:
   
     bFE &lt;- alltypes(bram,"F",envelope=TRUE,nsim=19,global=TRUE)
   

   # extract one entry
   as.fv(bKE[1,1])
   
</code></pre>

<hr>
<h2 id='as.data.frame.envelope'>Coerce Envelope to Data Frame</h2><span id='topic+as.data.frame.envelope'></span>

<h3>Description</h3>

<p>Converts an envelope object to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'envelope'
as.data.frame(x, ..., simfuns=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.envelope_+3A_x">x</code></td>
<td>
<p>Envelope object (class <code>"envelope"</code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.envelope_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.envelope_+3A_simfuns">simfuns</code></td>
<td>
<p>Logical value indicating whether the result should
include the values of the simulated functions
that were used to build the envelope. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
for the class of envelopes (see <code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>The result is a data frame with columns
containing the values of the function argument
(usually named <code>r</code>), the function estimate for the original
point pattern data (<code>obs</code>),
the upper and lower envelope limits (<code>hi</code> and <code>lo</code>),
and possibly additional columns.
</p>
<p>If <code>simfuns=TRUE</code>, the result also includes columns of values
of the simulated functions that were used to compute the envelope.
This is possible only when the envelope was computed with the
argument <code>savefuns=TRUE</code> in the call to <code><a href="#topic+envelope">envelope</a></code>.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  E &lt;- envelope(cells, nsim=5, savefuns=TRUE)
  tail(as.data.frame(E))
  tail(as.data.frame(E, simfuns=TRUE))
</code></pre>

<hr>
<h2 id='as.function.fv'>
Convert Function Value Table to Function
</h2><span id='topic+as.function.fv'></span>

<h3>Description</h3>

<p>Converts an object of class <code>"fv"</code> to an <span class="rlang"><b>R</b></span> language function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fv'
as.function(x, ..., value=".y", extrapolate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.fv_+3A_x">x</code></td>
<td>

<p>Object of class <code>"fv"</code> or <code>"rhohat"</code>.
</p>
</td></tr>
<tr><td><code id="as.function.fv_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="as.function.fv_+3A_value">value</code></td>
<td>

<p>Optional. Character string or character vector selecting
one or more of the columns of <code>x</code>
for use as the function value. See Details.
</p>
</td></tr>
<tr><td><code id="as.function.fv_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Logical, indicating whether to extrapolate the function
outside the domain of <code>x</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function value table (object of class <code>"fv"</code>)
is a convenient way of storing and plotting
several different estimates of the same function.
Objects of this class are returned 
by many commands in <span class="pkg">spatstat</span>,
such as <code><a href="#topic+Kest">Kest</a></code>,
which returns an estimate of Ripley's <code class="reqn">K</code>-function
for a point pattern dataset.
</p>
<p>Sometimes it is useful to convert the function value table
to a <code>function</code> in the <span class="rlang"><b>R</b></span> language. This is done by
<code>as.function.fv</code>. It converts an object <code>x</code> of class <code>"fv"</code>
to an <span class="rlang"><b>R</b></span> function <code>f</code>.
</p>
<p>If <code>f &lt;- as.function(x)</code> then <code>f</code> is an <span class="rlang"><b>R</b></span> function
that accepts a numeric argument and returns a corresponding value
for the summary function by linear interpolation between the values
in the table <code>x</code>. 
</p>
<p>Argument values lying outside the range of the table
yield an <code>NA</code> value (if <code>extrapolate=FALSE</code>)
or the function value at the nearest endpoint of the range
(if <code>extrapolate = TRUE</code>).
To apply different rules to the left and right extremes,
use <code>extrapolate=c(TRUE,FALSE)</code> and so on.
</p>
<p>Typically the table <code>x</code> contains several columns of
function values corresponding to different edge corrections.
Auxiliary information for the table identifies one of these
columns as the <em>recommended value</em>. 
By default, the values of the function <code>f &lt;- as.function(x)</code>
are taken from this column of recommended values. 
This default can be changed using the argument <code>value</code>,
which can be a character string or character vector of names of
columns of <code>x</code>. Alternatively <code>value</code> can be one of
the abbreviations used by <code><a href="#topic+fvnames">fvnames</a></code>.
</p>
<p>If <code>value</code> specifies a single column of the table,
then the result is a function <code>f(r)</code> with a single numeric
argument <code>r</code> (with the same name as the orginal argument
of the function table).
</p>
<p>If <code>value</code> specifies several columns of the table,
then the result is a function <code>f(r,what)</code> 
where <code>r</code> is the numeric argument and 
<code>what</code> is a character string identifying the column of values
to be used.
</p>
<p>The formal arguments of the resulting function
are <code>f(r, what=value)</code>, which
means that in a call to this function <code>f</code>, the permissible values
of <code>what</code> are the entries of the original vector <code>value</code>;
the default value of <code>what</code> is the first entry of <code>value</code>.
</p>
<p>The command <code>as.function.fv</code> is a method for the generic command
<code><a href="base.html#topic+as.function">as.function</a></code>. 
</p>


<h3>Value</h3>

<p>A <code>function(r)</code> or <code>function(r,what)</code>
where <code>r</code> is the name of the original argument of the function table.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.function.rhohat">as.function.rhohat</a></code>, 
<code><a href="#topic+fv">fv</a></code>, 
<code><a href="#topic+fv.object">fv.object</a></code>, 
<code><a href="#topic+fvnames">fvnames</a></code>, 
<code><a href="#topic+plot.fv">plot.fv</a></code>, 
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  K &lt;- Kest(cells)
  f &lt;- as.function(K)
  f
  f(0.1)
  g &lt;- as.function(K, value=c("iso", "trans"))
  g
  g(0.1, "trans")
</code></pre>

<hr>
<h2 id='as.function.rhohat'>
Convert Function Table to Function
</h2><span id='topic+as.function.rhohat'></span>

<h3>Description</h3>

<p>Converts an object of class <code>"rhohat"</code> to an <span class="rlang"><b>R</b></span> language function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'rhohat'
as.function(x, ..., value=".y", extrapolate=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.rhohat_+3A_x">x</code></td>
<td>

<p>Object of class <code>"rhohat"</code>,
produced by the function <code><a href="#topic+rhohat">rhohat</a></code>.
</p>
</td></tr>
<tr><td><code id="as.function.rhohat_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="as.function.rhohat_+3A_value">value</code></td>
<td>

<p>Optional. Character string or character vector selecting
one or more of the columns of <code>x</code>
for use as the function value. See Details.
</p>
</td></tr>
<tr><td><code id="as.function.rhohat_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Logical, indicating whether to extrapolate the function
outside the domain of <code>x</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"rhohat"</code> is essentially a data frame
of estimated values of the function <code class="reqn">rho(x)</code>
as described in the help file for <code><a href="#topic+rhohat">rhohat</a></code>. 
</p>
<p>Sometimes it is useful to convert the function value table
to a <code>function</code> in the <span class="rlang"><b>R</b></span> language. This is done by
<code>as.function.rhohat</code>. It converts an object <code>x</code>
of class <code>"rhohat"</code> to an <span class="rlang"><b>R</b></span> function <code>f</code>.
</p>
<p>The command <code>as.function.rhohat</code> is a method for the generic command
<code><a href="base.html#topic+as.function">as.function</a></code> for the class <code>"rhohat"</code>.
</p>
<p>If <code>f &lt;- as.function(x)</code> then <code>f</code> is an <span class="rlang"><b>R</b></span> function
that accepts a numeric argument and returns a corresponding value
for the summary function by linear interpolation between the values
in the table <code>x</code>. 
</p>
<p>Argument values lying outside the range of the table
yield an <code>NA</code> value (if <code>extrapolate=FALSE</code>)
or the function value at the nearest endpoint of the range
(if <code>extrapolate = TRUE</code>).
To apply different rules to the left and right extremes,
use <code>extrapolate=c(TRUE,FALSE)</code> and so on.
</p>
<p>Typically the table <code>x</code> contains several columns of
function values corresponding to different edge corrections.
Auxiliary information for the table identifies one of these
columns as the <em>recommended value</em>. 
By default, the values of the function <code>f &lt;- as.function(x)</code>
are taken from this column of recommended values. 
This default can be changed using the argument <code>value</code>,
which can be a character string or character vector of names of
columns of <code>x</code>. Alternatively <code>value</code> can be one of
the abbreviations used by <code><a href="#topic+fvnames">fvnames</a></code>.
</p>
<p>If <code>value</code> specifies a single column of the table,
then the result is a function <code>f(r)</code> with a single numeric
argument <code>r</code> (with the same name as the orginal argument
of the function table).
</p>
<p>If <code>value</code> specifies several columns of the table,
then the result is a function <code>f(r,what)</code> 
where <code>r</code> is the numeric argument and 
<code>what</code> is a character string identifying the column of values
to be used.
</p>
<p>The formal arguments of the resulting function
are <code>f(r, what=value)</code>, which
means that in a call to this function <code>f</code>, the permissible values
of <code>what</code> are the entries of the original vector <code>value</code>;
the default value of <code>what</code> is the first entry of <code>value</code>.
</p>


<h3>Value</h3>

<p>A <code>function(r)</code> or <code>function(r,what)</code>
where <code>r</code> is the name of the original argument of the function table.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhohat">rhohat</a></code>, 
<code><a href="#topic+methods.rhohat">methods.rhohat</a></code>,
<code><a href="#topic+as.function.fv">as.function.fv</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- rhohat(cells, "x")
  f &lt;- as.function(g)
  f
  f(0.1)
</code></pre>

<hr>
<h2 id='as.fv'>Convert Data To Class fv</h2><span id='topic+as.fv'></span><span id='topic+as.fv.fv'></span><span id='topic+as.fv.fasp'></span><span id='topic+as.fv.data.frame'></span><span id='topic+as.fv.matrix'></span><span id='topic+as.fv.bw.optim'></span>

<h3>Description</h3>

<p>Converts data into a function table (an object of class <code>"fv"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.fv(x)

  ## S3 method for class 'fv'
as.fv(x)

  ## S3 method for class 'data.frame'
as.fv(x)

  ## S3 method for class 'matrix'
as.fv(x)

  ## S3 method for class 'fasp'
as.fv(x)

  ## S3 method for class 'bw.optim'
as.fv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.fv_+3A_x">x</code></td>
<td>
<p>Data which will be converted into a function table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command converts data <code>x</code>, that
could be interpreted as the values of a function,
into a function value table (object of the class <code>"fv"</code>
as described in <code><a href="#topic+fv.object">fv.object</a></code>). This object can then
be plotted easily using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The dataset <code>x</code> may be any of the following:
</p>

<ul>
<li>
<p>an object of class <code>"fv"</code>;
</p>
</li>
<li>
<p>a matrix or data frame with at least two columns;
</p>
</li>
<li>
<p>an object of class <code>"fasp"</code>, representing an array of
<code>"fv"</code> objects.
</p>
</li>
<li>
<p>an object of class <code>"minconfit"</code>, giving the results
of a minimum contrast fit by
the command <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>.
The 
</p>
</li>
<li>
<p>an object of class <code>"kppm"</code>, representing a fitted
Cox or cluster point process model, obtained from the
model-fitting command <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>;
</p>
</li>
<li>
<p>an object of class <code>"dppm"</code>, representing a fitted
determinantal point process model, obtained from the
model-fitting command <code><a href="spatstat.model.html#topic+dppm">dppm</a></code>;
</p>
</li>
<li>
<p>an object of class <code>"bw.optim"</code>, representing an optimal
choice of smoothing bandwidth by a cross-validation method, obtained
from commands like <code><a href="#topic+bw.diggle">bw.diggle</a></code>.
</p>
</li></ul>

<p>The function <code>as.fv</code> is generic, with methods for each of the
classes listed above. The behaviour is as follows:
</p>

<ul>
<li>
<p>If <code>x</code> is an object of class <code>"fv"</code>, it is
returned unchanged.
</p>
</li>
<li>
<p>If <code>x</code> is a matrix or data frame, 
the first column is interpreted
as the function argument, and subsequent columns are interpreted as
values of the function computed by different methods.
</p>
</li>
<li>
<p>If <code>x</code> is an object of class <code>"fasp"</code>
representing an array of <code>"fv"</code> objects, 
these are combined into a single <code>"fv"</code> object.
</p>
</li>
<li>
<p>If <code>x</code> is an object of class <code>"minconfit"</code>,
or an object of class <code>"kppm"</code> or <code>"dppm"</code>,
the result is a function table containing the
observed summary function and the best fit summary function.
</p>
</li>
<li>
<p>If <code>x</code> is an object of class <code>"bw.optim"</code>,
the result is a function table of the optimisation criterion
as a function of the smoothing bandwidth.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  r &lt;- seq(0, 1, length=101)
  x &lt;- data.frame(r=r, y=r^2)
  as.fv(x)
</code></pre>

<hr>
<h2 id='as.owin.quadrattest'>Convert Data To Class owin</h2><span id='topic+as.owin.quadrattest'></span>

<h3>Description</h3>

<p>Converts data specifying an observation window
in any of several formats, into an object of class <code>"owin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'quadrattest'
as.owin(W, ..., fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin.quadrattest_+3A_w">W</code></td>
<td>

<p>Data specifying an observation window, in any of several formats
described under <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="as.owin.quadrattest_+3A_fatal">fatal</code></td>
<td>

<p>Logical value determining what to do
if the data cannot be converted to an observation window.
See Details.
</p>
</td></tr>
<tr><td><code id="as.owin.quadrattest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"owin"</code> is a way of specifying the observation window
for a point pattern. See <code>owin.object</code> for an overview.
</p>
<p>The generic function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
converts data in any of several formats 
into an object of class <code>"owin"</code> for use by the <span class="pkg">spatstat</span>
package. The function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
is generic, with methods
for different classes of objects, and a default method.
</p>
<p>The argument <code>W</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"owin"</code>
</p>
</li>
<li>
<p>a structure with entries <code>xrange</code>, <code>yrange</code> specifying the 
<code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xmin</code>, <code>xmax</code>, <code>ymin</code>,
<code>ymax</code> (in any order) 
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle.
This will accept objects of class <code>bbox</code> in the <code>sf</code> package.
</p>
</li>
<li>
<p>a numeric vector of length 4
(interpreted as <code>(xmin, xmax, ymin, ymax)</code> in that order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
(in any order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
as <code>(xmin, xmax) = (xl, xu)</code> and 
<code>(ymin, ymax) = (yl, yu)</code>. This will accept objects of
class <code>spp</code> used in the Venables and Ripley <span class="pkg">spatial</span>
package.
</p>
</li>
<li>
<p>an object of class <code>"ppp"</code> representing a point pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"psp"</code> representing a line segment pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"tess"</code> representing a tessellation.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"quad"</code> representing a quadrature scheme.
In this case, the window of the <code>data</code> component will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"im"</code> representing a pixel image.
In this case, a window of type <code>"mask"</code> will be returned,
with the same pixel raster coordinates as the image.
An image pixel value of <code>NA</code>, signifying that the pixel
lies outside the window, is transformed into the logical value
<code>FALSE</code>, which is the corresponding convention for window masks.
</p>
</li>
<li>
<p>an object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"dppm"</code>
representing a fitted point process
model. In this case, if <code>from="data"</code> (the default),
<code>as.owin</code> extracts the  original point
pattern data to which the model was fitted, and returns the
observation window of this point pattern. If
<code>from="covariates"</code> then <code>as.owin</code> extracts the
covariate images to which the model was fitted,
and returns a binary mask window that specifies the pixel locations.
</p>
</li>
<li>
<p>an object of class <code>"lpp"</code>
representing a point pattern on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>an object of class <code>"lppm"</code>
representing a fitted point process model on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly three columns. Each row of the
data frame corresponds to one pixel. Each row contains the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel, and a logical value
indicating whether the pixel lies inside the window.   
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly two columns. Each row of the
data frame contains the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel
that lies inside the window.
</p>
</li>
<li>
<p>an object of class <code>"distfun"</code>, <code>"nnfun"</code>
or <code>"funxy"</code> representing a function of spatial location,
defined on a spatial domain. The spatial domain of the function will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"rmhmodel"</code> representing a
point process model that can be simulated using <code>rmh</code>.
The window (spatial domain) of the model will be extracted.
The window may be <code>NULL</code> in some circumstances (indicating that the
simulation window has not yet been determined). This is not treated
as an error, because the argument <code>fatal</code> defaults to
<code>FALSE</code> for this method.
</p>
</li>
<li>
<p>an object of class <code>"layered"</code> representing a
list of spatial objects. See <code>layered</code>.
In this case, <code>as.owin</code> will be applied to each
of the objects in the list, and the union of these windows
will be returned.
</p>
</li>
<li>
<p>An object of another suitable class from another package.
For full details, see <code>vignette('shapefiles')</code>.
</p>
</li></ul>

<p>If the argument <code>W</code> is not in one of these formats
and cannot be converted to a window, then an error will
be generated (if <code>fatal=TRUE</code>) or a value of <code>NULL</code>
will be returned (if <code>fatal=FALSE</code>).
</p>
<p>When <code>W</code> is a data frame, the argument <code>step</code>
can be used to specify the pixel grid spacing; otherwise, the spacing
will be guessed from the data.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code>owin.object</code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.random.html#topic+as.owin.rmhmodel">as.owin.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+as.owin.lpp">as.owin.lpp</a></code>.
</p>
<p><code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>,
<code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>
<p>Additional methods for <code>as.owin</code> may be provided
by other packages outside the <span class="pkg">spatstat</span> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  te &lt;- quadrat.test(redwood, nx=3)
  as.owin(te)
</code></pre>

<hr>
<h2 id='as.tess'>Convert Data To Tessellation</h2><span id='topic+as.tess.quadrattest'></span>

<h3>Description</h3>

<p>Converts data specifying a tessellation,
in any of several formats, into an object of class <code>"tess"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'quadrattest'
as.tess(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tess_+3A_x">X</code></td>
<td>
<p>Data to be converted to a tessellation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. This command creates an object of class <code>"tess"</code> that
represents a tessellation. 
</p>
<p>This function converts data in any of several formats 
into an object of class <code>"tess"</code> for use by the <span class="pkg">spatstat</span>
package.  The argument <code>X</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"tess"</code>.
The object will be stripped of any extraneous attributes
and returned.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>) with pixel values that
are logical or factor values. Each level of the factor will
determine a tile of the tessellation.
</p>
</li>
<li>
<p>a window (object of class <code>"owin"</code>). The result will be a
tessellation consisting of a single tile.
</p>
</li>
<li>
<p>a set of quadrat counts (object of class <code>"quadratcount"</code>)
returned by the command <code>quadratcount</code>.
The quadrats
used to generate the counts will be extracted and returned as a
tessellation.
</p>
</li>
<li>
<p>a quadrat test (object of class <code>"quadrattest"</code>)
returned by the command <code><a href="#topic+quadrat.test">quadrat.test</a></code>. 
The quadrats
used to perform the test will be extracted and returned as a
tessellation.
</p>
</li>
<li>
<p>a list of windows (objects of class <code>"owin"</code>)
giving the tiles of the tessellation.
</p>
</li></ul>

<p>The function <code>as.tess</code> is generic, with methods for
various classes, as listed above.
</p>


<h3>Value</h3>

<p>An object of class <code>"tess"</code> specifying a tessellation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>tess</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 h &lt;- quadrat.test(nztrees, nx=4, ny=3)
 as.tess(h)
</code></pre>

<hr>
<h2 id='auc'>
Area Under ROC Curve
</h2><span id='topic+auc'></span><span id='topic+auc.ppp'></span>

<h3>Description</h3>

<p>Compute the AUC (area under the Receiver Operating Characteristic
curve) for
an observed point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(X, ...)

## S3 method for class 'ppp'
auc(X, covariate, ..., high = TRUE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>)
or fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code>, <code>"slrm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="auc_+3A_covariate">covariate</code></td>
<td>

<p>Spatial covariate. Either a <code>function(x,y)</code>,
a pixel image (object of class <code>"im"</code>), or
one of the strings <code>"x"</code> or <code>"y"</code> indicating the
Cartesian coordinates.    
</p>
</td></tr>
<tr><td><code id="auc_+3A_high">high</code></td>
<td>

<p>Logical value indicating whether the threshold operation
should favour high or low values of the covariate.
</p>
</td></tr>
<tr><td><code id="auc_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the AUC, the area under the Receiver Operating
Characteristic curve. The ROC itself is computed by <code><a href="#topic+roc">roc</a></code>.
</p>
<p>For a point pattern <code>X</code> and a covariate <code>Z</code>, the
AUC is a numerical index that measures the ability of the 
covariate to separate the spatial domain
into areas of high and low density of points.
Let <code class="reqn">x_i</code> be a randomly-chosen data point from <code>X</code>
and <code class="reqn">U</code> a randomly-selected location in the study region.
The AUC is the probability that
<code class="reqn">Z(x_i) &gt; Z(U)</code>
assuming <code>high=TRUE</code>.
That is, AUC is the probability that a randomly-selected data point
has a higher value of the covariate <code>Z</code> than does a
randomly-selected spatial location. The AUC is a number between 0 and 1. 
A value of 0.5 indicates a complete lack of discriminatory power.
</p>


<h3>Value</h3>

<p>Numeric.
For <code>auc.ppp</code> and <code>auc.lpp</code>, the result is a single number
giving the AUC value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  auc(swedishpines, "x")
</code></pre>

<hr>
<h2 id='berman.test'>Berman's Tests for Point Process Model</h2><span id='topic+berman.test'></span><span id='topic+berman.test.ppp'></span>

<h3>Description</h3>

<p>Tests the goodness-of-fit of a Poisson point process model
using methods of Berman (1986).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berman.test(...)

## S3 method for class 'ppp'
berman.test(X, covariate,
                         which = c("Z1", "Z2"),
        alternative = c("two.sided", "less", "greater"), ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="berman.test_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="berman.test_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
An image (object of class <code>"im"</code>)
or a function.
</p>
</td></tr>
<tr><td><code id="berman.test_+3A_which">which</code></td>
<td>

<p>Character string specifying the choice of test.
</p>
</td></tr>
<tr><td><code id="berman.test_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="berman.test_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the pixel resolution
(arguments <code>dimyx</code>, <code>eps</code> and <code>rule.eps</code>
passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>)
or other undocumented features.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson point
process model fitted to point pattern data. The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using either of two test statistics
<code class="reqn">Z_1</code> and <code class="reqn">Z_2</code> proposed by Berman (1986).
The <code class="reqn">Z_1</code> test is also known as the
Lawson-Waller test.
</p>
<p>The function <code>berman.test</code> is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>)
and point process models (<code>"ppm"</code> or <code>"lppm"</code>).
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern dataset (object of class
<code>"ppp"</code> or <code>"lpp"</code>), then
<code>berman.test(X, ...)</code> performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model
(object of class <code>"ppm"</code> or <code>"lppm"</code>)
then <code>berman.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. In this case,
<code>model</code> should be a Poisson point process.
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model.
Thus, you must nominate a spatial covariate for this test.
</p>
<p>The argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> containing the values
of a spatial function.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.  
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected.
</p>
<p>Next the values of the <code>covariate</code> at all locations in the
observation window are evaluated. The point process intensity
of the fitted model is also evaluated at all locations in the window.
</p>

<ul>
<li><p> If <code>which="Z1"</code>,
the test statistic <code class="reqn">Z_1</code> is computed as follows.
The sum <code class="reqn">S</code> of the covariate values at all data
points is evaluated. The predicted mean <code class="reqn">\mu</code> and variance
<code class="reqn">\sigma^2</code> of <code class="reqn">S</code> are computed
from the values of the covariate at all locations in the window.
Then we compute <code class="reqn">Z_1 = (S-\mu)/\sigma</code>.
Closely-related tests were proposed independently 
by Waller et al (1993) and Lawson (1993)
so this test is often termed the 
Lawson-Waller test in epidemiological literature.
</p>
</li>
<li><p> If <code>which="Z2"</code>,
the test statistic <code class="reqn">Z_2</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window, weighted by the point process intensity,
are compiled into a cumulative distribution function <code class="reqn">F</code>.
The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers.
The standardised sample mean of these numbers is the
statistic <code class="reqn">Z_2</code>. 
</p>
</li></ul>

<p>In both cases the null distribution of the test statistic
is the standard normal distribution, approximately.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> (hypothesis test)
and also of class <code>"bermantest"</code>,
containing the results of the test. The return value can be
plotted (by <code><a href="#topic+plot.bermantest">plot.bermantest</a></code>) or printed
to give an informative summary of the test.
</p>


<h3>Warning</h3>

<p>The meaning of a one-sided test must be carefully scrutinised: see
the printed output.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>
<p>Lawson, A.B. (1993)
On the analysis of mortality events around a
prespecified fixed point.
<em>Journal of the Royal Statistical Society, Series A</em>
<b>156</b> (3) 363&ndash;377.
</p>
<p>Waller, L., Turnbull, B., Clark, L.C. and Nasca, P. (1992)
Chronic Disease Surveillance and testing of
clustering of disease and exposure: Application to
leukaemia incidence and TCE-contaminated dumpsites
in upstate New York.
<em>Environmetrics</em> <b>3</b>, 281&ndash;300.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdf.test">cdf.test</a></code>,
<code><a href="#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Berman's data
   X &lt;- copper$SouthPoints
   L &lt;- copper$SouthLines
   D &lt;- distmap(L, eps=1)
   # test of CSR
   berman.test(X, D)
   berman.test(X, D, "Z2")
</code></pre>

<hr>
<h2 id='bind.fv'>
Combine Function Value Tables
</h2><span id='topic+bind.fv'></span><span id='topic+cbind.fv'></span>

<h3>Description</h3>

<p>Advanced Use Only.
Combine objects of class <code>"fv"</code>,
or glue extra columns of data onto an existing <code>"fv"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
cbind(...)
bind.fv(x, y, labl = NULL, desc = NULL, preferred = NULL, clip=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind.fv_+3A_...">...</code></td>
<td>

<p>Any number of arguments, which are objects of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_x">x</code></td>
<td>

<p>An object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_y">y</code></td>
<td>

<p>Either a data frame or an object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_labl">labl</code></td>
<td>

<p>Plot labels (see <code><a href="#topic+fv">fv</a></code>) for columns of <code>y</code>.
A character vector. 
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_desc">desc</code></td>
<td>

<p>Descriptions (see <code><a href="#topic+fv">fv</a></code>)
for columns of <code>y</code>. A character vector.
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_preferred">preferred</code></td>
<td>

<p>Character string specifying the column which is to be the
new recommended value of the function.
</p>
</td></tr>
<tr><td><code id="bind.fv_+3A_clip">clip</code></td>
<td>

<p>Logical value indicating whether each object must have exactly the
same domain, that is, the same sequence of values of the function argument
(<code>clip=FALSE</code>, the default) or whether objects with different
domains are permissible and will be restricted
to a common domain (<code>clip=TRUE</code>).
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This documentation is provided
for experienced programmers who want to modify the internal
behaviour of <span class="pkg">spatstat</span>.
</p>
<p>The function <code>cbind.fv</code> is a method for the generic
<span class="rlang"><b>R</b></span> function <code><a href="base.html#topic+cbind">cbind</a></code>. It combines any number of
objects of class <code>"fv"</code> into a single object of
class <code>"fv"</code>. The objects must be compatible, in the sense
that they have identical values of the function argument.
</p>
<p>The function <code>bind.fv</code> is a lower level
utility which glues additional columns onto an
existing object <code>x</code> of class <code>"fv"</code>.
It has two modes of use:
</p>

<ul>
<li> 
<p>If the additional dataset <code>y</code> is an object of class <code>"fv"</code>, then
<code>x</code> and <code>y</code> must be compatible as described above.
Then the columns of <code>y</code> that contain function values
will be appended to the object <code>x</code>.
</p>
</li>
<li> 
<p>Alternatively if <code>y</code> is a data frame, then <code>y</code> must have the
same number of rows as <code>x</code>. All columns of <code>y</code> will be
appended to <code>x</code>.
</p>
</li></ul>

<p>The arguments <code>labl</code> and <code>desc</code> provide
plot labels and description strings (as described in <code><a href="#topic+fv">fv</a></code>)
for the <em>new</em> columns. If <code>y</code> is an object of class
<code>"fv"</code> then <code>labl</code> and <code>desc</code> are optional, and
default to the relevant entries in the object <code>y</code>. 
If <code>y</code> is a data frame then
<code>labl</code> and <code>desc</code> must be provided.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv">fv</a></code>, 
<code><a href="#topic+with.fv">with.fv</a></code>.
</p>
<p><em>Undocumented</em> functions for modifying an <code>"fv"</code> object
include <code>fvnames</code>, <code>fvnames&lt;-</code>,
<code>tweak.fv.entry</code> and <code>rebadge.fv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K1 &lt;- Kest(cells, correction="border")
   K2 &lt;- Kest(cells, correction="iso")

   # remove column 'theo' to avoid duplication
   K2 &lt;- K2[, names(K2) != "theo"]

   cbind(K1, K2)

   bind.fv(K1, K2, preferred="iso")

   # constrain border estimate to be monotonically increasing
   bm &lt;- cumsum(c(0, pmax(0, diff(K1$border))))
   bind.fv(K1, data.frame(bmono=bm),
               "%s[bmo](r)",
               "monotone border-corrected estimate of %s",
               "bmono") 
</code></pre>

<hr>
<h2 id='bits.envelope'>
Global Envelopes for Balanced Independent Two-Stage Test
</h2><span id='topic+bits.envelope'></span>

<h3>Description</h3>

<p>Computes the global envelopes
corresponding to the balanced independent two-stage
Monte Carlo test of goodness-of-fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bits.envelope(X, ...,
            nsim = 19, nrank = 1,
            alternative=c("two.sided", "less", "greater"),
            leaveout=1, interpolate = FALSE,
            savefuns=FALSE, savepatterns=FALSE,
            verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bits.envelope_+3A_x">X</code></td>
<td>

<p>Either a point pattern dataset (object of class <code>"ppp"</code>,
<code>"lpp"</code> or <code>"pp3"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_...">...</code></td>
<td>

<p>Arguments passed to 
<code><a href="#topic+mad.test">mad.test</a></code> or <code><a href="#topic+envelope">envelope</a></code> to
control the conduct of the test.
Useful arguments include <code>fun</code> to determine the summary
function, <code>rinterval</code> to determine the range of
<code class="reqn">r</code> values used in the test, and
<code>verbose=FALSE</code> to turn off the messages.
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated patterns to be generated in each stage.
Number of simulations in each basic test. There will be <code>nsim</code>
repetitions of the basic test, each involving <code>nsim</code> simulated
realisations, together with one independent set of <code>nsim</code>
realisations, so there will be a total
of <code>nsim * (nsim + 1)</code> simulations.
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>alternative="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>alternative="less"</code>) or a one-sided test
with an upper critical boundary (<code>alternative="greater"</code>).
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating whether to interpolate the distribution of
the test statistic by kernel smoothing, as described in
Dao and Genton (2014, Section 5).
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="bits.envelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical value determining whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes global simulation envelopes corresponding to the
balanced independent two-stage Monte Carlo test of goodness-of-fit
described by Baddeley et al (2017). 
The envelopes are described in Baddeley et al (2019).
</p>
<p>If <code>X</code> is a point pattern, the null hypothesis is CSR.
</p>
<p>If <code>X</code> is a fitted model, the null hypothesis is that model.
</p>
<p>This command is similar to <code><a href="#topic+dg.envelope">dg.envelope</a></code> which corresponds
to the Dao-Genton test of goodness-of-fit.
It was shown in Baddeley et al (2017) that
the Dao-Genton test is biased when the significance level is very small
(small <code class="reqn">p</code>-values are not reliable) and
we recommend <code><a href="#topic+bits.envelope">bits.envelope</a></code> in this case.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, T.,
Milne, R.K., Nair, G. and Rakshit, S. (2017)
On two-stage Monte Carlo tests of composite
hypotheses. <em>Computational Statistics and Data Analysis</em>
<b>114</b>, 75&ndash;87.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2019)
Pushing the envelope: extensions of graphical
Monte Carlo tests. In preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dg.envelope">dg.envelope</a></code>,
<code><a href="#topic+bits.test">bits.test</a></code>,
<code><a href="#topic+mad.test">mad.test</a></code>,
<code><a href="#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ns &lt;- if(interactive()) 19 else 4
  E &lt;- bits.envelope(swedishpines, Lest, nsim=ns)
  E
  plot(E)
  Eo &lt;- bits.envelope(swedishpines, Lest, alternative="less", nsim=ns)
  Ei &lt;- bits.envelope(swedishpines, Lest, interpolate=TRUE, nsim=ns)
</code></pre>

<hr>
<h2 id='bits.test'>
Balanced Independent Two-Stage Monte Carlo Test
</h2><span id='topic+bits.test'></span>

<h3>Description</h3>

<p>Performs a Balanced Independent Two-Stage Monte Carlo test
of goodness-of-fit for spatial pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bits.test(X, ...,
        exponent = 2, nsim=19, 
        alternative=c("two.sided", "less", "greater"),
        leaveout=1, interpolate = FALSE,
        savefuns=FALSE, savepatterns=FALSE,
        verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bits.test_+3A_x">X</code></td>
<td>

<p>Either a point pattern dataset (object of class <code>"ppp"</code>,
<code>"lpp"</code> or <code>"pp3"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"lppm"</code>
or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+dclf.test">dclf.test</a></code> or
<code><a href="#topic+mad.test">mad.test</a></code> or <code><a href="#topic+envelope">envelope</a></code> to
control the conduct of the test.
Useful arguments include <code>fun</code> to determine the summary
function, <code>rinterval</code> to determine the range of
<code class="reqn">r</code> values used in the test, 
and <code>use.theory</code> described under Details. 
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_exponent">exponent</code></td>
<td>

<p>Exponent used in the test statistic. Use <code>exponent=2</code>
for the Diggle-Cressie-Loosmore-Ford test, and <code>exponent=Inf</code>
for the Maximum Absolute Deviation test.
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_nsim">nsim</code></td>
<td>

<p>Number of replicates in each stage of the test.
A total of <code>nsim * (nsim + 1)</code> simulated point patterns will be
generated, and the <code class="reqn">p</code>-value will be a multiple of <code>1/(nsim+1)</code>.
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
The default (<code>alternative="two.sided"</code>) is that the
true value of the summary function is not equal to the theoretical
value postulated under the null hypothesis.
If <code>alternative="less"</code> the alternative hypothesis is that the
true value of the summary function is lower than the theoretical value.
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating whether to interpolate the distribution of
the test statistic by kernel smoothing, as described in
Dao and Genton (2014, Section 5).
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="bits.test_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the Balanced Independent Two-Stage Monte Carlo test
proposed by Baddeley et al (2017),
an improvement of the Dao-Genton (2014) test.
</p>
<p>If <code>X</code> is a point pattern, the null hypothesis is CSR.
</p>
<p>If <code>X</code> is a fitted model, the null hypothesis is that model.
</p>
<p>The argument <code>use.theory</code> passed to <code><a href="#topic+envelope">envelope</a></code>
determines whether to compare the summary function for the data
to its theoretical value for CSR (<code>use.theory=TRUE</code>)
or to the sample mean of simulations from CSR
(<code>use.theory=FALSE</code>).
</p>
<p>The argument <code>leaveout</code> specifies how to calculate the
discrepancy between the summary function for the data and the
nominal reference value, when the reference value must be estimated
by simulation. The values <code>leaveout=0</code> and
<code>leaveout=1</code> are both algebraically equivalent (Baddeley et al, 2014,
Appendix) to computing the difference <code>observed - reference</code>
where the <code>reference</code> is the mean of simulated values.
The value <code>leaveout=2</code> gives the leave-two-out discrepancy
proposed by Dao and Genton (2014).
</p>


<h3>Value</h3>

<p>A hypothesis test (object of class <code>"htest"</code>
which can be printed to show the outcome of the test.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>
<p>Baddeley, A., Diggle, P.J., Hardegen, A., Lawrence, T., Milne,
R.K. and Nair, G. (2014) On tests of spatial pattern based on
simulation envelopes. <em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2017)
On two-stage Monte Carlo tests of composite hypotheses.
<em>Computational Statistics and Data Analysis</em>
<b>114</b>, 75&ndash;87. 
</p>


<h3>See Also</h3>

<p>Simulation envelopes: <code><a href="#topic+bits.envelope">bits.envelope</a></code>.
</p>
<p>Other tests:
<code><a href="#topic+dg.test">dg.test</a></code>,
<code><a href="#topic+dclf.test">dclf.test</a></code>,
<code><a href="#topic+mad.test">mad.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ns &lt;- if(interactive()) 19 else 4
 bits.test(cells, nsim=ns)
 bits.test(cells, alternative="less", nsim=ns)
 bits.test(cells, nsim=ns, interpolate=TRUE)
</code></pre>

<hr>
<h2 id='blur'>Apply Gaussian Blur to a Pixel Image</h2><span id='topic+blur'></span><span id='topic+Smooth.im'></span>

<h3>Description</h3>

<p>Applies a Gaussian blur to a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blur(x, sigma = NULL, ...,
     kernel="gaussian", normalise=FALSE, bleed = TRUE, varcov=NULL)

## S3 method for class 'im'
Smooth(X, sigma = NULL, ...,
                    kernel="gaussian",
                    normalise=FALSE, bleed = TRUE, varcov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blur_+3A_x">x</code>, <code id="blur_+3A_x">X</code></td>
<td>
<p>The pixel image. An object of class <code>"im"</code>.</p>
</td></tr>
<tr><td><code id="blur_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of isotropic Gaussian smoothing kernel.
</p>
</td></tr>
<tr><td><code id="blur_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="blur_+3A_kernel">kernel</code></td>
<td>

<p>String (partially matched) specifying the smoothing kernel.
Current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>.
</p>
</td></tr>
<tr><td><code id="blur_+3A_normalise">normalise</code></td>
<td>

<p>Logical flag indicating whether the output values should be divided
by the corresponding blurred image of the window itself. See Details.
</p>
</td></tr>
<tr><td><code id="blur_+3A_bleed">bleed</code></td>
<td>

<p>Logical flag indicating whether to allow blur to extend outside the
original domain of the image. See Details.
</p>
</td></tr>
<tr><td><code id="blur_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic Gaussian kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command applies a Gaussian blur to the pixel image <code>x</code>.
</p>
<p><code>Smooth.im</code> is a method for the generic <code><a href="#topic+Smooth">Smooth</a></code>
for pixel images. It is currently identical to <code>blur</code>,
apart from the name of the first argument.
</p>
<p>The blurring kernel is the isotropic Gaussian kernel with standard
deviation <code>sigma</code>, or the anisotropic Gaussian kernel with
variance-covariance matrix <code>varcov</code>.
The arguments <code>sigma</code> and <code>varcov</code> are incompatible.
Also <code>sigma</code> may be a vector of length 2 giving the
standard deviations of two independent Gaussian coordinates,
thus equivalent to <code>varcov = diag(sigma^2)</code>.
</p>
<p>If the pixel values of <code>x</code> include some <code>NA</code> values
(meaning that the image domain does not completely fill
the rectangular frame) then these <code>NA</code> values are first reset to zero.
</p>
<p>The algorithm then computes the convolution <code class="reqn">x \ast G</code>
of the (zero-padded) pixel
image <code class="reqn">x</code> with the specified Gaussian kernel <code class="reqn">G</code>.
</p>
<p>If <code>normalise=FALSE</code>, then this convolution <code class="reqn">x\ast G</code>
is returned.
If <code>normalise=TRUE</code>, then the convolution <code class="reqn">x \ast G</code>
is normalised by
dividing it by the convolution <code class="reqn">w \ast G</code> of the image
domain <code>w</code>
with the same Gaussian kernel. Normalisation ensures that the result
can be interpreted as a weighted average of input pixel values,
without edge effects due to the shape of the domain.
</p>
<p>If <code>bleed=FALSE</code>, then pixel values outside the original image
domain are set to <code>NA</code>. Thus the output is a pixel image with the
same domain as the input. If <code>bleed=TRUE</code>, then no such
alteration is performed, and the result is a pixel image defined
everywhere in the rectangular frame containing the input image.
</p>
<p>Computation is performed using the Fast Fourier Transform.
</p>


<h3>Value</h3>

<p>A pixel image with the same pixel array as the input image <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>interp.im</code> for interpolating a pixel image to a finer resolution,
<code><a href="#topic+density.ppp">density.ppp</a></code> for blurring a point pattern,
<code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> for interpolating marks attached to points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Z &lt;- as.im(function(x,y) { 4 * x^2 + 3 * y }, letterR)
   opa &lt;- par(mfrow=c(1,3))
   plot(Z)
   plot(letterR, add=TRUE)
   plot(blur(Z, 0.3, bleed=TRUE))
   plot(letterR, add=TRUE)
   plot(blur(Z, 0.3, bleed=FALSE))
   plot(letterR, add=TRUE)
   par(opa)
</code></pre>

<hr>
<h2 id='boyce'>
Boyce Index
</h2><span id='topic+boyce'></span>

<h3>Description</h3>

<p>Calculate the discrete or continuous Boyce index for a spatial
point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boyce(X, Z, ..., breaks = NULL, halfwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boyce_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="boyce_+3A_z">Z</code></td>
<td>

<p>Habitat suitability classes or habitat suitability index.
Either a tessellation (object of class <code>"tess"</code>)
or a spatial covariate such as a pixel image (object of class
<code>"im"</code>), a <code>function(x,y)</code> or one of the letters
<code>"a", "b"</code> representing the cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="boyce_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+rhohat.ppp">rhohat.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="boyce_+3A_breaks">breaks</code></td>
<td>

<p>The breakpoint values defining discrete bands of values
of the covariate <code>Z</code> for which the discrete Boyce index will
be calculated. Either a numeric vector of breakpoints for <code>Z</code>,
or a single integer specifying the number of evenly-spaced
breakpoints.
Incompatible with <code>halfwidth</code>.
</p>
</td></tr>
<tr><td><code id="boyce_+3A_halfwidth">halfwidth</code></td>
<td>

<p>The half-width <code class="reqn">h</code> of the interval <code class="reqn">[z-h,z+h]</code> which will
be used to calculate the continuous Boyce index <code class="reqn">B(z)</code> for each
possible value <code class="reqn">z</code> of the covariate <code class="reqn">Z</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a spatial point pattern <code>X</code> and some kind of explanatory
information <code>Z</code>, this function computes either the
index originally defined by Boyce et al (2002)
or the &lsquo;continuous Boyce index&rsquo; defined by Hirzel et al (2006).
</p>
<p>Boyce et al (2002) defined an index of habitat suitability in which
the study region <code class="reqn">W</code> is first divided into separate subregions
<code class="reqn">C_1,\ldots,C_m</code> based on appropriate scientific
considerations. Then we count the number <code class="reqn">n_j</code> of data
points of <code>X</code> that fall in each subregion <code class="reqn">C_j</code>,
measure the area <code class="reqn">a_j</code> of each subregion <code class="reqn">C_j</code>,
and calculate the index
</p>
<p style="text-align: center;"><code class="reqn">
    B_j = \frac{n_j/n}{a_j/a}
  </code>
</p>

<p>where <code class="reqn">a</code> is the total area and <code class="reqn">n</code> is the total number of
points in <code>X</code>.
</p>
<p>Hirzel et al (2006) defined another version of this index which is
based on a continuous spatial covariate. For each possible value <code class="reqn">z</code>
of the covariate <code class="reqn">Z</code>, 
consider the region <code class="reqn">C(z)</code> where the value of the covariate
lies between <code class="reqn">z-h</code> and <code class="reqn">z+h</code>, where <code class="reqn">h</code> is the
chosen &lsquo;halfwidth&rsquo;. The &lsquo;continuous Boyce index&rsquo; is
</p>
<p style="text-align: center;"><code class="reqn">
    B(z) = \frac{n(z)/n}{a(z)/a}
  </code>
</p>

<p>where <code class="reqn">n(z)</code> is the number of points of <code>X</code>
falling in <code class="reqn">C(z)</code>, and <code class="reqn">a(z)</code> is  the area of <code class="reqn">C(z)</code>.
</p>
<p>If <code>Z</code> is a tessellation (object of class <code>"tess"</code>),
the algorithm calculates the original (&lsquo;discrete&rsquo;) Boyce index
(Boyce et al, 2002)
for each tile of the tessellation. The result is another tessellation,
identical to <code>Z</code> except that the mark values are the
values of the discrete Boyce index.
</p>
<p>If <code>Z</code> is a pixel image whose values are categorical (i.e. factor
values), then <code>Z</code> is treated as a tessellation, with one tile
for each level of the factor. The discrete Boyce index is then
calculated. The result is a tessellation with marks that are the
values of the discrete Boyce index.
</p>
<p>Otherwise, if <code>Z</code> is a spatial covariate such as a pixel image,
a <code>function(x,y)</code> or one of the characters <code>"x"</code> or
<code>"y"</code>, then exactly one of the arguments <code>breaks</code> or
<code>halfwidth</code> must be given. 
</p>

<ul>
<li><p> if <code>halfwidth</code> is given, it should be a single positive
number. The continuous Boyce index (Hirzel et al, 2006)
is computed using the specified halfwidth <code class="reqn">h</code>.
The result is an object of class <code>"fv"</code> that can be plotted
to show <code class="reqn">B(z)</code> as a function of <code class="reqn">z</code>.
</p>
</li>
<li><p> if <code>breaks</code> is given, it can be either a numeric vector
of possible values of <code>Z</code> defining the breakpoints for the
bands of values of <code>Z</code>, or a single integer specifying the
number of evenly-spaced breakpoints that should be created.
The discrete Boyce index (Boyce et al, 2002) is computed.
The result is an object of class <code>"fv"</code> that can be plotted
to show the discrete Boyce index as a function of <code class="reqn">z</code>.
</p>
</li></ul>

<p>When <code>Z</code> is a spatial covariate (not factor-valued), the calculation is performed
using <code><a href="#topic+rhohat.ppp">rhohat.ppp</a></code> (since the Boyce index is a special case
of <code>rhohat</code>). Arguments <code>...</code> passed to
<code><a href="#topic+rhohat.ppp">rhohat.ppp</a></code> control the accuracy of the spatial discretisation
and other parameters of the algorithm.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>)
or a function value table (object of class <code>"fv"</code>)
as explained above.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Boyce, M.S., Vernier, P.R., Nielsen, S.E. and Schmiegelow, F.K.A. (2002)
Evaluating resource selection functions.
<em>Ecological modelling</em> <b>157</b>, 281&ndash;300.
</p>
<p>Hirzel, A.H., Le Lay, V., Helfer, V., Randin, C. and Guisan, A. (2006)
Evaluating the ability of habitat suitability models
to predict species presences.
<em>Ecological Modelling</em> <b>199</b>, 142&ndash;152.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhohat">rhohat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  ## a simple tessellation
  V &lt;- quadrats(Window(bei), 4, 3)
  if(online) plot(V)

  ## discrete Boyce index for a simple tessellation
  A &lt;- boyce(bei, V)

  if(online) {
   plot(A, do.col=TRUE)
   marks(A)
   tilenames(A)
  }

  ## spatial covariate: terrain elevation
  Z &lt;- bei.extra$elev

  ## continuous Boyce index for terrain elevation
  BC &lt;- boyce(bei, Z, halfwidth=10)

  if(online) plot(BC)

  ## discrete Boyce index for terrain elevation steps of height 5 metres
  bk &lt;- c(seq(min(Z), max(Z), by=5), Inf)
  BD &lt;- boyce(bei, Z, breaks=bk)

  if(online) plot(BD)
</code></pre>

<hr>
<h2 id='bw.abram'>
Abramson's Adaptive Bandwidths
</h2><span id='topic+bw.abram'></span>

<h3>Description</h3>

<p>Computes adaptive smoothing bandwidths
according to the inverse-square-root rule of Abramson (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.abram(X, h0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.abram_+3A_x">X</code></td>
<td>

<p>Data to be smoothed.
</p>
</td></tr>
<tr><td><code id="bw.abram_+3A_h0">h0</code></td>
<td>

<p>Global smoothing bandwidth. A numeric value.
</p>
</td></tr>
<tr><td><code id="bw.abram_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes adaptive smoothing bandwidths for a dataset,
using the methods of Abramson (1982) and Hall and Marron (1988).
</p>
<p>The function <code>bw.abram</code> is generic. There is a method
<code><a href="#topic+bw.abram.ppp">bw.abram.ppp</a></code>
for spatial point patterns (objects of class <code>"ppp"</code>),
and possibly other methods.
</p>


<h3>Value</h3>

<p>See the documentation for the particular method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Abramson, I. (1982)
On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223. 
</p>
<p>Hall, P. and Marron, J.S. (1988)
Variable window width kernel density estimates of probability
densities.
<em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49. 
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.abram.ppp">bw.abram.ppp</a></code>
</p>

<hr>
<h2 id='bw.abram.ppp'>
Abramson's Adaptive Bandwidths For Spatial Point Pattern
</h2><span id='topic+bw.abram.ppp'></span>

<h3>Description</h3>

<p>Computes adaptive smoothing bandwidths for a spatial point pattern,
according to the inverse-square-root rule of Abramson (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
bw.abram(X, h0, 
         ...,
         at=c("points", "pixels"),
         hp = h0, pilot = NULL, trim=5, smoother=density.ppp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.abram.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
for which the variable bandwidths should be computed.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_h0">h0</code></td>
<td>

<p>A scalar value giving the global smoothing bandwidth
in the same units as the coordinates of <code>X</code>.
The default is <code>h0=<a href="#topic+bw.ppl">bw.ppl</a>(X)</code>.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="spatstat.geom.html#topic+as.im">as.im</a></code> to control the pixel resolution,
or passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or <code>smoother</code>
to control the type of smoothing, when computing the pilot estimate.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_at">at</code></td>
<td>

<p>Character string (partially matched) specifying whether
to compute bandwidth values at the points of <code>X</code>
(<code>at="points"</code>, the default) or to compute bandwidths
at every pixel in a fine pixel grid (<code>at="pixels"</code>).
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_hp">hp</code></td>
<td>

<p>Optional. A scalar pilot bandwidth, used for estimation
of the pilot density if required. Ignored if <code>pilot</code> is a pixel image
(object of class <code>"im"</code>); see below.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_pilot">pilot</code></td>
<td>

<p>Optional. Specification of a pilot density
(possibly unnormalised).
If <code>pilot=NULL</code> the pilot density
is computed by applying fixed-bandwidth density estimation to
<code>X</code> using bandwidth <code>hp</code>.
If <code>pilot</code> is a point pattern, the pilot density is 
is computed using a fixed-bandwidth estimate based
on <code>pilot</code> and <code>hp</code>.
If <code>pilot</code> is a pixel image (object of class <code>"im"</code>),
this is taken to be the (possibly unnormalised)
pilot density, and <code>hp</code> is ignored.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_trim">trim</code></td>
<td>

<p>A trimming value required to curb excessively large bandwidths.
See Details. The default is sensible in most cases.
</p>
</td></tr>
<tr><td><code id="bw.abram.ppp_+3A_smoother">smoother</code></td>
<td>

<p>Smoother for the pilot.
A function or character string, specifying the function
to be used to compute the pilot estimate when
<code>pilot</code> is <code>NULL</code> or is a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes adaptive smoothing bandwidths
using the methods of Abramson (1982) and Hall and Marron (1988).
</p>
<p>The function <code><a href="#topic+bw.abram">bw.abram</a></code> is generic. The function
<code>bw.abram.ppp</code> documented here is the method
for spatial point patterns (objects of class <code>"ppp"</code>).
</p>
<p>If <code>at="points"</code> (the default) a smoothing bandwidth is
computed for each point in the pattern <code>X</code>. Alternatively if
<code>at="pixels"</code> a smoothing bandwidth is computed for
each spatial location in a pixel grid.
</p>
<p>Under the Abramson-Hall-Marron rule, the bandwidth at location <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
    h(u) = \mbox{\texttt{h0}}
    * \mbox{min}[ \frac{\tilde{f}(u)^{-1/2}}{\gamma}, \mbox{\texttt{trim}} ]
  </code>
</p>

<p>where <code class="reqn">\tilde{f}(u)</code> is a pilot estimate of the spatially varying
probability density. The variable bandwidths are rescaled by <code class="reqn">\gamma</code>, the
geometric mean of the <code class="reqn">\tilde{f}(u)^{-1/2}</code> terms evaluated at the
data; this allows the global bandwidth <code>h0</code> to be considered on
the same scale as a corresponding fixed bandwidth. The trimming value
<code>trim</code> has the same interpretation as the required &lsquo;clipping&rsquo; of
the pilot density at some small nominal value (see Hall and Marron,
1988), to necessarily prevent extreme bandwidths (which
can occur at very isolated observations).
</p>
<p>The pilot density or intensity is determined as follows:
</p>

<ul>
<li><p> If <code>pilot</code> is a pixel image, this is taken as the
pilot density or intensity.
</p>
</li>
<li><p> If <code>pilot</code> is <code>NULL</code>, then the pilot intensity is
computed as a fixed-bandwidth kernel
intensity estimate using <code><a href="#topic+density.ppp">density.ppp</a></code> applied to
the data pattern <code>X</code> using
the pilot bandwidth <code>hp</code>.
</p>
</li>
<li>
<p>If <code>pilot</code> is a different point pattern on the same spatial
domain as <code>X</code>, then the pilot intensity is
computed as a fixed-bandwidth kernel
intensity estimate using <code><a href="#topic+density.ppp">density.ppp</a></code> applied to
<code>pilot</code> using the pilot bandwidth <code>hp</code>.
</p>
</li></ul>

<p>In each case the pilot density or intensity is renormalised to
become a probability density, and then the Abramson rule is applied.
</p>
<p>Instead of calculating the pilot as a fixed-bandwidth density
estimate, the user can specify another density estimation procedure
using the argument <code>smoother</code>. This should be either a function
or the character string name of a function. It will replace
<code><a href="#topic+density.ppp">density.ppp</a></code> as the function used to calculate the
pilot estimate. The pilot estimate will be computed as
<code>smoother(X, sigma=hp, ...)</code> if <code>pilot</code> is <code>NULL</code>,
or <code>smoother(pilot, sigma=hp, ...)</code> if <code>pilot</code> is a point
pattern. If <code>smoother</code> does not recognise the argument name
<code>sigma</code> for the smoothing bandwidth, then <code>hp</code> is effectively
ignored, as shown in the Examples.  
</p>


<h3>Value</h3>

<p>Either a numeric vector of length <code>npoints(X)</code>
giving the Abramson bandwidth for each point
(when <code>at = "points"</code>, the default),
or the entire pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age
of the Abramson bandwidths over the relevant spatial domain
(when <code>at = "pixels"</code>).
</p>


<h3>Author(s)</h3>

<p>Tilman Davies <a href="mailto:Tilman.Davies@otago.ac.nz">Tilman.Davies@otago.ac.nz</a>. Adapted by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Abramson, I. (1982)
On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223. 
</p>
<p>Davies, T.M. and Baddeley, A. (2018)
Fast computation of spatially adaptive kernel estimates.
<em>Statistics and Computing</em>, <b>28</b>(4), 937-956. 
</p>
<p>Davies, T.M., Marshall, J.C., and Hazelton, M.L. (2018)
Tutorial on kernel estimation of continuous spatial
and spatiotemporal relative risk.
<em>Statistics in Medicine</em>, <b>37</b>(7), 1191-1221. 
</p>
<p>Hall, P. and Marron, J.S. (1988)
Variable window width kernel density estimates of probability
densities.
<em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49. 
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.abram">bw.abram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 'ch' just 58 laryngeal cancer cases
ch &lt;- split(chorley)[[1]]

h &lt;- bw.abram(ch,h0=1,hp=0.7)
length(h)
summary(h)
if(interactive()) hist(h)

# calculate pilot based on all 1036 observations
h.pool &lt;- bw.abram(ch,h0=1,hp=0.7,pilot=chorley)
length(h.pool)
summary(h.pool)
if(interactive()) hist(h.pool)

# get full image used for 'h' above
him &lt;- bw.abram(ch,h0=1,hp=0.7,at="pixels")
plot(him);points(ch,col="grey")

# use Voronoi-Dirichlet pilot ('hp' is ignored)
hvo &lt;- bw.abram(ch, h0=1, smoother=densityVoronoi)
</code></pre>

<hr>
<h2 id='bw.CvL'>
Cronie and van Lieshout's Criterion for Bandwidth Selection for Kernel Density
</h2><span id='topic+bw.CvL'></span>

<h3>Description</h3>

<p>Uses Cronie and van Lieshout's criterion based on Cambell's formula to select
a smoothing bandwidth for the kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.CvL(X, ..., srange = NULL, ns = 16, sigma = NULL, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.CvL_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.CvL_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="bw.CvL_+3A_srange">srange</code></td>
<td>

<p>Optional numeric vector of length 2 giving the
range of values of bandwidth to be searched.
</p>
</td></tr>
<tr><td><code id="bw.CvL_+3A_ns">ns</code></td>
<td>

<p>Optional integer giving the number of values of
bandwidth to search.
</p>
</td></tr>
<tr><td><code id="bw.CvL_+3A_sigma">sigma</code></td>
<td>

<p>Optional. Vector of values of the bandwidth to be searched.
Overrides the values of <code>ns</code> and <code>srange</code>.
</p>
</td></tr>
<tr><td><code id="bw.CvL_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a warning is issued if the optimal value of the
cross-validation criterion occurs at one of the ends of the search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is chosen to 
minimise the discrepancy between the area of the observation window and the
sum of reciprocal estimated intensity values at the points of the point process
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{CvL}(\sigma) =
    (|W| - \sum_i 1/\hat\lambda(x_i))^2
  </code>
</p>

<p>where the sum is taken over all the data points <code class="reqn">x_i</code>,
and where <code class="reqn">\hat\lambda(x_i)</code> is the
kernel-smoothing estimate of the intensity at
<code class="reqn">x_i</code> with smoothing bandwidth <code class="reqn">\sigma</code>.
</p>
<p>The value of <code class="reqn">\mbox{CvL}(\sigma)</code> is computed
directly, using <code><a href="#topic+density.ppp">density.ppp</a></code>, 
for <code>ns</code> different values of <code class="reqn">\sigma</code>
between <code>srange[1]</code> and <code>srange[2]</code>.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Ottmar Cronie <a href="mailto:ottmar@chalmers.se">ottmar@chalmers.se</a>
and
Marie-Colette van Lieshout <a href="mailto:Marie-Colette.van.Lieshout@cwi.nl">Marie-Colette.van.Lieshout@cwi.nl</a>.
Adapted for <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Cronie, O and Van Lieshout, M N M (2018) A non-model-based approach to
bandwidth selection for kernel estimators of spatial intensity functions,
<em>Biometrika</em>, <b>105</b>, 455-462.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.optim.object">bw.optim.object</a></code>.
</p>
<p>Alternative methods:
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>,
<code><a href="#topic+bw.ppl">bw.ppl</a></code>,
<code><a href="#topic+bw.frac">bw.frac</a></code>.
</p>
<p>For adaptive smoothing bandwidths, use <code><a href="#topic+bw.CvL.adaptive">bw.CvL.adaptive</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    b &lt;- bw.CvL(redwood)
    b
    plot(b, main="Cronie and van Lieshout bandwidth criterion for redwoods")
    plot(density(redwood, b))
    plot(density(redwood, bw.CvL))
  }
  
</code></pre>

<hr>
<h2 id='bw.CvL.adaptive'>
Select Adaptive Bandwidth for Kernel Estimation
Using Cronie-Van Lieshout Criterion
</h2><span id='topic+bw.CvL.adaptive'></span>

<h3>Description</h3>

<p>Uses the  Cronie-Van Lieshout criterion to
select the global smoothing bandwidth
for adaptive kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.CvL.adaptive(X, ..., 
            hrange = NULL, nh = 16, h=NULL,
            bwPilot = bw.scott.iso(X),
            edge = FALSE, diggle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.CvL.adaptive_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_hrange">hrange</code></td>
<td>

<p>Optional numeric vector of length 2 giving the
range of values of global bandwidth <code>h</code> to be searched.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_nh">nh</code></td>
<td>

<p>Optional integer giving the number of values of
bandwidth <code>h</code> to search.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_h">h</code></td>
<td>

<p>Optional. Vector of values of the bandwidth to be searched.
Overrides the values of <code>nh</code> and <code>hrange</code>.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_bwpilot">bwPilot</code></td>
<td>

<p>Pilot bandwidth. A scalar value in the same units as the
coordinates of <code>X</code>. The smoothing bandwidth
for computing an initial estimate of intensity using
<code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="bw.CvL.adaptive_+3A_diggle">diggle</code></td>
<td>

<p>Logical. If <code>TRUE</code>, use the Jones-Diggle improved edge correction,
which is more accurate but slower to compute than the default
correction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate value of global bandwidth
<code>h0</code> for adaptive kernel estimation of the intensity function
for the point pattern <code>X</code>.
</p>
<p>In adaptive estimation, each point in the point pattern is
subjected to a different amount of smoothing, controlled by
data-dependent or spatially-varying bandwidths.
The global bandwidth <code>h0</code> is a scale factor
which is used to adjust all of the data-dependent bandwidths
according to the Abramson (1982) square-root rule.
</p>
<p>This function considers each candidate value of bandwidth <code class="reqn">h</code>,
performs the smoothing steps described above, extracts the
adaptively-estimated intensity values
<code class="reqn">\hat\lambda(x_i)</code> at each data point <code class="reqn">x_i</code>,  
and calculates the Cronie-Van Lieshout criterion
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{CvL}(h) = \sum_{i=1}^n \frac 1 {\hat\lambda(x_i)}.
  </code>
</p>

<p>The value of <code class="reqn">h</code> which minimises the squared difference
</p>
<p style="text-align: center;"><code class="reqn">
    LP2(h) = (CvL(h) - |W|)^2
  </code>
</p>

<p>(where <code>|W|</code> is the area of the window of <code>X</code>)
is selected as the optimal global bandwidth.
</p>
<p>Bandwidths <code>h</code> are physical distance values
expressed in the same units as the coordinates of <code>X</code>.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected global bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Marie-Colette Van Lieshout.
Modified by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Abramson, I. (1982)
On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223.<br />
</p>
<p>Cronie, O and Van Lieshout, M N M (2018) A non-model-based approach to
bandwidth selection for kernel estimators of spatial intensity functions,
<em>Biometrika</em>, <b>105</b>, 455-462.
</p>
<p>Van Lieshout, M.N.M. (2021)
Infill asymptotics for adaptive kernel estimators of spatial intensity.
<em>Australian and New Zealand Journal of Statistics</em>
<b>63</b> (1) 159&ndash;181.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.optim.object">bw.optim.object</a></code>.
</p>
<p><code><a href="#topic+adaptive.density">adaptive.density</a></code>,
<code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code>,
<code><a href="#topic+bw.abram">bw.abram</a></code>,
<code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>To select a <em>fixed</em> smoothing bandwidth
using the Cronie-Van Lieshout criterion, use <code><a href="#topic+bw.CvL">bw.CvL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(online) {
    h0 &lt;- bw.CvL.adaptive(redwood3)
  } else {
    ## faster computation for package checker
    h0 &lt;- bw.CvL.adaptive(redwood3, nh=8,
                          hrange=c(1/4, 4) * bw.diggle(redwood3))
  }
  plot(h0)
  plot(as.fv(h0), CvL ~ h)
  if(online) {
    Z &lt;- densityAdaptiveKernel(redwood3, h0)
    plot(Z)
  }
</code></pre>

<hr>
<h2 id='bw.CvLHeat'>
Bandwidth Selection for Diffusion Smoother by Cronie-van Lieshout Rule
</h2><span id='topic+bw.CvLHeat'></span>

<h3>Description</h3>

<p>Selects an optimal bandwidth for diffusion smoothing
using the Cronie-van Lieshout rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.CvLHeat(X, ..., srange=NULL, ns=16, sigma=NULL,
         leaveoneout=TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.CvLHeat_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_srange">srange</code></td>
<td>

<p>Numeric vector of length 2 specifying a range of bandwidths to be
considered.
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_ns">ns</code></td>
<td>

<p>Integer. Number of candidate bandwidths to be considered.
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_sigma">sigma</code></td>
<td>

<p>Maximum smoothing bandwidth.
A numeric value, or a pixel image, or a <code>function(x,y)</code>.
Alternatively a numeric vector containing a sequence of
candidate bandwidths.
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether intensity values at data points
should be estimated using the leave-one-out rule.
</p>
</td></tr>
<tr><td><code id="bw.CvLHeat_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm selects the optimal global bandwidth for
kernel estimation of intensity for the dataset <code>X</code>
using diffusion smoothing <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>.
</p>
<p>If <code>sigma</code> is a numeric value, the algorithm finds the
optimal bandwidth <code>tau &lt;= sigma</code>.
</p>
<p>If <code>sigma</code> is a pixel image or function, the algorithm
finds the optimal fraction <code>0 &lt; f &lt;= 1</code> such that
smoothing with <code>f * sigma</code> would be optimal.
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth
(if <code>sigma</code> was a numeric value)
or the selected fraction of the maximum bandwidth
(if <code>sigma</code> was a pixel image or function).
The result also belongs to the class <code>"bw.optim"</code> which can be
plotted. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.pplHeat">bw.pplHeat</a></code> for an alternative method.
</p>
<p><code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(!online) op &lt;- spatstat.options(npixel=32)
  f &lt;- function(x,y) { dnorm(x, 2.3, 0.1) * dnorm(y, 2.0, 0.2) }
  X &lt;- rpoint(15, f, win=letterR)
  plot(X)
  b &lt;- bw.CvLHeat(X, sigma=0.25)
  b
  plot(b)
  if(!online) spatstat.options(op)
</code></pre>

<hr>
<h2 id='bw.diggle'>
Cross Validated Bandwidth Selection for Kernel Density
</h2><span id='topic+bw.diggle'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for the kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.diggle(X, ..., correction="good", hmax=NULL, nr=512, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.diggle_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.diggle_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="bw.diggle_+3A_correction">correction</code></td>
<td>

<p>Character string passed to <code><a href="#topic+Kest">Kest</a></code>
determining the edge correction to be used to
calculate the <code class="reqn">K</code> function.
</p>
</td></tr>
<tr><td><code id="bw.diggle_+3A_hmax">hmax</code></td>
<td>

<p>Numeric. Maximum value of bandwidth that should be considered.
</p>
</td></tr>
<tr><td><code id="bw.diggle_+3A_nr">nr</code></td>
<td>

<p>Integer. Number of steps in the distance value <code class="reqn">r</code> to use in computing
numerical integrals. 
</p>
</td></tr>
<tr><td><code id="bw.diggle_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the minimum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is chosen to 
minimise the mean-square error criterion defined by Diggle (1985).
The algorithm uses the method of Berman and Diggle (1989) to
compute the quantity
</p>
<p style="text-align: center;"><code class="reqn">
    M(\sigma) = \frac{\mbox{MSE}(\sigma)}{\lambda^2} - g(0)
  </code>
</p>

<p>as a function of bandwidth <code class="reqn">\sigma</code>,
where <code class="reqn">\mbox{MSE}(\sigma)</code> is the
mean squared error at bandwidth <code class="reqn">\sigma</code>,
while <code class="reqn">\lambda</code> is the mean intensity,
and <code class="reqn">g</code> is the pair correlation function. 
See Diggle (2003, pages 115-118) for a summary of this method.
</p>
<p>The result is a numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted to show the (rescaled) mean-square error
as a function of <code>sigma</code>.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Definition of bandwidth</h3>

<p>The smoothing parameter <code>sigma</code> returned by <code>bw.diggle</code>
(and displayed on the horizontal axis of the plot)
corresponds to <code>h/2</code>, where <code>h</code> is the smoothing
parameter described in Diggle (2003, pages 116-118) and
Berman and Diggle (1989).
In those references, the smoothing kernel 
is the uniform density on the disc of radius <code>h</code>. In
<code><a href="#topic+density.ppp">density.ppp</a></code>, the smoothing kernel is the
isotropic Gaussian density with standard deviation <code>sigma</code>.
When replacing one kernel by another, the usual
practice is to adjust the bandwidths so that the kernels have equal
variance (cf. Diggle 2003, page 118). This implies that <code>sigma = h/2</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Berman, M. and Diggle, P. (1989)
Estimating weighted integrals of the
second-order intensity of a spatial point process.
<em>Journal of the Royal Statistical Society, series B</em>
<b>51</b>, 81&ndash;92.
</p>
<p>Diggle, P.J. (1985)
A kernel method for smoothing point process data.
<em>Applied Statistics</em> (Journal of the Royal Statistical Society,
Series C) <b>34</b> (1985) 138&ndash;147.
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.optim.object">bw.optim.object</a></code>.
</p>
<p>Alternative methods:
<code><a href="#topic+bw.ppl">bw.ppl</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.frac">bw.frac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  attach(split(lansing))
  b &lt;- bw.diggle(hickory)
  plot(b, ylim=c(-2, 0), main="Cross validation for hickories")
  if(interactive()) {
   plot(density(hickory, b))
  }
</code></pre>

<hr>
<h2 id='bw.frac'>
Bandwidth Selection Based on Window Geometry
</h2><span id='topic+bw.frac'></span>

<h3>Description</h3>

<p>Select a smoothing bandwidth for smoothing a point pattern,
based only on the geometry of the spatial window.
The bandwidth is a specified quantile of the distance
between two independent random points in the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.frac(X, ..., f=1/4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.frac_+3A_x">X</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) or
point pattern (object of class <code>"ppp"</code>)
or other data which can be converted to a window
using <code>as.owin</code>.
</p>
</td></tr>
<tr><td><code id="bw.frac_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+distcdf">distcdf</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.frac_+3A_f">f</code></td>
<td>

<p>Probability value (between 0 and 1)
determining the quantile of the distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is computed as a 
quantile of the distance between two independent random points
in the window. The default is the lower quartile of this
distribution.
</p>
<p>If <code class="reqn">F(r)</code> is the cumulative distribution function of the
distance between two independent random points uniformly distributed
in the window, then the value returned is the quantile
with probability <code class="reqn">f</code>. That is, the bandwidth is 
the value <code class="reqn">r</code> such that <code class="reqn">F(r) = f</code>.
</p>
<p>The cumulative distribution function  <code class="reqn">F(r)</code> is
computed using <code><a href="#topic+distcdf">distcdf</a></code>. We then
we compute the smallest number <code class="reqn">r</code>
such that <code class="reqn">F(r) \ge f</code>.
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.frac"</code>
which can be plotted to show the cumulative distribution function
and the selected quantile.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>For estimating point process intensity, see
<code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.ppl">bw.ppl</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>.
</p>
<p>For other smoothing purposes, see
<code><a href="#topic+bw.stoyan">bw.stoyan</a></code>,
<code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code>,
<code><a href="#topic+bw.relrisk">bw.relrisk</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  h &lt;- bw.frac(letterR)
  h
  plot(h, main="bw.frac(letterR)")
</code></pre>

<hr>
<h2 id='bw.optim.object'>Class of Optimized Bandwidths</h2><span id='topic+bw.optim.object'></span>

<h3>Description</h3>

<p>An object of the class <code>"bw.optim"</code> represents
a tuning parameter (usually a smoothing bandwidth)
that has been selected automatically.
The object can be used as if it were a numerical value,
but it can also be plotted to show the optimality criterion.
</p>


<h3>Details</h3>

<p>An object of the class <code>"bw.optim"</code> represents the numerical
value of a smoothing bandwidth, a threshold, or a similar
tuning parameter, that has been selected by optimising 
a criterion such as cross-validation.
</p>
<p>The object is a numerical value, with some attributes that retain
information about how the value was selected.
</p>
<p>Attributes include the vector of candidate values that were examined,
the corresponding values of the optimality criterion, the name of the
parameter, the name of the optimality criterion, and the units in
which the parameter is measured.
</p>
<p>There are methods for <code>print</code>, <code>plot</code>,
<code>summary</code>, <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> and <code><a href="#topic+as.fv">as.fv</a></code>
for the class <code>"bw.optim"</code>.
</p>
<p>The <code>print</code> method simply prints the numerical value of the
parameter.
The <code>summary</code> method prints this value, and states how
this value was selected.
</p>
<p>The <code>plot</code> method produces a plot of the optimisation criterion
against the candidate value of the parameter. The <code>as.data.frame</code>
and <code>as.fv</code> methods extract this graphical information as a data
frame or function table, respectively.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Functions which produce objects of class <code>bw.optim</code> include
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.CvL.adaptive">bw.CvL.adaptive</a></code>,
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="spatstat.linnet.html#topic+bw.lppl">bw.lppl</a></code>,
<code><a href="#topic+bw.pcf">bw.pcf</a></code>,
<code><a href="#topic+bw.ppl">bw.ppl</a></code>,
<code><a href="#topic+bw.relrisk">bw.relrisk</a></code>,
<code><a href="spatstat.linnet.html#topic+bw.relrisk.lpp">bw.relrisk.lpp</a></code>,
<code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code>
and
<code><a href="spatstat.linnet.html#topic+bw.voronoi">bw.voronoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Ns &lt;- if(interactive()) 32 else 3
  b &lt;- bw.ppl(redwood, srange=c(0.02, 0.07), ns=Ns)
  b
  summary(b)
  plot(b)
</code></pre>

<hr>
<h2 id='bw.pcf'>
Cross Validated Bandwidth Selection for Pair Correlation Function
</h2><span id='topic+bw.pcf'></span>

<h3>Description</h3>

<p>Uses composite likelihood or generalized least squares 
cross-validation to select a smoothing bandwidth
for the kernel estimation of pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bw.pcf(X, rmax=NULL, lambda=NULL, divisor="r", 
         kernel="epanechnikov", nr=10000, bias.correct=TRUE, 
         cv.method=c("compLik", "leastSQ"), simple=TRUE, srange=NULL,
	 ..., verbose=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.pcf_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_rmax">rmax</code></td>
<td>

<p>Numeric. Maximum value of the spatial lag distance <code class="reqn">r</code> 
for which <code class="reqn">g(r)</code> should be evaluated.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
A vector giving the intensity values
at the points of the pattern <code>X</code>.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>. 
See <code>pcf.ppp</code>.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel, passed to <code>density</code>; 
see <code><a href="#topic+pcf">pcf</a></code> and <code><a href="#topic+pcfinhom">pcfinhom</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_nr">nr</code></td>
<td>

<p>Integer. Number of subintervals for discretization of 
[0, rmax] to use in computing numerical integrals.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_bias.correct">bias.correct</code></td>
<td>

<p>Logical. Whether to use bias corrected version of the kernel 
estimate. See Details.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_cv.method">cv.method</code></td>
<td>

<p>Choice of cross validation method: either
<code>"compLik"</code> or <code>"leastSQ"</code> (partially matched).
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_simple">simple</code></td>
<td>

<p>Logical. Whether to use simple removal of spatial lag 
distances. See Details.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_srange">srange</code></td>
<td>

<p>Optional. Numeric vector of length 2 giving the range of
bandwidth values that should be searched to find the optimum
bandwidth.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_...">...</code></td>
<td>

<p>Other arguments, passed to <code><a href="#topic+pcf">pcf</a></code> or 
<code><a href="#topic+pcfinhom">pcfinhom</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports
during the optimization procedure.
</p>
</td></tr>
<tr><td><code id="bw.pcf_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the optimum value of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>bw</code>
for the kernel estimator of the pair correlation function 
of a point process intensity computed by <code><a href="#topic+pcf.ppp">pcf.ppp</a></code> 
(homogeneous case) or <code><a href="#topic+pcfinhom">pcfinhom</a></code> 
(inhomogeneous case).
</p>
<p>With <code>cv.method="leastSQ"</code>, the bandwidth 
<code class="reqn">h</code> is chosen to minimise an unbiased 
estimate of the integrated mean-square error criterion 
<code class="reqn">M(h)</code> defined in equation (4) in Guan (2007a).
The code implements the fast algorithm of Jalilian and Waagepetersen
(2018).
</p>
<p>With <code>cv.method="compLik"</code>, the bandwidth 
<code class="reqn">h</code> is chosen to maximise a likelihood 
cross-validation criterion <code class="reqn">CV(h)</code> defined in 
equation (6) of Guan (2007b).
</p>
<p style="text-align: center;"><code class="reqn">
    M(b) = \frac{\mbox{MSE}(\sigma)}{\lambda^2} - g(0)
  </code>
</p>

<p>The result is a numerical value giving the selected bandwidth.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Definition of bandwidth</h3>

<p>The bandwidth <code>bw</code> returned by <code>bw.pcf</code>
is the standard deviation of the smoothing kernel,
following the standard convention in <span class="rlang"><b>R</b></span>.
As mentioned in the documentation for
<code><a href="stats.html#topic+density.default">density.default</a></code> and <code><a href="#topic+pcf.ppp">pcf.ppp</a></code>, 
this differs from other definitions of bandwidth that can be
found in the literature. The scale parameter
<code>h</code>, which is called the bandwidth in some literature,
is defined differently.
For example for the Epanechnikov kernel, <code>h</code> is the half-width
of the kernel, and <code>bw=h/sqrt(5)</code>.
</p>


<h3>Author(s)</h3>

<p>Rasmus Waagepetersen and Abdollah Jalilian. 
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Guan, Y. (2007a). 
A composite likelihood cross-validation approach in selecting 
bandwidth for the estimation of the pair correlation function. 
<em>Scandinavian Journal of Statistics</em>, 
<b>34</b>(2), 336&ndash;346.
</p>
<p>Guan, Y. (2007b). 
A least-squares cross-validation bandwidth selection approach 
in pair correlation function estimations. 
<em>Statistics &amp; Probability Letters</em>, 
<b>77</b>(18), 1722&ndash;1729.
</p>
<p>Jalilian, A. and Waagepetersen, R. (2018)
Fast bandwidth selection for estimation of the pair correlation
function.
<em>Journal of Statistical Computation and Simulation</em>,
<b>88</b>(10), 2001&ndash;2011.
<a href="https://www.tandfonline.com/doi/full/10.1080/00949655.2018.1428606">https://www.tandfonline.com/doi/full/10.1080/00949655.2018.1428606</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf.ppp">pcf.ppp</a></code>,
<code><a href="#topic+pcfinhom">pcfinhom</a></code>,
<code><a href="#topic+bw.optim.object">bw.optim.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  b &lt;- bw.pcf(redwood)
  plot(pcf(redwood, bw=b))
</code></pre>

<hr>
<h2 id='bw.ppl'>
Likelihood Cross Validation Bandwidth Selection for Kernel Density
</h2><span id='topic+bw.ppl'></span>

<h3>Description</h3>

<p>Uses likelihood cross-validation to select a smoothing bandwidth
for the kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.ppl(X, ..., srange=NULL, ns=16, sigma=NULL, varcov1=NULL,
          weights=NULL, shortcut=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.ppl_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_srange">srange</code></td>
<td>

<p>Optional numeric vector of length 2 giving the
range of values of bandwidth to be searched.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_ns">ns</code></td>
<td>

<p>Optional integer giving the number of values of
bandwidth to search.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_sigma">sigma</code></td>
<td>

<p>Optional. Vector of values of the bandwidth to be searched.
Overrides the values of <code>ns</code> and <code>srange</code>.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_varcov1">varcov1</code></td>
<td>

<p>Optional. Variance-covariance matrix matrix of the kernel with
bandwidth <code class="reqn">h=1</code>. See section on Anisotropic Smoothing.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of weights for the points of <code>X</code>.
Argument passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_shortcut">shortcut</code></td>
<td>

<p>Logical value indicating whether to speed up the calculation
by omitting the integral term in the cross-validation criterion.
</p>
</td></tr>
<tr><td><code id="bw.ppl_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the maximum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is chosen to 
maximise the point process likelihood cross-validation criterion
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{LCV}(\sigma) =
    \sum_i \log\hat\lambda_{-i}(x_i) - \int_W \hat\lambda(u) \, {\rm d}u
  </code>
</p>

<p>where the sum is taken over all the data points <code class="reqn">x_i</code>,
where <code class="reqn">\hat\lambda_{-i}(x_i)</code> is the
leave-one-out kernel-smoothing estimate of the intensity at
<code class="reqn">x_i</code> with smoothing bandwidth <code class="reqn">\sigma</code>,
and <code class="reqn">\hat\lambda(u)</code> is the kernel-smoothing estimate
of the intensity at a spatial location <code class="reqn">u</code> with smoothing
bandwidth <code class="reqn">\sigma</code>.
See Loader(1999, Section 5.3).
</p>
<p>The value of <code class="reqn">\mbox{LCV}(\sigma)</code> is computed
directly, using <code><a href="#topic+density.ppp">density.ppp</a></code>, 
for <code>ns</code> different values of <code class="reqn">\sigma</code>
between <code>srange[1]</code> and <code>srange[2]</code>.
</p>
<p>The result is a numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted to show the (rescaled) mean-square error
as a function of <code>sigma</code>.
</p>
<p>If <code>shortcut=TRUE</code>, the computation is accelerated by
omitting the integral term in the equation above. This is valid
because the integral is approximately constant.
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted.
</p>


<h3>Anisotropic Smoothing</h3>

<p>Anisotropic kernel smoothing is available in <code><a href="#topic+density.ppp">density.ppp</a></code> using
the argument <code>varcov</code> to specify the variance-covariance
matrix of the anisotropic kernel. In order to choose the matrix
<code>varcov</code>, the user can call <code>bw.ppl</code> 
using the argument <code>varcov1</code> to specify a &lsquo;template&rsquo;
matrix. Scalar multiples of <code>varcov1</code> will be
considered and the optimal scale factor will be determined.
That is, <code>bw.ppl</code> will try 
smoothing the data using <code>varcov = h^2 * varcov1</code> for different
values of <code>h</code>.
The result of <code>bw.ppl</code> will be the optimal value of <code>h</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Loader, C. (1999)
<em>Local Regression and Likelihood</em>.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.frac">bw.frac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    b &lt;- bw.ppl(redwood)
    plot(b, main="Likelihood cross validation for redwoods")
    plot(density(redwood, b))
  }
  
</code></pre>

<hr>
<h2 id='bw.pplHeat'>
Bandwidth Selection for Diffusion Smoother by Likelihood Cross-Validation
</h2><span id='topic+bw.pplHeat'></span>

<h3>Description</h3>

<p>Selects an optimal bandwidth for diffusion smoothing
by point process likelihood cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.pplHeat(X, ..., srange=NULL, ns=16, sigma=NULL,
         leaveoneout=TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.pplHeat_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_srange">srange</code></td>
<td>

<p>Numeric vector of length 2 specifying a range of bandwidths to be
considered.
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_ns">ns</code></td>
<td>

<p>Integer. Number of candidate bandwidths to be considered.
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_sigma">sigma</code></td>
<td>

<p>Maximum smoothing bandwidth.
A numeric value, or a pixel image, or a <code>function(x,y)</code>.
Alternatively a numeric vector containing a sequence of
candidate bandwidths.
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether intensity values at data points
should be estimated using the leave-one-out rule.
</p>
</td></tr>
<tr><td><code id="bw.pplHeat_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm selects the optimal global bandwidth for
kernel estimation of intensity for the dataset <code>X</code>
using diffusion smoothing <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>.
</p>
<p>If <code>sigma</code> is a numeric value, the algorithm finds the
optimal bandwidth <code>tau &lt;= sigma</code>.
</p>
<p>If <code>sigma</code> is a pixel image or function, the algorithm
finds the optimal fraction <code>0 &lt; f &lt;= 1</code> such that
smoothing with <code>f * sigma</code> would be optimal.
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth
(if <code>sigma</code> was a numeric value)
or the selected fraction of the maximum bandwidth
(if <code>sigma</code> was a pixel image or function).
The result also belongs to the class <code>"bw.optim"</code> which can be
plotted. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley and Tilman Davies.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.CvLHeat">bw.CvLHeat</a></code> for an alternative method.
</p>
<p><code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(!online) op &lt;- spatstat.options(npixel=32)
  f &lt;- function(x,y) { dnorm(x, 2.3, 0.1) * dnorm(y, 2.0, 0.2) }
  X &lt;- rpoint(15, f, win=letterR)
  plot(X)
  b &lt;- bw.pplHeat(X, sigma=0.25)
  b
  plot(b)
  if(!online) spatstat.options(op)
</code></pre>

<hr>
<h2 id='bw.relrisk'>
Cross Validated Bandwidth Selection for Relative Risk Estimation
</h2><span id='topic+bw.relrisk'></span><span id='topic+bw.relrisk.ppp'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for the estimation of relative risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.relrisk(X, ...)

   ## S3 method for class 'ppp'
bw.relrisk(X, method = "likelihood", ...,
           nh = spatstat.options("n.bandwidth"),
           hmin=NULL, hmax=NULL, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.relrisk_+3A_x">X</code></td>
<td>

<p>A multitype point pattern (object of class <code>"ppp"</code>
which has factor valued marks).
</p>
</td></tr>
<tr><td><code id="bw.relrisk_+3A_method">method</code></td>
<td>

<p>Character string determining the cross-validation method.
Current options are <code>"likelihood"</code>,
<code>"leastsquares"</code> or
<code>"weightedleastsquares"</code>.
</p>
</td></tr>
<tr><td><code id="bw.relrisk_+3A_nh">nh</code></td>
<td>

<p>Number of trial values of smoothing bandwith <code>sigma</code>
to consider. The default is 32.
</p>
</td></tr>
<tr><td><code id="bw.relrisk_+3A_hmin">hmin</code>, <code id="bw.relrisk_+3A_hmax">hmax</code></td>
<td>

<p>Optional. Numeric values.
Range of trial values of smoothing bandwith <code>sigma</code>
to consider. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="bw.relrisk_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the minimum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
<tr><td><code id="bw.relrisk_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code>
or to other methods for <code>bw.relrisk</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth for the nonparametric
estimation of relative risk using <code><a href="#topic+relrisk">relrisk</a></code>.
</p>
<p>Consider the indicators <code class="reqn">y_{ij}</code> which equal <code class="reqn">1</code> when
data point <code class="reqn">x_i</code> belongs to type <code class="reqn">j</code>, and equal <code class="reqn">0</code>
otherwise.
For a particular value of smoothing bandwidth,
let <code class="reqn">\hat p_j(u)</code> be the estimated
probabilities that a point at location <code class="reqn">u</code> will belong to
type <code class="reqn">j</code>. 
Then the bandwidth is chosen to minimise either the negative likelihood,
the squared error, or the approximately standardised squared error, of the
indicators <code class="reqn">y_{ij}</code> relative to the fitted
values  <code class="reqn">\hat p_j(x_i)</code>. See Diggle (2003)
or Baddeley et al (2015).
</p>
<p>The result is a numerical value giving the selected bandwidth <code>sigma</code>.
The result also belongs to the class <code>"bw.optim"</code>
allowing it to be printed and plotted. The plot shows the cross-validation
criterion as a function of bandwidth.  
</p>
<p>The range of values for the smoothing bandwidth <code>sigma</code>
is set by the arguments <code>hmin, hmax</code>. There is a sensible default,
based on multiples of Stoyan's rule of thumb <code><a href="#topic+bw.stoyan">bw.stoyan</a></code>.
</p>
<p>If the optimal bandwidth is achieved at an endpoint of the
interval <code>[hmin, hmax]</code>, the algorithm will issue a warning
(unless <code>warn=FALSE</code>). If this occurs, then it is probably advisable
to expand the interval by changing the arguments <code>hmin, hmax</code>.
</p>
<p>Computation time depends on the number <code>nh</code> of trial values
considered, and also on the range <code>[hmin, hmax]</code> of values
considered, because larger values of <code>sigma</code> require
calculations involving more pairs of data points.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995)
Kernel estimation of relative risk.
<em>Bernoulli</em> <b>1</b>, 3&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relrisk">relrisk</a></code>,
<code><a href="#topic+bw.stoyan">bw.stoyan</a></code>.
</p>
<p><code><a href="#topic+bw.optim.object">bw.optim.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  b &lt;- bw.relrisk(urkiola)
  b
  plot(b)
  b &lt;- bw.relrisk(urkiola, hmax=20)
  plot(b)
  
</code></pre>

<hr>
<h2 id='bw.scott'>
Scott's Rule for Bandwidth Selection for Kernel Density
</h2><span id='topic+bw.scott'></span><span id='topic+bw.scott.iso'></span>

<h3>Description</h3>

<p>Use Scott's rule of thumb to determine the smoothing bandwidth
for the kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.scott(X, isotropic=FALSE, d=NULL)

   bw.scott.iso(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.scott_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>,
<code>"lpp"</code>, <code>"pp3"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="bw.scott_+3A_isotropic">isotropic</code></td>
<td>

<p>Logical value indicating whether to compute a single
bandwidth for an isotropic Gaussian kernel (<code>isotropic=TRUE</code>)
or separate bandwidths for each coordinate axis
(<code>isotropic=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="bw.scott_+3A_d">d</code></td>
<td>

<p>Advanced use only.
An integer value that should be used in Scott's formula
instead of the true number of spatial dimensions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions select a bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>
or other appropriate functions.
They can be applied to a point pattern
belonging to any class <code>"ppp"</code>, <code>"lpp"</code>, <code>"pp3"</code>
or <code>"ppx"</code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is computed by the rule of thumb
of Scott (1992, page 152, equation 6.42). 
The bandwidth is proportional to <code class="reqn">n^{-1/(d+4)}</code>
where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the number of
spatial dimensions.
</p>
<p>This rule is very fast to compute. It typically produces a larger bandwidth
than <code><a href="#topic+bw.diggle">bw.diggle</a></code>. It is useful for estimating
gradual trend.
</p>
<p>If <code>isotropic=FALSE</code> (the default), <code>bw.scott</code> provides a
separate bandwidth for each coordinate axis, and the result of the
function is a vector, of length equal to the number of coordinates.
If <code>isotropic=TRUE</code>, a single bandwidth value is computed
and the result is a single numeric value.
</p>
<p><code>bw.scott.iso(X)</code> is equivalent to
<code>bw.scott(X, isotropic=TRUE)</code>.
</p>
<p>The default value of <code class="reqn">d</code> is as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>class</b> </td><td style="text-align: left;"> <b>dimension</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"ppp"</code> </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"lpp"</code> </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"pp3"</code> </td><td style="text-align: left;"> 3 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"ppx"</code> </td><td style="text-align: left;"> number of spatial coordinates
  </td>
</tr>

</table>

<p>The use of <code>d=1</code> for point patterns on a linear network
(class <code>"lpp"</code>) was proposed by McSwiggan et al (2016)
and Rakshit et al (2019).
</p>


<h3>Value</h3>

<p>A numerical value giving the selected
bandwidth, or a numerical vector giving the
selected bandwidths for each coordinate.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Scott, D.W. (1992)
<em>Multivariate Density Estimation. Theory, Practice and
Visualization</em>. 
New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.ppl">bw.ppl</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.frac">bw.frac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  hickory &lt;- split(lansing)[["hickory"]]
  b &lt;- bw.scott(hickory)
  b
  if(interactive()) {
   plot(density(hickory, b))
  }
  bw.scott.iso(hickory)
  bw.scott(osteo$pts[[1]])
</code></pre>

<hr>
<h2 id='bw.smoothppp'>
Cross Validated Bandwidth Selection for Spatial Smoothing
</h2><span id='topic+bw.smoothppp'></span>

<h3>Description</h3>

<p>Uses least-squares cross-validation to select a smoothing bandwidth
for spatial smoothing of marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.smoothppp(X, nh = spatstat.options("n.bandwidth"),
                hmin=NULL, hmax=NULL, warn=TRUE, kernel="gaussian",
                varcov1=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.smoothppp_+3A_x">X</code></td>
<td>

<p>A marked point pattern with numeric marks.
</p>
</td></tr>
<tr><td><code id="bw.smoothppp_+3A_nh">nh</code></td>
<td>

<p>Number of trial values of smoothing bandwith <code>sigma</code>
to consider. The default is 32.
</p>
</td></tr>
<tr><td><code id="bw.smoothppp_+3A_hmin">hmin</code>, <code id="bw.smoothppp_+3A_hmax">hmax</code></td>
<td>

<p>Optional. Numeric values.
Range of trial values of smoothing bandwith <code>sigma</code>
to consider. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="bw.smoothppp_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the minimum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
<tr><td><code id="bw.smoothppp_+3A_kernel">kernel</code></td>
<td>

<p>The smoothing kernel.
A character string specifying the smoothing kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>).
</p>
</td></tr>
<tr><td><code id="bw.smoothppp_+3A_varcov1">varcov1</code></td>
<td>

<p>Optional. Variance-covariance matrix matrix of the kernel with
bandwidth <code class="reqn">h=1</code>. See section on Anisotropic Smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth for the nonparametric
smoothing of mark values using <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
<p>The argument <code>X</code> must be a marked point pattern
with a vector or data frame of marks. All mark values must be numeric.
</p>
<p>The bandwidth is selected by least-squares cross-validation.
Let <code class="reqn">y_i</code> be the mark value at the <code class="reqn">i</code>th data point.
For a particular choice of smoothing bandwidth,
let <code class="reqn">\hat y_i</code> be the smoothed value at the <code class="reqn">i</code>th data point.
Then the bandwidth is chosen to minimise 
the squared error of the smoothed values
<code class="reqn">\sum_i (y_i - \hat y_i)^2</code>.
</p>
<p>The result of <code>bw.smoothppp</code>
is a numerical value giving the selected bandwidth <code>sigma</code>.
The result also belongs to the class <code>"bw.optim"</code>
allowing it to be printed and plotted. The plot shows the cross-validation
criterion as a function of bandwidth.  
</p>
<p>The range of values for the smoothing bandwidth <code>sigma</code>
is set by the arguments <code>hmin, hmax</code>. There is a sensible default,
based on the nearest neighbour distances.
</p>
<p>If the optimal bandwidth is achieved at an endpoint of the
interval <code>[hmin, hmax]</code>, the algorithm will issue a warning
(unless <code>warn=FALSE</code>). If this occurs, then it is probably advisable
to expand the interval by changing the arguments <code>hmin, hmax</code>.
</p>
<p>Computation time depends on the number <code>nh</code> of trial values
considered, and also on the range <code>[hmin, hmax]</code> of values
considered, because larger values of <code>sigma</code> require
calculations involving more pairs of data points.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Anisotropic Smoothing</h3>

<p>Anisotropic smoothing is available in <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> using
the argument <code>varcov</code> to specify the variance-covariance
matrix of the anisotropic kernel. In order to choose the matrix
<code>varcov</code>, the user can call <code>bw.smoothppp</code> 
using the argument <code>varcov1</code> to specify a &lsquo;template&rsquo;
matrix. Scalar multiples of <code>varcov1</code> will be
considered and the optimal scale factor will be determined.
That is, <code>bw.smoothppp</code> will try 
smoothing the data using <code>varcov = h^2 * varcov1</code> for different
values of <code>h</code> ranging from <code>hmin</code> to <code>hmax</code>. 
The result of <code>bw.smoothppp</code> will be the optimal value
of the standard deviation scale factor <code>h</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>,
<code><a href="#topic+bw.optim.object">bw.optim.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  b &lt;- bw.smoothppp(longleaf)
  b
  plot(b)
  
</code></pre>

<hr>
<h2 id='bw.stoyan'>
Stoyan's Rule of Thumb for Bandwidth Selection
</h2><span id='topic+bw.stoyan'></span>

<h3>Description</h3>

<p>Computes a rough estimate of the appropriate bandwidth
for kernel smoothing estimators of the pair correlation function
and other quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.stoyan(X, co=0.15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.stoyan_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.stoyan_+3A_co">co</code></td>
<td>

<p>Coefficient appearing in the rule of thumb. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the pair correlation function and other quantities
by smoothing methods requires a choice of the smoothing bandwidth.
Stoyan and Stoyan (1995, equation (15.16), page 285) proposed a
rule of thumb for choosing the smoothing bandwidth.
</p>
<p>For the Epanechnikov kernel, the rule of thumb is to set
the kernel's half-width <code class="reqn">h</code> to
<code class="reqn">0.15/\sqrt{\lambda}</code> where
<code class="reqn">\lambda</code> is the estimated intensity of the point pattern,
typically computed as the number of points of <code>X</code> divided by the
area of the window containing <code>X</code>.
</p>
<p>For a general kernel, the corresponding rule is to set the
standard deviation of the kernel to
<code class="reqn">\sigma = 0.15/\sqrt{5\lambda}</code>.
</p>
<p>The coefficient <code class="reqn">0.15</code> can be tweaked using the
argument <code>co</code>.
</p>
<p>To ensure the bandwidth is finite, an empty point pattern is treated
as if it contained 1 point.
</p>


<h3>Value</h3>

<p>A finite positive numerical value giving the selected bandwidth (the standard
deviation of the smoothing kernel).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1995)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf">pcf</a></code>,
<code><a href="#topic+bw.relrisk">bw.relrisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bw.stoyan(shapley)
</code></pre>

<hr>
<h2 id='CDF'>
Cumulative Distribution Function From Kernel Density Estimate
</h2><span id='topic+CDF'></span><span id='topic+CDF.density'></span>

<h3>Description</h3>

<p>Given a kernel estimate of a probability density,
compute the corresponding cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDF(f, ...)

## S3 method for class 'density'
CDF(f, ..., warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDF_+3A_f">f</code></td>
<td>

<p>Density estimate (object of class <code>"density"</code>).
</p>
</td></tr>
<tr><td><code id="CDF_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="CDF_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
density estimate <code>f</code> had to be renormalised because it
was computed in a restricted interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CDF</code> is generic, with a method for class <code>"density"</code>.
</p>
<p>This calculates the cumulative distribution function
whose probability density has been estimated and stored in the object
<code>f</code>. The object <code>f</code> must belong to the class <code>"density"</code>,
and would typically have been obtained from a call to the function
<code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Value</h3>

<p>A function, which can be applied to any numeric value or vector of
values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>,
<code><a href="#topic+quantile.density">quantile.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   b &lt;- density(runif(10))
   f &lt;- CDF(b)
   f(0.5)
   plot(f)
</code></pre>

<hr>
<h2 id='cdf.test'>Spatial Distribution Test for Point Pattern or Point Process Model</h2><span id='topic+cdf.test'></span><span id='topic+cdf.test.ppp'></span>

<h3>Description</h3>

<p>Performs a test of goodness-of-fit of a point process model.
The observed and predicted distributions
of the values of a spatial covariate are compared using either the
Kolmogorov-Smirnov test,
Cramer-von Mises test
or Anderson-Darling test.
For non-Poisson models, a Monte Carlo test is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf.test(...)

## S3 method for class 'ppp'
cdf.test(X, covariate, test=c("ks", "cvm", "ad"), ...,
                       interpolate=TRUE, jitter=TRUE)



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.test_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="cdf.test_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
A function, a pixel image (object of class <code>"im"</code>),
a list of pixel images, or one of the characters
<code>"x"</code> or <code>"y"</code> indicating the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="cdf.test_+3A_test">test</code></td>
<td>

<p>Character string identifying the test to be performed:
<code>"ks"</code> for Kolmogorov-Smirnov test,
<code>"cvm"</code> for Cramer-von Mises test
or <code>"ad"</code> for Anderson-Darling test.
</p>
</td></tr>
<tr><td><code id="cdf.test_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+ks.test">ks.test</a></code>
(from the <span class="pkg">stats</span> package) or 
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code><a href="goftest.html#topic+ad.test">ad.test</a></code> (from the <span class="pkg">goftest</span> package)
to control the test;
and arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
</td></tr>
<tr><td><code id="cdf.test_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical flag indicating whether to interpolate pixel images.
If <code>interpolate=TRUE</code>, the value of the covariate
at each point of <code>X</code> will be approximated by interpolating
the nearby pixel values.
If <code>interpolate=FALSE</code>, the nearest pixel value will be used.
</p>
</td></tr>
<tr><td><code id="cdf.test_+3A_jitter">jitter</code></td>
<td>

<p>Logical flag. If <code>jitter=TRUE</code>, values of the covariate
will be slightly perturbed at random, to avoid tied values in the test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson or Gibbs point
process model fitted to point pattern data. The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using the Kolmogorov-Smirnov test,
the Cramer-von Mises test
or the Anderson-Darling test. For Gibbs models, a Monte Carlo test is
performed using these test statistics.
</p>
<p>The function <code>cdf.test</code> is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>),
point process models (<code>"ppm"</code> or <code>"lppm"</code>)
and spatial logistic regression models (<code>"slrm"</code>).
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern dataset (object of class
<code>"ppp"</code>), then <code>cdf.test(X, ...)</code>
performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
For a multitype point pattern, the uniform intensity
is assumed to depend on the type of point (sometimes called
Complete Spatial Randomness and Independence, CSRI).
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model
(object of class <code>"ppm"</code> or <code>"lppm"</code>)
then <code>cdf.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. 
</p>
</li>
<li>
<p>If <code>model</code> is a fitted spatial logistic regression
(object of class <code>"slrm"</code>) then <code>cdf.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. 
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model,
using a classical goodness-of-fit test.
Thus, you must nominate
a spatial covariate for this test.
</p>
<p>If <code>X</code> is a point pattern that does not have marks,
the argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> containing the values
of a spatial function, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.
</p>
<p>If <code>X</code> is a multitype point pattern, the argument <code>covariate</code>
can be either a <code>function(x,y,marks)</code>,
or a pixel image, or a list of pixel images corresponding to
each possible mark value, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates. 
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected. 
</p>
<p>The predicted distribution of the values of the <code>covariate</code>
under the fitted <code>model</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window are evaluated,
weighted according to the point process intensity of the fitted model,
and compiled into a cumulative distribution function <code class="reqn">F</code> using
<code>ewcdf</code>.
</p>
<p>The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers. The
A goodness-of-fit test of the uniform distribution is applied
to these numbers using <code>stats::<a href="stats.html#topic+ks.test">ks.test</a></code>,
<code>goftest::<a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code>goftest::<a href="goftest.html#topic+ad.test">ad.test</a></code>.
</p>
<p>This test was apparently first described (in the context of
spatial data, and using Kolmogorov-Smirnov) by Berman (1986).
See also Baddeley et al (2005).
</p>
<p>If <code>model</code> is not a Poisson process, then
a Monte Carlo test is performed, by generating <code>nsim</code>
point patterns which are simulated realisations of the <code>model</code>,
re-fitting the model to each simulated point pattern, 
and calculating the test statistic for each fitted model.
The Monte Carlo <code class="reqn">p</code> value is determined by comparing
the simulated values of the test statistic 
with the value for the original data.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>
<p>The return value also belongs to the class <code>"cdftest"</code>
for which there is a plot method <code><a href="#topic+plot.cdftest">plot.cdftest</a></code>.
The plot method displays the empirical cumulative distribution
function of the covariate at the data points, and the predicted
cumulative distribution function of the covariate under the model,
plotted against the value of the covariate.
</p>
<p>The argument <code>jitter</code> controls whether covariate values are
randomly perturbed, in order to avoid ties.
If the original data contains any ties in the covariate (i.e. points
with equal values of the covariate), and if <code>jitter=FALSE</code>, then 
the Kolmogorov-Smirnov test implemented in <code><a href="stats.html#topic+ks.test">ks.test</a></code>
will issue a warning that it cannot calculate the exact <code class="reqn">p</code>-value.
To avoid this, if <code>jitter=TRUE</code> each value of the covariate will
be perturbed by adding a small random value. The perturbations are
normally distributed with standard deviation equal to one hundredth of
the range of values of the covariate. This prevents ties, 
and the <code class="reqn">p</code>-value is still correct. There is
a very slight loss of power.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> containing the results of the
test. See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for details. The return value can be
printed to give an informative summary of the test.
</p>
<p>The value also belongs to the class <code>"cdftest"</code> for which there is
a plot method.
</p>


<h3>Warning</h3>

<p>The outcome of the test involves a small amount of random variability,
because (by default) the coordinates are randomly perturbed to
avoid tied values. Hence, if <code>cdf.test</code> is executed twice, the
<code class="reqn">p</code>-values will not be exactly the same. To avoid this behaviour,
set <code>jitter=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R.,
Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cdftest">plot.cdftest</a></code>,
<code><a href="#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="#topic+berman.test">berman.test</a></code>,
<code><a href="stats.html#topic+ks.test">ks.test</a></code>,
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code>,
<code><a href="goftest.html#topic+ad.test">ad.test</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   op &lt;- options(useFancyQuotes=FALSE)

   # test of CSR using x coordinate
   cdf.test(nztrees, "x")
   cdf.test(nztrees, "x", "cvm")
   cdf.test(nztrees, "x", "ad")

   # test of CSR using a function of x and y
   fun &lt;- function(x,y){2* x + y}
   cdf.test(nztrees, fun)

   # test of CSR using an image covariate
   funimage &lt;- as.im(fun, W=Window(nztrees))
   cdf.test(nztrees, funimage)


   # multitype point pattern
   cdf.test(amacrine, "x")

   options(op)
</code></pre>

<hr>
<h2 id='circdensity'>
Density Estimation for Circular Data
</h2><span id='topic+circdensity'></span>

<h3>Description</h3>

<p>Computes a kernel smoothed estimate of the probability density
for angular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circdensity(x, sigma = "nrd0", ...,
               bw = NULL,
               weights=NULL, unit = c("degree", "radian"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circdensity_+3A_x">x</code></td>
<td>

<p>Numeric vector, containing angular data.
</p>
</td></tr>
<tr><td><code id="circdensity_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth, or bandwidth selection rule, passed to
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="circdensity_+3A_bw">bw</code></td>
<td>
<p>Alternative to <code>sigma</code> for consistency with other functions.</p>
</td></tr>
<tr><td><code id="circdensity_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="stats.html#topic+density.default">density.default</a></code>,
such as <code>kernel</code> and <code>weights</code>.
</p>
</td></tr>
<tr><td><code id="circdensity_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights for the data in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="circdensity_+3A_unit">unit</code></td>
<td>

<p>The unit of angle in which <code>x</code> is expressed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The angular values <code>x</code> are smoothed using
(by default) the wrapped Gaussian kernel with standard deviation <code>sigma</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"density"</code> (produced by
<code><a href="stats.html#topic+density.default">density.default</a></code>) which can be plotted
by <code>plot</code> or by <code><a href="#topic+rose">rose</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>),
<code><a href="#topic+rose">rose</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ang &lt;- runif(1000, max=360)
  rose(circdensity(ang, 12))
</code></pre>

<hr>
<h2 id='clarkevans'>Clark and Evans Aggregation Index</h2><span id='topic+clarkevans'></span>

<h3>Description</h3>

<p>Computes the Clark and Evans aggregation index
<code class="reqn">R</code> for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clarkevans(X, correction=c("none", "Donnelly", "cdf"),
              clipregion=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clarkevans_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="clarkevans_+3A_correction">correction</code></td>
<td>

<p>Character vector.
The type of edge correction(s) to be applied.
</p>
</td></tr>
<tr><td><code id="clarkevans_+3A_clipregion">clipregion</code></td>
<td>

<p>Clipping region for the guard area correction.
A window (object of class <code>"owin"</code>).
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Clark and Evans (1954) aggregation index <code class="reqn">R</code> is a crude
measure of clustering or ordering of a point pattern.
It is the ratio of the observed mean nearest neighbour distance
in the pattern to that expected for a Poisson point process
of the same intensity.
A value <code class="reqn">R&gt;1</code> suggests ordering, while <code class="reqn">R&lt;1</code> suggests
clustering.
</p>
<p>Without correction for edge effects, the value of <code>R</code> will be
positively biased. Edge effects arise because, for a point of <code>X</code>
close to the edge of the window, the true nearest neighbour may
actually lie outside the window. Hence observed nearest neighbour
distances tend to be larger than the true nearest neighbour distances.
</p>
<p>The argument <code>correction</code> specifies an edge correction
or several edge corrections to be applied. It is a character vector
containing one or more of the options
<code>"none"</code>, <code>"Donnelly"</code>, <code>"guard"</code> and <code>"cdf"</code>
(which are recognised by partial matching).
These edge corrections are:
</p>

<dl>
<dt>&quot;none&quot;:</dt><dd>
<p>No edge correction is applied. 
</p>
</dd>
<dt>&quot;Donnelly&quot;:</dt><dd>
<p>Edge correction of Donnelly (1978), available for rectangular
windows only.
The theoretical expected value of mean nearest neighbour distance
under a Poisson process is adjusted for edge effects by the 
edge correction of Donnelly (1978). The value of <code class="reqn">R</code> is the
ratio of the observed mean nearest neighbour distance to this
adjusted theoretical mean.
</p>
</dd>
<dt>&quot;guard&quot;:</dt><dd>
<p>Guard region or buffer area method.
The observed mean nearest neighbour distance
for the point pattern <code>X</code>
is re-defined by averaging only over those points of <code>X</code>
that fall inside the sub-window <code>clipregion</code>.
</p>
</dd>
<dt>&quot;cdf&quot;:</dt><dd>
<p>Cumulative Distribution Function method.
The nearest neighbour distance distribution function <code class="reqn">G(r)</code>
of the stationary point process is estimated by <code><a href="#topic+Gest">Gest</a></code>
using the Kaplan-Meier type edge correction. Then the mean of the
distribution is calculated from the cdf. 
</p>
</dd>
</dl>

<p>Alternatively <code>correction="all"</code> selects all options.
</p>
<p>If the argument <code>clipregion</code> is given, then the selected
edge corrections will be assumed to include <code>correction="guard"</code>.
</p>
<p>To perform a test based on the Clark-Evans index,
see <code><a href="#topic+clarkevans.test">clarkevans.test</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value, or a numeric vector with named components
</p>
<table>
<tr><td><code>naive</code></td>
<td>
<p><code class="reqn">R</code> without edge correction</p>
</td></tr>
<tr><td><code>Donnelly</code></td>
<td>
<p><code class="reqn">R</code> using Donnelly edge correction</p>
</td></tr>
<tr><td><code>guard</code></td>
<td>
<p><code class="reqn">R</code> using guard region</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p><code class="reqn">R</code> using cdf method</p>
</td></tr>
</table>
<p>(as selected by <code>correction</code>). The value of the <code>Donnelly</code>
component will be <code>NA</code> if the window of <code>X</code> is not a rectangle.
</p>


<h3>Author(s)</h3>

<p>John Rudge
<a href="mailto:rudge@esc.cam.ac.uk">rudge@esc.cam.ac.uk</a>
with modifications by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Clark, P.J. and Evans, F.C. (1954)
Distance to nearest neighbour as a measure of spatial
relationships in populations <em>Ecology</em> <b>35</b>,
445&ndash;453.
</p>
<p>Donnelly, K. (1978) Simulations to determine the variance
and edge-effect of total nearest neighbour distance.
In I. Hodder (ed.) <em>Simulation studies in archaeology</em>,
Cambridge/New York: Cambridge University Press, pp 91&ndash;95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clarkevans.test">clarkevans.test</a></code>,
<code><a href="#topic+hopskel">hopskel</a></code>,
<code>nndist</code>,
<code><a href="#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example of a clustered pattern
  clarkevans(redwood)

  # Example of an ordered pattern
  clarkevans(cells)

  # Random pattern
  X &lt;- rpoispp(100)
  clarkevans(X)

  # How to specify a clipping region
  clip1 &lt;- owin(c(0.1,0.9),c(0.1,0.9))
  clip2 &lt;- erosion(Window(cells), 0.1)
  clarkevans(cells, clipregion=clip1)
  clarkevans(cells, clipregion=clip2)
</code></pre>

<hr>
<h2 id='clarkevans.test'>Clark and Evans Test</h2><span id='topic+clarkevans.test'></span>

<h3>Description</h3>

<p>Performs the Clark-Evans test of aggregation
for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clarkevans.test(X, ...,
               correction,
               clipregion=NULL,
               alternative=c("two.sided", "less", "greater",
                             "clustered", "regular"),
               method=c("asymptotic", "MonteCarlo"),
               nsim=999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clarkevans.test_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_correction">correction</code></td>
<td>

<p>Character string.
The type of edge correction to be applied.
See <code><a href="#topic+clarkevans">clarkevans</a></code> and Details below.
</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_clipregion">clipregion</code></td>
<td>

<p>Clipping region for the guard area correction.
A window (object of class <code>"owin"</code>).
See <code><a href="#topic+clarkevans">clarkevans</a></code>
</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_alternative">alternative</code></td>
<td>

<p>String indicating the type of alternative for the
hypothesis test. Partially matched.
</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_method">method</code></td>
<td>

<p>Character string (partially matched) specifying how to calculate
the <code class="reqn">p</code>-value of the test. See Details.
</p>
</td></tr>
<tr><td><code id="clarkevans.test_+3A_nsim">nsim</code></td>
<td>

<p>Number of Monte Carlo simulations to perform, if a Monte Carlo
<code class="reqn">p</code>-value is required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command uses the Clark and Evans (1954) aggregation index <code class="reqn">R</code>
as the basis for a crude test of clustering or ordering of a point pattern.
</p>
<p>The Clark-Evans <em>aggregation index</em> <code class="reqn">R</code> is computed by the separate
function <code><a href="#topic+clarkevans">clarkevans</a></code>.
</p>
<p>This command <code>clarkevans.text</code>
performs a hypothesis test of clustering or ordering of
the point pattern <code>X</code> based on the Clark-Evans index <code class="reqn">R</code>.
The null hypothesis is Complete
Spatial Randomness, i.e.\ a uniform Poisson process. The alternative
hypothesis is specified by the argument <code>alternative</code>:
</p>

<ul>
<li> <p><code>alternative="less"</code> or <code>alternative="clustered"</code>:
the alternative hypothesis
is that <code class="reqn">R &lt; 1</code> corresponding to a clustered point pattern;
</p>
</li>
<li> <p><code>alternative="greater"</code> or <code>alternative="regular"</code>:
the alternative hypothesis
is that <code class="reqn">R &gt; 1</code> corresponding to a regular or ordered point pattern;
</p>
</li>
<li> <p><code>alternative="two.sided"</code>:
the alternative hypothesis is that <code class="reqn">R \neq 1</code>
corresponding to a clustered or regular pattern.
</p>
</li></ul>

<p>The Clark-Evans index <code class="reqn">R</code> is first computed for the point pattern
dataset <code>X</code> using the edge correction determined by
the arguments <code>correction</code> and <code>clipregion</code>. These arguments
are documented in the help file for <code><a href="#topic+clarkevans">clarkevans</a></code>.
</p>
<p>If <code>method="asymptotic"</code> (the default),
the <code class="reqn">p</code>-value for the test is computed by standardising
<code class="reqn">R</code> as proposed by Clark and Evans (1954) and referring the
standardised statistic to the standard Normal distribution. 
For this asymptotic test, the default edge correction is
<code>correction="Donnelly"</code> if the window of <code>X</code> is a rectangle,
and <code>correction="cdf"</code> otherwise. It is strongly recommended
to avoid using <code>correction="none"</code> which would lead to a severely
biased test.
</p>
<p>If <code>method="MonteCarlo"</code>, the <code class="reqn">p</code>-value for the test is computed
by comparing the observed value of <code class="reqn">R</code> to the
results obtained from <code>nsim</code> simulated realisations of
Complete Spatial Randomness conditional on the
observed number of points. This test is theoretically exact
for any choice of edge correction, but may have lower power
than the asymptotic test.
For this Monte Carlo test, the default edge correction
is <code>correction="none"</code> for computational efficiency.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> representing the result of the test.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Clark, P.J. and Evans, F.C. (1954)
Distance to nearest neighbour as a measure of spatial
relationships in populations. <em>Ecology</em> <b>35</b>,
445&ndash;453.
</p>
<p>Donnelly, K. (1978) Simulations to determine the variance
and edge-effect of total nearest neighbour distance.
In <em>Simulation methods in archaeology</em>,
Cambridge University Press, pp 91&ndash;95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clarkevans">clarkevans</a></code>,
<code><a href="#topic+hopskel.test">hopskel.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Redwood data - clustered
  clarkevans.test(redwood)
  clarkevans.test(redwood, alternative="clustered")
  clarkevans.test(redwood, correction="cdf", method="MonteCarlo", nsim=39)
</code></pre>

<hr>
<h2 id='clusterset'>
Allard-Fraley Estimator of Cluster Feature
</h2><span id='topic+clusterset'></span>

<h3>Description</h3>

<p>Detect high-density features in a spatial point pattern
using the (unrestricted) Allard-Fraley estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clusterset(X, what=c("marks", "domain"),
            ..., verbose=TRUE,
            fast=FALSE,
            exact=!fast)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterset_+3A_x">X</code></td>
<td>

<p>A dimensional spatial point pattern (object of class
<code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="clusterset_+3A_what">what</code></td>
<td>

<p>Character string or character vector
specifying the type of result. See Details.
</p>
</td></tr>
<tr><td><code id="clusterset_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="clusterset_+3A_fast">fast</code></td>
<td>

<p>Logical. If <code>FALSE</code> (the default), the Dirichlet tile areas
will be computed exactly using polygonal geometry, so that the
optimal choice of tiles will be computed exactly.
If <code>TRUE</code>, the Dirichlet tile areas
will be approximated using pixel counting, so the optimal
choice will be approximate.
</p>
</td></tr>
<tr><td><code id="clusterset_+3A_exact">exact</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the Allard-Fraley estimator
of the domain will be computed exactly using polygonal geometry.
If <code>FALSE</code>, the Allard-Fraley estimator of the domain
will be approximated by a binary pixel mask.
The default is initially set to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="clusterset_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to control the
pixel resolution if <code>exact=FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allard and Fraley (1997) developed a technique for recognising
features of high density in a spatial point pattern in the presence of
random clutter.
</p>
<p>This algorithm computes the <em>unrestricted</em> Allard-Fraley estimator.
The Dirichlet (Voronoi) tessellation of the point pattern <code>X</code> is
computed. The smallest <code>m</code> Dirichlet cells are selected,
where the number <code>m</code> is determined by a maximum likelihood
criterion.
</p>

<ul>
<li> 
<p>If <code>fast=FALSE</code> (the default), the areas of the tiles
of the Dirichlet tessellation will be computed exactly
using polygonal geometry. This ensures that the optimal selection of
tiles is computed exactly.
</p>
</li>
<li>
<p>If <code>fast=TRUE</code>, the Dirichlet tile areas
will be approximated by counting pixels.
This is faster, and is usually correct (depending on the pixel
resolution, which is controlled by the arguments <code>...</code>).
</p>
</li></ul>

<p>The type of result depends on the character vector <code>what</code>.
</p>

<ul>
<li>
<p>If <code>what="marks"</code> the result is the point pattern <code>X</code>
with a vector of marks labelling each point with a value <code>yes</code> or
<code>no</code> depending on whether the corresponding Dirichlet cell is
selected by the Allard-Fraley estimator. In other words each point of
<code>X</code> is labelled as either a cluster point or a non-cluster point.
</p>
</li>
<li> 
<p>If <code>what="domain"</code>, the result is the Allard-Fraley estimator
of the cluster feature set, which is the union of all the
selected Dirichlet cells, represented as a window (object of class
<code>"owin"</code>).
</p>
</li>
<li>
<p>If <code>what=c("marks", "domain")</code> the result is a list
containing both of the results described above.
</p>
</li></ul>

<p>Computation of the Allard-Fraley set estimator depends on
the argument <code>exact</code>.
</p>

<ul>
<li>
<p>If <code>exact=TRUE</code> (the default), the Allard-Fraley set estimator
will be computed exactly using polygonal geometry.
The result is a polygonal window.
</p>
</li>
<li>
<p>If <code>exact=FALSE</code>, the Allard-Fraley set estimator
will be approximated by a binary pixel mask.
This is faster than the exact computation.
The result is a binary mask.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>what="marks"</code>, a multitype point pattern (object of class
<code>"ppp"</code>).
</p>
<p>If  <code>what="domain"</code>, a window (object of class
<code>"owin"</code>).
</p>
<p>If  <code>what=c("marks", "domain")</code> (the default),
a list consisting of a multitype point pattern and a window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Allard, D. and Fraley, C. (1997) 
Nonparametric maximum likelihood estimation of features in
spatial point processes using Voronoi tessellation.
<em>Journal of the American Statistical Association</em>
<b>92</b>, 1485&ndash;1493.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnclean">nnclean</a></code>, 
<code><a href="#topic+sharpen">sharpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mfrow=c(1,2))
  W &lt;- grow.rectangle(as.rectangle(letterR), 1)
  X &lt;- superimpose(runifpoint(300, letterR),
                   runifpoint(50, W), W=W)
  plot(W, main="clusterset(X, 'm')")
  plot(clusterset(X, "marks", fast=TRUE), add=TRUE, chars=c(1, 3), cols=1:2)
  plot(letterR, add=TRUE)
  plot(W, main="clusterset(X, 'd')")
  plot(clusterset(X, "domain", exact=FALSE), add=TRUE)
  plot(letterR, add=TRUE)
  par(opa)
</code></pre>

<hr>
<h2 id='collapse.fv'>
Collapse Several Function Tables into One
</h2><span id='topic+collapse.fv'></span><span id='topic+collapse.anylist'></span>

<h3>Description</h3>

<p>Combines several function tables (objects of class <code>"fv"</code>)
into a single function table, merging columns that are identical
and relabelling columns that are different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
collapse(object, ..., same = NULL, different = NULL)

## S3 method for class 'anylist'
collapse(object, ..., same = NULL, different = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.fv_+3A_object">object</code></td>
<td>

<p>An object of class <code>"fv"</code>, or a list of such objects.
</p>
</td></tr>
<tr><td><code id="collapse.fv_+3A_...">...</code></td>
<td>

<p>Additional objects of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="collapse.fv_+3A_same">same</code></td>
<td>

<p>Character string or character vector specifying a column or columns
of function values that are identical in different <code>"fv"</code>
objects. These columns will be included only once in the result.
</p>
</td></tr>
<tr><td><code id="collapse.fv_+3A_different">different</code></td>
<td>

<p>Character string or character vector specifying a column or columns
of function values, that are different in different <code>"fv"</code> objects.
Each of these columns of data will be included, with
labels that distinguish them from each other.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="nlme.html#topic+collapse">collapse</a></code>.
</p>
<p>It combines the data in several function tables 
(objects of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>)
to make a single function table.
It is essentially a smart wrapper for
<code><a href="#topic+cbind.fv">cbind.fv</a></code>.
</p>
<p>A typical application is to calculate the same summary statistic
(such as the <code class="reqn">K</code> function) for different point patterns,
and then to use <code>collapse.fv</code> to combine the results into a
single object that can easily be plotted. See the Examples.
</p>
<p>The arguments <code>object</code> and <code>...</code> should be function tables
(objects of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>)
that are compatible in the sense that they
have the same values of the function argument.
(This can be ensured by applying <code><a href="#topic+harmonise.fv">harmonise.fv</a></code> to them.)
</p>
<p>The argument <code>same</code> identifies any columns that are present
in some or all of the function tables, and 
which are known to contain exactly the same values in each table
that includes them. This column or columns will be
included only once in the result.
</p>
<p>The argument <code>different</code> identifies any columns that are present
in some or all of the function tables, and which may contain
different numerical values in different tables.
Each of these columns will be included, with labels
to distinguish them. 
</p>
<p>Columns that are not named in <code>same</code> or <code>different</code> will not
be included.
</p>
<p>The function argument is always included and does not need to be
specified.
</p>
<p>The arguments <code>same</code> and <code>different</code> can be <code>NULL</code>,
or they can be character vectors containing the names
of columns of <code>object</code>. The argument <code>different</code> can be
one of the abbreviations recognised by <code><a href="#topic+fvnames">fvnames</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+cbind.fv">cbind.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate simulated data
  X &lt;- replicate(3, rpoispp(100), simplify=FALSE)
  names(X) &lt;- paste("Simulation", 1:3)
  # compute K function estimates
  Klist &lt;- anylapply(X, Kest)
  # collapse
  K &lt;- collapse(Klist, same="theo", different="iso")
  K
</code></pre>

<hr>
<h2 id='compatible.fasp'>Test Whether Function Arrays Are Compatible</h2><span id='topic+compatible.fasp'></span>

<h3>Description</h3>

<p>Tests whether two or more function arrays (class <code>"fasp"</code>)
are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fasp'
compatible(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible.fasp_+3A_a">A</code>, <code id="compatible.fasp_+3A_b">B</code>, <code id="compatible.fasp_+3A_...">...</code></td>
<td>
<p>Two or more function arrays (object of class <code>"fasp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"fasp"</code> can be regarded as an array
of functions. Such objects are returned by the
command <code><a href="#topic+alltypes">alltypes</a></code>.
</p>
<p>This command tests whether such objects are compatible
(so that, for example, they could be added or subtracted).
It is a method for the generic command <code>compatible</code>.
</p>
<p>The function arrays are compatible if the arrays have the same dimensions,
and the corresponding elements in each cell of the array
are compatible as defined by <code><a href="#topic+compatible.fv">compatible.fv</a></code>.
</p>


<h3>Value</h3>

<p>Logical value: <code>TRUE</code> if the objects are compatible, and <code>FALSE</code>
if they are not.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fasp">eval.fasp</a></code>
</p>

<hr>
<h2 id='compatible.fv'>Test Whether Function Objects Are Compatible</h2><span id='topic+compatible.fv'></span>

<h3>Description</h3>

<p>Tests whether two or more function objects (class <code>"fv"</code>)
are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fv'
compatible(A, B, ..., samenames=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible.fv_+3A_a">A</code>, <code id="compatible.fv_+3A_b">B</code>, <code id="compatible.fv_+3A_...">...</code></td>
<td>
<p>Two or more function value objects (class
<code>"fv"</code>).</p>
</td></tr>
<tr><td><code id="compatible.fv_+3A_samenames">samenames</code></td>
<td>

<p>Logical value indicating whether to check for complete agreement
between the column names of the objects (<code>samenames=TRUE</code>, the
default) or just to check that the name of the function argument
is the same (<code>samenames=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"fv"</code> is essentially a data frame
containing several different statistical estimates of the same
function. Such objects are returned by <code><a href="#topic+Kest">Kest</a></code> and its
relatives.
</p>
<p>This command tests whether such objects are compatible
(so that, for example, they could be added or subtracted).
It is a method for the generic command <code>compatible</code>.
</p>
<p>The functions are compatible if they have been evaluated at the
same sequence of values of the argument <code>r</code>, and if the
statistical estimates have the same names.
</p>


<h3>Value</h3>

<p>Logical value: <code>TRUE</code> if the objects are compatible, and <code>FALSE</code>
if they are not.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fv">eval.fv</a></code> 
</p>

<hr>
<h2 id='compileCDF'>
Generic Calculation of Cumulative Distribution Function of Distances
</h2><span id='topic+compileCDF'></span>

<h3>Description</h3>

<p>A low-level function which 
calculates the estimated cumulative distribution function
of a distance variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileCDF(D, B, r, ..., han.denom=NULL, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileCDF_+3A_d">D</code></td>
<td>

<p>A vector giving the distances from each data point to the target.
</p>
</td></tr>
<tr><td><code id="compileCDF_+3A_b">B</code></td>
<td>

<p>A vector giving the distances from each data point to the window boundary,
or censoring distances.
</p>
</td></tr>
<tr><td><code id="compileCDF_+3A_r">r</code></td>
<td>

<p>An equally spaced, finely spaced sequence of distance values
at which the CDF should be estimated.
</p>
</td></tr>
<tr><td><code id="compileCDF_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="compileCDF_+3A_han.denom">han.denom</code></td>
<td>

<p>Denominator for the Hanisch-Chiu-Stoyan estimator.
A single number, or a numeric vector with the same length
as <code>r</code>. 
</p>
</td></tr>
<tr><td><code id="compileCDF_+3A_check">check</code></td>
<td>

<p>Logical value specifying whether to check validity of the data,
for example, that the vectors <code>D</code> and <code>B</code> have the same
length, and contain non-negative numbers.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level function calculates estimates of
the cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(r) = P(D \le r)</code>
</p>

<p>of a distance variable <code class="reqn">D</code>, given a vector of observed values of
<code class="reqn">D</code> and other information.
Examples of this concept include the empty space distance function
computed by <code><a href="#topic+Fest">Fest</a></code> and the nearest-neighbour distance
distribution function <code><a href="#topic+Gest">Gest</a></code>.
</p>
<p>This function <code>compileCDF</code>
and its siblings <code><a href="#topic+compileK">compileK</a></code> and <code><a href="#topic+compilepcf">compilepcf</a></code>
are useful for code development and for teaching,
because they perform a common task, and do the housekeeping required to
make an object of class <code>"fv"</code> that represents the estimated
function. However, they are not very efficient. 
</p>
<p>The argument <code>D</code> should be a numeric vector of shortest distances
measured from each &lsquo;query&rsquo; point to the &lsquo;target&rsquo; set.
The argument <code>B</code> should be a numeric vector of shortest distances
measured from each &lsquo;query&rsquo; point to the boundary of the window
of observation.
All entries of <code>D</code> and <code>B</code> should be non-negative.
</p>
<p><code>compileCDF</code> calculates estimates of the cumulative distribution
function <code class="reqn">F(r)</code> using the border method (reduced sample
estimator), the Kaplan-Meier estimator and, if <code>han.denom</code> is
given, the Hanisch-Chiu-Stoyan estimator.
See Chapter 8 of Baddeley, Rubak and Turner (2015).
</p>
<p>The result is an object of class <code>"fv"</code> representing the
estimated function.
Additional columns (such as a column giving the theoretical
value) must be added by the user, with the aid of
<code><a href="#topic+bind.fv">bind.fv</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> representing the estimated function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compileK">compileK</a></code>.
</p>
<p><code><a href="#topic+bind.fv">bind.fv</a></code> to add more columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Equivalent to Gest(japanesepines)
  X &lt;- japanesepines
  D &lt;- nndist(X)
  B &lt;- bdist.points(X)
  r &lt;- seq(0, 0.25, by=0.01)
  H &lt;- eroded.areas(Window(X), r)
  G &lt;- compileCDF(D=D, B=B, r=r, han.denom=H)
  G &lt;- rebadge.fv(G, new.fname="G", new.ylab=quote(G(r)))
  plot(G)
</code></pre>

<hr>
<h2 id='compileK'>
Generic Calculation of K Function and Pair Correlation Function
</h2><span id='topic+compileK'></span><span id='topic+compilepcf'></span>

<h3>Description</h3>

<p>Low-level functions which 
calculate the estimated <code class="reqn">K</code> function
and estimated pair correlation function
(or any similar functions)
from a matrix of pairwise distances and optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileK(D, r, weights = NULL, denom = 1,
         check = TRUE, ratio = FALSE, fname = "K",
         samplesize=denom)

compilepcf(D, r, weights = NULL, denom = 1,
         check = TRUE, endcorrect = TRUE, ratio=FALSE,
	 ..., fname = "g", samplesize=denom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileK_+3A_d">D</code></td>
<td>

<p>A square matrix giving the distances between all pairs of points.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_r">r</code></td>
<td>

<p>An equally spaced, finely spaced sequence of distance values.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_weights">weights</code></td>
<td>

<p>Optional numerical weights for the pairwise distances.
A numeric matrix with the same dimensions as <code>D</code>.
If absent, the weights are taken to equal 1.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_denom">denom</code></td>
<td>

<p>Denominator for the estimator.
A single number, or a numeric vector with the same length
as <code>r</code>. See Details.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_check">check</code></td>
<td>

<p>Logical value specifying whether to check that <code>D</code> is a
valid matrix of pairwise distances.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to store ratio information.
See Details.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
controlling the kernel smoothing.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_endcorrect">endcorrect</code></td>
<td>

<p>Logical value indicating whether to apply End Correction of
the pair correlation estimate at <code>r=0</code>.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_fname">fname</code></td>
<td>

<p>Character string giving the name of the function being estimated.
</p>
</td></tr>
<tr><td><code id="compileK_+3A_samplesize">samplesize</code></td>
<td>

<p>The sample size that should be used as the denominator when
<code>ratio=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These low-level functions construct estimates of
the <code class="reqn">K</code> function or pair correlation function,
or any similar functions, given only the matrix of pairwise
distances and optional weights associated with these distances.
</p>
<p>These functions are useful for code development and for teaching,
because they perform a common task, and do the housekeeping required to
make an object of class <code>"fv"</code> that represents the estimated
function. However, they are not very efficient. 
</p>
<p><code>compileK</code> calculates the weighted estimate
of the <code class="reqn">K</code> function,
</p>
<p style="text-align: center;"><code class="reqn">
    \hat K(r) = (1/v(r)) \sum_i \sum_j 1\{ d_{ij} \le r\} w_{ij}
  </code>
</p>

<p>and <code>compilepcf</code> calculates the weighted estimate of the
pair correlation function,
</p>
<p style="text-align: center;"><code class="reqn">
    \hat g(r) = (1/v(r)) \sum_i \sum_j \kappa( d_{ij} - r ) w_{ij}
  </code>
</p>

<p>where <code class="reqn">d_{ij}</code> is the distance between spatial points
<code class="reqn">i</code> and <code class="reqn">j</code>, with corresponding weight <code class="reqn">w_{ij}</code>,
and <code class="reqn">v(r)</code> is a specified denominator. Here <code class="reqn">\kappa</code>
is a fixed-bandwidth smoothing kernel. 
</p>
<p>For a point pattern in two dimensions, the usual denominator <code class="reqn">v(r)</code>
is constant for the <code class="reqn">K</code> function, and proportional to <code class="reqn">r</code>
for the pair correlation function. See the Examples.
</p>
<p>The result is an object of class <code>"fv"</code> representing the
estimated function. This object has only one column of function
values. Additional columns (such as a column giving the theoretical
value) must be added by the user, with the aid of
<code><a href="#topic+bind.fv">bind.fv</a></code>.
</p>
<p>If <code>ratio=TRUE</code>, the result also belongs to class <code>"rat"</code>
and has attributes containing the numerator and denominator
of the function estimate.
(If <code>samplesize</code> is given, the numerator and denominator are
rescaled by a common factor so that the denominator is
equal to <code>samplesize</code>.)
This allows function estimates from
several datasets to be pooled using <code><a href="#topic+pool">pool</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> representing the estimated function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code> for definitions of the <code class="reqn">K</code> function
and pair correlation function.
</p>
<p><code><a href="#topic+bind.fv">bind.fv</a></code> to add more columns.
</p>
<p><code><a href="#topic+compileCDF">compileCDF</a></code> for the corresponding low-level utility
for estimating a cumulative distribution function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Equivalent to Kest(japanesepines) and pcf(japanesepines)
  X &lt;- japanesepines
  D &lt;- pairdist(X)
  Wt &lt;- edge.Ripley(X, D)
  lambda &lt;- intensity(X)
  a &lt;- (npoints(X)-1) * lambda
  r &lt;- seq(0, 0.25, by=0.01)
  K &lt;- compileK(D=D, r=r, weights=Wt, denom=a)
  g &lt;- compilepcf(D=D, r=r, weights=Wt, denom= a * 2 * pi * r)
</code></pre>

<hr>
<h2 id='cov.im'>
Covariance and Correlation between Images
</h2><span id='topic+cov.im'></span><span id='topic+cor.im'></span>

<h3>Description</h3>

<p>Compute the covariance or correlation between (the corresponding pixel
values in) several images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.im(..., use = "everything", method = c("pearson", "kendall", "spearman"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.im_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which is 
a pixel image (object of class <code>"im"</code>).
Alternatively, a single argument which is a list of pixel images.
</p>
</td></tr>
<tr><td><code id="cov.im_+3A_use">use</code></td>
<td>

<p>Argument passed to <code><a href="stats.html#topic+cov">cov</a></code>
or <code><a href="stats.html#topic+cor">cor</a></code> determining how to handle
<code>NA</code> values in the data.
</p>
</td></tr>
<tr><td><code id="cov.im_+3A_method">method</code></td>
<td>

<p>Argument passed to <code><a href="stats.html#topic+cov">cov</a></code>
or <code><a href="stats.html#topic+cor">cor</a></code> determining the type of correlation
that will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>...</code>
should be pixel images (objects of class <code>"im"</code>).
Their spatial domains must overlap, but need not have the same
pixel dimensions.
</p>
<p>These functions compute the covariance or correlation between
the corresponding pixel values in the images given.
</p>
<p>The pixel image domains are intersected, and converted to a
common pixel resolution. Then the corresponding pixel values of each image are
extracted. Finally the correlation or covariance between the
pixel values of each pair of images, at corresponding pixels, is
computed.
</p>
<p>The result is a symmetric matrix with one row and column for each image.
The <code>[i,j]</code> entry is the correlation or covariance between
the <code>i</code>th and <code>j</code>th images in the argument list.
The row names and column names of the matrix are copied from the
argument names if they were given (i.e. if the arguments were given
as <code>name=value</code>).
</p>
<p>Note that <code><a href="stats.html#topic+cor">cor</a></code> and <code><a href="stats.html#topic+cov">cov</a></code>
are not generic, so you have to type <code>cor.im</code>, <code>cov.im</code>.
</p>


<h3>Value</h3>

<p>A symmetric matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>,
<code><a href="stats.html#topic+cov">cov</a></code>
</p>
<p><code><a href="#topic+pairs.im">pairs.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cor.im(bei.extra)
</code></pre>

<hr>
<h2 id='dclf.progress'>
Progress Plot of Test of Spatial Pattern
</h2><span id='topic+dclf.progress'></span><span id='topic+mad.progress'></span><span id='topic+mctest.progress'></span>

<h3>Description</h3>

<p>Generates a progress plot (envelope representation) of the
Diggle-Cressie-Loosmore-Ford test or the
Maximum Absolute Deviation test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclf.progress(X, ...)
mad.progress(X, ...)
mctest.progress(X, fun = Lest, ...,
                exponent = 1, nrank = 1,
                interpolate = FALSE, alpha, rmin=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dclf.progress_+3A_x">X</code></td>
<td>

<p>Either a point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>
or other class), a fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code> or other class) or an envelope object (class
<code>"envelope"</code>). 
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>mctest.progress</code> or to <code><a href="#topic+envelope">envelope</a></code>.
Useful arguments include <code>fun</code> to determine the summary
function, <code>nsim</code> to specify the number of Monte Carlo
simulations, <code>alternative</code> to specify one-sided or two-sided
envelopes, and <code>verbose=FALSE</code> to turn off the messages.
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern. 
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_exponent">exponent</code></td>
<td>

<p>Positive number. The exponent of the <code class="reqn">L^p</code> distance.
See Details.
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_nrank">nrank</code></td>
<td>

<p>Integer. The rank of the critical value of the Monte Carlo test,
amongst the <code>nsim</code> simulated values.
A rank of 1 means that the minimum and maximum
simulated values will become the critical values for the test.
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating how to compute the critical value.
If <code>interpolate=FALSE</code> (the default), a standard Monte Carlo test
is performed, and the critical value is the largest
simulated value of the test statistic (if <code>nrank=1</code>)
or the <code>nrank</code>-th largest (if <code>nrank</code> is another number).
If <code>interpolate=TRUE</code>, kernel density estimation
is applied to the simulated values, and the critical value is
the upper <code>alpha</code> quantile of this estimated distribution.
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_alpha">alpha</code></td>
<td>

<p>Optional. The significance level of the test.
Equivalent to <code>nrank/(nsim+1)</code> where <code>nsim</code> is the
number of simulations.
</p>
</td></tr>
<tr><td><code id="dclf.progress_+3A_rmin">rmin</code></td>
<td>

<p>Optional. Left endpoint for the interval of <code class="reqn">r</code> values
on which the test statistic is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Diggle-Cressie-Loosmore-Ford test and the 
Maximum Absolute Deviation test for a spatial point pattern
are described in <code><a href="#topic+dclf.test">dclf.test</a></code>.
These tests depend on the choice of an interval of
distance values (the argument <code>rinterval</code>).
A <em>progress plot</em> or <em>envelope representation</em>
of the test (Baddeley et al, 2014) is a plot of the
test statistic (and the corresponding critical value) against the length of
the interval <code>rinterval</code>.
</p>
<p>The command <code>dclf.progress</code> performs 
<code><a href="#topic+dclf.test">dclf.test</a></code> on <code>X</code> using all possible intervals
of the form <code class="reqn">[0,R]</code>, and returns the resulting values of the test
statistic, and the corresponding critical values of the test,
as a function of <code class="reqn">R</code>. 
</p>
<p>Similarly <code>mad.progress</code> performs
<code><a href="#topic+mad.test">mad.test</a></code> using all possible intervals
and returns the test statistic and critical value.
</p>
<p>More generally, <code>mctest.progress</code> performs a test based on the
<code class="reqn">L^p</code> discrepancy between the curves. The deviation between two
curves is measured by the <code class="reqn">p</code>th root of the integral of
the <code class="reqn">p</code>th power of the absolute value of the difference
between the two curves. The exponent <code class="reqn">p</code> is
given by the argument <code>exponent</code>. The case <code>exponent=2</code>
is the Cressie-Loosmore-Ford test, while <code>exponent=Inf</code> is the
MAD test.
</p>
<p>If the argument <code>rmin</code> is given, it specifies the left endpoint
of the interval defining the test statistic: the tests are
performed using intervals <code class="reqn">[r_{\mbox{\scriptsize min}},R]</code>
where <code class="reqn">R \ge r_{\mbox{\scriptsize min}}</code>.
</p>
<p>The result of each command is an object of class <code>"fv"</code>
that can be plotted to obtain the progress plot. The display shows
the test statistic (solid black line) and the Monte Carlo
acceptance region (grey shading).
</p>
<p>The significance level for the Monte Carlo test is
<code>nrank/(nsim+1)</code>. Note that <code>nsim</code> defaults to 99,
so if the values of <code>nrank</code> and <code>nsim</code> are not given,
the default is a test with significance level 0.01.
</p>
<p>If <code>X</code> is an envelope object, then some of the data stored
in <code>X</code> may be re-used:
</p>

<ul>
<li>
<p>If <code>X</code> is an envelope object containing simulated functions,
and <code>fun=NULL</code>, then
the code will re-use the simulated functions stored in <code>X</code>.
</p>
</li>
<li>
<p>If <code>X</code> is an envelope object containing
simulated point patterns, 
then <code>fun</code> will be applied to the stored point patterns
to obtain the simulated functions.
If <code>fun</code> is not specified, it defaults to <code><a href="#topic+Lest">Lest</a></code>.
</p>
</li>
<li>
<p>Otherwise, new simulations will be performed,
and <code>fun</code> defaults to  <code><a href="#topic+Lest">Lest</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"fv"</code> that can be plotted to
obtain the progress plot. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Andrew Hardegen, Tom Lawrence, Gopal Nair and
Robin Milne.
</p>


<h3>References</h3>

<p>Baddeley, A., Diggle, P., Hardegen, A., Lawrence, T.,
Milne, R. and Nair, G. (2014)
On tests of spatial pattern based on simulation envelopes.
<em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dclf.test">dclf.test</a></code> and
<code><a href="#topic+mad.test">mad.test</a></code> for the tests.
</p>
<p>See <code><a href="#topic+plot.fv">plot.fv</a></code> for information on plotting
objects of class <code>"fv"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(dclf.progress(cells, nsim=19))
</code></pre>

<hr>
<h2 id='dclf.sigtrace'>
Significance Trace of Cressie-Loosmore-Ford or Maximum Absolute
Deviation Test
</h2><span id='topic+dclf.sigtrace'></span><span id='topic+mad.sigtrace'></span><span id='topic+mctest.sigtrace'></span>

<h3>Description</h3>

<p>Generates a Significance Trace of the
Diggle(1986)/ Cressie (1991)/ Loosmore and Ford (2006) test or the
Maximum Absolute Deviation test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclf.sigtrace(X, ...)
mad.sigtrace(X, ...)
mctest.sigtrace(X, fun=Lest, ...,
                exponent=1, interpolate=FALSE, alpha=0.05,
                confint=TRUE, rmin=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dclf.sigtrace_+3A_x">X</code></td>
<td>

<p>Either a point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>
or other class), a fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code> or other class) or an envelope object (class
<code>"envelope"</code>). 
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+envelope">envelope</a></code>
or <code><a href="#topic+mctest.progress">mctest.progress</a></code>.
Useful arguments include <code>fun</code> to determine the summary
function, <code>nsim</code> to specify the number of Monte Carlo
simulations, <code>alternative</code> to specify a one-sided test,
and <code>verbose=FALSE</code> to turn off the messages.
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern.
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_exponent">exponent</code></td>
<td>

<p>Positive number. The exponent of the <code class="reqn">L^p</code> distance.
See Details.
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value specifying whether to calculate the <code class="reqn">p</code>-value
by interpolation.
If <code>interpolate=FALSE</code> (the default), a standard Monte Carlo test
is performed, yielding a <code class="reqn">p</code>-value of the form <code class="reqn">(k+1)/(n+1)</code>
where <code class="reqn">n</code> is the number of simulations and <code class="reqn">k</code> is the number
of simulated values which are more extreme than the observed value.
If <code>interpolate=TRUE</code>, the <code class="reqn">p</code>-value is calculated by
applying kernel density estimation to the simulated values, and
computing the tail probability for this estimated distribution.
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_alpha">alpha</code></td>
<td>

<p>Significance level to be plotted (this has no effect on the calculation
but is simply plotted as a reference value).
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_confint">confint</code></td>
<td>

<p>Logical value indicating whether to compute a confidence interval
for the &lsquo;true&rsquo; <code class="reqn">p</code>-value.
</p>
</td></tr>
<tr><td><code id="dclf.sigtrace_+3A_rmin">rmin</code></td>
<td>

<p>Optional. Left endpoint for the interval of <code class="reqn">r</code> values
on which the test statistic is calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Diggle (1986)/ Cressie (1991)/Loosmore and Ford (2006) test and the 
Maximum Absolute Deviation test for a spatial point pattern
are described in <code><a href="#topic+dclf.test">dclf.test</a></code>.
These tests depend on the choice of an interval of
distance values (the argument <code>rinterval</code>).
A <em>significance trace</em> (Bowman and Azzalini, 1997;
Baddeley et al, 2014, 2015; Baddeley, Rubak and Turner, 2015)
of the test is a plot of the <code class="reqn">p</code>-value
obtained from the test against the length of
the interval <code>rinterval</code>.
</p>
<p>The command <code>dclf.sigtrace</code> performs 
<code><a href="#topic+dclf.test">dclf.test</a></code> on <code>X</code> using all possible intervals
of the form <code class="reqn">[0,R]</code>, and returns the resulting <code class="reqn">p</code>-values
as a function of <code class="reqn">R</code>.
</p>
<p>Similarly <code>mad.sigtrace</code> performs
<code><a href="#topic+mad.test">mad.test</a></code> using all possible intervals
and returns the <code class="reqn">p</code>-values.
</p>
<p>More generally, <code>mctest.sigtrace</code> performs a test based on the
<code class="reqn">L^p</code> discrepancy between the curves. The deviation between two
curves is measured by the <code class="reqn">p</code>th root of the integral of
the <code class="reqn">p</code>th power of the absolute value of the difference
between the two curves. The exponent <code class="reqn">p</code> is
given by the argument <code>exponent</code>. The case <code>exponent=2</code>
is the Cressie-Loosmore-Ford test, while <code>exponent=Inf</code> is the
MAD test.
</p>
<p>If the argument <code>rmin</code> is given, it specifies the left endpoint
of the interval defining the test statistic: the tests are
performed using intervals <code class="reqn">[r_{\mbox{\scriptsize min}},R]</code>
where <code class="reqn">R \ge r_{\mbox{\scriptsize min}}</code>.
</p>
<p>The result of each command
is an object of class <code>"fv"</code> that can be plotted to
obtain the significance trace. The plot shows the Monte Carlo
<code class="reqn">p</code>-value (solid black line), 
the critical value <code>0.05</code> (dashed red line),
and a pointwise 95% confidence band (grey shading)
for the &lsquo;true&rsquo; (Neyman-Pearson) <code class="reqn">p</code>-value.
The confidence band is based on the Agresti-Coull (1998)
confidence interval for a binomial proportion (when
<code>interpolate=FALSE</code>) or the delta method
and normal approximation (when <code>interpolate=TRUE</code>).
</p>
<p>If <code>X</code> is an envelope object and <code>fun=NULL</code> then
the code will re-use the simulated functions stored in <code>X</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> that can be plotted to
obtain the significance trace. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Agresti, A. and Coull, B.A. (1998)
Approximate is better than &ldquo;Exact&rdquo; for interval
estimation of binomial proportions.
<em>American Statistician</em> <b>52</b>, 119&ndash;126.
</p>
<p>Baddeley, A., Diggle, P., Hardegen, A., Lawrence, T.,
Milne, R. and Nair, G. (2014)
On tests of spatial pattern based on simulation envelopes.
<em>Ecological Monographs</em> <b>84</b>(3) 477&ndash;489.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2015)
Pushing the envelope: extensions of graphical
Monte Carlo tests. Unpublished manuscript.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Bowman, A.W. and Azzalini, A. (1997) 
<em>Applied smoothing techniques for data analysis: 
the kernel approach with S-Plus illustrations</em>.
Oxford University Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dclf.test">dclf.test</a></code> for the tests;
<code><a href="#topic+dclf.progress">dclf.progress</a></code> for progress plots.
</p>
<p>See <code><a href="#topic+plot.fv">plot.fv</a></code> for information on plotting
objects of class <code>"fv"</code>.
</p>
<p>See also <code><a href="#topic+dg.sigtrace">dg.sigtrace</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(dclf.sigtrace(cells, Lest, nsim=19))
</code></pre>

<hr>
<h2 id='dclf.test'>
Diggle-Cressie-Loosmore-Ford and Maximum Absolute Deviation Tests
</h2><span id='topic+dclf.test'></span><span id='topic+mad.test'></span>

<h3>Description</h3>

<p>Perform the Diggle (1986) / Cressie (1991) / Loosmore and Ford (2006)
test or the Maximum Absolute Deviation test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclf.test(X, ..., alternative=c("two.sided", "less", "greater"),
                  rinterval = NULL, leaveout=1,
                  scale=NULL, clamp=FALSE, interpolate=FALSE)

mad.test(X, ...,  alternative=c("two.sided", "less", "greater"),
                  rinterval = NULL, leaveout=1,
                  scale=NULL, clamp=FALSE, interpolate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dclf.test_+3A_x">X</code></td>
<td>

<p>Data for the test.
Either a point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>
or other class), a fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code> or other class), a simulation envelope (object of class
<code>"envelope"</code>) or a previous result of <code>dclf.test</code> or
<code>mad.test</code>. 
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+envelope">envelope</a></code>.
Useful arguments include <code>fun</code> to determine the summary
function, <code>nsim</code> to specify the number of Monte Carlo
simulations, <code>verbose=FALSE</code> to turn off the messages,
<code>savefuns</code> or <code>savepatterns</code> to save the simulation
results, and <code>use.theory</code> described under Details. 
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_alternative">alternative</code></td>
<td>

<p>The alternative hypothesis. A character string.
The default is a two-sided alternative. See Details.
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_rinterval">rinterval</code></td>
<td>

<p>Interval of values of the summary function argument <code>r</code>
over which the maximum absolute deviation, or the integral,
will be computed for the test. A numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_scale">scale</code></td>
<td>

<p>Optional. A function in the <span class="rlang"><b>R</b></span> language which determines the
relative scale of deviations, as a function of
distance <code class="reqn">r</code>. Summary function values for distance <code>r</code>
will be <em>divided</em> by <code>scale(r)</code> before the
test statistic is computed.
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_clamp">clamp</code></td>
<td>

<p>Logical value indicating how to compute deviations
in a one-sided test. Deviations of the observed
summary function from the theoretical summary function are initially
evaluated as signed real numbers, with large positive values indicating
consistency with the alternative hypothesis.
If <code>clamp=FALSE</code> (the default), these values are not changed.
If <code>clamp=TRUE</code>, any negative values are replaced by zero.
</p>
</td></tr>
<tr><td><code id="dclf.test_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value specifying whether to calculate the <code class="reqn">p</code>-value
by interpolation.
If <code>interpolate=FALSE</code> (the default), a standard Monte Carlo test
is performed, yielding a <code class="reqn">p</code>-value of the form <code class="reqn">(k+1)/(n+1)</code>
where <code class="reqn">n</code> is the number of simulations and <code class="reqn">k</code> is the number
of simulated values which are more extreme than the observed value.
If <code>interpolate=TRUE</code>, the <code class="reqn">p</code>-value is calculated by
applying kernel density estimation to the simulated values, and
computing the tail probability for this estimated distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform hypothesis tests for goodness-of-fit
of a point pattern dataset to a point process model, based on
Monte Carlo simulation from the model.
</p>
<p><code>dclf.test</code> performs the test advocated by Loosmore and Ford (2006)
which is also described in Diggle (1986), Cressie (1991, page 667, equation
(8.5.42)) and Diggle (2003, page 14). See Baddeley et al (2014) for
detailed discussion.
</p>
<p><code>mad.test</code> performs the &lsquo;global&rsquo; or
&lsquo;Maximum Absolute Deviation&rsquo; test described by Ripley (1977, 1981).
See Baddeley et al (2014).
</p>
<p>The type of test depends on the type of argument <code>X</code>.
</p>

<ul>
<li> 
<p>If <code>X</code> is some kind of point pattern, then a test of Complete
Spatial Randomness (CSR) will be performed. That is,
the null hypothesis is that the point pattern is completely random.
</p>
</li>
<li>
<p>If <code>X</code> is a fitted point process model, then a test of
goodness-of-fit for the fitted model will be performed. The model object
contains the data point pattern to which it was originally fitted.
The null hypothesis is that the data point pattern is a realisation
of the model.
</p>
</li>
<li>
<p>If <code>X</code> is an envelope object generated by <code><a href="#topic+envelope">envelope</a></code>,
then it should have been generated with <code>savefuns=TRUE</code> or
<code>savepatterns=TRUE</code> so that it contains simulation results.
These simulations will be treated as realisations from the null
hypothesis.
</p>
</li>
<li>
<p>Alternatively <code>X</code> could be a previously-performed
test of the same kind (i.e. the result of calling
<code>dclf.test</code> or <code>mad.test</code>).
The simulations used to perform the original test
will be re-used to perform the new test (provided these simulations
were saved in the original test, by setting <code>savefuns=TRUE</code> or
<code>savepatterns=TRUE</code>).
</p>
</li></ul>

<p>The argument <code>alternative</code> specifies the alternative hypothesis,
that is, the direction of deviation that will be considered
statistically significant. If <code>alternative="two.sided"</code> (the
default), both positive and negative deviations (between
the observed summary function and the theoretical function)
are significant. If <code>alternative="less"</code>, then only negative
deviations (where the observed summary function is lower than the
theoretical function) are considered. If <code>alternative="greater"</code>,
then only positive deviations (where the observed summary function is
higher than the theoretical function) are considered.
</p>
<p>In all cases, the algorithm will first call <code><a href="#topic+envelope">envelope</a></code> to
generate or extract the simulated summary functions.
The number of simulations that will be generated or extracted,
is determined by the argument <code>nsim</code>, and defaults to 99.
The summary function that will be computed is determined by the
argument <code>fun</code> (or the first unnamed argument in the list
<code>...</code>) and defaults to <code><a href="#topic+Kest">Kest</a></code> (except when
<code>X</code> is an envelope object generated with <code>savefuns=TRUE</code>,
when these functions will be taken).
</p>
<p>The choice of summary function <code>fun</code> affects the power of the
test. It is normally recommended to apply a variance-stabilising
transformation (Ripley, 1981). If you are using the <code class="reqn">K</code> function,
the normal practice is to replace this by the <code class="reqn">L</code> function
(Besag, 1977) computed by <code><a href="#topic+Lest">Lest</a></code>. If you are using
the <code class="reqn">F</code> or <code class="reqn">G</code> functions, the recommended practice is to apply
Fisher's variance-stabilising transformation
<code class="reqn">\sin^{-1}\sqrt x</code> using the argument
<code>transform</code>. See the Examples.
</p>
<p>The argument <code>rinterval</code> specifies the interval of
distance values <code class="reqn">r</code> which will contribute to the
test statistic (either maximising over this range of values
for <code>mad.test</code>, or integrating over this range of values
for <code>dclf.test</code>). This affects the power of the test.
General advice and experiments in Baddeley et al (2014) suggest
that the maximum <code class="reqn">r</code> value should be slightly larger than
the maximum possible range of interaction between points. The
<code>dclf.test</code> is quite sensitive to this choice, while the
<code>mad.test</code> is relatively insensitive.
</p>
<p>It is also possible to specify a pointwise test (i.e. taking
a single, fixed value of distance <code class="reqn">r</code>) by specifing
<code>rinterval = c(r,r)</code>.
</p>
<p>The argument <code>use.theory</code> passed to <code><a href="#topic+envelope">envelope</a></code>
determines whether to compare the summary function for the data
to its theoretical value for CSR (<code>use.theory=TRUE</code>)
or to the sample mean of simulations from CSR
(<code>use.theory=FALSE</code>). The test statistic <code class="reqn">T</code> is defined in
equations (10.21) and (10.22) respectively on page 394 of Baddeley,
Rubak and Turner (2015).
</p>
<p>The argument <code>leaveout</code> specifies how to calculate the
discrepancy between the summary function for the data and the
nominal reference value, when the reference value must be estimated
by simulation. The values <code>leaveout=0</code> and
<code>leaveout=1</code> are both algebraically equivalent (Baddeley et al, 2014,
Appendix) to computing the difference <code>observed - reference</code>
where the <code>reference</code> is the mean of simulated values.
The value <code>leaveout=2</code> gives the leave-two-out discrepancy
proposed by Dao and Genton (2014).
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code>.
Printing this object gives a report on the result of the test.
The <code class="reqn">p</code>-value is contained in the component <code>p.value</code>.
</p>


<h3>Handling Ties</h3>

<p>If the observed value of the test statistic is equal to one or more of the
simulated values (called a <em>tied value</em>), then the tied values
will be assigned a random ordering, and a message will be printed.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Andrew Hardegen and Suman Rakshit.
</p>


<h3>References</h3>

<p>Baddeley, A., Diggle, P.J., Hardegen, A., Lawrence, T., Milne,
R.K. and Nair, G. (2014) On tests of spatial pattern based on
simulation envelopes. 
<em>Ecological Monographs</em> <b>84</b>(3) 477&ndash;489.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Besag, J. (1977) 
Discussion of Dr Ripley's paper.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 193&ndash;195.
</p>
<p>Cressie, N.A.C. (1991)
<em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>
<p>Diggle, P. J. (1986).
Displaced amacrine cells in the retina of a
rabbit : analysis of a bivariate spatial point pattern. 
<em>J. Neuroscience Methods</em> <b>18</b>, 115&ndash;125.
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>
<p>Loosmore, N.B. and Ford, E.D. (2006)
Statistical inference using the <em>G</em> or <em>K</em> point
pattern spatial statistics. <em>Ecology</em> <b>87</b>, 1925&ndash;1931.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope">envelope</a></code>,
<code><a href="#topic+dclf.progress">dclf.progress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dclf.test(cells, Lest, nsim=39)
  m &lt;- mad.test(cells, Lest, verbose=FALSE, rinterval=c(0, 0.1), nsim=19)
  m
  # extract the p-value
  m$p.value
  # variance stabilised G function
  dclf.test(cells, Gest, transform=expression(asin(sqrt(.))),
                   verbose=FALSE, nsim=19)

  ## one-sided test
  ml &lt;- mad.test(cells, Lest, verbose=FALSE, nsim=19, alternative="less")

  ## scaled
  mad.test(cells, Kest, verbose=FALSE, nsim=19,
           rinterval=c(0.05, 0.2),
           scale=function(r) { r })
</code></pre>

<hr>
<h2 id='density.ppp'>Kernel Smoothed Intensity of Point Pattern</h2><span id='topic+density.ppp'></span>

<h3>Description</h3>

<p>Compute a kernel smoothed intensity function from a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
density(x, sigma=NULL, ...,
        weights=NULL, edge=TRUE, varcov=NULL,
        at="pixels", leaveoneout=TRUE,
        adjust=1, diggle=FALSE,
        se=FALSE, wtype=c("value", "multiplicity"),
        kernel="gaussian",
        scalekernel=is.character(kernel), 
        positive=FALSE, verbose=TRUE, sameas) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.ppp_+3A_x">x</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_sigma">sigma</code></td>
<td>

<p>The smoothing bandwidth (the amount of smoothing).
The standard deviation of the isotropic smoothing kernel.
Either a numerical value, 
or a function that computes an appropriate value of <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional weights to be attached to the points.
A numeric vector, numeric matrix, an <code>expression</code>,
or a pixel image.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>pixellate.ppp</code>
and <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine
the pixel resolution, or passed to <code>sigma</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic smoothing kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the intensity values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the smoothing parameter.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Logical. If <code>TRUE</code>, use the Jones-Diggle improved edge correction,
which is more accurate but slower to compute than the default
correction.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_kernel">kernel</code></td>
<td>

<p>The smoothing kernel.
A character string specifying the smoothing kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>),
or a pixel image (object of class <code>"im"</code>)
containing values of the kernel, or a <code>function(x,y)</code> which
yields values of the kernel.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_scalekernel">scalekernel</code></td>
<td>

<p>Logical value.
If <code>scalekernel=TRUE</code>, then the kernel will be rescaled
to the bandwidth determined by <code>sigma</code> and <code>varcov</code>:
this is the default behaviour when <code>kernel</code> is a character string.
If <code>scalekernel=FALSE</code>, then <code>sigma</code> and <code>varcov</code>
will be ignored: this is the default behaviour when <code>kernel</code> is a
function or a pixel image.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to compute standard errors as well.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_wtype">wtype</code></td>
<td>

<p>Character string (partially matched) specifying how the weights
should be interpreted for the calculation of standard error.
See Details.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_positive">positive</code></td>
<td>

<p>Logical value indicating whether to force all density values to
be positive numbers. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to issue warnings
about numerical problems and conditions.
</p>
</td></tr>
<tr><td><code id="density.ppp_+3A_sameas">sameas</code></td>
<td>

<p>Optional. The result of a previous evaluation of <code>density.ppp</code>.
Smoothing will be performed using the same kernel and bandwidth that
were used to produce <code>sameas</code>. Namely the values of the
arguments <code>kernel</code>, <code>sigma</code>, <code>varcov</code>,
<code>scalekernel</code> and <code>adjust</code> will be overwritten by the
values that were used to produce <code>sameas</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>density</code>.
</p>
<p>It computes a fixed-bandwidth kernel estimate 
(Diggle, 1985) of the intensity function of the point process
that generated the point pattern <code>x</code>.
</p>
<p>The amount of smoothing is controlled by <code>sigma</code>
if it is specified.
</p>
<p>By default, smoothing is performed using a Gaussian kernel.  
The resulting density estimate is the convolution of the
isotropic Gaussian kernel, of standard deviation <code>sigma</code>,
with point masses at each of the data points in <code>x</code>.
</p>
<p>Anisotropic kernels, and non-Gaussian kernels, are also supported.
Each point has unit weight, unless the argument <code>weights</code> is
given.
</p>
<p>If <code>edge=TRUE</code> (the default), the intensity estimate is corrected
for edge effect bias.
</p>
<p>If <code>at="pixels"</code> (the default), the result is a pixel image
giving the estimated intensity at each pixel in a grid.
If <code>at="points"</code>, the result is a numeric vector giving the
estimated intensity at each of the original data points in <code>x</code>.
</p>


<h3>Value</h3>

<p>By default, the result is
a pixel image (object of class <code>"im"</code>). 
Pixel values are estimated intensity values,
expressed in &ldquo;points per unit area&rdquo;.
</p>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>x</code>.
Values are estimated intensity values at the points of <code>x</code>.
</p>
<p>In either case, the return value has attributes
<code>"sigma"</code> and <code>"varcov"</code> which report the smoothing
bandwidth that was used.
</p>
<p>If <code>weights</code> is a matrix with more than one column, then the
result is a list of images (if <code>at="pixels"</code>) or a matrix of
numerical values (if <code>at="points"</code>).
</p>
<p>If <code>se=TRUE</code>, the result is a list with two elements named
<code>estimate</code> and <code>SE</code>, each of the format described above.
</p>


<h3>Amount of smoothing</h3>

<p>The amount of smoothing is determined by the arguments
<code>sigma</code>, <code>varcov</code> and <code>adjust</code>.
</p>

<ul>
<li><p> if <code>sigma</code> is a single numerical value,
this is taken as the standard deviation of the isotropic Gaussian
kernel.
</p>
</li>
<li><p> alternatively <code>sigma</code> may be a function that computes
an appropriate bandwidth 
from the data point pattern by calling <code>sigma(x)</code>.
To perform automatic bandwidth selection using cross-validation,
it is recommended to use the functions
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>
or
<code><a href="#topic+bw.ppl">bw.ppl</a></code>.
</p>
</li>
<li>
<p>The smoothing kernel may be made anisotropic
by giving the variance-covariance matrix <code>varcov</code>.
The arguments <code>sigma</code> and <code>varcov</code> are incompatible.
</p>
</li>
<li>
<p>Alternatively <code>sigma</code> may be a vector of length 2 giving the
standard deviations of the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates,
thus equivalent to <code>varcov = diag(rep(sigma^2, 2))</code>.
</p>
</li>
<li><p> if neither <code>sigma</code> nor <code>varcov</code> is specified,
an isotropic Gaussian kernel will be used, 
with a default value of <code>sigma</code>
calculated by a simple rule of thumb
that depends only on the size of the window.
</p>
</li>
<li>
<p>The argument <code>adjust</code> makes it easy for the user to change the
bandwidth specified by any of the rules above.
The value of <code>sigma</code> will be multiplied by
the factor <code>adjust</code>. The matrix <code>varcov</code> will be
multiplied by <code>adjust^2</code>. To double the smoothing bandwidth, set
<code>adjust=2</code>.
</p>
</li>
<li>
<p>An infinite bandwidth, <code>sigma=Inf</code> or <code>adjust=Inf</code>,
is permitted, and yields an intensity estimate which is constant
over the spatial domain.
</p>
</li></ul>



<h3>Edge correction</h3>

<p>If <code>edge=TRUE</code>, the intensity estimate is corrected for
edge effect bias in one of two ways:
</p>

<ul>
<li><p> If <code>diggle=FALSE</code> (the default) the intensity estimate is
correted by dividing it by the convolution of the
Gaussian kernel with the window of observation.
This is the approach originally described in Diggle (1985).
Thus the intensity value at a point <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
      \hat\lambda(u) = e(u) \sum_i k(x_i - u) w_i
    </code>
</p>

<p>where <code class="reqn">k</code> is the Gaussian smoothing kernel,
<code class="reqn">e(u)</code> is an edge correction factor, 
and <code class="reqn">w_i</code> are the weights.
</p>
</li>
<li>
<p>If <code>diggle=TRUE</code> then the code uses the improved edge correction
described by Jones (1993) and Diggle (2010, equation 18.9).
This has been shown to have better performance (Jones, 1993)
but is slightly slower to compute. 
The intensity value at a point <code class="reqn">u</code> is 
</p>
<p style="text-align: center;"><code class="reqn">
      \hat\lambda(u) = \sum_i k(x_i - u) w_i e(x_i)
    </code>
</p>

<p>where again <code class="reqn">k</code> is the Gaussian smoothing kernel,
<code class="reqn">e(x_i)</code> is an edge correction factor, 
and <code class="reqn">w_i</code> are the weights.
</p>
</li></ul>

<p>In both cases, the edge correction term <code class="reqn">e(u)</code> is the reciprocal of the
kernel mass inside the window:
</p>
<p style="text-align: center;"><code class="reqn">
    \frac{1}{e(u)} = \int_W k(v-u) \, {\rm d}v
  </code>
</p>

<p>where <code class="reqn">W</code> is the observation window.
</p>


<h3>Smoothing kernel</h3>

<p>By default, smoothing is performed using a Gaussian kernel.
</p>
<p>The choice of smoothing kernel is determined by the argument <code>kernel</code>.
This should be a character string giving the name of a recognised
two-dimensional kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>),
or a pixel image (object of class <code>"im"</code>)
containing values of the kernel, or a <code>function(x,y)</code> which
yields values of the kernel. The default is a Gaussian kernel.
</p>
<p>If <code>scalekernel=TRUE</code> then the kernel values will be rescaled
according to the arguments <code>sigma</code>, <code>varcov</code> and
<code>adjust</code> as explained above, effectively treating
<code>kernel</code> as the template kernel with standard deviation equal to 1.
This is the default behaviour when <code>kernel</code> is a character string.
If <code>scalekernel=FALSE</code>, the kernel values will not be altered,
and the arguments <code>sigma</code>, <code>varcov</code> and <code>adjust</code>
are ignored. This is the default behaviour when <code>kernel</code> is a
pixel image or a function.
</p>


<h3>Desired output</h3>

<p>If <code>at="pixels"</code> (the default), intensity values are
computed at every location <code class="reqn">u</code> in a fine grid,
and are returned as a pixel image. The point pattern is first discretised 
using <code>pixellate.ppp</code>, then the intensity is
computed using the Fast Fourier Transform.
Accuracy depends on the pixel resolution and the discretisation rule.
The pixel resolution is controlled by the arguments
<code>...</code> passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> (specify the number of
pixels by <code>dimyx</code> or the pixel size by <code>eps</code>). 
The discretisation rule is controlled by the arguments
<code>...</code> passed to <code>pixellate.ppp</code>
(the default rule is that each point is allocated to the nearest
pixel centre; this can be modified using the arguments
<code>fractional</code> and <code>preserve</code>).
</p>
<p>If <code>at="points"</code>, the intensity values are computed 
to high accuracy at the points of <code>x</code> only. Computation is
performed by directly evaluating and summing the kernel
contributions without discretising the data. The result is a numeric
vector giving the density values.
The intensity value at a point <code class="reqn">x_i</code> is (if <code>diggle=FALSE</code>)
</p>
<p style="text-align: center;"><code class="reqn">
    \hat\lambda(x_i) = e(x_i) \sum_j k(x_j - x_i) w_j
  </code>
</p>

<p>or (if <code>diggle=TRUE</code>)
</p>
<p style="text-align: center;"><code class="reqn">
    \hat\lambda(x_i) = \sum_j k(x_j - x_i) w_j e(x_j)
  </code>
</p>

<p>If <code>leaveoneout=TRUE</code> (the default), then the sum in the equation
is taken over all <code class="reqn">j</code> not equal to <code class="reqn">i</code>,
so that the intensity value at a
data point is the sum of kernel contributions from
all <em>other</em> data points.
If <code>leaveoneout=FALSE</code> then the sum is taken over all <code class="reqn">j</code>,
so that the intensity value at a data point includes a contribution
from the same point.
</p>


<h3>Weights</h3>

<p>If <code>weights</code> is a matrix with more than one column, then the
calculation is effectively repeated for each column of weights. The
result is a list of images (if <code>at="pixels"</code>) or a matrix of
numerical values (if <code>at="points"</code>).
</p>
<p>The argument <code>weights</code> can also be an <code>expression</code>.
It will be evaluated in the data frame <code>as.data.frame(x)</code>
to obtain a vector or matrix of weights. The expression may involve
the symbols <code>x</code> and <code>y</code> representing the Cartesian
coordinates, the symbol <code>marks</code> representing the mark values
if there is only one column of marks, and the names of the columns of
marks if there are several columns.  
</p>
<p>The argument <code>weights</code> can also be a pixel image
(object of class <code>"im"</code>). numerical weights for the data points
will be extracted from this image (by looking up the pixel values
at the locations of the data points in <code>x</code>).
</p>


<h3>Standard error</h3>

<p>If <code>se=TRUE</code>, the standard error of the estimate will also be
calculated. The calculation assumes a Poisson point process. 
</p>
<p>If <code>weights</code> are given, then the calculation of standard error
depends on the interpretation of the weights. This is controlled by
the argument <code>wtype</code>.
</p>

<ul>
<li>
<p>If <code>wtype="value"</code> (the default),
the weights are interpreted as numerical values observed
at the data locations. Roughly speaking,
standard errors are proportional to the absolute
values of the weights.
</p>
</li>
<li>
<p>If <code>wtype="multiplicity"</code> the weights are interpreted as
multiplicities so that a weight of 2 is equivalent to having a pair
of duplicated points at the data location. Roughly speaking,
standard errors are proportional
to the square roots of the weights. Negative weights are not
permitted.
</p>
</li></ul>

<p>The default rule is now <code>wtype="value"</code> but previous versions
of <code>density.ppp</code> (in <span class="pkg">spatstat.explore</span> versions
<code>3.1-0</code> and earlier) effectively used <code>wtype="multiplicity"</code>.
</p>


<h3>The meaning of <code>density.ppp</code></h3>

<p>This function is often misunderstood.
</p>
<p>The result of <code>density.ppp</code> is not a spatial smoothing 
of the marks or weights attached to the point pattern.
To perform spatial interpolation of values that were observed
at the points of a point pattern, use <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
<p>The result of <code>density.ppp</code> is not a probability density.
It is an estimate of the <em>intensity function</em> of the
point process that generated the point pattern data.
Intensity is the expected number of random points
per unit area.
The units of intensity are &ldquo;points per unit area&rdquo;.
Intensity is usually a function of spatial location,
and it is this function which is estimated by <code>density.ppp</code>.
The integral of the intensity function over a spatial region gives the
expected number of points falling in this region.
</p>
<p>Inspecting an estimate of the intensity function is usually the
first step in exploring a spatial point pattern dataset.
For more explanation, see Baddeley, Rubak and Turner (2015)
or Diggle (2003, 2010).
</p>
<p>If you have two (or more) types of points, and you want a
probability map or relative risk surface (the spatially-varying
probability of a given type), use <code><a href="#topic+relrisk">relrisk</a></code>.
</p>


<h3>Technical issue: Negative Values</h3>

<p>Negative and zero values of the density estimate are possible
when <code>at="pixels"</code> because of numerical errors in finite-precision
arithmetic.
</p>
<p>By default, <code>density.ppp</code> does not try to repair such errors.
This would take more computation time and is not always needed.
(Also it would not be appropriate if <code>weights</code> include negative values.)
</p>
<p>To ensure that the resulting density values are always positive,
set <code>positive=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Diggle, P.J. (1985)
A kernel method for smoothing point process data.
<em>Applied Statistics</em> (Journal of the Royal Statistical Society,
Series C) <b>34</b> (1985) 138&ndash;147.
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>
<p>Diggle, P.J. (2010)
Nonparametric methods.
Chapter 18, pp. 299&ndash;316 in
A.E. Gelfand, P.J. Diggle, M. Fuentes and P. Guttorp (eds.)
<em>Handbook of Spatial Statistics</em>,
CRC Press, Boca Raton, FL.
</p>
<p>Jones, M.C. (1993)
Simple boundary corrections for kernel density estimation.
<em>Statistics and Computing</em> <b>3</b>, 135&ndash;146.
</p>


<h3>See Also</h3>

<p>To select the bandwidth <code>sigma</code> automatically by
cross-validation, use
<code><a href="#topic+bw.diggle">bw.diggle</a></code>,
<code><a href="#topic+bw.CvL">bw.CvL</a></code>,
<code><a href="#topic+bw.scott">bw.scott</a></code>
or
<code><a href="#topic+bw.ppl">bw.ppl</a></code>.
</p>
<p>To perform spatial interpolation of values that were observed
at the points of a point pattern, use <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
<p>For adaptive nonparametric estimation, see
<code><a href="#topic+adaptive.density">adaptive.density</a></code>.
For data sharpening, see <code><a href="#topic+sharpen.ppp">sharpen.ppp</a></code>.
</p>
<p>To compute a relative risk surface or probability map for
two (or more) types of points, use <code><a href="#topic+relrisk">relrisk</a></code>.
</p>
<p>For information about the data structures, see
<code>ppp.object</code>,
<code>im.object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    opa &lt;- par(mfrow=c(1,2))
    plot(density(cells, 0.05))
    plot(density(cells, 0.05, diggle=TRUE))
    par(opa)
    v &lt;- diag(c(0.05, 0.07)^2)
    plot(density(cells, varcov=v))
  }
  # automatic bandwidth selection
  plot(density(cells, sigma=bw.diggle(cells)))
  # equivalent:
  plot(density(cells, bw.diggle))
  # evaluate intensity at points
  density(cells, 0.05, at="points")

  # non-Gaussian kernel
  plot(density(cells, sigma=0.4, kernel="epanechnikov"))

  if(interactive()) {
    # see effect of changing pixel resolution
    opa &lt;- par(mfrow=c(1,2))
    plot(density(cells, sigma=0.4))
    plot(density(cells, sigma=0.4, eps=0.05))
    par(opa)
  }

  # relative risk calculation by hand (see relrisk.ppp)
  lung &lt;- split(chorley)$lung
  larynx &lt;- split(chorley)$larynx
  D &lt;- density(lung, sigma=2)
  plot(density(larynx, sigma=2, weights=1/D))
</code></pre>

<hr>
<h2 id='density.psp'>Kernel Smoothing of Line Segment Pattern</h2><span id='topic+density.psp'></span>

<h3>Description</h3>

<p>Compute a kernel smoothed intensity function from a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
density(x, sigma, ..., weights=NULL, edge=TRUE,
                   method=c("FFT", "C", "interpreted"),
                   at=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.psp_+3A_x">x</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>)
to be smoothed.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of isotropic Gaussian smoothing kernel.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_...">...</code></td>
<td>

<p>Extra arguments, including arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to determine the resolution of the resulting image.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_weights">weights</code></td>
<td>

<p>Optional. Numerical weights for each line segment.
A numeric vector, of length equal to the number of segments in
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_edge">edge</code></td>
<td>

<p>Logical flag indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_method">method</code></td>
<td>

<p>Character string (partially matched) specifying the method of
computation. Option <code>"FFT"</code> is the fastest, while
<code>"C"</code> is the most accurate.
</p>
</td></tr>
<tr><td><code id="density.psp_+3A_at">at</code></td>
<td>

<p>Optional. An object specifying the locations where density values
should be computed. Either a window (object of class <code>"owin"</code>)
or a point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method for the generic function <code><a href="stats.html#topic+density">density</a></code>
for the class <code>"psp"</code> (line segment patterns).
</p>
<p>A kernel estimate of the intensity of the line segment pattern
is computed. The result is 
the convolution of the isotropic Gaussian kernel, of
standard deviation <code>sigma</code>, with the line segments.
The result is computed as follows:
</p>

<ul>
<li><p> if <code>method="FFT"</code> (the default),
the line segments are discretised
using <code>pixellate.psp</code>, then the Fast Fourier Transform
is used to calculate the convolution. This method is the fastest,
but is slightly less accurate. Accuracy can be improved by
increasing pixel resolution.
</p>
</li>
<li><p> if <code>method="C"</code> the exact value of the convolution at the
centre of each pixel is computed analytically using <code>C</code> code;
</p>
</li>
<li><p> if <code>method="interpreted"</code>,
the exact value of the convolution at the
centre of each pixel is computed analytically using <code>R</code> code.
This method is the slowest.
</p>
</li></ul>

<p>If <code>edge=TRUE</code> this result is adjusted for edge effects
by dividing it by the convolution of the same Gaussian kernel
with the observation window.
</p>
<p>If <code>weights</code> are given, then the contribution from line segment
<code>i</code> is multiplied by the value of <code>weights[i]</code>.
</p>
<p>If the argument <code>at</code> is given, then it specifies the locations
where density values should be computed.
</p>

<ul>
<li><p> If <code>at</code> is a window,
then the window is converted to a binary mask
using the arguments <code>...</code>, and density values are computed at
the centre of each pixel in this mask. The result is a pixel image.
</p>
</li>
<li>
<p>If <code>at</code> is a point pattern, then density values are computed at
each point location, and the result is a numeric vector.
</p>
</li></ul>



<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>)
or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>psp.object</code>,
<code>im.object</code>,
<code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
  D &lt;- density(L, sigma=0.03)
  plot(D, main="density(L)")
  plot(L, add=TRUE)
</code></pre>

<hr>
<h2 id='density.splitppp'>Kernel Smoothed Intensity of Split Point Pattern</h2><span id='topic+density.splitppp'></span><span id='topic+density.ppplist'></span>

<h3>Description</h3>

<p>Compute a kernel smoothed intensity function for each
of the components of a split point pattern,
or each of the point patterns in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'splitppp'
density(x, ..., weights=NULL, se=FALSE)

  ## S3 method for class 'ppplist'
density(x, ..., weights=NULL, se=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.splitppp_+3A_x">x</code></td>
<td>

<p>Split point pattern (object of class <code>"splitppp"</code>
created by <code>split.ppp</code>) to be smoothed.
Alternatively a list of point patterns,
of class <code>"ppplist"</code>.
</p>
</td></tr>
<tr><td><code id="density.splitppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to control
the smoothing, pixel resolution, edge correction etc.
</p>
</td></tr>
<tr><td><code id="density.splitppp_+3A_weights">weights</code></td>
<td>

<p>Numerical weights for the points. See Details.
</p>
</td></tr>
<tr><td><code id="density.splitppp_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to compute standard errors as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>density</code>.
</p>
<p>The argument <code>x</code> should be a list of point patterns,
and should belong to one of the classes 
<code>"ppplist"</code> or <code>"splitppp"</code>.
</p>
<p>Typically <code>x</code> is obtained by applying
the function <code>split.ppp</code> to a point pattern <code>y</code>
by calling <code>split(y)</code>. This splits the points of <code>y</code> into several
sub-patterns.
</p>
<p>A kernel estimate of the intensity function of each of the
point patterns is computed using <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
<p>The return value is usually a list, each of whose entries is a
pixel image (object of class <code>"im"</code>). The return value
also belongs to the class <code>"solist"</code> and can be plotted
or printed.
</p>
<p>If the argument <code>at="points"</code> is given, the result is a list
of numeric vectors giving the intensity values at the data points.
</p>
<p>If <code>se=TRUE</code>, the result is a list with two elements named
<code>estimate</code> and <code>SE</code>, each of the format described above.
</p>
<p>The argument <code>weights</code> specifies numerical case weights
for the data points.
Normally it should be a list, with the same length as
<code>x</code>. The entry <code>weights[[i]]</code> will determine the
case weights for the pattern <code>x[[i]]</code>, and may be given in
any format acceptable to <code><a href="#topic+density.ppp">density.ppp</a></code>.
For example, <code>weights[[i]]</code> can be
a numeric vector of length equal to <code>npoints(x[[i]])</code>,
a single numeric value, a numeric matrix,
a pixel image (object of class <code>"im"</code>),
an <code>expression</code>, or a function of class <code>"funxy"</code>.
</p>
<p>For convenience, <code>weights</code> can also be a single <code>expression</code>,
or a single pixel image (object of class <code>"im"</code>),
or a single function of class <code>"funxy"</code>.
</p>


<h3>Value</h3>

<p>A list of pixel images (objects of class <code>"im"</code>)
which can be plotted or printed;
or a list of numeric vectors giving the values at specified points.
</p>
<p>If <code>se=TRUE</code>, the result is a list with two elements named
<code>estimate</code> and <code>SE</code>, each of the format described above.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>ppp.object</code>,
<code>im.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- density(split(amacrine), 0.05)
  plot(Z)
</code></pre>

<hr>
<h2 id='densityAdaptiveKernel'>Adaptive Kernel Estimate of Intensity of Point Pattern</h2><span id='topic+densityAdaptiveKernel'></span><span id='topic+densityAdaptiveKernel.ppp'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of the intensity function of a point
pattern using a variable-bandwidth smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityAdaptiveKernel(X, ...)

## S3 method for class 'ppp'
densityAdaptiveKernel(X, bw, ...,
       weights=NULL,       
       at=c("pixels", "points"),
       edge=TRUE, ngroups) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityAdaptiveKernel_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_bw">bw</code></td>
<td>

<p>Numeric vector of smoothing bandwidths for each point in <code>X</code>,
or a pixel image giving the smoothing bandwidth at each spatial
location, or a spatial function of class <code>"funxy"</code> giving the
smoothing bandwidth at each location.
The default is to compute bandwidths using <code><a href="#topic+bw.abram.ppp">bw.abram.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_...">...</code></td>
<td>

<p>Arguments passed to
<code><a href="#topic+bw.abram">bw.abram</a></code> to compute the smoothing bandwidths
if <code>bw</code> is missing,
or passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>
to control the spatial resolution of the result.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_weights">weights</code></td>
<td>

<p>Optional vector of numeric weights for the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the intensity values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to perform edge correction.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_ngroups">ngroups</code></td>
<td>

<p>Number of groups into which the bandwidth values should be
partitioned and discretised.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a spatially-adaptive kernel estimate of the
spatially-varying intensity from the point pattern <code>X</code>
using the partitioning technique of Davies and Baddeley (2018).
</p>
<p>The argument <code>bw</code> specifies the smoothing bandwidths to be
applied to each of the points in <code>X</code>. It may be a numeric vector
of bandwidth values, or a pixel image or function yielding the
bandwidth values.
</p>
<p>If the points of <code>X</code> are <code class="reqn">x_1,\ldots,x_n</code>
and the corresponding bandwidths are
<code class="reqn">\sigma_1,\ldots,\sigma_n</code>
then the adaptive kernel estimate of intensity at a location <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
    \hat\lambda(u) = \sum_{i=1}^n k(u, x_i, \sigma_i)
  </code>
</p>

<p>where <code class="reqn">k(u, v, \sigma)</code> is the value at <code class="reqn">u</code>
of the (possibly edge-corrected) smoothing kernel with bandwidth <code class="reqn">\sigma</code>
induced by a data point at <code class="reqn">v</code>.
</p>
<p>Exact computation of the estimate above can be time-consuming:
it takes <code class="reqn">n</code> times longer than fixed-bandwidth smoothing.
</p>
<p>The partitioning method of Davies and Baddeley (2018)
accelerates this computation by partitioning the range of
bandwidths into <code>ngroups</code> intervals,
correspondingly subdividing the points of the pattern <code>X</code> into
<code>ngroups</code> sub-patterns according to bandwidth,
and applying fixed-bandwidth smoothing to each sub-pattern.
</p>
<p>The default value of <code>ngroups</code> is the integer part of the square root of
the number of points in <code>X</code>, so that the computation time is
only about <code class="reqn">\sqrt{n}</code> times slower than fixed-bandwidth
smoothing. Any positive value of <code>ngroups</code>
can be specified by the user. Specifying <code>ngroups=Inf</code> enforces exact
computation of the estimate without partitioning. Specifying
<code>ngroups=1</code> is the same as fixed-bandwidth smoothing with
bandwidth <code>sigma=median(bw)</code>.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default), the result is a pixel image.
If <code>at="points"</code>, the result is a numeric vector with one entry
for each data point in <code>X</code>.
</p>


<h3>Bandwidths and Bandwidth Selection</h3>

<p>The function <code>densityAdaptiveKernel</code>
computes one adaptive estimate of the intensity,
determined by the smoothing bandwidth values <code>bw</code>.
</p>
<p>Typically the bandwidth values are computed by first computing
a pilot estimate of the intensity, then using <code><a href="#topic+bw.abram">bw.abram</a></code>
to compute the vector of bandwidths according to Abramson's rule.
This involves specifying a global bandwidth <code>h0</code>.
</p>
<p>The default bandwidths may work well in many contexts, but for optimal
bandwidth selection, this calculation should be performed repeatedly with
different values of <code>h0</code> to optimise the value of <code>h0</code>.
This can be computationally demanding; we recommend
the function <code>multiscale.density</code> in the <span class="pkg">sparr</span> package
which supports much faster bandwidth selection, using the FFT
method of Davies and Baddeley (2018).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Tilman Davies.
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley, A. (2018)
Fast computation of spatially adaptive kernel estimates.
<em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Hall, P. and Marron, J.S. (1988)
Variable window width kernel density estimates of probability
densities.
<em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49.
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+adaptive.density">adaptive.density</a></code>,
<code><a href="#topic+densityVoronoi">densityVoronoi</a></code>,
<code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>.
</p>
<p>See the function <code>bivariate.density</code> in the <span class="pkg">sparr</span> package
for a more flexible implementation, and
<code>multiscale.density</code> for an implementation that is more
efficient for bandwidth selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- densityAdaptiveKernel(redwood, h0=0.1)
  plot(Z, main="Adaptive kernel estimate")
  points(redwood, col="white")
</code></pre>

<hr>
<h2 id='densityAdaptiveKernel.splitppp'>Adaptive Kernel Estimate of Intensity for Split Point Pattern</h2><span id='topic+densityAdaptiveKernel.splitppp'></span><span id='topic+densityAdaptiveKernel.ppplist'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of the intensity function 
(using a variable-bandwidth smoothing kernel)
for each of the components of a split point pattern,
or each of the point patterns in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitppp'
densityAdaptiveKernel(X, bw=NULL, ..., weights=NULL)

## S3 method for class 'ppplist'
densityAdaptiveKernel(X, bw=NULL, ..., weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityAdaptiveKernel.splitppp_+3A_x">X</code></td>
<td>

<p>Split point pattern (object of class <code>"splitppp"</code>
created by <code>split.ppp</code>) to be smoothed.
Alternatively a list of point patterns,
of class <code>"ppplist"</code>.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel.splitppp_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidths. See Details.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel.splitppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="#topic+densityAdaptiveKernel.ppp">densityAdaptiveKernel.ppp</a></code>.
These may include arguments that will be passed to
<code><a href="#topic+bw.abram">bw.abram</a></code> to compute
the smoothing bandwidths if <code>bw</code> is missing,
and arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>
to control the spatial resolution of the result.
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel.splitppp_+3A_weights">weights</code></td>
<td>

<p>Numerical weights for the points. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a spatially-adaptive kernel estimate of the
spatially-varying intensity for each of the point patterns
in the list <code>X</code>, using <code><a href="#topic+densityAdaptiveKernel.ppp">densityAdaptiveKernel.ppp</a></code>.
</p>
<p>The argument <code>bw</code> specifies smoothing bandwidths
for the data points.
Normally it should be a list, with the same length as
<code>x</code>. The entry <code>bw[[i]]</code> will determine the
smoothing bandwidths for the pattern <code>x[[i]]</code>, and may be given in
any format acceptable to <code><a href="#topic+densityAdaptiveKernel.ppp">densityAdaptiveKernel.ppp</a></code>.
For example, <code>bw[[i]]</code> can be
a numeric vector of length equal to <code>npoints(x[[i]])</code>,
a single numeric value, 
a pixel image (object of class <code>"im"</code>),
an <code>expression</code>, or a function of class <code>"funxy"</code>.
For convenience, <code>bw</code> can also be a single <code>expression</code>,
or a single pixel image, or a single function.
If <code>bw</code> is missing or <code>NULL</code>, the default is to compute
bandwidths using <code><a href="#topic+bw.abram.ppp">bw.abram.ppp</a></code>.
</p>
<p>The argument <code>weights</code> specifies numerical case weights
for the data points.
Normally it should be a list, with the same length as
<code>x</code>. The entry <code>weights[[i]]</code> will determine the
case weights for the pattern <code>x[[i]]</code>, and may be given in
any format acceptable to <code><a href="#topic+density.ppp">density.ppp</a></code>.
For example, <code>weights[[i]]</code> can be
a numeric vector of length equal to <code>npoints(x[[i]])</code>,
a single numeric value, a numeric matrix,
a pixel image (object of class <code>"im"</code>),
an <code>expression</code>, or a function of class <code>"funxy"</code>.
For convenience, <code>weights</code> can also be a single <code>expression</code>,
or a single pixel image (object of class <code>"im"</code>),
or a single function of class <code>"funxy"</code>.
If <code>weights</code> is missing or <code>NULL</code>, all weights are assumed
to be equal to 1.
</p>


<h3>Value</h3>

<p>A list of pixel images (objects of class <code>"im"</code>)
which can be plotted or printed;
or a list of numeric vectors giving the values at specified points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityAdaptiveKernel.ppp">densityAdaptiveKernel.ppp</a></code>,
<code><a href="#topic+bw.abram.ppp">bw.abram.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- amacrine
  if(!interactive()) X &lt;- X[c(TRUE,FALSE,FALSE,FALSE)]
  Z &lt;- densityAdaptiveKernel(split(X), h0=0.15)
  plot(Z, main="Adaptive kernel estimate")
</code></pre>

<hr>
<h2 id='densityfun.ppp'>
Kernel Estimate of Intensity as a Spatial Function
</h2><span id='topic+densityfun'></span><span id='topic+densityfun.ppp'></span>

<h3>Description</h3>

<p>Compute a kernel estimate of intensity for a point pattern,
and return the result as a function of spatial location.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityfun(X, ...)

## S3 method for class 'ppp'
densityfun(X, sigma = NULL, ...,
                        weights = NULL, edge = TRUE, diggle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityfun.ppp_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="densityfun.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth, or bandwidth selection function,
passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="densityfun.ppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="densityfun.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional vector of weights associated with the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="densityfun.ppp_+3A_edge">edge</code>, <code id="densityfun.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Logical arguments controlling the edge correction.
Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The commands <code>densityfun</code> and <code><a href="stats.html#topic+density">density</a></code>
both perform kernel estimation of the intensity of a point pattern.
The difference is that <code><a href="stats.html#topic+density">density</a></code> returns a pixel image,
containing the estimated intensity values at a grid of locations, while
<code>densityfun</code> returns a <code>function(x,y)</code> which can be used
to compute the intensity estimate at <em>any</em> spatial locations
with coordinates <code>x,y</code>.
For purposes such as model-fitting it is more accurate to
use <code>densityfun</code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> with arguments <code>x,y,drop</code>.
The function also belongs to the class <code>"densityfun"</code> which has
methods for <code>print</code> and <code>as.im</code>.
It also belongs to the class <code>"funxy"</code> which has methods
for <code>plot</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Using the result of <code>densityfun</code></h3>

<p>If <code>f &lt;- densityfun(X)</code>, where <code>X</code> is a two-dimensional
point pattern, the resulting object <code>f</code>
is a <code>function</code> in the <span class="rlang"><b>R</b></span> language.
</p>
<p>By calling this function,
the user can evaluate the estimated intensity at any desired spatial
locations. 
</p>
<p>Additionally <code>f</code> belongs to other
classes which allow it to be printed and plotted easily.
</p>
<p>The function <code>f</code> has arguments <code>x,y,drop</code>.
</p>

<ul>
<li><p> The arguments <code>x,y</code> of <code>f</code>
specify the query locations. They can be numeric vectors
of coordinates. Alternatively <code>x</code> can be a point pattern
(or data acceptable to <code>as.ppp</code>) and <code>y</code> is omitted.
The result of <code>f(x,y)</code> is a numeric vector giving the values of
the intensity.
</p>
</li>
<li> 
<p>The argument <code>drop</code> of <code>f</code> specifies how to handle query locations
which are outside the window of the original data.
If <code>drop=TRUE</code> (the default), such locations are ignored.
If <code>drop=FALSE</code>, a value of <code>NA</code> is returned
for each such location.
</p>
</li></ul>

<p>Note that the smoothing parameters, such as the bandwidth
<code>sigma</code>, are assigned when <code>densityfun</code> is executed.
Smoothing parameters are fixed inside the function <code>f</code>
and cannot be changed by arguments of <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>.
</p>
<p>To interpolate values observed at the points, use <code><a href="#topic+Smoothfun">Smoothfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- densityfun(swedishpines)
  f
  f(42, 60)
  X &lt;- runifpoint(2, Window(swedishpines))
  f(X)
  plot(f)
</code></pre>

<hr>
<h2 id='densityHeat'>
Diffusion Estimate of Point Pattern Intensity
</h2><span id='topic+densityHeat'></span>

<h3>Description</h3>

<p>Computes a diffusion estimate of intensity for a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityHeat(x, sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityHeat_+3A_x">x</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or another class).
</p>
</td></tr>
<tr><td><code id="densityHeat_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth. Usually a single number giving the equivalent
standard deviation of the smoother. 
</p>
</td></tr>
<tr><td><code id="densityHeat_+3A_...">...</code></td>
<td>

<p>Additional arguments depending on the method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>densityHeat</code> computes an
estimate of point process intensity using a diffusion kernel method.
</p>
<p>Further details depend on the class of point pattern <code>x</code>.
See the help file for the appropriate method.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley and Tilman Davies.
</p>


<h3>See Also</h3>

<p>For two-dimensional point patterns (objects of class <code>"ppp"</code>),
the diffusion kernel estimator is <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>.
The usual kernel estimator is <code><a href="#topic+density.ppp">density.ppp</a></code>,
and the tessellation-based estimator is
<code><a href="#topic+adaptive.density">adaptive.density</a></code>.
</p>



<hr>
<h2 id='densityHeat.ppp'>
Diffusion Estimate of Point Pattern Intensity
</h2><span id='topic+densityHeat.ppp'></span>

<h3>Description</h3>

<p>Computes the diffusion estimate of the intensity of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
densityHeat(x, sigma, ..., weights=NULL,
          connect=8, symmetric=FALSE,
          sigmaX=NULL, k=1, show=FALSE, se=FALSE,
          at=c("pixels", "points"),
          leaveoneout = TRUE,
          extrapolate = FALSE, coarsen = TRUE,
          verbose=TRUE, internal=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityHeat.ppp_+3A_x">x</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth. A single number giving the equivalent
standard deviation of the smoother.
Alternatively, a pixel image (class <code>"im"</code>) or a
<code>function(x,y)</code> giving the spatially-varying bandwidth.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+pixellate.ppp">pixellate.ppp</a></code>
controlling the pixel resolution.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights associated with each point of
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_connect">connect</code></td>
<td>

<p>Grid connectivity: either 4 or 8.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_symmetric">symmetric</code></td>
<td>

<p>Logical value indicating whether to <em>force</em> the algorithm
to use a symmetric random walk.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_sigmax">sigmaX</code></td>
<td>

<p>Numeric vector of bandwidths, one associated with each data point in
<code>x</code>. See Details.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_k">k</code></td>
<td>

<p>Integer. Calculations will be performed by repeatedly multiplying
the current state by the <code>k</code>-step transition matrix.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_show">show</code></td>
<td>

<p>Logical value indicating whether to plot successive iterations.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to compute standard errors.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_at">at</code></td>
<td>

<p>Character string specifying whether to compute values
at a grid of pixels (<code>at="pixels"</code>, the default)
or at the data points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether to compute a leave-one-out
estimate at each data point, when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Logical value specifying whether to use Richardson extrapolation
to improve the accuracy of the computation.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_coarsen">coarsen</code></td>
<td>

<p>Logical value, controlling the calculation performed when
<code>extrapolate=TRUE</code>. See Details.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="densityHeat.ppp_+3A_internal">internal</code></td>
<td>

<p>Developer use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes a diffusion kernel estimate 
of point process intensity from the observed point pattern <code>x</code>.
</p>
<p>The function <code><a href="#topic+densityHeat">densityHeat</a></code> is generic,
with methods for point patterns in two dimensions
(class <code>"ppp"</code>) and point patterns on a linear network
(class <code>"lpp"</code>). The function <code>densityHeat.ppp</code> described
here is the method for class <code>"ppp"</code>. Given a two-dimensional
point pattern <code>x</code>, it computes a diffusion kernel estimate
of the intensity of the point process which generated <code>x</code>.
</p>
<p>Diffusion kernel estimates were developed
by Botev et al (2010), Barry and McIntyre (2011) and
Baddeley et al (2022). 
</p>
<p>Barry and McIntyre (2011) proposed an estimator for point process
intensity based on a random walk on the pixel grid inside the
observation window. Baddeley et al (2022) showed that the
Barry-McIntyre method is a special case of the <em>diffusion estimator</em> 
proposed by Botev et al (2010).
</p>
<p>The original Barry-McIntyre algorithm assumes a symmetric random walk
(i.e. each possible transition has the same probability <code class="reqn">p</code>)
and requires a square pixel grid (i.e. equal
spacing in the <code class="reqn">x</code> and <code class="reqn">y</code> directions). Their original
algorithm is used if <code>symmetric=TRUE</code>. Use the <code>...</code>
arguments to ensure a square grid: for example, the argument
<code>eps</code> specifies a square grid with spacing <code>eps</code> units.
</p>
<p>The more general algorithm used here (Baddeley et al, 2022)
does not require a square grid of pixels.
If the pixel grid is not square, and if <code>symmetric=FALSE</code>
(the default), then the random walk is not symmetric,
in the sense that the probabilities of different jumps will be
different, in order to ensure that the smoothing is isotropic.
</p>
<p>This implementation also includes two generalizations to
the case of adaptive smoothing (Baddeley et al, 2022).
</p>
<p>In the first version of adaptive smoothing, the bandwidth is
spatially-varying.
The argument <code>sigma</code> should be a pixel image (class <code>"im"</code>)
or a <code>function(x,y)</code> specifying the bandwidth at each spatial
location. The smoothing is performed by solving the 
heat equation with spatially-varying parameters.
</p>
<p>In the second version of adaptive smoothing, each data point in
<code>x</code> is smoothed using a separate bandwidth.
The argument <code>sigmaX</code> should be a numeric vector
specifying the bandwidth for each point of <code>x</code>.
The smoothing is performed using the lagged arrival algorithm.
The argument <code>sigma</code> can be omitted.
</p>
<p>If <code>extrapolate=FALSE</code> (the default), calculations are performed
using the Euler scheme for the heat equation. 
If <code>extrapolate=TRUE</code>, the accuracy of the result will be
improved by applying Richardson extrapolation (Baddeley et al, 2022, Section
4). After computing the intensity estimate using the Euler scheme
on the desired pixel grid, another estimate is computed using the same
method on another pixel grid, and the two estimates are combined by
Richardson extrapolation to obtain a more accurate result.
The second grid is coarser than the original grid if
<code>coarsen=TRUE</code> (the default), and finer than the original grid
if <code>coarsen=FALSE</code>. Setting <code>extrapolate=TRUE</code> increases
computation time by 35% if <code>coarsen=TRUE</code> and by 400% if
<code>coarsen=FALSE</code>.
</p>


<h3>Value</h3>

<p>Pixel image (object of class <code>"im"</code>) giving the estimated
intensity of the point process.
</p>
<p>If <code>se=TRUE</code>, the result has an attribute <code>"se"</code>
which is another pixel image giving the estimated standard error.
</p>
<p>If <code>at="points"</code> then the result is a numeric vector
with one entry for each point of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley and Tilman Davies.
</p>


<h3>References</h3>

<p>Baddeley, A., Davies, T., Rakshit, S., Nair, G. and McSwiggan, G. (2022)
Diffusion smoothing for spatial point patterns.
<em>Statistical Science</em> <b>37</b> (1) 123&ndash;142.
</p>
<p>Barry, R.P. and McIntyre, J. (2011)
Estimating animal densities and home range in regions with irregular
boundaries and holes: a lattice-based alternative to the kernel
density estimator. <em>Ecological Modelling</em> <b>222</b>, 1666&ndash;1672.
</p>
<p>Botev, Z.I., Grotowski, J.F. and Kroese, D.P. (2010)
Kernel density estimation via diffusion.
<em>Annals of Statistics</em> <b>38</b>, 2916&ndash;2957.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code> for the usual kernel estimator,
and <code><a href="#topic+adaptive.density">adaptive.density</a></code> for the
tessellation-based estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   online &lt;- interactive()
   if(!online) op &lt;- spatstat.options(npixel=32)

   X &lt;- runifpoint(25, letterR)
   Z &lt;- densityHeat(X, 0.2)
   if(online) {
     plot(Z, main="Diffusion estimator")
     plot(X, add=TRUE, pch=16)
     integral(Z) # should equal 25
   }

   Z &lt;- densityHeat(X, 0.2, se=TRUE)
   Zse &lt;- attr(Z, "se")
   if(online) plot(solist(estimate=Z, SE=Zse), main="")

   Zex &lt;- densityHeat(X, 0.2, extrapolate=TRUE)

   ZS &lt;- densityHeat(X, 0.2, symmetric=TRUE, eps=0.125)
   if(online) {
     plot(ZS, main="fixed bandwidth")
     plot(X, add=TRUE, pch=16)
   }

   sig &lt;- function(x,y) { (x-1.5)/10 }
   ZZ &lt;- densityHeat(X, sig)
   if(online) {
     plot(ZZ, main="adaptive (I)")
     plot(X, add=TRUE, pch=16)
   }

   sigX &lt;- sig(X$x, X$y)
   AA &lt;- densityHeat(X, sigmaX=sigX)
   if(online) {
     plot(AA, main="adaptive (II)")
     plot(X, add=TRUE, pch=16)
   }
   if(!online) spatstat.options(op)
</code></pre>

<hr>
<h2 id='densityVoronoi'>Intensity Estimate of Point Pattern Using Voronoi-Dirichlet Tessellation</h2><span id='topic+densityVoronoi'></span><span id='topic+densityVoronoi.ppp'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of the intensity function of a point
pattern using the Dirichlet-Voronoi tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityVoronoi(X, ...)

## S3 method for class 'ppp'
densityVoronoi(X, f = 1, ...,
                          counting=FALSE,
                          fixed=FALSE,
                          nrep = 1, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityVoronoi_+3A_x">X</code></td>
<td>
<p>Point pattern dataset (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_f">f</code></td>
<td>

<p>Fraction (between 0 and 1 inclusive) of the data points that will be
used to build a tessellation for the intensity estimate.
</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>as.im</code> determining the
pixel resolution of the result.
</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_counting">counting</code></td>
<td>

<p>Logical value specifying the choice of estimation method.
See Details.
</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_fixed">fixed</code></td>
<td>

<p>Logical. If <code>FALSE</code> (the default), the data points are independently
randomly thinned, so the number of data points that are retained
is random. If <code>TRUE</code>, the number of data points retained
is fixed. See Details.
</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_nrep">nrep</code></td>
<td>
<p>Number of independent repetitions of the randomised
procedure.</p>
</td></tr>
<tr><td><code id="densityVoronoi_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print
progress reports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alternative to <code><a href="#topic+density.ppp">density.ppp</a></code>. It
computes an estimate of the intensity function of a point pattern
dataset. The result is a pixel image giving the estimated intensity.
</p>
<p>If <code>f=1</code> (the default), the Voronoi estimate (Barr and Schoenberg, 2010)
is computed: the point pattern <code>X</code> is used to construct
a Voronoi/Dirichlet tessellation (see <code>dirichlet</code>);
the areas of the Dirichlet tiles are computed; the estimated intensity
in each tile is the reciprocal of the tile area.
The result is a pixel image
of intensity estimates which are constant on each tile of the tessellation.
</p>
<p>If <code>f=0</code>, the intensity estimate at every location is
equal to the average intensity (number of points divided by window area).
The result is a pixel image
of intensity estimates which are constant.
</p>
<p>If <code>f</code> is strictly between 0 and 1,
the estimation method is applied to a random subset of <code>X</code>.
This randomised procedure is repeated <code>nrep</code> times,
and the results are averaged.
The subset is selected as follows:
</p>

<ul>
<li>
<p>if <code>fixed=FALSE</code>,
the dataset <code>X</code> is randomly
thinned by deleting or retaining each point independently, with
probability <code>f</code> of retaining a point.
</p>
</li>
<li>
<p>if <code>fixed=TRUE</code>,
a random sample of fixed size <code>m</code> is taken from
the dataset <code>X</code>, where <code>m</code> is the largest integer
less than or equal to <code>f*n</code> and <code>n</code> is the number of
points in <code>X</code>.
</p>
</li></ul>

<p>Then the intensity estimate is calculated as follows:
</p>

<ul>
<li><p> if <code>counting = FALSE</code> (the default), the thinned pattern
is used to construct a Dirichlet tessellation and form the
Voronoi estimate (Barr and Schoenberg, 2010) which is then
adjusted by a factor <code>1/f</code> or <code>n/m</code> as appropriate.
to obtain an estimate
of the intensity of <code>X</code> in the tile.
</p>
</li>
<li><p> if <code>counting = TRUE</code>,
the randomly selected subset <code>A</code>
is used to construct a Dirichlet tessellation, while the
complementary subset <code>B</code> (consisting of points that were not
selected in the sample) is used for counting
to calculate a quadrat count estimate of intensity.
For each tile of the Dirichlet tessellation formed by <code>A</code>,
we count the number of points of <code>B</code> falling in the
tile, and divide by the area of the same tile, to obtain an estimate
of the intensity of the pattern <code>B</code> in the tile.
This estimate is adjusted by <code>1/(1-f)</code>
or <code>n/(n-m)</code> as appropriate 
to obtain an estimate of the intensity of <code>X</code> in the tile.
</p>
</li></ul>

<p>Ogata et al. (2003) and Ogata (2004) estimated intensity using the
Dirichlet-Voronoi tessellation in a modelling context.
Baddeley (2007) proposed intensity estimation by subsampling
with <code>0 &lt; f &lt; 1</code>, and used the  technique described above 
with <code>fixed=TRUE</code> and <code>counting=TRUE</code>.
Barr and Schoenberg (2010) described and analysed the
Voronoi estimator (corresponding to <code>f=1</code>).
Moradi et al (2019) developed the subsampling technique with
<code>fixed=FALSE</code> and <code>counting=FALSE</code> and called it the
<em>smoothed Voronoi estimator</em>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose values are
estimates of the intensity of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2007)
Validation of statistical models for spatial point patterns.
In J.G. Babu and E.D. Feigelson (eds.)
<em>SCMA IV: Statistical Challenges in Modern Astronomy IV</em>,
volume 317 of Astronomical Society of the Pacific Conference Series,
San Francisco, California USA, 2007. Pages 22&ndash;38.
</p>
<p>Barr, C., and Schoenberg, F.P. (2010).
On the Voronoi estimator for the intensity of an inhomogeneous
planar Poisson process. <em>Biometrika</em> <b>97</b> (4), 977&ndash;984.
</p>
<p>Moradi, M., Cronie, 0., Rubak, E., Lachieze-Rey, R.,
Mateu, J. and Baddeley, A. (2019)
Resample-smoothing of Voronoi intensity estimators.
<em>Statistics and Computing</em> <b>29</b> (5) 995&ndash;1010.
</p>
<p>Ogata, Y. (2004)
Space-time model for regional seismicity and detection of crustal
stress changes.
<em>Journal of Geophysical Research</em>, <b>109</b>, 2004.
</p>
<p>Ogata, Y., Katsura, K. and Tanemura, M. (2003).
Modelling heterogeneous space-time occurrences of earthquakes and its
residual analysis.
<em>Applied Statistics</em> <b>52</b> 499&ndash;509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptive.density">adaptive.density</a></code>,
<code><a href="#topic+density.ppp">density.ppp</a></code>,
<code>dirichlet</code>,
<code>im.object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(densityVoronoi(nztrees, 1, f=1), main="Voronoi estimate")
  nr &lt;- if(interactive()) 100 else 5
  plot(densityVoronoi(nztrees, f=0.5, nrep=nr), main="smoothed Voronoi estimate")
</code></pre>

<hr>
<h2 id='deriv.fv'>
Calculate Derivative of Function Values
</h2><span id='topic+deriv.fv'></span>

<h3>Description</h3>

<p>Applies numerical differentiation to the values
in selected columns of a function value table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
deriv(expr, which = "*", ...,
          method=c("spline", "numeric"),
          kinks=NULL,
          periodic=FALSE,
          Dperiodic=periodic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv.fv_+3A_expr">expr</code></td>
<td>

<p>Function values to be differentiated.
A function value table (object of class <code>"fv"</code>,
see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_which">which</code></td>
<td>

<p>Character vector identifying which columns of the table
should be differentiated. Either a vector containing names
of columns, or one of the wildcard strings <code>"*"</code> or <code>"."</code>
explained below.
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
to control the differentiation algorithm, if <code>method="spline"</code>.
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_method">method</code></td>
<td>

<p>Differentiation method. A character string, partially matched
to either <code>"spline"</code> or <code>"numeric"</code>.
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_kinks">kinks</code></td>
<td>

<p>Optional vector of <code class="reqn">x</code> values where the derivative is
allowed to be discontinuous. 
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_periodic">periodic</code></td>
<td>

<p>Logical value indicating whether the function <code>expr</code>
is periodic. 
</p>
</td></tr>
<tr><td><code id="deriv.fv_+3A_dperiodic">Dperiodic</code></td>
<td>

<p>Logical value indicating whether the resulting derivative
should be a periodic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command performs numerical differentiation on the function values in
a function value table (object of class <code>"fv"</code>).
The differentiation is performed either by 
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or by
a naive numerical difference algorithm.
</p>
<p>The command <code><a href="stats.html#topic+deriv">deriv</a></code> is generic. This is the
method for objects of class <code>"fv"</code>.
</p>
<p>Differentiation is applied to every column
(or to each of the selected columns) of function values in turn,
using the function argument as the <code class="reqn">x</code> coordinate
and the selected column as the <code class="reqn">y</code> coordinate.
The original function values are then replaced by the corresponding
derivatives.
</p>
<p>The optional argument <code>which</code> specifies which of the
columns of function values in <code>expr</code> will be differentiated.
The default (indicated by the wildcard <code>which="*"</code>)
is to differentiate all function values, i.e.\ all columns except the
function argument. Alternatively <code>which="."</code> designates
the subset of function values that are displayed in the default plot.
Alternatively <code>which</code> can be a character vector containing the
names of columns of <code>expr</code>.
</p>
<p>If the argument <code>kinks</code> is given, it should be a numeric vector
giving the discontinuity points of the function: the value or values
of the function argument at which the function is
not differentiable. Differentiation will be performed separately on
intervals between the discontinuity points.
</p>
<p>If <code>periodic=TRUE</code> then the function <code>expr</code> is taken to be
periodic, with period equal to the range of the function
argument in <code>expr</code>. The resulting derivative is periodic.
</p>
<p>If <code>periodic=FALSE</code> but <code>Dperiodic=TRUE</code>, then the
<em>derivative</em> is assumed to be periodic. This would be
appropriate if <code>expr</code> is the cumulative distribution function
of an angular variable, for example. 
</p>


<h3>Value</h3>

<p>Another function value table (object of class <code>"fv"</code>)
of the same format.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.fv">with.fv</a></code>,
<code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   G &lt;- Gest(cells)
   plot(deriv(G, which=".", spar=0.5))
   A &lt;- pairorient(redwood, 0.05, 0.15)
   DA &lt;- deriv(A, spar=0.6, Dperiodic=TRUE)
</code></pre>

<hr>
<h2 id='dg.envelope'>
Global Envelopes for Dao-Genton Test
</h2><span id='topic+dg.envelope'></span>

<h3>Description</h3>

<p>Computes the global envelopes
corresponding to the Dao-Genton test of goodness-of-fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dg.envelope(X, ...,
            nsim = 19, nsimsub=nsim-1, nrank = 1,
            alternative=c("two.sided", "less", "greater"),
            leaveout=1, interpolate = FALSE,
            savefuns=FALSE, savepatterns=FALSE,
            verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dg.envelope_+3A_x">X</code></td>
<td>

<p>Either a point pattern dataset (object of class <code>"ppp"</code>,
<code>"lpp"</code> or <code>"pp3"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_...">...</code></td>
<td>

<p>Arguments passed to 
<code><a href="#topic+mad.test">mad.test</a></code> or <code><a href="#topic+envelope">envelope</a></code> to
control the conduct of the test.
Useful arguments include <code>fun</code> to determine the summary
function, <code>rinterval</code> to determine the range of
<code class="reqn">r</code> values used in the test, and
<code>verbose=FALSE</code> to turn off the messages.
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated patterns to be generated in the primary
experiment. 
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_nsimsub">nsimsub</code></td>
<td>

<p>Number of simulations in each basic test. There will be <code>nsim</code>
repetitions of the basic test, each involving <code>nsimsub</code> simulated
realisations, so there will be a total
of <code>nsim * (nsimsub + 1)</code> simulations.
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>alternative="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>alternative="less"</code>) or a one-sided test
with an upper critical boundary (<code>alternative="greater"</code>).
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating whether to interpolate the distribution of
the test statistic by kernel smoothing, as described in
Dao and Genton (2014, Section 5).
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="dg.envelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical value determining whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes global simulation envelopes corresponding to the
Dao-Genton (2014) adjusted Monte Carlo goodness-of-fit test.
The envelopes were developed in Baddeley et al (2015) and
described in Baddeley, Rubak and Turner (2015).
</p>
<p>If <code>X</code> is a point pattern, the null hypothesis is CSR.
</p>
<p>If <code>X</code> is a fitted model, the null hypothesis is that model.
</p>
<p>The Dao-Genton test is biased when the significance level is very small
(small <code class="reqn">p</code>-values are not reliable) and
we recommend <code><a href="#topic+bits.envelope">bits.envelope</a></code> in this case.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2015)
Pushing the envelope: extensions of graphical
Monte Carlo tests. Unpublished manuscript.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dg.test">dg.test</a></code>,
<code><a href="#topic+mad.test">mad.test</a></code>,
<code><a href="#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ns &lt;- if(interactive()) 19 else 4
  E &lt;- dg.envelope(swedishpines, Lest, nsim=ns)
  E
  plot(E)
  Eo &lt;- dg.envelope(swedishpines, Lest, alternative="less", nsim=ns)
  Ei &lt;- dg.envelope(swedishpines, Lest, interpolate=TRUE, nsim=ns)
</code></pre>

<hr>
<h2 id='dg.progress'>
Progress Plot of Dao-Genton Test of Spatial Pattern
</h2><span id='topic+dg.progress'></span>

<h3>Description</h3>

<p>Generates a progress plot (envelope representation) of the
Dao-Genton test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dg.progress(X, fun = Lest, ...,
            exponent = 2, nsim = 19, nsimsub = nsim - 1,
            nrank = 1, alpha, leaveout=1, interpolate = FALSE, rmin=0,
            savefuns = FALSE, savepatterns = FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dg.progress_+3A_x">X</code></td>
<td>

<p>Either a point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>
or other class), a fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code> or other class) or an envelope object (class
<code>"envelope"</code>). 
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern. 
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+envelope">envelope</a></code>.
Useful arguments include <code>alternative</code> to
specify one-sided or two-sided envelopes.
</p>
</td></tr>  
<tr><td><code id="dg.progress_+3A_exponent">exponent</code></td>
<td>

<p>Positive number. The exponent of the <code class="reqn">L^p</code> distance.
See Details.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_nsim">nsim</code></td>
<td>

<p>Number of repetitions of the basic test.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_nsimsub">nsimsub</code></td>
<td>

<p>Number of simulations in each basic test. There will be <code>nsim</code>
repetitions of the basic test, each involving <code>nsimsub</code> simulated
realisations, so there will be a total
of <code>nsim * (nsimsub + 1)</code> simulations.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_nrank">nrank</code></td>
<td>

<p>Integer. The rank of the critical value of the Monte Carlo test,
amongst the <code>nsim</code> simulated values.
A rank of 1 means that the minimum and maximum
simulated values will become the critical values for the test.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_alpha">alpha</code></td>
<td>

<p>Optional. The significance level of the test.
Equivalent to <code>nrank/(nsim+1)</code> where <code>nsim</code> is the
number of simulations.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating how to compute the critical value.
If <code>interpolate=FALSE</code> (the default), a standard Monte Carlo test
is performed, and the critical value is the largest
simulated value of the test statistic (if <code>nrank=1</code>)
or the <code>nrank</code>-th largest (if <code>nrank</code> is another number).
If <code>interpolate=TRUE</code>, kernel density estimation
is applied to the simulated values, and the critical value is
the upper <code>alpha</code> quantile of this estimated distribution.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_rmin">rmin</code></td>
<td>

<p>Optional. Left endpoint for the interval of <code class="reqn">r</code> values
on which the test statistic is calculated.
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical value indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical value indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="dg.progress_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dao and Genton (2014) test for a spatial point pattern
is described in <code><a href="#topic+dg.test">dg.test</a></code>.
This test depends on the choice of an interval of
distance values (the argument <code>rinterval</code>).
A <em>progress plot</em> or <em>envelope representation</em>
of the test (Baddeley et al, 2014, 2015; Baddeley, Rubak and Turner, 2015) is a plot of the
test statistic (and the corresponding critical value) against the length of
the interval <code>rinterval</code>.
</p>
<p>The command <code>dg.progress</code> effectively performs 
<code><a href="#topic+dg.test">dg.test</a></code> on <code>X</code> using all possible intervals
of the form <code class="reqn">[0,R]</code>, and returns the resulting values of the test
statistic, and the corresponding critical values of the test,
as a function of <code class="reqn">R</code>. 
</p>
<p>The result is an object of class <code>"fv"</code>
that can be plotted to obtain the progress plot. The display shows
the test statistic (solid black line) and the test
acceptance region (grey shading).
If <code>X</code> is an envelope object, then some of the data stored
in <code>X</code> may be re-used:
</p>

<ul>
<li>
<p>If <code>X</code> is an envelope object containing simulated functions,
and <code>fun=NULL</code>, then
the code will re-use the simulated functions stored in <code>X</code>.
</p>
</li>
<li>
<p>If <code>X</code> is an envelope object containing
simulated point patterns, 
then <code>fun</code> will be applied to the stored point patterns
to obtain the simulated functions.
If <code>fun</code> is not specified, it defaults to <code><a href="#topic+Lest">Lest</a></code>.
</p>
</li>
<li>
<p>Otherwise, new simulations will be performed,
and <code>fun</code> defaults to  <code><a href="#topic+Lest">Lest</a></code>.
</p>
</li></ul>

<p>If the argument <code>rmin</code> is given, it specifies the left endpoint
of the interval defining the test statistic: the tests are
performed using intervals <code class="reqn">[r_{\mbox{\scriptsize min}},R]</code>
where <code class="reqn">R \ge r_{\mbox{\scriptsize min}}</code>.
</p>
<p>The argument <code>leaveout</code> specifies how to calculate the
discrepancy between the summary function for the data and the
nominal reference value, when the reference value must be estimated
by simulation. The values <code>leaveout=0</code> and
<code>leaveout=1</code> are both algebraically equivalent (Baddeley et al, 2014,
Appendix) to computing the difference <code>observed - reference</code>
where the <code>reference</code> is the mean of simulated values.
The value <code>leaveout=2</code> gives the leave-two-out discrepancy
proposed by Dao and Genton (2014).
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> that can be plotted to
obtain the progress plot. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Diggle, P., Hardegen, A., Lawrence, T.,
Milne, R. and Nair, G. (2014)
On tests of spatial pattern based on simulation envelopes.
<em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2015)
Pushing the envelope: extensions of graphical
Monte Carlo tests. Unpublished manuscript.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dg.test">dg.test</a></code>,
<code><a href="#topic+dclf.progress">dclf.progress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ns &lt;- if(interactive()) 19 else 5
   plot(dg.progress(cells, nsim=ns))
</code></pre>

<hr>
<h2 id='dg.sigtrace'>
Significance Trace of Dao-Genton Test
</h2><span id='topic+dg.sigtrace'></span>

<h3>Description</h3>

<p>Generates a Significance Trace of the
Dao and Genton (2014) test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dg.sigtrace(X, fun = Lest, ...,
              exponent = 2, nsim = 19, nsimsub = nsim - 1,
              alternative = c("two.sided", "less", "greater"),
              rmin=0, leaveout=1,
              interpolate = FALSE, confint = TRUE, alpha = 0.05,
              savefuns=FALSE, savepatterns=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dg.sigtrace_+3A_x">X</code></td>
<td>

<p>Either a point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>
or other class), a fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code> or other class) or an envelope object (class
<code>"envelope"</code>). 
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+envelope">envelope</a></code>.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_exponent">exponent</code></td>
<td>

<p>Positive number. Exponent used in the test statistic. Use <code>exponent=2</code>
for the Diggle-Cressie-Loosmore-Ford test, and <code>exponent=Inf</code>
for the Maximum Absolute Deviation test.
See Details.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_nsim">nsim</code></td>
<td>

<p>Number of repetitions of the basic test.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_nsimsub">nsimsub</code></td>
<td>

<p>Number of simulations in each basic test. There will be <code>nsim</code>
repetitions of the basic test, each involving <code>nsimsub</code> simulated
realisations, so there will be a total
of <code>nsim * (nsimsub + 1)</code> simulations.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
The default (<code>alternative="two.sided"</code>) is that the
true value of the summary function is not equal to the theoretical
value postulated under the null hypothesis.
If <code>alternative="less"</code> the alternative hypothesis is that the
true value of the summary function is lower than the theoretical value.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_rmin">rmin</code></td>
<td>

<p>Optional. Left endpoint for the interval of <code class="reqn">r</code> values
on which the test statistic is calculated.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating whether to interpolate the distribution of
the test statistic by kernel smoothing, as described in
Dao and Genton (2014, Section 5).
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_confint">confint</code></td>
<td>

<p>Logical value indicating whether to compute a confidence interval
for the &lsquo;true&rsquo; <code class="reqn">p</code>-value.
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_alpha">alpha</code></td>
<td>

<p>Significance level to be plotted (this has no effect on the calculation
but is simply plotted as a reference value).
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="dg.sigtrace_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dao and Genton (2014) test for a spatial point pattern
is described in <code><a href="#topic+dg.test">dg.test</a></code>.
This test depends on the choice of an interval of
distance values (the argument <code>rinterval</code>).
A <em>significance trace</em> (Bowman and Azzalini, 1997;
Baddeley et al, 2014, 2015; Baddeley, Rubak and Turner, 2015)
of the test is a plot of the <code class="reqn">p</code>-value
obtained from the test against the length of
the interval <code>rinterval</code>.
</p>
<p>The command <code>dg.sigtrace</code> effectively performs 
<code><a href="#topic+dg.test">dg.test</a></code> on <code>X</code> using all possible intervals
of the form <code class="reqn">[0,R]</code>, and returns the resulting <code class="reqn">p</code>-values
as a function of <code class="reqn">R</code>.
</p>
<p>The result is an object of class <code>"fv"</code> that can be plotted to
obtain the significance trace. The plot shows the
Dao-Genton adjusted
<code class="reqn">p</code>-value (solid black line), 
the critical value <code>0.05</code> (dashed red line),
and a pointwise 95% confidence band (grey shading)
for the &lsquo;true&rsquo; (Neyman-Pearson) <code class="reqn">p</code>-value.
The confidence band is based on the Agresti-Coull (1998)
confidence interval for a binomial proportion.
</p>
<p>If <code>X</code> is an envelope object and <code>fun=NULL</code> then
the code will re-use the simulated functions stored in <code>X</code>.
</p>
<p>If the argument <code>rmin</code> is given, it specifies the left endpoint
of the interval defining the test statistic: the tests are
performed using intervals <code class="reqn">[r_{\mbox{\scriptsize min}},R]</code>
where <code class="reqn">R \ge r_{\mbox{\scriptsize min}}</code>.
</p>
<p>The argument <code>leaveout</code> specifies how to calculate the
discrepancy between the summary function for the data and the
nominal reference value, when the reference value must be estimated
by simulation. The values <code>leaveout=0</code> and
<code>leaveout=1</code> are both algebraically equivalent (Baddeley et al, 2014,
Appendix) to computing the difference <code>observed - reference</code>
where the <code>reference</code> is the mean of simulated values.
The value <code>leaveout=2</code> gives the leave-two-out discrepancy
proposed by Dao and Genton (2014).
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> that can be plotted to
obtain the significance trace. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Agresti, A. and Coull, B.A. (1998)
Approximate is better than &ldquo;Exact&rdquo; for interval
estimation of binomial proportions.
<em>American Statistician</em> <b>52</b>, 119&ndash;126.
</p>
<p>Baddeley, A., Diggle, P., Hardegen, A., Lawrence, T.,
Milne, R. and Nair, G. (2014)
On tests of spatial pattern based on simulation envelopes.
<em>Ecological Monographs</em> <b>84</b>(3) 477&ndash;489.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2015)
Pushing the envelope: extensions of graphical
Monte Carlo tests. Unpublished manuscript.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Bowman, A.W. and Azzalini, A. (1997) 
<em>Applied smoothing techniques for data analysis: 
the kernel approach with S-Plus illustrations</em>.
Oxford University Press, Oxford.
</p>
<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dg.test">dg.test</a></code> for the Dao-Genton test,
<code><a href="#topic+dclf.sigtrace">dclf.sigtrace</a></code> for significance traces of other tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ns &lt;- if(interactive()) 19 else 5
  plot(dg.sigtrace(cells, nsim=ns))
</code></pre>

<hr>
<h2 id='dg.test'>
Dao-Genton Adjusted Goodness-Of-Fit Test
</h2><span id='topic+dg.test'></span>

<h3>Description</h3>

<p>Performs the Dao and Genton (2014) adjusted
goodness-of-fit test of spatial pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dg.test(X, ...,
        exponent = 2, nsim=19, nsimsub=nsim-1,
        alternative=c("two.sided", "less", "greater"),
        reuse = TRUE, leaveout=1, interpolate = FALSE,
        savefuns=FALSE, savepatterns=FALSE,
        verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dg.test_+3A_x">X</code></td>
<td>

<p>Either a point pattern dataset (object of class <code>"ppp"</code>,
<code>"lpp"</code> or <code>"pp3"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"lppm"</code>
or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+dclf.test">dclf.test</a></code> or
<code><a href="#topic+mad.test">mad.test</a></code> or <code><a href="#topic+envelope">envelope</a></code> to
control the conduct of the test.
Useful arguments include <code>fun</code> to determine the summary
function, <code>rinterval</code> to determine the range of
<code class="reqn">r</code> values used in the test, 
and <code>use.theory</code> described under Details. 
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_exponent">exponent</code></td>
<td>

<p>Exponent used in the test statistic. Use <code>exponent=2</code>
for the Diggle-Cressie-Loosmore-Ford test, and <code>exponent=Inf</code>
for the Maximum Absolute Deviation test.
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_nsim">nsim</code></td>
<td>

<p>Number of repetitions of the basic test.
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_nsimsub">nsimsub</code></td>
<td>

<p>Number of simulations in each basic test. There will be <code>nsim</code>
repetitions of the basic test, each involving <code>nsimsub</code> simulated
realisations, so there will be a total
of <code>nsim * (nsimsub + 1)</code> simulations.
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
The default (<code>alternative="two.sided"</code>) is that the
true value of the summary function is not equal to the theoretical
value postulated under the null hypothesis.
If <code>alternative="less"</code> the alternative hypothesis is that the
true value of the summary function is lower than the theoretical value.
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_reuse">reuse</code></td>
<td>

<p>Logical value indicating whether to re-use the first stage
simulations at the second stage, as described by Dao and Genton (2014).
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_leaveout">leaveout</code></td>
<td>

<p>Optional integer 0, 1 or 2 indicating how to calculate the
deviation between the observed summary function and the
nominal reference value, when the reference value must be estimated
by simulation. See Details.
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value indicating whether to interpolate the distribution of
the test statistic by kernel smoothing, as described in
Dao and Genton (2014, Section 5).
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
function values (from the first stage).
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save the simulated
point patterns (from the first stage). 
</p>
</td></tr>
<tr><td><code id="dg.test_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the Dao-Genton (2014) adjusted Monte Carlo goodness-of-fit
test, in the equivalent form described by Baddeley et al (2014).
</p>
<p>If <code>X</code> is a point pattern, the null hypothesis is CSR.
</p>
<p>If <code>X</code> is a fitted model, the null hypothesis is that model.
</p>
<p>The argument <code>use.theory</code> passed to <code><a href="#topic+envelope">envelope</a></code>
determines whether to compare the summary function for the data
to its theoretical value for CSR (<code>use.theory=TRUE</code>)
or to the sample mean of simulations from CSR
(<code>use.theory=FALSE</code>).
</p>
<p>The argument <code>leaveout</code> specifies how to calculate the
discrepancy between the summary function for the data and the
nominal reference value, when the reference value must be estimated
by simulation. The values <code>leaveout=0</code> and
<code>leaveout=1</code> are both algebraically equivalent (Baddeley et al, 2014,
Appendix) to computing the difference <code>observed - reference</code>
where the <code>reference</code> is the mean of simulated values.
The value <code>leaveout=2</code> gives the leave-two-out discrepancy
proposed by Dao and Genton (2014).
</p>
<p>The Dao-Genton test is biased when the significance level is very small
(small <code class="reqn">p</code>-values are not reliable) and
we recommend <code><a href="#topic+bits.test">bits.test</a></code> in this case.
</p>


<h3>Value</h3>

<p>A hypothesis test (object of class <code>"htest"</code>
which can be printed to show the outcome of the test.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Andrew Hardegen, Tom Lawrence,
Robin Milne, Gopalan Nair and Suman Rakshit.
Implemented by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Dao, N.A. and Genton, M. (2014)
A Monte Carlo adjusted goodness-of-fit test for
parametric models describing spatial point patterns.
<em>Journal of Graphical and Computational Statistics</em>
<b>23</b>, 497&ndash;517.
</p>
<p>Baddeley, A., Diggle, P.J., Hardegen, A., Lawrence, T., Milne,
R.K. and Nair, G. (2014) On tests of spatial pattern based on
simulation envelopes. <em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>
<p>Baddeley, A., Hardegen, A., Lawrence, L., 
Milne, R.K., Nair, G.M. and Rakshit, S. (2017)
On two-stage Monte Carlo tests of composite hypotheses.
<em>Computational Statistics and Data Analysis</em>
<b>114</b>, 75&ndash;87. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bits.test">bits.test</a></code>,
<code><a href="#topic+dclf.test">dclf.test</a></code>,
<code><a href="#topic+mad.test">mad.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ns &lt;- if(interactive()) 19 else 4
 dg.test(cells, nsim=ns)
 dg.test(cells, alternative="less", nsim=ns)
 dg.test(cells, nsim=ns, interpolate=TRUE)
</code></pre>

<hr>
<h2 id='dimhat'>
Estimate Dimension of Central Subspace 
</h2><span id='topic+dimhat'></span>

<h3>Description</h3>

<p>Given the kernel matrix that characterises a central subspace,
this function estimates the dimension of the subspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dimhat(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimhat_+3A_m">M</code></td>
<td>

<p>Kernel of subspace. A symmetric, non-negative definite, numeric
matrix, typically obtained from <code><a href="#topic+sdr">sdr</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the maximum descent estimate of
the dimension of the central subspace with a given kernel matrix <code>M</code>.
</p>
<p>The matrix <code>M</code> should be the kernel matrix of a central subspace,
which can be obtained from <code><a href="#topic+sdr">sdr</a></code>. It must be a symmetric,
non-negative-definite, numeric matrix.
</p>
<p>The algorithm finds the eigenvalues
<code class="reqn">\lambda_1 \ge \ldots \ge \lambda_n</code>
of <code class="reqn">M</code>,
and then determines the index <code class="reqn">k</code> for which
<code class="reqn">\lambda_k/\lambda_{k-1}</code> is greatest.
</p>


<h3>Value</h3>

<p>A single integer giving the estimated dimension.
</p>


<h3>Author(s)</h3>

<p>Matlab original by Yongtao Guan,
translated to <span class="rlang"><b>R</b></span> by Suman Rakshit.
</p>


<h3>References</h3>

<p>Guan, Y. and Wang, H. (2010)
Sufficient dimension reduction for spatial point
processes directed by Gaussian random fields.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 367&ndash;387.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdr">sdr</a></code>, <code><a href="#topic+subspaceDistance">subspaceDistance</a></code>
</p>

<hr>
<h2 id='distcdf'>Distribution Function of Interpoint Distance </h2><span id='topic+distcdf'></span>

<h3>Description</h3>

<p>Computes the cumulative distribution function of the distance
between two independent random points in a given window
or windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  distcdf(W, V=W, ..., dW=1, dV=dW, nr=1024,
          regularise=TRUE, savedenom=FALSE, delta=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distcdf_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) containing the
first random point.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_v">V</code></td>
<td>

<p>Optional. Another window containing the second random point.
Defaults to <code>W</code>.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine the
pixel resolution for the calculation.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_dv">dV</code>, <code id="distcdf_+3A_dw">dW</code></td>
<td>

<p>Optional. Probability densities (not necessarily normalised)
for the first and second random points respectively.
Data in any format acceptable
to <code>as.im</code>, for example, a <code>function(x,y)</code>
or a pixel image or a numeric value. The default
corresponds to a uniform distribution over the window.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_nr">nr</code></td>
<td>

<p>Integer. The number of values of interpoint distance <code class="reqn">r</code>
for which the CDF will be computed.
Should be a large value.
Alternatively if <code>nr=NULL</code>, a good default value will be
chosen, depending on the pixel resolution.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_regularise">regularise</code></td>
<td>

<p>Logical value indicating whether to smooth the results
for very small distances, to avoid discretisation artefacts.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_savedenom">savedenom</code></td>
<td>

<p>Logical value indicating whether to save the denominator of the
double integral as an attribute of the result.
</p>
</td></tr>
<tr><td><code id="distcdf_+3A_delta">delta</code></td>
<td>

<p>Optional. A positive number.
The maximum permitted spacing between values of the function argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the Cumulative Distribution Function
<code class="reqn">
    CDF(r) = Prob(T \le r)
  </code>
of the Euclidean distance <code class="reqn">T = \|X_1 - X_2\|</code>
between two independent random points <code class="reqn">X_1</code> and <code class="reqn">X_2</code>.
</p>
<p>In the simplest case, the command <code>distcdf(W)</code>, the random points are 
assumed to be uniformly distributed in the same
window <code>W</code>.
</p>
<p>Alternatively the two random points may be 
uniformly distributed in two different windows <code>W</code> and <code>V</code>.
</p>
<p>In the most general case the first point <code class="reqn">X_1</code> is random
in the window <code>W</code> with a probability density proportional to
<code>dW</code>, and the second point <code class="reqn">X_2</code> is random in
a different window <code>V</code> with probability density proportional
to <code>dV</code>. The values of <code>dW</code> and <code>dV</code> must be
finite and nonnegative.
</p>
<p>The calculation is performed by numerical integration of the set covariance
function <code>setcov</code> for uniformly distributed points, and
by computing the covariance function <code>imcov</code> in the
general case. The accuracy of the result depends on
the pixel resolution used to represent the windows: this is controlled
by the arguments <code>...</code> which are passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
For example use <code>eps=0.1</code> to specify pixels of size 0.1 units.
</p>
<p>The arguments <code>W</code> or <code>V</code> may also be point patterns
(objects of class <code>"ppp"</code>).
The result is the cumulative distribution function
of the distance from a randomly selected point in the point pattern,
to a randomly selected point in the other point pattern or window.
</p>
<p>If <code>regularise=TRUE</code> (the default), values of the cumulative
distribution function for very short distances are smoothed to avoid
discretisation artefacts. Smoothing is applied to all distances
shorter than the width of 10 pixels.
</p>
<p>Numerical accuracy of some calculations requires
very fine spacing of the values of the function argument <code>r</code>.
If the argument <code>delta</code> is given, then
after the cumulative distribution function
has been calculated, it will be interpolated onto a finer grid of <code>r</code>
values with spacing less than or equal to <code>delta</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>setcov</code>,
<code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # The unit disc
 B &lt;- disc()
 plot(distcdf(B))
</code></pre>

<hr>
<h2 id='dkernel'>Kernel distributions and random generation</h2><span id='topic+dkernel'></span><span id='topic+pkernel'></span><span id='topic+qkernel'></span><span id='topic+rkernel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for several distributions used in kernel estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkernel(x, kernel = "gaussian", mean = 0, sd = 1)
pkernel(q, kernel = "gaussian", mean = 0, sd = 1, lower.tail = TRUE)
qkernel(p, kernel = "gaussian", mean = 0, sd = 1, lower.tail = TRUE)
rkernel(n, kernel = "gaussian", mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkernel_+3A_x">x</code>, <code id="dkernel_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="dkernel_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_mean">mean</code></td>
<td>
<p>Mean of distribution.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of distribution.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default),
then probabilities are <code class="reqn">P(X \le x)</code>,
otherwise, <code class="reqn">P(X &gt; x)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions give the
probability density, cumulative distribution function,
quantile function and random generation for several
distributions used in kernel estimation for one-dimensional
(numerical) data.
</p>
<p>The available kernels are those used in <code><a href="stats.html#topic+density.default">density.default</a></code>,
namely <code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>
<p><code>dkernel</code> gives the probability density,
<code>pkernel</code> gives the cumulative distribution function,
<code>qkernel</code> gives the quantile function,
and <code>rkernel</code> generates random deviates.
</p>


<h3>Value</h3>

<p>A numeric vector.
For <code>dkernel</code>, a vector of the same length as <code>x</code>
containing the corresponding values of the probability density.
For <code>pkernel</code>, a vector of the same length as <code>x</code>
containing the corresponding values of the cumulative distribution function.
For <code>qkernel</code>, a vector of the same length as <code>p</code>
containing the corresponding quantiles.
For <code>rkernel</code>, a vector of length <code>n</code>
containing randomly generated values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(-3,3,length=100)
  plot(x, dkernel(x, "epa"), type="l",
           main=c("Epanechnikov kernel", "probability density"))
  plot(x, pkernel(x, "opt"), type="l",
           main=c("OptCosine kernel", "cumulative distribution function"))
  p &lt;- seq(0,1, length=256)
  plot(p, qkernel(p, "biw"), type="l",
           main=c("Biweight kernel", "cumulative distribution function"))
  y &lt;- rkernel(100, "tri")
  hist(y, main="Random variates from triangular density")
  rug(y)
</code></pre>

<hr>
<h2 id='domain.quadrattest'>
Extract the Domain of any Spatial Object
</h2><span id='topic+domain.quadrattest'></span>

<h3>Description</h3>

<p>Given a spatial object such as a point pattern, in any number of dimensions,
this function extracts the spatial domain in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

 ## S3 method for class 'quadrattest'
domain(X, ...)



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain.quadrattest_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern (in any number
of dimensions), line segment pattern or pixel image.
</p>
</td></tr>
<tr><td><code id="domain.quadrattest_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+domain">domain</a></code> is generic.
</p>
<p>For a spatial object <code>X</code> in any number of dimensions, 
<code>domain(X)</code> extracts the spatial domain in which <code>X</code> is
defined.
</p>
<p>For a two-dimensional object <code>X</code>, typically <code>domain(X)</code>
is the same as <code>Window(X)</code>.
</p>
<p>Exceptions occur for methods related to linear networks.
</p>


<h3>Value</h3>

<p>A spatial object representing the domain of <code>X</code>.
Typically a window (object of class <code>"owin"</code>),
a three-dimensional box (<code>"box3"</code>), a multidimensional
box (<code>"boxx"</code>) or a linear network (<code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+domain">domain</a></code>,
<code><a href="spatstat.geom.html#topic+domain.quadratcount">domain.quadratcount</a></code>,
<code><a href="spatstat.model.html#topic+domain.ppm">domain.ppm</a></code>,
<code><a href="spatstat.random.html#topic+domain.rmhmodel">domain.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+domain.lpp">domain.lpp</a></code>.
<code>Window</code>,
<code>Frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  domain(quadrat.test(redwood, 2, 2))
</code></pre>

<hr>
<h2 id='edge.Ripley'>
Ripley's Isotropic Edge Correction 
</h2><span id='topic+edge.Ripley'></span><span id='topic+rmax.Ripley'></span>

<h3>Description</h3>

<p>Computes Ripley's isotropic edge correction weights
for a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.Ripley(X, r, W = Window(X), method = c("C", "interpreted"),
            maxweight = 100, internal=list())

rmax.Ripley(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.Ripley_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="edge.Ripley_+3A_w">W</code></td>
<td>

<p>Window for which the edge correction is required.
</p>
</td></tr>
<tr><td><code id="edge.Ripley_+3A_r">r</code></td>
<td>

<p>Vector or matrix of interpoint distances for which the edge correction
should be computed.
</p>
</td></tr>
<tr><td><code id="edge.Ripley_+3A_method">method</code></td>
<td>

<p>Choice of algorithm. Either <code>"interpreted"</code> or <code>"C"</code>.
This is needed only for debugging purposes.
</p>
</td></tr>
<tr><td><code id="edge.Ripley_+3A_maxweight">maxweight</code></td>
<td>

<p>Maximum permitted value of the edge correction weight.
</p>
</td></tr>
<tr><td><code id="edge.Ripley_+3A_internal">internal</code></td>
<td>
<p>For developer use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>edge.Ripley</code>
computes Ripley's (1977) isotropic edge correction
weight, which is used in estimating the <code class="reqn">K</code> function and in many
other contexts.
</p>
<p>The function <code>rmax.Ripley</code> computes the maximum value of
distance <code class="reqn">r</code> for which the isotropic edge correction
estimate of <code class="reqn">K(r)</code> is valid.
</p>
<p>For a single point <code class="reqn">x</code> in a window <code class="reqn">W</code>,
and a distance <code class="reqn">r &gt; 0</code>, the isotropic edge correction weight
is
</p>
<p style="text-align: center;"><code class="reqn">
    e(u, r) = \frac{2\pi r}{\mbox{length}(c(u,r) \cap W)}
  </code>
</p>

<p>where <code class="reqn">c(u,r)</code> is the circle of radius <code class="reqn">r</code> centred at the
point <code class="reqn">u</code>. The denominator is the length of the overlap between
this circle and the window <code class="reqn">W</code>.
</p>
<p>The function <code>edge.Ripley</code> computes this edge correction weight
for each point in the point pattern <code>X</code> and for each
corresponding distance value in the vector or matrix <code>r</code>.
</p>
<p>If <code>r</code> is a vector, with one entry for each point in
<code>X</code>, then the result is a vector containing the
edge correction weights <code>e(X[i], r[i])</code> for each <code>i</code>.
</p>
<p>If <code>r</code> is a matrix, with one row for each point in <code>X</code>,
then the result is a matrix whose <code>i,j</code> entry gives the
edge correction weight <code>e(X[i], r[i,j])</code>.
For example <code>edge.Ripley(X, pairdist(X))</code> computes all the
edge corrections required for the <code class="reqn">K</code>-function.
</p>
<p>If any value of the edge correction weight exceeds <code>maxwt</code>,
it is set to <code>maxwt</code>.
</p>
<p>The function <code>rmax.Ripley</code> computes the smallest distance <code class="reqn">r</code>
such that it is possible to draw a circle of radius <code class="reqn">r</code>, centred
at a point of <code>W</code>, such that the circle does not intersect the
interior of <code>W</code>. 
</p>


<h3>Value</h3>

<p>A numeric vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edge.Trans">edge.Trans</a></code>,
<code><a href="#topic+rmax.Trans">rmax.Trans</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  v &lt;- edge.Ripley(cells, pairdist(cells))

  rmax.Ripley(Window(cells))
</code></pre>

<hr>
<h2 id='edge.Trans'>
Translation Edge Correction
</h2><span id='topic+edge.Trans'></span><span id='topic+rmax.Trans'></span>

<h3>Description</h3>

<p>Computes Ohser and Stoyan's translation edge correction weights
for a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.Trans(X, Y = X, W = Window(X),
      exact = FALSE, paired = FALSE,
      ..., 
      trim = spatstat.options("maxedgewt"),
      dx=NULL, dy=NULL,
      give.rmax=FALSE, gW=NULL)

rmax.Trans(W, g=setcov(W))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.Trans_+3A_x">X</code>, <code id="edge.Trans_+3A_y">Y</code></td>
<td>

<p>Point patterns (objects of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_w">W</code></td>
<td>

<p>Window for which the edge correction is required.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_exact">exact</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a slow algorithm will be used
to compute the exact value. If <code>FALSE</code>, a fast algorithm
will be used to compute the approximate value.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_paired">paired</code></td>
<td>

<p>Logical value indicating whether <code>X</code> and <code>Y</code>
are paired. If <code>TRUE</code>, compute
the edge correction for corresponding points
<code>X[i], Y[i]</code> for all <code>i</code>.
If <code>FALSE</code>, compute the edge correction for
each possible pair of points <code>X[i], Y[j]</code>
for all <code>i</code> and <code>j</code>.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_trim">trim</code></td>
<td>

<p>Maximum permitted value of the edge correction weight.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_dx">dx</code>, <code id="edge.Trans_+3A_dy">dy</code></td>
<td>

<p>Alternative data giving the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
of the vector differences between the points.
Incompatible with <code>X</code> and <code>Y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_give.rmax">give.rmax</code></td>
<td>

<p>Logical. If <code>TRUE</code>, also compute the value of
<code>rmax.Trans(W)</code> and return it as an attribute
of the result.
</p>
</td></tr>
<tr><td><code id="edge.Trans_+3A_g">g</code>, <code id="edge.Trans_+3A_gw">gW</code></td>
<td>

<p>Optional. Set covariance of <code>W</code>, if it has already been
computed. Not required if <code>W</code> is a rectangle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>edge.Trans</code>
computes Ohser and Stoyan's translation edge correction
weight, which is used in estimating the <code class="reqn">K</code> function and in many
other contexts.
</p>
<p>The function <code>rmax.Trans</code> computes the maximum value of
distance <code class="reqn">r</code> for which the translation edge correction
estimate of <code class="reqn">K(r)</code> is valid.
</p>
<p>For a pair of points <code class="reqn">x</code> and <code class="reqn">y</code> in a window <code class="reqn">W</code>,
the translation edge correction weight
is
</p>
<p style="text-align: center;"><code class="reqn">
    e(u, r) = \frac{\mbox{area}(W)}{\mbox{area}(W \cap (W + y - x))}
  </code>
</p>

<p>where <code class="reqn">W + y - x</code> is the result of shifting the window <code class="reqn">W</code>
by the vector <code class="reqn">y - x</code>. The denominator is the area of the overlap between
this shifted window and the original window.
</p>
<p>The function <code>edge.Trans</code> computes this edge correction weight.
If <code>paired=TRUE</code>, then <code>X</code> and <code>Y</code> should contain the
same number of points. The result is a vector containing the
edge correction weights <code>e(X[i], Y[i])</code> for each <code>i</code>.
</p>
<p>If <code>paired=FALSE</code>, 
then the result is a matrix whose <code>i,j</code> entry gives the
edge correction weight <code>e(X[i], Y[j])</code>.
</p>
<p>Computation is exact if the window is a rectangle.
Otherwise,
</p>

<ul>
<li><p> if <code>exact=TRUE</code>, the edge
correction weights are computed exactly using 
<code>overlap.owin</code>, which can be quite slow.
</p>
</li>
<li><p> if <code>exact=FALSE</code> (the default),
the weights are computed rapidly by evaluating the
set covariance function <code>setcov</code>
using the Fast Fourier Transform.
</p>
</li></ul>

<p>If any value of the edge correction weight exceeds <code>trim</code>,
it is set to <code>trim</code>.
</p>
<p>The arguments <code>dx</code> and <code>dy</code> can be provided as
an alternative to <code>X</code> and <code>Y</code>.
If <code>paired=TRUE</code> then <code>dx,dy</code> should be vectors of equal length
such that the vector difference of the <code class="reqn">i</code>th pair is
<code>c(dx[i], dy[i])</code>. If <code>paired=FALSE</code> then 
<code>dx,dy</code> should be matrices of the same dimensions,
such that the vector difference between <code>X[i]</code> and <code>Y[j]</code> is
<code>c(dx[i,j], dy[i,j])</code>. The argument <code>W</code> is needed.
</p>
<p>The value of <code>rmax.Trans</code> is the shortest distance from the
origin <code class="reqn">(0,0)</code> to the boundary of the support of
the set covariance function of <code>W</code>. It is computed by pixel
approximation using <code>setcov</code>, unless <code>W</code> is a
rectangle, when <code>rmax.Trans(W)</code> is the length of the
shortest side of the rectangle.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Ohser, J. (1983)
On estimators for the reduced second moment measure of
point processes. <em>Mathematische Operationsforschung und
Statistik, series Statistics</em>, <b>14</b>, 63 &ndash; 71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmax.Trans">rmax.Trans</a></code>,
<code><a href="#topic+edge.Ripley">edge.Ripley</a></code>,
<code>setcov</code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  v &lt;- edge.Trans(cells)
  rmax.Trans(Window(cells))
</code></pre>

<hr>
<h2 id='Emark'>
Diagnostics for random marking
</h2><span id='topic+Emark'></span><span id='topic+Vmark'></span>

<h3>Description</h3>

<p>Estimate the summary functions <code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> for 
a marked point pattern, proposed by Schlather et al (2004) as diagnostics 
for dependence between the points and the marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Emark(X, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
Vmark(X, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Emark_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. The pattern should have numeric marks.
</p>
</td></tr>
<tr><td><code id="Emark_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code> should be evaluated.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Emark_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</p>
</td></tr>
<tr><td><code id="Emark_+3A_method">method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td></tr>
<tr><td><code id="Emark_+3A_...">...</code></td>
<td>

<p>Arguments passed to the density estimation routine
(<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+loess">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td></tr>
<tr><td><code id="Emark_+3A_normalise">normalise</code></td>
<td>

<p>If<code>TRUE</code>, normalise the estimate of <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
so that it would have value equal to 1 if the marks are independent
of the points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a marked point process,
Schlather et al (2004) defined the functions
<code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> to be the conditional mean
and conditional variance of the mark attached to a
typical random point, given that there exists another random
point at a distance <code class="reqn">r</code> away from it.
</p>
<p>More formally,
</p>
<p style="text-align: center;"><code class="reqn">
    E(r) = E_{0u}[M(0)]
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    V(r) = E_{0u}[(M(0)-E(u))^2]
  </code>
</p>

<p>where <code class="reqn">E_{0u}</code> denotes the conditional expectation
given that there are points of the process at the locations
<code class="reqn">0</code> and <code class="reqn">u</code> separated by a distance <code class="reqn">r</code>,
and where <code class="reqn">M(0)</code> denotes the mark attached to the point <code class="reqn">0</code>. 
</p>
<p>These functions may serve as diagnostics for dependence
between the points and the marks. If the points and marks are
independent, then <code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> should be
constant (not depending on <code class="reqn">r</code>). See Schlather et al (2004).
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern with numeric marks.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">k_f(r)</code> is estimated.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks).
</p>
</dd>
<dt>translate</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
</dl>

<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The numerator and denominator of the mark correlation function
(in the expression above) are estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt><dd>
<p>which uses the standard kernel
density estimation routine <code><a href="stats.html#topic+density">density</a></code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt><dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>If <code>marks(X)</code> is a numeric vector, the result is 
an object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
If <code>marks(X)</code> is a data frame, the result is
a list of objects of class <code>"fv"</code>, one for each column of marks.
</p>
<p>An object of class <code>"fv"</code> is essentially
a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
has been estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical, constant value of <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
when the marks attached to different points are independent
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Schlather, M. and Ribeiro, P. and Diggle, P. (2004)
Detecting dependence between marks and locations of
marked point processes.
<em>Journal of the Royal Statistical Society, series B</em>
<b>66</b> (2004) 79-83.
</p>


<h3>See Also</h3>

<p>Mark correlation <code><a href="#topic+markcorr">markcorr</a></code>,
mark variogram <code><a href="#topic+markvario">markvario</a></code> for numeric marks.
</p>
<p>Mark connection function <code><a href="#topic+markconnect">markconnect</a></code> and 
multitype K-functions <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>
for factor-valued marks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    plot(Emark(spruces))
    E &lt;- Emark(spruces, method="density", kernel="epanechnikov")
    plot(Vmark(spruces))

    plot(Emark(finpines))
    V &lt;- Vmark(finpines)
</code></pre>

<hr>
<h2 id='envelope'>Simulation Envelopes of Summary Function</h2><span id='topic+envelope'></span><span id='topic+envelope.ppp'></span>

<h3>Description</h3>

<p>Computes simulation envelopes of a summary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  envelope(Y, fun, ...)

  ## S3 method for class 'ppp'
envelope(Y, fun=Kest, nsim=99, nrank=1, ...,
  funargs=list(), funYargs=funargs,
  simulate=NULL,  fix.n=FALSE, fix.marks=FALSE,
  verbose=TRUE, clipdata=TRUE,
  transform=NULL, global=FALSE, ginterval=NULL, use.theory=NULL, 
  alternative=c("two.sided", "less", "greater"),
  scale=NULL, clamp=FALSE, 
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL,
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_y">Y</code></td>
<td>

<p>Object containing point pattern data.
A point pattern (object of class
<code>"ppp"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="envelope_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern. 
</p>
</td></tr>
<tr><td><code id="envelope_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns to be generated
when computing the envelopes.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_funargs">funargs</code></td>
<td>

<p>A list, containing extra arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_funyargs">funYargs</code></td>
<td>

<p>Optional. A list, containing extra arguments to be passed to
<code>fun</code> when applied to the original data <code>Y</code> only.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_simulate">simulate</code></td>
<td>

<p>Optional. Specifies how to generate the simulated point patterns.
If <code>simulate</code> is an expression in the R language, then this
expression will be evaluated <code>nsim</code> times,
to obtain <code>nsim</code> point patterns which are taken as the
simulated patterns from which the envelopes are computed.
If <code>simulate</code> is a function, then this function will be
repeatedly applied to the data pattern <code>Y</code> to obtain
<code>nsim</code> simulated patterns.
If <code>simulate</code> is a list of point patterns, then the entries
in this list will be treated as the simulated patterns from which
the envelopes are computed.
Alternatively <code>simulate</code> may be an object produced by the
<code>envelope</code> command: see Details.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_fix.n">fix.n</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points as the original data pattern.
This option is currently not available for <code>envelope.kppm</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_fix.marks">fix.marks</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points <em>and</em> the same marks as the
original data pattern. In a multitype point pattern this means that
the simulated patterns will have the same number of points
<em>of each type</em> as the original data.
This option is currently not available for <code>envelope.kppm</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
during the simulations.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_clipdata">clipdata</code></td>
<td>

<p>Logical flag indicating whether the data point pattern should be
clipped to the same window as the simulated patterns,
before the summary function for the data is computed.
This should usually be <code>TRUE</code> to ensure that the
data and simulations are properly comparable.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_transform">transform</code></td>
<td>

<p>Optional. A transformation to be applied to the
function values, before the envelopes are computed.
An expression object (see Details).
</p>
</td></tr>
<tr><td><code id="envelope_+3A_global">global</code></td>
<td>

<p>Logical flag indicating whether envelopes should be pointwise
(<code>global=FALSE</code>) or simultaneous (<code>global=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="envelope_+3A_ginterval">ginterval</code></td>
<td>

<p>Optional.
A vector of length 2 specifying
the interval of <code class="reqn">r</code> values for the simultaneous critical
envelopes. Only relevant if <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_use.theory">use.theory</code></td>
<td>

<p>Logical value indicating whether to use the theoretical value,
computed by <code>fun</code>, as the reference value for simultaneous
envelopes. Applicable only when <code>global=TRUE</code>.
Default is <code>use.theory=TRUE</code> if <code>Y</code> is a point pattern,
or a point process model equivalent to Complete Spatial Randomness,
and <code>use.theory=FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>side="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>side="less"</code>) or a one-sided test
with an upper critical boundary (<code>side="greater"</code>).
</p>
</td></tr>
<tr><td><code id="envelope_+3A_scale">scale</code></td>
<td>

<p>Optional. Scaling function for global envelopes.
A function in the <span class="rlang"><b>R</b></span> language which determines the
relative scale of deviations, as a function of
distance <code class="reqn">r</code>, when computing the global envelopes.
Applicable only when <code>global=TRUE</code>.
Summary function values for distance <code>r</code>
will be <em>divided</em> by <code>scale(r)</code> before the
maximum deviation is computed. The resulting global envelopes
will have width proportional to <code>scale(r)</code>. 
</p>
</td></tr>
<tr><td><code id="envelope_+3A_clamp">clamp</code></td>
<td>

<p>Logical value indicating how to compute envelopes when
<code>alternative="less"</code> or <code>alternative="greater"</code>.
Deviations of the observed
summary function from the theoretical summary function are initially
evaluated as signed real numbers, with large positive values indicating
consistency with the alternative hypothesis.
If <code>clamp=FALSE</code> (the default), these values are not changed.
If <code>clamp=TRUE</code>, any negative values are replaced by zero.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
function values.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
point patterns.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_nsim2">nsim2</code></td>
<td>

<p>Number of extra simulated point patterns to be generated
if it is necessary to use simulation to estimate the theoretical
mean of the summary function. Only relevant when <code>global=TRUE</code>
and the simulations are not based on CSR.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_variance">VARIANCE</code></td>
<td>

<p>Logical. If <code>TRUE</code>, critical envelopes will be calculated
as sample mean plus or minus <code>nSD</code> times sample standard
deviation.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_nsd">nSD</code></td>
<td>

<p>Number of estimated standard deviations used to determine
the critical envelopes, if <code>VARIANCE=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_yname">Yname</code></td>
<td>

<p>Character string that should be used as the name of the 
data point pattern <code>Y</code> when printing or plotting the results.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_maxnerr">maxnerr</code></td>
<td>

<p>Maximum number of rejected patterns.
If <code>fun</code> yields a fatal error when applied to a simulated point
pattern (for example, because the pattern is empty and <code>fun</code>
requires at least one point), the pattern will be rejected
and a new random point pattern will be generated. If this happens
more than <code>maxnerr</code> times, the algorithm will give up.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_rejectna">rejectNA</code></td>
<td>

<p>Logical value specifying whether to reject a simulated pattern
if the resulting values of <code>fun</code> are all equal to <code>NA</code>,
<code>NaN</code> or infinite. If <code>FALSE</code> (the default), then
simulated patterns are only rejected when <code>fun</code> gives a
fatal error. 
</p>
</td></tr>
<tr><td><code id="envelope_+3A_silent">silent</code></td>
<td>

<p>Logical value specifying whether to print a report each time
a simulated pattern is rejected.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_do.pwrong">do.pwrong</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the algorithm will also estimate
the true significance level of the &ldquo;wrong&rdquo; test (the test that
declares the summary function for the data to be significant
if it lies outside the <em>pointwise</em> critical boundary at any
point). This estimate is printed when the result is printed.
</p>
</td></tr>
<tr><td><code id="envelope_+3A_envir.simul">envir.simul</code></td>
<td>

<p>Environment in which to evaluate the expression <code>simulate</code>,
if not the current environment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>envelope</code> command performs simulations and
computes envelopes of a summary statistic based on the simulations.
The result is an object that can be plotted to display the envelopes.
The envelopes can be used to assess the goodness-of-fit of
a point process model to point pattern data.
</p>
<p>For the most basic use, if you have a point pattern <code>X</code> and
you want to test Complete Spatial Randomness (CSR), type
<code>plot(envelope(X, Kest,nsim=39))</code> to see the <code class="reqn">K</code> function
for <code>X</code> plotted together with the envelopes of the
<code class="reqn">K</code> function for 39 simulations of CSR. 
</p>
<p>The <code>envelope</code> function is generic, with methods for
the classes <code>"ppp"</code>, <code>"ppm"</code>, <code>"kppm"</code> and <code>"slrm"</code>
described here. There are also methods for the classes <code>"pp3"</code>,
<code>"lpp"</code> and <code>"lppm"</code> which are described separately
under <code><a href="#topic+envelope.pp3">envelope.pp3</a></code>
and <code>envelope.lpp</code>.
Envelopes can also be computed from other envelopes, using
<code><a href="#topic+envelope.envelope">envelope.envelope</a></code>.
</p>
<p>To create simulation envelopes, the command <code>envelope(Y, ...)</code> 
first generates <code>nsim</code> random point patterns
in one of the following ways. 
</p>

<ul>
<li> 
<p>If <code>Y</code> is a point pattern (an object of class <code>"ppp"</code>)
and <code>simulate=NULL</code>,
then we generate <code>nsim</code> simulations of
Complete Spatial Randomness (i.e. <code>nsim</code> simulated point patterns
each being a realisation of the uniform Poisson point process)
with the same intensity as the pattern <code>Y</code>.
(If <code>Y</code> is a multitype point pattern, then the simulated patterns
are also given independent random marks; the probability
distribution of the random marks is determined by the
relative frequencies of marks in <code>Y</code>.)
</p>
</li>
<li>
<p>If <code>Y</code> is a fitted point process model (an object of class
<code>"ppm"</code> or <code>"kppm"</code> or <code>"slrm"</code>) and <code>simulate=NULL</code>,
then this routine generates <code>nsim</code> simulated
realisations of that model.
</p>
</li>
<li>
<p>If <code>simulate</code> is supplied, then it determines how the
simulated point patterns are generated. It may be either
</p>

<ul>
<li>
<p>an expression in the R language, typically containing a call
to a random generator. This expression will be evaluated
<code>nsim</code> times to yield <code>nsim</code> point patterns. For example
if <code>simulate=expression(runifpoint(100))</code> then each simulated
pattern consists of exactly 100 independent uniform random points.
</p>
</li>
<li>
<p>a function in the R language, typically containing a call to a
random generator. This function will be applied repeatedly
to the original data pattern <code>Y</code> to yield <code>nsim</code> point
patterns. For example if <code>simulate=rlabel</code> then each
simulated pattern was generated by evaluating <code>rlabel(Y)</code>
and consists of a randomly-relabelled version of <code>Y</code>.
</p>
</li>
<li>
<p>a list of point patterns.
The entries in this list will be taken as the simulated patterns.
</p>
</li>
<li>
<p>an object of class <code>"envelope"</code>. This should have been
produced by calling <code>envelope</code> with the
argument <code>savepatterns=TRUE</code>.
The simulated point patterns that were saved in this object
will be extracted and used as the simulated patterns for the
new envelope computation. This makes it possible to plot envelopes
for two different summary functions based on exactly the same set of
simulated point patterns.
</p>
</li></ul>

</li></ul>

<p>The summary statistic <code>fun</code> is applied to each of these simulated
patterns. Typically <code>fun</code> is one of the functions
<code>Kest</code>, <code>Gest</code>, <code>Fest</code>, <code>Jest</code>, <code>pcf</code>,
<code>Kcross</code>, <code>Kdot</code>, <code>Gcross</code>, <code>Gdot</code>,
<code>Jcross</code>, <code>Jdot</code>, <code>Kmulti</code>, <code>Gmulti</code>,
<code>Jmulti</code> or <code>Kinhom</code>. It may also be a character string
containing the name of one of these functions.
</p>
<p>The statistic <code>fun</code> can also be a user-supplied function;
if so, then it must have arguments <code>X</code> and <code>r</code>
like those in the functions listed above, and it must return an object
of class <code>"fv"</code>.
</p>
<p>Upper and lower critical envelopes are computed in one of the following ways:
</p>

<dl>
<dt>pointwise:</dt><dd><p>by default, envelopes are calculated pointwise
(i.e. for each value of the distance argument <code class="reqn">r</code>), by sorting the
<code>nsim</code> simulated values, and taking the <code>m</code>-th lowest
and <code>m</code>-th highest values, where <code>m = nrank</code>.
For example if <code>nrank=1</code>, the upper and lower envelopes
are the pointwise maximum and minimum of the simulated values.
</p>
<p>The pointwise envelopes are <b>not</b> &ldquo;confidence bands&rdquo;
for the true value of the function! Rather,
they specify the critical points for a Monte Carlo test
(Ripley, 1981). The test is constructed by choosing a
<em>fixed</em> value of <code class="reqn">r</code>, and rejecting the null hypothesis if the
observed function value
lies outside the envelope <em>at this value of</em> <code class="reqn">r</code>.
This test has exact significance level
<code>alpha = 2 * nrank/(1 + nsim)</code>.
</p>
</dd>
<dt>simultaneous:</dt><dd><p>if <code>global=TRUE</code>, then the envelopes are
determined as follows. First we calculate the theoretical mean value of
the summary statistic (if we are testing CSR, the theoretical
value is supplied by <code>fun</code>; otherwise we perform a separate
set of <code>nsim2</code> simulations, compute the
average of all these simulated values, and take this average
as an estimate of the theoretical mean value). Then, for each simulation,
we compare the simulated curve to the theoretical curve, and compute the
maximum absolute difference between them (over the interval
of <code class="reqn">r</code> values specified by <code>ginterval</code>). This gives a
deviation value <code class="reqn">d_i</code> for each of the <code>nsim</code>
simulations. Finally we take the <code>m</code>-th largest of the
deviation values, where <code>m=nrank</code>, and call this
<code>dcrit</code>. Then the simultaneous envelopes are of the form
<code>lo = expected - dcrit</code> and <code>hi = expected + dcrit</code> where
<code>expected</code> is either the theoretical mean value <code>theo</code>
(if we are testing CSR) or the estimated theoretical value
<code>mmean</code> (if we are testing another model). The simultaneous critical
envelopes have constant width <code>2 * dcrit</code>.
</p>
<p>The simultaneous critical envelopes allow us to perform a different
Monte Carlo test (Ripley, 1981). The test rejects the null
hypothesis if the graph of the observed function
lies outside the envelope <b>at any value of</b> <code class="reqn">r</code>.
This test has exact significance level
<code>alpha = nrank/(1 + nsim)</code>.
</p>
<p>This test can also be performed using <code><a href="#topic+mad.test">mad.test</a></code>.
</p>
</dd>
<dt>based on sample moments:</dt><dd><p>if <code>VARIANCE=TRUE</code>,
the algorithm calculates the
(pointwise) sample mean and sample variance of
the simulated functions. Then the envelopes are computed
as mean plus or minus <code>nSD</code> standard deviations.
These envelopes do not have an exact significance interpretation.
They are a naive approximation to
the critical points of the Neyman-Pearson test
assuming the summary statistic is approximately Normally
distributed.
</p>
</dd>
</dl>

<p>The return value is an object of class <code>"fv"</code> containing
the summary function for the data point pattern,
the upper and lower simulation envelopes, and 
the theoretical expected value (exact or estimated) of the summary function 
for the model being tested. It can be plotted
using <code><a href="#topic+plot.envelope">plot.envelope</a></code>.
</p>
<p>If <code>VARIANCE=TRUE</code> then the return value also includes the
sample mean, sample variance and other quantities.
</p>
<p>Arguments can be passed to the function <code>fun</code> through
<code>...</code>. This means that you simply specify these arguments in the call to
<code>envelope</code>, and they will be passed to <code>fun</code>.
In particular, the argument <code>correction</code>
determines the edge correction to be used to calculate the summary
statistic. See the section on Edge Corrections, and the Examples.
</p>
<p>Arguments can also be passed to the function <code>fun</code>
through the list <code>funargs</code>. This mechanism is typically used if
an argument of <code>fun</code> has the same name as an argument of
<code>envelope</code>. The list <code>funargs</code> should contain
entries of the form <code>name=value</code>, where each <code>name</code> is the name
of an argument of <code>fun</code>.
</p>
<p>There is also an option, rarely used, in which different function
arguments are used when computing the summary function
for the data <code>Y</code> and for the simulated patterns.
If <code>funYargs</code> is given, it will be used
when the summary function for the data <code>Y</code> is computed,
while <code>funargs</code> will be used when computing the summary function
for the simulated patterns.
This option is only needed in rare cases: usually the basic principle
requires that the data and simulated patterns must be treated
equally, so that <code>funargs</code> and <code>funYargs</code> should be identical.
</p>
<p>If <code>Y</code> is a fitted cluster point process model (object of
class <code>"kppm"</code>), and <code>simulate=NULL</code>,
then the model is simulated directly
using <code><a href="spatstat.model.html#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>If <code>Y</code> is a fitted Gibbs point process model (object of
class <code>"ppm"</code>), and <code>simulate=NULL</code>,
then the model is simulated
by running the Metropolis-Hastings algorithm <code>rmh</code>.
Complete control over this algorithm is provided by the 
arguments <code>start</code> and <code>control</code> which are passed
to <code>rmh</code>.
</p>
<p>For simultaneous critical envelopes (<code>global=TRUE</code>)
the following options are also useful:
</p>

<dl>
<dt><code>ginterval</code></dt><dd><p>determines the interval of <code class="reqn">r</code> values
over which the deviation between curves is calculated.
It should be a numeric vector of length 2.
There is a sensible default (namely, the recommended plotting
interval for <code>fun(X)</code>, or the range of <code>r</code> values if
<code>r</code> is explicitly specified).
</p>
</dd>
<dt><code>transform</code></dt><dd><p>specifies a transformation of the
summary function <code>fun</code> that will be carried out before the
deviations are computed.
Such transforms are useful if <code>global=TRUE</code> or
<code>VARIANCE=TRUE</code>.
The <code>transform</code> must be an expression object
using the symbol <code>.</code> to represent the function value
(and possibly other symbols recognised by <code><a href="#topic+with.fv">with.fv</a></code>).
For example, 
the conventional way to normalise the <code class="reqn">K</code> function
(Ripley, 1981) is to transform it to the <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>
and this is implemented by setting
<code>transform=expression(sqrt(./pi))</code>.
</p>
</dd>
</dl>

<p>It is also possible to extract the summary functions for each of the
individual simulated point patterns, by setting <code>savefuns=TRUE</code>.
Then the return value also 
has an attribute <code>"simfuns"</code> containing all the 
summary functions for the individual simulated patterns.
It is an <code>"fv"</code> object containing
functions named <code>sim1, sim2, ...</code> representing the <code>nsim</code>
summary functions.
</p>
<p>It is also possible to save the simulated point patterns themselves,
by setting <code>savepatterns=TRUE</code>. Then the return value also has
an attribute <code>"simpatterns"</code> which is a list of length
<code>nsim</code> containing all the simulated point patterns.
</p>
<p>See <code><a href="#topic+plot.envelope">plot.envelope</a></code> and <code><a href="#topic+plot.fv">plot.fv</a></code>
for information about how to plot the envelopes.
</p>
<p>Different envelopes can be recomputed from the same data
using <code><a href="#topic+envelope.envelope">envelope.envelope</a></code>.
Envelopes can be combined using <code><a href="#topic+pool.envelope">pool.envelope</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"envelope"</code>
and <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be printed and plotted directly.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the summary function <code>fun</code> has been  estimated
</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>

<p>values of the summary function for the data point pattern
</p>
</td></tr>
<tr><td><code>lo</code></td>
<td>

<p>lower envelope of simulations
</p>
</td></tr>
<tr><td><code>hi</code></td>
<td>

<p>upper envelope of simulations
</p>
</td></tr>
</table>
<p>and <em>either</em>
</p>
<table>
<tr><td><code>theo</code></td>
<td>

<p>theoretical value of the summary function under CSR
(Complete Spatial Randomness, a uniform Poisson point process)
if the simulations were generated according to CSR
</p>
</td></tr>
<tr><td><code>mmean</code></td>
<td>

<p>estimated theoretical value of the summary function,
computed by averaging simulated values, 
if the simulations were not generated according to CSR.
</p>
</td></tr>
</table>
<p>Additionally, if <code>savepatterns=TRUE</code>, the return value has an attribute
<code>"simpatterns"</code> which is a list containing the <code>nsim</code>
simulated patterns. If <code>savefuns=TRUE</code>, the return value
has an attribute <code>"simfuns"</code> which is an object of class
<code>"fv"</code> containing the summary functions
computed for each of the <code>nsim</code> simulated patterns.
</p>


<h3>Errors and warnings</h3>

<p>An error may be generated if one of the simulations produces a
point pattern that is empty, or is otherwise unacceptable to the
function <code>fun</code>.
</p>
<p>The upper envelope may be <code>NA</code> (plotted as plus or minus
infinity) if some of the function values
computed for the simulated point patterns are <code>NA</code>.
Whether this occurs will depend on the function <code>fun</code>,
but it usually happens when the simulated point pattern does not contain
enough points to compute a meaningful value.
</p>


<h3>Confidence intervals</h3>

<p>Simulation envelopes do <b>not</b> compute confidence intervals;
they generate significance bands. 
If you really need a confidence interval for the true summary function
of the point process, use <code><a href="#topic+lohboot">lohboot</a></code>.
See also <code><a href="#topic+varblock">varblock</a></code>.
</p>


<h3>Edge corrections</h3>

<p>It is common to apply a correction for edge effects when
calculating a summary function such as the <code class="reqn">K</code> function.
Typically the user has a choice between several possible edge
corrections.
In a call to <code>envelope</code>, the user can specify the edge correction
to be applied in <code>fun</code>, using the argument <code>correction</code>.
See the Examples below.
</p>

<dl>
<dt>Summary functions in <span class="pkg">spatstat</span></dt><dd>
<p>Summary functions that are available in <span class="pkg">spatstat</span>, such as
<code><a href="#topic+Kest">Kest</a></code>, <code><a href="#topic+Gest">Gest</a></code> and <code><a href="#topic+pcf">pcf</a></code>,
have a standard argument called <code>correction</code> which specifies
the name of one or more edge corrections.
</p>
<p>The list of available edge
corrections is different for each summary function,
and may also depend on the kind of window in which the point pattern is
recorded.
In the
case of <code>Kest</code> (the default and most frequently used value of
<code>fun</code>) the best edge correction is Ripley's isotropic
correction if the window is rectangular or polygonal, 
and the translation correction if the window is a binary mask.
See the help files for the individual
functions for more information.
</p>
<p>All the summary functions in <span class="pkg">spatstat</span>
recognise the option <code>correction="best"</code>
which gives the &ldquo;best&rdquo; (most accurate) available edge correction
for that function. 
</p>
<p>In a call to <code>envelope</code>, if <code>fun</code> is one of the
summary functions provided in <span class="pkg">spatstat</span>, then the default
is <code>correction="best"</code>. This means that
<em>by default, the envelope will be computed
using the &ldquo;best&rdquo; available edge correction</em>.
</p>
<p>The user can override this default by specifying the argument
<code>correction</code>. For example the computation can be accelerated
by choosing another edge correction which is less accurate
than the &ldquo;best&rdquo; one, but faster to compute.
</p>
</dd>
<dt>User-written summary functions</dt><dd>
<p>If <code>fun</code> is a function written by the user,
then <code>envelope</code> has to guess what to do.
</p>
<p>If <code>fun</code> has an argument
called <code>correction</code>, or has <code>...</code> arguments,
then <code>envelope</code> assumes that the function 
can handle a correction argument. To compute the envelope,
<code>fun</code> will be called with a <code>correction</code> argument.
The default is <code>correction="best"</code>, unless
overridden in the call to <code>envelope</code>.
</p>
<p>Otherwise, if <code>fun</code> does not have an argument
called <code>correction</code> and does not have <code>...</code> arguments,
then <code>envelope</code> assumes that the function 
<em>cannot</em> handle a correction argument. To compute the
envelope, <code>fun</code> is called without a correction argument.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Diggle, P.J., Hardegen, A., Lawrence, T., Milne,
R.K. and Nair, G. (2014) On tests of spatial pattern based on
simulation envelopes. <em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Arnold, 2003.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dclf.test">dclf.test</a></code>,
<code><a href="#topic+mad.test">mad.test</a></code>
for envelope-based tests.
</p>
<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+plot.envelope">plot.envelope</a></code>,
<code><a href="#topic+plot.fv">plot.fv</a></code>,
<code><a href="#topic+envelope.envelope">envelope.envelope</a></code>,
<code><a href="#topic+pool.envelope">pool.envelope</a></code>
for handling envelopes.
There are also methods for <code>print</code> and <code>summary</code>.
</p>
<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>,
<code>ppp</code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code>default.expand</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- simdat
 online &lt;- interactive()
 Nsim &lt;- if(online) 19 else 3

 # Envelope of K function under CSR
 plot(envelope(X, nsim=Nsim))

 # Translation edge correction (this is also FASTER):
 if(online) {
   plot(envelope(X, correction="translate"))
 } else {
  E &lt;- envelope(X, nsim=Nsim, correction="translate")
 }

# Global envelopes
 if(online) {
   plot(envelope(X, Lest, global=TRUE))
   plot(envelope(X, Kest,  global=TRUE, scale=function(r) { r }))
 } else {
  E &lt;- envelope(X, Lest, nsim=Nsim, global=TRUE)
  E &lt;- envelope(X, Kest, nsim=Nsim, global=TRUE, scale=function(r) { r })
  E
  summary(E)
 }




 # Envelope of G function under CSR
 if(online) {
   plot(envelope(X, Gest))
 } else {
  E &lt;- envelope(X, Gest, correction="rs", nsim=Nsim)
 }

 # Envelope of L function under CSR
 #  L(r) = sqrt(K(r)/pi)
 if(online) {
  E &lt;- envelope(X, Kest)
 } else {
  E &lt;- envelope(X, Kest, correction="border", nsim=Nsim)
 }
 plot(E, sqrt(./pi) ~ r)

 # Simultaneous critical envelope for L function
 # (alternatively, use Lest)
 if(online) {
  plot(envelope(X, Kest, transform=expression(sqrt(./pi)), global=TRUE))
 } else {
  E &lt;- envelope(X, Kest, nsim=Nsim, correction="border",
               transform=expression(sqrt(./pi)), global=TRUE)
 }

 ## One-sided envelope
 if(online) {
  plot(envelope(X, Lest, alternative="less"))
 } else {
  E &lt;- envelope(X, Lest, nsim=Nsim, alternative="less")
 }
 
 # How to pass arguments needed to compute the summary functions:
 # We want envelopes for Jcross(X, "A", "B") 
 # where "A" and "B" are types of points in the dataset 'demopat'

 if(online) {
 plot(envelope(demopat, Jcross, i="A", j="B"))
 } else {
 plot(envelope(demopat, Jcross, correction="rs", i="A", j="B", nsim=Nsim))
 }
 
 # Use of `simulate' expression
 if(online) {
 plot(envelope(cells, Gest, simulate=expression(runifpoint(42))))
 plot(envelope(cells, Gest, simulate=expression(rMaternI(100,0.02))))
 } else {
  plot(envelope(cells, Gest, correction="rs", simulate=expression(runifpoint(42)), nsim=Nsim))
    plot(envelope(cells, Gest, correction="rs", simulate=expression(rMaternI(100, 0.02)),
nsim=Nsim, global=TRUE))
 }

 # Use of `simulate' function
 if(online) {
   plot(envelope(amacrine, Kcross, simulate=rlabel))
 } else {
   plot(envelope(amacrine, Kcross, simulate=rlabel, nsim=Nsim))
 }

 # Envelope under random toroidal shifts
 if(online) {
 plot(envelope(amacrine, Kcross, i="on", j="off",
               simulate=expression(rshift(amacrine, radius=0.25)))) 
 }

 # Envelope under random shifts with erosion
 if(online) {
 plot(envelope(amacrine, Kcross, i="on", j="off",
              simulate=expression(rshift(amacrine, radius=0.1, edge="erode"))))
 }


 # Note that the principle of symmetry, essential to the validity of
 # simulation envelopes, requires that both the observed and
 # simulated patterns be subjected to the same method of intensity
 # estimation. In the following example it would be incorrect to set the
 # argument 'lambda=red.dens' in the envelope command, because this
 # would mean that the inhomogeneous K functions of the simulated
 # patterns would be computed using the intensity function estimated
 # from the original redwood data, violating the symmetry.  There is
 # still a concern about the fact that the simulations are generated
 # from a model that was fitted to the data; this is only a problem in
 # small datasets.

 if(online) {
 red.dens &lt;- density(redwood, sigma=bw.diggle, positive=TRUE)
 plot(envelope(redwood, Kinhom, sigma=bw.diggle,
         simulate=expression(rpoispp(red.dens))))
 }

 # Precomputed list of point patterns
 if(online) {
  nX &lt;- npoints(X)
  PatList &lt;- list()
  for(i in 1:Nsim) PatList[[i]] &lt;- runifpoint(nX)
  E &lt;- envelope(X, Kest, nsim=19, simulate=PatList)
 } else {
  PatList &lt;- list()
  for(i in 1:Nsim) PatList[[i]] &lt;- runifpoint(10)
 }
 E &lt;- envelope(X, Kest, nsim=Nsim, simulate=PatList)

 # re-using the same point patterns
 EK &lt;- envelope(X, Kest, nsim=Nsim, savepatterns=TRUE)
 EG &lt;- envelope(X, Gest, nsim=Nsim, simulate=EK)
</code></pre>

<hr>
<h2 id='envelope.envelope'>
Recompute Envelopes
</h2><span id='topic+envelope.envelope'></span>

<h3>Description</h3>

<p>Given a simulation envelope (object of class <code>"envelope"</code>),
compute another envelope from the same simulation data
using different parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'envelope'
envelope(Y, fun = NULL, ...,
                            transform=NULL, global=FALSE, VARIANCE=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope.envelope_+3A_y">Y</code></td>
<td>

<p>A simulation envelope (object of class <code>"envelope"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.envelope_+3A_fun">fun</code></td>
<td>

<p>Optional. Summary function to be applied to the simulated point patterns.
</p>
</td></tr>
<tr><td><code id="envelope.envelope_+3A_...">...</code>, <code id="envelope.envelope_+3A_transform">transform</code>, <code id="envelope.envelope_+3A_global">global</code>, <code id="envelope.envelope_+3A_variance">VARIANCE</code></td>
<td>

<p>Parameters controlling the type of envelope that is re-computed. 
See <code><a href="#topic+envelope">envelope</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to re-compute a simulation envelope
from previously simulated data, using different parameter settings
for the envelope: for example, a different
significance level, or a global envelope instead of a pointwise
envelope.
</p>
<p>The function <code><a href="#topic+envelope">envelope</a></code> is generic. This is the method for
the class <code>"envelope"</code>. 
</p>
<p>The argument <code>Y</code> should be a simulation envelope (object of
class <code>"envelope"</code>) produced by any of the methods for
<code><a href="#topic+envelope">envelope</a></code>. Additionally, <code>Y</code> must contain either
</p>

<ul>
<li><p> the simulated point patterns that were used to create
the original envelope (so <code>Y</code> should have been created by calling
<code><a href="#topic+envelope">envelope</a></code> with <code>savepatterns=TRUE</code>);
</p>
</li>
<li><p> the summary functions of the simulated point patterns
that were used to create
the original envelope (so <code>Y</code> should have been created by calling
<code><a href="#topic+envelope">envelope</a></code> with <code>savefuns=TRUE</code>).
</p>
</li></ul>

<p>If the argument <code>fun</code> is given, it should be a summary function
that can be applied to the simulated point patterns that were
used to create <code>Y</code>. The envelope of
the summary function <code>fun</code> for these point patterns
will be computed using the parameters specified in <code>...</code>.
</p>
<p>If <code>fun</code> is not given, then:
</p>

<ul>
<li>
<p>If <code>Y</code> contains the summary functions that were used to
compute the original envelope, then the new envelope will be
computed from these original summary functions.
</p>
</li>
<li>
<p>Otherwise, if <code>Y</code> contains the simulated point patterns.
then the <code class="reqn">K</code> function <code><a href="#topic+Kest">Kest</a></code> will be applied to
each of these simulated point patterns, and the new envelope will
be based on the <code class="reqn">K</code> functions.
</p>
</li></ul>

<p>The new envelope 
will be computed using the parameters specified in <code>...</code>.
</p>
<p>See <code><a href="#topic+envelope">envelope</a></code> for a full list of envelope parameters.
Frequently-used parameters include <code>nrank</code> and <code>nsim</code> (to change the
number of simulations used and the significance level of the
envelope), <code>global</code> (to change from pointwise to global
envelopes) and <code>VARIANCE</code> (to compute the envelopes from the sample
moments instead of the ranks).
</p>


<h3>Value</h3>

<p>An envelope (object of class <code>"envelope"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  E &lt;- envelope(cells, Kest, nsim=19, savefuns=TRUE, savepatterns=TRUE)
  E2 &lt;- envelope(E, nrank=2)
  Eg &lt;- envelope(E, global=TRUE)
  EG &lt;- envelope(E, Gest)
  EL &lt;- envelope(E, transform=expression(sqrt(./pi)))
</code></pre>

<hr>
<h2 id='envelope.pp3'>Simulation Envelopes of Summary Function for 3D Point Pattern</h2><span id='topic+envelope.pp3'></span>

<h3>Description</h3>

<p>Computes simulation envelopes of a summary function
for a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
envelope(Y, fun=K3est, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs, simulate=NULL, verbose=TRUE, 
  transform=NULL,global=FALSE,ginterval=NULL,use.theory=NULL,
  alternative=c("two.sided", "less", "greater"),
  scale=NULL, clamp=FALSE, 
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL,
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE, 
  do.pwrong=FALSE, envir.simul=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope.pp3_+3A_y">Y</code></td>
<td>

<p>A three-dimensional point pattern (object of class
<code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a 3D point pattern. 
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns to be generated
when computing the envelopes.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_funargs">funargs</code></td>
<td>

<p>A list, containing extra arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_funyargs">funYargs</code></td>
<td>

<p>Optional. A list, containing extra arguments to be passed to
<code>fun</code> when applied to the original data <code>Y</code> only.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_simulate">simulate</code></td>
<td>

<p>Optional. Specifies how to generate the simulated point patterns.
If <code>simulate</code> is an expression in the R language, then this
expression will be evaluated <code>nsim</code> times,
to obtain <code>nsim</code> point patterns which are taken as the
simulated patterns from which the envelopes are computed.
If <code>simulate</code> is a function, then this function will be
repeatedly applied to the data pattern <code>Y</code> to obtain
<code>nsim</code> simulated patterns.
If <code>simulate</code> is a list of point patterns, then the entries
in this list will be treated as the simulated patterns from which
the envelopes are computed.
Alternatively <code>simulate</code> may be an object produced by the
<code>envelope</code> command: see Details.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
during the simulations.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_transform">transform</code></td>
<td>

<p>Optional. A transformation to be applied to the
function values, before the envelopes are computed.
An expression object (see Details).
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_global">global</code></td>
<td>

<p>Logical flag indicating whether envelopes should be pointwise
(<code>global=FALSE</code>) or simultaneous (<code>global=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_ginterval">ginterval</code></td>
<td>

<p>Optional.
A vector of length 2 specifying
the interval of <code class="reqn">r</code> values for the simultaneous critical
envelopes. Only relevant if <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_use.theory">use.theory</code></td>
<td>

<p>Logical value indicating whether to use the theoretical value,
computed by <code>fun</code>, as the reference value for simultaneous
envelopes. Applicable only when <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>side="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>side="less"</code>) or a one-sided test
with an upper critical boundary (<code>side="greater"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_scale">scale</code></td>
<td>

<p>Optional. Scaling function for global envelopes.
A function in the <span class="rlang"><b>R</b></span> language which determines the
relative scale of deviations, as a function of
distance <code class="reqn">r</code>, when computing the global envelopes.
Applicable only when <code>global=TRUE</code>.
Summary function values for distance <code>r</code>
will be <em>divided</em> by <code>scale(r)</code> before the
maximum deviation is computed. The resulting global envelopes
will have width proportional to <code>scale(r)</code>. 
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_clamp">clamp</code></td>
<td>

<p>Logical value indicating how to compute envelopes when
<code>alternative="less"</code> or <code>alternative="greater"</code>.
Deviations of the observed
summary function from the theoretical summary function are initially
evaluated as signed real numbers, with large positive values indicating
consistency with the alternative hypothesis.
If <code>clamp=FALSE</code> (the default), these values are not changed.
If <code>clamp=TRUE</code>, any negative values are replaced by zero.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
function values.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
point patterns.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_nsim2">nsim2</code></td>
<td>

<p>Number of extra simulated point patterns to be generated
if it is necessary to use simulation to estimate the theoretical
mean of the summary function. Only relevant when <code>global=TRUE</code>
and the simulations are not based on CSR.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_variance">VARIANCE</code></td>
<td>

<p>Logical. If <code>TRUE</code>, critical envelopes will be calculated
as sample mean plus or minus <code>nSD</code> times sample standard
deviation.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_nsd">nSD</code></td>
<td>

<p>Number of estimated standard deviations used to determine
the critical envelopes, if <code>VARIANCE=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_yname">Yname</code></td>
<td>

<p>Character string that should be used as the name of the 
data point pattern <code>Y</code> when printing or plotting the results.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_maxnerr">maxnerr</code></td>
<td>

<p>Maximum number of rejected patterns.
If <code>fun</code> yields a fatal error when applied to a simulated point
pattern (for example, because the pattern is empty and <code>fun</code>
requires at least one point), the pattern will be rejected
and a new random point pattern will be generated. If this happens
more than <code>maxnerr</code> times, the algorithm will give up.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_rejectna">rejectNA</code></td>
<td>

<p>Logical value specifying whether to reject a simulated pattern
if the resulting values of <code>fun</code> are all equal to <code>NA</code>,
<code>NaN</code> or infinite. If <code>FALSE</code> (the default), then
simulated patterns are only rejected when <code>fun</code> gives a
fatal error. 
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_silent">silent</code></td>
<td>

<p>Logical value specifying whether to print a report each time
a simulated pattern is rejected.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_do.pwrong">do.pwrong</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the algorithm will also estimate
the true significance level of the &ldquo;wrong&rdquo; test (the test that
declares the summary function for the data to be significant
if it lies outside the <em>pointwise</em> critical boundary at any
point). This estimate is printed when the result is printed.
</p>
</td></tr>
<tr><td><code id="envelope.pp3_+3A_envir.simul">envir.simul</code></td>
<td>

<p>Environment in which to evaluate the expression <code>simulate</code>,
if not the current environment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>envelope</code> command performs simulations and
computes envelopes of a summary statistic based on the simulations.
The result is an object that can be plotted to display the envelopes.
The envelopes can be used to assess the goodness-of-fit of
a point process model to point pattern data.
</p>
<p>The <code>envelope</code> function is generic, with methods for
the classes <code>"ppp"</code>, <code>"ppm"</code> and <code>"kppm"</code>
described in the help file for <code><a href="#topic+envelope">envelope</a></code>.
This function <code>envelope.pp3</code> is the method for 
three-dimensional point patterns (objects of class <code>"pp3"</code>).
</p>
<p>For the most basic use, if you have a 3D point pattern <code>X</code> and
you want to test Complete Spatial Randomness (CSR), type
<code>plot(envelope(X, K3est,nsim=39))</code> to see the three-dimensional
<code class="reqn">K</code> function for <code>X</code> plotted together with the envelopes of
the three-dimensional <code class="reqn">K</code> function for 39 simulations of CSR. 
</p>
<p>To create simulation envelopes, the command <code>envelope(Y, ...)</code> 
first generates <code>nsim</code> random point patterns
in one of the following ways. 
</p>

<ul>
<li> 
<p>If <code>simulate=NULL</code>,
then we generate <code>nsim</code> simulations of
Complete Spatial Randomness (i.e. <code>nsim</code> simulated point patterns
each being a realisation of the uniform Poisson point process)
with the same intensity as the pattern <code>Y</code>.
</p>
</li>
<li>
<p>If <code>simulate</code> is supplied, then it determines how the
simulated point patterns are generated.
See <code><a href="#topic+envelope">envelope</a></code> for details.
</p>
</li></ul>

<p>The summary statistic <code>fun</code> is applied to each of these simulated
patterns. Typically <code>fun</code> is one of the functions
<code>K3est</code>, <code>G3est</code>, <code>F3est</code> or <code>pcf3est</code>.
It may also be a character string
containing the name of one of these functions.
</p>
<p>For further information, see the documentation for
<code><a href="#topic+envelope">envelope</a></code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
which can be plotted directly.
See <code><a href="#topic+envelope">envelope</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A. (1993)
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b>, 641&ndash;668.
</p>


<h3>See Also</h3>

<p><code>pp3</code>,
<code>rpoispp3</code>,
<code><a href="#topic+K3est">K3est</a></code>,
<code><a href="#topic+G3est">G3est</a></code>,
<code><a href="#topic+F3est">F3est</a></code>,
<code><a href="#topic+pcf3est">pcf3est</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp3(20, box3())
 if(interactive()) {
 plot(envelope(X, nsim=39))
 }
 
</code></pre>

<hr>
<h2 id='envelopeArray'>
Array of Simulation Envelopes of Summary Function
</h2><span id='topic+envelopeArray'></span>

<h3>Description</h3>

<p>Compute an array of simulation envelopes using
a summary function that returns an array of curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelopeArray(X, fun, ..., dataname = NULL, verb = FALSE, reuse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelopeArray_+3A_x">X</code></td>
<td>

<p>Object containing point pattern data.
A point pattern (object of class
<code>"ppp"</code>, <code>"lpp"</code>, <code>"pp3"</code> or <code>"ppx"</code>)
or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="envelopeArray_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern. The result of <code>fun</code> should be a
function array (object of class <code>"fasp"</code>).
</p>
</td></tr>
<tr><td><code id="envelopeArray_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+envelope">envelope</a></code> to control the simulations,
or passed to <code>fun</code> when evaluating the function.
</p>
</td></tr>
<tr><td><code id="envelopeArray_+3A_dataname">dataname</code></td>
<td>

<p>Optional character string name for the data.
</p>
</td></tr>
<tr><td><code id="envelopeArray_+3A_verb">verb</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="envelopeArray_+3A_reuse">reuse</code></td>
<td>

<p>Logical value indicating whether the envelopes in each panel
should be based on the same set of simulated patterns
(<code>reuse=TRUE</code>, the default)
or on different, independent sets of simulated
patterns (<code>reuse=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is the counterpart of <code><a href="#topic+envelope">envelope</a></code>
when the function <code>fun</code> that is evaluated on each simulated point pattern
will return an object of class <code>"fasp"</code> representing an array of
summary functions.
</p>
<p>Simulated point patterns are generated according to the
rules described for <code><a href="#topic+envelope">envelope</a></code>. In brief, 
if <code>X</code> is a point pattern, the algorithm generates
simulated point patterns of the same kind, according to complete
spatial randomness. If <code>X</code> is a fitted model, the algorithm
generates simulated point patterns according to this model.
</p>
<p>For each simulated point pattern <code>Y</code>, the function <code>fun</code>
is invoked. The result <code>Z &lt;- fun(Y, ...)</code> should be an object of
class <code>"fasp"</code> representing an array of summary functions.
The dimensions of the array <code>Z</code> should be the same
for each simulated pattern <code>Y</code>.
</p>
<p>This algorithm finds the simulation envelope of the summary functions
in each cell of the array. 
</p>


<h3>Value</h3>

<p>An object of class <code>"fasp"</code> representing
an array of envelopes.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope">envelope</a></code>, <code><a href="#topic+alltypes">alltypes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    Nsim &lt;- 19
    X &lt;- finpines
    co &lt;- "best"
  } else {
    ## smaller task to reduce check time
    Nsim &lt;- 3
    X &lt;- finpines[c(FALSE, TRUE)]
    co &lt;- "none"
  }
  A &lt;- envelopeArray(X, markcrosscorr, nsim=Nsim, correction=co)
  plot(A)
</code></pre>

<hr>
<h2 id='eval.fasp'>Evaluate Expression Involving Function Arrays</h2><span id='topic+eval.fasp'></span>

<h3>Description</h3>

<p>Evaluates any expression involving one or more function arrays
(<code>fasp</code> objects) and returns another function array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eval.fasp(expr, envir, dotonly=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.fasp_+3A_expr">expr</code></td>
<td>

<p>An expression involving the names of objects of class <code>"fasp"</code>.
</p>
</td></tr>
<tr><td><code id="eval.fasp_+3A_envir">envir</code></td>
<td>

<p>Optional. The environment in which to evaluate the expression,
or a named list containing <code>"fasp"</code> objects to be used in
the expression.
</p>
</td></tr>
<tr><td><code id="eval.fasp_+3A_dotonly">dotonly</code></td>
<td>
<p>Logical. Passed to <code><a href="#topic+eval.fv">eval.fv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to make it easier to perform
pointwise calculations with the arrays of summary functions
used in spatial statistics.
</p>
<p>A function array (object of class <code>"fasp"</code>) can be regarded as a matrix
whose entries are functions. Objects of this kind
are returned by the command <code><a href="#topic+alltypes">alltypes</a></code>.
</p>
<p>Suppose <code>X</code> is an object of class <code>"fasp"</code>.
Then <code>eval.fasp(X+3)</code> effectively adds 3 to the value of
every function in the array <code>X</code>, and returns
the resulting object. 
</p>
<p>Suppose <code>X</code> and <code>Y</code> are two objects of class <code>"fasp"</code>
which are compatible (for example the arrays
must have the same dimensions). Then 
<code>eval.fasp(X + Y)</code> will add the corresponding functions in
each cell of the arrays <code>X</code> and <code>Y</code>,
and return the resulting array of functions.
</p>
<p>Suppose <code>X</code> is an object of class <code>"fasp"</code>
and <code>f</code> is an object of class <code>"fv"</code>.
Then <code>eval.fasp(X + f)</code> will add the function <code>f</code>
to the functions in each cell of the array <code>X</code>,
and return the resulting array of functions.
</p>
<p>In general, <code>expr</code> can be any expression involving
(a) the <em>names</em> of objects of class <code>"fasp"</code> or <code>"fv"</code>,
(b) scalar constants, and (c) functions which are vectorised.
See the Examples.
</p>
<p>First <code>eval.fasp</code> determines which of the <em>variable names</em>
in the expression <code>expr</code> refer to objects of class <code>"fasp"</code>.
The expression is then evaluated for each cell of the array
using <code><a href="#topic+eval.fv">eval.fv</a></code>.
</p>
<p>The expression <code>expr</code> must be vectorised.
There must be at least one object of class <code>"fasp"</code> in the expression.
All such objects must be compatible.
</p>


<h3>Value</h3>

<p>Another object of class <code>"fasp"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fasp.object">fasp.object</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  K &lt;- alltypes(amacrine, "K")

  # expressions involving a fasp object
  eval.fasp(K + 3)
  L &lt;- eval.fasp(sqrt(K/pi))

  # expression involving two fasp objects
  D &lt;- eval.fasp(K - L)

  # subtracting the unmarked K function from the cross-type K functions
  K0 &lt;- Kest(unmark(amacrine))
  DK &lt;- eval.fasp(K - K0)

  ## Use of 'envir'
  S &lt;- eval.fasp(1-G, list(G=alltypes(amacrine, 'G')))
</code></pre>

<hr>
<h2 id='eval.fv'>Evaluate Expression Involving Functions</h2><span id='topic+eval.fv'></span>

<h3>Description</h3>

<p>Evaluates any expression involving one or more function value (fv) objects,
and returns another object of the same kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eval.fv(expr, envir, dotonly=TRUE, equiv=NULL, relabel=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.fv_+3A_expr">expr</code></td>
<td>
<p>An expression.</p>
</td></tr>
<tr><td><code id="eval.fv_+3A_envir">envir</code></td>
<td>

<p>Optional. The environment in which to evaluate the
expression, or a named list containing <code>"fv"</code> objects to be
used in the expression.
</p>
</td></tr>
<tr><td><code id="eval.fv_+3A_dotonly">dotonly</code></td>
<td>
<p>Logical. See Details.</p>
</td></tr>
<tr><td><code id="eval.fv_+3A_equiv">equiv</code></td>
<td>
<p>Mapping between column names of different objects
that are deemed to be equivalent. See Details.</p>
</td></tr>
<tr><td><code id="eval.fv_+3A_relabel">relabel</code></td>
<td>

<p>Logical value indicating whether to
compute appropriate labels for the resulting function.
This should normally be <code>TRUE</code> (the default).
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to make it easier to perform
pointwise calculations with the summary functions
used in spatial statistics.
</p>
<p>An object of class <code>"fv"</code> is essentially a data frame
containing several different statistical estimates of the same
function. Such objects are returned by <code><a href="#topic+Kest">Kest</a></code> and its
relatives.
</p>
<p>For example, suppose <code>X</code> is an object of class <code>"fv"</code>
containing several different estimates of the Ripley's K function <code class="reqn">K(r)</code>,
evaluated at a sequence of values of <code class="reqn">r</code>.
Then <code>eval.fv(X+3)</code> effectively adds 3 to 
each function estimate in <code>X</code>, and returns
the resulting object. 
</p>
<p>Suppose <code>X</code> and <code>Y</code> are two objects of class <code>"fv"</code>
which are compatible (in particular they have the same vector
of <code class="reqn">r</code> values). Then 
<code>eval.im(X + Y)</code> will add the corresponding function values in
<code>X</code> and <code>Y</code>, and return the resulting function.
</p>
<p>In general, <code>expr</code> can be any expression involving
(a) the <em>names</em> of objects of class <code>"fv"</code>, (b) scalar
constants, and (c) functions which are vectorised.
See the Examples.
</p>
<p>First <code>eval.fv</code> determines which of the <em>variable names</em>
in the expression <code>expr</code> refer to objects of class <code>"fv"</code>.
Each such name is replaced by a vector containing the function values.
The expression is then evaluated. The result should be a vector;
it is taken as the new vector of function values.
</p>
<p>The expression <code>expr</code> must be vectorised.
There must be at least one object of class <code>"fv"</code> in the expression.
If the objects are not compatible, they will be made compatible
by <code><a href="#topic+harmonise.fv">harmonise.fv</a></code>.
</p>
<p>If <code>dotonly=TRUE</code> (the default), the expression will be
evaluated only for those columns of an <code>"fv"</code> object
that contain values of the function itself (rather than
values of the derivative of the function, the hazard rate, etc).
If <code>dotonly=FALSE</code>, the expression will be evaluated for all columns.
</p>
<p>For example the result of <code><a href="#topic+Fest">Fest</a></code> includes several columns
containing estimates of the empty space function <code class="reqn">F(r)</code>,
but also includes an estimate of the
<em>hazard</em> <code class="reqn">h(r)</code> of <code class="reqn">F(r)</code>. Transformations that are valid
for <code class="reqn">F</code> may not be valid for <code class="reqn">h</code>. Accordingly, <code class="reqn">h</code> would
normally be omitted from the calculation.
</p>
<p>The columns of an object <code>x</code> that represent the function itself
are identified by its &ldquo;dot&rdquo; names, <code>fvnames(x, ".")</code>.
They are the columns normally plotted by <code><a href="#topic+plot.fv">plot.fv</a></code>
and identified by the symbol <code>"."</code> in plot formulas
in <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The argument <code>equiv</code> can be used to specify that 
two different column names in different function objects
are mathematically equivalent or cognate.
It should be a list of <code>name=value</code> pairs, or a named vector of
character strings, indicating the pairing of equivalent names.
(Without this argument, these columns would be discarded.)
See the Examples.
</p>
<p>The argument <code>relabel</code> should normally be <code>TRUE</code> (the default).
It determines whether to compute appropriate mathematical labels and
descriptions for the resulting function object
(used when the object is printed or plotted).
If <code>relabel=FALSE</code> then this does not occur,
and the mathematical labels and descriptions
in the result are taken from the function object
that appears first in the expression. This reduces computation time
slightly (for advanced use only).
</p>


<h3>Value</h3>

<p>Another object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # manipulating the K function
  X &lt;- runifrect(42)
  Ks &lt;- Kest(X)

  eval.fv(Ks + 3)
  Ls &lt;- eval.fv(sqrt(Ks/pi))

  # manipulating two K functions
  Y &lt;- runifrect(20)
  Kr &lt;- Kest(Y)

  Kdif &lt;- eval.fv(Ks - Kr)
  Z &lt;- eval.fv(sqrt(Ks/pi) - sqrt(Kr/pi))

  ## Use of 'envir'
  U &lt;- eval.fv(sqrt(K), list(K=Ks))

  ## Use of 'equiv'
  Fc &lt;- Fest(cells)
  Gc &lt;- Gest(cells)
  # Hanisch and Chiu-Stoyan estimators are cognate
  Dc &lt;- eval.fv(Fc - Gc, equiv=list(cs="han"))
</code></pre>

<hr>
<h2 id='Extract.fasp'>Extract Subset of Function Array</h2><span id='topic++5B.fasp'></span>

<h3>Description</h3>

<p>Extract a subset of a function array (an object of class
<code>"fasp"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fasp'
x[I, J, drop=TRUE,...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.fasp_+3A_x">x</code></td>
<td>

<p>A function array. An object of class <code>"fasp"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.fasp_+3A_i">I</code></td>
<td>

<p>any valid expression for a subset of the row indices of the array.
</p>
</td></tr>
<tr><td><code id="Extract.fasp_+3A_j">J</code></td>
<td>

<p>any valid expression for a subset of the column indices of the array.
</p>
</td></tr>
<tr><td><code id="Extract.fasp_+3A_drop">drop</code></td>
<td>

<p>Logical.
When the selected subset consists of only one cell of the array,
if <code>drop=FALSE</code> the result is still returned as a
<code class="reqn">1 \times 1</code> array of functions (class <code>"fasp"</code>)
while if <code>drop=TRUE</code> it is returned as a
function (class <code>"fv"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.fasp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function array can be regarded as a matrix whose entries
are functions. See <code><a href="#topic+fasp.object">fasp.object</a></code> for an explanation of
function arrays.
</p>
<p>This routine extracts a sub-array according to the usual
conventions for matrix indexing.
</p>


<h3>Value</h3>

<p>A function array (of class <code>"fasp"</code>).
Exceptionally, if the array has only one cell, and
if <code>drop=TRUE</code>, then the result is a function value table
(class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fasp.object">fasp.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> online &lt;- interactive()
 # Lansing woods data - multitype points with 6 types
 X &lt;- lansing

 if(!online) {
   # subsample data (from 2251 to 450 points) to shorten check time
   X &lt;- X[c(FALSE,FALSE,FALSE,FALSE,TRUE)]
 }

 a &lt;- alltypes(X, 'K')

 # extract first three marks only
 b &lt;- a[1:3,1:3]
 if(online) {plot(b)}
 # subset of array pertaining to hickories
 h &lt;- a["hickory", ]
 if(online) {plot(h)}
</code></pre>

<hr>
<h2 id='Extract.fv'>Extract or Replace Subset of Function Values</h2><span id='topic++5B.fv'></span><span id='topic++5B+3C-.fv'></span><span id='topic++24+3C-.fv'></span>

<h3>Description</h3>

<p>Extract or replace a subset of an object of class <code>"fv"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fv'
x[i, j, ..., drop=FALSE]

  ## S3 replacement method for class 'fv'
x[i, j] &lt;- value

  ## S3 replacement method for class 'fv'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.fv_+3A_x">x</code></td>
<td>

<p>a function value object,
of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
Essentially a data frame.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_i">i</code></td>
<td>

<p>any appropriate subset index.
Selects a subset of the rows of the data frame, i.e.
a subset of the domain of the function(s) represented by <code>x</code>.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_j">j</code></td>
<td>

<p>any appropriate subset index for the columns of the data frame.
Selects some of the functions present in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_name">name</code></td>
<td>

<p>the name of a column of the data frame.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the result is a data frame or vector
containing the selected rows and columns of data.
If <code>FALSE</code> (the default),
the result is another object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.fv_+3A_value">value</code></td>
<td>

<p>Replacement value for the column or columns selected by
<code>name</code> or <code>j</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract a designated subset of an object of class
<code>"fv"</code>, or replace the designated subset with other data,
or delete the designated subset.
</p>
<p>The subset is specified by the 
row index <code>i</code> and column index <code>j</code>, or
by the column name <code>name</code>. Either <code>i</code> or <code>j</code>
may be missing, or both may be missing.
</p>
<p>The function <code>[.fv</code> is a method for the generic operator
<code><a href="Matrix.html#topic++5B">[</a></code> for the class <code>"fv"</code>. It extracts the
designated subset of <code>x</code>, and returns it as
another object of class <code>"fv"</code> (if <code>drop=FALSE</code>)
or as a data frame or vector (if <code>drop=TRUE</code>).
</p>
<p>The function <code>[&lt;-.fv</code> is a method for the generic operator
<code><a href="Matrix.html#topic++5B+3C-">[&lt;-</a></code> for the class <code>"fv"</code>.
If <code>value</code> is <code>NULL</code>, the designated subset of <code>x</code> will be
deleted from <code>x</code>.
Otherwise, the designated subset of <code>x</code> will be
replaced by the data contained in <code>value</code>.
The return value is the modified object <code>x</code>.
</p>
<p>The function <code>$&lt;-.fv</code> is a method for the generic operator
<code><a href="base.html#topic++24+3C-">$&lt;-</a></code> for the class <code>"fv"</code>.
If <code>value</code> is <code>NULL</code>, the designated column of <code>x</code> will be
deleted from <code>x</code>.
Otherwise, the designated column of <code>x</code> will be
replaced by the data contained in <code>value</code>.
The return value is the modified object <code>x</code>.
</p>


<h3>Value</h3>

<p>The result of <code>[.fv</code> with <code>drop=TRUE</code>
is a data frame or vector. 
</p>
<p>Otherwise, the result is another object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> K &lt;- Kest(cells)

 # discard the estimates of K(r) for r  &gt; 0.1
 Ksub &lt;- K[K$r &lt;= 0.1, ]

 # extract the border method estimates
 bor &lt;- K[ , "border", drop=TRUE]
 # or equivalently
 bor &lt;- K$border

 # remove the border-method estimates
 K$border &lt;- NULL
 K
</code></pre>

<hr>
<h2 id='F3est'>
Empty Space Function of a Three-Dimensional Point Pattern
</h2><span id='topic+F3est'></span>

<h3>Description</h3>

<p>Estimates the empty space function <code class="reqn">F_3(r)</code> from 
a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F3est(X, ..., rmax = NULL, nrval = 128, vside = NULL,
              correction = c("rs", "km", "cs"),
              sphere = c("fudge", "ideal", "digital"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F3est_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="F3est_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="F3est_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum value of argument <code class="reqn">r</code> for which
<code class="reqn">F_3(r)</code> will be estimated. 
</p>
</td></tr>
<tr><td><code id="F3est_+3A_nrval">nrval</code></td>
<td>

<p>Optional. Number of values of <code class="reqn">r</code> for which
<code class="reqn">F_3(r)</code> will be estimated. A large value of <code>nrval</code>
is required to avoid discretisation effects.
</p>
</td></tr>
<tr><td><code id="F3est_+3A_vside">vside</code></td>
<td>

<p>Optional. 
Side length of the voxels in the discrete approximation.
</p>
</td></tr>
<tr><td><code id="F3est_+3A_correction">correction</code></td>
<td>

<p>Optional. Character vector specifying the edge correction(s)
to be applied. See Details.
</p>
</td></tr>
<tr><td><code id="F3est_+3A_sphere">sphere</code></td>
<td>

<p>Optional. Character string specifying how to calculate the
theoretical value of <code class="reqn">F_3(r)</code> for a Poisson
process. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a stationary point process <code class="reqn">\Phi</code> in three-dimensional
space, the empty space function is
</p>
<p style="text-align: center;"><code class="reqn">
    F_3(r) = P(d(0,\Phi) \le r)
  </code>
</p>

<p>where <code class="reqn">d(0,\Phi)</code> denotes the distance from a fixed
origin <code class="reqn">0</code> to the nearest point of <code class="reqn">\Phi</code>.
</p>
<p>The three-dimensional point pattern <code>X</code> is assumed to be a
partial realisation of a stationary point process <code class="reqn">\Phi</code>.
The empty space function of <code class="reqn">\Phi</code> can then be estimated using
techniques described in the References.
</p>
<p>The box containing the point
pattern is discretised into cubic voxels of side length <code>vside</code>.
The distance function <code class="reqn">d(u,\Phi)</code> is computed for
every voxel centre point
<code class="reqn">u</code> using a three-dimensional version of the distance transform
algorithm (Borgefors, 1986). The empirical cumulative distribution
function of these values, with appropriate edge corrections, is the
estimate of <code class="reqn">F_3(r)</code>.
</p>
<p>The available edge corrections are:
</p>

<dl>
<dt><code>"rs"</code>:</dt><dd>
<p>the reduced sample (aka minus sampling, border correction)
estimator (Baddeley et al, 1993)
</p>
</dd>
<dt><code>"km"</code>:</dt><dd>
<p>the three-dimensional version of the
Kaplan-Meier estimator (Baddeley and Gill, 1997)
</p>
</dd>
<dt><code>"cs"</code>:</dt><dd>
<p>the three-dimensional generalisation of
the Chiu-Stoyan or Hanisch estimator (Chiu and Stoyan, 1998).
</p>
</dd>
</dl>

<p>Alternatively <code>correction="all"</code> selects all options.
</p>
<p>The result includes a column <code>theo</code> giving the 
theoretical value of <code class="reqn">F_3(r)</code> for
a uniform Poisson process (Complete Spatial Randomness).
This value depends on the volume of the sphere of radius <code>r</code>
measured in the discretised distance metric.
The argument <code>sphere</code> determines how this will be calculated.
</p>

<ul>
<li>
<p>If <code>sphere="ideal"</code> the calculation will use the
volume of an ideal sphere of radius <code class="reqn">r</code> namely
<code class="reqn">(4/3) \pi r^3</code>. This is not recommended
because the theoretical values of <code class="reqn">F_3(r)</code>
are inaccurate.
</p>
</li>
<li>
<p>If <code>sphere="fudge"</code> then the volume of the ideal sphere will
be multiplied by 0.78, which gives the approximate volume
of the sphere in the discretised distance metric.
</p>
</li>
<li>
<p>If <code>sphere="digital"</code> then the volume of the sphere in the
discretised distance metric is computed exactly using another
distance transform. This takes longer to compute, but is exact.
</p>
</li></ul>



<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>) that can be
plotted, printed or coerced to a data frame containing the function values.
</p>


<h3>Warnings</h3>

<p>A small value of <code>vside</code> and a large value of <code>nrval</code>
are required for reasonable accuracy. 
</p>
<p>The default value of <code>vside</code> ensures that the total number of
voxels is <code>2^22</code> or about 4 million.
To change the default number of voxels, see
<code>spatstat.options("nvoxel")</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rana Moyeed.
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A.
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b> (1993) 641&ndash;668.
</p>
<p>Baddeley, A.J. and Gill, R.D. (1997)
Kaplan-Meier estimators of interpoint distance
distributions for spatial point processes.
<em>Annals of Statistics</em> <b>25</b>, 263&ndash;292.
</p>
<p>Borgefors, G. (1986)
Distance transformations in digital images.
<em>Computer Vision, Graphics and Image Processing</em>
<b>34</b>, 344&ndash;371.
</p>
<p>Chiu, S.N. and Stoyan, D. (1998)
Estimators of distance distributions for spatial patterns.
<em>Statistica Neerlandica</em> <b>52</b>, 239&ndash;246.
</p>


<h3>See Also</h3>

<p><code>pp3</code> to create a three-dimensional point
pattern (object of class <code>"pp3"</code>).
</p>
<p><code><a href="#topic+G3est">G3est</a></code>,
<code><a href="#topic+K3est">K3est</a></code>,
<code><a href="#topic+pcf3est">pcf3est</a></code> for other summary functions of
a three-dimensional point pattern.
</p>
<p><code><a href="#topic+Fest">Fest</a></code> to estimate the empty space function of
point patterns in two dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  X &lt;- rpoispp3(42)
  Z &lt;- F3est(X)
  if(interactive()) plot(Z)
  
</code></pre>

<hr>
<h2 id='fasp.object'>Function Arrays for Spatial Patterns</h2><span id='topic+fasp.object'></span>

<h3>Description</h3>

<p>A class <code>"fasp"</code> to represent a &ldquo;matrix&rdquo;
of functions, amenable to plotting as a matrix of plot panels.
</p>


<h3>Details</h3>

<p>An object of this class is a convenient way of storing
(and later plotting, editing, etc)
a set of functions <code class="reqn">f_{i,j}(r)</code> of a real argument <code class="reqn">r</code>,
defined for each possible pair <code class="reqn">(i,j)</code> of indices
<code class="reqn">1 \le i,j \le n</code>. We may think of this
as a matrix or array of functions <code class="reqn">f_{i,j}</code>.
</p>
<p>Function arrays are particularly useful in the 
analysis of a multitype point pattern (a point pattern in which 
the points are identified as belonging to separate types).
We may want to compute a summary function for the points
of type <code class="reqn">i</code> only, for each of the possible types <code class="reqn">i</code>.
This produces a <code class="reqn">1 \times m</code> array of functions.
Alternatively we may compute a summary function
for each possible pair of types <code class="reqn">(i,j)</code>.
This produces an <code class="reqn">m \times m</code> array of functions.
</p>
<p>For multitype point patterns the command <code><a href="#topic+alltypes">alltypes</a></code>
will compute arrays of summary functions for each possible
type or for each possible pair of types.
The function <code><a href="#topic+alltypes">alltypes</a></code> 
returns an object of class <code>"fasp"</code>.
</p>
<p>An object of class <code>"fasp"</code> is a list containing at least the
following components:
</p>

<dl>
<dt>fns</dt><dd>
<p>A list of data frames, each representing one of the functions.
</p>
</dd>
<dt>which</dt><dd>
<p>A matrix representing the spatial arrangement of the
functions. If <code>which[i,j] = k</code>
then the function represented by <code>fns[[k]]</code> should be plotted
in the panel at position <code class="reqn">(i,j)</code>. If <code>which[i,j] = NA</code>
then nothing is plotted in that position.
</p>
</dd>
<dt>titles</dt><dd>
<p>A list of character strings, providing suitable plotting titles
for the functions.
</p>
</dd>
<dt>default.formulae</dt><dd>
<p>A list of default formulae for plotting each of the functions.
</p>
</dd>
<dt>title</dt><dd>
<p>A character string, giving a default title for the array
when it is plotted.
</p>
</dd>
</dl>



<h3>Functions available</h3>

<p>There are methods for <code>plot</code>, <code>print</code> and <code>"["</code>
for this class.
</p>
<p>The plot method displays the entire array of functions.
The method <code><a href="#topic++5B.fasp">[.fasp</a></code> selects a sub-array using the natural
indices <code>i,j</code>.
</p>
<p>The command <code><a href="#topic+eval.fasp">eval.fasp</a></code> can be used to apply
a transformation to each function in the array,
and to combine two arrays.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alltypes">alltypes</a></code>,
<code><a href="#topic+plot.fasp">plot.fasp</a></code>,
<code><a href="#topic++5B.fasp">[.fasp</a></code>,
<code><a href="#topic+eval.fasp">eval.fasp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  GG &lt;- alltypes(amacrine, 'G')

  plot(GG)

  # select the row corresponding to cells of type "on"
  Gon &lt;- GG["on", ]
  plot(Gon)

  # extract the G function for i = "on", j = "off"
  Gonoff &lt;- GG["on", "off", drop=TRUE]

  # Fisher variance stabilising transformation
  GGfish &lt;- eval.fasp(asin(sqrt(GG)))
  plot(GGfish)
</code></pre>

<hr>
<h2 id='Fest'>Estimate the Empty Space Function or its Hazard Rate</h2><span id='topic+Fest'></span><span id='topic+Fhazard'></span>

<h3>Description</h3>

<p>Estimates the empty space function <code class="reqn">F(r)</code>
or its hazard rate <code class="reqn">h(r)</code> from a point pattern in a 
window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fest(X, ..., eps, r=NULL, breaks=NULL,
     correction=c("rs", "km", "cs"),
     domain=NULL)

Fhazard(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fest_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">F(r)</code> will be computed.
An object of class <code>ppp</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_...">...</code></td>
<td>

<p>Extra arguments, passed from <code>Fhazard</code> to <code>Fest</code>.
Extra arguments to <code>Fest</code> are ignored.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_eps">eps</code></td>
<td>
<p>Optional. A positive number.
The resolution of the discrete approximation to Euclidean
distance (see below). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which <code class="reqn">F(r)</code> should be evaluated. There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_correction">correction</code></td>
<td>

<p>Optional.
The edge correction(s) to be used to estimate <code class="reqn">F(r)</code>.
A vector of character strings selected from
<code>"none"</code>, <code>"rs"</code>, <code>"km"</code>, <code>"cs"</code>
and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Fest_+3A_domain">domain</code></td>
<td>

<p>Optional. Calculations will be restricted to this subset
of the window. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Fest</code> computes an estimate of the empty space function <code class="reqn">F(r)</code>,
and <code>Fhazard</code> computes an estimate of its hazard rate <code class="reqn">h(r)</code>.
</p>
<p>The empty space function 
(also called the &ldquo;<em>spherical contact distribution</em>&rdquo;
or the &ldquo;<em>point-to-nearest-event</em>&rdquo; distribution)
of a stationary point process <code class="reqn">X</code>
is the cumulative distribution function <code class="reqn">F</code> of the distance
from a fixed point in space to the nearest point of <code class="reqn">X</code>.
</p>
<p>An estimate of <code class="reqn">F</code> derived from a spatial point pattern dataset
can be used in exploratory data analysis and formal inference
about the pattern (Cressie, 1991; Diggle, 1983; Ripley, 1988).
In exploratory analyses, the estimate of <code class="reqn">F</code> is a useful statistic 
summarising the sizes of gaps in the pattern.
For inferential purposes, the estimate of <code class="reqn">F</code> is usually compared to the 
true value of <code class="reqn">F</code> for a completely random (Poisson) point process,
which is
</p>
<p style="text-align: center;"><code class="reqn">F(r) = 1 - e^{ - \lambda \pi r^2}</code>
</p>

<p>where <code class="reqn">\lambda</code>
is the intensity (expected number of points per unit area).
Deviations between the empirical and theoretical <code class="reqn">F</code> curves
may suggest spatial clustering or spatial regularity.
</p>
<p>This algorithm estimates the empty space function <code class="reqn">F</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window. 
The window (which is specified in <code>X</code>) may have arbitrary shape. 
</p>
<p>The argument <code>X</code> is interpreted as a point pattern object 
(of class <code>"ppp"</code>, see <code>ppp.object</code>) and can
be supplied in any of the formats recognised
by <code>as.ppp</code>.
</p>
<p>The algorithm uses two discrete approximations which are controlled
by the parameter <code>eps</code> and by the spacing of values of <code>r</code>
respectively. (See below for details.)
First-time users are strongly advised not to specify these arguments.
</p>
<p>The estimation of <code class="reqn">F</code> is hampered by edge effects arising from 
the unobservability of points of the random pattern outside the window. 
An edge correction is needed to reduce bias (Baddeley, 1998; Ripley, 1988). 
The edge corrections implemented here are the border method or
&quot;<em>reduced sample</em>&quot; estimator, the spatial Kaplan-Meier estimator
(Baddeley and Gill, 1997) and the Chiu-Stoyan estimator (Chiu and
Stoyan, 1998). 
</p>
<p>Our implementation makes essential use of the distance transform algorithm
of image processing (Borgefors, 1986). A fine grid of pixels is 
created in the observation window. The Euclidean distance between two pixels
is approximated by the length of the shortest path joining them in the grid,
where a path is a sequence of steps between adjacent pixels, and 
horizontal, vertical and diagonal steps have length
<code class="reqn">1</code>, <code class="reqn">1</code> and <code class="reqn">\sqrt 2</code>
respectively in pixel units. If the pixel grid is sufficiently fine then
this is an accurate approximation. 
</p>
<p>The parameter <code>eps</code>
is the pixel width of the rectangular raster
used to compute the distance transform (see below). It must not be too
large: the absolute error in distance values due to discretisation is bounded
by <code>eps</code>.
</p>
<p>If <code>eps</code> is not specified, the function
checks whether the window <code>Window(X)</code> contains pixel raster
information. If so, then <code>eps</code> is set equal to the 
pixel width of the raster; otherwise, <code>eps</code>
defaults to 1/100 of the width of the observation window.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">F(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The 
estimators are computed from histogram counts. 
This introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the spacing of successive
<code>r</code> values must be very fine (ideally not greater than <code>eps/4</code>).
</p>
<p>The algorithm also returns an estimate of the hazard rate function, 
<code class="reqn">h(r)</code> of <code class="reqn">F(r)</code>. The hazard rate is
defined by
</p>
<p style="text-align: center;"><code class="reqn">h(r) = - \frac{d}{dr} \log(1 - F(r))</code>
</p>

<p>The hazard rate of <code class="reqn">F</code> has been proposed as a useful
exploratory statistic (Baddeley and Gill, 1994).
The estimate of <code class="reqn">h(r)</code> given here
is a discrete approximation to the hazard rate of the 
Kaplan-Meier estimator of <code class="reqn">F</code>. Note that <code class="reqn">F</code> is 
absolutely continuous (for any stationary point process <code class="reqn">X</code>), 
so the hazard function always exists (Baddeley and Gill, 1997). 
</p>
<p>If the argument <code>domain</code> is given, the estimate of <code class="reqn">F(r)</code>
will be based only on the empty space distances
measured from locations inside <code>domain</code> (although their
nearest data points may lie outside <code>domain</code>).
This is useful in bootstrap techniques. The argument <code>domain</code>
should be a window (object of class <code>"owin"</code>) or something acceptable to
<code>as.owin</code>. It must be a subset of the
window of the point pattern <code>X</code>.
</p>
<p>The naive empirical distribution of distances from each location
in the window to the nearest point of the data pattern, is a biased
estimate of <code class="reqn">F</code>. However this is also returned by the algorithm
(if <code>correction="none"</code>),
as it is sometimes useful in other contexts.
Care should be taken not to use the uncorrected
empirical <code class="reqn">F</code> as if it were an unbiased estimator of <code class="reqn">F</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The result of <code>Fest</code> is 
essentially a data frame containing up to seven columns:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">F(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">F(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">F(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">F(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>cs</code></td>
<td>
<p>the Chiu-Stoyan estimator of <code class="reqn">F(r)</code>
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">F(r)</code>,
i.e. the empirical distribution of the distance from 
a random point in the window to the nearest point of
the data pattern <code>X</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">F(r)</code>
for a stationary Poisson process of the same estimated intensity.
</p>
</td></tr>
</table>
<p>The result of <code>Fhazard</code> contains only three columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the hazard rate <code class="reqn">h(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the spatial Kaplan-Meier estimate of the
hazard rate <code class="reqn">h(r)</code></p>
</td></tr>
<tr><td><code>theo</code></td>
<td>

<p>the theoretical value of <code class="reqn">h(r)</code>
for a stationary Poisson process of the same estimated intensity.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The reduced sample (border method)
estimator of <code class="reqn">F</code> is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>. Its range is always 
within <code class="reqn">[0,1]</code>.
</p>
<p>The spatial Kaplan-Meier estimator of <code class="reqn">F</code> is always nondecreasing
but its maximum value may be less than <code class="reqn">1</code>.
</p>
<p>The estimate of hazard rate <code class="reqn">h(r)</code>
returned by the algorithm is an approximately
unbiased estimate for the integral of <code class="reqn">h()</code>
over the corresponding histogram cell.
It may exhibit oscillations due to discretisation effects.
We recommend modest smoothing, such as kernel smoothing with 
kernel width equal to the width of a histogram cell,
using <code><a href="#topic+Smooth.fv">Smooth.fv</a></code>.
</p>


<h3>Note</h3>

<p>Sizeable amounts of memory may be needed during the calculation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. Spatial sampling and censoring.
In O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. van Lieshout (eds) 
<em>Stochastic Geometry: Likelihood and Computation</em>.
Chapman and Hall, 1998.
Chapter 2, pages 37-78.
</p>
<p>Baddeley, A.J. and Gill, R.D. 
The empty space hazard of a spatial pattern.
Research Report 1994/3, Department of Mathematics,
University of Western Australia, May 1994.
</p>
<p>Baddeley, A.J. and Gill, R.D.
Kaplan-Meier estimators of interpoint distance
distributions for spatial point processes.
<em>Annals of Statistics</em> <b>25</b> (1997) 263-292.
</p>
<p>Borgefors, G.
Distance transformations in digital images.
<em>Computer Vision, Graphics and Image Processing</em>
<b>34</b> (1986) 344-371.
</p>
<p>Chiu, S.N. and Stoyan, D. (1998)
Estimators of distance distributions for spatial patterns.
<em>Statistica Neerlandica</em> <b>52</b>, 239&ndash;246.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>,
<code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Fc &lt;- Fest(cells, 0.01)

   # Tip: don't use F for the left hand side!
   # That's an abbreviation for FALSE

   plot(Fc)

   # P-P style plot
   plot(Fc, cbind(km, theo) ~ theo)

   # The empirical F is above the Poisson F
   # indicating an inhibited pattern

   if(interactive()) {
   plot(Fc, . ~ theo)
   plot(Fc, asin(sqrt(.)) ~ asin(sqrt(theo)))
   }
   
</code></pre>

<hr>
<h2 id='Finhom'>
Inhomogeneous Empty Space Function
</h2><span id='topic+Finhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous empty space function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Finhom(X, lambda = NULL, lmin = NULL, ...,
        sigma = NULL, varcov = NULL,
        r = NULL, breaks = NULL, ratio = FALSE,
        update = TRUE, warn.bias=TRUE, savelambda=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Finhom_+3A_x">X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">F</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_lmin">lmin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_sigma">sigma</code>, <code id="Finhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution, or passed to <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_update">update</code></td>
<td>

<p>Logical. If <code>lambda</code> is a fitted model
(class <code>"ppm"</code> or <code>"kppm"</code>)
and <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_warn.bias">warn.bias</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when the inhomogeneity correction factor takes extreme values,
which can often lead to biased results. This usually occurs
when insufficient smoothing is used to estimate the intensity.
</p>
</td></tr>
<tr><td><code id="Finhom_+3A_savelambda">savelambda</code></td>
<td>

<p>Logical value specifying whether to save the values of
<code>lmin</code> and <code>lambda</code> as attributes of the result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes estimates of the 
inhomogeneous <code class="reqn">F</code>-function (van Lieshout, 2010)
of a point pattern. It is the counterpart, for inhomogeneous
spatial point patterns, of the empty space function <code class="reqn">F</code> 
for homogeneous point patterns computed by <code><a href="#topic+Fest">Fest</a></code>.
</p>
<p>The argument <code>X</code> should be a point pattern
(object of class <code>"ppp"</code>).
</p>
<p>The inhomogeneous <code class="reqn">F</code> function is computed
using the border correction, equation (6) in Van Lieshout (2010).
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>
of the point process. It may be either
</p>

<dl>
<dt>a numeric vector</dt><dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt><dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code> or <code>"kppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
</dd>
</dl>

<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code><a href="#topic+blur">blur</a></code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.  The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Marie-Colette van Lieshout.
C implementation and R adaptation
by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>Van Lieshout, M.N.M. (2010)
A J-function for inhomogeneous point processes.
<em>Statistica Neerlandica</em> <b>65</b>, 183&ndash;201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ginhom">Ginhom</a></code>,
<code><a href="#topic+Jinhom">Jinhom</a></code>,
<code><a href="#topic+Fest">Fest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(online) {
    plot(Finhom(swedishpines, sigma=10))
    plot(Finhom(swedishpines, sigma=bw.diggle, adjust=2))
  } else {
    ## use a coarse grid for faster computation and package testing
    plot(Finhom(swedishpines, sigma=10, dimyx=32))
  }
</code></pre>

<hr>
<h2 id='FmultiInhom'>
Inhomogeneous Marked F-Function
</h2><span id='topic+FmultiInhom'></span><span id='topic+Fmulti.inhom'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the inhomogeneous version of the multitype <code class="reqn">F</code> function,
effectively the cumulative distribution function of the distance from
a fixed point to the nearest point in subset <code class="reqn">J</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Fmulti.inhom(X, J,
              lambda = NULL, lambdaJ = NULL, lambdamin = NULL,
              ...,
              r = NULL)

  FmultiInhom(X, J,
              lambda = NULL, lambdaJ = NULL, lambdamin = NULL,
              ...,
              r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FmultiInhom_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_j">J</code></td>
<td>

<p>A subset index specifying the subset of points to which
distances are measured. Any kind of subset index acceptable
to <code>[.ppp</code>.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity estimates for each point of <code>X</code>.
A numeric vector of length equal to <code>npoints(X)</code>.
Incompatible with <code>lambdaJ</code>.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Intensity estimates for each point of <code>X[J]</code>.
A numeric vector of length equal to <code>npoints(X[J])</code>.
Incompatible with <code>lambda</code>.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>A lower bound for the intensity,
or at least a lower bound for the values in <code>lambdaJ</code>
or <code>lambda[J]</code>.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution for the computation.
</p>
</td></tr>
<tr><td><code id="FmultiInhom_+3A_r">r</code></td>
<td>

<p>Vector of distance values at which the inhomogeneous <code class="reqn">G</code>
function should be estimated. There is a sensible default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Cronie and Van Lieshout (2015).
</p>
<p>The functions <code>FmultiInhom</code> and <code>Fmulti.inhom</code> are identical.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> containing the estimate of the
inhomogeneous multitype <code class="reqn">F</code> function.
</p>


<h3>Author(s)</h3>

<p>Ottmar Cronie and Marie-Colette van Lieshout.
Rewritten for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Finhom">Finhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- amacrine
  J &lt;- (marks(X) == "off")
  online &lt;- interactive()
  eps &lt;- if(online) NULL else 0.025
  if(online &amp;&amp; require(spatstat.model)) {
    mod &lt;- ppm(X ~ marks * x, eps=eps)
    lambdaX &lt;- fitted(mod, dataonly=TRUE)
    lambdaOff &lt;- predict(mod, eps=eps)[["off"]]
    lmin &lt;- min(lambdaOff) * 0.9
  } else {
    ## faster computation for package checker only
    lambdaX &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
  }

  plot(FmultiInhom(X, J, lambda=lambdaX, lambdamin=lmin, eps=eps))
</code></pre>

<hr>
<h2 id='formula.fv'>
Extract or Change the Plot Formula for a Function Value Table
</h2><span id='topic+formula.fv'></span><span id='topic+formula+3C-'></span><span id='topic+formula+3C-.fv'></span>

<h3>Description</h3>

<p>Extract or change the default plotting formula
for an object of class <code>"fv"</code> (function value table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
formula(x, ...)

formula(x, ...) &lt;- value

## S3 replacement method for class 'fv'
formula(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.fv_+3A_x">x</code></td>
<td>

<p>An object of class <code>"fv"</code>,
containing the values of several estimates of a function.
</p>
</td></tr>
<tr><td><code id="formula.fv_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="formula.fv_+3A_value">value</code></td>
<td>

<p>New value of the formula. Either a <code>formula</code> or a character
string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function value table
(object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>)
is a convenient way of storing and plotting
several different estimates of the same function.
</p>
<p>The default behaviour of <code>plot(x)</code> for a function value table
<code>x</code> is determined by a formula
associated with <code>x</code> called its <em>plot formula</em>.
See <code><a href="#topic+plot.fv">plot.fv</a></code> for explanation about these formulae.
</p>
<p>The function <code>formula.fv</code> is a method for the generic command
<code><a href="stats.html#topic+formula">formula</a></code>. It extracts the plot formula associated with
the object.
</p>
<p>The function <code>formula&lt;-</code> is generic. It changes the formula
associated with an object. 
</p>
<p>The function <code>formula&lt;-.fv</code> is the method for <code>formula&lt;-</code>
for the class <code>"fv"</code>. It changes the plot formula associated with
the object.
</p>


<h3>Value</h3>

<p>The result of <code>formula.fv</code> is a character string containing the
plot formula. The result of <code>formula&lt;-.fv</code> is a new object of
class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv">fv</a></code>,  
<code><a href="#topic+plot.fv">plot.fv</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- Kest(cells)
   formula(K)
   formula(K) &lt;- (iso ~ r)
</code></pre>

<hr>
<h2 id='fryplot'>Fry Plot of Point Pattern</h2><span id='topic+fryplot'></span><span id='topic+frypoints'></span>

<h3>Description</h3>

<p>Displays the Fry plot (Patterson plot) of a spatial point pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fryplot(X, ..., width=NULL, from=NULL, to=NULL, axes=FALSE)
frypoints(X, from=NULL, to=NULL, dmax=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fryplot_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>) or something
acceptable to <code>as.ppp</code>.
</p>
</td></tr>
<tr><td><code id="fryplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to control the appearance of the
plot.</p>
</td></tr>
<tr><td><code id="fryplot_+3A_width">width</code></td>
<td>
<p>Optional parameter indicating the width of a box
for a zoomed-in view of the Fry plot near the origin.</p>
</td></tr>
<tr><td><code id="fryplot_+3A_from">from</code>, <code id="fryplot_+3A_to">to</code></td>
<td>

<p>Optional. Subset indices specifying which points of <code>X</code>
will be considered when forming the vectors (drawn from each point of
<code>from</code>, to each point of <code>to</code>.)
</p>
</td></tr>
<tr><td><code id="fryplot_+3A_axes">axes</code></td>
<td>

<p>Logical value indicating whether to draw axes,
crossing at the origin.
</p>
</td></tr>
<tr><td><code id="fryplot_+3A_dmax">dmax</code></td>
<td>

<p>Maximum distance between points. Pairs at greater distances
do not contribute to the result. The default means there is
no maximum distance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fryplot</code> generates a Fry plot (or Patterson plot);
<code>frypoints</code> returns the points of the Fry plot as a point pattern
dataset.
</p>
<p>Fry (1979) and Hanna and Fry (1979) introduced a manual graphical method for
investigating features of a spatial point pattern of mineral deposits.
A transparent sheet, marked
with an origin or centre point, is placed over the point pattern.
The transparent sheet is shifted so that the origin lies over one of
the data points, and the positions of all the <em>other</em> data points
are copied onto the transparent sheet. This procedure is repeated for
each data point in turn. The resulting plot (the Fry plot)
is a pattern of <code class="reqn">n(n-1)</code> points, where <code class="reqn">n</code> is the original number
of data points. This procedure was previously proposed by
Patterson (1934, 1935) for studying inter-atomic distances in
crystals, and is also known as a Patterson plot.
</p>
<p>The function <code>fryplot</code> generates the Fry/Patterson plot.
Standard graphical parameters
such as <code>main</code>, <code>pch</code>,
<code>lwd</code>, <code>col</code>, <code>bg</code>, <code>cex</code> can be used to control
the appearance of the plot.
To zoom in (to view only a subset of the Fry plot at higher
magnification), use the argument <code>width</code> to specify the width
of a rectangular field of view centred at the origin, or the standard
graphical arguments <code>xlim</code> and <code>ylim</code> to specify another
rectangular field of view. (The actual field of view may be slightly
larger, depending on the graphics device.)
</p>
<p>The function <code>frypoints</code> returns the points of the Fry
plot as a point pattern object. There may be a large number of points
in this pattern, so this function should be used only if further
analysis of the Fry plot is required.
</p>
<p>Fry plots are particularly useful for recognising anisotropy in
regular point patterns. A void around the origin in the Fry plot
suggests regularity (inhibition between points) and the shape of the
void gives a clue to anisotropy in the pattern. Fry plots are also
useful for detecting periodicity or rounding of the spatial
coordinates. 
</p>
<p>In mathematical terms, the Fry plot of a point pattern <code>X</code>
is simply a plot of the vectors <code>X[i] - X[j]</code> connecting all
pairs of distinct points in <code>X</code>. 
</p>
<p>The Fry plot is related to the <code class="reqn">K</code> function (see
<code><a href="#topic+Kest">Kest</a></code>) and the reduced second moment measure
(see <code><a href="#topic+Kmeasure">Kmeasure</a></code>). For example, the number 
of points in the Fry plot lying within a circle of given radius
is an unnormalised and uncorrected version of the <code class="reqn">K</code> function.
The Fry plot has a similar appearance to the plot of the
reduced second moment measure <code><a href="#topic+Kmeasure">Kmeasure</a></code> when the
smoothing parameter <code>sigma</code> is very small.
</p>
<p>The Fry plot does not adjust for the effect
of the size and shape of the sampling window. 
The density of points in the Fry plot tapers off near the edges of the
plot. This is an edge effect, a consequence of the bounded sampling
window. In geological applications this is usually not
important, because interest is focused on the behaviour near the
origin where edge effects can be ignored.
To correct for the edge effect, use <code><a href="#topic+Kmeasure">Kmeasure</a></code> or
<code><a href="#topic+Kest">Kest</a></code> or its relatives.
</p>


<h3>Value</h3>

<p><code>fryplot</code> returns <code>NULL</code>.
<code>frypoints</code> returns a point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Fry, N. (1979) 
Random point distributions and strain measurement in rocks.
<em>Tectonophysics</em> <b>60</b>, 89&ndash;105.
</p>
<p>Hanna, S.S. and Fry, N. (1979)
A comparison of methods of strain determination in rocks from
southwest Dyfed (Pembrokeshire) and adjacent areas.
<em>Journal of Structural Geology</em> <b>1</b>, 155&ndash;162.
</p>
<p>Patterson, A.L. (1934) A Fourier series method for the determination
of the component of inter-atomic distances in crystals.
<em>Physics Reviews</em> <b>46</b>, 372&ndash;376.
</p>
<p>Patterson, A.L. (1935) A direct method for the determination of the
components of inter-atomic distances in crystals.
<em>Zeitschrift fuer Krystallographie</em> <b>90</b>, 517&ndash;554.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kmeasure">Kmeasure</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## unmarked data
fryplot(cells)
Y &lt;- frypoints(cells)

## numerical marks
fryplot(longleaf, width=4, axes=TRUE)

## multitype points
fryplot(amacrine, width=0.2,
                  from=(marks(amacrine) == "on"),
                  chars=c(3,16), cols=2:3,
                  main="Fry plot centred at an On-cell")
points(0,0)
</code></pre>

<hr>
<h2 id='fv'>
Create a Function Value Table
</h2><span id='topic+fv'></span>

<h3>Description</h3>

<p>Advanced Use Only.
This low-level function creates an object of class <code>"fv"</code>
from raw numerical data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fv(x, argu = "r", ylab = NULL, valu, fmla = NULL, alim = NULL,
   labl = names(x), desc = NULL, unitname = NULL, fname = NULL, yexp = ylab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fv_+3A_x">x</code></td>
<td>

<p>A data frame with at least 2 columns containing the
values of the function argument and the corresponding values
of (one or more versions of) the function.
</p>
</td></tr>
<tr><td><code id="fv_+3A_argu">argu</code></td>
<td>

<p>String. The name of the column of <code>x</code> that contains
the values of the function argument.
</p>
</td></tr>
<tr><td><code id="fv_+3A_ylab">ylab</code></td>
<td>

<p>Either <code>NULL</code>, or an <span class="rlang"><b>R</b></span> language expression
representing the mathematical name of the
function. See Details.
</p>
</td></tr>
<tr><td><code id="fv_+3A_valu">valu</code></td>
<td>

<p>String. The name of the column of <code>x</code> that should be taken
as containing the function values, in cases where a single column
is required.
</p>
</td></tr>
<tr><td><code id="fv_+3A_fmla">fmla</code></td>
<td>

<p>Either <code>NULL</code>, or a <code>formula</code> specifying the default
plotting behaviour. See Details.
</p>
</td></tr>
<tr><td><code id="fv_+3A_alim">alim</code></td>
<td>

<p>Optional.
The default range of values of the function argument for which the
function will be plotted.
Numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="fv_+3A_labl">labl</code></td>
<td>

<p>Optional. Plot labels for the columns of <code>x</code>.
A vector of strings, with one entry for each column of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="fv_+3A_desc">desc</code></td>
<td>

<p>Optional. Descriptions of the columns of <code>x</code>.
A vector of strings, with one entry for each column of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="fv_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of the unit (usually a unit of length)
in which the function argument is
expressed. Either a single character string,
or a vector of two character strings giving the
singular and plural forms, respectively.
</p>
</td></tr>
<tr><td><code id="fv_+3A_fname">fname</code></td>
<td>

<p>Optional.
The name of the function itself. A character string.
</p>
</td></tr>
<tr><td><code id="fv_+3A_yexp">yexp</code></td>
<td>

<p>Optional. Alternative form of <code>ylab</code>
more suitable for annotating an axis of the plot.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This documentation is provided
for experienced programmers who want to modify the internal
behaviour of <span class="pkg">spatstat</span>. Other users please see <code><a href="#topic+fv.object">fv.object</a></code>.
</p>
<p>The low-level function <code>fv</code> is used to create an object of
class <code>"fv"</code> from raw numerical data.
</p>
<p>The data frame <code>x</code> contains the numerical data.
It should have one column
(typically but not necessarily named <code>"r"</code>)
giving the values of the function argument for which
the function has been evaluated; and at least one other column,
containing the corresponding values of the function.
</p>
<p>Typically there is more than one column of function values.
These columns typically give the values of different versions or estimates
of the same function,
for example, different estimates of the <code class="reqn">K</code> function
obtained using different edge corrections.
However they may also contain the values of related functions
such as the derivative or hazard rate.
</p>
<p><code>argu</code> specifies the name of the column of
<code>x</code> that contains the values of the function argument
(typically <code>argu="r"</code> but this is not compulsory).
</p>
<p><code>valu</code> specifies the name of another column
that contains the &lsquo;recommended&rsquo; estimate of the function.
It will be used to provide function values in those situations where
a single column of data is required. For example,
<code><a href="#topic+envelope">envelope</a></code> computes its simulation envelopes
using the recommended value of the summary function.
</p>
<p><code>fmla</code> specifies the default plotting behaviour.
It should be a formula, or a string that can be converted to a
formula. Variables in the formula are names of columns of <code>x</code>.
See <code><a href="#topic+plot.fv">plot.fv</a></code> for the interpretation of this
formula.
</p>
<p><code>alim</code> specifies the recommended range of the
function argument. This is used in situations where statistical
theory or statistical practice indicates that the computed
estimates of the function are not trustworthy outside a certain
range of values of the function argument. By default,
<code><a href="#topic+plot.fv">plot.fv</a></code> will restrict the plot to this range.
</p>
<p><code>fname</code> is a string giving the name of the function itself.
For example, the <code class="reqn">K</code> function would have <code>fname="K"</code>.
</p>
<p><code>ylab</code> is a mathematical expression
for the function value, used when labelling an axis
of the plot, or when printing a description of the
function. It should be an <span class="rlang"><b>R</b></span> language object. 
For example the <code class="reqn">K</code> function's mathematical name <code class="reqn">K(r)</code> is rendered
by <code>ylab=quote(K(r))</code>. 
</p>
<p>If <code>yexp</code> is present, then <code>ylab</code> will be
used only for printing, and <code>yexp</code> will be used for
annotating axes in a plot. (Otherwise <code>yexp</code> defaults to <code>ylab</code>).
For example the cross-type <code class="reqn">K</code> function
<code class="reqn">K_{1,2}(r)</code> is rendered by something like
<code>ylab=quote(Kcross[1,2](r))</code>
and 
<code>yexp=quote(Kcross[list(1,2)](r))</code>
to get the most satisfactory behaviour.
</p>
<p>(A useful tip: use <code><a href="base.html#topic+substitute">substitute</a></code> instead of
<code><a href="base.html#topic+quote">quote</a></code> to insert values of variables into an expression,
e.g. <code>substitute(Kcross[i,j](r), list(i=42,j=97))</code>
yields the same as <code>quote(Kcross[42, 97](r))</code>.)
</p>
<p><code>labl</code> is a character vector specifying plot labels
for each column of <code>x</code>. These labels will appear on the
plot axes (in non-default plots), legends and printed output.
Entries in <code>labl</code>
may contain the string <code>"%s"</code> which will be replaced
by <code>fname</code>. For example the border-corrected estimate
of the <code class="reqn">K</code> function has label <code>"%s[bord](r)"</code> which
becomes <code>"K[bord](r)"</code>.
</p>
<p><code>desc</code> is a character vector containing intelligible
explanations of each column of <code>x</code>. Entries in
<code>desc</code> may contain the string <code>"%s"</code> which will be replaced
by <code>ylab</code>. For example the border correction estimate of the
<code class="reqn">K</code> function has description <code>"border correction estimate of %s"</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.fv">plot.fv</a></code> for plotting an <code>"fv"</code> object.
</p>
<p>See <code><a href="#topic+as.function.fv">as.function.fv</a></code> to convert an <code>"fv"</code> object
to an <span class="rlang"><b>R</b></span> function.
</p>
<p>Use <code><a href="#topic+cbind.fv">cbind.fv</a></code> to combine several <code>"fv"</code> objects.
Use <code><a href="#topic+bind.fv">bind.fv</a></code> to glue additional columns onto an existing
<code>"fv"</code> object.
</p>
<p>Simple calculations such as arithmetic and mathematical operations
can be computed directly.
The range of <code class="reqn">y</code> values of a function <code>f</code> can be computed by
typing <code>range(f)</code>. These operations are dispatched to 
<code><a href="#topic+Summary.fv">Summary.fv</a></code>, <code><a href="#topic+Math.fv">Math.fv</a></code> and <code><a href="#topic+Ops.fv">Ops.fv</a></code>.
</p>
<p>Use <code><a href="#topic+eval.fv">eval.fv</a></code> or <code><a href="#topic+with.fv">with.fv</a></code> for more complicated
calculations.
</p>
<p>The functions <code>fvnames</code>, <code>fvnames&lt;-</code> allow the user to
use standard abbreviations to refer to columns of an <code>"fv"</code> object.
</p>
<p><em>Undocumented</em> functions for modifying an <code>"fv"</code> object
include <code>tweak.fv.entry</code> and <code>rebadge.fv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  df &lt;- data.frame(r=seq(0,5,by=0.1))
  df &lt;- transform(df, a=pi*r^2, b=3*r^2)
  X &lt;- fv(df, "r", quote(A(r)),
              "a", cbind(a, b) ~ r,
              alim=c(0,4),
              labl=c("r", "%s[true](r)", "%s[approx](r)"),
              desc=c("radius of circle",
                     "true area %s",
                     "rough area %s"),
              fname="A")
  X
</code></pre>

<hr>
<h2 id='fv.object'>Function Value Table</h2><span id='topic+fv.object'></span>

<h3>Description</h3>

<p>A class <code>"fv"</code> to support the convenient plotting
of several estimates of the same function.
</p>


<h3>Details</h3>

<p>An object of this class is a convenient way of storing and plotting
several different estimates of the same function.
</p>
<p>It is a data frame with extra attributes indicating
the recommended way of plotting the function, and other information.
</p>
<p>There are methods for <code>print</code> and <code>plot</code> for
this class.
</p>
<p>Objects of class <code>"fv"</code> are returned by
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>,<code><a href="#topic+Jest">Jest</a></code>,
and <code><a href="#topic+Kest">Kest</a></code> along with many other functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Objects of class <code>"fv"</code> are returned by
<code><a href="#topic+Fest">Fest</a></code>, <code><a href="#topic+Gest">Gest</a></code>,<code><a href="#topic+Jest">Jest</a></code>,
and <code><a href="#topic+Kest">Kest</a></code> along with many other functions.
</p>
<p>See <code><a href="#topic+plot.fv">plot.fv</a></code> for plotting an <code>"fv"</code> object.
</p>
<p>See <code><a href="#topic+as.function.fv">as.function.fv</a></code> to convert an <code>"fv"</code> object
to an <span class="rlang"><b>R</b></span> function.
</p>
<p>Use <code><a href="#topic+cbind.fv">cbind.fv</a></code> to combine several <code>"fv"</code> objects.
Use <code><a href="#topic+bind.fv">bind.fv</a></code> to glue additional columns onto an existing
<code>"fv"</code> object.
</p>
<p><em>Undocumented</em> functions for modifying an <code>"fv"</code> object
include <code>fvnames</code>, <code>fvnames&lt;-</code>,
<code>tweak.fv.entry</code> and <code>rebadge.fv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    K &lt;- Kest(cells)
    class(K)

    K  # prints a sensible summary

    plot(K)
</code></pre>

<hr>
<h2 id='fvnames'>
Abbreviations for Groups of Columns in Function Value Table
</h2><span id='topic+fvnames'></span><span id='topic+fvnames+3C-'></span>

<h3>Description</h3>

<p>Groups of columns in a function value table (object
of class <code>"fv"</code>) identified by standard abbreviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fvnames(X, a = ".")

fvnames(X, a = ".") &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fvnames_+3A_x">X</code></td>
<td>

<p>Function value table (object of class <code>"fv"</code>).
See <code><a href="#topic+fv.object">fv.object</a></code>.
</p>
</td></tr>
<tr><td><code id="fvnames_+3A_a">a</code></td>
<td>

<p>One of the standard abbreviations listed below.
</p>
</td></tr>
<tr><td><code id="fvnames_+3A_value">value</code></td>
<td>

<p>Character vector containing names of columns of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"fv"</code> represents a table of
values of a function, usually a summary function for spatial data
such as the <code class="reqn">K</code>-function, for which several different statistical
estimators may be available. The different estimates are stored
as columns of the table.
</p>
<p>Auxiliary information carried in the object <code>X</code> specifies some
columns or groups of columns of this table that should be
used for particular purposes.
For convenience these groups can be referred to by standard
abbreviations which are recognised by various functions
in the <span class="pkg">spatstat</span> package, such as <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>These abbreviations are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>".x"</code> </td><td style="text-align: left;"> the function argument </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>".y"</code> </td><td style="text-align: left;"> the recommended value of the function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"."</code>  </td><td style="text-align: left;"> all function values to be plotted by default </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> (in order of plotting) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>".s"</code> </td><td style="text-align: left;"> the upper and lower limits of shading </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> (for envelopes and confidence intervals)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>".a"</code> </td><td style="text-align: left;"> all function values (in column order)
  </td>
</tr>

</table>

<p>The command <code>fvnames(X, a)</code> expands the abbreviation <code>a</code> and returns
a character vector containing the names of the columns.
</p>
<p>The assignment <code>fvnames(X, a) &lt;- value</code> changes the
definition of the abbreviation <code>a</code> to the character string
<code>value</code> (which should be the name of another column of <code>X</code>).
The column names of <code>X</code> are not changed.
</p>
<p>Note that <code>fvnames(x, ".")</code> lists the columns of values that will
be plotted by default, in the order that they would be plotted, not in
order of the column position. The order in which curves are plotted
affects the colours and line styles associated with the curves.
</p>


<h3>Value</h3>

<p>For <code>fvnames</code>, a character vector.
</p>
<p>For <code>fvnames&lt;-</code>, the updated object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+plot.fv">plot.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- Kest(cells)
   fvnames(K, ".y")
   fvnames(K, ".y") &lt;- "trans"
</code></pre>

<hr>
<h2 id='G3est'>
Nearest Neighbour Distance Distribution Function
of a Three-Dimensional Point Pattern
</h2><span id='topic+G3est'></span>

<h3>Description</h3>

<p>Estimates the nearest-neighbour distance distribution function
<code class="reqn">G_3(r)</code> from a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G3est(X, ..., rmax = NULL, nrval = 128, correction = c("rs", "km", "Hanisch"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G3est_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="G3est_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="G3est_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum value of argument <code class="reqn">r</code> for which
<code class="reqn">G_3(r)</code> will be estimated. 
</p>
</td></tr>
<tr><td><code id="G3est_+3A_nrval">nrval</code></td>
<td>

<p>Optional. Number of values of <code class="reqn">r</code> for which
<code class="reqn">G_3(r)</code> will be estimated. A large value of <code>nrval</code>
is required to avoid discretisation effects.
</p>
</td></tr>
<tr><td><code id="G3est_+3A_correction">correction</code></td>
<td>

<p>Optional. Character vector specifying the edge correction(s)
to be applied. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a stationary point process <code class="reqn">\Phi</code> in three-dimensional
space, the nearest-neighbour function
is
</p>
<p style="text-align: center;"><code class="reqn">
    G_3(r) = P(d^\ast(x,\Phi) \le r \mid x \in \Phi)
  </code>
</p>

<p>the cumulative distribution function of the distance 
<code class="reqn">d^\ast(x,\Phi)</code> from a typical point <code class="reqn">x</code>
in  <code class="reqn">\Phi</code> to its nearest neighbour, i.e.
to the nearest <em>other</em> point of <code class="reqn">\Phi</code>.
</p>
<p>The three-dimensional point pattern <code>X</code> is assumed to be a
partial realisation of a stationary point process <code class="reqn">\Phi</code>.
The nearest neighbour function of <code class="reqn">\Phi</code> can then be estimated using
techniques described in the References. For each data point, the
distance to the nearest neighbour is computed.
The empirical cumulative distribution
function of these values, with appropriate edge corrections, is the
estimate of <code class="reqn">G_3(r)</code>.
</p>
<p>The available edge corrections are:
</p>

<dl>
<dt><code>"rs"</code>:</dt><dd>
<p>the reduced sample (aka minus sampling, border correction)
estimator (Baddeley et al, 1993)
</p>
</dd>
<dt><code>"km"</code>:</dt><dd>
<p>the three-dimensional version of the
Kaplan-Meier estimator (Baddeley and Gill, 1997)
</p>
</dd>
<dt><code>"Hanisch"</code>:</dt><dd>
<p>the three-dimensional generalisation of
the Hanisch estimator (Hanisch, 1984).
</p>
</dd>
</dl>

<p>Alternatively <code>correction="all"</code> selects all options.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>) that can be
plotted, printed or coerced to a data frame containing the function values.
</p>


<h3>Warnings</h3>

<p>A large value of <code>nrval</code> is required in order to avoid
discretisation effects (due to the use of histograms in the
calculation).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rana Moyeed.
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A. (1993)
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b>, 641&ndash;668.
</p>
<p>Baddeley, A.J. and Gill, R.D. (1997)
Kaplan-Meier estimators of interpoint distance
distributions for spatial point processes.
<em>Annals of Statistics</em> <b>25</b>, 263&ndash;292.
</p>
<p>Hanisch, K.-H. (1984) 
Some remarks on estimators of the distribution function
of nearest neighbour distance in stationary spatial point patterns.
<em>Mathematische Operationsforschung und Statistik, series Statistics</em>
<b>15</b>, 409&ndash;412.
</p>


<h3>See Also</h3>

<p><code>pp3</code> to create a three-dimensional point
pattern (object of class <code>"pp3"</code>).
</p>
<p><code><a href="#topic+F3est">F3est</a></code>,
<code><a href="#topic+K3est">K3est</a></code>,
<code><a href="#topic+pcf3est">pcf3est</a></code> for other summary functions of
a three-dimensional point pattern.
</p>
<p><code><a href="#topic+Gest">Gest</a></code> to estimate the empty space function of
point patterns in two dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp3(42)
  Z &lt;- G3est(X)
  if(interactive()) plot(Z)
</code></pre>

<hr>
<h2 id='Gcross'>
Multitype Nearest Neighbour Distance Function (i-to-j)
</h2><span id='topic+Gcross'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the distribution of the distance
from a point of type <code class="reqn">i</code>
to the nearest point of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gcross(X, i, j, r=NULL, breaks=NULL, ..., correction=c("rs", "km", "han"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross type distance distribution function
<code class="reqn">G_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">G_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Gcross_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Gcross</code> and its companions
<code><a href="#topic+Gdot">Gdot</a></code> and <code><a href="#topic+Gmulti">Gmulti</a></code>
are generalisations of the function <code><a href="#topic+Gest">Gest</a></code>
to multitype point patterns. 
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
The arguments <code>i</code> and <code>j</code> will be interpreted as
levels of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as
the number 3, <b>not</b> the 3rd smallest level). 
</p>
<p>The &ldquo;cross-type&rdquo; (type <code class="reqn">i</code> to type <code class="reqn">j</code>)
nearest neighbour distance distribution function 
of a multitype point process 
is the cumulative distribution function <code class="reqn">G_{ij}(r)</code>
of the distance from a typical random point of the process with type <code class="reqn">i</code>
the nearest point of type <code class="reqn">j</code>. 
</p>
<p>An estimate of <code class="reqn">G_{ij}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern.
If the process of type <code class="reqn">i</code> points
were independent of the process of type <code class="reqn">j</code> points,
then <code class="reqn">G_{ij}(r)</code> would equal <code class="reqn">F_j(r)</code>,
the empty space function of the type <code class="reqn">j</code> points.
For a multitype Poisson point process where the type <code class="reqn">i</code> points
have intensity <code class="reqn">\lambda_i</code>, we have
</p>
<p style="text-align: center;"><code class="reqn">G_{ij}(r) = 1 - e^{ - \lambda_j \pi r^2} </code>
</p>

<p>Deviations between the empirical and theoretical <code class="reqn">G_{ij}</code> curves
may suggest dependence between the points of types <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>This algorithm estimates the distribution function <code class="reqn">G_{ij}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Gest">Gest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G_{ij}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The reduced-sample and
Kaplan-Meier estimators are computed from histogram counts. 
In the case of the Kaplan-Meier estimator this introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the successive entries of <code>r</code>
must be finely spaced.
</p>
<p>The algorithm also returns an estimate of the hazard rate function, 
<code class="reqn">\lambda(r)</code>, of <code class="reqn">G_{ij}(r)</code>. 
This estimate should be used with caution as <code class="reqn">G_{ij}(r)</code>
is not necessarily differentiable.
</p>
<p>The naive empirical distribution of distances from each point of
the pattern <code>X</code> to the nearest other point of the pattern, 
is a biased estimate of <code class="reqn">G_{ij}</code>.
However this is also returned by the algorithm, as it is sometimes 
useful in other contexts. Care should be taken not to use the uncorrected
empirical <code class="reqn">G_{ij}</code> as if it were an unbiased estimator of
<code class="reqn">G_{ij}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">G_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">G_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">G_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">G_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">G_{ij}(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">G_{ij}(r)</code>,
i.e. the empirical distribution of the distances from 
each point of type <code class="reqn">i</code> to the nearest point of type <code class="reqn">j</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">G_{ij}(r)</code>
for a marked Poisson process with the same estimated intensity
(see below).
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are always interpreted as
levels of the factor <code>X$marks</code>. They are converted to character
strings if they are not already character strings.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>
<p>The function <code class="reqn">G_{ij}</code> does not necessarily have a density. 
</p>
<p>The reduced sample estimator of <code class="reqn">G_{ij}</code> is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>. Its range is always 
within <code class="reqn">[0,1]</code>.
</p>
<p>The spatial Kaplan-Meier estimator of <code class="reqn">G_{ij}</code>
is always nondecreasing
but its maximum value may be less than <code class="reqn">1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Diggle, P. J. (1986).
Displaced amacrine cells in the retina of a
rabbit : analysis of a bivariate spatial point pattern. 
<em>J. Neurosci. Meth.</em> <b>18</b>, 115&ndash;125.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gdot">Gdot</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Gmulti">Gmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # amacrine cells data
    G01 &lt;- Gcross(amacrine)

    # equivalent to:
    
      G01 &lt;- Gcross(amacrine, "off", "on")
    

    plot(G01)

    # empty space function of `on' points
    if(interactive()) {
       F1 &lt;- Fest(split(amacrine)$on, r = G01$r)
       lines(F1$r, F1$km, lty=3)
    }

    # synthetic example    
    pp &lt;- runifpoispp(30)
    pp &lt;- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
    G &lt;- Gcross(pp, "0", "1")   # note: "0" not 0
</code></pre>

<hr>
<h2 id='Gcross.inhom'>
Inhomogeneous Multitype G Cross Function
</h2><span id='topic+Gcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the cross <code class="reqn">G</code> function,
which is the distribution of the distance
from a point of type <code class="reqn">i</code>
to the nearest point of type <code class="reqn">j</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Gcross.inhom(X, i, j,
              lambda = NULL, lambdaI = NULL, lambdaJ = NULL,
              lambdamin = NULL,
              ...,
              r = NULL,
              ReferenceMeasureMarkSetI = NULL,
              ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous cross type <code class="reqn">G</code> function
<code class="reqn">G_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the point process.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the the estimated intensity of the sub-process of
points of type <code>j</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>j</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location. 
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution for the computation.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">G</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="Gcross.inhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the function <code><a href="#topic+Gcross">Gcross</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Ginhom">Ginhom</a></code>.
</p>
<p>The argument <code>lambdaI</code> supplies the values
of the intensity of the sub-process of points of type <code>i</code>.
It may be either
</p>

<dl>
<dt>a pixel image</dt><dd><p>(object of class <code>"im"</code>) which
gives the values of the type <code>i</code> intensity
at all locations in the window containing <code>X</code>;
</p>
</dd>
<dt>a numeric vector</dt><dd><p>containing the values of the
type <code>i</code> intensity evaluated only
at the data points of type <code>i</code>. The length of this vector
must equal the number of type <code>i</code> points in <code>X</code>.
</p>
</dd>
<dt>a function</dt><dd>
<p>of the form <code>function(x,y)</code>
which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambdaI</code> is omitted then it will be estimated
using a leave-one-out kernel smoother. 
</p>
</dd>
</dl>

<p>If <code>lambdaI</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
<p>Similarly the argument <code>lambdaJ</code> should contain
estimated values of the intensity of the points of type <code class="reqn">j</code>.
It may be either a pixel image, a numeric vector of length equal
to the number of points in <code>X</code>, a function, or omitted.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>)
containing estimates of the inhomogeneous cross type <code class="reqn">G</code> function.
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Ginhom">Ginhom</a></code>,
<code><a href="#topic+Gcross.inhom">Gcross.inhom</a></code>,
<code><a href="#topic+Gmulti.inhom">Gmulti.inhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
  } else {
    ## for package testing 
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
  }
  GC &lt;- Gcross.inhom(X, "on", "off", lambda=lam, lambdamin=lmin)
</code></pre>

<hr>
<h2 id='Gdot'>
Multitype Nearest Neighbour Distance Function (i-to-any)
</h2><span id='topic+Gdot'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the distribution of the distance
from a point of type <code class="reqn">i</code>
to the nearest other point of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gdot(X, i, r=NULL, breaks=NULL, ..., correction=c("km", "rs", "han"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gdot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the 
distance distribution function
<code class="reqn">G_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Gdot_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gdot_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">G_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Gdot_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gdot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Gdot_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Gdot</code> and its companions
<code><a href="#topic+Gcross">Gcross</a></code> and <code><a href="#topic+Gmulti">Gmulti</a></code>
are generalisations of the function <code><a href="#topic+Gest">Gest</a></code>
to multitype point patterns.
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
The argument will be interpreted as a
level of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as the number 3,
<b>not</b> the 3rd smallest level.)
</p>
<p>The &ldquo;dot-type&rdquo; (type <code class="reqn">i</code> to any type)
nearest neighbour distance distribution function 
of a multitype point process 
is the cumulative distribution function <code class="reqn">G_{i\bullet}(r)</code>
of the distance from a typical random point of the process with type <code class="reqn">i</code>
the nearest other point of the process, regardless of type. 
</p>
<p>An estimate of <code class="reqn">G_{i\bullet}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern.
If the type <code class="reqn">i</code> points
were independent of all other points,
then <code class="reqn">G_{i\bullet}(r)</code> would equal <code class="reqn">G_{ii}(r)</code>,
the nearest neighbour distance distribution function of the type
<code class="reqn">i</code> points alone.
For a multitype Poisson point process with total intensity
<code class="reqn">\lambda</code>, we have
</p>
<p style="text-align: center;"><code class="reqn">G_{i\bullet}(r) = 1 - e^{ - \lambda \pi r^2} </code>
</p>

<p>Deviations between the empirical and theoretical
<code class="reqn">G_{i\bullet}</code> curves
may suggest dependence of the type <code class="reqn">i</code> points on the other points.
</p>
<p>This algorithm estimates the distribution function
<code class="reqn">G_{i\bullet}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Gest">Gest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G_{i\bullet}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The reduced-sample and
Kaplan-Meier estimators are computed from histogram counts. 
In the case of the Kaplan-Meier estimator this introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the successive entries of <code>r</code>
must be finely spaced.
</p>
<p>The algorithm also returns an estimate of the hazard rate function, 
<code class="reqn">\lambda(r)</code>, of <code class="reqn">G_{i\bullet}(r)</code>. 
This estimate should be used with caution as
<code class="reqn">G_{i\bullet}(r)</code>
is not necessarily differentiable.
</p>
<p>The naive empirical distribution of distances from each point of
the pattern <code>X</code> to the nearest other point of the pattern, 
is a biased estimate of <code class="reqn">G_{i\bullet}</code>.
However this is also returned by the algorithm, as it is sometimes 
useful in other contexts. Care should be taken not to use the uncorrected
empirical <code class="reqn">G_{i\bullet}</code> as if it were an unbiased estimator of
<code class="reqn">G_{i\bullet}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">G_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">G_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">G_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">G_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">G_{i\bullet}(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">G_{i\bullet}(r)</code>,
i.e. the empirical distribution of the distances from 
each point of type <code class="reqn">i</code> to the nearest other point of any type.
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">G_{i\bullet}(r)</code>
for a marked Poisson process with the same estimated intensity
(see below).
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>
<p>The function <code class="reqn">G_{i\bullet}</code> does not necessarily have a density. 
</p>
<p>The reduced sample estimator of <code class="reqn">G_{i\bullet}</code>
is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>. Its range is always 
within <code class="reqn">[0,1]</code>.
</p>
<p>The spatial Kaplan-Meier estimator of <code class="reqn">G_{i\bullet}</code>
is always nondecreasing
but its maximum value may be less than <code class="reqn">1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Diggle, P. J. (1986).
Displaced amacrine cells in the retina of a
rabbit : analysis of a bivariate spatial point pattern. 
<em>J. Neurosci. Meth.</em> <b>18</b>, 115&ndash;125.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Gmulti">Gmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # amacrine cells data
    G0. &lt;- Gdot(amacrine, "off") 
    plot(G0.)

    # synthetic example    
    pp &lt;- runifpoispp(30)
    pp &lt;- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
    G &lt;- Gdot(pp, "0")
    G &lt;- Gdot(pp, 0) # equivalent
</code></pre>

<hr>
<h2 id='Gdot.inhom'>
Inhomogeneous Multitype G Dot Function
</h2><span id='topic+Gdot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the dot <code class="reqn">G</code> function,
which is the distribution of the distance
from a point of type <code class="reqn">i</code>
to the nearest other point of any type,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Gdot.inhom(X, i,
              lambdaI = NULL, lambdadot = NULL, lambdamin = NULL,
              ...,
              r = NULL, ReferenceMeasureMarkSetI = NULL, ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gdot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous dot type <code class="reqn">G</code> function
<code class="reqn">G_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the entire point process,
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values at each of the 
points in <code>X</code>, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous dot type <code class="reqn">G</code> function
<code class="reqn">G_{i\bullet}(r)</code> should be evaluated.
Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="Gdot.inhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the function <code><a href="#topic+Gdot">Gdot</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Ginhom">Ginhom</a></code>.
</p>
<p>The argument <code>lambdaI</code> supplies the values
of the intensity of the sub-process of points of type <code>i</code>.
It may be either
</p>

<dl>
<dt>a pixel image</dt><dd><p>(object of class <code>"im"</code>) which
gives the values of the type <code>i</code> intensity
at all locations in the window containing <code>X</code>;
</p>
</dd>
<dt>a numeric vector</dt><dd><p>containing the values of the
type <code>i</code> intensity evaluated only
at the data points of type <code>i</code>. The length of this vector
must equal the number of type <code>i</code> points in <code>X</code>.
</p>
</dd>
<dt>a function</dt><dd>
<p>of the form <code>function(x,y)</code>
which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambdaI</code> is omitted then it will be estimated
using a leave-one-out kernel smoother. 
</p>
</dd>
</dl>

<p>If <code>lambdaI</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
<p>Similarly the argument <code>lambdadot</code> should contain
estimated values of the intensity of the entire point process.
It may be either a pixel image, a numeric vector of length equal
to the number of points in <code>X</code>, a function, or omitted.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>)
containing estimates of the inhomogeneous dot type <code class="reqn">G</code> function.
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gdot">Gdot</a></code>,
<code><a href="#topic+Ginhom">Ginhom</a></code>,
<code><a href="#topic+Gcross.inhom">Gcross.inhom</a></code>,
<code><a href="#topic+Gmulti.inhom">Gmulti.inhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
  } else {
    ## for package testing 
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
  }
  lamI &lt;- lam[marks(X) == "on"]
  GD &lt;- Gdot.inhom(X, "on", lambdaI=lamI, lambdadot=lam, lambdamin=lmin)
</code></pre>

<hr>
<h2 id='Gest'>
Nearest Neighbour Distance Function G
</h2><span id='topic+Gest'></span><span id='topic+nearest.neighbour'></span>

<h3>Description</h3>

<p>Estimates the nearest neighbour distance distribution
function <code class="reqn">G(r)</code> from a point pattern in a 
window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gest(X, r=NULL, breaks=NULL, ...,
     correction=c("rs", "km", "han"),
     domain=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gest_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">G(r)</code> will be computed.
An object of class <code>ppp</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Gest_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which <code class="reqn">G(r)</code> should be evaluated. There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Gest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Gest_+3A_correction">correction</code></td>
<td>

<p>Optional.
The edge correction(s) to be used to estimate <code class="reqn">G(r)</code>.
A vector of character strings selected from
<code>"none"</code>, <code>"rs"</code>, <code>"km"</code>, <code>"Hanisch"</code>
and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Gest_+3A_domain">domain</code></td>
<td>

<p>Optional. Calculations will be restricted to this subset
of the window. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nearest neighbour distance distribution function 
(also called the &ldquo;<em>event-to-event</em>&rdquo; or
&ldquo;<em>inter-event</em>&rdquo; distribution)
of a point process <code class="reqn">X</code>
is the cumulative distribution function <code class="reqn">G</code> of the distance
from a typical random point of <code class="reqn">X</code> to
the nearest other point of <code class="reqn">X</code>.
</p>
<p>An estimate of <code class="reqn">G</code> derived from a spatial point pattern dataset
can be used in exploratory data analysis and formal inference
about the pattern (Cressie, 1991; Diggle, 1983; Ripley, 1988).
In exploratory analyses, the estimate of <code class="reqn">G</code> is a useful statistic 
summarising one aspect of the &ldquo;clustering&rdquo; of points.
For inferential purposes, the estimate of <code class="reqn">G</code> is usually compared to the 
true value of <code class="reqn">G</code> for a completely random (Poisson) point process,
which is
</p>
<p style="text-align: center;"><code class="reqn">G(r) = 1 - e^{ - \lambda \pi r^2} </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity
(expected number of points per unit area).
Deviations between the empirical and theoretical <code class="reqn">G</code> curves
may suggest spatial clustering or spatial regularity.
</p>
<p>This algorithm estimates the nearest neighbour distance distribution
function <code class="reqn">G</code>
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape. 
</p>
<p>The argument <code>X</code> is interpreted as a point pattern object 
(of class <code>"ppp"</code>, see <code>ppp.object</code>) and can
be supplied in any of the formats recognised
by <code>as.ppp()</code>. 
</p>
<p>The estimation of <code class="reqn">G</code> is hampered by edge effects arising from 
the unobservability of points of the random pattern outside the window. 
An edge correction is needed to reduce bias (Baddeley, 1998; Ripley, 1988). 
The edge corrections implemented here are the border method or
&ldquo;<em>reduced sample</em>&rdquo; estimator, the spatial Kaplan-Meier estimator
(Baddeley and Gill, 1997) and the Hanisch estimator (Hanisch, 1984).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The 
estimators are computed from histogram counts. 
This introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the successive entries of <code>r</code>
must be finely spaced.
</p>
<p>The algorithm also returns an estimate of the hazard rate function, 
<code class="reqn">\lambda(r)</code>, of <code class="reqn">G(r)</code>. The hazard rate is
defined as the derivative
</p>
<p style="text-align: center;"><code class="reqn">\lambda(r) = - \frac{d}{dr} \log (1 - G(r))</code>
</p>

<p>This estimate should be used with caution as <code class="reqn">G</code> is not necessarily
differentiable.
</p>
<p>If the argument <code>domain</code> is given, the estimate of <code class="reqn">G(r)</code>
will be based only on the nearest neighbour distances
measured from points falling inside <code>domain</code> (although their
nearest neighbours may lie outside <code>domain</code>).
This is useful in bootstrap techniques. The argument <code>domain</code>
should be a window (object of class <code>"owin"</code>) or something acceptable to
<code>as.owin</code>. It must be a subset of the
window of the point pattern <code>X</code>.
</p>
<p>The naive empirical distribution of distances from each point of
the pattern <code>X</code> to the nearest other point of the pattern, 
is a biased estimate of <code class="reqn">G</code>. However it is sometimes useful.
It can be returned by the algorithm, by selecting <code>correction="none"</code>.
Care should be taken not to use the uncorrected
empirical <code class="reqn">G</code> as if it were an unbiased estimator of  <code class="reqn">G</code>.
</p>
<p>To simply compute the nearest neighbour distance for each point in the
pattern, use <code>nndist</code>. To determine which point is the
nearest neighbour of a given point, use <code>nnwhich</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing some or all of the following
columns:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">G(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">G(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">G(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">G(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">G(r)</code>,
i.e. the empirical distribution of the distances from 
each point in the pattern <code>X</code> to the nearest other point of
the pattern
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch correction estimator of <code class="reqn">G(r)</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">G(r)</code>
for a stationary Poisson process of the same estimated intensity.
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The function <code class="reqn">G</code> does not necessarily have a density. 
Any valid c.d.f. may appear as the nearest neighbour distance
distribution function of a stationary point process.
</p>
<p>The reduced sample estimator of <code class="reqn">G</code> is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>. Its range is always 
within <code class="reqn">[0,1]</code>.
</p>
<p>The spatial Kaplan-Meier estimator of <code class="reqn">G</code> is always nondecreasing
but its maximum value may be less than <code class="reqn">1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. Spatial sampling and censoring.
In O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. van Lieshout (eds) 
<em>Stochastic Geometry: Likelihood and Computation</em>.
Chapman and Hall, 1998.
Chapter 2, pages 37-78.
</p>
<p>Baddeley, A.J. and Gill, R.D.
Kaplan-Meier estimators of interpoint distance
distributions for spatial point processes.
<em>Annals of Statistics</em> <b>25</b> (1997) 263-292.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Hanisch, K.-H. (1984) Some remarks on estimators of the distribution
function of nearest-neighbour distance in stationary spatial point
patterns. <em>Mathematische Operationsforschung und Statistik,
series Statistics</em> <b>15</b>, 409&ndash;412.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>


<h3>See Also</h3>

<p><code>nndist</code>,
<code>nnwhich</code>,
<code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>,
<code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  G &lt;- Gest(cells)
  plot(G)

  # P-P style plot
  plot(G, cbind(km,theo) ~ theo)

  # the empirical G is below the Poisson G,
  # indicating an inhibited pattern

  if(interactive()) {
     plot(G, . ~ r)
     plot(G, . ~ theo)
     plot(G, asin(sqrt(.)) ~ asin(sqrt(theo)))
  }
</code></pre>

<hr>
<h2 id='Gfox'>
Foxall's Distance Functions
</h2><span id='topic+Gfox'></span><span id='topic+Jfox'></span>

<h3>Description</h3>

<p>Given a point pattern <code>X</code> and a spatial object <code>Y</code>,
compute estimates of Foxall's  <code class="reqn">G</code> and <code class="reqn">J</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gfox(X, Y, r=NULL, breaks=NULL, correction=c("km", "rs", "han"), W, ...)
Jfox(X, Y, r=NULL, breaks=NULL, correction=c("km", "rs", "han"), W, ...,
     warn.trim=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gfox_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
from which distances will be measured.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_y">Y</code></td>
<td>

<p>An object of class <code>"ppp"</code>, <code>"psp"</code> or <code>"owin"</code>
to which distances will be measured. Alternatively a pixel image
(class <code>"im"</code>) with logical values.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which <code class="reqn">Gfox(r)</code> or <code class="reqn">Jfox(r)</code>
should be evaluated. There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_correction">correction</code></td>
<td>

<p>Optional.
The edge correction(s) to be used to estimate
<code class="reqn">Gfox(r)</code> or <code class="reqn">Jfox(r)</code>.
A vector of character strings selected from
<code>"none"</code>, <code>"rs"</code>, <code>"km"</code>, <code>"cs"</code>
and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_w">W</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>)
to be taken as the window of observation.
The distribution function will be estimated from data inside <code>W</code>.
The default is <code>W=Frame(Y)</code> when <code>Y</code> is a window,
and <code>W=Window(Y)</code> otherwise.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_...">...</code></td>
<td>

<p>Extra arguments affecting the discretisation of distances.
These arguments are ignored by <code>Gfox</code>, but
<code>Jfox</code> passes them to <code><a href="#topic+Hest">Hest</a></code> to determine
the discretisation of the spatial domain.
</p>
</td></tr>
<tr><td><code id="Gfox_+3A_warn.trim">warn.trim</code></td>
<td>

<p>Logical value indicating whether a warning should be issued
by <code>Jfox</code> when the window of <code>X</code> had to be trimmed
in order to be a subset of the frame of <code>Y</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a point pattern <code>X</code> and another spatial object <code>Y</code>,
these functions compute two nonparametric measures of association
between <code>X</code> and <code>Y</code>, introduced by Foxall
(Foxall and Baddeley, 2002).
</p>
<p>Let the random variable <code class="reqn">R</code> be the distance from a typical point
of <code>X</code> to the object <code>Y</code>.
Foxall's <code class="reqn">G</code>-function is the cumulative distribution function
of <code class="reqn">R</code>:
</p>
<p style="text-align: center;"><code class="reqn">G(r) = P(R \le r)</code>
</p>

<p>Let the random variable <code class="reqn">S</code> be the distance from a <em>fixed</em> point
in space to the object <code>Y</code>. The cumulative distribution function
of <code class="reqn">S</code> is the (unconditional) spherical contact distribution
function
</p>
<p style="text-align: center;"><code class="reqn">H(r) = P(S \le r)</code>
</p>

<p>which is computed by <code><a href="#topic+Hest">Hest</a></code>.
</p>
<p>Foxall's <code class="reqn">J</code>-function is the ratio
</p>
<p style="text-align: center;"><code class="reqn">
    J(r) = \frac{1-G(r)}{1-H(r)}
  </code>
</p>

<p>For further interpretation, see Foxall and Baddeley (2002).
</p>
<p>Accuracy of <code>Jfox</code> depends on the pixel resolution,
which is controlled by the
arguments <code>eps</code>, <code>dimyx</code> and <code>xy</code> passed to
<code><a href="grid.html#topic+as.mask">as.mask</a></code>. For example, use <code>eps=0.1</code> to specify
square pixels of side 0.1 units, and <code>dimyx=256</code> to specify a
256 by 256 grid of pixels.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
which can be printed, plotted, or converted to a data frame of values.
</p>


<h3>Author(s)</h3>

<p>Rob Foxall and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Foxall, R. and Baddeley, A. (2002)
Nonparametric measures of association between a
spatial point process and a random set, with
geological applications. <em>Applied Statistics</em> <b>51</b>, 165&ndash;182.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gest">Gest</a></code>, 
<code><a href="#topic+Hest">Hest</a></code>, 
<code><a href="#topic+Jest">Jest</a></code>, 
<code><a href="#topic+Fest">Fest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- copper$SouthPoints
  Y &lt;- copper$SouthLines
  G &lt;- Gfox(X,Y)
  J &lt;- Jfox(X,Y, correction="km")
  
</code></pre>

<hr>
<h2 id='Ginhom'>
Inhomogeneous Nearest Neighbour Function
</h2><span id='topic+Ginhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous nearest neighbour function <code class="reqn">G</code> of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Ginhom(X, lambda = NULL, lmin = NULL, ...,
        sigma = NULL, varcov = NULL,
        r = NULL, breaks = NULL, ratio = FALSE,
        update = TRUE, warn.bias=TRUE, savelambda=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ginhom_+3A_x">X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">G</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_lmin">lmin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_sigma">sigma</code>, <code id="Ginhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution, or passed to <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_update">update</code></td>
<td>

<p>Logical. If <code>lambda</code> is a fitted model
(class <code>"ppm"</code> or <code>"kppm"</code>)
and <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_warn.bias">warn.bias</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when the inhomogeneity correction factor takes extreme values,
which can often lead to biased results. This usually occurs
when insufficient smoothing is used to estimate the intensity.
</p>
</td></tr>
<tr><td><code id="Ginhom_+3A_savelambda">savelambda</code></td>
<td>

<p>Logical value specifying whether to save the values of
<code>lmin</code> and <code>lambda</code> as attributes of the result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes estimates of the 
inhomogeneous <code class="reqn">G</code>-function (van Lieshout, 2010)
of a point pattern. It is the counterpart, for inhomogeneous
spatial point patterns, of the nearest-neighbour distance
distribution function <code class="reqn">G</code> 
for homogeneous point patterns computed by <code><a href="#topic+Gest">Gest</a></code>.
</p>
<p>The argument <code>X</code> should be a point pattern
(object of class <code>"ppp"</code>).
</p>
<p>The inhomogeneous <code class="reqn">G</code> function is computed
using the border correction, equation (7) in Van Lieshout (2010).
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>
of the point process. It may be either
</p>

<dl>
<dt>a numeric vector</dt><dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt><dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code> or <code>"kppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
</dd>
</dl>

<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code><a href="#topic+blur">blur</a></code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Marie-Colette van Lieshout.
C implementation and R adaptation by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>Van Lieshout, M.N.M. (2010)
A J-function for inhomogeneous point processes.
<em>Statistica Neerlandica</em> <b>65</b>, 183&ndash;201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Finhom">Finhom</a></code>,
<code><a href="#topic+Jinhom">Jinhom</a></code>,
<code><a href="#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(Ginhom(swedishpines, sigma=10))

  
    plot(Ginhom(swedishpines, sigma=bw.diggle, adjust=2))
  
</code></pre>

<hr>
<h2 id='Gmulti'>
Marked Nearest Neighbour Distance Function
</h2><span id='topic+Gmulti'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the distribution of the distance
from a typical point in subset <code>I</code>
to the nearest point of subset <code class="reqn">J</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmulti(X, I, J, r=NULL, breaks=NULL, ...,
        disjoint=NULL, correction=c("rs", "km", "han"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gmulti_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the multitype distance distribution function
<code class="reqn">G_{IJ}(r)</code> will be computed.
It must be a marked point pattern.
See under Details.
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_i">I</code></td>
<td>
<p>Subset of points of <code>X</code> from which distances are
measured. 
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_j">J</code></td>
<td>
<p>Subset of points in <code>X</code> to which distances are measured.
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">G_{IJ}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_disjoint">disjoint</code></td>
<td>
<p>Optional flag indicating whether
the subsets <code>I</code> and <code>J</code> are disjoint.
If missing, this value will be computed by inspecting the
vectors <code>I</code> and <code>J</code>.
</p>
</td></tr>
<tr><td><code id="Gmulti_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Gmulti</code>
generalises <code><a href="#topic+Gest">Gest</a></code> (for unmarked point
patterns) and <code><a href="#topic+Gdot">Gdot</a></code> and <code><a href="#topic+Gcross">Gcross</a></code> (for
multitype point patterns) to arbitrary marked point patterns.
</p>
<p>Suppose <code class="reqn">X_I</code>, <code class="reqn">X_J</code> are subsets, possibly
overlapping, of a marked point process. This function computes an
estimate of the cumulative
distribution function <code class="reqn">G_{IJ}(r)</code> of the distance
from a typical point of  <code class="reqn">X_I</code> to the nearest distinct point of
<code class="reqn">X_J</code>. 
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
</p>
<p>The arguments <code>I</code> and <code>J</code> specify two subsets of the
point pattern. They may be any type of subset indices, for example,
logical vectors of length equal to <code>npoints(X)</code>,
or integer vectors with entries in the range 1 to
<code>npoints(X)</code>, or negative integer vectors.
</p>
<p>Alternatively, <code>I</code> and <code>J</code> may be <b>functions</b>
that will be applied to the point pattern <code>X</code> to obtain
index vectors. If <code>I</code> is a function, then evaluating
<code>I(X)</code> should yield a valid subset index. This option
is useful when generating simulation envelopes using
<code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>This algorithm estimates the distribution function <code class="reqn">G_{IJ}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Gest">Gest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">G_{IJ}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The reduced-sample and
Kaplan-Meier estimators are computed from histogram counts. 
In the case of the Kaplan-Meier estimator this introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the successive entries of <code>r</code>
must be finely spaced.
</p>
<p>The algorithm also returns an estimate of the hazard rate function, 
<code class="reqn">\lambda(r)</code>, of <code class="reqn">G_{IJ}(r)</code>. 
This estimate should be used with caution as <code class="reqn">G_{IJ}(r)</code>
is not necessarily differentiable.
</p>
<p>The naive empirical distribution of distances from each point of
the pattern <code>X</code> to the nearest other point of the pattern, 
is a biased estimate of <code class="reqn">G_{IJ}</code>.
However this is also returned by the algorithm, as it is sometimes 
useful in other contexts. Care should be taken not to use the uncorrected
empirical <code class="reqn">G_{IJ}</code> as if it were an unbiased estimator of
<code class="reqn">G_{IJ}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">G_{IJ}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">G_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">G_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">G_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">G_{IJ}(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">G_{IJ}(r)</code>,
i.e. the empirical distribution of the distances from 
each point of type <code class="reqn">i</code> to the nearest point of type <code class="reqn">j</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">G_{IJ}(r)</code>
for a marked Poisson process with the same estimated intensity
</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The function <code class="reqn">G_{IJ}</code> does not necessarily have a density. 
</p>
<p>The reduced sample estimator of <code class="reqn">G_{IJ}</code> is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>. Its range is always 
within <code class="reqn">[0,1]</code>.
</p>
<p>The spatial Kaplan-Meier estimator of <code class="reqn">G_{IJ}</code>
is always nondecreasing
but its maximum value may be less than <code class="reqn">1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Diggle, P. J. (1986).
Displaced amacrine cells in the retina of a
rabbit : analysis of a bivariate spatial point pattern. 
<em>J. Neurosci. Meth.</em> <b>18</b>, 115&ndash;125.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gcross">Gcross</a></code>,
<code><a href="#topic+Gdot">Gdot</a></code>,
<code><a href="#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    trees &lt;- longleaf
     # Longleaf Pine data: marks represent diameter
    
    Gm &lt;- Gmulti(trees, marks(trees) &lt;= 15, marks(trees) &gt;= 25)
    plot(Gm)
</code></pre>

<hr>
<h2 id='GmultiInhom'>
Inhomogeneous Marked G-Function
</h2><span id='topic+GmultiInhom'></span><span id='topic+Gmulti.inhom'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the inhomogeneous version of the multitype <code class="reqn">G</code> function,
effectively the cumulative distribution function of the distance from
a point in subset <code class="reqn">I</code> to the nearest point in subset <code class="reqn">J</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Gmulti.inhom(X, I, J,
             lambda = NULL, lambdaI = NULL, lambdaJ = NULL,
             lambdamin = NULL, ...,
             r = NULL,
             ReferenceMeasureMarkSetI = NULL,
             ratio = FALSE)

  GmultiInhom(X, I, J,
             lambda = NULL, lambdaI = NULL, lambdaJ = NULL,
             lambdamin = NULL, ...,
             r = NULL,
             ReferenceMeasureMarkSetI = NULL,
             ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GmultiInhom_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_i">I</code></td>
<td>

<p>A subset index specifying the subset of points <em>from</em> which
distances are measured. Any kind of subset index acceptable
to <code>[.ppp</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_j">J</code></td>
<td>

<p>A subset index specifying the subset of points <em>to</em> which
distances are measured. Any kind of subset index acceptable
to <code>[.ppp</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity estimates for each point of <code>X</code>.
A numeric vector of length equal to <code>npoints(X)</code>.
Incompatible with <code>lambdaI,lambdaJ</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Intensity estimates for each point of <code>X[I]</code>.
A numeric vector of length equal to <code>npoints(X[I])</code>.
Incompatible with <code>lambda</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Intensity estimates for each point of <code>X[J]</code>.
A numeric vector of length equal to <code>npoints(X[J])</code>.
Incompatible with <code>lambda</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>A lower bound for the intensity,
or at least a lower bound for the values in <code>lambdaJ</code>
or <code>lambda[J]</code>.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_...">...</code></td>
<td>

<p>Ignored. 
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_r">r</code></td>
<td>

<p>Vector of distance values at which the inhomogeneous <code class="reqn">G</code>
function should be estimated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="GmultiInhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Cronie and Van Lieshout (2015).
</p>
<p>The functions <code>GmultiInhom</code> and <code>Gmulti.inhom</code> are identical.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> containing the estimate of the
inhomogeneous multitype <code class="reqn">G</code> function.
</p>


<h3>Author(s)</h3>

<p>Ottmar Cronie and Marie-Colette van Lieshout.
Rewritten for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ginhom">Ginhom</a></code>,
<code><a href="#topic+Gmulti">Gmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  I &lt;- (marks(X) == "on")
  J &lt;- (marks(X) == "off")
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
  } else {
    ## for package testing
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
  }
  plot(GmultiInhom(X, I, J, lambda=lam, lambdamin=lmin))
  # equivalent
  plot(GmultiInhom(X, I, J, lambdaI=lam[I], lambdaJ=lam[J], lambdamin=lmin),
       main="")
</code></pre>

<hr>
<h2 id='harmonise.fv'>Make Function Tables Compatible</h2><span id='topic+harmonise.fv'></span><span id='topic+harmonize.fv'></span>

<h3>Description</h3>

<p>Convert several objects of class <code>"fv"</code> 
to the same values of the function argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
harmonise(..., strict=FALSE)

## S3 method for class 'fv'
harmonize(..., strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise.fv_+3A_...">...</code></td>
<td>

<p>Any number of function tables (objects of class <code>"fv"</code>).
</p>
</td></tr>
<tr><td><code id="harmonise.fv_+3A_strict">strict</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a column of data will be deleted
if columns of the same name do not appear in every object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function value table (object of class <code>"fv"</code>) is
essentially a data frame giving the values of a function <code class="reqn">f(x)</code>
(or several alternative estimates of this value)
at equally-spaced values of the function argument <code class="reqn">x</code>.
</p>
<p>The command <code>harmonise</code> is generic. This is the
method for objects of class <code>"fv"</code>.
</p>
<p>This command makes any number of <code>"fv"</code> objects compatible,
in the loose sense that they have the same sequence of values of
<code class="reqn">x</code>. They can then be combined by <code><a href="#topic+cbind.fv">cbind.fv</a></code>,
but not necessarily by <code><a href="#topic+eval.fv">eval.fv</a></code>.
</p>
<p>All arguments <code>...</code> must be function value tables
(objects of class <code>"fv"</code>). 
The result will be a list, of length equal to the number of
arguments <code>...</code>, containing new versions of each of these functions,
converted to a common sequence of <code class="reqn">x</code> values.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>
<p>The range of <code class="reqn">x</code> values in the resulting functions
will be the intersection of the ranges of <code class="reqn">x</code> values
in the original functions. 
The spacing of <code class="reqn">x</code> values in the resulting functions
will be the finest (narrowest) of the spacings of the
<code class="reqn">x</code> values in the original functions.
Function values are interpolated using <code><a href="stats.html#topic+approxfun">approxfun</a></code>.
</p>
<p>If <code>strict=TRUE</code>, each column of data will be retained only if
a column of the same name appears in all of the arguments <code>...</code>.
This ensures that the resulting objects are strictly compatible
in the sense of <code><a href="#topic+compatible.fv">compatible.fv</a></code>,
and can be combined using <code><a href="#topic+eval.fv">eval.fv</a></code>
or <code><a href="#topic+collapse.fv">collapse.fv</a></code>.
</p>
<p>If <code>strict=FALSE</code> (the default), this does not occur,
and then the resulting objects are <b>not</b> guaranteed to be compatible
in the sense of <code><a href="#topic+compatible.fv">compatible.fv</a></code>.
</p>


<h3>Value</h3>

<p>A list, of length equal to the number of arguments <code>...</code>,
whose entries are objects of class <code>"fv"</code>.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+cbind.fv">cbind.fv</a></code>,
<code><a href="#topic+eval.fv">eval.fv</a></code>,
<code><a href="#topic+compatible.fv">compatible.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   H &lt;- harmonise(K=Kest(cells), G=Gest(cells))
   H
</code></pre>

<hr>
<h2 id='Hest'>Spherical Contact Distribution Function</h2><span id='topic+Hest'></span>

<h3>Description</h3>

<p>Estimates the spherical contact distribution function of a
random set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hest(X, r=NULL, breaks=NULL, ...,
     W,
     correction=c("km", "rs", "han"),
     conditional=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hest_+3A_x">X</code></td>
<td>
<p>The observed random set.
An object of class <code>"ppp"</code>, <code>"psp"</code> or <code>"owin"</code>.
Alternatively a pixel image (class <code>"im"</code>) with logical values.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">H(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to control the discretisation.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_w">W</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>)
to be taken as the window of observation.
The contact distribution function will be estimated
from values of the contact distance inside <code>W</code>.
The default is <code>W=Frame(X)</code> when <code>X</code> is a window,
and <code>W=Window(X)</code> otherwise.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_correction">correction</code></td>
<td>

<p>Optional.
The edge correction(s) to be used to estimate <code class="reqn">H(r)</code>.
A vector of character strings selected from
<code>"none"</code>, <code>"rs"</code>, <code>"km"</code>, <code>"han"</code>
and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Hest_+3A_conditional">conditional</code></td>
<td>

<p>Logical value indicating whether to compute the
conditional or unconditional distribution. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spherical contact distribution function
of a stationary random set <code class="reqn">X</code>
is the cumulative distribution function <code class="reqn">H</code> of the distance
from a fixed point in space to the nearest point of <code class="reqn">X</code>,
given that the point lies outside <code class="reqn">X</code>.
That is, <code class="reqn">H(r)</code> equals
the probability that <code>X</code> lies closer than <code class="reqn">r</code> units away
from the fixed point <code class="reqn">x</code>, given that <code>X</code> does not cover <code class="reqn">x</code>.
</p>
<p>Let <code class="reqn">D = d(x,X)</code> be the shortest distance from an arbitrary
point <code class="reqn">x</code> to the set <code>X</code>. Then the spherical contact
distribution function is
</p>
<p style="text-align: center;"><code class="reqn">H(r) = P(D \le r \mid D &gt; 0)</code>
</p>

<p>For a point process, the spherical contact distribution function
is the same as the empty space function <code class="reqn">F</code> discussed
in <code><a href="#topic+Fest">Fest</a></code>. 
</p>
<p>The argument <code>X</code> may be a point pattern
(object of class <code>"ppp"</code>), a line segment pattern
(object of class <code>"psp"</code>) or a window (object of class
<code>"owin"</code>). It is assumed to be a realisation of a stationary
random set.
</p>
<p>The algorithm first calls <code>distmap</code> to compute the
distance transform of <code>X</code>, then computes the Kaplan-Meier
and reduced-sample estimates of the cumulative distribution
following Hansen et al (1999).
If <code>conditional=TRUE</code> (the default) the algorithm
returns an estimate of the spherical contact function
<code class="reqn">H(r)</code> as defined above. 
If <code>conditional=FALSE</code>, it instead returns an estimate of the
cumulative distribution function
<code class="reqn">H^\ast(r) = P(D \le r)</code>
which includes a jump at <code class="reqn">r=0</code> if <code>X</code> has nonzero area.
</p>
<p>Accuracy depends on the pixel resolution, which is controlled by the
arguments <code>eps</code>, <code>dimyx</code> and <code>xy</code> passed to
<code><a href="grid.html#topic+as.mask">as.mask</a></code>. For example, use <code>eps=0.1</code> to specify
square pixels of side 0.1 units, and <code>dimyx=256</code> to specify a
256 by 256 grid of pixels.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing up to six columns:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">H(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">H(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">H(r)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the hazard rate <code class="reqn">\lambda(r)</code>
of <code class="reqn">H(r)</code> by the spatial Kaplan-Meier method
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the spatial Hanisch-Chiu-Stoyan estimator of <code class="reqn">H(r)</code>
</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">H(r)</code>,
i.e. the empirical distribution of the distance from 
a fixed point in the window to the nearest point of <code>X</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
with contributions from Kassel Hingee.
</p>


<h3>References</h3>

<p>Baddeley, A.J. Spatial sampling and censoring.
In O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. van Lieshout (eds) 
<em>Stochastic Geometry: Likelihood and Computation</em>.
Chapman and Hall, 1998.
Chapter 2, pages 37-78.
</p>
<p>Baddeley, A.J. and Gill, R.D. 
The empty space hazard of a spatial pattern.
Research Report 1994/3, Department of Mathematics,
University of Western Australia, May 1994.
</p>
<p>Hansen, M.B., Baddeley, A.J. and Gill, R.D.
First contact distributions for spatial patterns:
regularity and estimation.
<em>Advances in Applied Probability</em> <b>31</b> (1999) 15-33.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fest">Fest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runifpoint(42)
   H &lt;- Hest(X)
   Y &lt;- rpoisline(10)
   H &lt;- Hest(Y)
   H &lt;- Hest(Y, dimyx=256)
   X &lt;- heather$coarse
   plot(Hest(X))
   H &lt;- Hest(X, conditional=FALSE)

   P &lt;- owin(poly=list(x=c(5.3, 8.5, 8.3, 3.7, 1.3, 3.7),
                       y=c(9.7, 10.0, 13.6, 14.4, 10.7, 7.2)))
   plot(X)
   plot(P, add=TRUE, col="red")
   H &lt;- Hest(X, W=P)
   Z &lt;- as.im(FALSE, Frame(X))
   Z[X] &lt;- TRUE
   Z &lt;- Z[P, drop=FALSE]
   plot(Z)
   H &lt;- Hest(Z)
</code></pre>

<hr>
<h2 id='hopskel'>Hopkins-Skellam Test</h2><span id='topic+hopskel'></span><span id='topic+hopskel.test'></span>

<h3>Description</h3>

<p>Perform the Hopkins-Skellam test of Complete Spatial Randomness,
or simply calculate the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopskel(X)

hopskel.test(X, ...,
             alternative=c("two.sided", "less", "greater",
                           "clustered", "regular"),
             method=c("asymptotic", "MonteCarlo"),
             nsim=999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopskel_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="hopskel_+3A_alternative">alternative</code></td>
<td>

<p>String indicating the type of alternative for the
hypothesis test. Partially matched.
</p>
</td></tr>
<tr><td><code id="hopskel_+3A_method">method</code></td>
<td>

<p>Method of performing the test. Partially matched.
</p>
</td></tr>
<tr><td><code id="hopskel_+3A_nsim">nsim</code></td>
<td>

<p>Number of Monte Carlo simulations to perform, if a Monte Carlo
p-value is required.
</p>
</td></tr>
<tr><td><code id="hopskel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hopkins and Skellam (1954) proposed a test of Complete Spatial
Randomness based on comparing nearest-neighbour distances with
point-event distances.
</p>
<p>If the point pattern <code>X</code> contains <code>n</code>
points, we first compute the nearest-neighbour distances
<code class="reqn">P_1, \ldots, P_n</code> 
so that <code class="reqn">P_i</code> is the distance from the <code class="reqn">i</code>th data
point to the nearest other data point. Then we 
generate another completely random pattern <code>U</code> with
the same number <code>n</code> of points, and compute for each point of <code>U</code>
the distance to the nearest point of <code>X</code>, giving
distances <code class="reqn">I_1, \ldots, I_n</code>.
The test statistic is 
</p>
<p style="text-align: center;"><code class="reqn">
    A = \frac{\sum_i P_i^2}{\sum_i I_i^2}
  </code>
</p>

<p>The null distribution of <code class="reqn">A</code> is roughly
an <code class="reqn">F</code> distribution with shape parameters <code class="reqn">(2n,2n)</code>.
(This is equivalent to using the test statistic <code class="reqn">H=A/(1+A)</code>
and referring <code class="reqn">H</code> to the Beta distribution with parameters
<code class="reqn">(n,n)</code>).
</p>
<p>The function <code>hopskel</code> calculates the Hopkins-Skellam test statistic
<code class="reqn">A</code>, and returns its numeric value. This can be used as a simple
summary of spatial pattern: the value <code class="reqn">H=1</code> is consistent
with Complete Spatial Randomness, while values <code class="reqn">H &lt; 1</code> are
consistent with spatial clustering, and values <code class="reqn">H &gt; 1</code> are consistent
with spatial regularity.
</p>
<p>The function <code>hopskel.test</code> performs the test.
If <code>method="asymptotic"</code> (the default), the test statistic <code class="reqn">H</code>
is referred to the <code class="reqn">F</code> distribution. If <code>method="MonteCarlo"</code>,
a Monte Carlo test is performed using <code>nsim</code> simulated point
patterns.
</p>


<h3>Value</h3>

<p>The value of <code>hopskel</code> is a single number.
</p>
<p>The value of <code>hopskel.test</code> is an object of class <code>"htest"</code>
representing the outcome of the test. It can be printed. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Hopkins, B. and Skellam, J.G. (1954) 
A new method of determining the type of distribution
of plant individuals. <em>Annals of Botany</em> <b>18</b>, 
213&ndash;227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clarkevans">clarkevans</a></code>,
<code><a href="#topic+clarkevans.test">clarkevans.test</a></code>,
<code>nndist</code>,
<code>nncross</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  hopskel(redwood)
  hopskel.test(redwood, alternative="clustered")
</code></pre>

<hr>
<h2 id='hotbox'>
Heat Kernel for a Two-Dimensional Rectangle
</h2><span id='topic+hotbox'></span>

<h3>Description</h3>

<p>Calculate values of the heat kernel in a rectangle
with insulated edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotbox(Xsource, Xquery, sigma,
       ..., W=NULL, squared=FALSE, nmax=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotbox_+3A_xsource">Xsource</code></td>
<td>

<p>Point pattern of sources of heat.
Object of class <code>"ppp"</code>
or convertible to a point pattern using <code>as.ppp(Xsource, W)</code>.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_xquery">Xquery</code></td>
<td>

<p>Locations where the heat kernel value is required.
An object of class <code>"ppp"</code> specifying query location points,
or an object of class <code>"im"</code> or <code>"owin"</code> specifying a
grid of query points.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth for kernel. A single number.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_...">...</code></td>
<td>

<p>Extra arguments (passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>)
controlling the
pixel resolution of the result, when <code>Xquery</code> is a window
or an image.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) used to define the spatial domain
when <code>Xsource</code> is not of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_squared">squared</code></td>
<td>

<p>Logical value indicating whether to take the square
of each heat kernel value, before summing over the source points.
</p>
</td></tr>
<tr><td><code id="hotbox_+3A_nmax">nmax</code></td>
<td>

<p>Number of terms to be used from the infinite-sum expression
for the heat kernel. A single integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the sum of heat kernels
associated with each of the source points, evaluating them
at each query location.
</p>
<p>The window for evaluation of the heat kernel must be a rectangle.
</p>
<p>The heat kernel in any region can be expressed as an infinite sum of terms
associated with the eigenfunctions of the Laplacian. The heat kernel
in a rectangle is the product of heat kernels for
one-dimensional intervals on the horizontal and vertical axes. This
function uses <code><a href="spatstat.geom.html#topic+hotrod">hotrod</a></code> to compute the
one-dimensional heat kernels, truncating the infinite sum to the
first <code>nmax</code> terms, and then calculates the two-dimensional heat
kernel from each source point to each query location. If
<code>squared=TRUE</code> these values are squared. Finally the values are
summed over all source points to obtain a single value for each
query location.
</p>


<h3>Value</h3>

<p>If <code>Xquery</code> is a point pattern,
the result is a numeric vector with one entry for each query point.
</p>
<p>If <code>Xquery</code> is an image or window, the result is
a pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Baddeley, A., Davies, T., Rakshit, S., Nair, G. and McSwiggan, G. (2021)
Diffusion smoothing for spatial point patterns.
<em>Statistical Science</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifpoint(10)

  Y &lt;- runifpoint(5)
  hotbox(X, Y, 0.1)

  plot(hotbox(X, Window(X), 0.1))
  points(X, pch=16)
</code></pre>

<hr>
<h2 id='idw'>Inverse-distance weighted smoothing of observations at irregular points</h2><span id='topic+idw'></span>

<h3>Description</h3>

<p>Performs spatial smoothing of numeric values observed
at a set of irregular locations using inverse-distance weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idw(X, power=2, at=c("pixels", "points"), ..., se=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idw_+3A_x">X</code></td>
<td>
<p>A marked point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="idw_+3A_power">power</code></td>
<td>
<p>Numeric. Power of distance used in the weighting.</p>
</td></tr>
<tr><td><code id="idw_+3A_at">at</code></td>
<td>

<p>Character string specifying whether to compute the intensity values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
String is partially matched.
</p>
</td></tr>
<tr><td><code id="idw_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to control the pixel resolution of the result.</p>
</td></tr>
<tr><td><code id="idw_+3A_se">se</code></td>
<td>

<p>Logical value specifying whether to calculate a standard error.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs spatial smoothing of numeric values
observed at a set of irregular locations.
</p>
<p>Smoothing is performed by inverse distance weighting. If the
observed values are <code class="reqn">v_1,\ldots,v_n</code>
at locations <code class="reqn">x_1,\ldots,x_n</code> respectively,
then the smoothed value at a location <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
    g(u) = \frac{\sum_i w_i v_i}{\sum_i w_i}
  </code>
</p>

<p>where the weights are the inverse <code class="reqn">p</code>-th powers of distance,
</p>
<p style="text-align: center;"><code class="reqn">
    w_i = \frac 1 {d(u,x_i)^p}
  </code>
</p>

<p>where <code class="reqn">d(u,x_i) = ||u - x_i||</code>
is the Euclidean distance from <code class="reqn">u</code> to <code class="reqn">x_i</code>.
</p>
<p>The argument <code>X</code> must be a marked point pattern (object
of class <code>"ppp"</code>, see <code>ppp.object</code>).
The points of the pattern are taken to be the
observation locations <code class="reqn">x_i</code>, and the marks of the pattern
are taken to be the numeric values <code class="reqn">v_i</code> observed at these
locations.
</p>
<p>The marks are allowed to be a data frame.
Then the smoothing procedure is applied to each
column of marks. 
</p>
<p>If <code>at="pixels"</code> (the default), the smoothed mark value
is calculated at a grid of pixels, and the result is a pixel image.
The arguments <code>...</code> control the pixel resolution.
See <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>
<p>If <code>at="points"</code>, the smoothed mark values are calculated
at the data points only, using a leave-one-out rule (the mark value
at a data point is excluded when calculating the smoothed value
for that point). 
</p>
<p>An estimate of standard error is also calculated, if <code>se=TRUE</code>.
The calculation assumes that the data point locations are fixed,
that is, the standard error only takes into account the variability
in the mark values, and not the variability due to randomness of the
data point locations.
</p>
<p>An alternative to  inverse-distance weighting is kernel smoothing,
which is performed by <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
Pixel values are values of the interpolated function.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p>If <code>se=TRUE</code>, then the result is a list
with two entries named <code>estimate</code> and <code>SE</code>, which
each have the format described above.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
Variance calculation by Andrew P Wheeler with modifications by
Adrian Baddeley.
</p>


<h3>References</h3>

<p>Shepard, D. (1968) A two-dimensional interpolation function for
irregularly-spaced data.
<em>Proceedings of the 1968 ACM National Conference</em>,
1968, pages 517&ndash;524. DOI: 10.1145/800186.810616
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code>ppp.object</code>,
<code>im.object</code>.
</p>
<p>See <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> for kernel smoothing
and <code>nnmark</code> for nearest-neighbour interpolation.
</p>
<p>To perform other kinds of interpolation, see also the <code>akima</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # data frame of marks: trees marked by diameter and height
   plot(idw(finpines))
   idw(finpines, at="points")[1:5,]
   plot(idw(finpines, se=TRUE)$SE)
   idw(finpines, at="points", se=TRUE)$SE[1:5, ]
</code></pre>

<hr>
<h2 id='Iest'>Estimate the I-function</h2><span id='topic+Iest'></span>

<h3>Description</h3>

<p>Estimates the summary function <code class="reqn">I(r)</code> for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Iest(X, ..., eps=NULL, r=NULL, breaks=NULL, correction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Iest_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">I(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Iest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Iest_+3A_eps">eps</code></td>
<td>

<p>the resolution of the discrete approximation to Euclidean distance
(see below). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Iest_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector of values for the argument <code class="reqn">r</code>
at which <code class="reqn">I(r)</code> 
should be evaluated. There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code>r</code>.
</p>
</td></tr>
<tr><td><code id="Iest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Iest_+3A_correction">correction</code></td>
<td>

<p>Optional. Vector of character strings specifying the edge correction(s)
to be used by <code><a href="#topic+Jest">Jest</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">I</code> function 
summarises the dependence between types in a multitype point process
(Van Lieshout and Baddeley, 1999)
It is based on the concept of the <code class="reqn">J</code> function for an
unmarked point process (Van Lieshout and Baddeley, 1996).
See <code><a href="#topic+Jest">Jest</a></code> for information about the <code class="reqn">J</code> function.
</p>
<p>The <code class="reqn">I</code> function is defined as 
</p>
<p style="text-align: center;"><code class="reqn"> %
    I(r) = \sum_{i=1}^m p_i J_{ii}(r) %
    - J_{\bullet\bullet}(r)</code>
</p>

<p>where <code class="reqn">J_{\bullet\bullet}</code> is the <code class="reqn">J</code> function for
the entire point process ignoring the marks, while 
<code class="reqn">J_{ii}</code> is the <code class="reqn">J</code> function for the
process consisting of points of type <code class="reqn">i</code> only,
and <code class="reqn">p_i</code> is the proportion of points which are of type <code class="reqn">i</code>.
</p>
<p>The <code class="reqn">I</code> function is designed to measure dependence between
points of different types, even if the points are
not Poisson. Let <code class="reqn">X</code> be a stationary multitype point process,
and write <code class="reqn">X_i</code> for the process of points of type <code class="reqn">i</code>.
If the processes <code class="reqn">X_i</code> are independent of each other,
then the <code class="reqn">I</code>-function is identically equal to <code class="reqn">0</code>. 
Deviations <code class="reqn">I(r) &lt; 1</code> or <code class="reqn">I(r) &gt; 1</code>
typically indicate negative and positive association, respectively,
between types.
See Van Lieshout and Baddeley (1999)
for further information.
</p>
<p>An estimate of <code class="reqn">I</code> derived from a multitype spatial point pattern dataset
can be used in exploratory data analysis and formal inference
about the pattern. The estimate of <code class="reqn">I(r)</code> is compared against the 
constant function <code class="reqn">0</code>.
Deviations <code class="reqn">I(r) &lt; 1</code> or <code class="reqn">I(r) &gt; 1</code>
may suggest negative and positive association, respectively.
</p>
<p>This algorithm estimates the <code class="reqn">I</code>-function
from the multitype point pattern <code>X</code>.
It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial marked point process in the plane, observed through
a bounded window. 
</p>
<p>The argument <code>X</code> is interpreted as a point pattern object 
(of class <code>"ppp"</code>, see <code>ppp.object</code>) and can
be supplied in any of the formats recognised by
<code>as.ppp()</code>. It must be a multitype point pattern
(it must have a <code>marks</code> vector which is a <code>factor</code>).
</p>
<p>The function <code><a href="#topic+Jest">Jest</a></code> is called to 
compute estimates of the <code class="reqn">J</code> functions in the formula above.
In fact three different estimates are computed
using different edge corrections. See <code><a href="#topic+Jest">Jest</a></code> for
information.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">I</code> has been  estimated</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">I(r)</code> computed from
the border-corrected estimates of <code class="reqn">J</code> functions</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">I(r)</code> computed from
the Kaplan-Meier estimates of <code class="reqn">J</code> functions</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">I(r)</code> computed from
the Hanisch-style estimates of <code class="reqn">J</code> functions</p>
</td></tr>
<tr><td><code>un</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">I(r)</code>
computed from the uncorrected estimates of <code class="reqn">J</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">I(r)</code>
for a stationary Poisson process: identically equal to <code class="reqn">0</code>
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sizeable amounts of memory may be needed during the calculation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jest">Jest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Ic &lt;- Iest(amacrine)
   plot(Ic, main="Amacrine Cells data")
   # values are below I= 0, suggesting negative association
   # between 'on' and 'off' cells.
</code></pre>

<hr>
<h2 id='increment.fv'>
Increments of a Function
</h2><span id='topic+increment.fv'></span>

<h3>Description</h3>

<p>Compute the change in the value of a function <code>f</code>
when the function argument increases by <code>delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increment.fv(f, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment.fv_+3A_f">f</code></td>
<td>

<p>Object of class <code>"fv"</code> representing a function.
</p>
</td></tr>
<tr><td><code id="increment.fv_+3A_delta">delta</code></td>
<td>

<p>Numeric. The increase in the value of the function argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the new function
</p>
<p style="text-align: center;"><code class="reqn">g(x) = f(x+h) - f(x-h)</code>
</p>

<p>where <code>h = delta/2</code>. The value of <code class="reqn">g(x)</code> is
the change in the value of <code class="reqn">f</code> over an interval of length
<code>delta</code> centred at <code class="reqn">x</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"fv"</code> compatible with <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>, 
<code><a href="#topic+deriv.fv">deriv.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(increment.fv(Kest(cells), 0.05))
</code></pre>

<hr>
<h2 id='integral.fv'>
Compute Integral of Function Object
</h2><span id='topic+integral.fv'></span>

<h3>Description</h3>

<p>Compute the integral of a function 
over a specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
integral(f, domain = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.fv_+3A_f">f</code></td>
<td>

<p>A function value table
(object of class <code>"fv"</code>).
</p>
</td></tr>
<tr><td><code id="integral.fv_+3A_domain">domain</code></td>
<td>

<p>Optional. Range of values of the argument <code class="reqn">x</code> over which the
density <code class="reqn">f(x)</code> should be integrated. A numeric vector of length
2 giving the minimum and maximum values of <code class="reqn">x</code>. Infinite limits
are permitted.
</p>
</td></tr>
<tr><td><code id="integral.fv_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+integral">integral</a></code>.
It computes the numerical integral
</p>
<p style="text-align: center;"><code class="reqn">
    I = \int f(x) dx
  </code>
</p>

<p>of the function object <code>f</code>.
If <code>domain</code> is specified, the integral is restricted to the
interval of <code class="reqn">x</code> values given by the <code>domain</code>.
</p>
<p>The result is a numeric value or numeric vector containing one entry
for each column of function values in <code>f</code>.
</p>
<p>Integrals are calculated numerically using the trapezoidal rule
restricted to the domain given.
</p>


<h3>Value</h3>

<p>A single numerical value, or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>, <code><a href="spatstat.geom.html#topic+integral">integral</a></code>
</p>
<p><code><a href="#topic+stieltjes">stieltjes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- pcf(redwood, divisor="d")
  integral(g, domain=c(0, 0.1))
</code></pre>

<hr>
<h2 id='Jcross'>
Multitype J Function (i-to-j)
</h2><span id='topic+Jcross'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the multitype <code class="reqn">J</code> function 
summarising the interpoint dependence between
points of type <code class="reqn">i</code> and of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jcross(X, i, j, eps=NULL, r=NULL, breaks=NULL, ..., correction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jcross_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of the multitype <code class="reqn">J</code> function
<code class="reqn">J_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_eps">eps</code></td>
<td>
<p>A positive number.
The resolution of the discrete approximation to Euclidean
distance (see below). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">J_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Jcross_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Jcross_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"Hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Jcross</code> and its companions
<code><a href="#topic+Jdot">Jdot</a></code> and <code><a href="#topic+Jmulti">Jmulti</a></code>
are generalisations of the function <code><a href="#topic+Jest">Jest</a></code>
to multitype point patterns. 
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
The argument <code>i</code> will be interpreted as a
level of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as the number 3,
<b>not</b> the 3rd smallest level).
</p>
<p>The &ldquo;type <code class="reqn">i</code> to type <code class="reqn">j</code>&rdquo; multitype <code class="reqn">J</code> function 
of a stationary multitype point process <code class="reqn">X</code>
was introduced by Van lieshout and Baddeley (1999). It is defined by
</p>
<p style="text-align: center;"><code class="reqn">J_{ij}(r) = \frac{1 - G_{ij}(r)}{1 -
      F_{j}(r)}</code>
</p>

<p>where <code class="reqn">G_{ij}(r)</code> is the distribution function of
the distance from a type <code class="reqn">i</code> point to the nearest point of type <code class="reqn">j</code>,
and <code class="reqn">F_{j}(r)</code> is the distribution
function of the distance from a fixed point in space to the nearest
point of type <code class="reqn">j</code> in the pattern.
</p>
<p>An estimate of <code class="reqn">J_{ij}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern. 
If the subprocess of type <code class="reqn">i</code> points is independent
of the subprocess of points of type <code class="reqn">j</code>,
then <code class="reqn">J_{ij}(r) \equiv 1</code>.
Hence deviations of the empirical estimate of
<code class="reqn">J_{ij}</code> from the value 1
may suggest dependence between types.
</p>
<p>This algorithm estimates <code class="reqn">J_{ij}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Jest">Jest</a></code>,
using the Kaplan-Meier and border corrections.
The main work is done by <code><a href="#topic+Gmulti">Gmulti</a></code> and <code><a href="#topic+Fest">Fest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">J_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>J</code></td>
<td>
<p>the recommended
estimator of <code class="reqn">J_{ij}(r)</code>,
currently the Kaplan-Meier estimator.
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">J_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the Kaplan-Meier 
estimator of <code class="reqn">J_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">J_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style
estimator of <code class="reqn">J_{ij}(r)</code>
</p>
</td></tr>
<tr><td><code>un</code></td>
<td>
<p>the &ldquo;uncorrected&rdquo; 
estimator of <code class="reqn">J_{ij}(r)</code>
formed by taking the ratio of uncorrected empirical estimators
of <code class="reqn">1 - G_{ij}(r)</code>
and <code class="reqn">1 - F_{j}(r)</code>, see
<code><a href="#topic+Gdot">Gdot</a></code> and <code><a href="#topic+Fest">Fest</a></code>.
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">J_{ij}(r)</code>
for a marked Poisson process, namely 1.
</p>
</td></tr>
</table>
<p>The result also has two attributes <code>"G"</code> and <code>"F"</code>
which are respectively the outputs of <code><a href="#topic+Gcross">Gcross</a></code>
and <code><a href="#topic+Fest">Fest</a></code> for the point pattern.
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are always interpreted as
levels of the factor <code>X$marks</code>. They are converted to character
strings if they are not already character strings.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jdot">Jdot</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Jmulti">Jmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Lansing woods data: 6 types of trees
    woods &lt;- lansing
    
    Jhm &lt;- Jcross(woods, "hickory", "maple")
    # diagnostic plot for independence between hickories and maples
    plot(Jhm)

    # synthetic example with two types "a" and "b"
    pp &lt;- runifpoint(30) %mark% factor(sample(c("a","b"), 30, replace=TRUE))
    J &lt;- Jcross(pp)
</code></pre>

<hr>
<h2 id='Jcross.inhom'>
Inhomogeneous Multitype J function (i-to-j)
</h2><span id='topic+Jcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous multitype <code class="reqn">J</code> function 
summarising the interpoint dependence between
points of type <code class="reqn">i</code> and of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Jcross.inhom(X, i, j,
               lambda = NULL, lambdaI = NULL, lambdaJ = NULL,
               lambdamin = NULL,
               ...,
               r = NULL, ReferenceMeasureMarkSetI = NULL, ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jcross.inhom_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of the multitype <code class="reqn">J</code> function
<code class="reqn">J_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the point process.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the the estimated intensity of the sub-process of
points of type <code>j</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>j</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location. 
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution for the computation.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">J</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="Jcross.inhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the counterpart of <code><a href="#topic+Jcross">Jcross</a></code>
for inhomogeneous patterns. It is computed as a special case
of <code><a href="#topic+Jmulti.inhom">Jmulti.inhom</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> containing the estimate of the
inhomogeneous multitype <code class="reqn">J</code> function.
</p>


<h3>Author(s)</h3>

<p>Jonatan Gonzalez and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jdot.inhom">Jdot.inhom</a></code>, <code><a href="#topic+Jmulti.inhom">Jmulti.inhom</a></code>,
<code><a href="#topic+Jcross">Jcross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
    dd &lt;- NULL
  } else {
    ## for package testing
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
    dd &lt;- 32
  }
  JC &lt;- Jcross.inhom(X, "on", "off", lambda=lam, lambdamin=lmin, dimyx=dd)
</code></pre>

<hr>
<h2 id='Jdot'>
Multitype J Function (i-to-any)
</h2><span id='topic+Jdot'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the multitype <code class="reqn">J</code> function 
summarising the interpoint dependence between
the type <code class="reqn">i</code> points and the points of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jdot(X, i, eps=NULL, r=NULL, breaks=NULL, ..., correction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jdot_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of the multitype <code class="reqn">J</code> function
<code class="reqn">J_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Jdot_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jdot_+3A_eps">eps</code></td>
<td>
<p>A positive number.
The resolution of the discrete approximation to Euclidean
distance (see below). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jdot_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">J_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Jdot_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Jdot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Jdot_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"Hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Jdot</code> and its companions
<code><a href="#topic+Jcross">Jcross</a></code> and <code><a href="#topic+Jmulti">Jmulti</a></code>
are generalisations of the function <code><a href="#topic+Jest">Jest</a></code>
to multitype point patterns. 
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
The argument <code>i</code> will be interpreted as a
level of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as the number 3,
<b>not</b> the 3rd smallest level.)
</p>
<p>The &ldquo;type <code class="reqn">i</code> to any type&rdquo; multitype <code class="reqn">J</code> function 
of a stationary multitype point process <code class="reqn">X</code>
was introduced by Van lieshout and Baddeley (1999). It is defined by
</p>
<p style="text-align: center;"><code class="reqn">J_{i\bullet}(r) = \frac{1 - G_{i\bullet}(r)}{1 -
      F_{\bullet}(r)}</code>
</p>

<p>where <code class="reqn">G_{i\bullet}(r)</code> is the distribution function of
the distance from a type <code class="reqn">i</code> point to the nearest other point
of the pattern, and <code class="reqn">F_{\bullet}(r)</code> is the distribution
function of the distance from a fixed point in space to the nearest
point of the pattern.
</p>
<p>An estimate of <code class="reqn">J_{i\bullet}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern. If the pattern is 
a marked Poisson point process, then
<code class="reqn">J_{i\bullet}(r) \equiv 1</code>.
If the subprocess of type <code class="reqn">i</code> points is independent
of the subprocess of points of all types not equal to <code class="reqn">i</code>,
then <code class="reqn">J_{i\bullet}(r)</code> equals
<code class="reqn">J_{ii}(r)</code>, the ordinary <code class="reqn">J</code> function
(see <code><a href="#topic+Jest">Jest</a></code> and Van Lieshout and Baddeley (1996))
of the points of type <code class="reqn">i</code>. 
Hence deviations from zero of the empirical estimate of
<code class="reqn">J_{i\bullet} - J_{ii}</code> 
may suggest dependence between types.
</p>
<p>This algorithm estimates <code class="reqn">J_{i\bullet}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Jest">Jest</a></code>,
using the Kaplan-Meier and border corrections.
The main work is done by <code><a href="#topic+Gmulti">Gmulti</a></code> and <code><a href="#topic+Fest">Fest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">J_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>J</code></td>
<td>
<p>the recommended
estimator of <code class="reqn">J_{i\bullet}(r)</code>,
currently the Kaplan-Meier estimator.
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">J_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the Kaplan-Meier 
estimator of <code class="reqn">J_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">J_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style
estimator of <code class="reqn">J_{i\bullet}(r)</code>
</p>
</td></tr>
<tr><td><code>un</code></td>
<td>
<p>the &ldquo;uncorrected&rdquo; 
estimator of <code class="reqn">J_{i\bullet}(r)</code>
formed by taking the ratio of uncorrected empirical estimators
of <code class="reqn">1 - G_{i\bullet}(r)</code>
and <code class="reqn">1 - F_{\bullet}(r)</code>, see
<code><a href="#topic+Gdot">Gdot</a></code> and <code><a href="#topic+Fest">Fest</a></code>.
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">J_{i\bullet}(r)</code>
for a marked Poisson process, namely 1.
</p>
</td></tr>
</table>
<p>The result also has two attributes <code>"G"</code> and <code>"F"</code>
which are respectively the outputs of <code><a href="#topic+Gdot">Gdot</a></code>
and <code><a href="#topic+Fest">Fest</a></code> for the point pattern.
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jcross">Jcross</a></code>,
<code><a href="#topic+Jest">Jest</a></code>,
<code><a href="#topic+Jmulti">Jmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Lansing woods data: 6 types of trees
   woods &lt;- lansing

    
    Jh. &lt;- Jdot(woods, "hickory")
    plot(Jh.)
    # diagnostic plot for independence between hickories and other trees
    Jhh &lt;- Jest(split(woods)$hickory)
    plot(Jhh, add=TRUE, legendpos="bottom")

    # synthetic example with two marks "a" and "b"
    
    pp &lt;- runifpoint(30) %mark% factor(sample(c("a","b"), 30, replace=TRUE))
    J &lt;- Jdot(pp, "a")
    
</code></pre>

<hr>
<h2 id='Jdot.inhom'>
Inhomogeneous Multitype J function (i-to-any)
</h2><span id='topic+Jdot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous multitype <code class="reqn">J</code> function 
summarising the interpoint dependence between
points of type <code class="reqn">i</code> and points of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Jdot.inhom(X, i, 
             lambdaI = NULL, lambdadot = NULL,
             lambdamin = NULL,
             ...,
             r = NULL, ReferenceMeasureMarkSetI = NULL, ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jdot.inhom_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of the inhomogeneous multitype <code class="reqn">J</code> function
<code class="reqn">J_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the point process.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution for the computation.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="Jdot.inhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the counterpart of <code><a href="#topic+Jdot">Jdot</a></code>
for inhomogeneous patterns. It is computed as a special case
of <code><a href="#topic+Jmulti.inhom">Jmulti.inhom</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> containing the estimate of the
inhomogeneous multitype <code class="reqn">J</code> function.
</p>


<h3>Author(s)</h3>

<p>Jonatan Gonzalez and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jdot.inhom">Jdot.inhom</a></code>, <code><a href="#topic+Jmulti.inhom">Jmulti.inhom</a></code>,
<code><a href="#topic+Jdot">Jdot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
    dd &lt;- NULL
  } else {
    ## for package testing 
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
    dd &lt;- 32
  }
  lamI &lt;- lam[marks(X) == "on"]
  JD &lt;- Jdot.inhom(X, "on", lambdaI=lamI, lambdadot=lam, lambdamin=lmin,
                   dimyx=dd)
</code></pre>

<hr>
<h2 id='Jest'>Estimate the J-function</h2><span id='topic+Jest'></span>

<h3>Description</h3>

<p>Estimates the summary function <code class="reqn">J(r)</code> for a point pattern in a 
window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Jest(X, ..., eps=NULL, r=NULL, breaks=NULL, correction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jest_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">J(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Jest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Jest_+3A_eps">eps</code></td>
<td>

<p>the resolution of the discrete approximation to Euclidean distance
(see below). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jest_+3A_r">r</code></td>
<td>
<p>vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">J(r)</code> 
should be evaluated. There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code>r</code>.
</p>
</td></tr>
<tr><td><code id="Jest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Jest_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the choice of edge
correction(s) in <code><a href="#topic+Fest">Fest</a></code> and <code><a href="#topic+Gest">Gest</a></code>.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">J</code> function (Van Lieshout and Baddeley, 1996)
of a stationary point process is defined as 
</p>
<p style="text-align: center;"><code class="reqn">J(r) = \frac{1-G(r)}{1-F(r)} </code>
</p>

<p>where <code class="reqn">G(r)</code> is the nearest neighbour distance distribution
function of the point process (see <code><a href="#topic+Gest">Gest</a></code>) 
and <code class="reqn">F(r)</code> is its empty space function (see <code><a href="#topic+Fest">Fest</a></code>).
</p>
<p>For a completely random (uniform Poisson) point process,
the <code class="reqn">J</code>-function is identically equal to <code class="reqn">1</code>. 
Deviations <code class="reqn">J(r) &lt; 1</code> or <code class="reqn">J(r) &gt; 1</code>
typically indicate spatial clustering or spatial regularity, respectively.
The <code class="reqn">J</code>-function is one of the few characteristics that can be
computed explicitly for a wide range of point processes. 
See Van Lieshout and Baddeley (1996), Baddeley et al (2000),
Thonnes and Van Lieshout (1999)  for further information.
</p>
<p>An estimate of <code class="reqn">J</code> derived from a spatial point pattern dataset
can be used in exploratory data analysis and formal inference
about the pattern. The estimate of <code class="reqn">J(r)</code> is compared against the 
constant function <code class="reqn">1</code>.
Deviations <code class="reqn">J(r) &lt; 1</code> or <code class="reqn">J(r) &gt; 1</code>
may suggest spatial clustering or spatial regularity, respectively.
</p>
<p>This algorithm estimates the <code class="reqn">J</code>-function
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window. 
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape. 
</p>
<p>The argument <code>X</code> is interpreted as a point pattern object 
(of class <code>"ppp"</code>, see <code>ppp.object</code>) and can
be supplied in any of the formats recognised by
<code>as.ppp()</code>. 
</p>
<p>The functions <code><a href="#topic+Fest">Fest</a></code> and <code><a href="#topic+Gest">Gest</a></code> are called to 
compute estimates of <code class="reqn">F(r)</code> and <code class="reqn">G(r)</code> respectively.
These estimates are then combined by simply taking the ratio
<code class="reqn">J(r) = (1-G(r))/(1-F(r))</code>.
</p>
<p>In fact several different estimates are computed
using different edge corrections (Baddeley, 1998).
</p>
<p>The Kaplan-Meier estimate (returned as <code>km</code>) is the ratio 
<code>J = (1-G)/(1-F)</code> of the Kaplan-Meier estimates of
<code class="reqn">1-F</code> and <code class="reqn">1-G</code> computed by
<code><a href="#topic+Fest">Fest</a></code> and <code><a href="#topic+Gest">Gest</a></code> respectively.
This is computed if <code>correction=NULL</code> or if <code>correction</code>
includes <code>"km"</code>.
</p>
<p>The Hanisch-style estimate (returned as <code>han</code>) is the ratio 
<code>J = (1-G)/(1-F)</code> where <code>F</code> is the Chiu-Stoyan estimate of
<code class="reqn">F</code> and <code>G</code> is the Hanisch estimate of <code class="reqn">G</code>.
This is computed if <code>correction=NULL</code> or if <code>correction</code>
includes <code>"cs"</code> or <code>"han"</code>.
</p>
<p>The reduced-sample or border corrected estimate
(returned as <code>rs</code>) is
the same ratio <code>J = (1-G)/(1-F)</code>
of the border corrected estimates. 
This is computed if <code>correction=NULL</code> or if <code>correction</code>
includes <code>"rs"</code> or <code>"border"</code>.
</p>
<p>These edge-corrected estimators are slightly biased for <code class="reqn">J</code>, 
since they are ratios
of approximately unbiased estimators.
The logarithm of the
Kaplan-Meier estimate is exactly unbiased for <code class="reqn">\log J</code>.
</p>
<p>The uncorrected estimate (returned as <code>un</code>
and computed only if <code>correction</code> includes <code>"none"</code>)
is the ratio <code>J = (1-G)/(1-F)</code>
of the uncorrected (&ldquo;raw&rdquo;) estimates of the survival functions
of <code class="reqn">F</code> and <code class="reqn">G</code>,
which are the empirical distribution functions of the 
empty space distances <code>Fest(X,...)$raw</code>
and of the nearest neighbour distances 
<code>Gest(X,...)$raw</code>. The uncorrected estimates
of <code class="reqn">F</code> and <code class="reqn">G</code> are severely biased.
However the uncorrected estimate of <code class="reqn">J</code>
is approximately unbiased (if the process is close to Poisson);
it is insensitive to edge effects, and should be used when
edge effects are severe (see Baddeley et al, 2000).
</p>
<p>The algorithm for <code><a href="#topic+Fest">Fest</a></code>
uses two discrete approximations which are controlled
by the parameter <code>eps</code> and by the spacing of values of <code>r</code>
respectively. See <code><a href="#topic+Fest">Fest</a></code> for details.
First-time users are strongly advised not to specify these arguments.
</p>
<p>Note that the value returned by <code>Jest</code> includes 
the output of <code><a href="#topic+Fest">Fest</a></code> and <code><a href="#topic+Gest">Gest</a></code>
as attributes (see the last example below).
If the user is intending to compute the <code>F,G</code> and <code>J</code>
functions for the point pattern, it is only necessary to
call <code>Jest</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">J</code> has been  estimated</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">J(r)</code> computed from
the border-corrected estimates of <code class="reqn">F</code> and <code class="reqn">G</code> </p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">J(r)</code> computed from
the Kaplan-Meier estimates of <code class="reqn">F</code> and <code class="reqn">G</code> </p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">J(r)</code> computed from
the Hanisch estimate of <code class="reqn">G</code> and the Chiu-Stoyan estimate of
<code class="reqn">F</code>
</p>
</td></tr>
<tr><td><code>un</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">J(r)</code>
computed from the uncorrected estimates of <code class="reqn">F</code> and
<code class="reqn">G</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">J(r)</code>
for a stationary Poisson process: identically equal to <code class="reqn">1</code>
</p>
</td></tr>
</table>
<p>The data frame also has <b>attributes</b>
</p>
<table>
<tr><td><code>F</code></td>
<td>

<p>the output of <code><a href="#topic+Fest">Fest</a></code> for this point pattern,
containing three estimates of the empty space function <code class="reqn">F(r)</code>
and an estimate of its hazard function
</p>
</td></tr>
<tr><td><code>G</code></td>
<td>

<p>the output of <code><a href="#topic+Gest">Gest</a></code> for this point pattern,
containing three estimates of the nearest neighbour distance distribution
function <code class="reqn">G(r)</code> and an estimate of its hazard function
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sizeable amounts of memory may be needed during the calculation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. Spatial sampling and censoring.
In O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. van Lieshout (eds) 
<em>Stochastic Geometry: Likelihood and Computation</em>.
Chapman and Hall, 1998.
Chapter 2, pages 37&ndash;78.
</p>
<p>Baddeley, A.J. and Gill, R.D. 
The empty space hazard of a spatial pattern.
Research Report 1994/3, Department of Mathematics,
University of Western Australia, May 1994.
</p>
<p>Baddeley, A.J. and Gill, R.D.
Kaplan-Meier estimators of interpoint distance
distributions for spatial point processes.
<em>Annals of Statistics</em> <b>25</b> (1997) 263&ndash;292.
</p>
<p>Baddeley, A., Kerscher, M., Schladitz, K. and Scott, B.T.
Estimating the <em>J</em> function without edge correction.
<em>Statistica Neerlandica</em> <b>54</b> (2000) 315&ndash;328.
</p>
<p>Borgefors, G.
Distance transformations in digital images.
<em>Computer Vision, Graphics and Image Processing</em>
<b>34</b> (1986) 344&ndash;371.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>
<p>Thonnes, E. and Van Lieshout, M.N.M,
A comparative study on the power of Van Lieshout and Baddeley's J-function.
<em>Biometrical Journal</em> <b>41</b> (1999) 721&ndash;734.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J.
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b> (1996) 344&ndash;361.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jinhom">Jinhom</a></code>,
<code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>,
<code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   J &lt;- Jest(cells, 0.01)
   plot(J, main="cells data")
   # values are far above J = 1, indicating regular pattern

   data(redwood)
   J &lt;- Jest(redwood, 0.01, legendpos="center")
   plot(J, main="redwood data")
   # values are below J = 1, indicating clustered pattern
</code></pre>

<hr>
<h2 id='Jinhom'>
Inhomogeneous J-function
</h2><span id='topic+Jinhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous <code class="reqn">J</code> function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Jinhom(X, lambda = NULL, lmin = NULL, ...,
        sigma = NULL, varcov = NULL,
        r = NULL, breaks = NULL, ratio=FALSE, 
        update = TRUE, warn.bias=TRUE, savelambda=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jinhom_+3A_x">X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">J</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_lmin">lmin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_sigma">sigma</code>, <code id="Jinhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution, or passed to <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_update">update</code></td>
<td>

<p>Logical. If <code>lambda</code> is a fitted model
(class <code>"ppm"</code> or <code>"kppm"</code>)
and <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_warn.bias">warn.bias</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when the inhomogeneity correction factor takes extreme values,
which can often lead to biased results. This usually occurs
when insufficient smoothing is used to estimate the intensity.
</p>
</td></tr>
<tr><td><code id="Jinhom_+3A_savelambda">savelambda</code></td>
<td>

<p>Logical value specifying whether to save the values of
<code>lmin</code> and <code>lambda</code> as attributes of the result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes estimates of the 
inhomogeneous <code class="reqn">J</code>-function (Van Lieshout, 2010)
of a point pattern. It is the counterpart, for inhomogeneous
spatial point patterns, of the <code class="reqn">J</code> function
for homogeneous point patterns computed by <code><a href="#topic+Jest">Jest</a></code>.
</p>
<p>The argument <code>X</code> should be a point pattern
(object of class <code>"ppp"</code>).
</p>
<p>The inhomogeneous <code class="reqn">J</code> function is computed as
<code class="reqn">Jinhom(r) = (1 - Ginhom(r))/(1-Finhom(r))</code>
where <code class="reqn">Ginhom, Finhom</code> are the inhomogeneous <code class="reqn">G</code> and <code class="reqn">F</code>
functions computed using the border correction
(equations (7) and (6) respectively in Van Lieshout, 2010).
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>
of the point process. It may be either
</p>

<dl>
<dt>a numeric vector</dt><dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt><dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code> or <code>"kppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
</dd>
</dl>

<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code><a href="#topic+blur">blur</a></code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Marie-Colette van Lieshout.
C implementation and R adaptation by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344&ndash;361.
</p>
<p>van Lieshout, M.N.M. (2010)
A J-function for inhomogeneous point processes.
<em>Statistica Neerlandica</em> <b>65</b>, 183&ndash;201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ginhom">Ginhom</a></code>,
<code><a href="#topic+Finhom">Finhom</a></code>,
<code><a href="#topic+Jest">Jest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(online) {
    plot(Jinhom(swedishpines, sigma=10))
    plot(Jinhom(swedishpines, sigma=bw.diggle, adjust=2))
  } else {
    ## use a coarse grid for faster computation and package testing
    plot(Jinhom(swedishpines, sigma=10, dimyx=32))
  }

</code></pre>

<hr>
<h2 id='Jmulti'>
Marked J Function
</h2><span id='topic+Jmulti'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the multitype <code class="reqn">J</code> function
summarising dependence between the
points in subset <code class="reqn">I</code>
and those in subset <code class="reqn">J</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Jmulti(X, I, J, eps=NULL, r=NULL, breaks=NULL, ..., disjoint=NULL,
         correction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jmulti_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the multitype distance distribution function
<code class="reqn">J_{IJ}(r)</code> will be computed.
It must be a marked point pattern.
See under Details.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_i">I</code></td>
<td>
<p>Subset of points of <code>X</code> from which distances are
measured. See Details.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_j">J</code></td>
<td>
<p>Subset of points in <code>X</code> to which distances are measured.
See Details.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_eps">eps</code></td>
<td>
<p>A positive number.
The pixel resolution of the discrete approximation to Euclidean
distance (see <code><a href="#topic+Jest">Jest</a></code>). There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">J_{IJ}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_disjoint">disjoint</code></td>
<td>
<p>Optional flag indicating whether
the subsets <code>I</code> and <code>J</code> are disjoint.
If missing, this value will be computed by inspecting the
vectors <code>I</code> and <code>J</code>.
</p>
</td></tr>
<tr><td><code id="Jmulti_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying the edge correction(s)
to be used. Options are <code>"none"</code>, <code>"rs"</code>, <code>"km"</code>,
<code>"Hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Jmulti</code>
generalises <code><a href="#topic+Jest">Jest</a></code> (for unmarked point
patterns) and <code><a href="#topic+Jdot">Jdot</a></code> and <code><a href="#topic+Jcross">Jcross</a></code> (for
multitype point patterns) to arbitrary marked point patterns.
</p>
<p>Suppose <code class="reqn">X_I</code>, <code class="reqn">X_J</code> are subsets, possibly
overlapping, of a marked point process. Define
</p>
<p style="text-align: center;"><code class="reqn">J_{IJ}(r) = \frac{1 - G_{IJ}(r)}{1 - F_J(r)}</code>
</p>

<p>where <code class="reqn">F_J(r)</code> is the cumulative distribution function of
the distance from a fixed location to the nearest point
of <code class="reqn">X_J</code>, and <code class="reqn">G_{IJ}(r)</code>
is the distribution function of the distance
from a typical point of  <code class="reqn">X_I</code> to the nearest distinct point of
<code class="reqn">X_J</code>. 
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
</p>
<p>The arguments <code>I</code> and <code>J</code> specify two subsets of the
point pattern. They may be any type of subset indices, for example,
logical vectors of length equal to <code>npoints(X)</code>,
or integer vectors with entries in the range 1 to
<code>npoints(X)</code>, or negative integer vectors.
</p>
<p>Alternatively, <code>I</code> and <code>J</code> may be <b>functions</b>
that will be applied to the point pattern <code>X</code> to obtain
index vectors. If <code>I</code> is a function, then evaluating
<code>I(X)</code> should yield a valid subset index. This option
is useful when generating simulation envelopes using
<code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>It is assumed that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Jest">Jest</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">J_{IJ}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances. The reduced-sample and
Kaplan-Meier estimators are computed from histogram counts. 
In the case of the Kaplan-Meier estimator this introduces a discretisation
error which is controlled by the fineness of the breakpoints.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. Furthermore, the successive entries of <code>r</code>
must be finely spaced.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing six numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">J_{IJ}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>the &ldquo;reduced sample&rdquo; or &ldquo;border correction&rdquo;
estimator of <code class="reqn">J_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>the spatial Kaplan-Meier estimator of <code class="reqn">J_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>han</code></td>
<td>
<p>the Hanisch-style estimator of <code class="reqn">J_{IJ}(r)</code>
</p>
</td></tr>
<tr><td><code>un</code></td>
<td>
<p>the uncorrected estimate of <code class="reqn">J_{IJ}(r)</code>,
formed by taking the ratio of uncorrected empirical estimators
of <code class="reqn">1 - G_{IJ}(r)</code>
and <code class="reqn">1 - F_{J}(r)</code>, see
<code><a href="#topic+Gdot">Gdot</a></code> and <code><a href="#topic+Fest">Fest</a></code>.
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">J_{IJ}(r)</code>
for a marked Poisson process with the same estimated intensity,
namely 1.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jcross">Jcross</a></code>,
<code><a href="#topic+Jdot">Jdot</a></code>,
<code><a href="#topic+Jest">Jest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    trees &lt;- longleaf
     # Longleaf Pine data: marks represent diameter
    
    Jm &lt;- Jmulti(trees, marks(trees) &lt;= 15, marks(trees) &gt;= 25)
    plot(Jm)
</code></pre>

<hr>
<h2 id='Jmulti.inhom'>
Inhomogeneous Marked J-Function
</h2><span id='topic+Jmulti.inhom'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the inhomogeneous version of the multitype <code class="reqn">J</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jmulti.inhom(X, I, J,
             lambda = NULL, lambdaI = NULL, lambdaJ = NULL,
             lambdamin = NULL,
             ...,
             r = NULL,
             ReferenceMeasureMarkSetI = NULL,
             ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jmulti.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous multitype <code class="reqn">J</code> function
<code class="reqn">J_{IJ}(r)</code> will be computed.
It must be a marked point pattern.
See under Details.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_i">I</code></td>
<td>
<p>Subset index specifying the points of <code>X</code>
from which distances are measured, for the inhomogeneous <code class="reqn">G</code> function.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_j">J</code></td>
<td>
<p>Subset index specifying the points in <code>X</code> to which
distances are measured, for the inhomogeneous <code class="reqn">G</code> and <code class="reqn">F</code> functions.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process <code>X[I]</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X[I]</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location,
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process <code>X[J]</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X[J]</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_lambdamin">lambdamin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution for the computation.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_referencemeasuremarkseti">ReferenceMeasureMarkSetI</code></td>
<td>

<p>Optional. The total measure of the mark set. A positive number.
</p>
</td></tr>
<tr><td><code id="Jmulti.inhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical value indicating whether to save ratio information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the counterpart of <code><a href="#topic+Jmulti">Jmulti</a></code>
for inhomogeneous patterns. It is computed by evaluating the
inhomogeneous <code class="reqn">G</code> function <code><a href="#topic+GmultiInhom">GmultiInhom</a></code> 
and the inhomogeneous <code class="reqn">F</code> function <code><a href="#topic+FmultiInhom">FmultiInhom</a></code>
and computing the ratio <code class="reqn">J = (1-G)/(1-F)</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> containing the estimate of the
inhomogeneous multitype <code class="reqn">J</code> function.
</p>


<h3>Author(s)</h3>

<p>Jonatan Gonzalez and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O. and Van Lieshout, M.N.M. (2015)
Summary statistics for inhomogeneous marked point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
DOI: 10.1007/s10463-015-0515-z
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jcross.inhom">Jcross.inhom</a></code>, <code><a href="#topic+Jdot.inhom">Jdot.inhom</a></code>
for special cases.
</p>
<p><code><a href="#topic+GmultiInhom">GmultiInhom</a></code>, <code><a href="#topic+FmultiInhom">FmultiInhom</a></code>,
<code><a href="#topic+Jmulti">Jmulti</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(amacrine)
  I &lt;- (marks(X) == "on")
  J &lt;- (marks(X) == "off")
  if(interactive() &amp;&amp; require(spatstat.model)) {
    ## how to do it normally
    mod &lt;- ppm(X ~ marks * x)
    lam &lt;- fitted(mod, dataonly=TRUE)
    lmin &lt;- min(predict(mod)[["off"]]) * 0.9
    dd &lt;- NULL
  } else {
    ## for package testing
    lam &lt;- intensity(X)[as.integer(marks(X))]
    lmin &lt;- intensity(X)[2] * 0.9
    dd &lt;- 32
  }
  JM &lt;- Jmulti.inhom(X, I, J, lambda=lam, lambdamin=lmin, dimyx=dd)
</code></pre>

<hr>
<h2 id='K3est'>
K-function of a Three-Dimensional Point Pattern
</h2><span id='topic+K3est'></span>

<h3>Description</h3>

<p>Estimates the <code class="reqn">K</code>-function from a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  K3est(X, ...,
        rmax = NULL, nrval = 128,
        correction = c("translation", "isotropic"),
        ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K3est_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="K3est_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="K3est_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum value of argument <code class="reqn">r</code> for which
<code class="reqn">K_3(r)</code> will be estimated. 
</p>
</td></tr>
<tr><td><code id="K3est_+3A_nrval">nrval</code></td>
<td>

<p>Optional. Number of values of <code class="reqn">r</code> for which
<code class="reqn">K_3(r)</code> will be estimated. A large value of <code>nrval</code>
is required to avoid discretisation effects.
</p>
</td></tr>
<tr><td><code id="K3est_+3A_correction">correction</code></td>
<td>

<p>Optional. Character vector specifying the edge correction(s)
to be applied. See Details.
</p>
</td></tr>
<tr><td><code id="K3est_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a stationary point process <code class="reqn">\Phi</code> in three-dimensional
space, the three-dimensional <code class="reqn">K</code> function
is
</p>
<p style="text-align: center;"><code class="reqn">
    K_3(r) = \frac 1 \lambda E(N(\Phi, x, r) \mid x \in \Phi)
  </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity of the process
(the expected number of points per unit volume) and
<code class="reqn">N(\Phi,x,r)</code> is the number of points of
<code class="reqn">\Phi</code>, other than <code class="reqn">x</code> itself, which fall within a
distance <code class="reqn">r</code> of <code class="reqn">x</code>. This is the three-dimensional
generalisation of Ripley's <code class="reqn">K</code> function for two-dimensional
point processes (Ripley, 1977).
</p>
<p>The three-dimensional point pattern <code>X</code> is assumed to be a
partial realisation of a stationary point process <code class="reqn">\Phi</code>.
The distance between each pair of distinct points is computed.
The empirical cumulative distribution
function of these values, with appropriate edge corrections, is
renormalised to give the estimate of <code class="reqn">K_3(r)</code>.
</p>
<p>The available edge corrections are:
</p>

<dl>
<dt><code>"translation"</code>:</dt><dd>
<p>the Ohser translation correction estimator
(Ohser, 1983; Baddeley et al, 1993)
</p>
</dd>
<dt><code>"isotropic"</code>:</dt><dd>
<p>the three-dimensional counterpart of
Ripley's isotropic edge correction (Ripley, 1977; Baddeley et al, 1993).
</p>
</dd>
</dl>

<p>Alternatively <code>correction="all"</code> selects all options.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>) that can be
plotted, printed or coerced to a data frame containing the function values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rana Moyeed.
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A. (1993)
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b>, 641&ndash;668.
</p>
<p>Ohser, J. (1983)
On estimators for the reduced second moment measure of
point processes. <em>Mathematische Operationsforschung und
Statistik, series Statistics</em>, <b>14</b>, 63 &ndash; 71.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code>pp3</code> to create a three-dimensional point
pattern (object of class <code>"pp3"</code>).
</p>
<p><code><a href="#topic+pcf3est">pcf3est</a></code>,
<code><a href="#topic+F3est">F3est</a></code>,
<code><a href="#topic+G3est">G3est</a></code>
for other summary functions of
a three-dimensional point pattern.
</p>
<p><code><a href="#topic+Kest">Kest</a></code> to estimate the <code class="reqn">K</code>-function of
point patterns in two dimensions or other spaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp3(42)
  Z &lt;- K3est(X)
  if(interactive()) plot(Z)
</code></pre>

<hr>
<h2 id='kaplan.meier'>Kaplan-Meier Estimator using Histogram Data</h2><span id='topic+kaplan.meier'></span>

<h3>Description</h3>

<p>Compute the Kaplan-Meier estimator of a survival time distribution
function, from histogram data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kaplan.meier(obs, nco, breaks, upperobs=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaplan.meier_+3A_obs">obs</code></td>
<td>
<p>vector of <code class="reqn">n</code> integers giving the histogram of
all observations (censored or uncensored survival times)
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_nco">nco</code></td>
<td>
<p>vector of <code class="reqn">n</code> integers giving the histogram of
uncensored observations (those survival times that are less than or
equal to the censoring time)
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_breaks">breaks</code></td>
<td>
<p>Vector of <code class="reqn">n+1</code> breakpoints which were used to form
both histograms.
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_upperobs">upperobs</code></td>
<td>

<p>Number of observations beyond the rightmost breakpoint, if any.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
Kaplan-Meier estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>If the number of observations <code class="reqn">M</code> is large, it is efficient to
use histograms.
Form the histogram <code>obs</code> of all observed times <code class="reqn">\tilde T_i</code>.
That is, <code>obs[k]</code> counts the number of values 
<code class="reqn">\tilde T_i</code> in the interval
<code>(breaks[k],breaks[k+1]]</code> for <code class="reqn">k &gt; 1</code>
and <code>[breaks[1],breaks[2]]</code> for <code class="reqn">k = 1</code>.
Also form the histogram <code>nco</code> of all uncensored times,
i.e. those <code class="reqn">\tilde T_i</code> such that <code class="reqn">D_i=1</code>.
These two histograms are the arguments passed to <code>kaplan.meier</code>.
</p>
<p>The vectors <code>km</code> and <code>lambda</code> returned by <code>kaplan.meier</code>
are (histogram approximations to) the Kaplan-Meier estimator
of <code class="reqn">F(t)</code> and its hazard rate <code class="reqn">\lambda(t)</code>.
Specifically, <code>km[k]</code> is an estimate of
<code>F(breaks[k+1])</code>, and <code>lambda[k]</code> is an estimate of
the average of <code class="reqn">\lambda(t)</code> over the interval
<code>(breaks[k],breaks[k+1])</code>.
</p>
<p>The histogram breaks must include <code class="reqn">0</code>.
If the histogram breaks do not span the range of the observations,
it is important to count how many survival times
<code class="reqn">\tilde T_i</code> exceed the rightmost breakpoint,
and give this as the value <code>upperobs</code>.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>km</code></td>
<td>
<p>Kaplan-Meier estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>corresponding Nelson-Aalen estimate of the
hazard rate <code class="reqn">\lambda(t)</code>
</p>
</td></tr>
</table>
<p>These are numeric vectors of length <code class="reqn">n</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>
</p>

<hr>
<h2 id='Kcross'>
Multitype K Function (Cross-type)
</h2><span id='topic+Kcross'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the multitype <code class="reqn">K</code> function
which counts the expected number of points of type <code class="reqn">j</code>
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kcross(X, i, j, r=NULL, breaks=NULL, correction,
       ..., ratio=FALSE, from, to )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross type <code class="reqn">K</code> function
<code class="reqn">K_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">K_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"periodic"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Kcross_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Kcross_+3A_from">from</code>, <code id="Kcross_+3A_to">to</code></td>
<td>

<p>An alternative way to specify <code>i</code> and <code>j</code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Kcross</code> and its companions
<code><a href="#topic+Kdot">Kdot</a></code> and <code><a href="#topic+Kmulti">Kmulti</a></code>
are generalisations of the function <code><a href="#topic+Kest">Kest</a></code>
to multitype point patterns. 
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
</p>
<p>The arguments <code>i</code> and <code>j</code> will be interpreted as
levels of the factor <code>X$marks</code>. 
If <code>i</code> and <code>j</code> are missing, they default to the first
and second level of the marks factor, respectively.
</p>
<p>The &ldquo;cross-type&rdquo; (type <code class="reqn">i</code> to type <code class="reqn">j</code>)
<code class="reqn">K</code> function 
of a stationary multitype point process <code class="reqn">X</code> is defined so that
<code class="reqn">\lambda_j K_{ij}(r)</code> equals the expected number of
additional random points of type <code class="reqn">j</code>
within a distance <code class="reqn">r</code> of a
typical point of type <code class="reqn">i</code> in the process <code class="reqn">X</code>.
Here <code class="reqn">\lambda_j</code>
is the intensity of the type <code class="reqn">j</code> points,
i.e. the expected number of points of type <code class="reqn">j</code> per unit area.
The function <code class="reqn">K_{ij}</code> is determined by the 
second order moment properties of <code class="reqn">X</code>.
</p>
<p>An estimate of <code class="reqn">K_{ij}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern.
If the process of type <code class="reqn">i</code> points
were independent of the process of type <code class="reqn">j</code> points,
then <code class="reqn">K_{ij}(r)</code> would equal <code class="reqn">\pi r^2</code>.
Deviations between the empirical <code class="reqn">K_{ij}</code> curve
and the theoretical curve <code class="reqn">\pi r^2</code> 
may suggest dependence between the points of types <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>This algorithm estimates the distribution function <code class="reqn">K_{ij}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>,
using the border correction.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kcross</code>; see <code><a href="#topic+pcf">pcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{ij}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{ij}(r)</code>
obtained by the edge corrections named.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K(r)</code>. 
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are always interpreted as
levels of the factor <code>X$marks</code>. They are converted to character
strings if they are not already character strings.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # amacrine cells data
    K01 &lt;- Kcross(amacrine, "off", "on") 
    plot(K01)

    

    # synthetic example: point pattern with marks 0 and 1
    
     pp &lt;- runifpoispp(50)
     pp &lt;- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
     K &lt;- Kcross(pp, "0", "1")
     K &lt;- Kcross(pp, 0, 1) # equivalent
    
</code></pre>

<hr>
<h2 id='Kcross.inhom'>
Inhomogeneous Cross K Function
</h2><span id='topic+Kcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the cross <code class="reqn">K</code> function,
which counts the expected number of points of type <code class="reqn">j</code>
within a given distance of a point of type <code class="reqn">i</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kcross.inhom(X, i, j, lambdaI=NULL, lambdaJ=NULL, ...,  r=NULL, breaks=NULL,
         correction = c("border", "isotropic", "Ripley", "translate"),
         sigma=NULL, varcov=NULL,
         lambdaIJ=NULL,
         lambdaX=NULL, update=TRUE, leaveoneout=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous cross type <code class="reqn">K</code> function
<code class="reqn">K_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the the estimated intensity of the sub-process of
points of type <code>j</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>j</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location. 
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector giving the values of the argument <code class="reqn">r</code>
at which the cross K function
<code class="reqn">K_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for advanced use only.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code> ,<code>"translate"</code>,
<code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of isotropic Gaussian smoothing kernel,
used in computing leave-one-out kernel estimates of
<code>lambdaI</code>, <code>lambdaJ</code> if they are omitted.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic Gaussian kernel,
used in computing leave-one-out kernel estimates of
<code>lambdaI</code>, <code>lambdaJ</code> if they are omitted.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_lambdaij">lambdaIJ</code></td>
<td>

<p>Optional. A matrix containing estimates of the
product of the intensities <code>lambdaI</code> and <code>lambdaJ</code>
for each pair of points of types <code>i</code> and <code>j</code> respectively.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_lambdax">lambdaX</code></td>
<td>

<p>Optional. Values of the intensity for all points of <code>X</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
If present, this argument overrides both <code>lambdaI</code> and
<code>lambdaJ</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when
<code>lambdaI</code>, <code>lambdaJ</code> or <code>lambdaX</code>
is a fitted point process model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Kcross.inhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the function <code><a href="#topic+Kcross">Kcross</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Kinhom">Kinhom</a></code>.
</p>
<p>The inhomogeneous cross-type <code class="reqn">K</code> function is described by
Moller and Waagepetersen (2003, pages 48-49 and 51-53).
</p>
<p>Briefly, given a multitype point process, suppose the sub-process
of points of type <code class="reqn">j</code> has intensity function
<code class="reqn">\lambda_j(u)</code> at spatial locations <code class="reqn">u</code>.
Suppose we place a mass of <code class="reqn">1/\lambda_j(\zeta)</code>
at each point <code class="reqn">\zeta</code> of type <code class="reqn">j</code>. Then the expected total
mass per unit area is 1. The
inhomogeneous &ldquo;cross-type&rdquo; <code class="reqn">K</code> function 
<code class="reqn">K_{ij}^{\mbox{inhom}}(r)</code> equals the expected
total mass within a radius <code class="reqn">r</code> of a point of the process
of type <code class="reqn">i</code>. 
</p>
<p>If the process of type <code class="reqn">i</code> points
were independent of the process of type <code class="reqn">j</code> points,
then <code class="reqn">K_{ij}^{\mbox{inhom}}(r)</code>
would equal <code class="reqn">\pi r^2</code>.
Deviations between the empirical <code class="reqn">K_{ij}</code> curve
and the theoretical curve <code class="reqn">\pi r^2</code> 
suggest dependence between the points of types <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
</p>
<p>The arguments <code>i</code> and <code>j</code> will be interpreted as
levels of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as the number 3,
<b>not</b> the 3rd smallest level).
If <code>i</code> and <code>j</code> are missing, they default to the first
and second level of the marks factor, respectively.
</p>
<p>The argument <code>lambdaI</code> supplies the values
of the intensity of the sub-process of points of type <code>i</code>.
It may be either
</p>

<dl>
<dt>a pixel image</dt><dd><p>(object of class <code>"im"</code>) which
gives the values of the type <code>i</code> intensity
at all locations in the window containing <code>X</code>;
</p>
</dd>
<dt>a numeric vector</dt><dd><p>containing the values of the
type <code>i</code> intensity evaluated only
at the data points of type <code>i</code>. The length of this vector
must equal the number of type <code>i</code> points in <code>X</code>.
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambdaI</code> is omitted then it will be estimated
using a leave-one-out kernel smoother. 
</p>
</dd>
</dl>

<p>If <code>lambdaI</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother,
as described in Baddeley, Moller 
and Waagepetersen (2000).  The estimate of <code>lambdaI</code> for a given
point is computed by removing the point from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point in question. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>
<p>Similarly <code>lambdaJ</code> should contain
estimated values of the intensity of the sub-process of points of
type <code>j</code>. It may be either a pixel image, a function,
a numeric vector, or omitted.
</p>
<p>Alternatively if the argument <code>lambdaX</code> is given, then it specifies
the intensity values for all points of <code>X</code>, and the
arguments <code>lambdaI</code>, <code>lambdaJ</code> will be ignored.
</p>
<p>The optional argument <code>lambdaIJ</code> is for advanced use only.
It is a matrix containing estimated
values of the products of these two intensities for each pair of
data points of types <code>i</code> and <code>j</code> respectively.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>The argument <code>correction</code> chooses the edge correction
as explained e.g. in <code><a href="#topic+Kest">Kest</a></code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kcross.inhom</code>; see <code><a href="#topic+pcf">pcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{ij}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{ij}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are always interpreted as
levels of the factor <code>X$marks</code>. They are converted to character
strings if they are not already character strings.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329&ndash;350.
</p>
<p>Moller, J. and Waagepetersen, R.
Statistical Inference and Simulation for Spatial Point Processes
Chapman and Hall/CRC
Boca Raton, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kdot.inhom">Kdot.inhom</a></code>,
<code><a href="#topic+Kmulti.inhom">Kmulti.inhom</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Lansing Woods data
    woods &lt;- lansing
    
    ma &lt;- split(woods)$maple
    wh &lt;- split(woods)$whiteoak

    # method (1): estimate intensities by nonparametric smoothing
    lambdaM &lt;- density.ppp(ma, sigma=0.15, at="points")
    lambdaW &lt;- density.ppp(wh, sigma=0.15, at="points")
    K &lt;- Kcross.inhom(woods, "whiteoak", "maple", lambdaW, lambdaM)

    # method (2): leave-one-out
    K &lt;- Kcross.inhom(woods, "whiteoak", "maple", sigma=0.15)

    # method (3): fit parametric intensity model
    if(require("spatstat.model")) {
    fit &lt;- ppm(woods ~marks * polynom(x,y,2))
    # alternative (a): use fitted model as 'lambda' argument
    online &lt;- interactive()
    K &lt;- Kcross.inhom(woods, "whiteoak", "maple",
                      lambdaI=fit, lambdaJ=fit,
                      update=online, leaveoneout=online)
    K &lt;- Kcross.inhom(woods, "whiteoak", "maple",
                      lambdaX=fit,
                      update=online, leaveoneout=online)
    # alternative (b): evaluate fitted intensities at data points
    # (these are the intensities of the sub-processes of each type)
    inten &lt;- fitted(fit, dataonly=TRUE, leaveoneout=FALSE)
    # split according to types of points
    lambda &lt;- split(inten, marks(woods))
    K &lt;- Kcross.inhom(woods, "whiteoak", "maple",
              lambda$whiteoak, lambda$maple)
    }
    
    # synthetic example: type A points have intensity 50,
    #                    type B points have intensity 100 * x
    lamB &lt;- as.im(function(x,y){50 + 100 * x}, owin())
    X &lt;- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
    K &lt;- Kcross.inhom(X, "A", "B",
        lambdaI=as.im(50, Window(X)), lambdaJ=lamB)
</code></pre>

<hr>
<h2 id='Kdot'>
Multitype K Function (i-to-any)
</h2><span id='topic+Kdot'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the multitype <code class="reqn">K</code> function
which counts the expected number of other points of the process
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kdot(X, i, r=NULL, breaks=NULL, correction, ..., ratio=FALSE, from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kdot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the multitype <code class="reqn">K</code> function
<code class="reqn">K_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the distribution function
<code class="reqn">K_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"periodic"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Kdot_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Kdot_+3A_from">from</code></td>
<td>
<p>An alternative way to specify <code>i</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Kdot</code> and its companions
<code><a href="#topic+Kcross">Kcross</a></code> and <code><a href="#topic+Kmulti">Kmulti</a></code>
are generalisations of the function <code><a href="#topic+Kest">Kest</a></code>
to multitype point patterns. 
</p>
<p>A multitype point pattern is a spatial pattern of
points classified into a finite number of possible
&ldquo;colours&rdquo; or &ldquo;types&rdquo;. In the <span class="pkg">spatstat</span> package,
a multitype pattern is represented as a single 
point pattern object in which the points carry marks,
and the mark value attached to each point
determines the type of that point.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
</p>
<p>The argument <code>i</code> will be interpreted as a
level of the factor <code>X$marks</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor, <code>i = levels(X$marks)[1]</code>.
</p>
<p>The &ldquo;type <code class="reqn">i</code> to any type&rdquo; multitype <code class="reqn">K</code> function 
of a stationary multitype point process <code class="reqn">X</code> is defined so that
<code class="reqn">\lambda K_{i\bullet}(r)</code>
equals the expected number of
additional random points within a distance <code class="reqn">r</code> of a
typical point of type <code class="reqn">i</code> in the process <code class="reqn">X</code>.
Here <code class="reqn">\lambda</code>
is the intensity of the process,
i.e. the expected number of points of <code class="reqn">X</code> per unit area.
The function <code class="reqn">K_{i\bullet}</code> is determined by the 
second order moment properties of <code class="reqn">X</code>.
</p>
<p>An estimate of <code class="reqn">K_{i\bullet}(r)</code>
is a useful summary statistic in exploratory data analysis
of a multitype point pattern.
If the subprocess of type <code class="reqn">i</code> points were independent
of the subprocess of points of all types not equal to <code class="reqn">i</code>,
then <code class="reqn">K_{i\bullet}(r)</code> would equal <code class="reqn">\pi r^2</code>.
Deviations between the empirical <code class="reqn">K_{i\bullet}</code> curve
and the theoretical curve <code class="reqn">\pi r^2</code> 
may suggest dependence between types.
</p>
<p>This algorithm estimates the distribution function <code class="reqn">K_{i\bullet}(r)</code> 
from the point pattern <code>X</code>. It assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>,
using the chosen edge correction(s).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kdot</code>; see <code><a href="#topic+pcf">pcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{i\bullet}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{i\bullet}(r)</code>
obtained by the edge corrections named.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K(r)</code>. 
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>
<p>The reduced sample estimator of <code class="reqn">K_{i\bullet}</code> is pointwise approximately 
unbiased, but need not be a valid distribution function; it may 
not be a nondecreasing function of <code class="reqn">r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Lansing woods data: 6 types of trees
    woods &lt;- lansing

    

    Kh. &lt;- Kdot(woods, "hickory") 
    # diagnostic plot for independence between hickories and other trees
    plot(Kh.)

    # synthetic example with two marks "a" and "b"
    
      pp &lt;- runifpoispp(50)
      pp &lt;- pp %mark% factor(sample(c("a","b"), npoints(pp), replace=TRUE))
      K &lt;- Kdot(pp, "a")
   
</code></pre>

<hr>
<h2 id='Kdot.inhom'>
Inhomogeneous Multitype K Dot Function
</h2><span id='topic+Kdot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the dot <code class="reqn">K</code> function,
which counts the expected number of points of any type
within a given distance of a point of type <code class="reqn">i</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kdot.inhom(X, i, lambdaI=NULL, lambdadot=NULL, ..., r=NULL, breaks=NULL,
         correction = c("border", "isotropic", "Ripley", "translate"),
         sigma=NULL, varcov=NULL, lambdaIdot=NULL,
         lambdaX=NULL, update=TRUE, leaveoneout=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kdot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous dot type <code class="reqn">K</code> function
<code class="reqn">K_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process of
points of type <code>i</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the type <code>i</code> points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the entire point process,
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values at each of the 
points in <code>X</code>, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector giving the values of the argument <code class="reqn">r</code>
at which the dot K function
<code class="reqn">K_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of isotropic Gaussian smoothing kernel,
used in computing leave-one-out kernel estimates of
<code>lambdaI</code>, <code>lambdadot</code> if they are omitted.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic Gaussian kernel,
used in computing leave-one-out kernel estimates of
<code>lambdaI</code>, <code>lambdadot</code> if they are omitted.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_lambdaidot">lambdaIdot</code></td>
<td>

<p>Optional. A matrix containing estimates of the
product of the intensities <code>lambdaI</code> and <code>lambdadot</code>
for each pair of points, the first point of type <code>i</code> and
the second of any type.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_lambdax">lambdaX</code></td>
<td>

<p>Optional. Values of the intensity for all points of <code>X</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
If present, this argument overrides both <code>lambdaI</code> and
<code>lambdadot</code>.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when
<code>lambdaI</code>, <code>lambdadot</code> or <code>lambdaX</code>
is a fitted point process model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Kdot.inhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the function <code><a href="#topic+Kdot">Kdot</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Kinhom">Kinhom</a></code>.
</p>
<p>Briefly, given a multitype point process, consider the points without
their types, and suppose this unmarked point process 
has intensity function
<code class="reqn">\lambda(u)</code> at spatial locations <code class="reqn">u</code>.
Suppose we place a mass of <code class="reqn">1/\lambda(\zeta)</code>
at each point <code class="reqn">\zeta</code> of the process. Then the expected total
mass per unit area is 1. The
inhomogeneous &ldquo;dot-type&rdquo; <code class="reqn">K</code> function 
<code class="reqn">K_{i\bullet}^{\mbox{inhom}}(r)</code> equals the expected
total mass within a radius <code class="reqn">r</code> of a point of the process
of type <code class="reqn">i</code>, discounting this point itself.
</p>
<p>If the process of type <code class="reqn">i</code> points
were independent of the points of other types,
then <code class="reqn">K_{i\bullet}^{\mbox{inhom}}(r)</code>
would equal <code class="reqn">\pi r^2</code>.
Deviations between the empirical <code class="reqn">K_{i\bullet}</code> curve
and the theoretical curve <code class="reqn">\pi r^2</code> 
suggest dependence between the points of types <code class="reqn">i</code> and <code class="reqn">j</code> for
<code class="reqn">j\neq i</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern, and the mark vector
<code>X$marks</code> must be a factor.
</p>
<p>The argument <code>i</code> will be interpreted as a
level of the factor <code>X$marks</code>. (Warning: this means that
an integer value <code>i=3</code> will be interpreted as the number 3,
<b>not</b> the 3rd smallest level).
If <code>i</code> is missing, it defaults to the first
level of the marks factor, <code>i = levels(X$marks)[1]</code>.
</p>
<p>The argument <code>lambdaI</code> supplies the values
of the intensity of the sub-process of points of type <code>i</code>.
It may be either
</p>

<dl>
<dt>a pixel image</dt><dd><p>(object of class <code>"im"</code>) which
gives the values of the type <code>i</code> intensity
at all locations in the window containing <code>X</code>;
</p>
</dd>
<dt>a numeric vector</dt><dd><p>containing the values of the
type <code>i</code> intensity evaluated only
at the data points of type <code>i</code>. The length of this vector
must equal the number of type <code>i</code> points in <code>X</code>.
</p>
</dd>
<dt>a function</dt><dd>
<p>of the form <code>function(x,y)</code>
which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambdaI</code> is omitted then it will be estimated
using a leave-one-out kernel smoother. 
</p>
</dd>
</dl>

<p>If <code>lambdaI</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother, as described in Baddeley,
Moller 
and Waagepetersen (2000).  The estimate of <code>lambdaI</code> for a given
point is computed by removing the point from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point in question. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>
<p>Similarly the argument <code>lambdadot</code> should contain
estimated values of the intensity of the entire point process.
It may be either a pixel image, a numeric vector of length equal
to the number of points in <code>X</code>, a function, or omitted.
</p>
<p>Alternatively if the argument <code>lambdaX</code> is given, then it specifies
the intensity values for all points of <code>X</code>, and the
arguments <code>lambdaI</code>, <code>lambdadot</code> will be ignored.
(The two arguments <code>lambdaI</code>, <code>lambdadot</code> allow the user
to specify two different methods for calculating the intensities of
the two kinds of points, while <code>lambdaX</code> ensures that the same
method is used for both kinds of points.)
</p>
<p>For advanced use only, the optional argument <code>lambdaIdot</code>
is a matrix containing estimated
values of the products of these two intensities for each pair of
points, the first point of type <code>i</code> and the second of any type.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>The argument <code>correction</code> chooses the edge correction
as explained e.g. in <code><a href="#topic+Kest">Kest</a></code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kdot.inhom</code>; see <code><a href="#topic+pcf">pcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{i\bullet}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{i\bullet}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Moller, J. and Waagepetersen, R.
Statistical Inference and Simulation for Spatial Point Processes
Chapman and Hall/CRC
Boca Raton, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code>,
<code><a href="#topic+Kmulti.inhom">Kmulti.inhom</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Lansing Woods data
    woods &lt;- lansing
    woods &lt;- woods[seq(1,npoints(woods), by=10)]
    ma &lt;- split(woods)$maple
    lg &lt;- unmark(woods)

    # Estimate intensities by nonparametric smoothing
    lambdaM &lt;- density.ppp(ma, sigma=0.15, at="points")
    lambdadot &lt;- density.ppp(lg, sigma=0.15, at="points")
    K &lt;- Kdot.inhom(woods, "maple", lambdaI=lambdaM,
                                      lambdadot=lambdadot)

    # Equivalent
    K &lt;- Kdot.inhom(woods, "maple", sigma=0.15)

    # Fit model
    if(require("spatstat.model")) {
    fit &lt;- ppm(woods ~ marks * polynom(x,y,2))
    K &lt;- Kdot.inhom(woods, "maple", lambdaX=fit,
                    update=FALSE, leaveoneout=FALSE)
    }
    
    # synthetic example: type A points have intensity 50,
    #                    type B points have intensity 50 + 100 * x
    lamB &lt;- as.im(function(x,y){50 + 100 * x}, owin())
    lamdot &lt;- as.im(function(x,y) { 100 + 100 * x}, owin())
    X &lt;- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
    K &lt;- Kdot.inhom(X, "B",  lambdaI=lamB,     lambdadot=lamdot)
</code></pre>

<hr>
<h2 id='kernel.factor'>Scale factor for density kernel</h2><span id='topic+kernel.factor'></span>

<h3>Description</h3>

<p>Returns a scale factor for the kernels used in density estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.factor(kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.factor_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
</p>
<p>This function computes a scale constant for the kernel.
For the Gaussian kernel, this constant is equal to 1.
Otherwise, the constant <code class="reqn">c</code> is such that the kernel
with standard deviation <code class="reqn">1</code> is supported on the interval
<code class="reqn">[-c,c]</code>. 
</p>
<p>For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.factor("rect")
   # bandwidth for Epanechnikov kernel with half-width h=1
   h &lt;- 1
   bw &lt;- h/kernel.factor("epa")
</code></pre>

<hr>
<h2 id='kernel.moment'>Incomplete Moment of Smoothing Kernel</h2><span id='topic+kernel.moment'></span>

<h3>Description</h3>

<p>Computes the complete or incomplete <code class="reqn">m</code>th moment of a
smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.moment(m, r, kernel = "gaussian", mean=0, sd=1/kernel.factor(kernel))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.moment_+3A_m">m</code></td>
<td>

<p>Exponent (order of moment).
An integer.
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_r">r</code></td>
<td>

<p>Upper limit of integration for the incomplete moment.
A numeric value or numeric vector.
Set <code>r=Inf</code> to obtain the complete moment.
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_mean">mean</code>, <code id="kernel.moment_+3A_sd">sd</code></td>
<td>

<p>Optional numerical values giving the mean and standard deviation
of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>
<p>The function <code>kernel.moment</code> computes the integral 
</p>
<p style="text-align: center;"><code class="reqn">
    \int_{-\infty}^r t^m k(t) dt
  </code>
</p>

<p>where <code class="reqn">k(t)</code> is the selected kernel, <code class="reqn">r</code> is the upper limit of
integration, and <code class="reqn">m</code> is the exponent or order.
</p>
<p>Note that, if <code>mean</code> and <code>sd</code> are not specified, the
calculations assume that <code class="reqn">k(t)</code> is the <b>standard form</b> of the kernel,
which has support <code class="reqn">[-1,1]</code> and
standard deviation <code class="reqn">sigma = 1/c</code> where <code>c = kernel.factor(kernel)</code>.
</p>
<p>The code uses the explicit analytic expressions when
<code>m = 0, 1, 2</code> and numerical integration otherwise.
</p>


<h3>Value</h3>

<p>A single number, or a numeric vector of the same length as <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.moment(1, 0.1, "epa")
   curve(kernel.moment(2, x, "epa"), from=-1, to=1)
</code></pre>

<hr>
<h2 id='kernel.squint'>Integral of Squared Kernel</h2><span id='topic+kernel.squint'></span>

<h3>Description</h3>

<p>Computes the integral of the squared kernel,
for the kernels used in density estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.squint(kernel = "gaussian", bw=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.squint_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="kernel.squint_+3A_bw">bw</code></td>
<td>

<p>Bandwidth (standard deviation) of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
</p>
<p>This function computes the integral of the squared kernel,
</p>
<p style="text-align: center;"><code class="reqn">
    R = \int_{-\infty}^{\infty} k(x)^2 \, {\rm d}x
  </code>
</p>

<p>where <code class="reqn">k(x)</code> is the kernel with bandwidth <code>bw</code>.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.squint("gaussian", 3)

   # integral of squared Epanechnikov kernel with half-width h=1
   h &lt;- 1
   bw &lt;- h/kernel.factor("epa")
   kernel.squint("epa", bw)
</code></pre>

<hr>
<h2 id='Kest'>K-function</h2><span id='topic+Kest'></span>

<h3>Description</h3>

<p>Estimates Ripley's reduced second moment function <code class="reqn">K(r)</code> 
from a point pattern in a window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kest(X, ..., r=NULL, rmax=NULL, breaks=NULL, 
     correction=c("border", "isotropic", "Ripley", "translate"),
    nlarge=3000, domain=NULL, var.approx=FALSE, ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kest_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">K(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Kest_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">K(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default. If necessary, specify <code>rmax</code>.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_correction">correction</code></td>
<td>

<p>Optional. A character vector containing any selection of the
options <code>"none"</code>, <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"rigid"</code>,
<code>"none"</code>, <code>"periodic"</code>, <code>"good"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_nlarge">nlarge</code></td>
<td>

<p>Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed (by default), using a fast algorithm.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_domain">domain</code></td>
<td>

<p>Optional. Calculations will be restricted to this subset
of the window. See Details.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_var.approx">var.approx</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the approximate
variance of <code class="reqn">\hat K(r)</code> under CSR
will also be computed.
</p>
</td></tr>
<tr><td><code id="Kest_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">K</code> function (variously called &ldquo;Ripley's K-function&rdquo;
and the &ldquo;reduced second moment function&rdquo;)
of a stationary point process <code class="reqn">X</code> is defined so that
<code class="reqn">\lambda K(r)</code> equals the expected number of
additional random points within a distance <code class="reqn">r</code> of a
typical random point of <code class="reqn">X</code>. Here <code class="reqn">\lambda</code>
is the intensity of the process,
i.e. the expected number of points of <code class="reqn">X</code> per unit area.
The <code class="reqn">K</code> function is determined by the 
second order moment properties of <code class="reqn">X</code>.
</p>
<p>An estimate of <code class="reqn">K</code> derived from a spatial point pattern dataset
can be used in exploratory data analysis and formal inference
about the pattern (Cressie, 1991; Diggle, 1983; Ripley, 1977, 1988).
In exploratory analyses, the estimate of <code class="reqn">K</code> is a useful statistic 
summarising aspects of inter-point &ldquo;dependence&rdquo; and &ldquo;clustering&rdquo;.
For inferential purposes, the estimate of <code class="reqn">K</code> is usually compared to the 
true value of <code class="reqn">K</code> for a completely random (Poisson) point process,
which is <code class="reqn">K(r) = \pi r^2</code>.
Deviations between the empirical and theoretical <code class="reqn">K</code> curves
may suggest spatial clustering or spatial regularity.
</p>
<p>This routine <code>Kest</code> estimates the <code class="reqn">K</code> function
of a stationary point process, given observation of the process
inside a known, bounded window. 
The argument <code>X</code> is interpreted as a point pattern object 
(of class <code>"ppp"</code>, see <code>ppp.object</code>) and can
be supplied in any of the formats recognised by
<code>as.ppp()</code>.
</p>
<p>The estimation of <code class="reqn">K</code> is hampered by edge effects arising from 
the unobservability of points of the random pattern outside the window. 
An edge correction is needed to reduce bias (Baddeley, 1998; Ripley, 1988). 
The corrections implemented here are
</p>

<dl>
<dt>border</dt><dd><p>the border method or
&ldquo;reduced sample&rdquo; estimator (see Ripley, 1988). This is
the least efficient (statistically) and the fastest to compute.
It can be computed for a window of arbitrary shape.
</p>
</dd>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented for rectangular and polygonal windows
(not for binary masks).
</p>
</dd>
<dt>translate/translation</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
<dt>rigid</dt><dd><p>Rigid motion correction (Ohser and Stoyan, 1981).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
<dt>none</dt><dd>
<p>Uncorrected estimate.
An estimate of the K function <em>without</em> edge correction.
(i.e. setting <code class="reqn">e_{ij} = 1</code> in the equation below.
This estimate is <b>biased</b> and should
not be used for data analysis, <em>unless</em> you have
an extremely large point pattern (more than 100,000 points).
</p>
</dd>
<dt>periodic</dt><dd>
<p>Periodic (toroidal) edge correction.
Defined only for rectangular windows.
</p>
</dd>
<dt>best</dt><dd>
<p>Selects the best edge correction
that is available for the geometry of the window. Currently
this is Ripley's isotropic correction for a rectangular
or polygonal window, and the translation correction for masks.
</p>
</dd>
<dt>good</dt><dd>
<p>Selects the best edge correction
that can be computed in a reasonable time.
This is the same as <code>"best"</code> for datasets with fewer
than 3000 points; otherwise the selected edge correction
is <code>"border"</code>, unless there are more than 100,000 points, when 
it is <code>"none"</code>.
</p>
</dd>
</dl>

<p>The estimates of <code class="reqn">K(r)</code> are of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \hat K(r) = \frac a {n (n-1) } \sum_i \sum_j I(d_{ij}\le r) e_{ij}
  </code>
</p>

<p>where <code class="reqn">a</code> is the area of the window, <code class="reqn">n</code> is the number of
data points, and the sum is taken over all ordered pairs of points
<code class="reqn">i</code> and <code class="reqn">j</code> in <code>X</code>.
Here <code class="reqn">d_{ij}</code> is the distance between the two points,
and <code class="reqn">I(d_{ij} \le r)</code> is the indicator
that equals 1 if the distance is less than or equal to <code class="reqn">r</code>.
The term <code class="reqn">e_{ij}</code> is the edge correction weight (which
depends on the choice of edge correction listed above).
</p>
<p>Note that this estimator assumes the process is stationary (spatially
homogeneous). For inhomogeneous point patterns, see
<code><a href="#topic+Kinhom">Kinhom</a></code>.
</p>
<p>If the point pattern <code>X</code> contains more than about 3000 points,
the isotropic and translation edge corrections can be computationally
prohibitive. The computations for the border method are much faster,
and are statistically efficient when there are large numbers of
points. Accordingly, if the number of points in <code>X</code> exceeds
the threshold <code>nlarge</code>, then only the border correction will be
computed. Setting <code>nlarge=Inf</code> or <code>correction="best"</code>
will prevent this from happening.
Setting <code>nlarge=0</code> is equivalent to selecting only the border
correction with <code>correction="border"</code>.
</p>
<p>If <code>X</code> contains more than about 100,000 points,
even the border correction is time-consuming. You may want to consider
setting <code>correction="none"</code> in this case.
There is an even faster algorithm for the uncorrected estimate.
</p>
<p>Approximations to the variance of <code class="reqn">\hat K(r)</code>
are available, for the case of the isotropic edge correction estimator,
<b>assuming complete spatial randomness</b>
(Ripley, 1988; Lotwick and Silverman, 1982; Diggle, 2003, pp 51-53).
If <code>var.approx=TRUE</code>, then the result of
<code>Kest</code> also has a column named <code>rip</code> 
giving values of Ripley's (1988) approximation to
<code class="reqn">\mbox{var}(\hat K(r))</code>,
and (if the window is a rectangle) a column named <code>ls</code> giving
values of Lotwick and Silverman's (1982) approximation.
</p>
<p>If the argument <code>domain</code> is given, the calculations will
be restricted to a subset of the data. In the formula for <code class="reqn">K(r)</code> above,
the <em>first</em> point <code class="reqn">i</code> will be restricted to lie inside
<code>domain</code>. The result is an approximately unbiased estimate
of <code class="reqn">K(r)</code> based on pairs of points in which the first point lies
inside <code>domain</code> and the second point is unrestricted.
This is useful in bootstrap techniques. The argument <code>domain</code>
should be a window (object of class <code>"owin"</code>) or something acceptable to
<code>as.owin</code>. It must be a subset of the
window of the point pattern <code>X</code>.
</p>
<p>The estimator <code>Kest</code> ignores marks.
Its counterparts for multitype point patterns
are <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>,
and for general marked point patterns
see <code><a href="#topic+Kmulti">Kmulti</a></code>. 
</p>
<p>Some writers, particularly Stoyan (1994, 1995) advocate the use of
the &ldquo;pair correlation function&rdquo;
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \frac{K'(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'(r)</code> is the derivative of <code class="reqn">K(r)</code>.
See <code><a href="#topic+pcf">pcf</a></code> on how to estimate this function.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K(r)</code> obtained by the edge corrections
named.
</p>
<p>If <code>var.approx=TRUE</code> then the return value
also has columns <code>rip</code> and <code>ls</code> containing approximations
to the variance of <code class="reqn">\hat K(r)</code> under CSR.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K(r)</code>. 
</p>


<h3>Envelopes, significance bands and confidence intervals</h3>

<p>To compute simulation envelopes for the <code class="reqn">K</code>-function
under CSR, use <code><a href="#topic+envelope">envelope</a></code>. 
</p>
<p>To compute a confidence interval for the true <code class="reqn">K</code>-function,
use <code><a href="#topic+varblock">varblock</a></code> or <code><a href="#topic+lohboot">lohboot</a></code>.
</p>


<h3>Warnings</h3>

<p>The estimator of <code class="reqn">K(r)</code> is approximately unbiased for each fixed
<code class="reqn">r</code>, for point processes which do not have very strong
interaction. (For point processes with a strong clustering interaction,
the estimator is negatively biased; for point processes with a strong
inhibitive interaction, the estimator is positively biased.)
</p>
<p>Bias increases with <code class="reqn">r</code> and depends on the window geometry.
For a rectangular window it is prudent to restrict the <code class="reqn">r</code> values to
a maximum of <code class="reqn">1/4</code> of the smaller side length of the rectangle
(Ripley, 1977, 1988; Diggle, 1983).
Bias may become appreciable for point patterns consisting of 
fewer than 15 points.
</p>
<p>While <code class="reqn">K(r)</code> is always a non-decreasing function, the estimator 
of <code class="reqn">K</code> is not guaranteed to be non-decreasing. This is rarely 
a problem in practice, except for the border correction estimators
when the number of points is small.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. Spatial sampling and censoring.
In O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. van Lieshout (eds) 
<em>Stochastic Geometry: Likelihood and Computation</em>.
Chapman and Hall, 1998.
Chapter 2, pages 37&ndash;78.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Ohser, J. (1983)
On estimators for the reduced second moment measure of
point processes. <em>Mathematische Operationsforschung und
Statistik, series Statistics</em>, <b>14</b>, 63 &ndash; 71.
</p>
<p>Ohser, J. and Stoyan, D. (1981)
On the second-order and orientation analysis of
planar stationary point processes.
<em>Biometrical Journal</em> <b>23</b>, 523&ndash;533.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localK">localK</a></code> to extract individual summands in the <code class="reqn">K</code>
function.
</p>
<p><code><a href="#topic+pcf">pcf</a></code> for the pair correlation.
</p>
<p><code><a href="#topic+Fest">Fest</a></code>,
<code><a href="#topic+Gest">Gest</a></code>,
<code><a href="#topic+Jest">Jest</a></code>
for alternative summary functions.
</p>
<p><code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code> for counterparts of the <code class="reqn">K</code> function
for multitype point patterns.
</p>
<p><code><a href="#topic+reduced.sample">reduced.sample</a></code> for the calculation of reduced sample
estimators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- runifpoint(50)
 K &lt;- Kest(X)
 K &lt;- Kest(cells, correction="isotropic")
 plot(K)
 plot(K, main="K function for cells")
 # plot the L function
 plot(K, sqrt(iso/pi) ~ r)
 plot(K, sqrt(./pi) ~ r, ylab="L(r)", main="L function for cells")
</code></pre>

<hr>
<h2 id='Kest.fft'>K-function using FFT</h2><span id='topic+Kest.fft'></span>

<h3>Description</h3>

<p>Estimates the reduced second moment function <code class="reqn">K(r)</code> 
from a point pattern in a window of arbitrary shape,
using the Fast Fourier Transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kest.fft(X, sigma, r=NULL, ..., breaks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kest.fft_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">K(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Kest.fft_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of the isotropic Gaussian
smoothing kernel.
</p>
</td></tr>
<tr><td><code id="Kest.fft_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">K(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kest.fft_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> determining the
spatial resolution for the FFT calculation.
</p>
</td></tr>
<tr><td><code id="Kest.fft_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative to the function <code><a href="#topic+Kest">Kest</a></code>
for estimating the <code class="reqn">K</code> function. It may be useful for
very large patterns of points.
</p>
<p>Whereas <code><a href="#topic+Kest">Kest</a></code> computes the distance between
each pair of points analytically, this function discretises the
point pattern onto a rectangular pixel raster and applies
Fast Fourier Transform techniques to estimate <code class="reqn">K(t)</code>.
The hard work is done by the function <code><a href="#topic+Kmeasure">Kmeasure</a></code>.
</p>
<p>The result is an approximation whose accuracy depends on the
resolution of the pixel raster. The resolution is controlled
by the arguments <code>...</code>, or by setting the parameter <code>npixel</code> in 
<code>spatstat.options</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>the estimates of <code class="reqn">K(r)</code> for these values of <code class="reqn">r</code>
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
for a stationary Poisson process
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Ohser, J. (1983)
On estimators for the reduced second moment measure of
point processes. <em>Mathematische Operationsforschung und
Statistik, series Statistics</em>, <b>14</b>, 63 &ndash; 71.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kmeasure">Kmeasure</a></code>,
<code>spatstat.options</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pp &lt;- runifpoint(10000)
 
 Kpp &lt;- Kest.fft(pp, 0.01)
 plot(Kpp)
 
</code></pre>

<hr>
<h2 id='Kinhom'>Inhomogeneous K-function</h2><span id='topic+Kinhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous <code class="reqn">K</code> function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kinhom(X, lambda=NULL, ..., r = NULL, breaks = NULL,
    correction=c("border", "bord.modif", "isotropic", "translate"),
    renormalise=TRUE,
    normpower=1,
    update=TRUE,
    leaveoneout=TRUE,
    nlarge = 1000,
    lambda2=NULL, reciplambda=NULL, reciplambda2=NULL,
    diagonal=TRUE,
    sigma=NULL, varcov=NULL,
    ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kinhom_+3A_x">X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">K</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_...">...</code></td>
<td>

<p>Extra arguments. Ignored if <code>lambda</code> is present.
Passed to <code><a href="#topic+density.ppp">density.ppp</a></code> if <code>lambda</code> is omitted.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_renormalise">renormalise</code></td>
<td>

<p>Logical. Whether to renormalise the estimate. See Details.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_nlarge">nlarge</code></td>
<td>

<p>Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed, using a fast algorithm.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_lambda2">lambda2</code></td>
<td>

<p>Advanced use only.
Matrix containing estimates of the products
<code class="reqn">\lambda(x_i)\lambda(x_j)</code>
of the intensities at each pair of data points 
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>. 
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_reciplambda">reciplambda</code></td>
<td>

<p>Alternative to <code>lambda</code>.
Values of the estimated <em>reciprocal</em> <code class="reqn">1/\lambda</code>
of the intensity function.
Either a vector giving the reciprocal intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
reciprocal intensity values at all locations,
or a <code>function(x,y)</code> which can be evaluated to give the
reciprocal intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_reciplambda2">reciplambda2</code></td>
<td>

<p>Advanced use only. Alternative to <code>lambda2</code>.
A matrix giving values of the estimated <em>reciprocal products</em>
<code class="reqn">1/\lambda(x_i)\lambda(x_j)</code>
of the intensities at each pair of data points 
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>. 
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_diagonal">diagonal</code></td>
<td>

<p>Do not use this argument.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_sigma">sigma</code>, <code id="Kinhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="Kinhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes a generalisation of the <code class="reqn">K</code> function
for inhomogeneous point patterns, proposed by
Baddeley, Moller and Waagepetersen (2000).
</p>
<p>The &ldquo;ordinary&rdquo; <code class="reqn">K</code> function
(variously known as the reduced second order moment function
and Ripley's <code class="reqn">K</code> function), is
described under <code><a href="#topic+Kest">Kest</a></code>. It is defined only
for stationary point processes.
</p>
<p>The inhomogeneous <code class="reqn">K</code> function
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
is a direct generalisation to nonstationary point processes.
Suppose <code class="reqn">x</code> is a point process with non-constant intensity
<code class="reqn">\lambda(u)</code> at each location <code class="reqn">u</code>.
Define <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> to be the expected
value, given that <code class="reqn">u</code> is a point of <code class="reqn">x</code>,
of the sum of all terms
<code class="reqn">1/\lambda(x_j)</code>
over all points <code class="reqn">x_j</code>
in the process separated from <code class="reqn">u</code> by a distance less than <code class="reqn">r</code>.
This reduces to the ordinary <code class="reqn">K</code> function if
<code class="reqn">\lambda()</code> is constant.
If <code class="reqn">x</code> is an inhomogeneous Poisson process with intensity
function <code class="reqn">\lambda(u)</code>, then
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r) = \pi r^2</code>.
</p>
<p>Given a point pattern dataset, the 
inhomogeneous <code class="reqn">K</code> function can be estimated
essentially by summing the values
<code class="reqn">1/(\lambda(x_i)\lambda(x_j))</code>
for all pairs of points <code class="reqn">x_i, x_j</code>
separated by a distance less than <code class="reqn">r</code>.
</p>
<p>This allows us to inspect a point pattern for evidence of 
interpoint interactions after allowing for spatial inhomogeneity
of the pattern. Values 
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r) &gt; \pi r^2</code>
are suggestive of clustering.
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>.
It may be either
</p>

<dl>
<dt>a numeric vector</dt><dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt><dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
</dd>
</dl>

<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code><a href="#topic+blur">blur</a></code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother,
as described in Baddeley, Moller
and Waagepetersen (2000).  The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>
<p>Edge corrections are used to correct bias in the estimation
of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}</code>.
Each edge-corrected estimate of
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> is
of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \widehat K_{\mbox{\scriptsize\rm inhom}}(r) = (1/A)
    \sum_i \sum_j \frac{1\{d_{ij} \le r\}
      e(x_i,x_j,r)}{\lambda(x_i)\lambda(x_j)}
  </code>
</p>

<p>where <code>A</code> is a constant denominator, 
<code class="reqn">d_{ij}</code> is the distance between points
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>, and
<code class="reqn">e(x_i,x_j,r)</code> is
an edge correction factor. For the &lsquo;border&rsquo; correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac{1(b_i &gt; r)}{\sum_j 1(b_j &gt; r)/\lambda(x_j)}
  </code>
</p>

<p>where <code class="reqn">b_i</code> is the distance from <code class="reqn">x_i</code>
to the boundary of the window. For the &lsquo;modified border&rsquo;
correction, 
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac{1(b_i &gt; r)}{\mbox{area}(W \ominus r)}
  </code>
</p>

<p>where <code class="reqn">W \ominus r</code> is the eroded window obtained
by trimming a margin of width <code class="reqn">r</code> from the border of the original
window.
For the &lsquo;translation&rsquo; correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac 1 {\mbox{area}(W \cap (W + (x_j - x_i)))}
  </code>
</p>

<p>and for the &lsquo;isotropic&rsquo; correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac 1 {\mbox{area}(W) g(x_i,x_j)}
  </code>
</p>

<p>where <code class="reqn">g(x_i,x_j)</code> is the fraction of the
circumference of the circle with centre <code class="reqn">x_i</code> and radius
<code class="reqn">||x_i - x_j||</code> which lies inside the window.
</p>
<p>If <code>renormalise=TRUE</code> (the default), then the estimates
described above 
are multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{area}(W)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1 (for consistency with
previous versions of <span class="pkg">spatstat</span>)
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>
<p>If the point pattern <code>X</code> contains more than about 1000 points,
the isotropic and translation edge corrections can be computationally
prohibitive. The computations for the border method are much faster,
and are statistically efficient when there are large numbers of
points. Accordingly, if the number of points in <code>X</code> exceeds
the threshold <code>nlarge</code>, then only the border correction will be
computed. Setting <code>nlarge=Inf</code> or <code>correction="best"</code>
will prevent this from happening.
Setting <code>nlarge=0</code> is equivalent to selecting only the border
correction with <code>correction="border"</code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kinhom</code>; see <code><a href="#topic+pcf">pcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing at least the following columns,
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> has been estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values of <code class="reqn">\pi r^2</code>,
the theoretical value of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
for an inhomogeneous Poisson process
</p>
</td></tr>
</table>
<p>and containing additional columns
according to the choice specified in the <code>correction</code>
argument. The additional columns are named
<code>border</code>, <code>trans</code> and <code>iso</code>
and give the estimated values of 
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
using the border correction, translation correction,
and Ripley isotropic correction, respectively.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.,
Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329&ndash;350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # inhomogeneous pattern of maples
  X &lt;- unmark(split(lansing)$maple)
  

  if(require("spatstat.model")) {
    # (1) intensity function estimated by model-fitting
    # Fit spatial trend: polynomial in x and y coordinates
    fit &lt;- ppm(X, ~ polynom(x,y,2), Poisson())
    # (a) predict intensity values at points themselves,
    #     obtaining a vector of lambda values
    lambda &lt;- predict(fit, locations=X, type="trend")
    # inhomogeneous K function
    Ki &lt;- Kinhom(X, lambda)
    plot(Ki)
    # (b) predict intensity at all locations,
    #     obtaining a pixel image
    lambda &lt;- predict(fit, type="trend")
    Ki &lt;- Kinhom(X, lambda)
    plot(Ki)
  }

  # (2) intensity function estimated by heavy smoothing
  Ki &lt;- Kinhom(X, sigma=0.1)
  plot(Ki)

  # (3) simulated data: known intensity function
  lamfun &lt;- function(x,y) { 50 + 100 * x }
  # inhomogeneous Poisson process
  Y &lt;- rpoispp(lamfun, 150, owin())
  # inhomogeneous K function
  Ki &lt;- Kinhom(Y, lamfun)
  plot(Ki)

  # How to make simulation envelopes:
  #      Example shows method (2)
  if(interactive()) {
    smo &lt;- density.ppp(X, sigma=0.1)
    Ken &lt;- envelope(X, Kinhom, nsim=99,
                    simulate=expression(rpoispp(smo)),
                    sigma=0.1, correction="trans")
    plot(Ken)
  }
</code></pre>

<hr>
<h2 id='km.rs'>Kaplan-Meier and Reduced Sample Estimator using Histograms</h2><span id='topic+km.rs'></span>

<h3>Description</h3>

<p>Compute the Kaplan-Meier and Reduced Sample estimators of a
survival time distribution function, using histogram techniques
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  km.rs(o, cc, d, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="km.rs_+3A_o">o</code></td>
<td>
<p>vector of observed survival times
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_cc">cc</code></td>
<td>
<p>vector of censoring times
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_d">d</code></td>
<td>
<p>vector of non-censoring indicators
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_breaks">breaks</code></td>
<td>
<p>Vector of breakpoints to be used to form histograms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
Kaplan-Meier estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>The arguments to this function are 
vectors <code>o</code>, <code>cc</code>, <code>d</code>
of observed values of <code class="reqn">\tilde T_i</code>, <code class="reqn">C_i</code>
and <code class="reqn">D_i</code> respectively.
The function computes histograms and forms the reduced-sample
and Kaplan-Meier estimates of  <code class="reqn">F(t)</code> by
invoking the functions <code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
and <code><a href="#topic+reduced.sample">reduced.sample</a></code>.
This is efficient if the lengths of <code>o</code>, <code>cc</code>, <code>d</code>
(i.e. the number of observations) is large.
</p>
<p>The vectors <code>km</code> and <code>hazard</code> returned by <code>kaplan.meier</code>
are (histogram approximations to) the Kaplan-Meier estimator
of <code class="reqn">F(t)</code> and its hazard rate <code class="reqn">\lambda(t)</code>.
Specifically, <code>km[k]</code> is an estimate of
<code>F(breaks[k+1])</code>, and <code>lambda[k]</code> is an estimate of
the average of <code class="reqn">\lambda(t)</code> over the interval
<code>(breaks[k],breaks[k+1])</code>. This approximation is exact only if the
survival times are discrete and the 
histogram breaks are fine enough to ensure that each interval
<code>(breaks[k],breaks[k+1])</code> contains only one possible value of
the survival time. 
</p>
<p>The vector <code>rs</code> is the reduced-sample estimator,
<code>rs[k]</code> being the reduced sample estimate of <code>F(breaks[k+1])</code>.
This value is exact, i.e. the use of histograms does not introduce any
approximation error in the reduced-sample estimator.
</p>


<h3>Value</h3>

<p>A list with five elements
</p>
<table>
<tr><td><code>rs</code></td>
<td>
<p>Reduced-sample estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>Kaplan-Meier estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>corresponding Nelson-Aalen estimate of the
hazard rate <code class="reqn">\lambda(t)</code>
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>values of <code class="reqn">t</code> for which <code class="reqn">F(t)</code> is estimated
</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>the breakpoints vector
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
</p>

<hr>
<h2 id='Kmark'>Mark-Weighted K Function</h2><span id='topic+Kmark'></span><span id='topic+markcorrint'></span>

<h3>Description</h3>

<p>Estimates the mark-weighted <code class="reqn">K</code> function
of a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kmark(X, f = NULL, r = NULL,
        correction = c("isotropic", "Ripley", "translate"), ...,
        f1 = NULL, normalise = TRUE, returnL = FALSE, fargs = NULL)

  markcorrint(X, f = NULL, r = NULL,
              correction = c("isotropic", "Ripley", "translate"), ...,
              f1 = NULL, normalise = TRUE, returnL = FALSE, fargs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmark_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_f">f</code></td>
<td>
<p>Optional. Test function <code class="reqn">f</code> used in the definition of the
mark correlation function. An <span class="rlang"><b>R</b></span> function with at least two
arguments. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark correlation function 
<code class="reqn">k_f(r)</code> should be evaluated.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_f1">f1</code></td>
<td>

<p>An alternative to <code>f</code>. If this argument is given,
then <code class="reqn">f</code> is assumed to take the form
<code class="reqn">f(u,v)=f_1(u)f_1(v)</code>.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_normalise">normalise</code></td>
<td>

<p>If <code>normalise=FALSE</code>,
compute only the numerator of the expression for the
mark correlation.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_returnl">returnL</code></td>
<td>

<p>Compute the analogue of the K-function if <code>returnL=FALSE</code>
or the analogue of the L-function if <code>returnL=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="Kmark_+3A_fargs">fargs</code></td>
<td>

<p>Optional. A list of extra arguments to be passed to the function
<code>f</code> or <code>f1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>Kmark</code> and <code>markcorrint</code> are identical.
(Eventually <code>markcorrint</code> will be deprecated.)
</p>
<p>The <em>mark-weighted <code class="reqn">K</code> function</em> <code class="reqn">K_f(r)</code>
of a marked point process (Penttinen et al, 1992)
is a generalisation of Ripley's <code class="reqn">K</code> function, in which the contribution
from each pair of points is weighted by a function of their marks.
If the marks of the two points are <code class="reqn">m_1, m_2</code> then
the weight is proportional to <code class="reqn">f(m_1, m_2)</code> where
<code class="reqn">f</code> is a specified <em>test function</em>.
</p>
<p>The mark-weighted <code class="reqn">K</code> function is defined so that
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda K_f(r) = \frac{C_f(r)}{E[ f(M_1, M_2) ]}
  </code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">
    C_f(r) = 
    E \left[
    \sum_{x \in X}
    f(m(u), m(x))
    1{0 &lt; ||u - x|| \le r}
    \;  \big| \;
    u \in X
    \right]
  </code>
</p>

<p>for any spatial location <code class="reqn">u</code> taken to be a typical point of
the point process <code class="reqn">X</code>. Here <code class="reqn">||u-x||</code> is the
euclidean distance between <code class="reqn">u</code> and <code class="reqn">x</code>, so that the sum
is taken over all random points <code class="reqn">x</code> that lie within a distance
<code class="reqn">r</code> of the point <code class="reqn">u</code>. The function <code class="reqn">C_f(r)</code> is
the <em>unnormalised</em> mark-weighted <code class="reqn">K</code> function.
To obtain <code class="reqn">K_f(r)</code> we standardise <code class="reqn">C_f(r)</code>
by dividing by <code class="reqn">E[f(M_1,M_2)]</code>, the expected value of
<code class="reqn">f(M_1,M_2)</code> when <code class="reqn">M_1</code> and <code class="reqn">M_2</code> are
independent random marks with the same distribution as the marks in
the point process. 
</p>
<p>Under the hypothesis of random labelling, the
mark-weighted <code class="reqn">K</code> function 
is equal to Ripley's <code class="reqn">K</code> function,
<code class="reqn">K_f(r) = K(r)</code>.
</p>
<p>The mark-weighted <code class="reqn">K</code> function is sometimes called the 
<em>mark correlation integral</em> because it is related to the
mark correlation function <code class="reqn">k_f(r)</code>
and the pair correlation function <code class="reqn">g(r)</code> by
</p>
<p style="text-align: center;"><code class="reqn">
    K_f(r) = 2 \pi \int_0^r s k_f(s) \, g(s) \, {\rm d}s
  </code>
</p>

<p>See <code><a href="#topic+markcorr">markcorr</a></code> for a definition of the
mark correlation function.
</p>
<p>Given a marked point pattern <code>X</code>,
this command computes edge-corrected estimates
of the mark-weighted <code class="reqn">K</code> function.
If <code>returnL=FALSE</code> then the estimated
function <code class="reqn">K_f(r)</code> is returned;
otherwise the function
</p>
<p style="text-align: center;"><code class="reqn">
    L_f(r) = \sqrt{K_f(r)/\pi}
  </code>
</p>

<p>is returned.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark correlation integral <code class="reqn">K_f(r)</code>
has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">K_f(r)</code>
when the marks attached to different points are independent,
namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the mark-weighted <code class="reqn">K</code> function <code class="reqn">K_f(r)</code>
obtained by the edge corrections named (if <code>returnL=FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Penttinen, A., Stoyan, D. and Henttonen, H. M. (1992)
Marked point processes in forest statistics.
<em>Forest Science</em> <b>38</b> (1992) 806-824.
</p>
<p>Illian, J., Penttinen, A., Stoyan, H. and Stoyan, D. (2008)
<em>Statistical analysis and modelling of spatial point patterns</em>.
Chichester: John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markcorr">markcorr</a></code> to estimate the mark correlation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # CONTINUOUS-VALUED MARKS:
    # (1) Spruces
    # marks represent tree diameter
    # mark correlation function
    ms &lt;- Kmark(spruces)
    plot(ms)

    # (2) simulated data with independent marks
    X &lt;- rpoispp(100)
    X &lt;- X %mark% runif(npoints(X))
    Xc &lt;- Kmark(X)
    plot(Xc)
    
    # MULTITYPE DATA:
    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    M &lt;- Kmark(amacrine, function(m1,m2) {m1==m2},
                         correction="translate")
    plot(M)
</code></pre>

<hr>
<h2 id='Kmeasure'>Reduced Second Moment Measure</h2><span id='topic+Kmeasure'></span>

<h3>Description</h3>

<p>Estimates the reduced second moment measure <code class="reqn">\kappa</code> 
from a point pattern in a window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kmeasure(X, sigma, edge=TRUE, ..., varcov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmeasure_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">\kappa</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Kmeasure_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma</code> of the Gaussian
smoothing kernel. Incompatible with <code>varcov</code>.
</p>
</td></tr>
<tr><td><code id="Kmeasure_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether an edge correction
should be applied.
</p>
</td></tr>
<tr><td><code id="Kmeasure_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling
the pixel resolution.
</p>
</td></tr>
<tr><td><code id="Kmeasure_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of the Gaussian smoothing kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a point pattern dataset, 
this command computes an estimate of the reduced second moment
measure <code class="reqn">\kappa</code> of the point process.
The result is a pixel image whose pixel values are estimates of
the density of the reduced second moment measure. 
</p>
<p>The reduced second moment measure <code class="reqn">\kappa</code>
can be regarded as a generalisation of the more familiar
<code class="reqn">K</code>-function.
An estimate of <code class="reqn">\kappa</code> derived from a spatial point
pattern dataset can be useful in exploratory data analysis.
Its advantage over the <code class="reqn">K</code>-function is that it is also sensitive
to anisotropy and directional effects. 
</p>
<p>In a nutshell, the command <code>Kmeasure</code> computes a smoothed version
of the <em>Fry plot</em>. 
As explained under <code><a href="#topic+fryplot">fryplot</a></code>, the Fry plot is a scatterplot of the
vectors joining all pairs of points in the pattern.
The reduced second moment measure is (essentially) defined as
the average of the Fry plot over different realisations of the point
process. The command <code>Kmeasure</code> effectively smooths the Fry plot
of a dataset to obtain an estimate of the reduced second moment measure.
</p>
<p>In formal terms, the reduced second moment measure <code class="reqn">\kappa</code>
of a stationary point process <code class="reqn">X</code> is a measure defined on the
two-dimensional plane such that,
for a &lsquo;typical&rsquo; point <code class="reqn">x</code> of the process, 
the expected number of other points <code class="reqn">y</code> of the process
such that the vector <code class="reqn">y - x</code> lies in a region <code class="reqn">A</code>,
equals <code class="reqn">\lambda \kappa(A)</code>.
Here <code class="reqn">\lambda</code>
is the intensity of the process,
i.e. the expected number of points of <code class="reqn">X</code> per unit area.
</p>
<p>The <code class="reqn">K</code>-function is a special case. The function value <code class="reqn">K(t)</code> is
the value of the reduced second moment measure
for the disc of radius <code class="reqn">t</code> centred at the origin; that is,
<code class="reqn">K(t) = \kappa(b(0,t))</code>.
</p>
<p>The command <code>Kmeasure</code> computes an estimate of <code class="reqn">\kappa</code>
from a point pattern dataset <code>X</code>,
which is assumed to be a realisation of a stationary point process,
observed inside a known, bounded window. Marks are ignored.
</p>
<p>The algorithm approximates the point pattern and its window by binary pixel
images, introduces a Gaussian smoothing kernel
and uses the Fast Fourier Transform <code><a href="stats.html#topic+fft">fft</a></code>
to form a density estimate of <code class="reqn">\kappa</code>. The calculation
corresponds to the edge correction known as the &ldquo;translation
correction&rdquo;.
</p>
<p>The Gaussian smoothing kernel may be specified by either of the
arguments <code>sigma</code> or <code>varcov</code>. If <code>sigma</code> is a single
number, this specifies an isotropic Gaussian kernel
with standard deviation <code>sigma</code> on each coordinate axis.
If <code>sigma</code> is a vector of two numbers, this specifies a Gaussian
kernel with standard deviation <code>sigma[1]</code> on the <code class="reqn">x</code> axis,
standard deviation <code>sigma[2]</code> on the <code class="reqn">y</code> axis, and zero
correlation between the <code class="reqn">x</code> and <code class="reqn">y</code> axes. If <code>varcov</code> is
given, this specifies the variance-covariance matrix of the
Gaussian kernel. There do not seem to be any well-established rules
for selecting the smoothing kernel in this context.
</p>
<p>The density estimate of <code class="reqn">\kappa</code>
is returned in the form of a real-valued pixel image.
Pixel values are estimates of the normalised
second moment density at the centre of the pixel.
(The uniform Poisson process would have values identically equal to
<code class="reqn">1</code>.)
The image <code>x</code> and <code>y</code>
coordinates are on the same scale as vector displacements in the
original point pattern window. The point <code>x=0, y=0</code> corresponds
to the &lsquo;typical point&rsquo;.
A peak in the image near <code>(0,0)</code> suggests clustering;
a dip in the image near <code>(0,0)</code> suggests inhibition;
peaks or dips at other positions suggest possible periodicity.
</p>
<p>If desired, the value of <code class="reqn">\kappa(A)</code> for a region
<code class="reqn">A</code> can be estimated by computing the integral of the pixel image
over the domain <code class="reqn">A</code>, i.e.\ summing the pixel values and
multiplying by pixel area, using <code>integral.im</code>.
One possible application is to compute anisotropic counterparts of the
<code class="reqn">K</code>-function (in which the disc of radius <code class="reqn">t</code> is replaced
by another shape). See Examples.
</p>


<h3>Value</h3>

<p>A real-valued pixel image (an object of class <code>"im"</code>,
see <code>im.object</code>) whose pixel values are estimates
of the density of the reduced second moment measure
at each location.
</p>


<h3>Warning</h3>

<p>Some writers use the term <em>reduced second moment measure</em>
when they mean the <code class="reqn">K</code>-function. This has caused
confusion. 
</p>
<p>As originally defined, the
reduced second moment measure is a measure, obtained by modifying
the second moment measure, while the <code class="reqn">K</code>-function is a function
obtained by evaluating this measure for discs of increasing radius.
In <span class="pkg">spatstat</span>, the <code class="reqn">K</code>-function is computed by
<code><a href="#topic+Kest">Kest</a></code> and the reduced second moment measure is computed
by <code>Kmeasure</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+fryplot">fryplot</a></code>,
<code>spatstat.options</code>,
<code>integral.im</code>,
<code>im.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(Kmeasure(cells, 0.05))
 # shows pronounced dip around origin consistent with strong inhibition
 plot(Kmeasure(redwood, 0.03), col=grey(seq(1,0,length=32)))
 # shows peaks at several places, reflecting clustering and ?periodicity
 M &lt;- Kmeasure(cells, 0.05)
 # evaluate measure on a sector
 W &lt;- Window(M)
 ang &lt;- as.im(atan2, W)
 rad &lt;- as.im(function(x,y){sqrt(x^2+y^2)}, W)
 sector &lt;- solutionset(ang &gt; 0 &amp; ang &lt; 1 &amp; rad &lt; 0.6)
 integral.im(M[sector, drop=FALSE])
</code></pre>

<hr>
<h2 id='Kmulti'>
Marked K-Function
</h2><span id='topic+Kmulti'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the multitype <code class="reqn">K</code> function
which counts the expected number of points of subset <code class="reqn">J</code>
within a given distance from a typical point in subset <code>I</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmulti(X, I, J, r=NULL, breaks=NULL, correction, ..., rmax=NULL, ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmulti_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the multitype <code class="reqn">K</code> function
<code class="reqn">K_{IJ}(r)</code> will be computed.
It must be a marked point pattern.
See under Details.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_i">I</code></td>
<td>
<p>Subset index specifying the points of <code>X</code>
from which distances are measured. See Details.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_j">J</code></td>
<td>
<p>Subset index specifying the points in <code>X</code> to which
distances are measured. See Details.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the multitype <code class="reqn">K</code> function
<code class="reqn">K_{IJ}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
If necessary, specify <code>rmax</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"periodic"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Kmulti</code>
generalises <code><a href="#topic+Kest">Kest</a></code> (for unmarked point
patterns) and <code><a href="#topic+Kdot">Kdot</a></code> and <code><a href="#topic+Kcross">Kcross</a></code> (for
multitype point patterns) to arbitrary marked point patterns.
</p>
<p>Suppose <code class="reqn">X_I</code>, <code class="reqn">X_J</code> are subsets, possibly
overlapping, of a marked point process.
The multitype <code class="reqn">K</code> function 
is defined so that
<code class="reqn">\lambda_J K_{IJ}(r)</code> equals the expected number of
additional random points of <code class="reqn">X_J</code> 
within a distance <code class="reqn">r</code> of a
typical point of  <code class="reqn">X_I</code>.
Here <code class="reqn">\lambda_J</code>
is the intensity of <code class="reqn">X_J</code> 
i.e. the expected number of points of <code class="reqn">X_J</code> per unit area.
The function <code class="reqn">K_{IJ}</code> is determined by the 
second order moment properties of <code class="reqn">X</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
</p>
<p>The arguments <code>I</code> and <code>J</code> specify two subsets of the
point pattern. They may be any type of subset indices, for example,
logical vectors of length equal to <code>npoints(X)</code>,
or integer vectors with entries in the range 1 to
<code>npoints(X)</code>, or negative integer vectors.
</p>
<p>Alternatively, <code>I</code> and <code>J</code> may be <b>functions</b>
that will be applied to the point pattern <code>X</code> to obtain
index vectors. If <code>I</code> is a function, then evaluating
<code>I(X)</code> should yield a valid subset index. This option
is useful when generating simulation envelopes using
<code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{IJ}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. 
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>.
The edge corrections implemented here are
</p>

<dl>
<dt>border</dt><dd><p>the border method or
&ldquo;reduced sample&rdquo; estimator (see Ripley, 1988). This is
the least efficient (statistically) and the fastest to compute.
It can be computed for a window of arbitrary shape.
</p>
</dd>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is currently implemented only for rectangular and polygonal windows.
</p>
</dd>
<dt>translate</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries.
</p>
</dd>
</dl>

<p>The pair correlation function <code><a href="#topic+pcf">pcf</a></code> can also be applied to the
result of <code>Kmulti</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{IJ}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{IJ}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{IJ}(r)</code>
obtained by the edge corrections named.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K(r)</code>. 
</p>


<h3>Warnings</h3>

<p>The function <code class="reqn">K_{IJ}</code> is not necessarily differentiable.
</p>
<p>The border correction (reduced sample) estimator of
<code class="reqn">K_{IJ}</code> used here is pointwise approximately 
unbiased, but need not be a nondecreasing function of <code class="reqn">r</code>,
while the true  <code class="reqn">K_{IJ}</code> must be nondecreasing.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 1983.
</p>
<p>Diggle, P. J. (1986).
Displaced amacrine cells in the retina of a
rabbit : analysis of a bivariate spatial point pattern. 
<em>J. Neurosci. Meth.</em> <b>18</b>, 115&ndash;125.
</p>
<p>Harkness, R.D and Isham, V. (1983)
A bivariate spatial point pattern of ants' nests.
<em>Applied Statistics</em> <b>32</b>, 293&ndash;303
</p>
<p>Lotwick, H. W. and Silverman, B. W. (1982).
Methods for analysing spatial processes of several types of points.
<em>J. Royal Statist. Soc. Ser. B</em> <b>44</b>, 406&ndash;413.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J.
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag, 1995.
</p>
<p>Van Lieshout, M.N.M. and Baddeley, A.J. (1999)
Indices of dependence between types in multivariate point patterns.
<em>Scandinavian Journal of Statistics</em> <b>26</b>, 511&ndash;532.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Longleaf Pine data: marks represent diameter
    trees &lt;- longleaf
    
    K &lt;- Kmulti(trees, marks(trees) &lt;= 15, marks(trees) &gt;= 25)
    plot(K)
    # functions determining subsets
    f1 &lt;- function(X) { marks(X) &lt;= 15 }
    f2 &lt;- function(X) { marks(X) &gt;= 15 }
    K &lt;- Kmulti(trees, f1, f2)
   
</code></pre>

<hr>
<h2 id='Kmulti.inhom'>
Inhomogeneous Marked K-Function
</h2><span id='topic+Kmulti.inhom'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the inhomogeneous version of the multitype <code class="reqn">K</code> function
which counts the expected number of points of subset <code class="reqn">J</code>
within a given distance from a typical point in subset <code>I</code>,
adjusted for spatially varying intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kmulti.inhom(X, I, J, lambdaI=NULL, lambdaJ=NULL,
          ...,
          r=NULL, breaks=NULL,
          correction=c("border", "isotropic", "Ripley", "translate"),
          lambdaIJ=NULL,
          sigma=NULL, varcov=NULL,
          lambdaX=NULL, update=TRUE, leaveoneout=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmulti.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous multitype <code class="reqn">K</code> function
<code class="reqn">K_{IJ}(r)</code> will be computed.
It must be a marked point pattern.
See under Details.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_i">I</code></td>
<td>
<p>Subset index specifying the points of <code>X</code>
from which distances are measured. See Details.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_j">J</code></td>
<td>
<p>Subset index specifying the points in <code>X</code> to which
distances are measured. See Details.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process <code>X[I]</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X[I]</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the estimated intensity of the sub-process <code>X[J]</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X[J]</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the multitype <code class="reqn">K</code> function
<code class="reqn">K_{IJ}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_lambdaij">lambdaIJ</code></td>
<td>

<p>Optional. A matrix containing estimates of
the product of the intensities <code>lambdaI</code> and <code>lambdaJ</code>
for each pair of points, the first point belonging to subset
<code>I</code> and the second point to subset <code>J</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_sigma">sigma</code>, <code id="Kmulti.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_lambdax">lambdaX</code></td>
<td>

<p>Optional. Values of the intensity for all points of <code>X</code>.
Either a pixel image (object of class <code>"im"</code>),
a numeric vector containing the intensity values
at each of the points in <code>X</code>,
a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>),
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
If present, this argument overrides both <code>lambdaI</code> and
<code>lambdaJ</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when
<code>lambdaI</code>, <code>lambdaJ</code> or <code>lambdaX</code>
is a fitted point process model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Kmulti.inhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Kmulti.inhom</code>
is the counterpart, for spatially-inhomogeneous marked point patterns,
of the multitype <code class="reqn">K</code> function <code><a href="#topic+Kmulti">Kmulti</a></code>.
</p>
<p>Suppose <code class="reqn">X</code> is a marked point process, with marks of any kind.
Suppose <code class="reqn">X_I</code>, <code class="reqn">X_J</code> are two sub-processes, possibly
overlapping. Typically <code class="reqn">X_I</code> would consist of those points
of <code class="reqn">X</code> whose marks lie in a specified range of mark values,
and similarly for <code class="reqn">X_J</code>. Suppose that
<code class="reqn">\lambda_I(u)</code>, <code class="reqn">\lambda_J(u)</code> are the
spatially-varying intensity functions of <code class="reqn">X_I</code> and
<code class="reqn">X_J</code> respectively. Consider all the pairs of points
<code class="reqn">(u,v)</code> in the point process <code class="reqn">X</code> such that the first point
<code class="reqn">u</code> belongs to <code class="reqn">X_I</code>, the second point <code class="reqn">v</code>
belongs to <code class="reqn">X_J</code>, and the distance between <code class="reqn">u</code> and <code class="reqn">v</code>
is less than a specified distance <code class="reqn">r</code>. Give this pair <code class="reqn">(u,v)</code>
the numerical weight
<code class="reqn">1/(\lambda_I(u)\lambda_J(u))</code>.
Calculate the sum of these weights over all pairs of points as
described. This sum (after appropriate edge-correction and
normalisation) is the estimated inhomogeneous multitype <code class="reqn">K</code> function.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
</p>
<p>The arguments <code>I</code> and <code>J</code> specify two subsets of the
point pattern. They may be any type of subset indices, for example,
logical vectors of length equal to <code>npoints(X)</code>,
or integer vectors with entries in the range 1 to
<code>npoints(X)</code>, or negative integer vectors.
</p>
<p>Alternatively, <code>I</code> and <code>J</code> may be <b>functions</b>
that will be applied to the point pattern <code>X</code> to obtain
index vectors. If <code>I</code> is a function, then evaluating
<code>I(X)</code> should yield a valid subset index. This option
is useful when generating simulation envelopes using
<code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>The argument <code>lambdaI</code> supplies the values
of the intensity of the sub-process identified by index <code>I</code>.
It may be either
</p>

<dl>
<dt>a pixel image</dt><dd><p>(object of class <code>"im"</code>) which
gives the values of the intensity of <code>X[I]</code>
at all locations in the window containing <code>X</code>;
</p>
</dd>
<dt>a numeric vector</dt><dd><p>containing the values of the
intensity of <code>X[I]</code> evaluated only
at the data points of <code>X[I]</code>. The length of this vector
must equal the number of points in <code>X[I]</code>.
</p>
</dd>
<dt>a function</dt><dd>
<p>of the form <code>function(x,y)</code>
which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>a fitted point process model</dt><dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambdaI</code> is omitted then it will be estimated
using a leave-one-out kernel smoother. 
</p>
</dd>
</dl>

<p>If <code>lambdaI</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother, as described in Baddeley,
Moller 
and Waagepetersen (2000).  The estimate of <code>lambdaI</code> for a given
point is computed by removing the point from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point in question. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>
<p>Similarly <code>lambdaJ</code> supplies the values
of the intensity of the sub-process identified by index <code>J</code>.
</p>
<p>Alternatively if the argument <code>lambdaX</code> is given, then it specifies
the intensity values for all points of <code>X</code>, and the
arguments <code>lambdaI</code>, <code>lambdaJ</code> will be ignored.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{IJ}(r)</code> should be evaluated. 
It is also used to determine the breakpoints
(in the sense of <code><a href="graphics.html#topic+hist">hist</a></code>)
for the computation of histograms of distances.
</p>
<p>First-time users would be strongly advised not to specify <code>r</code>.
However, if it is specified, <code>r</code> must satisfy <code>r[1] = 0</code>, 
and <code>max(r)</code> must be larger than the radius of the largest disc 
contained in the window. 
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kinhom">Kinhom</a></code>.
The edge corrections implemented here are
</p>

<dl>
<dt>border</dt><dd><p>the border method or
&ldquo;reduced sample&rdquo; estimator (see Ripley, 1988). This is
the least efficient (statistically) and the fastest to compute.
It can be computed for a window of arbitrary shape.
</p>
</dd>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is currently implemented only for rectangular windows.
</p>
</dd>
<dt>translate</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries.
</p>
</dd>
</dl>

<p>The pair correlation function <code><a href="#topic+pcf">pcf</a></code> can also be applied to the
result of <code>Kmulti.inhom</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K_{IJ}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">K_{IJ}(r)</code>
for a marked Poisson process, namely <code class="reqn">\pi r^2</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">K_{IJ}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329&ndash;350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+Kdot.inhom">Kdot.inhom</a></code>,
<code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Finnish Pines data: marked by diameter and height
    plot(finpines, which.marks="height")
    II &lt;- (marks(finpines)$height &lt;= 2)
    JJ &lt;- (marks(finpines)$height &gt; 3)
    K &lt;- Kmulti.inhom(finpines, II, JJ)
    plot(K)
    # functions determining subsets
    f1 &lt;- function(X) { marks(X)$height &lt;= 2 }
    f2 &lt;- function(X) { marks(X)$height &gt; 3 }
    K &lt;- Kmulti.inhom(finpines, f1, f2)
</code></pre>

<hr>
<h2 id='Kscaled'>Locally Scaled K-function</h2><span id='topic+Kscaled'></span><span id='topic+Lscaled'></span>

<h3>Description</h3>

<p>Estimates the locally-rescaled <code class="reqn">K</code>-function of
a point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kscaled(X, lambda=NULL, ..., r = NULL, breaks = NULL,
    rmax = 2.5, 
    correction=c("border", "isotropic", "translate"),
    renormalise=FALSE, normpower=1,
    sigma=NULL, varcov=NULL)

  Lscaled(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kscaled_+3A_x">X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the locally scaled <code class="reqn">K</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location,
or a fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_...">...</code></td>
<td>

<p>Arguments passed from <code>Lscaled</code> to <code>Kscaled</code>
and from <code>Kscaled</code> to <code><a href="#topic+density.ppp">density.ppp</a></code>
if <code>lambda</code> is omitted.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_r">r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the locally scaled <code class="reqn">K</code> function
should be evaluated. (These are rescaled distances.)
Not normally given by the user; there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_rmax">rmax</code></td>
<td>

<p>maximum value of the argument <code class="reqn">r</code> that should be used.
(This is the rescaled distance).
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, 
<code>"isotropic"</code>, <code>"Ripley"</code>,
<code>"translate"</code>, <code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_renormalise">renormalise</code></td>
<td>

<p>Logical. Whether to renormalise the estimate. See Details.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="Kscaled_+3A_sigma">sigma</code>, <code id="Kscaled_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Kscaled</code> computes an estimate of the <code class="reqn">K</code> function
for a locally scaled point process.
<code>Lscaled</code> computes the corresponding <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>
<p>Locally scaled point processes are a class of models
for inhomogeneous point patterns, introduced by Hahn et al (2003).
They include inhomogeneous Poisson processes, and many other models.
</p>
<p>The template <code class="reqn">K</code> function of a locally-scaled process is a counterpart
of the &ldquo;ordinary&rdquo; Ripley <code class="reqn">K</code> function, in which
the distances between points of the process are measured
on a spatially-varying scale (such that the locally rescaled
process has unit intensity).
</p>
<p>The template <code class="reqn">K</code> function is an indicator of interaction
between the points. For an inhomogeneous Poisson process, the
theoretical template <code class="reqn">K</code> function is approximately equal
to <code class="reqn">K(r) = \pi r^2</code>.
Values <code class="reqn">K_{\rm scaled}(r) &gt; \pi r^2</code>
are suggestive of clustering.
</p>
<p><code>Kscaled</code> computes an estimate of the template <code class="reqn">K</code> function
and <code>Lscaled</code> computes the corresponding <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>
<p>The locally scaled interpoint distances are computed
using an approximation proposed by Hahn (2007). The Euclidean
distance between two points is multiplied by the average of the
square roots of the intensity values at the two points.
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>.
It may be either
</p>

<dl>
<dt>a numeric vector</dt><dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt><dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a function</dt><dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt><dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother.
</p>
</dd>
</dl>

<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code><a href="#topic+blur">blur</a></code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a &lsquo;leave-one-out&rsquo; kernel smoother,
as described in Baddeley, Moller
and Waagepetersen (2000).  The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="#topic+density.ppp">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="#topic+density.ppp">density.ppp</a></code> along with any extra arguments.
</p>
<p>If <code>renormalise=TRUE</code>, the estimated intensity <code>lambda</code>
is multiplied by <code class="reqn">c^(normpower/2)</code> before performing other calculations,
where <code class="reqn">c = area(W)/sum[i] (1/lambda(x[i]))</code>. This 
renormalisation has about the same effect as in <code><a href="#topic+Kinhom">Kinhom</a></code>,
reducing the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
</p>
<p>Edge corrections are used to correct bias in the estimation
of <code class="reqn">K_{\rm scaled}</code>. First the interpoint distances are 
rescaled, and then edge corrections are applied as in <code><a href="#topic+Kest">Kest</a></code>.
See <code><a href="#topic+Kest">Kest</a></code> for details of the edge corrections
and the options for the argument <code>correction</code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kscaled</code>; see <code><a href="#topic+pcf">pcf</a></code> and <code><a href="#topic+pcf.fv">pcf.fv</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing at least the following columns,
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the pair correlation function <code class="reqn">g(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values of <code class="reqn">\pi r^2</code>,
the theoretical value of <code class="reqn">K_{\rm scaled}(r)</code>
for an inhomogeneous Poisson process
</p>
</td></tr>
</table>
<p>and containing additional columns
according to the choice specified in the <code>correction</code>
argument. The additional columns are named
<code>border</code>, <code>trans</code> and <code>iso</code>
and give the estimated values of 
<code class="reqn">K_{\rm scaled}(r)</code>
using the border correction, translation correction,
and Ripley isotropic correction, respectively.
</p>


<h3>Author(s)</h3>

<p>Ute Hahn,
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.,
Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329&ndash;350.
</p>
<p>Hahn, U. (2007)
<em>Global and Local Scaling in the
Statistics of Spatial Point Processes</em>. Habilitationsschrift,
Universitaet Augsburg.
</p>
<p>Hahn, U., Jensen, E.B.V., van Lieshout, M.N.M. and Nielsen, L.S. (2003)
Inhomogeneous spatial point processes by location-dependent scaling.
<em>Advances in Applied Probability</em> <b>35</b>, 319&ndash;336.
</p>
<p>Prokesova, M.,
Hahn, U. and Vedel Jensen, E.B. (2006)
Statistics for locally scaled point patterns.
In A. Baddeley, P. Gregori, J. Mateu, R. Stoica and D. Stoyan (eds.)
<em>Case Studies in Spatial Point Pattern Modelling</em>.
Lecture Notes in Statistics 185. New York: Springer Verlag.
Pages 99&ndash;123.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- unmark(bronzefilter)
  K &lt;- Kscaled(X)
  if(require("spatstat.model")) {
    fit &lt;- ppm(X, ~x)
    lam &lt;- predict(fit)
    K &lt;- Kscaled(X, lam)
  }
</code></pre>

<hr>
<h2 id='Ksector'>Sector K-function</h2><span id='topic+Ksector'></span>

<h3>Description</h3>

<p>A directional counterpart of Ripley's <code class="reqn">K</code> function,
in which pairs of points are counted only when the
vector joining the pair happens to
lie in a particular range of angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ksector(X, begin = 0, end = 360, ...,
        units = c("degrees", "radians"), 
        r = NULL, breaks = NULL,
        correction = c("border", "isotropic", "Ripley", "translate"),
        domain=NULL, ratio = FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ksector_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">K(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_begin">begin</code>, <code id="Ksector_+3A_end">end</code></td>
<td>

<p>Numeric values giving the range of angles inside which
points will be counted. Angles are measured in degrees
(if <code>units="degrees"</code>, the default) or radians
(if <code>units="radians"</code>) anti-clockwise from the positive <code class="reqn">x</code>-axis.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Ksector_+3A_units">units</code></td>
<td>

<p>Units in which the angles <code>begin</code> and <code>end</code> are expressed.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">K(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_correction">correction</code></td>
<td>

<p>Optional. A character vector containing any selection of the
options <code>"none"</code>, <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"none"</code>, <code>"good"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_domain">domain</code></td>
<td>

<p>Optional window. The first point <code class="reqn">x_i</code> of each pair of points
will be constrained to lie in <code>domain</code>.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Ksector_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports
and warnings.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a directional counterpart of Ripley's <code class="reqn">K</code> function
(see <code><a href="#topic+Kest">Kest</a></code>) in which, instead of counting all
pairs of points within a specified distance <code class="reqn">r</code>, we
count only the pairs <code class="reqn">(x_i, x_j)</code>
for which the vector <code class="reqn">x_j - x_i</code>
falls in a particular range of angles.
</p>
<p>This can be used to evaluate evidence for anisotropy
in the point pattern <code>X</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> containing the estimated
function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> K &lt;- Ksector(swedishpines, 0, 90)
 plot(K)
</code></pre>

<hr>
<h2 id='laslett'>
Laslett's Transform
</h2><span id='topic+laslett'></span>

<h3>Description</h3>

<p>Apply Laslett's Transform to a spatial region,
returning the original and transformed regions,
and the original and transformed positions of the lower tangent points.
This is a diagnostic for the Boolean model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laslett(X, ..., verbose = FALSE, plotit = TRUE, discretise = FALSE,
        type=c("lower", "upper", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laslett_+3A_x">X</code></td>
<td>

<p>Spatial region to be transformed.
A window (object of class <code>"owin"</code>) or a logical-valued pixel
image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="laslett_+3A_...">...</code></td>
<td>

<p>Graphics arguments to control the plot (passed to
<code><a href="#topic+plot.laslett">plot.laslett</a></code> when <code>plotit=TRUE</code>)
or arguments determining the pixel resolution
(passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>).
</p>
</td></tr>
<tr><td><code id="laslett_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="laslett_+3A_plotit">plotit</code></td>
<td>

<p>Logical value indicating whether to plot the result.
</p>
</td></tr>
<tr><td><code id="laslett_+3A_discretise">discretise</code></td>
<td>

<p>Logical value indicating whether polygonal windows should first be
converted to pixel masks before the Laslett transform is
computed. This should be set to <code>TRUE</code> for very complicated
polygons. 
</p>
</td></tr>
<tr><td><code id="laslett_+3A_type">type</code></td>
<td>

<p>Type of tangent points to be detected.
This also determines the direction of contraction in the
set transformation.
Default is <code>type="lower"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the lower tangent points of the spatial region <code>X</code>,
then applies Laslett's Transform to the space,
and records the transformed positions of the lower tangent points.
</p>
<p>Laslett's transform is a diagnostic for the Boolean Model.
A test of the Boolean model can be performed by applying a test of CSR
to the transformed tangent points. See the Examples.
</p>
<p>The rationale is that, if the region <code>X</code> was generated by a
Boolean model with convex grains, then the lower tangent points of
<code>X</code>, when subjected to Laslett's transform,
become a Poisson point process (Cressie, 1993, section 9.3.5;
Molchanov, 1997; Barbour and Schmidt, 2001).
</p>
<p>Intuitively, Laslett's transform is a way to account for the fact that
tangent points of <code>X</code> cannot occur <em>inside</em> <code>X</code>.
It treats the interior of <code>X</code> as empty space, and collapses
this empty space so that only the <em>exterior</em> of <code>X</code> remains.
In this collapsed space, the tangent points are completely random.
</p>
<p>Formally, Laslett's transform is a random (i.e. data-dependent)
spatial transformation which maps each spatial
location <code class="reqn">(x,y)</code> to a new location <code class="reqn">(x',y)</code> at the same height
<code class="reqn">y</code>. The transformation is defined so that <code class="reqn">x'</code>
is the total <em>uncovered</em> length of the line segment from <code class="reqn">(0,y)</code> to
<code class="reqn">(x,y)</code>, that is, the total length of the parts of this segment that
fall outside the region <code>X</code>.
</p>
<p>In more colourful terms, suppose we use an abacus to display a
pixellated version of <code>X</code>. Each wire of the abacus represents one
horizontal line in the pixel image. Each pixel lying <em>outside</em>
the region <code>X</code> is represented by a bead of the abacus; pixels
<em>inside</em> <code>X</code> are represented by the absence of a bead. Next
we find any beads which are lower tangent points of <code>X</code>, and
paint them green. Then Laslett's Transform is applied by pushing all
beads to the left, as far as possible. The final locations of all the
beads provide a new spatial region, inside which is the point pattern
of tangent points (marked by the green-painted beads). 
</p>
<p>If <code>plotit=TRUE</code> (the default), a before-and-after plot is
generated, showing the region <code>X</code> and the tangent points
before and after the transformation. This plot can also be generated
by calling <code>plot(a)</code> where <code>a</code> is the object returned by
the function <code>laslett</code>.
</p>
<p>If the argument <code>type</code> is given, then this determines the
type of tangents that will be detected, and also the direction of
contraction in Laslett's transform. The computation is performed
by first rotating <code>X</code>, applying Laslett's transform for lower
tangent points, then rotating back.
</p>
<p>There are separate algorithms for polygonal windows and
pixellated windows (binary masks). The polygonal algorithm may be slow
for very complicated polygons. If this happens, setting
<code>discretise=TRUE</code> will convert the polygonal window to a binary
mask and invoke the pixel raster algorithm.
</p>


<h3>Value</h3>

<p>A list, which also belongs to the class <code>"laslett"</code>
so that it can immediately be printed and plotted.
</p>
<p>The list elements are:
</p>

<dl>
<dt>oldX:</dt><dd><p>the original dataset <code>X</code>;</p>
</dd>
<dt>TanOld:</dt><dd><p>a point pattern, whose window is <code>Frame(X)</code>,
containing the lower tangent points of <code>X</code>;</p>
</dd>
<dt>TanNew:</dt><dd><p>a point pattern, whose window is the Laslett transform
of <code>Frame(X)</code>, and which contains the Laslett-transformed
positions of the tangent points;</p>
</dd>
<dt>Rect:</dt><dd><p>a rectangular window, which is the largest rectangle
lying inside the transformed set;</p>
</dd>
<dt>df:</dt><dd><p>a data frame giving the locations of the tangent points
before and after transformation. </p>
</dd>
<dt>type:</dt><dd><p>character string specifying the type of tangents.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kassel Hingee and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Barbour, A.D. and Schmidt, V. (2001)
On Laslett's Transform for the Boolean Model.
<em>Advances in Applied Probability</em> 
<b>33</b>(1), 1&ndash;5.
</p>
<p>Cressie, N.A.C. (1993)
<em>Statistics for spatial data</em>, second edition.
John Wiley and Sons.
</p>
<p>Molchanov, I. (1997)
<em>Statistics of the Boolean Model for Practitioners and Mathematicians</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.laslett">plot.laslett</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- laslett(heather$coarse)
transformedHeather &lt;- with(a, Window(TanNew))
plot(transformedHeather, invert=TRUE)

with(a, clarkevans.test(TanNew[Rect], correction="D", nsim=39))

X &lt;- discs(runifrect(15) %mark% 0.2, npoly=16)
b &lt;- laslett(X, type="left")
b
</code></pre>

<hr>
<h2 id='Lcross'>Multitype L-function (cross-type)</h2><span id='topic+Lcross'></span>

<h3>Description</h3>

<p>Calculates an estimate of the cross-type L-function
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Lcross(X, i, j, ..., from, to, correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross-type <code class="reqn">L</code> function
<code class="reqn">L_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Lcross_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Lcross_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Lcross_+3A_correction">correction</code>, <code id="Lcross_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+Kcross">Kcross</a></code>.
</p>
</td></tr>
<tr><td><code id="Lcross_+3A_from">from</code>, <code id="Lcross_+3A_to">to</code></td>
<td>

<p>An alternative way to specify <code>i</code> and <code>j</code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-type L-function is a transformation of the cross-type K-function,
</p>
<p style="text-align: center;"><code class="reqn">L_{ij}(r) = \sqrt{\frac{K_{ij}(r)}{\pi}}</code>
</p>

<p>where <code class="reqn">K_{ij}(r)</code> is the cross-type K-function
from type <code>i</code> to type <code>j</code>.
See <code><a href="#topic+Kcross">Kcross</a></code> for information
about the cross-type K-function.
</p>
<p>The command <code>Lcross</code> first calls
<code><a href="#topic+Kcross">Kcross</a></code> to compute the estimate of the cross-type K-function,
and then applies the square root transformation.
</p>
<p>For a marked point pattern in which the points of type <code>i</code>
are independent of the points of type <code>j</code>,
the theoretical value of the L-function is
<code class="reqn">L_{ij}(r) = r</code>.
The square root also has the effect of stabilising
the variance of the estimator, so that <code class="reqn">L_{ij}</code> is more appropriate
for use in simulation envelopes and hypothesis tests.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L_{ij}</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">L_{ij}(r) = r</code>
for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L_{ij}</code> obtained by the edge corrections
named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Ldot">Ldot</a></code>,
<code><a href="#topic+Lest">Lest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> L &lt;- Lcross(amacrine, "off", "on")
 plot(L)
</code></pre>

<hr>
<h2 id='Lcross.inhom'>
Inhomogeneous Cross Type L Function
</h2><span id='topic+Lcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the cross-type <code class="reqn">L</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lcross.inhom(X, i, j, ..., correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous cross type <code class="reqn">L</code> function
<code class="reqn">L_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Lcross.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Lcross.inhom_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Lcross.inhom_+3A_correction">correction</code>, <code id="Lcross.inhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the function <code><a href="#topic+Lcross">Lcross</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Linhom">Linhom</a></code>.
</p>
<p>All the arguments are passed to <code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code>, which 
estimates the inhomogeneous multitype K function
<code class="reqn">K_{ij}(r)</code> for the point pattern.
The resulting values are then
transformed by taking <code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">L_{ij}(r)</code>
for a marked Poisson process, identically equal to <code>r</code>
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L_{ij}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are always interpreted as
levels of the factor <code>X$marks</code>. They are converted to character
strings if they are not already character strings.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Moller, J. and Waagepetersen, R.
Statistical Inference and Simulation for Spatial Point Processes
Chapman and Hall/CRC
Boca Raton, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lcross">Lcross</a></code>,
<code><a href="#topic+Linhom">Linhom</a></code>,
<code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Lansing Woods data
    woods &lt;- lansing
    
    ma &lt;- split(woods)$maple
    wh &lt;- split(woods)$whiteoak

    # method (1): estimate intensities by nonparametric smoothing
    lambdaM &lt;- density.ppp(ma, sigma=0.15, at="points")
    lambdaW &lt;- density.ppp(wh, sigma=0.15, at="points")
    L &lt;- Lcross.inhom(woods, "whiteoak", "maple", lambdaW, lambdaM)

    # method (2): fit parametric intensity model
    if(require("spatstat.model"))  {
      fit &lt;- ppm(woods ~marks * polynom(x,y,2))
      # evaluate fitted intensities at data points
      # (these are the intensities of the sub-processes of each type)
      inten &lt;- fitted(fit, dataonly=TRUE)
      # split according to types of points
      lambda &lt;- split(inten, marks(woods))
      L &lt;- Lcross.inhom(woods, "whiteoak", "maple",
                        lambda$whiteoak, lambda$maple)
    }

    # synthetic example: type A points have intensity 50,
    #                    type B points have intensity 100 * x
    lamB &lt;- as.im(function(x,y){50 + 100 * x}, owin())
    X &lt;- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
    L &lt;- Lcross.inhom(X, "A", "B",
        lambdaI=as.im(50, Window(X)), lambdaJ=lamB)
</code></pre>

<hr>
<h2 id='Ldot'>Multitype L-function (i-to-any)</h2><span id='topic+Ldot'></span>

<h3>Description</h3>

<p>Calculates an estimate of the multitype L-function
(from type <code>i</code> to any type)
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Ldot(X, i, ..., from, correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ldot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the dot-type <code class="reqn">L</code> function
<code class="reqn">L_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Ldot_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Ldot_+3A_correction">correction</code>, <code id="Ldot_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+Kdot">Kdot</a></code>.
</p>
</td></tr>
<tr><td><code id="Ldot_+3A_from">from</code></td>
<td>
<p>An alternative way to specify <code>i</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes 
</p>
<p style="text-align: center;"><code class="reqn">L_{i\bullet}(r) = \sqrt{\frac{K_{i\bullet}(r)}{\pi}}</code>
</p>

<p>where <code class="reqn">K_{i\bullet}(r)</code> is the multitype <code class="reqn">K</code>-function
from points of type <code>i</code> to points of any type.
See <code><a href="#topic+Kdot">Kdot</a></code> for information
about <code class="reqn">K_{i\bullet}(r)</code>.
</p>
<p>The command <code>Ldot</code> first calls
<code><a href="#topic+Kdot">Kdot</a></code> to compute the estimate of the <code>i</code>-to-any
<code class="reqn">K</code>-function, and then applies the square root transformation.
</p>
<p>For a marked Poisson point process,
the theoretical value of the L-function is
<code class="reqn">L_{i\bullet}(r) = r</code>.
The square root also has the effect of stabilising
the variance of the estimator, so that <code class="reqn">L_{i\bullet}</code>
is more appropriate
for use in simulation envelopes and hypothesis tests.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L_{i\bullet}</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">L_{i\bullet}(r) = r</code>
for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L_{i\bullet}</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Lcross">Lcross</a></code>,
<code><a href="#topic+Lest">Lest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> L &lt;- Ldot(amacrine, "off")
 plot(L)
</code></pre>

<hr>
<h2 id='Ldot.inhom'>
Inhomogeneous Multitype L Dot Function
</h2><span id='topic+Ldot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern, 
estimate the inhomogeneous version of the dot <code class="reqn">L</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ldot.inhom(X, i, ..., correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ldot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous cross type <code class="reqn">L</code> function
<code class="reqn">L_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). See under Details.
</p>
</td></tr>
<tr><td><code id="Ldot.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="Ldot.inhom_+3A_correction">correction</code>, <code id="Ldot.inhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+Kdot.inhom">Kdot.inhom</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This a generalisation of the function <code><a href="#topic+Ldot">Ldot</a></code>
to include an adjustment for spatially inhomogeneous intensity,
in a manner similar to the function <code><a href="#topic+Linhom">Linhom</a></code>.
</p>
<p>All the arguments are passed to <code><a href="#topic+Kdot.inhom">Kdot.inhom</a></code>, which 
estimates the inhomogeneous multitype K function
<code class="reqn">K_{i\bullet}(r)</code> for the point pattern.
The resulting values are then
transformed by taking <code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of  <code class="reqn">L_{i\bullet}(r)</code>
for a marked Poisson process, identical to <code class="reqn">r</code>.
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L_{i\bullet}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as
a level of the factor <code>X$marks</code>. It is converted to a character
string if it is not already a character string.
The value <code>i=1</code> does <b>not</b>
refer to the first level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Moller, J. and Waagepetersen, R.
Statistical Inference and Simulation for Spatial Point Processes
Chapman and Hall/CRC
Boca Raton, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ldot">Ldot</a></code>,
<code><a href="#topic+Linhom">Linhom</a></code>,
<code><a href="#topic+Kdot.inhom">Kdot.inhom</a></code>,
<code><a href="#topic+Lcross.inhom">Lcross.inhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Lansing Woods data
    lan &lt;- lansing
    lan &lt;- lan[seq(1,npoints(lan), by=10)]
    ma &lt;- split(lan)$maple
    lg &lt;- unmark(lan)

    # Estimate intensities by nonparametric smoothing
    lambdaM &lt;- density(ma, sigma=0.15, at="points")
    lambdadot &lt;- density(lg, sigma=0.15, at="points")
    L &lt;- Ldot.inhom(lan, "maple", lambdaI=lambdaM,
                                  lambdadot=lambdadot)


    # synthetic example: type A points have intensity 50,
    #                    type B points have intensity 50 + 100 * x
    lamB &lt;- as.im(function(x,y){50 + 100 * x}, owin())
    lamdot &lt;- as.im(function(x,y) { 100 + 100 * x}, owin())
    X &lt;- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
    L &lt;- Ldot.inhom(X, "B",  lambdaI=lamB,     lambdadot=lamdot)
</code></pre>

<hr>
<h2 id='Lest'>L-function</h2><span id='topic+Lest'></span>

<h3>Description</h3>

<p>Calculates an estimate of the <code class="reqn">L</code>-function (Besag's
transformation of Ripley's <code class="reqn">K</code>-function)
for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Lest(X, ..., correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lest_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of <code class="reqn">L(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Lest_+3A_correction">correction</code>, <code id="Lest_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+Kest">Kest</a></code>
to control the estimation procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes an estimate of the <code class="reqn">L</code>-function
for the spatial point pattern <code>X</code>.
The <code class="reqn">L</code>-function is a transformation of Ripley's <code class="reqn">K</code>-function,
</p>
<p style="text-align: center;"><code class="reqn">L(r) = \sqrt{\frac{K(r)}{\pi}}</code>
</p>

<p>where <code class="reqn">K(r)</code> is the <code class="reqn">K</code>-function.
</p>
<p>See <code><a href="#topic+Kest">Kest</a></code> for information
about Ripley's <code class="reqn">K</code>-function. The transformation to <code class="reqn">L</code> was
proposed by Besag (1977).
</p>
<p>The command <code>Lest</code> first calls
<code><a href="#topic+Kest">Kest</a></code> to compute the estimate of the <code class="reqn">K</code>-function,
and then applies the square root transformation.
</p>
<p>For a completely random (uniform Poisson) point pattern,
the theoretical value of the <code class="reqn">L</code>-function is <code class="reqn">L(r) = r</code>.
The square root also has the effect of stabilising
the variance of the estimator, so that <code class="reqn">L(r)</code> is more appropriate
for use in simulation envelopes and hypothesis tests.
</p>
<p>See <code><a href="#topic+Kest">Kest</a></code> for the list of arguments.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">L(r) = r</code>
for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L(r)</code> obtained by the edge corrections
named.
</p>


<h3>Variance approximations</h3>

<p>If the argument <code>var.approx=TRUE</code> is given, the return value
includes columns <code>rip</code> and <code>ls</code> containing approximations
to the variance of <code class="reqn">\hat L(r)</code> under CSR.
These are obtained by the delta method from the variance
approximations described in <code><a href="#topic+Kest">Kest</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Besag, J. (1977) 
Discussion of Dr Ripley's paper.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 193&ndash;195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> L &lt;- Lest(cells)
 plot(L, main="L function for cells")
</code></pre>

<hr>
<h2 id='Linhom'>Inhomogeneous L-function</h2><span id='topic+Linhom'></span>

<h3>Description</h3>

<p>Calculates an estimate of the inhomogeneous version of
the <code class="reqn">L</code>-function (Besag's transformation of Ripley's <code class="reqn">K</code>-function)
for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Linhom(X, ..., correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linhom_+3A_x">X</code></td>
<td>

<p>The observed point pattern, 
from which an estimate of <code class="reqn">L(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Linhom_+3A_correction">correction</code>, <code id="Linhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+Kinhom">Kinhom</a></code>
to control the estimation procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes an estimate of the inhomogeneous version of
the <code class="reqn">L</code>-function for a spatial point pattern.
</p>
<p>The original <code class="reqn">L</code>-function is a transformation
(proposed by Besag) of Ripley's <code class="reqn">K</code>-function,
</p>
<p style="text-align: center;"><code class="reqn">L(r) = \sqrt{\frac{K(r)}{\pi}}</code>
</p>

<p>where <code class="reqn">K(r)</code> is the Ripley <code class="reqn">K</code>-function of a spatially homogeneous
point pattern, estimated by <code><a href="#topic+Kest">Kest</a></code>.
</p>
<p>The inhomogeneous <code class="reqn">L</code>-function is the corresponding transformation
of the inhomogeneous <code class="reqn">K</code>-function, estimated by <code><a href="#topic+Kinhom">Kinhom</a></code>.
It is appropriate when the point pattern clearly does not have a
homogeneous intensity of points. It was proposed by
Baddeley, Moller and Waagepetersen (2000).
</p>
<p>The command <code>Linhom</code> first calls
<code><a href="#topic+Kinhom">Kinhom</a></code> to compute the estimate of the inhomogeneous K-function,
and then applies the square root transformation.
</p>
<p>For a Poisson point pattern (homogeneous or inhomogeneous),
the theoretical value of the inhomogeneous <code class="reqn">L</code>-function is <code class="reqn">L(r) = r</code>.
The square root also has the effect of stabilising
the variance of the estimator, so that <code class="reqn">L</code> is more appropriate
for use in simulation envelopes and hypothesis tests.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">L</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">L(r) = r</code>
for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">L(r)</code> obtained by the edge corrections
named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329&ndash;350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Lest">Lest</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- japanesepines
 L &lt;- Linhom(X, sigma=0.1)
 plot(L, main="Inhomogeneous L function for Japanese Pines")
</code></pre>

<hr>
<h2 id='localK'>Neighbourhood density function</h2><span id='topic+localK'></span><span id='topic+localL'></span>

<h3>Description</h3>

<p>Computes the neighbourhood density function, a local version of
the <code class="reqn">K</code>-function or <code class="reqn">L</code>-function,
defined by Getis and Franklin (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localK(X, ..., rmax = NULL, correction = "Ripley", verbose = TRUE, rvalue=NULL)
  localL(X, ..., rmax = NULL, correction = "Ripley", verbose = TRUE, rvalue=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localK_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="localK_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="localK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="localK_+3A_correction">correction</code></td>
<td>
<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"translation"</code>,
<code>"Ripley"</code>,
<code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td></tr>
<tr><td><code id="localK_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress
reports during the calculation.
</p>
</td></tr>
<tr><td><code id="localK_+3A_rvalue">rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the function L or K should be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>localL</code> computes the <em>neighbourhood density function</em>,
a local version of the <code class="reqn">L</code>-function (Besag's transformation of Ripley's
<code class="reqn">K</code>-function) that was proposed by Getis and Franklin (1987).
The command <code>localK</code> computes the corresponding
local analogue of the K-function.
</p>
<p>Given a spatial point pattern <code>X</code>, the neighbourhood density function
<code class="reqn">L_i(r)</code> associated with the <code class="reqn">i</code>th point
in <code>X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">
    L_i(r) = \sqrt{\frac a {(n-1) \pi} \sum_j e_{ij}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code> that lie
within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">a</code> is the area of the observation window, <code class="reqn">n</code> is the number
of points in <code>X</code>, and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code><a href="#topic+Kest">Kest</a></code>).
The value of <code class="reqn">L_i(r)</code> can also be interpreted as one
of the summands that contributes to the global estimate of the L
function.
</p>
<p>By default, the function <code class="reqn">L_i(r)</code> or
<code class="reqn">K_i(r)</code> is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code>. The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>.
</p>
<p>Inhomogeneous counterparts of <code>localK</code> and <code>localL</code>
are computed by <code>localKinhom</code> and <code>localLinhom</code>.
</p>


<h3>Value</h3>

<p>If <code>rvalue</code> is given, the result is a numeric vector
of length equal to the number of points in the point pattern.
</p>
<p>If <code>rvalue</code> is absent, the result is 
an object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Getis, A. and Franklin, J. (1987)
Second-order neighbourhood analysis of mapped point patterns.
<em>Ecology</em> <b>68</b>, 473&ndash;477.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Lest">Lest</a></code>,
<code><a href="#topic+localKinhom">localKinhom</a></code>,
<code><a href="#topic+localLinhom">localLinhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- ponderosa

  # compute all the local L functions
  L &lt;- localL(X)

  # plot all the local L functions against r
  plot(L, main="local L functions for ponderosa", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
  
  # compute the values of L(r) for r = 12 metres
  L12 &lt;- localL(X, rvalue=12)

  # Spatially interpolate the values of L12
  # Compare Figure 5(b) of Getis and Franklin (1987)
  X12 &lt;- X %mark% L12
  Z &lt;- Smooth(X12, sigma=5, dimyx=128)

  plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  contour(Z, add=TRUE)
  points(X, pch=16, cex=0.5)
</code></pre>

<hr>
<h2 id='localKcross'>Local Multitype K Function (Cross-Type)</h2><span id='topic+localKcross'></span><span id='topic+localLcross'></span>

<h3>Description</h3>

<p>for a multitype point pattern,
computes the cross-type version of
the local K function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localKcross(X, from, to, ..., rmax = NULL,
              correction = "Ripley", verbose = TRUE, rvalue=NULL)
  localLcross(X, from, to, ..., rmax = NULL, correction = "Ripley")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localKcross_+3A_x">X</code></td>
<td>

<p>A multitype point pattern (object of class <code>"ppp"</code>
with marks which are a factor).
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_...">...</code></td>
<td>

<p>Further arguments passed from <code>localLcross</code> to
<code>localKcross</code>.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_from">from</code></td>
<td>

<p>Type of points from which distances should be measured.
A single value;
one of the possible levels of <code>marks(X)</code>,
or an integer indicating which level.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_to">to</code></td>
<td>

<p>Type of points to which distances should be measured.
A single value; 
one of the possible levels of <code>marks(X)</code>,
or an integer indicating which level.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_correction">correction</code></td>
<td>

<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"translation"</code>,
<code>"Ripley"</code>,
<code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress
reports during the calculation.
</p>
</td></tr>
<tr><td><code id="localKcross_+3A_rvalue">rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the function L or K should be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multitype spatial point pattern <code>X</code>,
the local cross-type <code class="reqn">K</code> function <code>localKcross</code>
is the local version of the multitype <code class="reqn">K</code> function
<code><a href="#topic+Kcross">Kcross</a></code>. 
Recall that <code>Kcross(X, from, to)</code> is a sum of contributions
from all pairs of points in <code>X</code> where
the first point belongs to <code>from</code>
and the second point belongs to type <code>to</code>.
The <em>local</em> cross-type <code class="reqn">K</code>
function is defined for each point <code>X[i]</code> that belongs to
type <code>from</code>, and it consists of all the contributions to
the cross-type <code class="reqn">K</code> function that originate from point <code>X[i]</code>:
</p>
<p style="text-align: center;"><code class="reqn">
    K_{i,from,to}(r) = \sqrt{\frac a {(n-1) \pi} \sum_j e_{ij}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code>
belonging to type <code>to</code>, that lie
within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">a</code> is the area of the observation window, <code class="reqn">n</code> is the number
of points in <code>X</code>, and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code><a href="#topic+Kest">Kest</a></code>).
The value of <code class="reqn">K_{i,from,to}(r)</code>
can also be interpreted as one
of the summands that contributes to the global estimate of the
<code><a href="#topic+Kcross">Kcross</a></code> function.
</p>
<p>By default, the function <code class="reqn">K_{i,from,to}(r)</code>
is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code> belonging to type <code>from</code>.
The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code> belonging to type <code>from</code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>
belonging to type <code>from</code>.
</p>
<p>The local cross-type <code class="reqn">L</code> function <code>localLcross</code>
is computed by applying the transformation
<code class="reqn">L(r) = \sqrt{K(r)/(2\pi)}</code>.
</p>


<h3>Value</h3>

<p>If <code>rvalue</code> is given, the result is a numeric vector
of length equal to the number of points in the point pattern
that belong to type <code>from</code>.
</p>
<p>If <code>rvalue</code> is absent, the result is 
an object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point
of type <code>from</code>.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Lcross">Lcross</a></code>,
<code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localL">localL</a></code>.
</p>
<p>Inhomogeneous counterparts of <code>localK</code> and <code>localL</code>
are computed by <code><a href="#topic+localKcross.inhom">localKcross.inhom</a></code> and
<code><a href="#topic+localLinhom">localLinhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- amacrine

  # compute all the local Lcross functions
  L &lt;- localLcross(X)

  # plot all the local Lcross functions against r
  plot(L, main="local Lcross functions for amacrine", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
  
  # compute the values of L(r) for r = 0.1 metres
  L12 &lt;- localLcross(X, rvalue=0.1)
</code></pre>

<hr>
<h2 id='localKcross.inhom'>Inhomogeneous Multitype K Function</h2><span id='topic+localKcross.inhom'></span><span id='topic+localLcross.inhom'></span>

<h3>Description</h3>

<p>Computes spatially-weighted versions of the
the local multitype <code class="reqn">K</code>-function or <code class="reqn">L</code>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localKcross.inhom(X, from, to,
              lambdaFrom=NULL, lambdaTo=NULL,
              ..., rmax = NULL,
              correction = "Ripley", sigma=NULL, varcov=NULL,
              lambdaX=NULL, update=TRUE, leaveoneout=TRUE)
  localLcross.inhom(X, from, to,
              lambdaFrom=NULL, lambdaTo=NULL, ..., rmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localKcross.inhom_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_from">from</code></td>
<td>

<p>Type of points from which distances should be measured.
A single value;
one of the possible levels of <code>marks(X)</code>,
or an integer indicating which level.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_to">to</code></td>
<td>

<p>Type of points to which distances should be measured.
A single value; 
one of the possible levels of <code>marks(X)</code>,
or an integer indicating which level.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_lambdafrom">lambdaFrom</code>, <code id="localKcross.inhom_+3A_lambdato">lambdaTo</code></td>
<td>

<p>Optional.
Values of the estimated intensity function
for the points of type <code>from</code> and <code>to</code>, respectively.
Each argument should be either a vector giving the intensity values
at the required points,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_...">...</code></td>
<td>

<p>Extra arguments. Ignored if <code>lambda</code> is present.
Passed to <code><a href="#topic+density.ppp">density.ppp</a></code> if <code>lambda</code> is omitted.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_correction">correction</code></td>
<td>

<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"Ripley"</code>,
<code>"translation"</code>, <code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_sigma">sigma</code>, <code id="localKcross.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to control
the kernel smoothing procedure for estimating <code>lambdaFrom</code>
and <code>lambdaTo</code>, if they are missing.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_lambdax">lambdaX</code></td>
<td>

<p>Optional. 
Values of the estimated intensity function
for all points of <code>X</code>.
Either a vector giving the intensity values
at each point of <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a list of pixel images
giving the intensity values at all locations for each type of point,
or a fitted point process model (object of class <code>"ppm"</code>)
or a <code>function(x,y)</code> or <code>function(x,y,m)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambdaFrom</code>,
<code>lambdaTo</code> or <code>lambdaX</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="localKcross.inhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>localKcross.inhom</code> and <code>localLcross.inhom</code>
are inhomogeneous or weighted versions of the
local multitype <code class="reqn">K</code> and <code class="reqn">L</code> functions implemented in
<code><a href="#topic+localKcross">localKcross</a></code> and <code><a href="#topic+localLcross">localLcross</a></code>.
</p>
<p>Given a multitype spatial point pattern <code>X</code>,
and two designated types <code>from</code> and <code>to</code>,
the local multitype <code class="reqn">K</code> function is
defined for each point <code>X[i]</code> that belongs to type <code>from</code>,
and is computed by
</p>
<p style="text-align: center;"><code class="reqn">
    K_i(r) = \sqrt{\frac 1 \pi \sum_j \frac{e_{ij}}{\lambda_j}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code>
of type <code>to</code> that lie
within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">\lambda_j</code> is the estimated intensity of the
point pattern at the point <code class="reqn">j</code>,
and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code><a href="#topic+Kest">Kest</a></code>).
</p>
<p>The function 
<code class="reqn">K_i(r)</code> is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code>. The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code> of type <code>from</code>.
</p>
<p>The corresponding <code class="reqn">L</code> function 
<code class="reqn">L_i(r)</code> is computed by applying the
transformation 
<code class="reqn">L(r) = \sqrt{K(r)/(2\pi)}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern
of type <code>from</code>.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Linhom">Linhom</a></code>,
<code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localL">localL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- amacrine

  # compute all the local L functions
  L &lt;- localLcross.inhom(X)

  # plot all the local L functions against r
  plot(L, main="local L functions for ponderosa", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
</code></pre>

<hr>
<h2 id='localKdot'>Local Multitype K Function (Dot-Type)</h2><span id='topic+localKdot'></span><span id='topic+localLdot'></span>

<h3>Description</h3>

<p>for a multitype point pattern,
computes the dot-type version of
the local K function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localKdot(X, from, ..., rmax = NULL,
              correction = "Ripley", verbose = TRUE, rvalue=NULL)
  localLdot(X, from, ..., rmax = NULL, correction = "Ripley")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localKdot_+3A_x">X</code></td>
<td>

<p>A multitype point pattern (object of class <code>"ppp"</code>
with marks which are a factor).
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_...">...</code></td>
<td>

<p>Further arguments passed from <code>localLdot</code> to
<code>localKdot</code>.
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_from">from</code></td>
<td>

<p>Type of points from which distances should be measured.
A single value;
one of the possible levels of <code>marks(X)</code>,
or an integer indicating which level.
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_correction">correction</code></td>
<td>

<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"translation"</code>,
<code>"Ripley"</code>,
<code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress
reports during the calculation.
</p>
</td></tr>
<tr><td><code id="localKdot_+3A_rvalue">rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the function L or K should be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multitype spatial point pattern <code>X</code>,
the local dot-type <code class="reqn">K</code> function <code>localKdot</code>
is the local version of the multitype <code class="reqn">K</code> function
<code><a href="#topic+Kdot">Kdot</a></code>. 
Recall that <code>Kdot(X, from)</code> is a sum of contributions
from all pairs of points in <code>X</code> where
the first point belongs to <code>from</code>.
The <em>local</em> dot-type <code class="reqn">K</code>
function is defined for each point <code>X[i]</code> that belongs to
type <code>from</code>, and it consists of all the contributions to
the dot-type <code class="reqn">K</code> function that originate from point <code>X[i]</code>:
</p>
<p style="text-align: center;"><code class="reqn">
    K_{i,from,to}(r) = \sqrt{\frac a {(n-1) \pi} \sum_j e_{ij}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code>
that lie within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">a</code> is the area of the observation window, <code class="reqn">n</code> is the number
of points in <code>X</code>, and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code><a href="#topic+Kest">Kest</a></code>).
The value of <code class="reqn">K_{i,from}(r)</code>
can also be interpreted as one
of the summands that contributes to the global estimate of the
<code><a href="#topic+Kdot">Kdot</a></code> function.
</p>
<p>By default, the function <code class="reqn">K_{i,from}(r)</code>
is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code> belonging to type <code>from</code>.
The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code> belonging to type <code>from</code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>
belonging to type <code>from</code>.
</p>
<p>The local dot-type <code class="reqn">L</code> function <code>localLdot</code>
is computed by applying the transformation
<code class="reqn">L(r) = \sqrt{K(r)/(2\pi)}</code>.
</p>


<h3>Value</h3>

<p>If <code>rvalue</code> is given, the result is a numeric vector
of length equal to the number of points in the point pattern
that belong to type <code>from</code>.
</p>
<p>If <code>rvalue</code> is absent, the result is 
an object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point
of type <code>from</code>.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Ldot">Ldot</a></code>,
<code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localL">localL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- amacrine

  # compute all the local Ldot functions
  L &lt;- localLdot(X)

  # plot all the local Ldot functions against r
  plot(L, main="local Ldot functions for amacrine", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
  
  # compute the values of L(r) for r = 0.1 metres
  L12 &lt;- localLdot(X, rvalue=0.1)
</code></pre>

<hr>
<h2 id='localKinhom'>Inhomogeneous Neighbourhood Density Function</h2><span id='topic+localKinhom'></span><span id='topic+localLinhom'></span>

<h3>Description</h3>

<p>Computes spatially-weighted versions of the
the local <code class="reqn">K</code>-function or <code class="reqn">L</code>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localKinhom(X, lambda, ..., rmax = NULL,
              correction = "Ripley", verbose = TRUE, rvalue=NULL,
              sigma = NULL, varcov = NULL, update=TRUE, leaveoneout=TRUE)
  localLinhom(X, lambda, ..., rmax = NULL, 
              correction = "Ripley", verbose = TRUE, rvalue=NULL,
              sigma = NULL, varcov = NULL, update=TRUE, leaveoneout=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localKinhom_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"dppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_...">...</code></td>
<td>

<p>Extra arguments. Ignored if <code>lambda</code> is present.
Passed to <code><a href="#topic+density.ppp">density.ppp</a></code> if <code>lambda</code> is omitted.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_correction">correction</code></td>
<td>

<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"Ripley"</code>,
<code>"translation"</code>, <code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress
reports during the calculation.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_rvalue">rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the function L or K should be computed.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_sigma">sigma</code>, <code id="localKinhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to control
the kernel smoothing procedure for estimating <code>lambda</code>,
if <code>lambda</code> is missing.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
<tr><td><code id="localKinhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>localKinhom</code> and <code>localLinhom</code>
are inhomogeneous or weighted versions of the
neighbourhood density function implemented in
<code><a href="#topic+localK">localK</a></code> and <code><a href="#topic+localL">localL</a></code>.
</p>
<p>Given a spatial point pattern <code>X</code>, the
inhomogeneous neighbourhood density function
<code class="reqn">L_i(r)</code> associated with the <code class="reqn">i</code>th point
in <code>X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">
    L_i(r) = \sqrt{\frac 1 \pi \sum_j \frac{e_{ij}}{\lambda_j}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code> that lie
within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">\lambda_j</code> is the estimated intensity of the
point pattern at the point <code class="reqn">j</code>,
and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code><a href="#topic+Kest">Kest</a></code>).
The value of <code class="reqn">L_i(r)</code> can also be interpreted as one
of the summands that contributes to the global estimate of the
inhomogeneous L function (see <code><a href="#topic+Linhom">Linhom</a></code>).
</p>
<p>By default, the function <code class="reqn">L_i(r)</code> or
<code class="reqn">K_i(r)</code> is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code>. The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>.
</p>


<h3>Value</h3>

<p>If <code>rvalue</code> is given, the result is a numeric vector
of length equal to the number of points in the point pattern.
</p>
<p>If <code>rvalue</code> is absent, the result is 
an object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Mike Kuhn,
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Linhom">Linhom</a></code>,
<code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localL">localL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- ponderosa

  # compute all the local L functions
  L &lt;- localLinhom(X)

  # plot all the local L functions against r
  plot(L, main="local L functions for ponderosa", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
  
  # compute the values of L(r) for r = 12 metres
  L12 &lt;- localL(X, rvalue=12)
</code></pre>

<hr>
<h2 id='localpcf'>Local pair correlation function</h2><span id='topic+localpcf'></span><span id='topic+localpcfinhom'></span>

<h3>Description</h3>

<p>Computes individual contributions to the
pair correlation function from each data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  localpcf(X, ..., delta=NULL, rmax=NULL, nr=512, stoyan=0.15, rvalue=NULL)

  localpcfinhom(X, ..., delta=NULL, rmax=NULL, nr=512, stoyan=0.15,
         lambda=NULL, sigma=NULL, varcov=NULL,
         update=TRUE, leaveoneout=TRUE, rvalue=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localpcf_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="localpcf_+3A_delta">delta</code></td>
<td>

<p>Smoothing bandwidth for pair correlation.
The halfwidth of the Epanechnikov kernel.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum value of distance <code class="reqn">r</code> for which
pair correlation values <code class="reqn">g(r)</code> should be computed.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_nr">nr</code></td>
<td>

<p>Optional. Number of values of distance <code class="reqn">r</code> for which
pair correlation <code class="reqn">g(r)</code> should be computed.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_stoyan">stoyan</code></td>
<td>

<p>Optional. The value of the constant <code class="reqn">c</code> in Stoyan's rule
of thumb for selecting the smoothing bandwidth <code>delta</code>.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function, for the
inhomogeneous pair correlation.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_sigma">sigma</code>, <code id="localpcf_+3A_varcov">varcov</code>, <code id="localpcf_+3A_...">...</code></td>
<td>

<p>These arguments are ignored by <code>localpcf</code>
but are passed by <code>localpcfinhom</code> (when <code>lambda=NULL</code>)
to the function <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the kernel smoothing estimation of <code>lambda</code>.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="localpcf_+3A_rvalue">rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the local pair correlation should be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>localpcf</code> computes the contribution, from each individual
data point in a point pattern <code>X</code>, to the
empirical pair correlation function of <code>X</code>.
These contributions are sometimes known as LISA (local indicator
of spatial association) functions based on pair correlation.
</p>
<p><code>localpcfinhom</code> computes the corresponding contribution
to the <em>inhomogeneous</em> empirical pair correlation function of <code>X</code>.
</p>
<p>Given a spatial point pattern <code>X</code>, the local pcf
<code class="reqn">g_i(r)</code> associated with the <code class="reqn">i</code>th point
in <code>X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">
    g_i(r) = \frac a {2 \pi n} \sum_j k(d_{i,j} - r) 
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code>,
<code class="reqn">a</code> is the area of the observation window, <code class="reqn">n</code> is the number
of points in <code>X</code>, and <code class="reqn">d_{ij}</code> is the distance
between points <code>i</code> and <code>j</code>. Here <code>k</code> is the
Epanechnikov kernel,
</p>
<p style="text-align: center;"><code class="reqn">
    k(t) = \frac 3 { 4\delta} \max(0, 1 - \frac{t^2}{\delta^2}).
  </code>
</p>

<p>Edge correction is performed using the border method
(for the sake of computational efficiency):
the estimate <code class="reqn">g_i(r)</code> is set to <code>NA</code> if
<code class="reqn">r &gt; b_i</code>, where <code class="reqn">b_i</code>
is the distance from point <code class="reqn">i</code> to the boundary of the
observation window.
</p>
<p>The smoothing bandwidth <code class="reqn">\delta</code> may be specified.
If not, it is chosen by Stoyan's rule of thumb
<code class="reqn">\delta = c/\hat\lambda</code>
where <code class="reqn">\hat\lambda = n/a</code> is the estimated intensity
and <code class="reqn">c</code> is a constant, usually taken to be 0.15.
The value of <code class="reqn">c</code> is controlled by the argument <code>stoyan</code>.
</p>
<p>For <code>localpcfinhom</code>, the optional argument <code>lambda</code>
specifies the values of the estimated intensity function.
If <code>lambda</code> is given, it should be either a
numeric vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
If <code>lambda</code> is not given, then it will be estimated
using a leave-one-out kernel density smoother as described
in <code><a href="#topic+pcfinhom">pcfinhom</a></code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td></tr>
</table>
<p>together with columns containing the values of the
local pair correlation function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localKinhom">localKinhom</a></code>,
<code><a href="#topic+pcf">pcf</a></code>,
<code><a href="#topic+pcfinhom">pcfinhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- ponderosa

  g &lt;- localpcf(X, stoyan=0.5)
  colo &lt;- c(rep("grey", npoints(X)), "blue")
  a &lt;- plot(g, main=c("local pair correlation functions", "Ponderosa pines"),
          legend=FALSE, col=colo, lty=1)

  # plot only the local pair correlation function for point number 7
  plot(g, est007 ~ r)

  # Extract the local pair correlation at distance 15 metres, for each point
  g15 &lt;- localpcf(X, rvalue=15, stoyan=0.5)
  g15[1:10]
  # Check that the value for point 7 agrees with the curve for point 7:
  points(15, g15[7], col="red") 

  # Inhomogeneous 
  gi &lt;- localpcfinhom(X, stoyan=0.5)
  a &lt;- plot(gi, main=c("inhomogeneous local pair correlation functions",
                       "Ponderosa pines"),
                legend=FALSE, col=colo, lty=1)
</code></pre>

<hr>
<h2 id='lohboot'>Bootstrap Confidence Bands for Summary Function</h2><span id='topic+lohboot'></span>

<h3>Description</h3>

<p>Computes a bootstrap confidence band for a summary function
of a point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lohboot(X,
          fun=c("pcf", "Kest", "Lest", "pcfinhom", "Kinhom", "Linhom",
                "Kcross", "Lcross", "Kdot", "Ldot",
                "Kcross.inhom", "Lcross.inhom"),
          ...,
           block=FALSE, global=FALSE, basicboot=FALSE, Vcorrection=FALSE,
           confidence=0.95, nx = 4, ny = nx, nsim=200, type=7) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lohboot_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_fun">fun</code></td>
<td>

<p>Name of the summary function for which confidence intervals are
desired: one of the strings <code>"pcf"</code>, <code>"Kest"</code>, <code>"Lest"</code>,
<code>"pcfinhom"</code>, <code>"Kinhom"</code> <code>"Linhom"</code>, <code>"Kcross"</code>,
<code>"Lcross"</code>, <code>"Kdot"</code>, <code>"Ldot"</code>,
<code>"Kcross.inhom"</code> or <code>"Lcross.inhom"</code>.
Alternatively, the function itself; it must be
one of the functions listed here.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_...">...</code></td>
<td>

<p>Arguments passed to the corresponding local version of the summary
function (see Details).
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_block">block</code></td>
<td>

<p>Logical value indicating whether to use Loh's block bootstrap
as originally proposed. Default is <code>FALSE</code> for consistency
with older code. See Details.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_global">global</code></td>
<td>

<p>Logical. If <code>FALSE</code> (the default), pointwise confidence intervals
are constructed. If <code>TRUE</code>, a global (simultaneous) confidence band is
constructed.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_basicboot">basicboot</code></td>
<td>

<p>Logical value indicating whether to use the so-called basic
bootstrap confidence interval. See Details.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_vcorrection">Vcorrection</code></td>
<td>

<p>Logical value indicating whether to use a variance correction
when <code>fun="Kest"</code> or <code>fun="Kinhom"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level, as a fraction between 0 and 1.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_nx">nx</code>, <code id="lohboot_+3A_ny">ny</code></td>
<td>

<p>Integers.
If <code>block=TRUE</code>, divide the window into <code>nx*ny</code> rectangles.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_nsim">nsim</code></td>
<td>

<p>Number of bootstrap simulations.
</p>
</td></tr>
<tr><td><code id="lohboot_+3A_type">type</code></td>
<td>

<p>Integer. Type of quantiles.
Argument passed to <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>
controlling the way the quantiles are calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm computes 
confidence bands for the true value of the summary function
<code>fun</code> using the bootstrap method of Loh (2008)
and a modification described in Baddeley, Rubak, Turner (2015).
</p>
<p>If <code>fun="pcf"</code>, for example, the algorithm computes a pointwise
<code>(100 * confidence)</code>% confidence interval for the true value of
the pair correlation function for the point process,
normally estimated by <code><a href="#topic+pcf">pcf</a></code>.
It starts by computing the array of
<em>local</em> pair correlation functions,
<code><a href="#topic+localpcf">localpcf</a></code>, of the data pattern <code>X</code>.
This array consists of the contributions to the estimate of the
pair correlation function from each
data point. 
</p>
<p>If  <code>block=FALSE</code>, these contributions are resampled <code>nsim</code> times
with replacement as described in Baddeley, Rubak, Turner (2015);
from each resampled dataset the total contribution
is computed, yielding <code>nsim</code> random pair correlation functions.
</p>
<p>If <code>block=TRUE</code>, the calculation is performed as originally
proposed by Loh (2008, 2010). The (bounding box of the) window is divided
into <code class="reqn">nx * ny</code> rectangles (blocks).
The average contribution of a block
is obtained by averaging the contribution of each point included in the block.
Then, the average contributions on each block are resampled <code>nsim</code> times
with replacement as described in Loh (2008) and Loh (2010);
from each resampled dataset the total contribution
is computed, yielding <code>nsim</code> random pair correlation functions.
Notice that for non-rectangular windows any blocks not fully contained in the
window are discarded before doing the resampling, so the effective number of
blocks may be substantially smaller than <code class="reqn">nx * ny</code> in this case.
</p>
<p>The pointwise <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
these functions are computed, where <code>alpha = 1 - confidence</code>.
The average of the local functions is also computed as an estimate
of the pair correlation function.
</p>
<p>There are several ways to define a bootstrap confidence interval. 
If <code>basicbootstrap=TRUE</code>,
the so-called basic confidence bootstrap interval
is used as described in Loh (2008).
</p>
<p>It has been noticed in Loh (2010) that
when the intensity of the point process is unknown, 
the bootstrap error estimate is larger than it should be.
When the <code class="reqn">K</code> function is used, 
an adjustment procedure has been proposed in Loh (2010)
that is used if <code>Vcorrection=TRUE</code>.
In this case, the basic confidence bootstrap interval is implicitly used. 
</p>
<p>To control the estimation algorithm, use the 
arguments <code>...</code>, which are passed to the local version
of the summary function, as shown below:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>fun</b> </td><td style="text-align: left;"> <b>local version</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcf">pcf</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localpcf">localpcf</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kest">Kest</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localK">localK</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lest">Lest</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localL">localL</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfinhom">pcfinhom</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localpcfinhom">localpcfinhom</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kinhom">Kinhom</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localKinhom">localKinhom</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Linhom">Linhom</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localLinhom">localLinhom</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kcross">Kcross</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localKcross">localKcross</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lcross">Lcross</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localLcross">localLcross</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kdot">Kdot</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localKdot">localKdot</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Ldot">Ldot</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localLdot">localLdot</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kcross.inhom">Kcross.inhom</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localKcross.inhom">localKcross.inhom</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lcross.inhom">Lcross.inhom</a></code> </td><td style="text-align: left;"> <code><a href="#topic+localLcross.inhom">localLcross.inhom</a></code>
  </td>
</tr>

</table>

<p>For <code>fun="Lest"</code>, the calculations are first performed
as if <code>fun="Kest"</code>, and then the square-root transformation is
applied to obtain the <code class="reqn">L</code>-function. Similarly for
<code>fun="Linhom", "Lcross", "Ldot", "Lcross.inhom"</code>.
</p>
<p>Note that the confidence bands computed by 
<code>lohboot(fun="pcf")</code> may not contain the estimate of the
pair correlation function computed by <code><a href="#topic+pcf">pcf</a></code>,
because of differences between the algorithm parameters
(such as the choice of edge correction)
in <code><a href="#topic+localpcf">localpcf</a></code> and <code><a href="#topic+pcf">pcf</a></code>.
If you are using <code>lohboot</code>, the
appropriate point estimate of the pair correlation itself is
the pointwise mean of the local estimates, which is provided
in the result of <code>lohboot</code> and is shown in the default plot.
</p>
<p>If the confidence bands seem unbelievably narrow,
this may occur because the point pattern has a hard core
(the true pair correlation function is zero for certain values of
distance) or because of an optical illusion when the
function is steeply sloping (remember the width of the confidence
bands should be measured <em>vertically</em>).
</p>
<p>An alternative to <code>lohboot</code> is <code><a href="#topic+varblock">varblock</a></code>.
</p>


<h3>Value</h3>

<p>A function value table
(object of class <code>"fv"</code>)
containing columns giving the estimate of the summary function,
the upper and lower limits of the bootstrap confidence interval,
and the theoretical value of the summary function for a Poisson process.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Christophe Biscio.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Loh, J.M. (2008)
A valid and fast spatial bootstrap for correlation functions.
<em>The Astrophysical Journal</em>, <b>681</b>, 726&ndash;734.
</p>
<p>Loh, J.M. (2010)
Bootstrapping an inhomogeneous point process.
<em>Journal of Statistical Planning and Inference</em>, <b>140</b>, 734&ndash;749.
</p>


<h3>See Also</h3>

<p>Summary functions
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+pcfinhom">pcfinhom</a></code>,
<code><a href="#topic+localK">localK</a></code>,
<code><a href="#topic+localpcf">localpcf</a></code>,
<code><a href="#topic+localKinhom">localKinhom</a></code>,
<code><a href="#topic+localpcfinhom">localpcfinhom</a></code>,
<code><a href="#topic+localKcross">localKcross</a></code>,
<code><a href="#topic+localKdot">localKdot</a></code>,
<code><a href="#topic+localLcross">localLcross</a></code>,
<code><a href="#topic+localLdot">localLdot</a></code>.
<code><a href="#topic+localKcross.inhom">localKcross.inhom</a></code>,
<code><a href="#topic+localLcross.inhom">localLcross.inhom</a></code>.
</p>
<p>See <code><a href="#topic+varblock">varblock</a></code> for an alternative bootstrap technique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  p &lt;- lohboot(simdat, stoyan=0.5)
  g &lt;- lohboot(simdat, stoyan=0.5, block=TRUE)
  g
  plot(g)
</code></pre>

<hr>
<h2 id='markconnect'>
Mark Connection Function
</h2><span id='topic+markconnect'></span>

<h3>Description</h3>

<p>Estimate the marked connection function
of a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markconnect(X, i, j, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markconnect_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark connection function <code class="reqn">p_{ij}(r)</code>
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_method">method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+markcorr">markcorr</a></code>,
or passed to the density estimation routine
(<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+loess">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td></tr>
<tr><td><code id="markconnect_+3A_normalise">normalise</code></td>
<td>

<p>If <code>TRUE</code>, normalise the pair connection function by
dividing it by <code class="reqn">p_i p_j</code>, the estimated probability
that randomly-selected points will have marks <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mark connection function <code class="reqn">p_{ij}(r)</code>
of a multitype point process <code class="reqn">X</code>
is a measure of the dependence between the types of two 
points of the process a distance <code class="reqn">r</code> apart.
</p>
<p>Informally <code class="reqn">p_{ij}(r)</code> is defined
as the conditional probability,
given that there is a point of the process at a location <code class="reqn">u</code>
and another point of the process at a location <code class="reqn">v</code>
separated by a distance <code class="reqn">||u-v|| = r</code>, that the first point
is of type <code class="reqn">i</code> and the second point is of type <code class="reqn">j</code>.
See Stoyan and Stoyan (1994).
</p>
<p>If the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">p_{ij}(r) \equiv p_i p_j</code> where
<code class="reqn">p_i</code> denotes the probability that a point is of type
<code class="reqn">i</code>. Values larger than this,
<code class="reqn">p_{ij}(r) &gt; p_i p_j</code>,
indicate positive association between the two types,
while smaller values indicate negative association.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a multitype point pattern (a marked point pattern
with factor-valued marks).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">p_{ij}(r)</code> is estimated.
There is a sensible default.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks) and is slow for complicated polygons.
</p>
</dd>
<dt>translate</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries.
</p>
</dd>
<dt>none</dt><dd><p>No edge correction.</p>
</dd>
</dl>

<p>The option <code>correction="none"</code> should only be used if the
number of data points is extremely large (otherwise an edge correction
is needed to correct bias).
</p>
<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The mark connection function is estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt><dd>
<p>which uses the standard kernel
density estimation routine <code><a href="stats.html#topic+density">density</a></code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt><dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark connection function <code class="reqn">p_{ij}(r)</code>
has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">p_{ij}(r)</code>
when the marks attached to different points are independent
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">p_{ij}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>Multitype pair correlation <code><a href="#topic+pcfcross">pcfcross</a></code>
and multitype K-functions <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>.
</p>
<p>Use <code><a href="#topic+alltypes">alltypes</a></code> to compute the mark connection functions
between all pairs of types.
</p>
<p>Mark correlation <code><a href="#topic+markcorr">markcorr</a></code> and 
mark variogram <code><a href="#topic+markvario">markvario</a></code>
for numeric-valued marks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    M &lt;- markconnect(amacrine, "on", "off")
    plot(M)

    # Compute for all pairs of types at once
    plot(alltypes(amacrine, markconnect))
</code></pre>

<hr>
<h2 id='markcorr'>
Mark Correlation Function
</h2><span id='topic+markcorr'></span>

<h3>Description</h3>

<p>Estimate the marked correlation function
of a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markcorr(X, f = function(m1, m2) { m1 * m2}, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., weights=NULL,
         f1=NULL, normalise=TRUE, fargs=NULL, internal=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markcorr_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_f">f</code></td>
<td>
<p>Optional. Test function <code class="reqn">f</code> used in the definition of the
mark correlation function. An <span class="rlang"><b>R</b></span> function with at least two
arguments. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark correlation function 
<code class="reqn">k_f(r)</code> should be evaluated.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_method">method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_...">...</code></td>
<td>

<p>Arguments passed to the density estimation routine
(<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+loess">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric weights for each data point in <code>X</code>.
A numeric vector, a pixel image, or a <code>function(x,y)</code>.
Alternatively, an <code>expression</code> to be evaluated to yield the
weights; the expression may involve the variables
<code>x,y,marks</code> representing the coordinates and marks of<code>X</code>. 
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_f1">f1</code></td>
<td>

<p>An alternative to <code>f</code>. If this argument is given,
then <code class="reqn">f</code> is assumed to take the form
<code class="reqn">f(u,v)=f_1(u)f_1(v)</code>.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_normalise">normalise</code></td>
<td>

<p>If <code>normalise=FALSE</code>,
compute only the numerator of the expression for the
mark correlation.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_fargs">fargs</code></td>
<td>

<p>Optional. A list of extra arguments to be passed to the function
<code>f</code> or <code>f1</code>.
</p>
</td></tr>
<tr><td><code id="markcorr_+3A_internal">internal</code></td>
<td>
<p>Do not use this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of
Stoyan's mark correlation <code class="reqn">k_{mm}(r)</code>
for the point pattern.
</p>
<p>Alternatively if the argument <code>f</code> or <code>f1</code> is given, then it
calculates Stoyan's generalised mark correlation <code class="reqn">k_f(r)</code>
with test function <code class="reqn">f</code>.
</p>
<p>Theoretical definitions are as follows
(see Stoyan and Stoyan (1994, p. 262)):
</p>

<ul>
<li>
<p>For a point process <code class="reqn">X</code> with numeric marks,
Stoyan's mark correlation function <code class="reqn">k_{mm}(r)</code>,
is
</p>
<p style="text-align: center;"><code class="reqn">
      k_{mm}(r) = \frac{E_{0u}[M(0) M(u)]}{E[M,M']}
    </code>
</p>

<p>where <code class="reqn">E_{0u}</code> denotes the conditional expectation
given that there are points of the process at the locations
<code class="reqn">0</code> and <code class="reqn">u</code> separated by a distance <code class="reqn">r</code>,
and where <code class="reqn">M(0),M(u)</code> denote the marks attached to these
two points. On the denominator, <code class="reqn">M,M'</code> are random marks
drawn independently from the marginal distribution of marks,
and <code class="reqn">E</code> is the usual expectation.
</p>
</li>
<li>
<p>For a multitype point process <code class="reqn">X</code>, the mark correlation is 
</p>
<p style="text-align: center;"><code class="reqn">
      k_{mm}(r) = \frac{P_{0u}[M(0) M(u)]}{P[M = M']}
    </code>
</p>

<p>where <code class="reqn">P</code> and <code class="reqn">P_{0u}</code> denote the
probability and conditional probability.
</p>
</li>
<li> 
<p>The <em>generalised</em> mark correlation function <code class="reqn">k_f(r)</code>
of a marked point process <code class="reqn">X</code>, with test function <code class="reqn">f</code>,
is
</p>
<p style="text-align: center;"><code class="reqn">
      k_f(r) = \frac{E_{0u}[f(M(0),M(u))]}{E[f(M,M')]}
    </code>
</p>

</li></ul>

<p>The test function <code class="reqn">f</code> is any function
<code class="reqn">f(m_1,m_2)</code>
with two arguments which are possible marks of the pattern,
and which returns a nonnegative real value.
Common choices of <code class="reqn">f</code> are:
for continuous nonnegative real-valued marks,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = m_1 m_2</code>
</p>

<p>for discrete marks (multitype point patterns),
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = 1(m_1 = m_2)</code>
</p>

<p>and for marks taking values in <code class="reqn">[0,2\pi)</code>,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = \sin(m_1 - m_2)</code>
</p>
<p>.
</p>
<p>Note that <code class="reqn">k_f(r)</code> is not a &ldquo;correlation&rdquo;
in the usual statistical sense. It can take any 
nonnegative real value. The value 1 suggests &ldquo;lack of correlation&rdquo;:
if the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">k_f(r) \equiv 1</code>.
The interpretation of values larger or smaller than 1 depends
on the choice of function <code class="reqn">f</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern.
</p>
<p>The argument <code>f</code> determines the function to be applied to
pairs of marks. It has a sensible default, which depends on the
kind of marks in <code>X</code>. If the marks
are numeric values, then <code>f &lt;- function(m1, m2) { m1 * m2}</code>
computes the product of two marks.
If the marks are a factor (i.e. if <code>X</code> is a multitype point
pattern) then <code>f &lt;- function(m1, m2) { m1 == m2}</code> yields
the value 1 when the two marks are equal, and 0 when they are unequal.
These are the conventional definitions for numerical
marks and multitype points respectively.
</p>
<p>The argument <code>f</code> may be specified by the user.
It must be an <span class="rlang"><b>R</b></span> function, accepting two arguments <code>m1</code>
and <code>m2</code> which are vectors of equal length containing mark
values (of the same type as the marks of <code>X</code>).
(It may also take additional arguments, passed through <code>fargs</code>).
It must return a vector of numeric
values of the same length as <code>m1</code> and <code>m2</code>.
The values must be non-negative, and <code>NA</code> values are not permitted.
</p>
<p>Alternatively the user may specify the argument <code>f1</code>
instead of <code>f</code>. This indicates that the test function <code class="reqn">f</code>
should take the form <code class="reqn">f(u,v)=f_1(u)f_1(v)</code>
where <code class="reqn">f_1(u)</code> is given by the argument <code>f1</code>.
The argument <code>f1</code> should be an <span class="rlang"><b>R</b></span> function with at least one
argument.
(It may also take additional arguments, passed through <code>fargs</code>).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">k_f(r)</code> is estimated.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code><a href="#topic+Kest">Kest</a></code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt><dd><p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks).
</p>
</dd>
<dt>translate</dt><dd><p>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
</dl>

<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The numerator and denominator of the mark correlation function
(in the expression above) are estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt><dd>
<p>which uses the standard kernel
density estimation routine <code><a href="stats.html#topic+density">density</a></code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt><dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt><dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>

<p>If <code>normalise=FALSE</code> then the algorithm will compute
only the numerator
</p>
<p style="text-align: center;"><code class="reqn">
    c_f(r) = E_{0u} f(M(0),M(u))
  </code>
</p>

<p>of the expression for the mark correlation function.
In this case, negative values of <code>f</code> are permitted.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
or a list of function value tables, one for each column of marks.
</p>
<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>)
is essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark correlation function <code class="reqn">k_f(r)</code>
has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">k_f(r)</code>
when the marks attached to different points are independent,
namely 1
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the mark correlation function <code class="reqn">k_f(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>Mark variogram <code><a href="#topic+markvario">markvario</a></code> for numeric marks.
</p>
<p>Mark connection function <code><a href="#topic+markconnect">markconnect</a></code> and 
multitype K-functions <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>
for factor-valued marks.
</p>
<p>Mark cross-correlation function <code><a href="#topic+markcrosscorr">markcrosscorr</a></code>
for point patterns with several columns of marks.
</p>
<p><code><a href="#topic+Kmark">Kmark</a></code> to estimate a cumulative function
related to the mark correlation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # CONTINUOUS-VALUED MARKS:
    # (1) Spruces
    # marks represent tree diameter
    # mark correlation function
    ms &lt;- markcorr(spruces)
    plot(ms)

    # (2) simulated data with independent marks
    
      X &lt;- rpoispp(100)
      X &lt;- X %mark% runif(npoints(X))
      Xc &lt;- markcorr(X)
      plot(Xc)
    
    
    # MULTITYPE DATA:
    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    X &lt;- if(interactive()) amacrine else amacrine[c(FALSE, TRUE)]
    # (3) Kernel density estimate with Epanecnikov kernel
    # (as proposed by Stoyan &amp; Stoyan)
    M &lt;- markcorr(X, function(m1,m2) {m1==m2},
                  correction="translate", method="density",
                  kernel="epanechnikov")
    # Note: kernel="epanechnikov" comes from help(density)

    # (4) Same again with explicit control over bandwidth
    
      M &lt;- markcorr(X, 
                  correction="translate", method="density",
                  kernel="epanechnikov", bw=0.02)
      # see help(density) for correct interpretation of 'bw'
   
   

   # weighted mark correlation
   X &lt;- if(interactive()) betacells else betacells[c(TRUE,FALSE)]
   Y &lt;- subset(X, select=type)
   a &lt;- marks(X)$area
   v &lt;- markcorr(Y, weights=a)
</code></pre>

<hr>
<h2 id='markcrosscorr'>
Mark Cross-Correlation Function
</h2><span id='topic+markcrosscorr'></span>

<h3>Description</h3>

<p>Given a spatial point pattern with several columns of marks,
this function computes the mark correlation function between
each pair of columns of marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  markcrosscorr(X, r = NULL,
                correction = c("isotropic", "Ripley", "translate"),
                method = "density", ..., normalise = TRUE, Xname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markcrosscorr_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark correlation function 
<code class="reqn">k_f(r)</code> should be evaluated.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_method">method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_...">...</code></td>
<td>

<p>Arguments passed to the density estimation routine
(<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+loess">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_normalise">normalise</code></td>
<td>

<p>If <code>normalise=FALSE</code>,
compute only the numerator of the expression for the
mark correlation.
</p>
</td></tr>
<tr><td><code id="markcrosscorr_+3A_xname">Xname</code></td>
<td>

<p>Optional character string name for the dataset <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, all columns of marks are converted to numerical values.
A factor with <code class="reqn">m</code> possible levels is converted to
<code class="reqn">m</code> columns of dummy (indicator) values.
</p>
<p>Next, each pair of columns is considered, and the mark
cross-correlation is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    k_{mm}(r) = \frac{E_{0u}[M_i(0) M_j(u)]}{E[M_i,M_j]}
  </code>
</p>

<p>where <code class="reqn">E_{0u}</code> denotes the conditional expectation
given that there are points of the process at the locations
<code class="reqn">0</code> and <code class="reqn">u</code> separated by a distance <code class="reqn">r</code>.
On the numerator,
<code class="reqn">M_i(0)</code> and <code class="reqn">M_j(u)</code>
are the marks attached to locations <code class="reqn">0</code> and <code class="reqn">u</code> respectively
in the <code class="reqn">i</code>th and <code class="reqn">j</code>th columns of marks respectively.
On the denominator, <code class="reqn">M_i</code> and <code class="reqn">M_j</code> are
independent random values drawn from the
<code class="reqn">i</code>th and <code class="reqn">j</code>th columns of marks, respectively,
and <code class="reqn">E</code> is the usual expectation.
</p>
<p>Note that <code class="reqn">k_{mm}(r)</code> is not a &ldquo;correlation&rdquo;
in the usual statistical sense. It can take any 
nonnegative real value. The value 1 suggests &ldquo;lack of correlation&rdquo;:
if the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">k_{mm}(r) \equiv 1</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern.
</p>
<p>The cross-correlations are estimated in the same manner as
for <code><a href="#topic+markcorr">markcorr</a></code>.
</p>


<h3>Value</h3>

<p>A function array (object of class <code>"fasp"</code>) containing
the mark cross-correlation functions for each possible pair
of columns of marks.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markcorr">markcorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # The dataset 'betacells' has two columns of marks:
  #       'type' (factor)
  #       'area' (numeric)
  if(interactive()) plot(betacells)
  plot(markcrosscorr(betacells))
</code></pre>

<hr>
<h2 id='markmarkscatter'>
Mark-Mark Scatter Plot
</h2><span id='topic+markmarkscatter'></span>

<h3>Description</h3>

<p>Generates the mark-mark scatter plot of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markmarkscatter(X, rmax, ..., col = NULL, symap = NULL, transform=I, jit=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markmarkscatter_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>, <code>"pp3"</code>,
<code>"lpp"</code> or <code>"ppx"</code>) with numeric marks.
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_rmax">rmax</code></td>
<td>

<p>Maximum distance between pairs of points
which contribute to the plot.
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>plot.ppp</code> to
control the scatterplot.
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_transform">transform</code></td>
<td>

<p>Optional. A function which should be applied to the mark values.
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_jit">jit</code></td>
<td>

<p>Logical value indicating whether mark values should be randomly
perturbed using <code><a href="base.html#topic+jitter">jitter</a></code>. 
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_col">col</code></td>
<td>

<p>Optional. A vector of colour values, or a <code>colourmap</code>
to be used to portray the pairwise distance values. Ignored
if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="markmarkscatter_+3A_symap">symap</code></td>
<td>

<p>Optional. A <code>symbolmap</code> to be used to
portray the pairwise distance values. Overrides <code>col</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mark-mark scatter plot (Ballani et al, 2019) is a
scatterplot of the mark values of all pairs of distinct points in <code>X</code>
which are closer than the distance <code>rmax</code>.
The dots in the scatterplot are coloured according to the
pairwise distance between the two spatial points.
The plot is augmented by three curves explained by
Ballani et al (2019).
</p>
<p>If the marks only take a few different values, then
it is usually appropriate to apply random perturbation (jitter)
to the mark values, by setting <code>jit=TRUE</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley (coded from the description in Ballani et al.)
</p>


<h3>References</h3>

<p>Ballani, F., Pommerening, A. and Stoyan, D. (2019)
Mark-mark scatterplots improve pattern analysis in spatial plant
ecology.
<em>Ecological Informatics</em> <b>49</b>, 13&ndash;21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  markmarkscatter(longleaf, 10)

  markmarkscatter(spruces, 10, jit=TRUE)
</code></pre>

<hr>
<h2 id='marktable'>Tabulate Marks in Neighbourhood of Every Point in a Point Pattern</h2><span id='topic+marktable'></span>

<h3>Description</h3>

<p>Visit each point in a multitype point pattern, find the neighbouring points,
and compile a frequency table of the marks of these neighbour points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   marktable(X, R, N, exclude=TRUE, collapse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marktable_+3A_x">X</code></td>
<td>

<p>A multitype point pattern. 
An object of class <code>"ppp"</code>, <code>"lpp"</code>,
<code>"pp3"</code> or <code>"ppx"</code>, with marks which are a factor.
</p>
</td></tr>
<tr><td><code id="marktable_+3A_r">R</code></td>
<td>

<p>Neighbourhood radius. Incompatible with <code>N</code>.
</p>
</td></tr>
<tr><td><code id="marktable_+3A_n">N</code></td>
<td>

<p>Number of neighbours of each point. Incompatible with <code>R</code>.
</p>
</td></tr>
<tr><td><code id="marktable_+3A_exclude">exclude</code></td>
<td>

<p>Logical. If <code>exclude=TRUE</code>, the neighbours of a point
do not include the point itself. If <code>exclude=FALSE</code>,
a point belongs to its own neighbourhood.
</p>
</td></tr>
<tr><td><code id="marktable_+3A_collapse">collapse</code></td>
<td>

<p>Logical. If <code>collapse=FALSE</code> (the default) the results for
each point are returned as separate rows of a table.
If <code>collapse=TRUE</code>, the results are aggregated according to the
type of point.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm visits each point in the point pattern <code>X</code>,
inspects all the neighbouring points within a radius <code>R</code> of the current
point (or the <code>N</code> nearest neighbours of the current point),
and compiles a frequency table of the marks attached to the
neighbours. 
</p>
<p>The dataset <code>X</code> must be a multitype point pattern, that is,
<code>marks(X)</code> must be a <code>factor</code>.
</p>
<p>If <code>collapse=FALSE</code> (the default), 
the result is a two-dimensional contingency table with one row for
each point in the pattern, and one column for each possible mark
value. The <code>[i,j]</code> entry in the table gives the number of
neighbours of point <code>i</code> that have mark <code>j</code>.
</p>
<p>If <code>collapse=TRUE</code>, this contingency table is aggregated
according to the type of point, so that the result is a contingency
table with one row and one column for each possible mark value.
The  <code>[i,j]</code> entry in the table gives the number of
neighbours of a point with mark <code>i</code> that have mark <code>j</code>.
</p>
<p>To perform more complicated calculations on the neighbours of every
point, use <code>markstat</code> or <code>applynbd</code>. 
</p>


<h3>Value</h3>

<p>A contingency table (object of class <code>"table"</code>).
If <code>collapse=FALSE</code>, the table has one row for
each point in <code>X</code>, and one column for each possible mark value.
If <code>collapse=TRUE</code>, the table has one row and one column
for each possible mark value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>markstat</code>,
<code>applynbd</code>,
<code><a href="#topic+Kcross">Kcross</a></code>,
<code>ppp.object</code>,
<code><a href="base.html#topic+table">table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  head(marktable(amacrine, 0.1))
  head(marktable(amacrine, 0.1, exclude=FALSE))
  marktable(amacrine, N=1, collapse=TRUE)
</code></pre>

<hr>
<h2 id='markvario'>Mark Variogram</h2><span id='topic+markvario'></span>

<h3>Description</h3>

<p>Estimate the mark variogram of a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markvario(X, correction = c("isotropic", "Ripley", "translate"),
r = NULL, method = "density", ..., normalise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markvario_+3A_x">X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. It must have marks which are numeric.
</p>
</td></tr>
<tr><td><code id="markvario_+3A_correction">correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</p>
</td></tr>
<tr><td><code id="markvario_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark variogram
<code class="reqn">\gamma(r)</code>
should be evaluated.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="markvario_+3A_method">method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td></tr>
<tr><td><code id="markvario_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+markcorr">markcorr</a></code>,
or passed to the density estimation routine
(<code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+loess">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td></tr>
<tr><td><code id="markvario_+3A_normalise">normalise</code></td>
<td>
<p>If <code>TRUE</code>, normalise the variogram by
dividing it by the estimated mark variance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mark variogram <code class="reqn">\gamma(r)</code>
of a marked point process <code class="reqn">X</code>
is a measure of the dependence between the marks of two 
points of the process a distance <code class="reqn">r</code> apart.
It is informally defined as
</p>
<p style="text-align: center;"><code class="reqn">
    \gamma(r) = E[\frac 1 2 (M_1 - M_2)^2]
  </code>
</p>

<p>where <code class="reqn">E[ ]</code> denotes expectation and <code class="reqn">M_1,M_2</code>
are the marks attached to two points of the process
a distance <code class="reqn">r</code> apart.
</p>
<p>The mark variogram of a marked point process is analogous,
but <b>not equivalent</b>, to the variogram of a random field
in geostatistics. See Waelder and Stoyan (1996).
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark variogram <code class="reqn">\gamma(r)</code>
has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">\gamma(r)</code>
when the marks attached to different points are independent;
equal to the sample variance of the marks
</p>
</td></tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">\gamma(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Cressie, N.A.C. (1991)
<em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Mase, S. (1996) 
The threshold method for estimating annual rainfall.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>48</b> (1996) 201-213.
</p>
<p>Waelder, O. and Stoyan, D. (1996)
On variograms in point process statistics.
<em>Biometrical Journal</em> <b>38</b> (1996) 895-905.
</p>


<h3>See Also</h3>

<p>Mark correlation function <code><a href="#topic+markcorr">markcorr</a></code> for numeric marks.
</p>
<p>Mark connection function <code><a href="#topic+markconnect">markconnect</a></code> and 
multitype K-functions <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>
for factor-valued marks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Longleaf Pine data
    # marks represent tree diameter
    # Subset of this large pattern
    swcorner &lt;- owin(c(0,100),c(0,100))
    sub &lt;- longleaf[ , swcorner]
    # mark correlation function
    mv &lt;- markvario(sub)
    plot(mv)
</code></pre>

<hr>
<h2 id='Math.fasp'>S3 Group Generic Methods for Function Arrays</h2><span id='topic+Math.fasp'></span><span id='topic+Ops.fasp'></span><span id='topic+Complex.fasp'></span><span id='topic+Summary.fasp'></span>

<h3>Description</h3>

<p>These are group generic methods for objects of class <code>"fasp"</code>, which
allows for usual mathematical functions and operators to be applied
directly to function arrays. See Details for a list of implemented functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm=FALSE, drop=TRUE)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.fasp_+3A_x">x</code>, <code id="Math.fasp_+3A_z">z</code>, <code id="Math.fasp_+3A_e1">e1</code>, <code id="Math.fasp_+3A_e2">e2</code></td>
<td>
<p>objects of class <code>"fasp"</code>.</p>
</td></tr>
<tr><td><code id="Math.fasp_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="Math.fasp_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical value specifying whether missing values
should be removed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is a list of mathematical functions and operators which are
defined for objects of class <code>"fasp"</code>.
The methods are implemented using <code><a href="#topic+eval.fasp">eval.fasp</a></code>, which tries
to harmonise the functions via <code><a href="#topic+harmonise.fv">harmonise.fv</a></code> if they aren't
compatible to begin with.
</p>

<ol>
<li><p> Group <code>"Math"</code>:
</p>

<ul>
<li>
<p><code>abs</code>, <code>sign</code>, <code>sqrt</code>,<br />
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,<br />
<code>round</code>, <code>signif</code>
</p>
</li>
<li>
<p><code>exp</code>, <code>log</code>,  <code>expm1</code>, <code>log1p</code>,<br />
<code>cos</code>, <code>sin</code>, <code>tan</code>,<br />
<code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>,<br />
<code>acos</code>, <code>asin</code>, <code>atan</code>
</p>
<p><code>cosh</code>, <code>sinh</code>, <code>tanh</code>,<br />
<code>acosh</code>, <code>asinh</code>, <code>atanh</code>
</p>
</li>
<li>
<p><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, <code>cummin</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Ops"</code>:
</p>

<ul>
<li>
<p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>
</p>
</li>
<li> <p><code>"&amp;"</code>, <code>"|"</code>, <code>"!"</code>
</p>
</li>
<li> <p><code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"&gt;"</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Summary"</code>:
</p>

<ul>
<li> <p><code>all</code>, <code>any</code>
</p>
</li>
<li> <p><code>sum</code>, <code>prod</code>
</p>
</li>
<li> <p><code>min</code>, <code>max</code>
</p>
</li>
<li> <p><code>range</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Complex"</code>:
</p>

<ul>
<li> <p><code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code>
</p>
</li></ul>

</li></ol>

<p>For the <code>Ops</code> group, one of the arguments is permitted to be
a single atomic value, or a function table, instead of a function array.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fasp">eval.fasp</a></code> for evaluating expressions involving function arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## convert array of K functions to array of L functions
  K &lt;- alltypes(amacrine, "K")
  L &lt;- sqrt(K/pi)
</code></pre>

<hr>
<h2 id='Math.fv'>S3 Group Generic Methods for Function Tables</h2><span id='topic+Math.fv'></span><span id='topic+Ops.fv'></span><span id='topic+Complex.fv'></span><span id='topic+Summary.fv'></span>

<h3>Description</h3>

<p>These are group generic methods for objects of class <code>"fv"</code>, which
allows for usual mathematical functions and operators to be applied
directly to function tables. See Details for a list of implemented functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm=FALSE, drop=TRUE)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.fv_+3A_x">x</code>, <code id="Math.fv_+3A_z">z</code>, <code id="Math.fv_+3A_e1">e1</code>, <code id="Math.fv_+3A_e2">e2</code></td>
<td>
<p>objects of class <code>"fv"</code>.</p>
</td></tr>
<tr><td><code id="Math.fv_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="Math.fv_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical value specifying whether missing values
should be removed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is a list of mathematical functions and operators which are
defined for objects of class <code>"fv"</code>.
The methods are implemented using <code><a href="#topic+eval.fv">eval.fv</a></code>, which tries
to harmonise the functions via <code><a href="#topic+harmonise.fv">harmonise.fv</a></code> if they aren't
compatible to begin with.
</p>

<ol>
<li><p> Group <code>"Math"</code>:
</p>

<ul>
<li>
<p><code>abs</code>, <code>sign</code>, <code>sqrt</code>,<br />
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,<br />
<code>round</code>, <code>signif</code>
</p>
</li>
<li>
<p><code>exp</code>, <code>log</code>,  <code>expm1</code>, <code>log1p</code>,<br />
<code>cos</code>, <code>sin</code>, <code>tan</code>,<br />
<code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>,<br />
<code>acos</code>, <code>asin</code>, <code>atan</code>
</p>
<p><code>cosh</code>, <code>sinh</code>, <code>tanh</code>,<br />
<code>acosh</code>, <code>asinh</code>, <code>atanh</code>
</p>
</li>
<li>
<p><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, <code>cummin</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Ops"</code>:
</p>

<ul>
<li>
<p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>
</p>
</li>
<li> <p><code>"&amp;"</code>, <code>"|"</code>, <code>"!"</code>
</p>
</li>
<li> <p><code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"&gt;"</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Summary"</code>:
</p>

<ul>
<li> <p><code>all</code>, <code>any</code>
</p>
</li>
<li> <p><code>sum</code>, <code>prod</code>
</p>
</li>
<li> <p><code>min</code>, <code>max</code>
</p>
</li>
<li> <p><code>range</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Complex"</code>:
</p>

<ul>
<li> <p><code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code>
</p>
</li></ul>

</li></ol>

<p>For the <code>Ops</code> group, one of the arguments is permitted to be
a single atomic value instead of a function table.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fv">eval.fv</a></code> for evaluating expressions involving function tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Convert K function to L function
  K &lt;- Kest(cells)
  L &lt;- sqrt(K/pi)
  ## Manually calculate J function
  FR &lt;- Fest(redwood)
  GR &lt;- Gest(redwood)
  suppressWarnings(JR &lt;- (1-GR)/(1-FR))
</code></pre>

<hr>
<h2 id='methods.rho2hat'>
Methods for Intensity Functions of Two Spatial Covariates
</h2><span id='topic+methods.rho2hat'></span><span id='topic+predict.rho2hat'></span><span id='topic+print.rho2hat'></span><span id='topic+plot.rho2hat'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"rho2hat"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rho2hat'
plot(x, ..., do.points=FALSE)

## S3 method for class 'rho2hat'
print(x, ...)

## S3 method for class 'rho2hat'
predict(object, ..., relative=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.rho2hat_+3A_x">x</code>, <code id="methods.rho2hat_+3A_object">object</code></td>
<td>

<p>An object of class <code>"rho2hat"</code>.
</p>
</td></tr>
<tr><td><code id="methods.rho2hat_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.rho2hat_+3A_do.points">do.points</code></td>
<td>

<p>Logical value indicating whether to plot the observed values of
the covariates at the data points.
</p>
</td></tr>
<tr><td><code id="methods.rho2hat_+3A_relative">relative</code></td>
<td>

<p>Logical value indicating whether to compute the
estimated point process intensity (<code>relative=FALSE</code>)
or the relative risk (<code>relative=TRUE</code>) in the case
of a relative risk estimate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code> and
<code><a href="graphics.html#topic+plot">plot</a></code> 
for the class <code>"rho2hat"</code>.
</p>
<p>An object of class <code>"rho2hat"</code> is an estimate
of the intensity of a point process, as a function of two
given spatial covariates. See <code><a href="#topic+rho2hat">rho2hat</a></code>.
</p>
<p>The method <code>plot.rho2hat</code> displays the estimated function
<code class="reqn">\rho</code> using <code><a href="#topic+plot.fv">plot.fv</a></code>, and optionally
adds a <code><a href="graphics.html#topic+rug">rug</a></code> plot of the observed values of the covariate.
In this plot the two axes represent possible values of the two covariates.
</p>
<p>The method <code>predict.rho2hat</code> computes a pixel image of the
intensity <code class="reqn">\rho(Z_1(u), Z_2(u))</code>
at each spatial location <code class="reqn">u</code>, where <code class="reqn">Z_1(u)</code>
and <code class="reqn">Z_2(u)</code> are the two spatial covariates.
</p>


<h3>Value</h3>

<p>For <code>predict.rho2hat</code> the value is a pixel image
(object of class <code>"im"</code>). 
For other functions, the value is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rho2hat">rho2hat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  r2 &lt;- with(bei.extra, rho2hat(bei, elev, grad))
  r2
  plot(r2)
  plot(predict(r2))
</code></pre>

<hr>
<h2 id='methods.rhohat'>
Methods for Intensity Functions of Spatial Covariate
</h2><span id='topic+methods.rhohat'></span><span id='topic+print.rhohat'></span><span id='topic+plot.rhohat'></span><span id='topic+predict.rhohat'></span><span id='topic+simulate.rhohat'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"rhohat"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rhohat'
print(x, ...)

## S3 method for class 'rhohat'
plot(x, ..., do.rug=TRUE)

## S3 method for class 'rhohat'
predict(object, ..., relative=FALSE,
             what=c("rho", "lo", "hi", "se"))

## S3 method for class 'rhohat'
simulate(object, nsim=1, ..., drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.rhohat_+3A_x">x</code>, <code id="methods.rhohat_+3A_object">object</code></td>
<td>

<p>An object of class <code>"rhohat"</code> representing 
a smoothed estimate of the intensity function of a point process.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_do.rug">do.rug</code></td>
<td>

<p>Logical value indicating whether to plot the observed values of
the covariate as a rug plot along the horizontal axis.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_relative">relative</code></td>
<td>

<p>Logical value indicating whether to compute the
estimated point process intensity (<code>relative=FALSE</code>)
or the relative risk (<code>relative=TRUE</code>) in the case
of a relative risk estimate.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations to be generated.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do when <code>nsim=1</code>.
If <code>drop=TRUE</code> (the default), a point pattern is returned.
If <code>drop=FALSE</code>, a list of length 1 containing a point pattern
is returned.
</p>
</td></tr>
<tr><td><code id="methods.rhohat_+3A_what">what</code></td>
<td>

<p>Optional character string (partially matched) specifying which
value should be calculated: either the function estimate (<code>what="rho"</code>,
the default), the lower or upper end of the confidence interval
(<code>what="lo"</code> or <code>what="hi"</code>) or the standard error
(<code>what="se"</code>).
</p>
</td></tr>	 
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code> and
<code><a href="stats.html#topic+simulate">simulate</a></code>
for the class <code>"rhohat"</code>.
</p>
<p>An object of class <code>"rhohat"</code> is an estimate
of the intensity of a point process, as a function of a
given spatial covariate. See <code><a href="#topic+rhohat">rhohat</a></code>.
</p>
<p>The method <code>plot.rhohat</code> displays the estimated function
<code class="reqn">\rho</code> using <code><a href="#topic+plot.fv">plot.fv</a></code>, and optionally
adds a <code><a href="graphics.html#topic+rug">rug</a></code> plot of the observed values of the covariate.
</p>
<p>The method <code>predict.rhohat</code> computes a pixel image of the
intensity <code class="reqn">\rho(Z(u))</code> at each spatial location
<code class="reqn">u</code>, where <code class="reqn">Z</code> is the spatial covariate.
</p>
<p>The method <code>simulate.rhohat</code> invokes <code>predict.rhohat</code>
to determine the predicted intensity, and then simulates a
Poisson point process with this intensity.
</p>


<h3>Value</h3>

<p>For <code>predict.rhohat</code> the value is a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>).
For <code>simulate.rhohat</code> the value is a point pattern
(object of class <code>"ppp"</code> or <code>"lpp"</code>).
For other functions, the value is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhohat">rhohat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;-  rpoispp(function(x,y){exp(3+3*x)})
  rho &lt;- rhohat(X, function(x,y){x})
  rho
  plot(rho)
  Y &lt;- predict(rho)
  plot(Y)
  plot(simulate(rho), add=TRUE)
  #
  if(require("spatstat.model")) {
    fit &lt;- ppm(X, ~x)
    rho &lt;- rhohat(fit, "y")
    opa &lt;- par(mfrow=c(1,2))
    plot(predict(rho))
    plot(predict(rho, relative=TRUE))
    par(opa)
    plot(predict(rho, what="se"))
  }
</code></pre>

<hr>
<h2 id='methods.ssf'>Methods for Spatially Sampled Functions</h2><span id='topic+methods.ssf'></span><span id='topic+marks.ssf'></span><span id='topic+marks+3C-.ssf'></span><span id='topic+unmark.ssf'></span><span id='topic+as.im.ssf'></span><span id='topic+as.function.ssf'></span><span id='topic+as.ppp.ssf'></span><span id='topic+print.ssf'></span><span id='topic+summary.ssf'></span><span id='topic+range.ssf'></span><span id='topic+min.ssf'></span><span id='topic+max.ssf'></span><span id='topic+integral.ssf'></span>

<h3>Description</h3>

<p>Methods for various generic commands, for the class
<code>"ssf"</code> of spatially sampled functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ssf'
marks(x, ...)

  ## S3 replacement method for class 'ssf'
marks(x, ...) &lt;- value

  ## S3 method for class 'ssf'
unmark(X)

  ## S3 method for class 'ssf'
as.im(X, ...)

  ## S3 method for class 'ssf'
as.function(x, ...)

  ## S3 method for class 'ssf'
as.ppp(X, ...)

  ## S3 method for class 'ssf'
print(x, ..., brief=FALSE)

  ## S3 method for class 'ssf'
summary(object, ...)

  ## S3 method for class 'ssf'
range(x, ...)

  ## S3 method for class 'ssf'
min(x, ...)

  ## S3 method for class 'ssf'
max(x, ...)

  ## S3 method for class 'ssf'
integral(f, domain=NULL, ..., weights=attr(f, "weights"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.ssf_+3A_x">x</code>, <code id="methods.ssf_+3A_x">X</code>, <code id="methods.ssf_+3A_f">f</code>, <code id="methods.ssf_+3A_object">object</code></td>
<td>

<p>A spatially sampled function (object of class <code>"ssf"</code>). 
</p>
</td></tr>
<tr><td><code id="methods.ssf_+3A_...">...</code></td>
<td>
<p>Arguments passed to the default method.</p>
</td></tr>
<tr><td><code id="methods.ssf_+3A_brief">brief</code></td>
<td>
<p>Logical value controlling the amount of detail printed.</p>
</td></tr>
<tr><td><code id="methods.ssf_+3A_value">value</code></td>
<td>
<p>Matrix of replacement values for the function.</p>
</td></tr>
<tr><td><code id="methods.ssf_+3A_domain">domain</code></td>
<td>
<p>Optional.
Domain of integration. An object of class<code>"owin"</code> or <code>"tess"</code>.
</p>
</td></tr>
<tr><td><code id="methods.ssf_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of <em>quadrature weights</em> associated with the
sample points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ssf"</code> represents a
function (real- or vector-valued) that has been
sampled at a finite set of points.
</p>
<p>The commands documented here are methods for this class,
for the generic commands
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>,
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code>,
<code><a href="spatstat.geom.html#topic+unmark">unmark</a></code>,
<code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>,
<code><a href="base.html#topic+as.function">as.function</a></code>,
<code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="base.html#topic+range">range</a></code>,
<code><a href="base.html#topic+min">min</a></code>,
<code><a href="base.html#topic+max">max</a></code>
and <code><a href="spatstat.geom.html#topic+integral">integral</a></code>.
</p>


<h3>Value</h3>

<p><code>marks</code> returns a matrix.
</p>
<p><code>marks(x) &lt;- value</code> returns an object of class <code>"ssf"</code>.
</p>
<p><code>as.owin</code> returns a window (object of class <code>"owin"</code>).
</p>
<p><code>as.ppp</code> and <code>unmark</code>
return a point pattern (object of class <code>"ppp"</code>).
</p>
<p><code>as.function</code> returns a <code>function(x,y)</code> of class <code>"funxy"</code>.
</p>
<p><code>print</code> returns <code>NULL</code>.
</p>
<p><code>summary</code> returns an object of class
<code>"summary.ssf"</code> which has a print method.
</p>
<p><code>range</code> returns a numeric vector of length 2.
<code>min</code> and <code>max</code> return a single numeric value.
</p>
<p><code>integral</code> returns a numeric or complex value, vector, or matrix.
<code>integral(f)</code> returns a numeric or complex value
(if <code>f</code> had numeric or complex values)
or a numeric vector (if <code>f</code> had vector values).
If <code>domain</code> is a tessellation then <code>integral(f, domain)</code>
returns a numeric or complex vector with one entry for each tile
(if <code>f</code> had numeric or complex values)
or a numeric matrix with one row for each tile
(if <code>f</code> had vector values).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssf">ssf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- distfun(cells[1:4])
  X &lt;- rsyst(Window(cells), 10)
  f &lt;- ssf(X, g(X))
  f
  summary(f)
  marks(f)
  as.ppp(f)
  as.im(f)
  integral(f)
  integral(f, quadrats(Window(f), 3))
</code></pre>

<hr>
<h2 id='miplot'>Morisita Index Plot</h2><span id='topic+miplot'></span>

<h3>Description</h3>

<p>Displays the Morisita Index Plot of a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miplot(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miplot_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>) or something
acceptable to <code>as.ppp</code>.
</p>
</td></tr>
<tr><td><code id="miplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to control the appearance of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Morisita (1959) defined an index of spatial aggregation for a spatial
point pattern based on quadrat counts. The spatial domain of the point
pattern is first divided into <code class="reqn">Q</code> subsets (quadrats) of equal size and
shape. The numbers of points falling in each quadrat are counted.
Then the Morisita Index is computed as
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{MI} = Q \frac{\sum_{i=1}^Q n_i (n_i - 1)}{N(N-1)}
  </code>
</p>

<p>where <code class="reqn">n_i</code> is the number of points falling in the <code class="reqn">i</code>-th
quadrat, and <code class="reqn">N</code> is the total number of points.
If the pattern is completely random, <code>MI</code> should be approximately
equal to 1. Values of <code>MI</code> greater than 1 suggest clustering.
</p>
<p>The <em>Morisita Index plot</em> is a plot of the Morisita Index
<code>MI</code> against the linear dimension of the quadrats. 
The point pattern dataset is divided into <code class="reqn">2 \times 2</code>
quadrats, then <code class="reqn">3 \times 3</code> quadrats, etc, and the
Morisita Index is computed each time. This plot is an attempt to
discern different scales of dependence in the point pattern data.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>M. Morisita (1959) Measuring of the dispersion of individuals and
analysis of the distributional patterns.
Memoir of the Faculty of Science, Kyushu University, Series E: Biology. 
<b>2</b>: 215&ndash;235. 
</p>


<h3>See Also</h3>

<p><code>quadratcount</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> miplot(longleaf)
 opa &lt;- par(mfrow=c(2,3))
 plot(cells)
 plot(japanesepines)
 plot(redwood)
 miplot(cells)
 miplot(japanesepines)
 miplot(redwood)
 par(opa)
</code></pre>

<hr>
<h2 id='nnclean'>
Nearest Neighbour Clutter Removal
</h2><span id='topic+nnclean'></span><span id='topic+nnclean.ppp'></span><span id='topic+nnclean.pp3'></span>

<h3>Description</h3>

<p>Detect features in a 2D or 3D spatial point pattern
using nearest neighbour clutter removal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nnclean(X, k, ...)

  ## S3 method for class 'ppp'
nnclean(X, k, ..., 
                     edge.correct = FALSE, wrap = 0.1,
                     convergence = 0.001, plothist = FALSE,
                     verbose = TRUE, maxit = 50)

  ## S3 method for class 'pp3'
nnclean(X, k, ..., 
                     convergence = 0.001, plothist = FALSE,
                     verbose = TRUE, maxit = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnclean_+3A_x">X</code></td>
<td>

<p>A two-dimensional spatial point pattern (object of class
<code>"ppp"</code>) or a three-dimensional point pattern
(object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_k">k</code></td>
<td>

<p>Degree of neighbour: <code>k=1</code> means nearest neighbour,
<code>k=2</code> means second nearest, etc.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+hist.default">hist.default</a></code> to control
the appearance of the histogram, if <code>plothist=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_edge.correct">edge.correct</code></td>
<td>

<p>Logical flag specifying whether periodic edge correction
should be performed (only implemented in 2 dimensions).
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_wrap">wrap</code></td>
<td>

<p>Numeric value specifying the relative size of the margin
in which data will be replicated for the 
periodic edge correction (if <code>edge.correct=TRUE</code>).
A fraction of window width and window height.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_convergence">convergence</code></td>
<td>

<p>Relative tolerance threshold for testing convergence of EM algorithm.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations for EM algorithm.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_plothist">plothist</code></td>
<td>

<p>Logical flag specifying whether to plot a diagnostic histogram
of the nearest neighbour distances and the fitted distribution.
</p>
</td></tr>
<tr><td><code id="nnclean_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag specifying whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Byers and Raftery (1998) developed a technique for recognising
features in a spatial point pattern in the presence of
random clutter.
</p>
<p>For each point in the pattern, the distance to the
<code class="reqn">k</code>th nearest neighbour is computed. Then the E-M algorithm is
used to fit a mixture distribution to the
<code class="reqn">k</code>th nearest neighbour distances.
The mixture components represent the feature and the clutter. The
mixture model can be used to classify each point as belong to one
or other component.
</p>
<p>The function <code>nnclean</code> is generic, with methods for
two-dimensional point patterns (class <code>"ppp"</code>)
and three-dimensional point patterns (class <code>"pp3"</code>)
currently implemented.
</p>
<p>The result is a point pattern (2D or 3D) with two additional
columns of marks:
</p>

<dl>
<dt>class</dt><dd>
<p>A factor, with levels <code>"noise"</code> and <code>"feature"</code>,
indicating the maximum likelihood classification of each point.
</p>
</dd>
<dt>prob</dt><dd>
<p>Numeric vector giving the estimated probabilities
that each point belongs to a feature.
</p>
</dd>
</dl>

<p>The object also has extra information stored in attributes:
<code>"theta"</code> contains the fitted parameters
of the mixture model, <code>"info"</code> contains
information about the fitting procedure, and <code>"hist"</code> contains
the histogram structure returned from <code><a href="graphics.html#topic+hist.default">hist.default</a></code>
if <code>plothist = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of the same kind as <code>X</code>,
obtained by attaching marks to the points of <code>X</code>.
</p>
<p>The object also has attributes, as described under Details.
</p>


<h3>Author(s)</h3>

<p>Original by Simon Byers and Adrian Raftery.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Byers, S. and Raftery, A.E. (1998)
Nearest-neighbour clutter removal for estimating features
in spatial point processes.
<em>Journal of the American Statistical Association</em>
<b>93</b>, 577&ndash;584.
</p>


<h3>See Also</h3>

<p><code>nndist</code>, 
<code>split.ppp</code>, 
<code>cut.ppp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # shapley galaxy cluster
  X &lt;- nnclean(shapley, k=17, plothist=TRUE)
  plot(X, which.marks=1, chars=c(".", "+"), cols=1:2,
       main="Shapley data, cluster and noise")
  plot(X, which.marks=2, cols=function(x)hsv(0.2+0.8*(1-x),1,1),
       main="Shapley data, probability of cluster")
  Y &lt;- split(X, un=TRUE)
  plot(Y, chars="+", cex=0.5)
  marks(X) &lt;- marks(X)$prob
  plot(cut(X, breaks=3), chars=c(".", "+", "+"), cols=1:3)
</code></pre>

<hr>
<h2 id='nncorr'>Nearest-Neighbour Correlation Indices of Marked Point Pattern</h2><span id='topic+nncorr'></span><span id='topic+nnmean'></span><span id='topic+nnvario'></span>

<h3>Description</h3>

<p>Computes nearest-neighbour correlation indices of a marked point
pattern, including the nearest-neighbour mark product index
(default case of <code>nncorr</code>),
the nearest-neighbour mark index (<code>nnmean</code>),
and the nearest-neighbour variogram index (<code>nnvario</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     nncorr(X,
            f = function(m1, m2) { m1 * m2 },
            k = 1,       
            ...,
            use = "all.obs", method = c("pearson", "kendall", "spearman"),
            denominator=NULL, na.action="warn")

     nnmean(X, k=1, na.action="warn")

     nnvario(X, k=1, na.action="warn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nncorr_+3A_x">X</code></td>
<td>

<p>The observed point pattern.
An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_f">f</code></td>
<td>

<p>Function <code class="reqn">f</code> used in the definition of the
nearest neighbour correlation. There is a sensible default
that depends on the type of marks of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_k">k</code></td>
<td>

<p>Integer. The <code>k</code>-th nearest neighbour of each point will be used.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>f</code>.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_use">use</code>, <code id="nncorr_+3A_method">method</code></td>
<td>

<p>Arguments passed to the standard correlation function <code><a href="stats.html#topic+cor">cor</a></code>.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_denominator">denominator</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
<tr><td><code id="nncorr_+3A_na.action">na.action</code></td>
<td>

<p>Character string (passed to <code>is.marked.ppp</code>)
specifying what to do if the marks contain <code>NA</code> values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nearest neighbour correlation index <code class="reqn">\bar n_f</code>
of a marked point process <code class="reqn">X</code>
is a number measuring the dependence between the mark of a typical point
and the mark of its nearest neighbour. 
</p>
<p>The command <code>nncorr</code> computes the nearest neighbour correlation index
based on any test function <code>f</code> provided by the user.
The default behaviour of <code>nncorr</code> is to compute the
nearest neighbour mark product index.
The commands <code>nnmean</code> and <code>nnvario</code> are
convenient abbreviations for other special choices of <code>f</code>.
</p>
<p>In the default case, <code>nncorr(X)</code> computes three different
versions of the nearest-neighbour correlation index:
the unnormalised, normalised, and classical correlations.
</p>

<dl>
<dt>unnormalised:</dt><dd>
<p>The <b>unnormalised</b> nearest neighbour correlation (Stoyan and Stoyan,
1994, section 14.7) is defined as
</p>
<p style="text-align: center;"><code class="reqn">\bar n_f = E[f(M, M^\ast)]</code>
</p>

<p>where <code class="reqn">E[]</code> denotes mean value,
<code class="reqn">M</code> is the mark attached to a
typical point of the point process, and <code class="reqn">M^\ast</code> is the mark
attached to its nearest neighbour (i.e. the nearest other point of the
point process).
</p>
<p>Here <code class="reqn">f</code> is any function
<code class="reqn">f(m_1,m_2)</code>
with two arguments which are possible marks of the pattern,
and which returns a nonnegative real value.
Common choices of <code class="reqn">f</code> are:
for continuous real-valued marks,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = m_1 m_2</code>
</p>

<p>for discrete marks (multitype point patterns),
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = 1(m_1 = m_2)</code>
</p>

<p>and for marks taking values in <code class="reqn">[0,2\pi)</code>,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = \sin(m_1 - m_2)</code>
</p>

<p>For example, in the second case, the unnormalised nearest neighbour
correlation <code class="reqn">\bar n_f</code> equals the proportion of
points in the pattern which have the same mark as their nearest
neighbour.
</p>
<p>Note that <code class="reqn">\bar n_f</code> is not a &ldquo;correlation&rdquo;
in the usual statistical sense. It can take values greater than 1.
</p>
</dd>
<dt>normalised:</dt><dd>
<p>We can define a <b>normalised</b> nearest neighbour correlation
by 
</p>
<p style="text-align: center;"><code class="reqn">\bar m_f = \frac{E[f(M,M^\ast)]}{E[f(M,M')]}</code>
</p>

<p>where again <code class="reqn">M</code> is the
mark attached to a typical point, <code class="reqn">M^\ast</code> is the mark
attached to its nearest neighbour, and <code class="reqn">M'</code> is an independent
copy of <code class="reqn">M</code> with the same distribution.
This normalisation is also not a &ldquo;correlation&rdquo;
in the usual statistical sense, but is normalised so that 
the value 1 suggests &ldquo;lack of correlation&rdquo;:
if the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">\bar m_f = 1</code>.
The interpretation of values larger or smaller than 1 depends
on the choice of function <code class="reqn">f</code>.
</p>
</dd>
<dt>classical:</dt><dd>
<p>Finally if the marks of <code>X</code> are real numbers,
we can also compute the
<b>classical</b> correlation, that is, the correlation coefficient
of the two random variables <code class="reqn">M</code> and <code class="reqn">M^\ast</code>.
The classical correlation has a value between <code class="reqn">-1</code> and <code class="reqn">1</code>.
Values close to <code class="reqn">-1</code> or <code class="reqn">1</code> indicate strong dependence between
the marks.
</p>
</dd>
</dl>

<p>In the default case where <code>f</code> is not given,
<code>nncorr(X)</code> computes
</p>

<ul>
<li>
<p>If the marks of <code>X</code> are real numbers, 
the unnormalised and normalised
versions of the nearest-neighbour product index
<code class="reqn">E[M \, M^\ast]</code>,
and the classical correlation
between <code class="reqn">M</code> and <code class="reqn">M^\ast</code>.
</p>
</li>
<li>
<p>If the marks of <code>X</code> are factor valued,
the unnormalised and normalised
versions of the nearest-neighbour equality index
<code class="reqn">P[M = M^\ast]</code>.
</p>
</li></ul>

<p>The wrapper functions <code>nnmean</code> and <code>nnvario</code>
compute the correlation indices for two special choices of the
function <code class="reqn">f(m_1,m_2)</code>. They are defined only when the
marks are numeric.
</p>

<ul>
<li>
<p><code>nnmean</code> computes the correlation indices for 
<code class="reqn">f(m_1,m_2) = m_1</code>. The unnormalised index
is simply the mean value of the mark of the neighbour of a typical point,
<code class="reqn">E[M^\ast]</code>, while the normalised index is
<code class="reqn">E[M^\ast]/E[M]</code>, the ratio of the mean mark of the
neighbour of a typical point to the mean mark of a typical point.
</p>
</li>
<li> 
<p><code>nnvario</code> computes the correlation indices for 
<code class="reqn">f(m_1,m_2) = (1/2) (m_1-m_2)^2</code>.
</p>
</li></ul>

<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) and must be a marked point pattern.
(The marks may be a data frame, containing several columns of mark variables;
each column is treated separately.)
</p>
<p>If the argument <code>f</code> is given, it
must be a function, accepting two arguments <code>m1</code>
and <code>m2</code> which are vectors of equal length containing mark
values (of the same type as the marks of <code>X</code>).
It must return a vector of numeric
values of the same length as <code>m1</code> and <code>m2</code>.
The values must be non-negative.
</p>
<p>The arguments <code>use</code> and <code>method</code> control
the calculation of the classical correlation using <code><a href="stats.html#topic+cor">cor</a></code>,
as explained in the help file for <code><a href="stats.html#topic+cor">cor</a></code>.
</p>
<p>Other arguments may be passed to <code>f</code> through the <code>...</code>
argument.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
Biases due to edge effects are
treated using the &lsquo;border method&rsquo; edge correction.
</p>


<h3>Value</h3>

<p>Labelled vector of length 2 or 3
containing the unnormalised and normalised
nearest neighbour correlations, and the classical correlation
if appropriate.
Alternatively a matrix with 2 or 3 rows, containing this information
for each mark variable.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nnmean(finpines)
  nnvario(finpines)
  nncorr(finpines)
  # heights of neighbouring trees are slightly negatively correlated

  nncorr(amacrine)
  # neighbouring cells are usually of different type
</code></pre>

<hr>
<h2 id='nndensity.ppp'>
Estimate Intensity of Point Pattern Using Nearest Neighbour Distances
</h2><span id='topic+nndensity'></span><span id='topic+nndensity.ppp'></span>

<h3>Description</h3>

<p>Estimates the intensity of a point pattern
using the distance from each spatial location
to the <code>k</code>th nearest data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nndensity(x, ...)

## S3 method for class 'ppp'
nndensity(x, k, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndensity.ppp_+3A_x">x</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
or some other spatial object.
</p>
</td></tr>
<tr><td><code id="nndensity.ppp_+3A_k">k</code></td>
<td>

<p>Integer. The distance to the <code>k</code>th nearest data point
will be computed. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="nndensity.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>nnmap</code> and <code><a href="grid.html#topic+as.mask">as.mask</a></code>
controlling the pixel resolution.
</p>
</td></tr>
<tr><td><code id="nndensity.ppp_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, print the value of <code>k</code>
when it is automatically selected. If <code>FALSE</code>, remain silent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a quick estimate of the intensity of the point
process that generated the point pattern <code>x</code>.
</p>
<p>For each spatial location <code class="reqn">s</code>, let <code class="reqn">d(s)</code> be the distance from <code class="reqn">s</code>
to the <code class="reqn">k</code>-th nearest point in the dataset <code>x</code>.
If the data came from a homogeneous
Poisson process with intensity <code class="reqn">\lambda</code>,
then <code class="reqn">\pi d(s)^2</code> would follow a 
negative exponential distribution with mean
<code class="reqn">1/\lambda</code>, and the maximum likelihood estimate of
<code class="reqn">\lambda</code> would be <code class="reqn">1/(\pi d(s)^2)</code>.
This is the estimate computed by <code>nndensity</code>,
apart from an edge effect correction.
</p>
<p>See Cressie (1991, equation (8.5.14), p. 654)
and Silverman (1986, p. 96).
</p>
<p>This estimator of intensity is relatively fast to compute, 
and is spatially adaptive
(so that it can handle wide variation in the intensity
function). However, it implicitly assumes the points are independent,
so it does not perform well if the pattern is strongly clustered
or strongly inhibited.
</p>
<p>In normal use, the value of <code>k</code> should be at least 3.
(Theoretically the estimator has infinite expected value if <code class="reqn">k=1</code>,
and infinite variance if <code class="reqn">k=2</code>.
The computed intensity estimate will have infinite peaks
around each data point if <code>k = 1</code>.)
The default value of <code>k</code> is the square root of the number of
points in <code>x</code>, which seems to work well in many cases.
</p>
<p>The window of <code>x</code> is digitised using <code><a href="grid.html#topic+as.mask">as.mask</a></code>
and the values <code class="reqn">d(s)</code> are computed using <code>nnmap</code>.
To control the pixel resolution, see <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) giving the
estimated intensity of the point process at each spatial location.
Pixel values are intensities (number of points per unit area).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C. (1991)
<em>Statistics for spatial data</em>.
John Wiley and Sons, New York.
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code>intensity</code>
for alternative estimates of point process intensity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(nndensity(swedishpines))
</code></pre>

<hr>
<h2 id='nnorient'>
Nearest Neighbour Orientation Distribution
</h2><span id='topic+nnorient'></span>

<h3>Description</h3>

<p>Computes the distribution of the orientation of the vectors
from each point to its nearest neighbour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nnorient(X, ..., cumulative = FALSE, correction, k = 1,
                     unit = c("degree", "radian"),
                     domain = NULL, ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnorient_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+circdensity">circdensity</a></code> to control
the kernel smoothing, if <code>cumulative=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_cumulative">cumulative</code></td>
<td>

<p>Logical value specifying whether to estimate the probability density
(<code>cumulative=FALSE</code>, the default) or the cumulative
distribution function (<code>cumulative=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_correction">correction</code></td>
<td>

<p>Character vector specifying edge correction or corrections.
Options are <code>"none"</code>, <code>"bord.modif"</code>, 
<code>"good"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_k">k</code></td>
<td>

<p>Integer. The <code class="reqn">k</code>th nearest neighbour will be used.
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_unit">unit</code></td>
<td>

<p>Unit in which the angles should be expressed.
Either <code>"degree"</code> or <code>"radian"</code>.
</p>
</td></tr>
<tr><td><code id="nnorient_+3A_domain">domain</code></td>
<td>

<p>Optional window. The first point <code class="reqn">x_i</code> of each pair of points
will be constrained to lie in <code>domain</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm considers each point in the pattern <code>X</code>
and finds its nearest neighbour (or <code class="reqn">k</code>th nearest neighour).
The <em>direction</em> of the arrow joining the data point to its neighbour
is measured, as an angle in degrees or radians,
anticlockwise from the <code class="reqn">x</code> axis.
</p>
<p>If <code>cumulative=FALSE</code> (the default),
a kernel estimate of the probability density of the angles
is calculated using <code><a href="#topic+circdensity">circdensity</a></code>.
This is the function <code class="reqn">\vartheta(\phi)</code> defined 
in Illian et al (2008), equation (4.5.3), page 253.
</p>
<p>If <code>cumulative=TRUE</code>, then the cumulative distribution
function of these angles is calculated.
</p>
<p>In either case the result can be plotted as a rose diagram by 
<code><a href="#topic+rose">rose</a></code>, or as a function plot by <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The algorithm gives each observed direction a weight,
determined by an edge correction, to adjust for the fact that some
interpoint distances are more likely to be observed than others.
The choice of edge correction or corrections is determined by the argument
<code>correction</code>.
</p>
<p>It is also possible to calculate an estimate of the probability
density from the cumulative distribution function,
by numerical differentiation. 
Use <code><a href="#topic+deriv.fv">deriv.fv</a></code> with the argument <code>Dperiodic=TRUE</code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the estimates of the probability density or the
cumulative distribution function of angles,
in degrees (if <code>unit="degree"</code>)
or radians (if <code>unit="radian"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Illian, J., Penttinen, A., Stoyan, H. and Stoyan, D. (2008)
<em>Statistical Analysis and Modelling of Spatial Point Patterns.</em>
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairorient">pairorient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rose(nnorient(redwood, adjust=0.6), col="grey")
  plot(CDF &lt;- nnorient(redwood, cumulative=TRUE))
</code></pre>

<hr>
<h2 id='pairMean'>
Mean of a Function of Interpoint Distance
</h2><span id='topic+pairMean'></span>

<h3>Description</h3>

<p>Computes the mean value, or the double integral, of a specified
function of the distance between two independent random points
in a given window or windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairMean(fun, W, V = NULL, ..., normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairMean_+3A_fun">fun</code></td>
<td>

<p>A function in the <span class="rlang"><b>R</b></span> language which takes one argument.
</p>
</td></tr>
<tr><td><code id="pairMean_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) containing the
first random point.
</p>
</td></tr>
<tr><td><code id="pairMean_+3A_v">V</code></td>
<td>

<p>Optional. Another window containing the second random point.
Defaults to <code>W</code>.
</p>
</td></tr>
<tr><td><code id="pairMean_+3A_...">...</code></td>
<td>

<p>Further optional arguments passed to <code><a href="#topic+distcdf">distcdf</a></code> to determine the
pixel resolution for the calculation and the
probability distributions of the random points.
</p>
</td></tr>
<tr><td><code id="pairMean_+3A_normalise">normalise</code></td>
<td>

<p>Logical value specifying whether to calculate the mean
value (<code>normalise=TRUE</code>, the default) or the
double integral (<code>normalise=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the mean value of
<code>fun(T)</code> where <code>T</code> is 
the Euclidean distance <code class="reqn">T = \|X_1 - X_2\|</code>
between two independent random points <code class="reqn">X_1</code> and <code class="reqn">X_2</code>.
</p>
<p>In the simplest case, the command <code>pairMean(fun, W)</code>,
the random points are assumed to be uniformly distributed in the same
window <code>W</code>.  Alternatively the two random points may be 
uniformly distributed in two different windows <code>W</code> and <code>V</code>.
Other options are described in <code><a href="#topic+distcdf">distcdf</a></code>.
</p>
<p>The algorithm uses <code><a href="#topic+distcdf">distcdf</a></code> to compute the cumulative
distribution function of <code>T</code>, and <code><a href="#topic+stieltjes">stieltjes</a></code> to
compute the mean value of <code>fun(T)</code>.
</p>
<p>If <code>normalise=TRUE</code> (the default) the result is the mean value of
<code>fun(T)</code>. If <code>normalise=FALSE</code> the result is the double
integral.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distcdf">distcdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pairMean(function(d) { d^2 }, disc())
</code></pre>

<hr>
<h2 id='pairorient'>
Point Pair Orientation Distribution
</h2><span id='topic+pairorient'></span>

<h3>Description</h3>

<p>Computes the distribution of the orientation of vectors joining
pairs of points at a particular range of distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairorient(X, r1, r2, ..., cumulative=FALSE,
           correction, ratio = FALSE,
           unit=c("degree", "radian"), domain=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairorient_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_r1">r1</code>, <code id="pairorient_+3A_r2">r2</code></td>
<td>

<p>Minimum and maximum values of distance
to be considered.
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+circdensity">circdensity</a></code> to control
the kernel smoothing, if <code>cumulative=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_cumulative">cumulative</code></td>
<td>

<p>Logical value specifying whether to estimate the probability density
(<code>cumulative=FALSE</code>, the default) or the cumulative
distribution function (<code>cumulative=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_correction">correction</code></td>
<td>

<p>Character vector specifying edge correction or corrections.
Options are <code>"none"</code>, <code>"isotropic"</code>, <code>"translate"</code>,
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"good"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
The default is to compute all edge corrections except <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_unit">unit</code></td>
<td>

<p>Unit in which the angles should be expressed.
Either <code>"degree"</code> or <code>"radian"</code>.
</p>
</td></tr>
<tr><td><code id="pairorient_+3A_domain">domain</code></td>
<td>

<p>Optional window. The first point <code class="reqn">x_i</code> of each pair of points
will be constrained to lie in <code>domain</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm considers all pairs of points in the pattern
<code>X</code> that lie more than <code>r1</code> and less than <code>r2</code>
units apart. The <em>direction</em> of the arrow joining the points
is measured, as an angle in degrees or radians,
anticlockwise from the <code class="reqn">x</code> axis.
</p>
<p>If <code>cumulative=FALSE</code> (the default),
a kernel estimate of the probability density of the orientations
is calculated using <code><a href="#topic+circdensity">circdensity</a></code>.
</p>
<p>If <code>cumulative=TRUE</code>, then the cumulative distribution
function of these directions is calculated.
This is the function <code class="reqn">O_{r1,r2}(\phi)</code> defined 
in Stoyan and Stoyan (1994), equation (14.53), page 271.
</p>
<p>In either case the result can be plotted as a rose diagram by 
<code><a href="#topic+rose">rose</a></code>, or as a function plot by <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The algorithm gives each observed direction a weight,
determined by an edge correction, to adjust for the fact that some
interpoint distances are more likely to be observed than others.
The choice of edge correction or corrections is determined by the argument
<code>correction</code>. See the help for <code><a href="#topic+Kest">Kest</a></code> for details
of edge corrections, and explanation of the options available.
The choice <code>correction="none"</code> is not recommended;
it is included for demonstration purposes only. The default is to
compute all corrections except <code>"none"</code>.
</p>
<p>It is also possible to calculate an estimate of the probability
density from the cumulative distribution function,
by numerical differentiation. 
Use <code><a href="#topic+deriv.fv">deriv.fv</a></code> with the argument <code>Dperiodic=TRUE</code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the estimates of the probability density or the
cumulative distribution function of angles,
in degrees (if <code>unit="degree"</code>)
or radians (if <code>unit="radian"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, Random Shapes and Point Fields:
Methods of Geometrical Statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>, <code><a href="#topic+Ksector">Ksector</a></code>, <code><a href="#topic+nnorient">nnorient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rose(pairorient(redwood, 0.05, 0.15, sigma=8), col="grey")
  plot(CDF &lt;- pairorient(redwood, 0.05, 0.15, cumulative=TRUE))
  plot(f &lt;- deriv(CDF, spar=0.6, Dperiodic=TRUE))
</code></pre>

<hr>
<h2 id='pairs.im'>
Scatterplot Matrix for Pixel Images
</h2><span id='topic+pairs.im'></span>

<h3>Description</h3>

<p>Produces a scatterplot matrix of the pixel values
in two or more pixel images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
pairs(..., plot=TRUE, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.im_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which is either
a pixel image (object of class <code>"im"</code>)
or a named argument to be passed to <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>.
Alternatively, a single argument which is a list of pixel images.
</p>
</td></tr>
<tr><td><code id="pairs.im_+3A_plot">plot</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the scatterplot matrix is plotted.
</p>
</td></tr>
<tr><td><code id="pairs.im_+3A_drop">drop</code></td>
<td>

<p>Logical value specifying whether pixel values that are <code>NA</code> 
should be removed from the data frame that is returned by the function.
This does not affect the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="graphics.html#topic+pairs">pairs</a></code>
for the class of pixel images.
</p>
<p>It produces a square array of plot panels, in which each panel shows
a scatterplot of the pixel values of one image against the
corresponding pixel values of another image.
</p>
<p>At least two of the arguments <code>...</code>
should be pixel images (objects of class <code>"im"</code>).
Their spatial domains must overlap, but need not have the same
pixel dimensions.
</p>
<p>First the pixel image domains are intersected, and converted to a
common pixel resolution. Then the corresponding pixel values of each image are
extracted. Then <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code> is called to 
plot the scatterplot matrix.
</p>
<p>Any arguments in <code>...</code> which are not pixel images will be
passed to <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code> to control the plot.
</p>
<p>The return value of <code>pairs.im</code> is a data frame, returned
invisibly. The data frame has one column
for each image. Each row contains the pixel values of
the different images for one pixel in the raster.
If <code>drop=TRUE</code> (the default), any row which contains <code>NA</code>
is deleted. The plot is not affected by the value of <code>drop</code>.
</p>


<h3>Value</h3>

<p>Invisible. A <code>data.frame</code> containing the
corresponding pixel values for each image.
The return value also belongs to the class <code>plotpairsim</code> which has
a plot method, so that it can be re-plotted.
</p>


<h3>Image or Contour Plots</h3>

<p>Since the scatterplots may show very dense concentrations of points,
it may be useful to set <code>panel=panel.image</code>
or <code>panel=panel.contour</code> to draw a colour image or contour plot
of the kernel-smoothed density of the scatterplot in each panel.
The argument <code>panel</code> is passed
to <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>. See the help for 
<code><a href="#topic+panel.image">panel.image</a></code> and <code><a href="#topic+panel.contour">panel.contour</a></code>.
</p>


<h3>Low Level Control of Graphics</h3>

<p>To control the appearance of the individual scatterplot panels,
see <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>, <code><a href="graphics.html#topic+points">points</a></code>
or <code><a href="graphics.html#topic+par">par</a></code>.
To control the plotting symbol for the points in the scatterplot,
use the arguments <code>pch</code>, <code>col</code>, <code>bg</code> as described
under <code><a href="graphics.html#topic+points">points</a></code> (because 
the default panel plotter is the function <code><a href="graphics.html#topic+points">points</a></code>).
To suppress the tick marks on the plot axes,
type <code>par(xaxt="n", yaxt="n")</code> before calling <code>pairs</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>,
<code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>,
<code><a href="#topic+panel.contour">panel.contour</a></code>,
<code><a href="#topic+panel.image">panel.image</a></code>,
<code>plot.im</code>,
<code><a href="#topic+cov.im">cov.im</a></code>,
<code>im</code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- density(rpoispp(30))
  Y &lt;- density(rpoispp(40))
  Z &lt;- density(rpoispp(30))
  p &lt;- pairs(X,Y,Z)
  p
  plot(p)
</code></pre>

<hr>
<h2 id='panel.contour'>
Panel Plots using Colour Image or Contour Lines
</h2><span id='topic+panel.contour'></span><span id='topic+panel.image'></span><span id='topic+panel.histogram'></span>

<h3>Description</h3>

<p>These functions can be passed to <code><a href="graphics.html#topic+pairs">pairs</a></code> or
<code><a href="graphics.html#topic+coplot">coplot</a></code>
to determine what kind of plotting is done in each panel
of a multi-panel graphical display. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.contour(x, y, ..., sigma = NULL)

panel.image(x, y, ..., sigma = NULL)

panel.histogram(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.contour_+3A_x">x</code>, <code id="panel.contour_+3A_y">y</code></td>
<td>

<p>Coordinates of points in a scatterplot.
</p>
</td></tr>
<tr><td><code id="panel.contour_+3A_...">...</code></td>
<td>

<p>Extra graphics arguments, passed to <code>contour.im</code>,
<code>plot.im</code> or <code><a href="graphics.html#topic+rect">rect</a></code>, respectively,
to control the appearance of the panel.
</p>
</td></tr>
<tr><td><code id="panel.contour_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth of kernel smoother, on a scale where
<code class="reqn">x</code> and <code class="reqn">y</code> range between 0 and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can serve as one of the arguments <code>panel</code>,
<code>lower.panel</code>, <code>upper.panel</code>, <code>diag.panel</code>
passed to graphics commands like
<code><a href="graphics.html#topic+pairs">pairs</a></code> or <code><a href="graphics.html#topic+coplot">coplot</a></code>,
to determine what kind of plotting is done in each panel
of a multi-panel graphical display. In particular they work
with <code><a href="#topic+pairs.im">pairs.im</a></code>.
</p>
<p>The functions <code>panel.contour</code> and <code>panel.contour</code>
are suitable for the off-diagonal plots which involve
two datasets <code>x</code> and <code>y</code>.
They first rescale <code>x</code> and <code>y</code> to the unit square,
then apply kernel smoothing with bandwidth <code>sigma</code>
using <code><a href="#topic+density.ppp">density.ppp</a></code>.
Then <code>panel.contour</code> draws a contour plot
while <code>panel.image</code> draws a colour image.
</p>
<p>The function <code>panel.histogram</code> is suitable for the
diagonal plots which involve a single dataset <code>x</code>.
It displays a histogram of the data.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs.im">pairs.im</a></code>,
<code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>,
<code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pairs(bei.extra,
        panel      = panel.contour,
        diag.panel = panel.histogram)
  with(bei.extra,
        pairs(grad, elev, 
              panel      = panel.image,
              diag.panel = panel.histogram))
  pairs(marks(finpines), panel=panel.contour, diag.panel=panel.histogram)
</code></pre>

<hr>
<h2 id='pcf'>Pair Correlation Function</h2><span id='topic+pcf'></span>

<h3>Description</h3>

<p>Estimate the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pcf(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf_+3A_x">X</code></td>
<td>

<p>Either the observed data point pattern,
or an estimate of its <code class="reqn">K</code> function,
or an array of multitype <code class="reqn">K</code> functions
(see Details).
</p>
</td></tr>
<tr><td><code id="pcf_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the appropriate method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair correlation function of a stationary point process is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \frac{K'(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'(r)</code> is the derivative of <code class="reqn">K(r)</code>, the
reduced second moment function (aka &ldquo;Ripley's <code class="reqn">K</code> function&rdquo;)
of the point process. See <code><a href="#topic+Kest">Kest</a></code> for information
about <code class="reqn">K(r)</code>. For a stationary Poisson process, the
pair correlation function is identically equal to 1. Values
<code class="reqn">g(r) &lt; 1</code> suggest inhibition between points;
values greater than 1 suggest clustering.
</p>
<p>We also apply the same definition to
other variants of the classical <code class="reqn">K</code> function,
such as the multitype <code class="reqn">K</code> functions
(see <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>) and the
inhomogeneous <code class="reqn">K</code> function (see <code><a href="#topic+Kinhom">Kinhom</a></code>).
For all these variants, the benchmark value of
<code class="reqn">K(r) = \pi r^2</code> corresponds to
<code class="reqn">g(r) = 1</code>.
</p>
<p>This routine computes an estimate of <code class="reqn">g(r)</code>
either directly from a point pattern,
or indirectly from an estimate of <code class="reqn">K(r)</code> or one of its variants.
</p>
<p>This function is generic, with methods for
the classes <code>"ppp"</code>, <code>"fv"</code> and <code>"fasp"</code>.
</p>
<p>If <code>X</code> is a point pattern (object of class <code>"ppp"</code>)
then the pair correlation function is estimated using
a traditional kernel smoothing method (Stoyan and Stoyan, 1994).
See <code><a href="#topic+pcf.ppp">pcf.ppp</a></code> for details.
</p>
<p>If <code>X</code> is a function value table (object of class <code>"fv"</code>),
then it is assumed to contain estimates of the <code class="reqn">K</code> function
or one of its variants (typically obtained from <code><a href="#topic+Kest">Kest</a></code> or
<code><a href="#topic+Kinhom">Kinhom</a></code>).
This routine computes an estimate of <code class="reqn">g(r)</code> 
using smoothing splines to approximate the derivative.
See <code><a href="#topic+pcf.fv">pcf.fv</a></code> for details.
</p>
<p>If <code>X</code> is a function value array (object of class <code>"fasp"</code>),
then it is assumed to contain estimates of several <code class="reqn">K</code> functions
(typically obtained from <code><a href="#topic+Kmulti">Kmulti</a></code> or
<code><a href="#topic+alltypes">alltypes</a></code>). This routine computes
an estimate of <code class="reqn">g(r)</code> for each cell in the array,
using smoothing splines to approximate the derivatives.
See <code><a href="#topic+pcf.fasp">pcf.fasp</a></code> for details.
</p>


<h3>Value</h3>

<p>Either a function value table
(object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>)
representing a pair correlation function,
or a function array (object of class <code>"fasp"</code>,
see <code><a href="#topic+fasp.object">fasp.object</a></code>)
representing an array of pair correlation functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf.ppp">pcf.ppp</a></code>,
<code><a href="#topic+pcf.fv">pcf.fv</a></code>,
<code><a href="#topic+pcf.fasp">pcf.fasp</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+alltypes">alltypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # ppp object
  X &lt;- simdat
  
  p &lt;- pcf(X)
  plot(p)

  # fv object
  K &lt;- Kest(X)
  p2 &lt;- pcf(K, spar=0.8, method="b")
  plot(p2)

  # multitype pattern; fasp object
  amaK &lt;- alltypes(amacrine, "K")
  amap &lt;- pcf(amaK, spar=1, method="b")
  plot(amap)
</code></pre>

<hr>
<h2 id='pcf.fasp'>Pair Correlation Function obtained from array of K functions</h2><span id='topic+pcf.fasp'></span>

<h3>Description</h3>

<p>Estimates the (bivariate) pair correlation functions of
a point pattern, given an array of (bivariate) K functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'fasp'
pcf(X, ..., method="c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf.fasp_+3A_x">X</code></td>
<td>

<p>An array of multitype <code class="reqn">K</code> functions
(object of class <code>"fasp"</code>).
</p>
</td></tr>
<tr><td><code id="pcf.fasp_+3A_...">...</code></td>
<td>

<p>Arguments controlling the smoothing spline
function <code>smooth.spline</code>.
</p>
</td></tr>
<tr><td><code id="pcf.fasp_+3A_method">method</code></td>
<td>

<p>Letter <code>"a"</code>, <code>"b"</code>, <code>"c"</code> or <code>"d"</code> indicating the
method for deriving the pair correlation function from the
<code>K</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair correlation function of a stationary point process is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \frac{K'(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'(r)</code> is the derivative of <code class="reqn">K(r)</code>, the
reduced second moment function (aka &ldquo;Ripley's <code class="reqn">K</code> function&rdquo;)
of the point process. See <code><a href="#topic+Kest">Kest</a></code> for information
about <code class="reqn">K(r)</code>. For a stationary Poisson process, the
pair correlation function is identically equal to 1. Values
<code class="reqn">g(r) &lt; 1</code> suggest inhibition between points;
values greater than 1 suggest clustering.
</p>
<p>We also apply the same definition to
other variants of the classical <code class="reqn">K</code> function,
such as the multitype <code class="reqn">K</code> functions
(see <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>) and the
inhomogeneous <code class="reqn">K</code> function (see <code><a href="#topic+Kinhom">Kinhom</a></code>).
For all these variants, the benchmark value of
<code class="reqn">K(r) = \pi r^2</code> corresponds to
<code class="reqn">g(r) = 1</code>.
</p>
<p>This routine computes an estimate of <code class="reqn">g(r)</code>
from an array of estimates of <code class="reqn">K(r)</code> or its variants,
using smoothing splines to approximate the derivatives.
It is a method for the generic function <code><a href="#topic+pcf">pcf</a></code>.
</p>
<p>The argument <code>X</code> should be
a function array (object of class <code>"fasp"</code>,
see <code><a href="#topic+fasp.object">fasp.object</a></code>)
containing several estimates of <code class="reqn">K</code> functions.
This should have been obtained from <code><a href="#topic+alltypes">alltypes</a></code>
with the argument <code>fun="K"</code>.
</p>
<p>The smoothing spline operations are performed by
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> and <code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>
from the <code>modreg</code> library.
Four numerical methods are available:
</p>

<ul>
<li>
<p><b>&quot;a&quot;</b> apply smoothing to <code class="reqn">K(r)</code>,
estimate its derivative, and plug in to the formula above;
</p>
</li>
<li> 
<p><b>&quot;b&quot;</b> apply smoothing to
<code class="reqn">Y(r) = \frac{K(r)}{2 \pi r}</code>
constraining <code class="reqn">Y(0) = 0</code>,
estimate the derivative of <code class="reqn">Y</code>, and solve;
</p>
</li>
<li>
<p><b>&quot;c&quot;</b> apply smoothing to 
<code class="reqn">Z(r) = \frac{K(r)}{\pi r^2}</code>
constraining <code class="reqn">Z(0)=1</code>,
estimate its derivative, and solve.
</p>
</li>
<li>
<p><b>&quot;d&quot;</b> apply smoothing to 
<code class="reqn">V(r) = \sqrt{K(r)}</code>,
estimate its derivative, and solve.
</p>
</li></ul>

<p>Method <code>"c"</code> seems to be the best at 
suppressing variability for small values of <code class="reqn">r</code>.
However it effectively constrains <code class="reqn">g(0) = 1</code>.
If the point pattern seems to have inhibition at small distances,
you may wish to experiment with method <code>"b"</code> which effectively
constrains <code class="reqn">g(0)=0</code>. Method <code>"a"</code> seems
comparatively unreliable.
</p>
<p>Useful arguments to control the splines
include the smoothing tradeoff parameter <code>spar</code>
and the degrees of freedom <code>df</code>. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
for details.
</p>


<h3>Value</h3>

<p>A function array (object of class <code>"fasp"</code>,
see <code><a href="#topic+fasp.object">fasp.object</a></code>)
representing an array of pair correlation functions.
This can be thought of as a matrix <code>Y</code> each of whose entries
<code>Y[i,j]</code> is a function value table (class <code>"fv"</code>)
representing the pair correlation function between
points of type <code>i</code> and points of type <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+alltypes">alltypes</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multitype point pattern
  KK &lt;- alltypes(amacrine, "K")
  p &lt;- pcf.fasp(KK, spar=0.5, method="b")
  plot(p)
  # strong inhibition between points of the same type
</code></pre>

<hr>
<h2 id='pcf.fv'>Pair Correlation Function obtained from K Function</h2><span id='topic+pcf.fv'></span>

<h3>Description</h3>

<p>Estimates the pair correlation function of
a point pattern, given an estimate of the K function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fv'
pcf(X, ..., method="c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf.fv_+3A_x">X</code></td>
<td>

<p>An estimate of the <code class="reqn">K</code> function
or one of its variants.
An object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="pcf.fv_+3A_...">...</code></td>
<td>

<p>Arguments controlling the smoothing spline
function <code>smooth.spline</code>.
</p>
</td></tr>
<tr><td><code id="pcf.fv_+3A_method">method</code></td>
<td>

<p>Letter <code>"a"</code>, <code>"b"</code>, <code>"c"</code> or <code>"d"</code> indicating the
method for deriving the pair correlation function from the
<code>K</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair correlation function of a stationary point process is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \frac{K'(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'(r)</code> is the derivative of <code class="reqn">K(r)</code>, the
reduced second moment function (aka &ldquo;Ripley's <code class="reqn">K</code> function&rdquo;)
of the point process. See <code><a href="#topic+Kest">Kest</a></code> for information
about <code class="reqn">K(r)</code>. For a stationary Poisson process, the
pair correlation function is identically equal to 1. Values
<code class="reqn">g(r) &lt; 1</code> suggest inhibition between points;
values greater than 1 suggest clustering.
</p>
<p>We also apply the same definition to
other variants of the classical <code class="reqn">K</code> function,
such as the multitype <code class="reqn">K</code> functions
(see <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kdot">Kdot</a></code>) and the
inhomogeneous <code class="reqn">K</code> function (see <code><a href="#topic+Kinhom">Kinhom</a></code>).
For all these variants, the benchmark value of
<code class="reqn">K(r) = \pi r^2</code> corresponds to
<code class="reqn">g(r) = 1</code>.
</p>
<p>This routine computes an estimate of <code class="reqn">g(r)</code>
from an estimate of <code class="reqn">K(r)</code> or its variants,
using smoothing splines to approximate the derivative.
It is a method for the generic function <code><a href="#topic+pcf">pcf</a></code>
for the class <code>"fv"</code>.
</p>
<p>The argument <code>X</code> should be an estimated <code class="reqn">K</code> function,
given as a function value table (object of class <code>"fv"</code>,
see <code><a href="#topic+fv.object">fv.object</a></code>).
This object should be the value returned by
<code><a href="#topic+Kest">Kest</a></code>, <code><a href="#topic+Kcross">Kcross</a></code>, <code><a href="#topic+Kmulti">Kmulti</a></code>
or <code><a href="#topic+Kinhom">Kinhom</a></code>.
</p>
<p>The smoothing spline operations are performed by
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> and <code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>
from the <code>modreg</code> library.
Four numerical methods are available:
</p>

<ul>
<li>
<p><b>&quot;a&quot;</b> apply smoothing to <code class="reqn">K(r)</code>,
estimate its derivative, and plug in to the formula above;
</p>
</li>
<li> 
<p><b>&quot;b&quot;</b> apply smoothing to
<code class="reqn">Y(r) = \frac{K(r)}{2 \pi r}</code>
constraining <code class="reqn">Y(0) = 0</code>,
estimate the derivative of <code class="reqn">Y</code>, and solve;
</p>
</li>
<li>
<p><b>&quot;c&quot;</b> apply smoothing to 
<code class="reqn">Z(r) = \frac{K(r)}{\pi r^2}</code>
constraining <code class="reqn">Z(0)=1</code>,
estimate its derivative, and solve.
</p>
</li>
<li>
<p><b>&quot;d&quot;</b> apply smoothing to 
<code class="reqn">V(r) = \sqrt{K(r)}</code>,
estimate its derivative, and solve.
</p>
</li></ul>

<p>Method <code>"c"</code> seems to be the best at 
suppressing variability for small values of <code class="reqn">r</code>.
However it effectively constrains <code class="reqn">g(0) = 1</code>.
If the point pattern seems to have inhibition at small distances,
you may wish to experiment with method <code>"b"</code> which effectively
constrains <code class="reqn">g(0)=0</code>. Method <code>"a"</code> seems
comparatively unreliable.
</p>
<p>Useful arguments to control the splines
include the smoothing tradeoff parameter <code>spar</code>
and the degrees of freedom <code>df</code>. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
for details.
</p>


<h3>Value</h3>

<p>A function value table
(object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>)
representing a pair correlation function.
</p>
<p>Essentially a data frame containing (at least) the variables
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the pair correlation function <code class="reqn">g(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>pcf</code></td>
<td>
<p>vector of values of <code class="reqn">g(r)</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf">pcf</a></code>,
<code><a href="#topic+pcf.ppp">pcf.ppp</a></code>,
<code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>,
<code><a href="#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+Kmulti">Kmulti</a></code>,
<code><a href="#topic+alltypes">alltypes</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # univariate point pattern
  X &lt;- simdat
  
  K &lt;- Kest(X)
  p &lt;- pcf.fv(K, spar=0.5, method="b")
  plot(p, main="pair correlation function for simdat")
  # indicates inhibition at distances r &lt; 0.3
</code></pre>

<hr>
<h2 id='pcf.ppp'>Pair Correlation Function of Point Pattern</h2><span id='topic+pcf.ppp'></span>

<h3>Description</h3>

<p>Estimates the pair correlation function of
a point pattern using kernel methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
pcf(X, ..., r = NULL, kernel="epanechnikov", bw=NULL,
                    stoyan=0.15,
                    correction=c("translate", "Ripley"),
                    divisor = c("r", "d"),
                    var.approx = FALSE,
                    domain=NULL,
                    ratio=FALSE, close=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">g(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
Either a single numeric value giving the standard deviation of the kernel,
or a character string specifying a bandwidth selection rule
recognised by <code><a href="stats.html#topic+density.default">density.default</a></code>.
If <code>bw</code> is missing or <code>NULL</code>,
the default value is computed using
Stoyan's rule of thumb: see Details.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the kernel density estimation 
function <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_stoyan">stoyan</code></td>
<td>

<p>Coefficient for Stoyan's bandwidth selection rule; see Details.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_correction">correction</code></td>
<td>

<p>Edge correction. A character vector specifying the choice
(or choices) of edge correction. See Details.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_var.approx">var.approx</code></td>
<td>

<p>Logical value indicating whether to compute an analytic
approximation to the variance of the estimated pair correlation.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_domain">domain</code></td>
<td>

<p>Optional. Calculations will be restricted to this subset
of the window. See Details.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="pcf.ppp_+3A_close">close</code></td>
<td>

<p>Advanced use only. Precomputed data. See section on Advanced Use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair correlation function <code class="reqn">g(r)</code> 
is a summary of the dependence between points in a spatial point
process. The best intuitive interpretation is the following: the probability
<code class="reqn">p(r)</code> of finding two points at locations <code class="reqn">x</code> and <code class="reqn">y</code>
separated by a distance <code class="reqn">r</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda^2 g(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity of the point process.
For a completely random (uniform Poisson) process,
<code class="reqn">p(r) = \lambda^2 \,{\rm d}x \, {\rm d}y</code>
so <code class="reqn">g(r) = 1</code>.
Formally, the pair correlation function of a stationary point process
is defined by 
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \frac{K'(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'(r)</code> is the derivative of <code class="reqn">K(r)</code>, the
reduced second moment function (aka &ldquo;Ripley's <code class="reqn">K</code> function&rdquo;)
of the point process. See <code><a href="#topic+Kest">Kest</a></code> for information
about <code class="reqn">K(r)</code>.
</p>
<p>For a stationary Poisson process, the
pair correlation function is identically equal to 1. Values
<code class="reqn">g(r) &lt; 1</code> suggest inhibition between points;
values greater than 1 suggest clustering.
</p>
<p>This routine computes an estimate of <code class="reqn">g(r)</code>
by kernel smoothing. 
</p>

<ul>
<li>
<p>If <code>divisor="r"</code> (the default), then the standard
kernel estimator (Stoyan and Stoyan, 1994, pages 284&ndash;285)
is used. By default, the recommendations of Stoyan and Stoyan (1994)
are followed exactly. 
</p>
</li>
<li>
<p>If <code>divisor="d"</code> then a modified estimator is used
(Guan, 2007): the contribution from
an interpoint distance <code class="reqn">d_{ij}</code> to the
estimate of <code class="reqn">g(r)</code> is divided by <code class="reqn">d_{ij}</code>
instead of dividing by <code class="reqn">r</code>. This usually improves the
bias of the estimator when <code class="reqn">r</code> is close to zero.
</p>
</li></ul>

<p>There is also a choice of spatial edge corrections
(which are needed to avoid bias due to edge effects
associated with the boundary of the spatial window):
</p>

<ul>
<li>
<p>If <code>correction="translate"</code> or <code>correction="translation"</code>
then the translation correction
is used. For <code>divisor="r"</code> the translation-corrected estimate
is given in equation (15.15), page 284 of Stoyan and Stoyan (1994).
</p>
</li>
<li>
<p>If <code>correction="Ripley"</code> or <code>correction="isotropic"</code>
then Ripley's isotropic edge correction
is used. For <code>divisor="r"</code> the isotropic-corrected estimate
is given in equation (15.18), page 285 of Stoyan and Stoyan (1994). 
</p>
</li>
<li>
<p>If <code>correction="none"</code> then no edge correction is used,
that is, an uncorrected estimate is computed. 
</p>
</li></ul>

<p>Multiple corrections can be selected. The default is
<code>correction=c("translate", "Ripley")</code>.
</p>
<p>Alternatively <code>correction="all"</code> selects all options;
<code>correction="best"</code> selects the option which has the best
statistical performance; <code>correction="good"</code> selects the option
which is the best compromise between statistical performance and speed
of computation.
</p>
<p>The choice of smoothing kernel is controlled by the 
argument <code>kernel</code> which is passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
The default is the Epanechnikov kernel, recommended by
Stoyan and Stoyan (1994, page 285).
</p>
<p>The bandwidth of the smoothing kernel can be controlled by the
argument <code>bw</code>. Bandwidth is defined as the standard deviation
of the kernel; see the documentation for <code><a href="stats.html#topic+density.default">density.default</a></code>.
For the Epanechnikov kernel with half-width <code>h</code>,
the argument <code>bw</code> is equivalent to <code class="reqn">h/\sqrt{5}</code>.
</p>
<p>Stoyan and Stoyan (1994, page 285) recommend using the Epanechnikov
kernel with support <code class="reqn">[-h,h]</code> chosen by the rule of thumn
<code class="reqn">h = c/\sqrt{\lambda}</code>,
where <code class="reqn">\lambda</code> is the (estimated) intensity of the
point process, and <code class="reqn">c</code> is a constant in the range from 0.1 to 0.2.
See equation (15.16).
If <code>bw</code> is missing or <code>NULL</code>,
then this rule of thumb will be applied.
The argument <code>stoyan</code> determines the value of <code class="reqn">c</code>.
The smoothing bandwidth that was used in the calculation is returned
as an attribute of the final result.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">g(r)</code> should be evaluated.
There is a sensible default.
If it is specified, <code>r</code> must be a vector of increasing numbers
starting from <code>r[1] = 0</code>, 
and <code>max(r)</code> must not exceed half the diameter of 
the window.
</p>
<p>If the argument <code>domain</code> is given, estimation will be restricted
to this region. That is, the estimate of 
<code class="reqn">g(r)</code> will be based on pairs of points in which the first point lies
inside <code>domain</code> and the second point is unrestricted.
The argument <code>domain</code>
should be a window (object of class <code>"owin"</code>) or something acceptable to
<code>as.owin</code>. It must be a subset of the
window of the point pattern <code>X</code>.
</p>
<p>To compute a confidence band for the true value of the
pair correlation function, use <code><a href="#topic+lohboot">lohboot</a></code>.
</p>
<p>If <code>var.approx = TRUE</code>, the variance of the
estimate of the pair correlation will also be calculated using
an analytic approximation (Illian et al, 2008, page 234)
which is valid for stationary point processes which are not
too clustered. This calculation is not yet implemented when
the argument <code>domain</code> is given.
</p>


<h3>Value</h3>

<p>A function value table
(object of class <code>"fv"</code>).
Essentially a data frame containing the variables
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the pair correlation function <code class="reqn">g(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values equal to 1,
the theoretical value of <code class="reqn">g(r)</code> for the Poisson process
</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>vector of values of <code class="reqn">g(r)</code>
estimated by translation correction
</p>
</td></tr>
<tr><td><code>iso</code></td>
<td>
<p>vector of values of <code class="reqn">g(r)</code>
estimated by Ripley isotropic correction
</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>vector of approximate values of the variance of
the estimate of <code class="reqn">g(r)</code>
</p>
</td></tr>
</table>
<p>as required.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">g(r)</code>.
</p>
<p>The return value also has an attribute <code>"bw"</code> giving the
smoothing bandwidth that was used.
</p>


<h3>Advanced Use</h3>

<p>To perform the same computation using several different bandwidths <code>bw</code>,
it is efficient to use the argument <code>close</code>.
This should be the result of <code>closepairs(X, rmax)</code>
for a suitably large value of <code>rmax</code>, namely
<code>rmax &gt;= max(r) + 3 * bw</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>References</h3>

<p>Guan, Y. (2007)
A least-squares cross-validation bandwidth selection approach in pair
correlation function estimation.
<em>Statistics and Probability Letters</em> <b>77</b> (18) 1722&ndash;1729.
</p>
<p>Illian, J., Penttinen, A., Stoyan, H. and Stoyan, D. (2008)
<em>Statistical Analysis and Modelling of Spatial Point Patterns.</em>
Wiley.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
<em>Fractals, random shapes and point fields:
methods of geometrical statistics.</em>
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>,
<code><a href="#topic+pcf">pcf</a></code>,
<code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+bw.stoyan">bw.stoyan</a></code>,
<code><a href="#topic+bw.pcf">bw.pcf</a></code>,
<code><a href="#topic+lohboot">lohboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- simdat
  
  p &lt;- pcf(X)
  plot(p, main="pair correlation function for X")
  # indicates inhibition at distances r &lt; 0.3

  pd &lt;- pcf(X, divisor="d")

  # compare estimates
  plot(p, cbind(iso, theo) ~ r, col=c("blue", "red"),
         ylim.covers=0, main="", lwd=c(2,1), lty=c(1,3), legend=FALSE)
  plot(pd, iso ~ r, col="green", lwd=2, add=TRUE)
  legend("center", col=c("blue", "green"), lty=1, lwd=2,
         legend=c("divisor=r","divisor=d"))

  # calculate approximate variance and show POINTWISE confidence bands
  pv &lt;- pcf(X, var.approx=TRUE)
  plot(pv, cbind(iso, iso+2*sqrt(v), iso-2*sqrt(v)) ~ r)
</code></pre>

<hr>
<h2 id='pcf3est'>
Pair Correlation Function of a Three-Dimensional Point Pattern
</h2><span id='topic+pcf3est'></span>

<h3>Description</h3>

<p>Estimates the pair correlation function
from a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   pcf3est(X, ..., rmax = NULL, nrval = 128,
           correction = c("translation", "isotropic"),
           delta=NULL, adjust=1, biascorrect=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf3est_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum value of argument <code class="reqn">r</code> for which
<code class="reqn">g_3(r)</code> will be estimated. 
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_nrval">nrval</code></td>
<td>

<p>Optional. Number of values of <code class="reqn">r</code> for which
<code class="reqn">g_3(r)</code> will be estimated. 
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_correction">correction</code></td>
<td>

<p>Optional. Character vector specifying the edge correction(s)
to be applied. See Details.
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_delta">delta</code></td>
<td>

<p>Optional. Half-width of the Epanechnikov smoothing kernel.
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the default value of <code>delta</code>.
</p>
</td></tr>
<tr><td><code id="pcf3est_+3A_biascorrect">biascorrect</code></td>
<td>

<p>Logical value. Whether to correct for underestimation due to
truncation of the kernel near <code class="reqn">r=0</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a stationary point process <code class="reqn">\Phi</code> in three-dimensional
space, the pair correlation function is
</p>
<p style="text-align: center;"><code class="reqn">
    g_3(r) = \frac{K_3'(r)}{4\pi r^2}
  </code>
</p>

<p>where <code class="reqn">K_3'</code> is the derivative of the
three-dimensional <code class="reqn">K</code>-function (see <code><a href="#topic+K3est">K3est</a></code>).
</p>
<p>The three-dimensional point pattern <code>X</code> is assumed to be a
partial realisation of a stationary point process <code class="reqn">\Phi</code>.
The distance between each pair of distinct points is computed.
Kernel smoothing is applied to these distance values (weighted by
an edge correction factor) and the result is 
renormalised to give the estimate of <code class="reqn">g_3(r)</code>.
</p>
<p>The available edge corrections are:
</p>

<dl>
<dt><code>"translation"</code>:</dt><dd>
<p>the Ohser translation correction estimator
(Ohser, 1983; Baddeley et al, 1993)
</p>
</dd>
<dt><code>"isotropic"</code>:</dt><dd>
<p>the three-dimensional counterpart of
Ripley's isotropic edge correction (Ripley, 1977; Baddeley et al, 1993).
</p>
</dd>
</dl>

<p>Kernel smoothing is performed using the Epanechnikov kernel
with half-width <code>delta</code>. If <code>delta</code> is missing, the
default is to use the rule-of-thumb
<code class="reqn">\delta = 0.26/\lambda^{1/3}</code> where
<code class="reqn">\lambda = n/v</code> is the estimated intensity, computed
from the number <code class="reqn">n</code> of data points and the volume <code class="reqn">v</code> of the
enclosing box. This default value of <code>delta</code> is multiplied by
the factor <code>adjust</code>. 
</p>
<p>The smoothing estimate of the pair correlation <code class="reqn">g_3(r)</code>
is typically an underestimate when <code class="reqn">r</code> is small, due to
truncation of the kernel at <code class="reqn">r=0</code>. 
If <code>biascorrect=TRUE</code>, the smoothed estimate is
approximately adjusted for this bias. This is advisable whenever
the dataset contains a sufficiently large number of points.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>) that can be
plotted, printed or coerced to a data frame containing the function
values.
</p>
<p>Additionally the value of <code>delta</code> is returned as an attribute
of this object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rana Moyeed.
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A. (1993)
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b>, 641&ndash;668.
</p>
<p>Ohser, J. (1983)
On estimators for the reduced second moment measure of
point processes. <em>Mathematische Operationsforschung und
Statistik, series Statistics</em>, <b>14</b>, 63 &ndash; 71.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code>pp3</code> to create a three-dimensional point
pattern (object of class <code>"pp3"</code>).
</p>
<p><code><a href="#topic+F3est">F3est</a></code>,
<code><a href="#topic+G3est">G3est</a></code>,
<code><a href="#topic+K3est">K3est</a></code> for other summary functions of
a three-dimensional point pattern.
</p>
<p><code><a href="#topic+pcf">pcf</a></code> to estimate the pair correlation function of
point patterns in two dimensions or other spaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp3(250)
  Z &lt;- pcf3est(X)
  Zbias &lt;- pcf3est(X, biascorrect=FALSE)
  if(interactive()) {
    opa &lt;- par(mfrow=c(1,2))
    plot(Z,     ylim.covers=c(0, 1.2))
    plot(Zbias, ylim.covers=c(0, 1.2))
    par(opa)
  }
  attr(Z, "delta")
</code></pre>

<hr>
<h2 id='pcfcross'>Multitype pair correlation function (cross-type)</h2><span id='topic+pcfcross'></span>

<h3>Description</h3>

<p>Calculates an estimate of the cross-type pair correlation function
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pcfcross(X, i, j, ..., 
           r = NULL, 
           kernel = "epanechnikov", bw = NULL, stoyan = 0.15,
           correction = c("isotropic", "Ripley", "translate"),
           divisor = c("r", "d"),
           ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross-type pair correlation function
<code class="reqn">g_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). 
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">g(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for smoothing kernel, 
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_stoyan">stoyan</code></td>
<td>

<p>Coefficient for default bandwidth rule; see Details.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_correction">correction</code></td>
<td>

<p>Choice of edge correction.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="pcfcross_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-type pair correlation function
is a generalisation of the pair correlation function <code><a href="#topic+pcf">pcf</a></code>
to multitype point patterns.
</p>
<p>For two locations <code class="reqn">x</code> and <code class="reqn">y</code> separated by a distance <code class="reqn">r</code>,
the probability <code class="reqn">p(r)</code> of finding a point of type <code class="reqn">i</code> at location
<code class="reqn">x</code> and a point of type <code class="reqn">j</code> at location <code class="reqn">y</code> is 
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda_i \lambda_j g_{i,j}(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda_i</code> is the intensity of the points
of type <code class="reqn">i</code>. 
For a completely random Poisson marked point process,
<code class="reqn">p(r) = \lambda_i \lambda_j</code>
so <code class="reqn">g_{i,j}(r) = 1</code>.
Indeed for any marked point pattern in which the points of type <code>i</code>
are independent of the points of type <code>j</code>,
the theoretical value of the cross-type pair correlation is
<code class="reqn">g_{i,j}(r) = 1</code>.
</p>
<p>For a stationary multitype point process, the cross-type pair correlation
function between marks <code class="reqn">i</code> and <code class="reqn">j</code> is formally defined as
</p>
<p style="text-align: center;"><code class="reqn">
    g_{i,j}(r) = \frac{K_{i,j}^\prime(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K_{i,j}^\prime</code> is the derivative of
the cross-type <code class="reqn">K</code> function <code class="reqn">K_{i,j}(r)</code>.
of the point process. See <code><a href="#topic+Kest">Kest</a></code> for information
about <code class="reqn">K(r)</code>. 
</p>
<p>The command <code>pcfcross</code> computes a kernel estimate of
the cross-type pair correlation function between marks <code class="reqn">i</code> and
<code class="reqn">j</code>. 
</p>

<ul>
<li>
<p>If <code>divisor="r"</code> (the default), then the multitype
counterpart of the standard
kernel estimator (Stoyan and Stoyan, 1994, pages 284&ndash;285)
is used. By default, the recommendations of Stoyan and Stoyan (1994)
are followed exactly. 
</p>
</li>
<li>
<p>If <code>divisor="d"</code> then a modified estimator is used:
the contribution from
an interpoint distance <code class="reqn">d_{ij}</code> to the
estimate of <code class="reqn">g(r)</code> is divided by <code class="reqn">d_{ij}</code>
instead of dividing by <code class="reqn">r</code>. This usually improves the
bias of the estimator when <code class="reqn">r</code> is close to zero.
</p>
</li></ul>

<p>There is also a choice of spatial edge corrections
(which are needed to avoid bias due to edge effects
associated with the boundary of the spatial window):
<code>correction="translate"</code> is the Ohser-Stoyan translation
correction, and <code>correction="isotropic"</code> or <code>"Ripley"</code>
is Ripley's isotropic correction.  
</p>
<p>The choice of smoothing kernel is controlled by the 
argument <code>kernel</code> which is passed to <code><a href="stats.html#topic+density">density</a></code>.
The default is the Epanechnikov kernel.
</p>
<p>The bandwidth of the smoothing kernel can be controlled by the
argument <code>bw</code>. Its precise interpretation
is explained in the documentation for <code><a href="stats.html#topic+density.default">density.default</a></code>.
For the Epanechnikov kernel with support <code class="reqn">[-h,h]</code>,
the argument <code>bw</code> is equivalent to <code class="reqn">h/\sqrt{5}</code>.
</p>
<p>If <code>bw</code> is not specified, the default bandwidth
is determined by Stoyan's rule of thumb (Stoyan and Stoyan, 1994, page
285) applied to the points of type <code>j</code>. That is,
<code class="reqn">h = c/\sqrt{\lambda}</code>,
where <code class="reqn">\lambda</code> is the (estimated) intensity of the
point process of type <code>j</code>,
and <code class="reqn">c</code> is a constant in the range from 0.1 to 0.2.
The argument <code>stoyan</code> determines the value of <code class="reqn">c</code>.
</p>
<p>The companion function <code><a href="#topic+pcfdot">pcfdot</a></code> computes the
corresponding analogue of <code><a href="#topic+Kdot">Kdot</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">g_{i,j}</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">g_{i,j}(r) = 1</code>
for independent marks.
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">g_{i,j}</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Mark connection function <code><a href="#topic+markconnect">markconnect</a></code>.
</p>
<p>Multitype pair correlation <code><a href="#topic+pcfdot">pcfdot</a></code>, <code><a href="#topic+pcfmulti">pcfmulti</a></code>.
</p>
<p>Pair correlation <code><a href="#topic+pcf">pcf</a></code>,<code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
</p>
<p><code><a href="#topic+Kcross">Kcross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> p &lt;- pcfcross(amacrine, "off", "on")
 p &lt;- pcfcross(amacrine, "off", "on", stoyan=0.1)
 plot(p)
</code></pre>

<hr>
<h2 id='pcfcross.inhom'>
Inhomogeneous Multitype Pair Correlation Function (Cross-Type)
</h2><span id='topic+pcfcross.inhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous cross-type pair correlation function
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcfcross.inhom(X, i, j, lambdaI = NULL, lambdaJ = NULL, ...,
               r = NULL, breaks = NULL,
               kernel="epanechnikov", bw=NULL, adjust.bw = 1, stoyan=0.15,
               correction = c("isotropic", "Ripley", "translate"),
               sigma = NULL, adjust.sigma = 1, varcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous
cross-type pair correlation function
<code class="reqn">g_{ij}(r)</code>
will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). 
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_j">j</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> to which distances are measured.
A character string (or something that will be
converted to a character string).
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity function of the points of type <code>i</code>.
Either a vector giving the intensity values
at the points of type <code>i</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Optional.
Values of the estimated intensity function of the points of type <code>j</code>.
A numeric vector, pixel image or <code>function(x,y)</code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which
<code class="reqn">g_{ij}(r)</code>
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_kernel">kernel</code></td>
<td>

<p>Choice of one-dimensional smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for one-dimensional smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the one-dimensional kernel density estimation 
function <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_stoyan">stoyan</code></td>
<td>

<p>Bandwidth coefficient; see Details.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_correction">correction</code></td>
<td>

<p>Choice of edge correction.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_sigma">sigma</code>, <code id="pcfcross.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambdaI</code> or
<code>lambdaJ</code> is estimated by spatial kernel smoothing.
</p>
</td></tr>
<tr><td><code id="pcfcross.inhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inhomogeneous cross-type pair correlation function
<code class="reqn">g_{ij}(r)</code>
is a summary of the dependence between two types of points in a
multitype spatial point process that does not have a uniform
density of points.
</p>
<p>The best intuitive interpretation is the following: the probability
<code class="reqn">p(r)</code> of finding two points, of types <code class="reqn">i</code> and <code class="reqn">j</code>
respectively, at locations <code class="reqn">x</code> and <code class="reqn">y</code>
separated by a distance <code class="reqn">r</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda_i(x) lambda_j(y) g(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda_i</code> is the intensity function
of the process of points of type <code class="reqn">i</code>.
For a multitype Poisson point process,
this probability is 
<code class="reqn">p(r) = \lambda_i(x) \lambda_j(y)</code>
so   <code class="reqn">g_{ij}(r) = 1</code>.
</p>
<p>The command <code>pcfcross.inhom</code> estimates the inhomogeneous
pair correlation using a modified version of
the algorithm in <code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
The arguments <code>bw</code> and <code>adjust.bw</code> control the
degree of one-dimensional smoothing of the estimate of pair correlation.
</p>
<p>If the arguments <code>lambdaI</code> and/or <code>lambdaJ</code> are missing or
null, they will be estimated from <code>X</code> by spatial kernel smoothing
using a leave-one-out estimator, computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
The arguments <code>sigma</code>, <code>varcov</code>
and <code>adjust.sigma</code> control the degree of spatial smoothing.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>).
Essentially a data frame containing the variables
</p>
<table>
<tr><td><code>r</code></td>
<td>

<p>the vector of values of the argument <code class="reqn">r</code> 
at which the inhomogeneous cross-type pair correlation function
<code class="reqn">g_{ij}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values equal to 1,
the theoretical value of <code class="reqn">g_{ij}(r)</code>
for the Poisson process
</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>vector of values of <code class="reqn">g_{ij}(r)</code>
estimated by translation correction
</p>
</td></tr>
<tr><td><code>iso</code></td>
<td>
<p>vector of values of <code class="reqn">g_{ij}(r)</code>
estimated by Ripley isotropic correction
</p>
</td></tr>
</table>
<p>as required.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf.ppp">pcf.ppp</a></code>, 
<code><a href="#topic+pcfinhom">pcfinhom</a></code>, 
<code><a href="#topic+pcfcross">pcfcross</a></code>,
<code><a href="#topic+pcfdot.inhom">pcfdot.inhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(pcfcross.inhom(amacrine, "on", "off", stoyan=0.1),
       legendpos="bottom")
</code></pre>

<hr>
<h2 id='pcfdot'>Multitype pair correlation function (i-to-any)</h2><span id='topic+pcfdot'></span>

<h3>Description</h3>

<p>Calculates an estimate of the multitype pair correlation function
(from points of type <code>i</code> to points of any type)
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pcfdot(X, i, ..., r = NULL,
         kernel = "epanechnikov", bw = NULL, stoyan = 0.15,
         correction = c("isotropic", "Ripley", "translate"),
         divisor = c("r", "d"),
         ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfdot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the dot-type pair correlation function
<code class="reqn">g_{i\bullet}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). 
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">g(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for smoothing kernel, 
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_stoyan">stoyan</code></td>
<td>

<p>Coefficient for default bandwidth rule; see Details.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_correction">correction</code></td>
<td>

<p>Choice of edge correction.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="pcfdot_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the pair correlation function <code><a href="#topic+pcf">pcf</a></code>
to multitype point patterns.
</p>
<p>For two locations <code class="reqn">x</code> and <code class="reqn">y</code> separated by a nonzero
distance <code class="reqn">r</code>,
the probability <code class="reqn">p(r)</code> of finding a point of type <code class="reqn">i</code> at location
<code class="reqn">x</code> and a point of any type at location <code class="reqn">y</code> is 
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda_i \lambda g_{i\bullet}(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity of all points,
and <code class="reqn">\lambda_i</code> is the intensity of the points
of type <code class="reqn">i</code>. 
For a completely random Poisson marked point process,
<code class="reqn">p(r) = \lambda_i \lambda</code>
so <code class="reqn">g_{i\bullet}(r) = 1</code>.
</p>
<p>For a stationary multitype point process, the
type-<code>i</code>-to-any-type pair correlation
function between marks <code class="reqn">i</code> and <code class="reqn">j</code> is formally defined as
</p>
<p style="text-align: center;"><code class="reqn">
    g_{i\bullet}(r) = \frac{K_{i\bullet}^\prime(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K_{i\bullet}^\prime</code> is the derivative of
the type-<code>i</code>-to-any-type <code class="reqn">K</code> function
<code class="reqn">K_{i\bullet}(r)</code>.
of the point process. See <code><a href="#topic+Kdot">Kdot</a></code> for information
about   <code class="reqn">K_{i\bullet}(r)</code>.
</p>
<p>The command <code>pcfdot</code> computes a kernel estimate of
the multitype pair correlation function from points of type <code class="reqn">i</code>
to points of any type.
</p>

<ul>
<li>
<p>If <code>divisor="r"</code> (the default), then the multitype
counterpart of the standard
kernel estimator (Stoyan and Stoyan, 1994, pages 284&ndash;285)
is used. By default, the recommendations of Stoyan and Stoyan (1994)
are followed exactly. 
</p>
</li>
<li>
<p>If <code>divisor="d"</code> then a modified estimator is used:
the contribution from
an interpoint distance <code class="reqn">d_{ij}</code> to the
estimate of <code class="reqn">g(r)</code> is divided by <code class="reqn">d_{ij}</code>
instead of dividing by <code class="reqn">r</code>. This usually improves the
bias of the estimator when <code class="reqn">r</code> is close to zero.
</p>
</li></ul>

<p>There is also a choice of spatial edge corrections
(which are needed to avoid bias due to edge effects
associated with the boundary of the spatial window):
<code>correction="translate"</code> is the Ohser-Stoyan translation
correction, and <code>correction="isotropic"</code> or <code>"Ripley"</code>
is Ripley's isotropic correction.  
</p>
<p>The choice of smoothing kernel is controlled by the 
argument <code>kernel</code> which is passed to <code><a href="stats.html#topic+density">density</a></code>.
The default is the Epanechnikov kernel.
</p>
<p>The bandwidth of the smoothing kernel can be controlled by the
argument <code>bw</code>. Its precise interpretation
is explained in the documentation for <code><a href="stats.html#topic+density.default">density.default</a></code>.
For the Epanechnikov kernel with support <code class="reqn">[-h,h]</code>,
the argument <code>bw</code> is equivalent to <code class="reqn">h/\sqrt{5}</code>.
</p>
<p>If <code>bw</code> is not specified, the default bandwidth
is determined by Stoyan's rule of thumb (Stoyan and Stoyan, 1994, page
285). That is,
<code class="reqn">h = c/\sqrt{\lambda}</code>,
where <code class="reqn">\lambda</code> is the (estimated) intensity of the
unmarked point process, 
and <code class="reqn">c</code> is a constant in the range from 0.1 to 0.2.
The argument <code>stoyan</code> determines the value of <code class="reqn">c</code>.
</p>
<p>The companion function <code><a href="#topic+pcfcross">pcfcross</a></code> computes the
corresponding analogue of <code><a href="#topic+Kcross">Kcross</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">g_{i\bullet}</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">g_{i\bullet}(r) = 1</code>
for independent marks.
</p>
</td></tr>
</table>
<p>together with columns named 
<code>"border"</code>, <code>"bord.modif"</code>,
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">g_{i,j}</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Mark connection function <code><a href="#topic+markconnect">markconnect</a></code>.
</p>
<p>Multitype pair correlation <code><a href="#topic+pcfcross">pcfcross</a></code>, <code><a href="#topic+pcfmulti">pcfmulti</a></code>.
</p>
<p>Pair correlation <code><a href="#topic+pcf">pcf</a></code>,<code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
</p>
<p><code><a href="#topic+Kdot">Kdot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> p &lt;- pcfdot(amacrine, "on")
 p &lt;- pcfdot(amacrine, "on", stoyan=0.1)
 plot(p)
</code></pre>

<hr>
<h2 id='pcfdot.inhom'>
Inhomogeneous Multitype Pair Correlation Function (Type-i-To-Any-Type)
</h2><span id='topic+pcfdot.inhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous multitype pair correlation function
(from type <code class="reqn">i</code> to any type)
for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcfdot.inhom(X, i, lambdaI = NULL, lambdadot = NULL, ...,
               r = NULL, breaks = NULL,
               kernel="epanechnikov", bw=NULL, adjust.bw=1, stoyan=0.15,
               correction = c("isotropic", "Ripley", "translate"),
               sigma = NULL, adjust.sigma = 1, varcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfdot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the inhomogeneous
multitype pair correlation function
<code class="reqn">g_{i\bullet}(r)</code>
will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). 
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_i">i</code></td>
<td>
<p>The type (mark value)
of the points in <code>X</code> from which distances are measured.
A character string (or something that will be converted to a
character string).
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Optional.
Values of the estimated intensity function of the points of type <code>i</code>.
Either a vector giving the intensity values
at the points of type <code>i</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Optional.
Values of the estimated intensity function of the point pattern <code>X</code>.
A numeric vector, pixel image or <code>function(x,y)</code>.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which
<code class="reqn">g_{i\bullet}(r)</code>
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_kernel">kernel</code></td>
<td>

<p>Choice of one-dimensional smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for one-dimensional smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the one-dimensional kernel density estimation 
function <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_stoyan">stoyan</code></td>
<td>

<p>Bandwidth coefficient; see Details.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_correction">correction</code></td>
<td>

<p>Choice of edge correction.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_sigma">sigma</code>, <code id="pcfdot.inhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambdaI</code> and/or
<code>lambdadot</code> is estimated by spatial kernel smoothing.
</p>
</td></tr>
<tr><td><code id="pcfdot.inhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inhomogeneous multitype (type <code class="reqn">i</code> to any type)
pair correlation function
<code class="reqn">g_{i\bullet}(r)</code>
is a summary of the dependence between different types of points in a
multitype spatial point process that does not have a uniform
density of points.
</p>
<p>The best intuitive interpretation is the following: the probability
<code class="reqn">p(r)</code> of finding a point of type <code class="reqn">i</code> at location <code class="reqn">x</code>
and another point of any type at location <code class="reqn">y</code>,
where <code class="reqn">x</code> and <code class="reqn">y</code> are separated by a distance <code class="reqn">r</code>,
is equal to
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda_i(x) lambda(y) g(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda_i</code> is the intensity function
of the process of points of type <code class="reqn">i</code>, and 
where <code class="reqn">\lambda</code> is the intensity function of the points
of all types.
For a multitype Poisson point process, this probability is 
<code class="reqn">p(r) = \lambda_i(x) \lambda(y)</code>
so   <code class="reqn">g_{i\bullet}(r) = 1</code>.
</p>
<p>The command <code>pcfdot.inhom</code> estimates the inhomogeneous
multitype pair correlation using a modified version of
the algorithm in <code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
The arguments <code>bw</code> and <code>adjust.bw</code> control the
degree of one-dimensional smoothing of the estimate of pair correlation.
</p>
<p>If the arguments <code>lambdaI</code> and/or <code>lambdadot</code> are missing or
null, they will be estimated from <code>X</code> by spatial kernel
smoothing using a leave-one-out estimator,
computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
The arguments <code>sigma</code>, <code>varcov</code>
and <code>adjust.sigma</code> control the degree of spatial smoothing.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>).
Essentially a data frame containing the variables
</p>
<table>
<tr><td><code>r</code></td>
<td>

<p>the vector of values of the argument <code class="reqn">r</code> 
at which the inhomogeneous multitype pair correlation function
<code class="reqn">g_{i\bullet}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values equal to 1,
the theoretical value of <code class="reqn">g_{i\bullet}(r)</code>
for the Poisson process
</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>vector of values of <code class="reqn">g_{i\bullet}(r)</code>
estimated by translation correction
</p>
</td></tr>
<tr><td><code>iso</code></td>
<td>
<p>vector of values of <code class="reqn">g_{i\bullet}(r)</code>
estimated by Ripley isotropic correction
</p>
</td></tr>
</table>
<p>as required.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf.ppp">pcf.ppp</a></code>, 
<code><a href="#topic+pcfinhom">pcfinhom</a></code>, 
<code><a href="#topic+pcfdot">pcfdot</a></code>,
<code><a href="#topic+pcfcross.inhom">pcfcross.inhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(pcfdot.inhom(amacrine, "on", stoyan=0.1), legendpos="bottom")
</code></pre>

<hr>
<h2 id='pcfinhom'>
Inhomogeneous Pair Correlation Function
</h2><span id='topic+pcfinhom'></span>

<h3>Description</h3>

<p>Estimates the inhomogeneous pair correlation function of
a point pattern using kernel methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcfinhom(X, lambda = NULL, ..., r = NULL,
         kernel = "epanechnikov",
         bw = NULL, adjust.bw=1, stoyan = 0.15,
         correction = c("translate", "Ripley"),
         divisor = c("r", "d"),
         renormalise = TRUE, normpower=1,
         update = TRUE, leaveoneout = TRUE,
         reciplambda = NULL,
         sigma = NULL, adjust.sigma = 1,
         varcov = NULL, close=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfinhom_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_lambda">lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">g(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel, passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for one-dimensional smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
Either a single numeric value,
or a character string specifying a bandwidth selection rule
recognised by <code><a href="stats.html#topic+density.default">density.default</a></code>.
If <code>bw</code> is missing or <code>NULL</code>,
the default value is computed using
Stoyan's rule of thumb: see <code><a href="#topic+bw.stoyan">bw.stoyan</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the kernel density estimation 
function <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_stoyan">stoyan</code></td>
<td>

<p>Coefficient for Stoyan's bandwidth selection rule;
see <code><a href="#topic+bw.stoyan">bw.stoyan</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_correction">correction</code></td>
<td>

<p>Character string or character vector
specifying the choice of edge correction.
See <code><a href="#topic+Kest">Kest</a></code> for explanation and options.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>.
See <code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_renormalise">renormalise</code></td>
<td>

<p>Logical. Whether to renormalise the estimate. See Details.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_update">update</code></td>
<td>

<p>Logical. If <code>lambda</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
and <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code> or <code><a href="spatstat.model.html#topic+update.kppm">update.kppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+density.ppp">density.ppp</a></code> or
<code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_reciplambda">reciplambda</code></td>
<td>

<p>Alternative to <code>lambda</code>.
Values of the estimated <em>reciprocal</em> <code class="reqn">1/\lambda</code>
of the intensity function.
Either a vector giving the reciprocal intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
reciprocal intensity values at all locations,
or a <code>function(x,y)</code> which can be evaluated to give the
reciprocal intensity value at any location.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_sigma">sigma</code>, <code id="pcfinhom_+3A_varcov">varcov</code></td>
<td>

<p>Optional arguments passed to  <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="pcfinhom_+3A_close">close</code></td>
<td>

<p>Advanced use only. Precomputed data. See section on Advanced Use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inhomogeneous pair correlation function <code class="reqn">g_{\rm inhom}(r)</code>
is a summary of the dependence between points in a spatial point
process that does not have a uniform density of points.
</p>
<p>The best intuitive interpretation is the following: the probability
<code class="reqn">p(r)</code> of finding two points at locations <code class="reqn">x</code> and <code class="reqn">y</code>
separated by a distance <code class="reqn">r</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">
    p(r) = \lambda(x) lambda(y) g(r) \,{\rm d}x \, {\rm d}y
  </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity function
of the point process.
For a Poisson point process with intensity function
<code class="reqn">\lambda</code>, this probability is 
<code class="reqn">p(r) = \lambda(x) \lambda(y)</code>
so <code class="reqn">g_{\rm inhom}(r) = 1</code>.
</p>
<p>The inhomogeneous pair correlation function 
is related to the inhomogeneous <code class="reqn">K</code> function through
</p>
<p style="text-align: center;"><code class="reqn">
    g_{\rm inhom}(r) = \frac{K'_{\rm inhom}(r)}{2\pi r}
  </code>
</p>

<p>where <code class="reqn">K'_{\rm inhom}(r)</code>
is the derivative of <code class="reqn">K_{\rm inhom}(r)</code>, the
inhomogeneous <code class="reqn">K</code> function. See <code><a href="#topic+Kinhom">Kinhom</a></code> for information
about <code class="reqn">K_{\rm inhom}(r)</code>.
</p>
<p>The command <code>pcfinhom</code> estimates the inhomogeneous
pair correlation using a modified version of
the algorithm in <code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.   
</p>
<p>If <code>renormalise=TRUE</code> (the default), then the estimates 
are multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{area}(W)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>).
Essentially a data frame containing the variables
</p>
<table>
<tr><td><code>r</code></td>
<td>

<p>the vector of values of the argument <code class="reqn">r</code> 
at which the inhomogeneous pair correlation function
<code class="reqn">g_{\rm inhom}(r)</code> has been  estimated
</p>
</td></tr>
<tr><td><code>theo</code></td>
<td>
<p>vector of values equal to 1,
the theoretical value of <code class="reqn">g_{\rm inhom}(r)</code>
for the Poisson process
</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>vector of values of <code class="reqn">g_{\rm inhom}(r)</code>
estimated by translation correction
</p>
</td></tr>
<tr><td><code>iso</code></td>
<td>
<p>vector of values of <code class="reqn">g_{\rm inhom}(r)</code>
estimated by Ripley isotropic correction
</p>
</td></tr>
</table>
<p>as required.
</p>


<h3>Advanced Use</h3>

<p>To perform the same computation using several different bandwidths <code>bw</code>,
it is efficient to use the argument <code>close</code>.
This should be the result of <code>closepairs(X, rmax)</code>
for a suitably large value of <code>rmax</code>, namely
<code>rmax &gt;= max(r) + 3 * bw</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcf">pcf</a></code>, 
<code><a href="#topic+pcf.ppp">pcf.ppp</a></code>, 
<code><a href="#topic+bw.stoyan">bw.stoyan</a></code>,
<code><a href="#topic+bw.pcf">bw.pcf</a></code>,
<code><a href="#topic+Kinhom">Kinhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- residualspaper$Fig4b
  online &lt;- interactive()
  if(!online) {
    ## reduce size of dataset
    X &lt;- X[c(FALSE, TRUE)]
  }
  plot(pcfinhom(X, stoyan=0.2, sigma=0.1))
  if(require("spatstat.model")) {
    if(online) {
      fit &lt;- ppm(X ~ polynom(x,y,2))
    } else {
      ## simpler model, faster computation
      fit &lt;- ppm(X ~ x)
    }
    plot(pcfinhom(X, lambda=fit, normpower=2))
  }
</code></pre>

<hr>
<h2 id='pcfmulti'>
Marked pair correlation function
</h2><span id='topic+pcfmulti'></span>

<h3>Description</h3>

<p>For a marked point pattern, 
estimate the multitype pair correlation function
using kernel methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   pcfmulti(X, I, J, ..., r = NULL,
            kernel = "epanechnikov", bw = NULL, stoyan = 0.15,
            correction = c("translate", "Ripley"),
            divisor = c("r", "d"),
            Iname = "points satisfying condition I",
            Jname = "points satisfying condition J",
            ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcfmulti_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross-type pair correlation function
<code class="reqn">g_{ij}(r)</code> will be computed.
It must be a multitype point pattern (a marked point pattern
whose marks are a factor). 
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_i">I</code></td>
<td>
<p>Subset index specifying the points of <code>X</code>
from which distances are measured. 
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_j">J</code></td>
<td>
<p>Subset index specifying the points in <code>X</code> to which
distances are measured. 
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_r">r</code></td>
<td>

<p>Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">g(r)</code> 
should be evaluated. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_kernel">kernel</code></td>
<td>

<p>Choice of smoothing kernel,
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_bw">bw</code></td>
<td>

<p>Bandwidth for smoothing kernel, 
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_stoyan">stoyan</code></td>
<td>

<p>Coefficient for default bandwidth rule.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_correction">correction</code></td>
<td>

<p>Choice of edge correction.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_divisor">divisor</code></td>
<td>

<p>Choice of divisor in the estimation formula:
either <code>"r"</code> (the default) or <code>"d"</code>. 
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_iname">Iname</code>, <code id="pcfmulti_+3A_jname">Jname</code></td>
<td>

<p>Optional. Character strings describing the members of
the subsets <code>I</code> and <code>J</code>.
</p>
</td></tr>
<tr><td><code id="pcfmulti_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of <code><a href="#topic+pcfcross">pcfcross</a></code>
to arbitrary collections of points.
</p>
<p>The algorithm measures the distance from each data point
in subset <code>I</code> to each data point in subset <code>J</code>,
excluding identical pairs of points. The distances are
kernel-smoothed and renormalised to form a pair correlation
function.
</p>

<ul>
<li>
<p>If <code>divisor="r"</code> (the default), then the multitype
counterpart of the standard
kernel estimator (Stoyan and Stoyan, 1994, pages 284&ndash;285)
is used. By default, the recommendations of Stoyan and Stoyan (1994)
are followed exactly. 
</p>
</li>
<li>
<p>If <code>divisor="d"</code> then a modified estimator is used:
the contribution from
an interpoint distance <code class="reqn">d_{ij}</code> to the
estimate of <code class="reqn">g(r)</code> is divided by <code class="reqn">d_{ij}</code>
instead of dividing by <code class="reqn">r</code>. This usually improves the
bias of the estimator when <code class="reqn">r</code> is close to zero.
</p>
</li></ul>

<p>There is also a choice of spatial edge corrections
(which are needed to avoid bias due to edge effects
associated with the boundary of the spatial window):
<code>correction="translate"</code> is the Ohser-Stoyan translation
correction, and <code>correction="isotropic"</code> or <code>"Ripley"</code>
is Ripley's isotropic correction.  
</p>
<p>The arguments <code>I</code> and <code>J</code> specify two subsets of the
point pattern <code>X</code>. They may be any type of subset indices, for example,
logical vectors of length equal to <code>npoints(X)</code>,
or integer vectors with entries in the range 1 to
<code>npoints(X)</code>, or negative integer vectors.
</p>
<p>Alternatively, <code>I</code> and <code>J</code> may be <b>functions</b>
that will be applied to the point pattern <code>X</code> to obtain
index vectors. If <code>I</code> is a function, then evaluating
<code>I(X)</code> should yield a valid subset index. This option
is useful when generating simulation envelopes using
<code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>The choice of smoothing kernel is controlled by the 
argument <code>kernel</code> which is passed to <code><a href="stats.html#topic+density">density</a></code>.
The default is the Epanechnikov kernel.
</p>
<p>The bandwidth of the smoothing kernel can be controlled by the
argument <code>bw</code>. Its precise interpretation
is explained in the documentation for <code><a href="stats.html#topic+density.default">density.default</a></code>.
For the Epanechnikov kernel with support <code class="reqn">[-h,h]</code>,
the argument <code>bw</code> is equivalent to <code class="reqn">h/\sqrt{5}</code>.
</p>
<p>If <code>bw</code> is not specified, the default bandwidth
is determined by Stoyan's rule of thumb (Stoyan and Stoyan, 1994, page
285) applied to the points of type <code>j</code>. That is,
<code class="reqn">h = c/\sqrt{\lambda}</code>,
where <code class="reqn">\lambda</code> is the (estimated) intensity of the
point process of type <code>j</code>,
and <code class="reqn">c</code> is a constant in the range from 0.1 to 0.2.
The argument <code>stoyan</code> determines the value of <code class="reqn">c</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcfcross">pcfcross</a></code>, 
<code><a href="#topic+pcfdot">pcfdot</a></code>, 
<code><a href="#topic+pcf.ppp">pcf.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  adult &lt;- (marks(longleaf) &gt;= 30)
  juvenile &lt;- !adult
  p &lt;- pcfmulti(longleaf, adult, juvenile)
</code></pre>

<hr>
<h2 id='plot.bermantest'>Plot Result of Berman Test</h2><span id='topic+plot.bermantest'></span>

<h3>Description</h3>

<p>Plot the result of Berman's test of goodness-of-fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bermantest'
plot(x, ...,
                   lwd=par("lwd"), col=par("col"), lty=par("lty"),
                   lwd0=lwd, col0=2, lty0=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bermantest_+3A_x">x</code></td>
<td>

<p>Object to be plotted. An object of class <code>"bermantest"</code>
produced by <code><a href="#topic+berman.test">berman.test</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.bermantest_+3A_...">...</code></td>
<td>

<p>extra arguments that will be passed to the plotting function
<code><a href="stats.html#topic+plot.ecdf">plot.ecdf</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.bermantest_+3A_col">col</code>, <code id="plot.bermantest_+3A_lwd">lwd</code>, <code id="plot.bermantest_+3A_lty">lty</code></td>
<td>

<p>The width, colour and type of lines used to plot the
empirical distribution curve.
</p>
</td></tr>
<tr><td><code id="plot.bermantest_+3A_col0">col0</code>, <code id="plot.bermantest_+3A_lwd0">lwd0</code>, <code id="plot.bermantest_+3A_lty0">lty0</code></td>
<td>

<p>The width, colour and type of lines used to plot the
predicted (null) distribution curve.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"bermantest"</code>.
An object of this class represents the outcome of Berman's test
of goodness-of-fit of a spatial Poisson point process model,
computed by <code><a href="#topic+berman.test">berman.test</a></code>.
</p>
<p>For the <em>Z1</em> test (i.e. if <code>x</code> was computed using
<code>berman.test( ,which="Z1")</code>), 
the plot displays the two cumulative distribution functions
that are compared by the test: namely the empirical cumulative distribution
function of the covariate at the data points, <code class="reqn">\hat F</code>,
and the predicted
cumulative distribution function of the covariate under the model,
<code class="reqn">F_0</code>, both plotted against the value of the covariate.
Two vertical lines show the mean values of these two distributions.
If the model is correct, the two curves should be close; the test is
based on comparing the two vertical lines.
</p>
<p>For the <em>Z2</em> test (i.e. if <code>x</code> was computed using
<code>berman.test( ,which="Z2")</code>), the plot displays the empirical
cumulative distribution function of the values
<code class="reqn">U_i = F_0(Y_i)</code> where <code class="reqn">Y_i</code> is the
value of the covariate at the <code class="reqn">i</code>-th data point. The diagonal line
with equation <code class="reqn">y=x</code> is also shown. Two vertical lines show the
mean of the values <code class="reqn">U_i</code> and the value <code class="reqn">1/2</code>. If the
model is correct, the two curves should be close. The test is based on
comparing the two vertical lines. 
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+berman.test">berman.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(berman.test(cells, "x"))

   if(require("spatstat.model")) {
     # synthetic data: nonuniform Poisson process
     X &lt;- rpoispp(function(x,y) { 100 * exp(-x) }, win=square(1))

     # fit uniform Poisson process
     fit0 &lt;- ppm(X ~1)

     # test covariate = x coordinate
     xcoord &lt;- function(x,y) { x }

     # test wrong model
     k &lt;- berman.test(fit0, xcoord, "Z1")
   
     # plot result of test
     plot(k, col="red", col0="green")

     # Z2 test
     k2 &lt;- berman.test(fit0, xcoord, "Z2")
     plot(k2, col="red", col0="green")
   }
</code></pre>

<hr>
<h2 id='plot.cdftest'>Plot a Spatial Distribution Test</h2><span id='topic+plot.cdftest'></span>

<h3>Description</h3>

<p>Plot the result of a spatial distribution test
computed by <code>cdf.test</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdftest'
plot(x, ...,
                   style=c("cdf", "PP", "QQ"),
                   lwd=par("lwd"), col=par("col"), lty=par("lty"),
                   lwd0=lwd, col0=2, lty0=2,
                   do.legend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cdftest_+3A_x">x</code></td>
<td>

<p>Object to be plotted. An object of class <code>"cdftest"</code>
produced by a method for <code><a href="#topic+cdf.test">cdf.test</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cdftest_+3A_...">...</code></td>
<td>

<p>extra arguments that will be passed to the plotting function
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cdftest_+3A_style">style</code></td>
<td>

<p>Style of plot. See Details.
</p>
</td></tr>
<tr><td><code id="plot.cdftest_+3A_col">col</code>, <code id="plot.cdftest_+3A_lwd">lwd</code>, <code id="plot.cdftest_+3A_lty">lty</code></td>
<td>

<p>The width, colour and type of lines used to plot the
empirical curve (the empirical distribution, or PP plot or QQ plot).
</p>
</td></tr>
<tr><td><code id="plot.cdftest_+3A_col0">col0</code>, <code id="plot.cdftest_+3A_lwd0">lwd0</code>, <code id="plot.cdftest_+3A_lty0">lty0</code></td>
<td>

<p>The width, colour and type of lines used to plot the
reference curve (the predicted distribution, or the diagonal).
</p>
</td></tr>
<tr><td><code id="plot.cdftest_+3A_do.legend">do.legend</code></td>
<td>

<p>Logical value indicating whether to add an
explanatory legend. Applies only when <code>style="cdf"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"cdftest"</code>.
An object of this class represents the outcome of
a spatial distribution test, computed by <code><a href="#topic+cdf.test">cdf.test</a></code>,
and based on either the Kolmogorov-Smirnov,
Cramer-von Mises
or Anderson-Darling test.
</p>
<p>If <code>style="cdf"</code> (the default), 
the plot displays the two cumulative distribution functions
that are compared by the test: namely the empirical cumulative distribution
function of the covariate at the data points, and the predicted
cumulative distribution function of the covariate under the model,
both plotted against the value of the covariate. The
Kolmogorov-Smirnov test statistic (for example)
is the maximum vertical separation
between the two curves.
</p>
<p>If <code>style="PP"</code> then the P-P plot is drawn. The
<code class="reqn">x</code> coordinates of the plot are cumulative
probabilities for the covariate under the model.
The <code class="reqn">y</code> coordinates are cumulative probabilities
for the covariate at the data points. The diagonal line
<code class="reqn">y=x</code> is also drawn for reference. The Kolmogorov-Smirnov
test statistic is the maximum vertical separation
between the P-P plot and the diagonal reference line.
</p>
<p>If <code>style="QQ"</code> then the Q-Q plot is drawn. The
<code class="reqn">x</code> coordinates of the plot are quantiles
of the covariate under the model.
The <code class="reqn">y</code> coordinates are quantiles of the 
covariate at the data points. The diagonal line
<code class="reqn">y=x</code> is also drawn for reference. The Kolmogorov-Smirnov
test statistic cannot be read off the Q-Q plot.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdf.test">cdf.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   op &lt;- options(useFancyQuotes=FALSE)

   plot(cdf.test(cells, "x"))

   if(require("spatstat.model")) {   
     # synthetic data: nonuniform Poisson process
     X &lt;- rpoispp(function(x,y) { 100 * exp(x) }, win=square(1))

     # fit uniform Poisson process
     fit0 &lt;- ppm(X ~1)

     # test covariate = x coordinate
     xcoord &lt;- function(x,y) { x }

     # test wrong model
     k &lt;- cdf.test(fit0, xcoord)

     # plot result of test
     plot(k, lwd0=3)

     plot(k, style="PP")

     plot(k, style="QQ")
   }

   options(op)
</code></pre>

<hr>
<h2 id='plot.envelope'>Plot a Simulation Envelope</h2><span id='topic+plot.envelope'></span>

<h3>Description</h3>

<p>Plot method for the class <code>"envelope"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'envelope'
plot(x, ..., main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.envelope_+3A_x">x</code></td>
<td>

<p>An object of class <code>"envelope"</code>, containing the variables to be plotted
or variables from which the plotting coordinates can be computed.
</p>
</td></tr>
<tr><td><code id="plot.envelope_+3A_main">main</code></td>
<td>
<p>Main title for plot.</p>
</td></tr>
<tr><td><code id="plot.envelope_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"envelope"</code>
of simulation envelopes. Objects of this class are
created by the command <code><a href="#topic+envelope">envelope</a></code>.
</p>
<p>This plot method is currently identical to <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Its default behaviour is to shade the region
between the upper and lower envelopes in a light grey colour.
To suppress the shading and plot the upper and lower envelopes
as curves, set <code>shade=NULL</code>.
To change the colour of the shading, use the argument <code>shadecol</code>
which is passed to <code><a href="#topic+plot.fv">plot.fv</a></code>. 
</p>
<p>See <code><a href="#topic+plot.fv">plot.fv</a></code> for further information on how to
control the plot.
</p>


<h3>Value</h3>

<p>Either <code>NULL</code>, or a data frame giving the meaning of the
different line types and colours.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope">envelope</a></code>,
<code><a href="#topic+plot.fv">plot.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   E &lt;- envelope(cells, Kest, nsim=19)
   plot(E)
   plot(E, sqrt(./pi) ~ r)
</code></pre>

<hr>
<h2 id='plot.fasp'>Plot a Function Array</h2><span id='topic+plot.fasp'></span>

<h3>Description</h3>

<p>Plots an array of summary functions, usually associated with a
point pattern, stored in an object of class <code>"fasp"</code>.
A method for <code>plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'fasp'
plot(x,formule=NULL, ...,
                        subset=NULL, title=NULL, banner=TRUE,
                        transpose=FALSE,
                        samex=FALSE, samey=FALSE,
                        mar.panel=NULL,
                        outerlabels=TRUE, cex.outerlabels=1.25,
                        legend=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fasp_+3A_x">x</code></td>
<td>
<p>An object of class <code>"fasp"</code> representing a
function array.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_formule">formule</code></td>
<td>

<p>A formula or list of formulae indicating what
variables are to be plotted against what variable. Each formula is
either an R language formula object, or a string that can be parsed
as a formula. If <code>formule</code> is a list, its <code class="reqn">k^{th}</code> component
should be applicable to the <code class="reqn">(i,j)^{th}</code>
plot where <code>x$which[i,j]=k</code>.  If the formula is left
as <code>NULL</code>, then <code>plot.fasp</code> attempts to use the component
<code>default.formula</code> of <code>x</code>.  If that component is NULL
as well, it gives up.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.fv">plot.fv</a></code> to control 
the individual plot panels. 
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_subset">subset</code></td>
<td>

<p>A logical vector, or a vector of indices, or an
expression or a character string, or a <b>list</b> of such,
indicating a subset of the data to be included in each plot.
If <code>subset</code> is a list, its <code class="reqn">k^{th}</code> component
should be applicable to the <code class="reqn">(i,j)^{th}</code> plot
where <code>x$which[i,j]=k</code>.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_title">title</code></td>
<td>

<p>Overall title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_banner">banner</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the overall title is plotted.
If <code>FALSE</code>, the overall title is not plotted
and no space is allocated for it.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_transpose">transpose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, rows and columns will be exchanged.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_samex">samex</code>, <code id="plot.fasp_+3A_samey">samey</code></td>
<td>

<p>Logical values indicating whether all individual plot panels should have the
same x axis limits and the same y axis limits, respectively.
This makes it easier to compare the plots.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_mar.panel">mar.panel</code></td>
<td>

<p>Vector of length 4 giving the value of the
graphics parameter <code>mar</code> controlling the size of plot margins
for each individual plot panel. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_outerlabels">outerlabels</code></td>
<td>
<p>Logical.
If <code>TRUE</code>, the row and column names of the array of functions
are plotted in the margins of the array of plot panels.
If <code>FALSE</code>, each individual plot panel is labelled by its
row and column name.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_cex.outerlabels">cex.outerlabels</code></td>
<td>

<p>Character expansion factor for row and column labels of array.
</p>
</td></tr>
<tr><td><code id="plot.fasp_+3A_legend">legend</code></td>
<td>

<p>Logical flag determining whether to plot a legend in each panel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"fasp"</code> represents
an array of summary functions, usually associated with a point
pattern. See <code><a href="#topic+fasp.object">fasp.object</a></code> for details.
Such an object is created, for example, 
by <code><a href="#topic+alltypes">alltypes</a></code>.
</p>
<p>The function <code>plot.fasp</code> is
a method for <code>plot</code>.  It calls <code><a href="#topic+plot.fv">plot.fv</a></code> to plot the
individual panels.
</p>
<p>For information about the interpretation of the
arguments <code>formule</code> and <code>subset</code>,
see <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Arguments that are often passed through <code>...</code> include
<code>col</code> to control the colours of the different lines in a panel,
and <code>lty</code> and <code>lwd</code> to control the line type and line width
of the different lines in a panel. The argument <code>shade</code>
can also be used to display confidence intervals or significance bands
as filled grey shading. See <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
<p>The argument <code>title</code>, if present, will determine the
overall title of the plot. If it is absent, it defaults to <code>x$title</code>.
Titles for the individual plot panels will be taken from
<code>x$titles</code>.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Warnings</h3>

<p>(Each component of) the <code>subset</code> argument may be a
logical vector (of the same length as the vectors of data which
are extracted from <code>x</code>), or a vector of indices, or an
<b>expression</b> such as <code>expression(r&lt;=0.2)</code>, or a text string,
such as <code>"r&lt;=0.2"</code>.
</p>
<p>Attempting a syntax such as <code>subset = r&lt;=0.2</code> (without
wrapping <code>r&lt;=0.2</code> either in quote marks or in <code>expression()</code>)
will cause this function to fall over.
</p>
<p>Variables referred to in any formula must exist in the data frames
stored in <code>x</code>.  What the names of these variables are will
of course depend upon the nature of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alltypes">alltypes</a></code>,
<code><a href="#topic+plot.fv">plot.fv</a></code>,
<code><a href="#topic+fasp.object">fasp.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
   X.G &lt;- alltypes(amacrine,"G")
   plot(X.G)
   plot(X.G,subset="r&lt;=0.2")
   plot(X.G,formule=asin(sqrt(cbind(km,theo))) ~ asin(sqrt(theo)))
   plot(X.G,fo=cbind(km,theo) - theo~r, subset="theo&lt;=0.9")
   }
</code></pre>

<hr>
<h2 id='plot.fv'>Plot Function Values</h2><span id='topic+plot.fv'></span>

<h3>Description</h3>

<p>Plot method for the class <code>"fv"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'fv'
plot(x, fmla, ..., subset=NULL, lty=NULL, col=NULL, lwd=NULL,
           xlim=NULL, ylim=NULL, xlab=NULL, ylab=NULL,
           clip.xlim=TRUE, ylim.covers=NULL,
           legend=!add, legendpos="topleft", legendavoid=missing(legendpos),
           legendmath=TRUE, legendargs=list(),
           shade=fvnames(x, ".s"), shadecol="grey",
           add=FALSE, log="",
           mathfont=c("italic", "plain", "bold", "bolditalic"), 
           limitsonly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fv_+3A_x">x</code></td>
<td>

<p>An object of class <code>"fv"</code>, containing the variables to be plotted
or variables from which the plotting coordinates can be computed.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_fmla">fmla</code></td>
<td>

<p>an R language formula 
determining which variables or expressions are plotted.
Either a formula object, or a string that can be parsed as a
formula.
See Details.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_subset">subset</code></td>
<td>

<p>(optional) subset of rows of the data frame that will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_lty">lty</code></td>
<td>

<p>(optional) numeric vector of values of the graphical parameter
<code>lty</code> controlling the line style of each plot.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_col">col</code></td>
<td>

<p>(optional) numeric vector of values of the graphical parameter
<code>col</code> controlling the colour of each plot.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_lwd">lwd</code></td>
<td>

<p>(optional) numeric vector of values of the graphical parameter
<code>lwd</code> controlling the line width of each plot.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_xlim">xlim</code></td>
<td>

<p>(optional) range of x axis
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_ylim">ylim</code></td>
<td>

<p>(optional) range of y axis
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_xlab">xlab</code></td>
<td>

<p>(optional) label for x axis
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_ylab">ylab</code></td>
<td>

<p>(optional) label for y axis
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>plot.default</code>.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_clip.xlim">clip.xlim</code></td>
<td>

<p>Logical value specifying whether the range of the horizontal axis
<code>xlim</code> should be automatically restricted to a subset of the
range of the available data. See the section on
<b>Controlling the horizontal axis limits</b> below.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_ylim.covers">ylim.covers</code></td>
<td>

<p>Optional vector of <code class="reqn">y</code> values that must be included in the
<code class="reqn">y</code> axis. For example <code>ylim.covers=0</code> will ensure that the
<code class="reqn">y</code> axis includes the origin.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_legend">legend</code></td>
<td>

<p>Logical flag or <code>NULL</code>. If <code>legend=TRUE</code>, the algorithm
plots a legend in the top left corner of the plot,
explaining the meaning of the different line types and colours.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_legendpos">legendpos</code></td>
<td>

<p>The position of the legend. Either a character string keyword
(see <code><a href="graphics.html#topic+legend">legend</a></code> for keyword options)
or a pair of coordinates in the format <code>list(x,y)</code>.
Alternatively if <code>legendpos="float"</code>, a location will be
selected inside the plot region, avoiding the graphics.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_legendavoid">legendavoid</code></td>
<td>

<p>Whether to avoid collisions between the legend and the graphics.
Logical value.
If <code>TRUE</code>, the code will check for collisions between the
legend box and the graphics, and will override <code>legendpos</code>
if a collision occurs.
If <code>FALSE</code>, the value of <code>legendpos</code> is always respected.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_legendmath">legendmath</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the legend will display the
mathematical notation for each curve. If <code>FALSE</code>, the legend text
is the identifier (column name) for each curve.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_legendargs">legendargs</code></td>
<td>

<p>Named list containing additional arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code> controlling the appearance of the legend.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_shade">shade</code></td>
<td>

<p>A character vector giving the names of two columns of <code>x</code>,
or another type of index that identifies two columns.
When the corresponding curves are plotted,
the region between the curves will be shaded in light grey.
The object <code>x</code> may or may not contain two columns which are designated
as boundaries for shading; they are identified by <code>fvnames(x, ".s")</code>.
The default is to shade between these two curves
if they exist. To suppress this behaviour, set <code>shade=NULL</code>.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_shadecol">shadecol</code></td>
<td>

<p>The colour to be used in the <code>shade</code> plot.
A character string or an integer specifying a colour.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_add">add</code></td>
<td>

<p>Logical. Whether the plot should be added to an existing plot
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_log">log</code></td>
<td>

<p>A character string which contains <code>"x"</code> if the x axis is to
be logarithmic, <code>"y"</code> if the y axis is to be logarithmic and
<code>"xy"</code> or <code>"yx"</code> if both axes are to be logarithmic.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_mathfont">mathfont</code></td>
<td>

<p>Character string. The font to be used for mathematical
expressions in the axis labels and the legend.
</p>
</td></tr>
<tr><td><code id="plot.fv_+3A_limitsonly">limitsonly</code></td>
<td>

<p>Logical. If <code>FALSE</code>, plotting is performed normally.
If <code>TRUE</code>, no plotting is performed at all; 
just the <code class="reqn">x</code> and <code class="reqn">y</code> limits of the plot are computed
and returned. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"fv"</code>.
</p>
<p>An object of class <code>"fv"</code> is a convenient way of storing several different
statistical estimates of a summary function; see <code><a href="#topic+fv.object">fv.object</a></code>.
The default behaviour, executed by <code>plot(x)</code>, displays these
different estimates as curves with different colours and line styles,
and plots a legend explaining them.
</p>
<p>The use of the argument <code>fmla</code> is like <code>plot.formula</code>, but offers
some extra functionality.
</p>
<p>The left and right hand sides of <code>fmla</code> are evaluated,
and the results are plotted against each other
(the left side on the <code class="reqn">y</code> axis 
against the right side on the <code class="reqn">x</code> axis).
</p>
<p>The left and right hand sides of <code>fmla</code> may be
the names of columns of the data frame <code>x</code>,
or expressions involving these names. If a variable in <code>fmla</code>
is not the name of a column of <code>x</code>, the algorithm will search for
an object of this name in the environment where <code>plot.fv</code> was
called, and then in the enclosing environment, and so on. 
</p>
<p>Multiple curves may be specified by a single formula
of the form 
<code>cbind(y1,y2,...,yn) ~ x</code>, where <code>x,y1,y2,...,yn</code> are
expressions involving the variables in the data frame.
Each of the variables <code>y1,y2,...,yn</code> in turn will be plotted
against <code>x</code>. 
See the examples.
</p>
<p>Convenient abbreviations which can be used in the formula
are 
</p>

<ul>
<li><p> the symbol <code>.</code> which represents all the
columns in the data frame that will be plotted by default;
</p>
</li>
<li><p> the symbol <code>.x</code> which represents the function argument;
</p>
</li>
<li><p> the symbol <code>.y</code> which represents the recommended value
of the function.
</p>
</li></ul>

<p>For further information, see <code><a href="#topic+fvnames">fvnames</a></code>.
</p>
<p>The value returned by this plot function indicates the
meaning of the line types and colours in the plot. It can be used
to make a suitable legend for the plot if you want to do this
by hand. See the examples.
</p>
<p>The argument <code>shade</code> can be used to display critical bands
or confidence intervals. If it is not <code>NULL</code>, then it should be
a subset index for the columns of <code>x</code>, that identifies exactly
2 columns. When the corresponding curves are plotted, the region
between the curves will be shaded in light grey. See the Examples.
</p>
<p>The default values of <code>lty</code>, <code>col</code> and <code>lwd</code> can
be changed using <code>spatstat.options("plot.fv")</code>.
</p>
<p>Use <code>type = "n"</code> to create the plot region and draw the axes
without plotting any data.
</p>
<p>Use <code>limitsonly=TRUE</code> to suppress all plotting
and just compute the <code class="reqn">x</code> and <code class="reqn">y</code> limits. This can be used
to calculate common <code class="reqn">x</code> and <code class="reqn">y</code> scales for several plots.
</p>
<p>To change the kind of parenthesis enclosing the
explanatory text about the unit of length, use
<code>spatstat.options('units.paren')</code>
</p>


<h3>Value</h3>

<p>Invisible: either <code>NULL</code>, or a data frame giving the meaning of the
different line types and colours.
</p>


<h3>Controlling the horizontal axis limits</h3>

<p>The plot generated by <code>plot(x)</code>
does not necessarily display all the data that is contained in the object.
The range of values of the function argument <code class="reqn">r</code>
displayed in the plot may be narrower than the 
range of values actually contained in the data frame.
</p>
<p>To override this behaviour and display all the available data,
set <code>clip.xlim=FALSE</code>.
</p>
<p>Statistical literature for summary functions of spatial data
recommends that, when the function is plotted,
the values of the function argument on the horizontal axis
should be restricted to a limited range of values.
For example, Ripley recommends that the K-function <code class="reqn">K(r)</code>
should be plotted only for
values of distance <code class="reqn">r</code> between <code class="reqn">0</code> and <code class="reqn">b/4</code> where <code class="reqn">b</code>
is the shortest side of the enclosing rectangle of the data.
</p>
<p>This may be desirable so that the interesting detail is clearly visible in the
plot. 
It may be necessary because values outside the recommended range
are theoretically invalid, or unreliable due to high variance or large bias.
</p>
<p>To support this standard practice, each object of class <code>"fv"</code>
may include data specifying a &ldquo;recommended range&rdquo; of values of 
the function argument. The object produced by <code><a href="#topic+Kest">Kest</a></code>
includes a recommended range following Ripley's recommendation above.
Similarly for <code><a href="#topic+Gest">Gest</a></code>, <code><a href="#topic+Fest">Fest</a></code> and many other
commands.
</p>
<p>When <code>plot(x)</code> is executed, the horizontal axis is restricted
to the recommended range of values. This recommendation can be
overridden by setting <code>clip.xlim=FALSE</code>
or by specifying the numerical limits <code>xlim</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- Kest(cells)
   # K is an object of class "fv"

   plot(K, iso ~ r)                # plots iso against r

   plot(K, sqrt(iso/pi) ~ r)   # plots sqrt(iso/r)  against r

   plot(K, cbind(iso,theo) ~ r)   # plots iso against r  AND theo against r

   plot(K, .  ~ r)            # plots all available estimates of K against r

   plot(K, sqrt(./pi) ~ r)   # plots all estimates of L-function
                             # L(r) = sqrt(K(r)/pi)

   plot(K, cbind(iso,theo) ~ r, col=c(2,3))
                                   # plots iso against r  in colour 2
                                   # and theo against r in colour 3

   plot(K, iso ~ r, subset=quote(r &lt; 0.2))
                                   # plots iso against r for r &lt; 10

   # Can't remember the names of the columns? No problem..
   plot(K, sqrt(./pi) ~ .x)

   # making a legend by hand
   v &lt;- plot(K, . ~ r, legend=FALSE)
   legend("topleft", legend=v$meaning, lty=v$lty, col=v$col)

   # significance bands
   KE &lt;- envelope(cells, Kest, nsim=19)
   plot(KE, shade=c("hi", "lo"))

   # how to display two functions on a common scale
   Kr &lt;- Kest(redwood)
   a &lt;- plot(K, limitsonly=TRUE)
   b &lt;- plot(Kr, limitsonly=TRUE)
   xlim &lt;- range(a$xlim, b$xlim)
   ylim &lt;- range(a$ylim, b$ylim)
   opa &lt;- par(mfrow=c(1,2))
   plot(K, xlim=xlim, ylim=ylim)
   plot(Kr, xlim=xlim, ylim=ylim)
   par(opa)
   # For a shortcut, try plot(anylist(K, Kr), equal.scales=TRUE)
</code></pre>

<hr>
<h2 id='plot.laslett'>
Plot Laslett Transform
</h2><span id='topic+plot.laslett'></span>

<h3>Description</h3>

<p>Plot the result of Laslett's Transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'laslett'
plot(x, ...,
          Xpars = list(box = TRUE, col = "grey"),
          pointpars = list(pch = 3, cols = "blue"),
          rectpars = list(lty = 3, border = "green"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.laslett_+3A_x">x</code></td>
<td>

<p>Object of class <code>"laslett"</code> produced by <code><a href="#topic+laslett">laslett</a></code>
representing the result of Laslett's transform.
</p>
</td></tr>
<tr><td><code id="plot.laslett_+3A_...">...</code></td>
<td>

<p>Additional plot arguments passed to <code>plot.solist</code>.
</p>
</td></tr>
<tr><td><code id="plot.laslett_+3A_xpars">Xpars</code></td>
<td>

<p>A list of plot arguments passed to <code>plot.owin</code>
or <code>plot.im</code> to display the original region <code>X</code>
before transformation.
</p>
</td></tr>
<tr><td><code id="plot.laslett_+3A_pointpars">pointpars</code></td>
<td>

<p>A list of plot arguments passed to <code>plot.ppp</code>
to display the tangent points.
</p>
</td></tr>
<tr><td><code id="plot.laslett_+3A_rectpars">rectpars</code></td>
<td>

<p>A list of plot arguments passed to <code>plot.owin</code>
to display the maximal rectangle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"laslett"</code>.
</p>
<p>The function <code><a href="#topic+laslett">laslett</a></code> applies Laslett's Transform
to a spatial region <code>X</code> and returns an object of class
<code>"laslett"</code> representing the result of the transformation.
The result is plotted by this method.
</p>
<p>The plot function <code>plot.solist</code> is used to align
the before-and-after pictures. See <code>plot.solist</code> for
further options to control the plot.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Kassel Hingee and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+laslett">laslett</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  b &lt;- laslett(heather$coarse, plotit=FALSE)
  plot(b, main="Heather Data")
</code></pre>

<hr>
<h2 id='plot.quadrattest'>
Display the result of a quadrat counting test.
</h2><span id='topic+plot.quadrattest'></span>

<h3>Description</h3>

<p>Given the result of a quadrat counting test,
graphically display the quadrats that were used, the 
observed and expected counts, and the residual in each quadrat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'quadrattest'
plot(x, ..., textargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.quadrattest_+3A_x">x</code></td>
<td>

<p>Object of class <code>"quadrattest"</code> containing the result
of <code><a href="#topic+quadrat.test">quadrat.test</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.quadrattest_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>plot.tess</code> to
control the display of the quadrats.
</p>
</td></tr>
<tr><td><code id="plot.quadrattest_+3A_textargs">textargs</code></td>
<td>

<p>List of additional arguments passed to
<code><a href="graphics.html#topic+text.default">text.default</a></code>
to control the appearance of the text.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for objects
of class <code>"quadrattest"</code>. Such an object is produced by
<code><a href="#topic+quadrat.test">quadrat.test</a></code> and represents the result of
a <code class="reqn">\chi^2</code> test for a spatial point pattern.
</p>
<p>The quadrats are first plotted using <code>plot.tess</code>.
Then in each quadrat, the observed and expected counts
and the Pearson residual are displayed as text using
<code><a href="graphics.html#topic+text.default">text.default</a></code>.
Observed count is displayed at top left; expected count at top right;
and Pearson residual at bottom. 
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrat.test">quadrat.test</a></code>,
<code>plot.tess</code>,
<code><a href="graphics.html#topic+text.default">text.default</a></code>,
<code>plot.quadratcount</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(quadrat.test(swedishpines, 3))
</code></pre>

<hr>
<h2 id='plot.scan.test'>
Plot Result of Scan Test
</h2><span id='topic+plot.scan.test'></span><span id='topic+as.im.scan.test'></span>

<h3>Description</h3>

<p>Computes or plots an image showing the
likelihood ratio test statistic for the scan test,
or the optimal circle radius. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'scan.test'
plot(x, ..., what=c("statistic", "radius"),
               do.window = TRUE)

 ## S3 method for class 'scan.test'
as.im(X, ..., what=c("statistic", "radius"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.scan.test_+3A_x">x</code>, <code id="plot.scan.test_+3A_x">X</code></td>
<td>

<p>Result of a scan test. An object of class <code>"scan.test"</code>
produced by <code><a href="#topic+scan.test">scan.test</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.scan.test_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>plot.im</code> to control the appearance
of the plot.
</p>
</td></tr>
<tr><td><code id="plot.scan.test_+3A_what">what</code></td>
<td>

<p>Character string indicating whether to produce an image of the
(profile) likelihood ratio test statistic (<code>what="statistic"</code>,
the default) or an image of the optimal value of circle radius
(<code>what="radius"</code>).
</p>
</td></tr>
<tr><td><code id="plot.scan.test_+3A_do.window">do.window</code></td>
<td>

<p>Logical value indicating whether to plot the original window
of the data as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract, and plot, the spatially-varying value
of the likelihood ratio test statistic which forms the basis of
the scan test.
</p>
<p>If the test result <code>X</code> was based on circles of
the same radius <code>r</code>, then <code>as.im(X)</code> is a pixel image
of the likelihood ratio test statistic as a function of the
position of the centre of the circle.
</p>
<p>If the test result <code>X</code> was based on circles of
several different radii <code>r</code>, then <code>as.im(X)</code> is a pixel image
of the profile (maximum value over all radii <code>r</code>)
likelihood ratio test statistic as a function of the
position of the centre of the circle, and
<code>as.im(X, what="radius")</code> is a pixel image giving
for each location <code class="reqn">u</code> the value of <code>r</code> which maximised
the likelihood ratio test statistic at that location.
</p>
<p>The <code>plot</code> method plots the corresponding image.
</p>


<h3>Value</h3>

<p>The value of <code>as.im.scan.test</code> is a pixel image (object of
class <code>"im"</code>). The value of <code>plot.scan.test</code> is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan.test">scan.test</a></code>,
<code><a href="#topic+scanLRTS">scanLRTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   online &lt;- interactive()
   Nsim &lt;- if(online) 19 else 2
   r &lt;- if(online) seq(0.04, 0.1, by=0.01) else c(0.05, 0.1)
   a &lt;- scan.test(redwood, r=r, method="poisson", nsim=Nsim)
   plot(a)
   as.im(a)
   plot(a, what="radius")
</code></pre>

<hr>
<h2 id='plot.ssf'>
Plot a Spatially Sampled Function
</h2><span id='topic+plot.ssf'></span><span id='topic+image.ssf'></span><span id='topic+contour.ssf'></span>

<h3>Description</h3>

<p>Plot a spatially sampled function object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssf'
plot(x, ...,
                   how = c("smoothed", "nearest", "points"),
                   style = c("image", "contour", "imagecontour"),
                   sigma = NULL, contourargs=list())

## S3 method for class 'ssf'
image(x, ...)

## S3 method for class 'ssf'
contour(x, ..., main, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ssf_+3A_x">x</code></td>
<td>

<p>Spatially sampled function (object of class <code>"ssf"</code>).
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+image.default">image.default</a></code>
or 
<code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code> to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_how">how</code></td>
<td>

<p>Character string determining whether to display the
function values at the data points (<code>how="points"</code>),
a smoothed interpolation of the function
(<code>how="smoothed"</code>), or the function value at the
nearest data point (<code>how="nearest"</code>).
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_style">style</code></td>
<td>

<p>Character string indicating whether to plot the smoothed function as
a colour image, a contour map, or both.
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_contourargs">contourargs</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+contour.default">contour.default</a></code>
to control the contours, if <code>style="contour"</code> or
<code>style="imagecontour"</code>.
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth for smooth interpolation.
</p>
</td></tr>
<tr><td><code id="plot.ssf_+3A_main">main</code></td>
<td>

<p>Optional main title for the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> and
<code><a href="graphics.html#topic+contour">contour</a></code>
for the class <code>"ssf"</code>.
</p>
<p>An object of class <code>"ssf"</code> represents a
function (real- or vector-valued) that has been
sampled at a finite set of points.
</p>
<p>For <code>plot.ssf</code> there are three types of display.
If <code>how="points"</code> the exact function values
will be displayed as circles centred at the locations where they
were computed. If <code>how="smoothed"</code> (the default) these
values will be kernel-smoothed using <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>
and displayed as a pixel image.
If <code>how="nearest"</code> the values will be interpolated
by nearest neighbour interpolation using <code><a href="spatstat.geom.html#topic+nnmark">nnmark</a></code>
and displayed as a pixel image.
</p>
<p>For <code>image.ssf</code> and <code>contour.ssf</code> the values are
kernel-smoothed before being displayed.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017)
Local composite likelihood for spatial point processes.
<em>Spatial Statistics</em> <b>22</b>, 261&ndash;295.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssf">ssf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- ssf(cells, nndist(cells, k=1:3))
  plot(a, how="points")
  plot(a, how="smoothed")
  plot(a, how="nearest")
</code></pre>

<hr>
<h2 id='plot.studpermutest'>
Plot a Studentised Permutation Test
</h2><span id='topic+plot.studpermutest'></span>

<h3>Description</h3>

<p>Plot the result of the studentised permutation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'studpermutest'
plot(x, fmla, ...,
          lty = NULL, col = NULL, lwd = NULL,
          lty.theo = NULL, col.theo = NULL, lwd.theo = NULL,
          lwd.mean = if (meanonly) 1 else NULL,
          lty.mean = lty, col.mean = col,
          separately = FALSE, meanonly = FALSE,
          main = if (meanonly) "group means" else NULL,
          xlim = NULL, ylim = NULL, ylab = NULL,
          legend = !add, legendpos = "topleft", lbox = FALSE, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.studpermutest_+3A_x">x</code></td>
<td>

<p>An object of class <code>"studpermutest"</code> generated by
<code><a href="#topic+studpermu.test">studpermu.test</a></code> and representing the result of a
studentised permutation test for spatial point pattern data.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_fmla">fmla</code></td>
<td>

<p>Plot formula used in <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_...">...</code></td>
<td>

<p>Additional graphical arguments passed to <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_lty">lty</code>, <code id="plot.studpermutest_+3A_col">col</code>, <code id="plot.studpermutest_+3A_lwd">lwd</code></td>
<td>

<p>Line type, colour, and line width of the curves plotting the
summary function for each point pattern in the original data.
Either a single value or a
vector of length equal to the number of point patterns.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_lty.theo">lty.theo</code>, <code id="plot.studpermutest_+3A_col.theo">col.theo</code>, <code id="plot.studpermutest_+3A_lwd.theo">lwd.theo</code></td>
<td>

<p>Line type, colour, and line width of the curve representing the
theoretical value of the summary function. 
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_lty.mean">lty.mean</code>, <code id="plot.studpermutest_+3A_col.mean">col.mean</code>, <code id="plot.studpermutest_+3A_lwd.mean">lwd.mean</code></td>
<td>

<p>Line type, colour, and line width (as a multiple of <code>lwd</code>)
of the curve representing the group mean of the summary function.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_separately">separately</code></td>
<td>

<p>Logical value indicating whether to plot each group of data
in a separate panel.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_meanonly">meanonly</code></td>
<td>

<p>Logical value indicating whether to plot only the group means
of the summary function.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_main">main</code></td>
<td>

<p>Character string giving a main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_xlim">xlim</code>, <code id="plot.studpermutest_+3A_ylim">ylim</code></td>
<td>

<p>Numeric vectors of length 2 giving the limits for the <code class="reqn">x</code> and
<code class="reqn">y</code> coordinates of the plot or plots.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_ylab">ylab</code></td>
<td>

<p>Character string or expression to be used for the label on the
<code class="reqn">y</code> axis.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_legend">legend</code></td>
<td>

<p>Logical value indicating whether to plot a legend
explaining the meaning of each curve.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_legendpos">legendpos</code></td>
<td>

<p>Position of legend. See <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_lbox">lbox</code></td>
<td>

<p>Logical value indicating whether to plot a box around the plot.
</p>
</td></tr>
<tr><td><code id="plot.studpermutest_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether the plot should be added to
the existing plot (<code>add=TRUE</code>) or whether a new frame should be
created (<code>add=FALSE</code>, the default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for objects of class
<code>"studpermutest"</code> which represent the result of a studentised
permutation test applied to several point patterns. The test is
performed by <code><a href="#topic+studpermu.test">studpermu.test</a></code>.
</p>
<p>The plot shows the summary functions for each point pattern,
coloured according to group.
Optionally it can show the different groups
in separate plot panels, or show only the group means in a single panel.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Ute Hahn.
</p>
<p>Modified for <code>spatstat</code> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+studpermu.test">studpermu.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  np &lt;- if(interactive()) 99 else 19
  testpyramidal &lt;- studpermu.test(pyramidal, Neurons ~ group, nperm=np)
  plot(testpyramidal)
  plot(testpyramidal, meanonly=TRUE)
  plot(testpyramidal, col.theo=8, lwd.theo=4, lty.theo=1)
  plot(testpyramidal, . ~ pi * r^2)
  op &lt;- par(mfrow=c(1,3))
  plot(testpyramidal, separately=TRUE)
  plot(testpyramidal, separately=TRUE, col=2, lty=1, lwd.mean=2, col.mean=4)
  par(op)
</code></pre>

<hr>
<h2 id='pool'>
Pool Data 
</h2><span id='topic+pool'></span>

<h3>Description</h3>

<p>Pool the data from several objects of the same class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_+3A_...">...</code></td>
<td>

<p>Objects of the same type.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pool</code> is generic. There are methods for several
classes, listed below.
</p>
<p><code>pool</code> is used to combine the data from several objects of the same type,
and to compute statistics based on the combined dataset.
It may be used to pool the estimates obtained from replicated datasets.
It may also be used in high-performance computing applications,
when the objects <code>...</code> have been computed on different processors
or in different batch runs, and we wish to combine them.
</p>


<h3>Value</h3>

<p>An object of the same class as the arguments <code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool.envelope">pool.envelope</a></code>,
<code><a href="#topic+pool.fasp">pool.fasp</a></code>,
<code><a href="#topic+pool.rat">pool.rat</a></code>,
<code><a href="#topic+pool.fv">pool.fv</a></code>
</p>

<hr>
<h2 id='pool.anylist'>
Pool Data from a List of Objects
</h2><span id='topic+pool.anylist'></span>

<h3>Description</h3>

<p>Pool the data from the objects in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anylist'
pool(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.anylist_+3A_x">x</code></td>
<td>

<p>A list, belonging to the class <code>"anylist"</code>,
containing objects that can be pooled.
</p>
</td></tr>
<tr><td><code id="pool.anylist_+3A_...">...</code></td>
<td>

<p>Optional additional objects 
which can be pooled with the elements of <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. Its purpose is to combine
data from several objects of the same type (typically computed
from different datasets) into a common, pooled estimate. 
</p>
<p>The function <code>pool.anyist</code> is the method
for the class <code>"anylist"</code>. It is used when the objects to be
pooled are given in a list <code>x</code>.
</p>
<p>Each of the elements of the list <code>x</code>, and each of the
subsequent arguments <code>...</code> if provided, must be an object of the same
class. 
</p>


<h3>Value</h3>

<p>An object of the same class as each of the entries in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>anylist</code>,
<code><a href="#topic+pool">pool</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Keach &lt;- anylapply(waterstriders, Kest, ratio=TRUE, correction="iso")
   K &lt;- pool(Keach)
</code></pre>

<hr>
<h2 id='pool.envelope'>
Pool Data from Several Envelopes
</h2><span id='topic+pool.envelope'></span>

<h3>Description</h3>

<p>Pool the simulation data from several simulation envelopes
(objects of class <code>"envelope"</code>)
and compute a new envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'envelope'
pool(..., savefuns=FALSE, savepatterns=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.envelope_+3A_...">...</code></td>
<td>

<p>Objects of class <code>"envelope"</code>.
</p>
</td></tr>
<tr><td><code id="pool.envelope_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
function values.
</p>
</td></tr>
<tr><td><code id="pool.envelope_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. This is the method for the
class <code>"envelope"</code> of simulation envelopes. It is used to
combine the simulation data from several simulation envelopes
and to compute an envelope based on the combined data.
</p>
<p>Each of the arguments <code>...</code> must be an object of class
<code>"envelope"</code>. These envelopes must be compatible,
in that they are envelopes for the same function,
and were computed using the same options.
</p>

<ul>
<li><p> In normal use, each envelope object will have been 
created by running the command <code><a href="#topic+envelope">envelope</a></code>
with the argument <code>savefuns=TRUE</code>.
This ensures that each object contains the simulated data
(summary function values for the simulated point patterns)
that were used to construct the envelope.
</p>
<p>The simulated data are extracted from each object and combined.
A new envelope is computed from the combined set of simulations.
</p>
</li>
<li>
<p>Alternatively, if each envelope object was created
by running <code><a href="#topic+envelope">envelope</a></code> with <code>VARIANCE=TRUE</code>,
then the saved functions are not required.
</p>
<p>The sample means and sample variances from each envelope
will be pooled. A new envelope is computed from the pooled
mean and variance.
</p>
</li></ul>

<p>Warnings or errors will be issued if the envelope objects <code>...</code>
appear to be incompatible. Apart from these basic checks,
the code is not smart enough to decide whether it is sensible
to pool the data.
</p>
<p>To modify the envelope parameters or the type of envelope that is
computed, first pool the envelope data using <code>pool.envelope</code>,
then use <code><a href="#topic+envelope.envelope">envelope.envelope</a></code> to modify the envelope
parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"envelope"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope">envelope</a></code>,
<code><a href="#topic+envelope.envelope">envelope.envelope</a></code>,
<code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+pool.fasp">pool.fasp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   E1 &lt;- envelope(cells, Kest, nsim=10, savefuns=TRUE)
   E2 &lt;- envelope(cells, Kest, nsim=20, savefuns=TRUE)
   pool(E1, E2)

   V1 &lt;- envelope(E1, VARIANCE=TRUE)
   V2 &lt;- envelope(E2, VARIANCE=TRUE)
   pool(V1, V2)
</code></pre>

<hr>
<h2 id='pool.fasp'>
Pool Data from Several Function Arrays
</h2><span id='topic+pool.fasp'></span>

<h3>Description</h3>

<p>Pool the simulation data from several function arrays
(objects of class <code>"fasp"</code>)
and compute a new function array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fasp'
pool(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.fasp_+3A_...">...</code></td>
<td>

<p>Objects of class <code>"fasp"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. This is the method for the
class <code>"fasp"</code> of function arrays. It is used to
combine the simulation data from several arrays of simulation envelopes
and to compute a new array of envelopes based on the combined data.
</p>
<p>Each of the arguments <code>...</code> must be a function array
(object of class <code>"fasp"</code>) containing simulation envelopes.
This is typically created by running the command
<code><a href="#topic+alltypes">alltypes</a></code> with the arguments
<code>envelope=TRUE</code> and <code>savefuns=TRUE</code>.
This ensures that each object is an array of simulation envelopes,
and that each envelope contains the simulated data
(summary function values) that were used to construct the envelope.
</p>
<p>The simulated data are extracted from each object and combined.
A new array of envelopes is computed from the combined set of simulations.
</p>
<p>Warnings or errors will be issued if the objects <code>...</code>
appear to be incompatible. However, the code is not smart enough to
decide whether it is sensible to pool the data.
</p>


<h3>Value</h3>

<p>An object of class <code>"fasp"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fasp">fasp</a></code>,
<code><a href="#topic+alltypes">alltypes</a></code>,
<code><a href="#topic+pool.envelope">pool.envelope</a></code>,
<code><a href="#topic+pool">pool</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A1 &lt;- alltypes(amacrine,"K",nsim=9,envelope=TRUE,savefuns=TRUE)
   A2 &lt;- alltypes(amacrine,"K",nsim=10,envelope=TRUE,savefuns=TRUE)
   pool(A1, A2)
</code></pre>

<hr>
<h2 id='pool.fv'>Pool Several Functions</h2><span id='topic+pool.fv'></span>

<h3>Description</h3>

<p>Combine several summary functions into a single function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
pool(..., weights=NULL, relabel=TRUE, variance=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.fv_+3A_...">...</code></td>
<td>

<p>Objects of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="pool.fv_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights for the functions.
</p>
</td></tr>
<tr><td><code id="pool.fv_+3A_relabel">relabel</code></td>
<td>

<p>Logical value indicating whether the columns of the resulting function
should be labelled to show that they were obtained by pooling.
</p>
</td></tr>
<tr><td><code id="pool.fv_+3A_variance">variance</code></td>
<td>

<p>Logical value indicating whether to compute the sample variance
and related terms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. This is the method for the
class <code>"fv"</code> of summary functions. It is used to
combine several estimates of the same function into a single function.
</p>
<p>Each of the arguments <code>...</code> must be an object of class
<code>"fv"</code>. They must be compatible,
in that they are estimates of the same function,
and were computed using the same options.
</p>
<p>The sample mean and sample variance of the corresponding
estimates will be computed.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+pool.anylist">pool.anylist</a></code>,
<code><a href="#topic+pool.rat">pool.rat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- lapply(waterstriders, Kest, correction="iso")
   Kall &lt;- pool(K[[1]], K[[2]], K[[3]])
   Kall &lt;- pool(as.anylist(K))
   plot(Kall, cbind(pooliso, pooltheo) ~ r,
              shade=c("loiso", "hiiso"),
              main="Pooled K function of waterstriders")
</code></pre>

<hr>
<h2 id='pool.quadrattest'>
Pool Several Quadrat Tests
</h2><span id='topic+pool.quadrattest'></span>

<h3>Description</h3>

<p>Pool several quadrat tests into a single quadrat test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quadrattest'
pool(..., df=NULL, df.est=NULL, nsim=1999,
                                Xname=NULL, CR=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.quadrattest_+3A_...">...</code></td>
<td>

<p>Any number of objects, each of which is a quadrat test
(object of class <code>"quadrattest"</code>).
</p>
</td></tr>
<tr><td><code id="pool.quadrattest_+3A_df">df</code></td>
<td>

<p>Optional. Number of degrees of freedom of the test statistic.
Relevant only for <code class="reqn">\chi^2</code> tests.
Incompatible with <code>df.est</code>.
</p>
</td></tr>
<tr><td><code id="pool.quadrattest_+3A_df.est">df.est</code></td>
<td>

<p>Optional. The number of fitted parameters, or the
number of degrees of freedom lost by estimation of
parameters. 
Relevant only for <code class="reqn">\chi^2</code> tests.
Incompatible with <code>df</code>.
</p>
</td></tr>
<tr><td><code id="pool.quadrattest_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations, for Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="pool.quadrattest_+3A_xname">Xname</code></td>
<td>

<p>Optional. Name of the original data.
</p>
</td></tr>
<tr><td><code id="pool.quadrattest_+3A_cr">CR</code></td>
<td>

<p>Optional. Numeric value of the Cressie-Read exponent <code>CR</code>
overriding the value used in the tests.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. This is the method for the
class <code>"quadrattest"</code>.
</p>
<p>An object of class <code>"quadrattest"</code> represents a
<code class="reqn">\chi^2</code> test or Monte Carlo test
of goodness-of-fit for a point process model, based on quadrat counts.
Such objects are created by the command <code><a href="#topic+quadrat.test">quadrat.test</a></code>.
</p>
<p>Each of the arguments <code>...</code> must be an object of class
<code>"quadrattest"</code>. They must all be the same type of test
(chi-squared test or Monte Carlo test, conditional or unconditional)
and must all have the same type of alternative hypothesis.
</p>
<p>The test statistic of the pooled test is the Pearson <code class="reqn">X^2</code>
statistic taken over all cells (quadrats) of all tests.
The <code class="reqn">p</code> value of the pooled test is then computed using
either a Monte Carlo test or a <code class="reqn">\chi^2</code> test.
</p>
<p>For a pooled <code class="reqn">\chi^2</code> test, the number of degrees of freedom of
the combined test is computed by adding the degrees of freedom
of all the tests (equivalent to assuming the tests are independent)
unless it is determined by the arguments <code>df</code> or <code>df.est</code>.
The resulting <code class="reqn">p</code> value is computed to obtain the
pooled test.
</p>
<p>For a pooled Monte Carlo test, new simulations are performed
to determine the pooled Monte Carlo <code class="reqn">p</code> value. 
</p>


<h3>Value</h3>

<p>Another object of class <code>"quadrattest"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+quadrat.test">quadrat.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- split(humberside)
  test1 &lt;- quadrat.test(Y[[1]])
  test2 &lt;- quadrat.test(Y[[2]])
  pool(test1, test2, Xname="Humberside")
</code></pre>

<hr>
<h2 id='pool.rat'>
Pool Data from Several Ratio Objects
</h2><span id='topic+pool.rat'></span>

<h3>Description</h3>

<p>Pool the data from several ratio objects
(objects of class <code>"rat"</code>)
and compute a pooled estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rat'
pool(..., weights=NULL, relabel=TRUE, variance=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.rat_+3A_...">...</code></td>
<td>

<p>Objects of class <code>"rat"</code>.
</p>
</td></tr>
<tr><td><code id="pool.rat_+3A_weights">weights</code></td>
<td>

<p>Numeric vector of weights.
</p>
</td></tr>
<tr><td><code id="pool.rat_+3A_relabel">relabel</code></td>
<td>

<p>Logical value indicating whether the result 
should be relabelled to show that it was obtained by pooling.
</p>
</td></tr>
<tr><td><code id="pool.rat_+3A_variance">variance</code></td>
<td>

<p>Logical value indicating whether to compute the sample variance
and related terms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+pool">pool</a></code> is generic. This is the method for the
class <code>"rat"</code> of ratio objects. It is used to
combine several estimates of the same quantity
when each estimate is a ratio. 
</p>
<p>Each of the arguments <code>...</code> must be an object of class
<code>"rat"</code> representing a ratio object (basically a
numerator and a denominator; see <code><a href="#topic+rat">rat</a></code>).
We assume that these ratios are all estimates of the same quantity.
</p>
<p>If the objects are called <code class="reqn">R_1, \ldots, R_n</code>
and if <code class="reqn">R_i</code> has numerator <code class="reqn">Y_i</code> and
denominator <code class="reqn">X_i</code>, so that notionally
<code class="reqn">R_i = Y_i/X_i</code>, then the pooled estimate is the
ratio-of-sums estimator
</p>
<p style="text-align: center;"><code class="reqn">
    R = \frac{\sum_i Y_i}{\sum_i X_i}.
  </code>
</p>

<p>The standard error of <code class="reqn">R</code> is computed using the delta method
as described in Baddeley <em>et al.</em> (1993)
or Cochran (1977, pp 154, 161).
</p>
<p>If the argument <code>weights</code> is given, it should be a numeric vector
of length equal to the number of objects to be pooled. 
The pooled estimator is the ratio-of-sums estimator
</p>
<p style="text-align: center;"><code class="reqn">
    R = \frac{\sum_i w_i Y_i}{\sum_i w_i X_i}
  </code>
</p>

<p>where <code class="reqn">w_i</code> is the <code>i</code>th weight.
</p>
<p>This calculation is implemented only for certain classes of objects
where the arithmetic can be performed.
</p>
<p>This calculation is currently implemented only for objects which
also belong to the class <code>"fv"</code> (function value tables).
For example, if <code><a href="#topic+Kest">Kest</a></code> is called with argument
<code>ratio=TRUE</code>, the result is a suitable object (belonging to the classes
<code>"rat"</code> and <code>"fv"</code>).
</p>
<p>Warnings or errors will be issued if the ratio objects <code>...</code>
appear to be incompatible. However, the code is not smart enough to
decide whether it is sensible to pool the data.
</p>


<h3>Value</h3>

<p>An object of the same class as the input.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A.J, Moyeed, R.A., Howard, C.V. and Boyde, A. (1993)
Analysis of a three-dimensional point pattern with replication.
<em>Applied Statistics</em> <b>42</b>, 641&ndash;668.
</p>
<p>Cochran, W.G. (1977) 
<em>Sampling techniques</em>, 3rd edition.
New York: John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rat">rat</a></code>,
<code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+pool.fv">pool.fv</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K1 &lt;- Kest(runifpoint(42), ratio=TRUE, correction="iso")   
   K2 &lt;- Kest(runifpoint(42), ratio=TRUE, correction="iso")   
   K3 &lt;- Kest(runifpoint(42), ratio=TRUE, correction="iso")
   K &lt;- pool(K1, K2, K3)
   plot(K, pooliso ~ r, shade=c("hiiso", "loiso"))
</code></pre>

<hr>
<h2 id='PPversion'>
Transform a Function into its P-P or Q-Q Version
</h2><span id='topic+PPversion'></span><span id='topic+QQversion'></span>

<h3>Description</h3>

<p>Given a function object <code>f</code> containing both the estimated
and theoretical versions of a summary function, these operations
combine the estimated and theoretical functions into a new function.
When plotted, the new function gives either the P-P plot or Q-Q plot
of the original <code>f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPversion(f, theo = "theo", columns = ".")

QQversion(f, theo = "theo", columns = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPversion_+3A_f">f</code></td>
<td>

<p>The function to be transformed. An object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="PPversion_+3A_theo">theo</code></td>
<td>

<p>The name of the column of <code>f</code> that should be treated as the
theoretical value of the function.
</p>
</td></tr>
<tr><td><code id="PPversion_+3A_columns">columns</code></td>
<td>

<p>Character vector, specifying the columns of <code>f</code>
to which the transformation will be applied.
Either a vector of names of columns of <code>f</code>,
or one of the abbreviations recognised by <code><a href="#topic+fvnames">fvnames</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>f</code> should be an object of class <code>"fv"</code>,
containing both empirical estimates <code class="reqn">\widehat f(r)</code>
and a theoretical value <code class="reqn">f_0(r)</code> for a summary function.
</p>
<p>The <em>P&ndash;P version</em> of <code>f</code> is the function
<code class="reqn">g(x) = \widehat f (f_0^{-1}(x))</code>
where <code class="reqn">f_0^{-1}</code> is the inverse function of
<code class="reqn">f_0</code>.
A plot of <code class="reqn">g(x)</code> against <code class="reqn">x</code> 
is equivalent to a plot of <code class="reqn">\widehat f(r)</code> against
<code class="reqn">f_0(r)</code> for all <code class="reqn">r</code>.
If <code>f</code> is a cumulative distribution function (such as the
result of <code><a href="#topic+Fest">Fest</a></code> or <code><a href="#topic+Gest">Gest</a></code>) then
this is a P&ndash;P plot, a plot of the observed versus theoretical
probabilities for the distribution.
The diagonal line <code class="reqn">y=x</code>
corresponds to perfect agreement between observed and theoretical
distribution.
</p>
<p>The <em>Q&ndash;Q version</em> of <code>f</code> is the function
<code class="reqn">h(x) = f_0^{-1}(\widehat f(x))</code>.
If <code>f</code> is a cumulative distribution function,
a plot of <code class="reqn">h(x)</code> against <code class="reqn">x</code>
is a Q&ndash;Q plot, a plot of the observed versus theoretical
quantiles of the distribution.
The diagonal line <code class="reqn">y=x</code>
corresponds to perfect agreement between observed and theoretical
distribution.
Another straight line corresponds to the situation where the
observed variable is a linear transformation of the theoretical variable.
For a point pattern <code>X</code>, the Q&ndash;Q version of <code>Kest(X)</code> is
essentially equivalent to <code>Lest(X)</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Tom Lawrence
and Adrian Baddeley.
</p>
<p>Implemented by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fv">plot.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mar=0.1+c(5,5,4,2))
  G &lt;- Gest(redwoodfull)
  plot(PPversion(G))
  plot(QQversion(G))
  par(opa)
</code></pre>

<hr>
<h2 id='quadrat.test'>Dispersion Test for Spatial Point Pattern Based on
Quadrat Counts</h2><span id='topic+quadrat.test'></span><span id='topic+quadrat.test.ppp'></span><span id='topic+quadrat.test.quadratcount'></span>

<h3>Description</h3>

<p>Performs a test of Complete Spatial Randomness
for a given point pattern, based on quadrat counts.
Alternatively performs a goodness-of-fit test of a fitted
inhomogeneous Poisson model.
By default performs chi-squared tests; can also perform
Monte Carlo based tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrat.test(X, ...)

## S3 method for class 'ppp'
quadrat.test(X, nx=5, ny=nx,
                          alternative=c("two.sided", "regular", "clustered"),
                           method=c("Chisq", "MonteCarlo"),
                           conditional=TRUE, CR=1,
                           lambda=NULL, df.est=NULL,
                           ...,
                           xbreaks=NULL, ybreaks=NULL, tess=NULL,
                           nsim=1999)
## S3 method for class 'quadratcount'
quadrat.test(X,
                          alternative=c("two.sided", "regular", "clustered"),
                          method=c("Chisq", "MonteCarlo"),
                          conditional=TRUE, CR=1,
                          lambda=NULL, df.est=NULL,
                          ...,
                          nsim=1999)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrat.test_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
to be subjected to the goodness-of-fit test.
Alternatively a fitted point process model (object of class
<code>"ppm"</code> or <code>"slrm"</code>) to be tested.
Alternatively <code>X</code> can be the result of applying
<code>quadratcount</code> to a point pattern.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_nx">nx</code>, <code id="quadrat.test_+3A_ny">ny</code></td>
<td>

<p>Numbers of quadrats in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
Incompatible with <code>xbreaks</code> and <code>ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_alternative">alternative</code></td>
<td>

<p>Character string (partially matched) specifying the alternative
hypothesis.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_method">method</code></td>
<td>

<p>Character string (partially matched) specifying the test to use:
either <code>method="Chisq"</code> for the chi-squared test (the default),
or <code>method="MonteCarlo"</code> for a Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_conditional">conditional</code></td>
<td>

<p>Logical.  Should the Monte Carlo test be conducted
conditionally upon the observed number of points of the pattern?
Ignored if <code>method="Chisq"</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_cr">CR</code></td>
<td>

<p>Optional. Numerical value. The exponent
for the Cressie-Read test statistic. See Details.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_lambda">lambda</code></td>
<td>

<p>Optional. Pixel image (object of class <code>"im"</code>)
or function (class <code>"funxy"</code>) giving the predicted
intensity of the point process.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_df.est">df.est</code></td>
<td>

<p>Optional. Advanced use only.
The number of fitted parameters, or the
number of degrees of freedom lost by estimation of
parameters. 
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_xbreaks">xbreaks</code></td>
<td>

<p>Optional. Numeric vector giving the <code class="reqn">x</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_ybreaks">ybreaks</code></td>
<td>

<p>Optional. Numeric vector giving the <code class="reqn">y</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_tess">tess</code></td>
<td>

<p>Tessellation (object of class <code>"tess"</code> or something acceptable
to <code>as.tess</code>) determining the
quadrats. Incompatible with <code>nx, ny, xbreaks, ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulated samples to generate when
<code>method="MonteCarlo"</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform <code class="reqn">\chi^2</code> tests or Monte Carlo tests
of goodness-of-fit for a point process model, based on quadrat counts.
</p>
<p>The function <code>quadrat.test</code> is generic, with methods for
point patterns (class <code>"ppp"</code>), split point patterns
(class <code>"splitppp"</code>), point process models
(class <code>"ppm"</code> or <code>"slrm"</code>)
and quadrat count tables (class <code>"quadratcount"</code>).
</p>

<ul>
<li>
<p>if <code>X</code> is a point pattern, we test the null hypothesis
that the data pattern is a realisation of Complete Spatial
Randomness (the uniform Poisson point process). Marks in the point
pattern are ignored. (If <code>lambda</code> is given then the null
hypothesis is the Poisson process with intensity <code>lambda</code>.)
</p>
</li>
<li> 
<p>if <code>X</code> is a split point pattern, then for each of the
component point patterns (taken separately) we test 
the null hypotheses of Complete Spatial Randomness.
See <code><a href="#topic+quadrat.test.splitppp">quadrat.test.splitppp</a></code> for documentation.
</p>
</li>
<li>
<p>If <code>X</code> is a fitted point process model, then it should be
a Poisson point process model. The 
data to which this model was fitted are extracted from the model
object, and are treated as the data point pattern for the test.
We test the null hypothesis 
that the data pattern is a realisation of the (inhomogeneous) Poisson point
process specified by <code>X</code>.
</p>
</li></ul>

<p>In all cases, the window of observation is divided
into tiles, and the number of data points in each tile is
counted, as described in <code>quadratcount</code>.
The quadrats are rectangular by default, or may be regions of arbitrary shape
specified by the argument <code>tess</code>.
The expected number of points in each quadrat is also calculated,
as determined by CSR (in the first case) or by the fitted model
(in the second case).
Then the Pearson <code class="reqn">X^2</code> statistic 
</p>
<p style="text-align: center;"><code class="reqn">
    X^2 = sum((observed - expected)^2/expected)
  </code>
</p>

<p>is computed.
</p>
<p>If <code>method="Chisq"</code> then a <code class="reqn">\chi^2</code> test of
goodness-of-fit is performed by comparing the test statistic
to the <code class="reqn">\chi^2</code> distribution
with <code class="reqn">m-k</code> degrees of freedom, where <code>m</code> is the number of
quadrats and <code class="reqn">k</code> is the number of fitted parameters
(equal to 1 for <code>quadrat.test.ppp</code>). The default is to
compute the <em>two-sided</em> <code class="reqn">p</code>-value, so that the test will
be declared significant if <code class="reqn">X^2</code> is either very large or very
small. One-sided <code class="reqn">p</code>-values can be obtained by specifying the
<code>alternative</code>. An important requirement of the
<code class="reqn">\chi^2</code> test is that the expected counts in each quadrat
be greater than 5.
</p>
<p>If <code>method="MonteCarlo"</code> then a Monte Carlo test is performed,
obviating the need for all expected counts to be at least 5.  In the
Monte Carlo test, <code>nsim</code> random point patterns are generated
from the null hypothesis (either CSR or the fitted point process
model). The Pearson <code class="reqn">X^2</code> statistic is computed as above.
The <code class="reqn">p</code>-value is determined by comparing the <code class="reqn">X^2</code>
statistic for the observed point pattern, with the values obtained
from the simulations. Again the default is to
compute the <em>two-sided</em> <code class="reqn">p</code>-value.
</p>
<p>If <code>conditional</code> is <code>TRUE</code> then the simulated samples are
generated from the multinomial distribution with the number of &ldquo;trials&rdquo;
equal to the number of observed points and the vector of probabilities
equal to the expected counts divided by the sum of the expected counts.
Otherwise the simulated samples are independent Poisson counts, with
means equal to the expected counts.
</p>
<p>If the argument <code>CR</code> is given, then instead of the
Pearson <code class="reqn">X^2</code> statistic, the Cressie-Read (1984) power divergence
test statistic
</p>
<p style="text-align: center;"><code class="reqn">
    2nI = \frac{2}{CR(CR+1)}
           \sum_i \left[ \left( \frac{X_i}{E_i} \right)^CR - 1 \right]
  </code>
</p>

<p>is computed, where <code class="reqn">X_i</code> is the <code class="reqn">i</code>th observed count
and <code class="reqn">E_i</code> is the corresponding expected count.
The value <code>CR=1</code> gives the Pearson <code class="reqn">X^2</code> statistic;
<code>CR=0</code> gives the likelihood ratio test statistic <code class="reqn">G^2</code>;
<code>CR=-1/2</code> gives the Freeman-Tukey statistic <code class="reqn">T^2</code>;
<code>CR=-1</code> gives the modified likelihood ratio test statistic <code class="reqn">GM^2</code>;
and <code>CR=-2</code> gives Neyman's modified statistic <code class="reqn">NM^2</code>.
In all cases the asymptotic distribution of this test statistic is
the same <code class="reqn">\chi^2</code> distribution as above.
</p>
<p>The return value is an object of class <code>"htest"</code>.
Printing the object gives comprehensible output
about the outcome of the test.
</p>
<p>The return value also belongs to
the special class <code>"quadrat.test"</code>. Plotting the object
will display the quadrats, annotated by their observed and expected
counts and the Pearson residuals. See the examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code>. See <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
for explanation. 
</p>
<p>The return value is also an object of the special class
<code>"quadrattest"</code>, and there is a plot method for this class.
See the examples.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Cressie, N. and Read, T.R.C. (1984)
Multinomial goodness-of-fit tests.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>46</b>, 440&ndash;464. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrat.test.splitppp">quadrat.test.splitppp</a></code>,
<code>quadratcount</code>,
<code>quadrats</code>,
<code>quadratresample</code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="#topic+cdf.test">cdf.test</a></code>.
</p>
<p>To test a Poisson point process model against a specific alternative,
use <code><a href="spatstat.model.html#topic+anova.ppm">anova.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  quadrat.test(simdat)
  quadrat.test(simdat, 4, 3)

  quadrat.test(simdat, alternative="regular")
  quadrat.test(simdat, alternative="clustered")

  ## Likelihood ratio test
  quadrat.test(simdat, CR=0)
  ## Power divergence tests
  quadrat.test(simdat, CR=-1)$p.value
  quadrat.test(simdat, CR=-2)$p.value

  # Using Monte Carlo p-values
  quadrat.test(swedishpines) # Get warning, small expected values.
  Nsim &lt;- if(interactive()) 4999 else 9
  quadrat.test(swedishpines, method="M", nsim=Nsim)
  quadrat.test(swedishpines, method="M", nsim=Nsim, conditional=FALSE)

  # quadrat counts
  qS &lt;- quadratcount(simdat, 4, 3)
  quadrat.test(qS)


  te &lt;- quadrat.test(simdat, 4)
  residuals(te)  # Pearson residuals

  plot(te)

  plot(simdat, pch="+", cols="green", lwd=2)
  plot(te, add=TRUE, col="red", cex=1.4, lty=2, lwd=3)

  sublab &lt;- eval(substitute(expression(p[chi^2]==z),
                       list(z=signif(te$p.value,3))))
  title(sub=sublab, cex.sub=3)

  # quadrats of irregular shape
  B &lt;- dirichlet(runifpoint(6, Window(simdat)))
  qB &lt;- quadrat.test(simdat, tess=B)
  plot(simdat, main="quadrat.test(simdat, tess=B)", pch="+")
  plot(qB, add=TRUE, col="red", lwd=2, cex=1.2)
</code></pre>

<hr>
<h2 id='quadrat.test.splitppp'>Dispersion Test of CSR for Split Point Pattern Based on
Quadrat Counts</h2><span id='topic+quadrat.test.splitppp'></span>

<h3>Description</h3>

<p>Performs a test of Complete Spatial Randomness
for each of the component patterns in a split point pattern,
based on quadrat counts.
By default performs chi-squared tests; can also perform
Monte Carlo based tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitppp'
quadrat.test(X, ..., df=NULL, df.est=NULL, Xname=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrat.test.splitppp_+3A_x">X</code></td>
<td>

<p>A split point pattern (object of class <code>"splitppp"</code>),
each component of which will be subjected to the goodness-of-fit test.
</p>
</td></tr>
<tr><td><code id="quadrat.test.splitppp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+quadrat.test.ppp">quadrat.test.ppp</a></code>.</p>
</td></tr>
<tr><td><code id="quadrat.test.splitppp_+3A_df">df</code>, <code id="quadrat.test.splitppp_+3A_df.est">df.est</code>, <code id="quadrat.test.splitppp_+3A_xname">Xname</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+pool.quadrattest">pool.quadrattest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>quadrat.test</code> is generic, with methods for
point patterns (class <code>"ppp"</code>), split point patterns
(class <code>"splitppp"</code>) and point process models
(class <code>"ppm"</code>).
</p>
<p>If <code>X</code> is a split point pattern, then for each of the
component point patterns (taken separately) we test 
the null hypotheses of Complete Spatial Randomness,
then combine the result into a single test.
</p>
<p>The method <code>quadrat.test.ppp</code> is applied to each
component point pattern. Then the results are pooled using
<code><a href="#topic+pool.quadrattest">pool.quadrattest</a></code> to obtain a single test.
</p>


<h3>Value</h3>

<p>An object of class <code>"quadrattest"</code> which can be printed and
plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrat.test">quadrat.test</a></code>,
<code>quadratcount</code>,
<code>quadrats</code>,
<code>quadratresample</code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="#topic+cdf.test">cdf.test</a></code>.
</p>
<p>To test a Poisson point process model against a specific Poisson alternative,
use <code><a href="spatstat.model.html#topic+anova.ppm">anova.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> qH &lt;- quadrat.test(split(humberside), 2, 3)
 plot(qH)
 qH
</code></pre>

<hr>
<h2 id='quantile.density'>
Quantiles of a Density Estimate
</h2><span id='topic+quantile.density'></span>

<h3>Description</h3>

<p>Given a kernel estimate of a probability density, compute quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
quantile(x, probs = seq(0, 1, 0.25), names = TRUE,
        ..., warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.density_+3A_x">x</code></td>
<td>

<p>Object of class <code>"density"</code> computed by a method for
<code><a href="stats.html#topic+density">density</a></code>
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_probs">probs</code></td>
<td>

<p>Numeric vector of probabilities for which the quantiles are required.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_names">names</code></td>
<td>

<p>Logical value indicating whether to attach names (based on
<code>probs</code>) to the result.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
density estimate <code>x</code> had to be renormalised because it
was computed in a restricted interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates quantiles of the probability distribution
whose probability density has been estimated and stored in the object
<code>x</code>. The object <code>x</code> must belong to the class <code>"density"</code>,
and would typically have been obtained from a call to the function
<code><a href="stats.html#topic+density">density</a></code>.
</p>
<p>The probability density is first normalised so that the total
probability is equal to 1. A warning is issued if the density
estimate was restricted to an interval (i.e. if <code>x</code>
was created by a call to   <code><a href="stats.html#topic+density">density</a></code> which
included either of the arguments <code>from</code> and <code>to</code>).
</p>
<p>Next, the density estimate is numerically integrated to obtain an estimate
of the cumulative distribution function <code class="reqn">F(x)</code>. Then
for each desired probability <code class="reqn">p</code>, the algorithm finds the
corresponding quantile <code class="reqn">q</code>.
</p>
<p>The quantile <code class="reqn">q</code> corresponding to probability <code class="reqn">p</code>
satisfies <code class="reqn">F(q) = p</code> up to
the resolution of the grid of values contained in <code>x</code>.
The quantile is computed from the right, that is,
<code class="reqn">q</code> is the smallest available value of <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>.
</p>


<h3>Value</h3>

<p>A numeric vector containing the quantiles.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, 
<code>quantile.ewcdf</code>, 

<code><a href="#topic+CDF">CDF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   dd &lt;- density(runif(10))
   quantile(dd)
</code></pre>

<hr>
<h2 id='radcumint'>
Radial Cumulative Integral
</h2><span id='topic+radcumint'></span>

<h3>Description</h3>

<p>Compute the cumulative integral of an image over increasing radial
distances from the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radcumint(X, ..., origin, Xname, result = c("fv", "im"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radcumint_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>)
with numerical or logical values.
</p>
</td></tr>
<tr><td><code id="radcumint_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="radcumint_+3A_origin">origin</code></td>
<td>

<p>Optional. Origin about which the rotations should be performed.
Either a numeric vector or a character string as described
in the help for <code>shift.owin</code>.
</p>
</td></tr>
<tr><td><code id="radcumint_+3A_xname">Xname</code></td>
<td>

<p>Optional name for <code>X</code> to be used in the
function labels.
</p>
</td></tr>
<tr><td><code id="radcumint_+3A_result">result</code></td>
<td>

<p>Character string specifying the kind of result required:
either a function object or a pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes, for each possible distance <code class="reqn">r</code>,
the integral of the pixel values lying inside the disc of radius
<code class="reqn">r</code> centred at the origin. 
</p>
<p>If <code>result="fv"</code> (the default) the result is a function
object <code>f</code> of class <code>"fv"</code>. For each value of radius <code class="reqn">r</code>,
the function value <code>f(r)</code> is the integral of <code>X</code>
over the disc of radius <code class="reqn">r</code>.
</p>
<p>If <code>result="im"</code> the result is a pixel image, with the same
dimensions as <code>X</code>. At a given pixel, the result is
equal to <code>f(r)</code> where <code>r</code> is the distance from the given
pixel to the origin. That is, at any given pixel, the resulting value
is the integral of <code>X</code> over the disc
centred at the origin whose boundary passes through the given pixel. 
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> or <code>"im"</code>,
with the same coordinate units as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotmean">rotmean</a></code>, <code><a href="#topic+spatialcdf">spatialcdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   D &lt;- density(redwood)
   plot(radcumint(D))
   plot(radcumint(D, result="im"))
</code></pre>

<hr>
<h2 id='rat'>
Ratio object
</h2><span id='topic+rat'></span>

<h3>Description</h3>

<p>Stores the numerator, denominator, and value of a ratio
as a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rat(ratio, numerator, denominator, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rat_+3A_ratio">ratio</code>, <code id="rat_+3A_numerator">numerator</code>, <code id="rat_+3A_denominator">denominator</code></td>
<td>

<p>Three objects belonging to the same class.
</p>
</td></tr>
<tr><td><code id="rat_+3A_check">check</code></td>
<td>

<p>Logical. Whether to check that
the objects are <code>compatible</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"rat"</code> is a simple mechanism for keeping track of
the numerator and denominator when calculating a ratio. Its main
purpose is simply to signal that the object is a ratio.
</p>
<p>The function <code>rat</code> creates an object of class <code>"rat"</code>
given the numerator, the denominator and the ratio.
No calculation is performed; 
the three objects are simply stored together.
</p>
<p>The arguments <code>ratio</code>, <code>numerator</code>, <code>denominator</code>
can be objects of any kind. They should belong to the same class.
It is assumed that the relationship
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{ratio} = \frac{\mbox{numerator}}{\mbox{denominator}}
  </code>
</p>

<p>holds in some version of arithmetic. However, no calculation is
performed.
</p>
<p>By default the algorithm checks
whether the three arguments <code>ratio</code>, <code>numerator</code>,
<code>denominator</code> are compatible objects, according to
<code>compatible</code>.
</p>
<p>The result is equivalent to <code>ratio</code> except for the
addition of extra information.
</p>


<h3>Value</h3>

<p>An object equivalent to the object <code>ratio</code>
except that it also belongs to the class <code>"rat"</code>
and has additional attributes <code>numerator</code> and <code>denominator</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code>compatible</code>, 
<code><a href="#topic+pool">pool</a></code>
</p>

<hr>
<h2 id='rectcontact'>
Contact Distribution Function using Rectangular Structuring Element
</h2><span id='topic+rectcontact'></span>

<h3>Description</h3>

<p>Computes an estimate of the contact distribution function
of a set, using a rectangular structuring element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectcontact(X, ..., asp = 1, npasses=4,
            eps = NULL, r = NULL, breaks = NULL, correction = c("rs", "km"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectcontact_+3A_x">X</code></td>
<td>

<p>Logical-valued image. The <code>TRUE</code> values in the image
determine the spatial region whose contact distribution function
should be estimated. 
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_asp">asp</code></td>
<td>

<p>Aspect ratio for the rectangular metric. A single positive number.
See <code>rectdistmap</code> for explanation.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_npasses">npasses</code></td>
<td>

<p>Number of passes to perform in the distance algorithm. A positive integer.
See <code>rectdistmap</code> for explanation.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_eps">eps</code></td>
<td>

<p>Pixel size, if the image should be converted to a finer grid.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_r">r</code></td>
<td>

<p>Optional vector of distance values. Do Not Use This.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_breaks">breaks</code></td>
<td>

<p>Do Not Use This.
</p>
</td></tr>
<tr><td><code id="rectcontact_+3A_correction">correction</code></td>
<td>

<p>Character vector specifying the edge correction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be written.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hest">Hest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## make an image which is TRUE/FALSE inside/outside the letter R
  V &lt;- letterR
  Frame(V) &lt;- grow.rectangle(Frame(V), 0.5)
  Z &lt;- as.im(V, value=TRUE, na.replace=FALSE)
  ## analyse
  plot(rectcontact(Z))
</code></pre>

<hr>
<h2 id='reduced.sample'>Reduced Sample Estimator using Histogram Data</h2><span id='topic+reduced.sample'></span>

<h3>Description</h3>

<p>Compute the Reduced Sample estimator of a survival time distribution
function, from histogram data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  reduced.sample(nco, cen, ncc, show=FALSE, uppercen=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduced.sample_+3A_nco">nco</code></td>
<td>
<p>vector of counts giving the histogram of
uncensored observations (those survival times that are less than or
equal to the censoring time)
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_cen">cen</code></td>
<td>
<p>vector of counts giving the histogram of
censoring times
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_ncc">ncc</code></td>
<td>
<p>vector of counts giving the histogram of
censoring times for the uncensored observations only 
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_uppercen">uppercen</code></td>
<td>

<p>number of censoring times greater than the rightmost
histogram breakpoint (if there are any)
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_show">show</code></td>
<td>
<p>Logical value controlling the amount of detail
returned by the function value (see below)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
reduced sample estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>If the number of observations <code class="reqn">M</code> is large, it is efficient to
use histograms.
Form the histogram <code>cen</code> of all censoring times <code class="reqn">C_i</code>.
That is, <code>obs[k]</code> counts the number of values 
<code class="reqn">C_i</code> in the interval
<code>(breaks[k],breaks[k+1]]</code> for <code class="reqn">k &gt; 1</code>
and <code>[breaks[1],breaks[2]]</code> for <code class="reqn">k = 1</code>.
Also form the histogram <code>nco</code> of all uncensored times,
i.e. those <code class="reqn">\tilde T_i</code> such that <code class="reqn">D_i=1</code>,
and the histogram of all censoring times for which the survival time
is uncensored,
i.e. those <code class="reqn">C_i</code> such that <code class="reqn">D_i=1</code>.
These three histograms are the arguments passed to <code>kaplan.meier</code>.
</p>
<p>The return value <code>rs</code> is the reduced-sample estimator
of the distribution function <code class="reqn">F(t)</code>. Specifically,
<code>rs[k]</code> is the reduced sample estimate of <code>F(breaks[k+1])</code>.
The value is exact, i.e. the use of histograms does not introduce any
approximation error.
</p>
<p>Note that, for the results to be valid, either the histogram breaks
must span the censoring times, or the number of censoring times
that do not fall in a histogram cell must have been counted in
<code>uppercen</code>.
</p>


<h3>Value</h3>

<p>If <code>show = FALSE</code>, a numeric vector giving the values of
the reduced sample estimator.
If <code>show=TRUE</code>, a list with three components which are
vectors of equal length,
</p>
<table>
<tr><td><code>rs</code></td>
<td>
<p>Reduced sample estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>numerator</code></td>
<td>
<p>numerator of the reduced sample estimator
</p>
</td></tr>
<tr><td><code>denominator</code></td>
<td>
<p>denominator of the reduced sample estimator
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kaplan.meier">kaplan.meier</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>
</p>

<hr>
<h2 id='reload.or.compute'>
Compute Unless Previously Saved
</h2><span id='topic+reload.or.compute'></span>

<h3>Description</h3>

<p>If the designated file does not yet exist,
evaluate the expression and save the results in the file.
If the file already exists, re-load the results from the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reload.or.compute(filename, expr, objects = NULL,
                  context = parent.frame(), 
                  destination = parent.frame(),
                  force=FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reload.or.compute_+3A_filename">filename</code></td>
<td>

<p>Name of data file. A character string.
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_expr">expr</code></td>
<td>

<p><span class="rlang"><b>R</b></span> language expression to be evaluated.
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_objects">objects</code></td>
<td>

<p>Optional character vector of names of objects to be saved
in <code>filename</code> after evaluating <code>expr</code>,
or names of objects that should be present in <code>filename</code>
when loaded.
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_context">context</code></td>
<td>

<p>Environment containing objects that are mentioned in <code>expr</code>
(other than objects in the global environment).
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_destination">destination</code></td>
<td>

<p>Environment into which the resulting objects should be assigned.
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_force">force</code></td>
<td>

<p>Logical value indicating whether to perform the computation
in any case.
</p>
</td></tr>
<tr><td><code id="reload.or.compute_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print a message indicating
whether the data were recomputed or reloaded from the file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This facility is useful for saving, and later re-loading, the results of
time-consuming computations. It would typically be
used in an <span class="rlang"><b>R</b></span> script file or an <code><a href="utils.html#topic+Sweave">Sweave</a></code> document.
</p>
<p>If the file called <code>filename</code> does not yet exist,
then <code>expr</code> will be evaluated
and the results will be saved in <code>filename</code>.
The optional argument <code>objects</code> specifies which results should be saved
to the file: the default is to save all objects that were created
by evaluating the expression. 
</p>
<p>If the file called <code>filename</code> already exists, then it
will be loaded.
The optional argument <code>objects</code> specifies the names
of objects that should be present in the file; a warning is issued
if any of them are missing.
</p>
<p>The resulting objects can be assigned into any desired <code>destination</code>.
The default behaviour is equivalent to evaluating <code>expr</code>
in the current environment.
</p>
<p>If <code>force=TRUE</code> then <code>expr</code> will be evaluated
(regardless of whether the file already exists or not)
and the results will be saved in <code>filename</code>, overwriting
any previously-existing file with that name. This is a convenient
way to force the code to re-compute everything
in an <span class="rlang"><b>R</b></span> script file or <code><a href="utils.html#topic+Sweave">Sweave</a></code> document.
</p>


<h3>Value</h3>

<p>Character vector (invisible) giving the names of the objects computed
or loaded.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Demonstration using a temporary file
  ## (For real applications, use a permanent file in your own filespace)
  myfile &lt;- paste0(tempdir(), .Platform$file.sep, "mydata.rda")
  reload.or.compute(myfile, {
     # some very long computation ending with ..
     x &lt;- 42
     y &lt;- sqrt(x)
  })
</code></pre>

<hr>
<h2 id='relrisk'>
Estimate of Spatially-Varying Relative Risk
</h2><span id='topic+relrisk'></span>

<h3>Description</h3>

<p>Generic command to estimate the 
spatially-varying probability of each type of point, or the ratios of
such probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  relrisk(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrisk_+3A_x">X</code></td>
<td>

<p>Either a point pattern (class <code>"ppp"</code>)
or a fitted point process model (class <code>"ppm"</code>)
from which the probabilities will be estimated.
</p>
</td></tr>
<tr><td><code id="relrisk_+3A_...">...</code></td>
<td>

<p>Additional arguments appropriate to the method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a point pattern containing several different types of points,
we may be interested in the spatially-varying probability of each
possible type, or the relative risks which are the
ratios of such probabilities.
</p>
<p>The command <code><a href="#topic+relrisk">relrisk</a></code> is generic and can be used to
estimate relative risk in different ways.
</p>
<p>The function <code><a href="#topic+relrisk.ppp">relrisk.ppp</a></code> is the method for point pattern
datasets. It computes <em>nonparametric</em> estimates of relative risk
by kernel smoothing.
</p>
<p>The function <code><a href="spatstat.model.html#topic+relrisk.ppm">relrisk.ppm</a></code> is the method for fitted point
process models (class <code>"ppm"</code>). It computes <em>parametric</em>
estimates of relative risk, using the fitted model.
</p>


<h3>Value</h3>

<p>A pixel image, or a list of pixel images, or a numeric vector or
matrix, containing the requested estimates of relative risk.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relrisk.ppp">relrisk.ppp</a></code>,
<code><a href="spatstat.model.html#topic+relrisk.ppm">relrisk.ppm</a></code>.
</p>

<hr>
<h2 id='relrisk.ppp'>
Nonparametric Estimate of Spatially-Varying Relative Risk
</h2><span id='topic+relrisk.ppp'></span>

<h3>Description</h3>

<p>Given a multitype point pattern, this function estimates the
spatially-varying probability of each type of point, or the ratios of
such probabilities, using kernel smoothing.
The default smoothing bandwidth is selected by
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
relrisk(X, sigma = NULL, ...,
           at = c("pixels", "points"),
           weights = NULL, varcov = NULL, 
           relative=FALSE,
           adjust=1, edge=TRUE, diggle=FALSE,
           se=FALSE, wtype=c("value", "multiplicity"),
           casecontrol=TRUE, control=1, case, fudge=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrisk.ppp_+3A_x">X</code></td>
<td>

<p>A multitype point pattern (object of class <code>"ppp"</code>
which has factor valued marks).
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Optional. The numeric value of the smoothing bandwidth
(the standard deviation of isotropic
Gaussian smoothing kernel).
Alternatively <code>sigma</code> may be a function which can be used
to select a different bandwidth for each type of point. See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+bw.relrisk">bw.relrisk</a></code> to select the
bandwidth, or passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to control the
pixel resolution.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_at">at</code></td>
<td>

<p>Character string specifying whether to compute the probability values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional. Weights for the data points of <code>X</code>.
A numeric vector, an <code>expression</code>, or a pixel image.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_varcov">varcov</code></td>
<td>

<p>Optional. Variance-covariance matrix of anisotopic Gaussian
smoothing kernel. Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_relative">relative</code></td>
<td>

<p>Logical.
If <code>FALSE</code> (the default) the algorithm
computes the probabilities of each type of point.
If <code>TRUE</code>, it computes the    
<em>relative risk</em>, the ratio of probabilities
of each type relative to the probability of a control.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the bandwidth <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Logical. If <code>TRUE</code>, use the Jones-Diggle improved edge correction,
which is more accurate but slower to compute than the default
correction.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to compute standard errors
as well.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_wtype">wtype</code></td>
<td>

<p>Character string (partially matched) specifying how the weights
should be interpreted for the calculation of standard error.
See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_casecontrol">casecontrol</code></td>
<td>

<p>Logical. Whether to treat a bivariate point pattern
as consisting of cases and controls, and return only the
probability or relative risk of a case.
Ignored if there are more than 2 types of points.
See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_control">control</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a control. 
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_case">case</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a case (rather than a control)
in a bivariate point pattern.
This is an alternative to the argument <code>control</code>
in a bivariate point pattern. 
Ignored if there are more than 2 types of points.
</p>
</td></tr>
<tr><td><code id="relrisk.ppp_+3A_fudge">fudge</code></td>
<td>

<p>Optional. A single numeric value,
or a numeric vector with one entry for each type of point.
This value will be added to the estimates
of point process intensity, before calculation of the relative risk.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code><a href="#topic+relrisk">relrisk</a></code> is generic and can be used to
estimate relative risk in different ways.
</p>
<p>This function <code>relrisk.ppp</code> is the method for point pattern
datasets. It computes <em>nonparametric</em> estimates of relative risk
by kernel smoothing (Bithell, 1990, 1991; Diggle, 2003; Baddeley,
Rubak and Turner, 2015).
</p>
<p>If <code>X</code>  is a bivariate point pattern
(a multitype point pattern consisting of two types of points)
then by default,
the points of the first type (the first level of <code>marks(X)</code>)
are treated as controls or non-events, and points of the second type
are treated as cases or events. Then by default this command computes
the spatially-varying <em>probability</em> of a case,
i.e. the probability <code class="reqn">p(u)</code>
that a point at spatial location <code class="reqn">u</code>
will be a case. If <code>relative=TRUE</code>, it computes the
spatially-varying <em>relative risk</em> of a case relative to a
control, <code class="reqn">r(u) = p(u)/(1- p(u))</code>.
</p>
<p>If <code>X</code> is a multitype point pattern with <code class="reqn">m &gt; 2</code> types,
or if <code>X</code> is a bivariate point pattern
and <code>casecontrol=FALSE</code>,
then by default this command computes, for each type <code class="reqn">j</code>,
a nonparametric estimate of
the spatially-varying <em>probability</em> of an event of type <code class="reqn">j</code>.
This is the probability <code class="reqn">p_j(u)</code>
that a point at spatial location <code class="reqn">u</code>
will belong to type <code class="reqn">j</code>.
If <code>relative=TRUE</code>, the command computes the
<em>relative risk</em> of an event of type <code class="reqn">j</code>
relative to a control,
<code class="reqn">r_j(u) = p_j(u)/p_k(u)</code>,
where events of type <code class="reqn">k</code> are treated as controls.
The argument <code>control</code> determines which type <code class="reqn">k</code>
is treated as a control.
</p>
<p>If <code>at = "pixels"</code> the calculation is performed for
every spatial location <code class="reqn">u</code> on a fine pixel grid, and the result
is a pixel image representing the function <code class="reqn">p(u)</code>
or a list of pixel images representing the functions 
<code class="reqn">p_j(u)</code> or <code class="reqn">r_j(u)</code>
for <code class="reqn">j = 1,\ldots,m</code>.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>NA</code>.
</p>
<p>If <code>at = "points"</code> the calculation is performed
only at the data points <code class="reqn">x_i</code>. By default
the result is a vector of values
<code class="reqn">p(x_i)</code> giving the estimated probability of a case
at each data point, or a matrix of values 
<code class="reqn">p_j(x_i)</code> giving the estimated probability of
each possible type <code class="reqn">j</code> at each data point.
If <code>relative=TRUE</code> then the relative risks
<code class="reqn">r(x_i)</code> or <code class="reqn">r_j(x_i)</code> are
returned.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>Inf</code>.
</p>
<p>Estimation is performed by a simple Nadaraja-Watson type kernel
smoother (Bithell, 1990, 1991; Diggle, 2003; Baddeley, Rubak and
Turner, 2015, section 14.4).
The smoothing bandwidth can be specified in any of the following ways:
</p>

<ul>
<li> <p><code>sigma</code> is a single numeric value, giving the standard
deviation of the isotropic Gaussian kernel.
</p>
</li>
<li> <p><code>sigma</code> is a numeric vector of length 2, giving the
standard deviations in the <code class="reqn">x</code> and <code class="reqn">y</code> directions of
a Gaussian kernel.
</p>
</li>
<li> <p><code>varcov</code> is a 2 by 2 matrix giving the
variance-covariance matrix of the Gaussian kernel.
</p>
</li>
<li> <p><code>sigma</code> is a <code>function</code> which selects
the bandwidth. 
Bandwidth selection will be applied
<b>separately to each type of point</b>.
An example of such a function is <code><a href="#topic+bw.diggle">bw.diggle</a></code>.
</p>
</li>
<li> 
<p><code>sigma</code> and <code>varcov</code>
are both missing or null. Then a <b>common</b>
smoothing bandwidth <code>sigma</code>
will be selected by cross-validation using <code><a href="#topic+bw.relrisk">bw.relrisk</a></code>.
</p>
</li>
<li>
<p>An infinite smoothing bandwidth, <code>sigma=Inf</code>, is permitted
and yields a constant estimate of relative risk.
</p>
</li></ul>

<p>If <code>se=TRUE</code> then standard errors will also be computed,
based on asymptotic theory, <em>assuming a Poisson process</em>.
</p>
<p>The optional argument <code>weights</code> may provide numerical weights
for the points of <code>X</code>. It should be a numeric vector of length
equal to <code>npoints(X)</code>.
</p>
<p>The argument <code>weights</code> can also be an <code>expression</code>.
It will be evaluated in the data frame <code>as.data.frame(X)</code>
to obtain a vector of weights. The expression may involve
the symbols <code>x</code> and <code>y</code> representing the Cartesian
coordinates, and the symbol <code>marks</code> representing the mark values.
</p>
<p>The argument <code>weights</code> can also be a pixel image
(object of class <code>"im"</code>). numerical weights for the data points
will be extracted from this image (by looking up the pixel values
at the locations of the data points in <code>X</code>).
</p>


<h3>Value</h3>

<p>If <code>se=FALSE</code> (the default), the format is described below.
If <code>se=TRUE</code>, the result is a list of two entries,
<code>estimate</code> and <code>SE</code>, each having the format described below.
</p>
<p>If <code>X</code> consists of only two types of points,
and if <code>casecontrol=TRUE</code>,
the result is a pixel image (if <code>at="pixels"</code>)
or a vector (if <code>at="points"</code>).
The pixel values or vector values
are the probabilities of a case if <code>relative=FALSE</code>,
or the relative risk of a case (probability of a case divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>X</code> consists of more than two types of points,
or if <code>casecontrol=FALSE</code>, the result is:
</p>

<ul>
<li><p> (if <code>at="pixels"</code>)
a list of pixel images, with one image for each possible type of point.
The result also belongs to the class <code>"solist"</code> so that it can
be printed and plotted.
</p>
</li>
<li>
<p>(if <code>at="points"</code>)
a matrix of probabilities, with rows corresponding to
data points <code class="reqn">x_i</code>, and columns corresponding
to types <code class="reqn">j</code>.
</p>
</li></ul>

<p>The pixel values or matrix entries
are the probabilities of each type of point if <code>relative=FALSE</code>,
or the relative risk of each type (probability of each type divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>relative=FALSE</code>, the resulting values always lie between 0
and 1. If <code>relative=TRUE</code>, the results are either non-negative
numbers, or the values <code>Inf</code> or <code>NA</code>. 
</p>


<h3>Standard error</h3>

<p>If <code>se=TRUE</code>, the standard error of the estimate will also be
calculated. The calculation assumes a Poisson point process. 
</p>
<p>If <code>weights</code> are given, then the calculation of standard error
depends on the interpretation of the weights. This is controlled by
the argument <code>wtype</code>.
</p>

<ul>
<li>
<p>If <code>wtype="value"</code> (the default),
the weights are interpreted as numerical values observed
at the data locations. Roughly speaking,
standard errors are proportional to the absolute
values of the weights.
</p>
</li>
<li>
<p>If <code>wtype="multiplicity"</code> the weights are interpreted as
multiplicities so that a weight of 2 is equivalent to having a pair
of duplicated points at the data location. Roughly speaking,
standard errors are proportional
to the square roots of the weights. Negative weights are not
permitted.
</p>
</li></ul>

<p>The default rule is now <code>wtype="value"</code> but previous versions
of <code>relrisk.ppp</code> (in <span class="pkg">spatstat.explore</span> versions
<code>3.1-0</code> and earlier) effectively used <code>wtype="multiplicity"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Bithell, J.F. (1990)
An application of density estimation to geographical epidemiology.
<em>Statistics in Medicine</em> <b>9</b>, 691&ndash;701.
</p>
<p>Bithell, J.F. (1991)
Estimation of relative risk functions.
<em>Statistics in Medicine</em> <b>10</b>, 1745&ndash;1751.
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>


<h3>See Also</h3>

<p>There is another method <code><a href="spatstat.model.html#topic+relrisk.ppm">relrisk.ppm</a></code> for point process
models which computes <em>parametric</em>
estimates of relative risk, using the fitted model.
</p>
<p>See also 
<code><a href="#topic+bw.relrisk">bw.relrisk</a></code>,
<code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>,
<code>eval.im</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   p.oak &lt;- relrisk(urkiola, 20)
   if(interactive()) {
      plot(p.oak, main="proportion of oak")
      plot(eval.im(p.oak &gt; 0.3), main="More than 30 percent oak")
      plot(split(lansing), main="Lansing Woods")
      p.lan &lt;- relrisk(lansing, 0.05, se=TRUE)
      plot(p.lan$estimate, main="Lansing Woods species probability")
      plot(p.lan$SE, main="Lansing Woods standard error")
      wh &lt;- im.apply(p.lan$estimate, which.max)
      types &lt;- levels(marks(lansing))
      wh &lt;- eval.im(types[wh])
      plot(wh, main="Most common species")
   }
</code></pre>

<hr>
<h2 id='rho2hat'>
Smoothed Relative Density of Pairs of Covariate Values
</h2><span id='topic+rho2hat'></span>

<h3>Description</h3>

<p>Given a point pattern and two spatial covariates <code class="reqn">Z_1</code> and
<code class="reqn">Z_2</code>, construct a smooth estimate of the relative risk of
the pair <code class="reqn">(Z_1,Z_2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho2hat(object, cov1, cov2, ..., method=c("ratio", "reweight"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho2hat_+3A_object">object</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>),
a quadrature scheme (object of class <code>"quad"</code>)
or a fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="rho2hat_+3A_cov1">cov1</code>, <code id="rho2hat_+3A_cov2">cov2</code></td>
<td>

<p>The two covariates.
Each argument is either a <code>function(x,y)</code> or a pixel image (object of
class <code>"im"</code>) providing the values of the covariate at any
location, or one of the strings <code>"x"</code> or <code>"y"</code>
signifying the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="rho2hat_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to smooth
the scatterplots.
</p>
</td></tr>
<tr><td><code id="rho2hat_+3A_method">method</code></td>
<td>

<p>Character string determining the smoothing method. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a bivariate version of <code><a href="#topic+rhohat">rhohat</a></code>.
</p>
<p>If <code>object</code> is a point pattern, this command
produces a smoothed version of the scatterplot of
the values of the covariates <code>cov1</code> and <code>cov2</code>
observed at the points of the point pattern. 
</p>
<p>The covariates <code>cov1,cov2</code> must have continuous values.
</p>
<p>If <code>object</code> is a fitted point process model, suppose <code>X</code> is
the original data point pattern to which the model was fitted. Then
this command assumes <code>X</code> is a realisation of a Poisson point
process with intensity function of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u) = \rho(Z_1(u), Z_2(u)) \kappa(u)
  </code>
</p>

<p>where <code class="reqn">\kappa(u)</code> is the intensity of the fitted model
<code>object</code>, and <code class="reqn">\rho(z_1,z_2)</code> is a function
to be estimated. The algorithm computes a smooth estimate of the
function <code class="reqn">\rho</code>.
</p>
<p>The <code>method</code> determines how the density estimates will be
combined to obtain an estimate of <code class="reqn">\rho(z_1, z_2)</code>:
</p>

<ul>
<li>
<p>If <code>method="ratio"</code>, then <code class="reqn">\rho(z_1, z_2)</code> is
estimated by the ratio of two density estimates.
The numerator is a (rescaled) density estimate obtained by
smoothing the points <code class="reqn">(Z_1(y_i), Z_2(y_i))</code> 
obtained by evaluating the two covariate <code class="reqn">Z_1, Z_2</code>
at the data points <code class="reqn">y_i</code>. The denominator
is a density estimate of the reference distribution of
<code class="reqn">(Z_1,Z_2)</code>.
</p>
</li>
<li>
<p>If <code>method="reweight"</code>, then <code class="reqn">\rho(z_1, z_2)</code> is
estimated by applying density estimation to the 
points <code class="reqn">(Z_1(y_i), Z_2(y_i))</code>
obtained by evaluating the two covariate <code class="reqn">Z_1, Z_2</code>
at the data points <code class="reqn">y_i</code>,
with weights inversely proportional to the reference density of
<code class="reqn">(Z_1,Z_2)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>). Also
belongs to the special class <code>"rho2hat"</code> which has a plot method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2012)
Nonparametric estimation of the dependence of a point
process on spatial covariates.
<em>Statistics and Its Interface</em> <b>5</b> (2), 221&ndash;236.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhohat">rhohat</a></code>,
<code><a href="#topic+methods.rho2hat">methods.rho2hat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  attach(bei.extra)
  plot(rho2hat(bei, elev, grad))
  if(require("spatstat.model")) {
    fit &lt;- ppm(bei ~elev, covariates=bei.extra)
    
      plot(rho2hat(fit, elev, grad))
    
    plot(rho2hat(fit, elev, grad, method="reweight"))
  }
</code></pre>

<hr>
<h2 id='rhohat'>
Nonparametric Estimate of Intensity as Function of a Covariate
</h2><span id='topic+rhohat'></span><span id='topic+rhohat.ppp'></span><span id='topic+rhohat.quad'></span>

<h3>Description</h3>

<p>Computes a nonparametric estimate of the intensity of a point process,
as a function of a (continuous) spatial covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhohat(object, covariate, ...)

## S3 method for class 'ppp'
rhohat(object, covariate, ...,
       baseline=NULL, weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
       "mountain", "valley", "piecewise"),
       subset=NULL,
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,
       dimyx=NULL, eps=NULL,
       rule.eps = c("adjust.eps", "grow.frame", "shrink.frame"),
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)

## S3 method for class 'quad'
rhohat(object, covariate, ...,
       baseline=NULL, weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
                  "mountain", "valley", "piecewise"),
       subset=NULL, 
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,
       dimyx=NULL, eps=NULL,
       rule.eps = c("adjust.eps", "grow.frame", "shrink.frame"),
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhohat_+3A_object">object</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>),
a quadrature scheme (object of class <code>"quad"</code>)
or a fitted point process model (object of class <code>"ppm"</code>,
<code>"slrm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_covariate">covariate</code></td>
<td>

<p>Either a <code>function(x,y)</code> or a pixel image (object of
class <code>"im"</code>) providing the values of the covariate at any
location.
Alternatively one of the strings <code>"x"</code> or <code>"y"</code>
signifying the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_weights">weights</code></td>
<td>

<p>Optional weights attached to the data points.
Either a numeric vector of weights for each data point,
or a pixel image (object of class <code>"im"</code>) or
a <code>function(x,y)</code> providing the weights.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_baseline">baseline</code></td>
<td>

<p>Optional baseline for intensity function.
A <code>function(x,y)</code> or a pixel image (object of
class <code>"im"</code>) providing the values of the baseline at any
location. 
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_method">method</code></td>
<td>

<p>Character string determining the estimation method. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_horvitz">horvitz</code></td>
<td>

<p>Logical value indicating whether to use Horvitz-Thompson weights.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_smoother">smoother</code></td>
<td>

<p>Character string determining the smoothing algorithm
and the type of curve that will be estimated. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_subset">subset</code></td>
<td>

<p>Optional. A spatial window (object of class <code>"owin"</code>)
specifying a subset of the data, from which the estimate should
be calculated.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_do.ci">do.CI</code></td>
<td>

<p>Logical value specifying whether to calculate standard errors
and confidence bands.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_jitter">jitter</code></td>
<td>

<p>Logical value. If <code>jitter=TRUE</code> (the default),
the values of the covariate at the
data points will be jittered (randomly perturbed by adding a small
amount of noise) using the function <code><a href="base.html#topic+jitter">jitter</a></code>.
If <code>jitter=FALSE</code>, the covariate values at the data points will
not be altered. See the section on <em>Randomisation and discretisation</em>.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_jitterfactor">jitterfactor</code></td>
<td>

<p>Numeric value controlling the scale of noise added to the
covariate values at the data points when <code>jitter=TRUE</code>.
Passed to the function <code><a href="base.html#topic+jitter">jitter</a></code>
as the argument <code>factor</code>.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value specifying whether to use spatial interpolation
to obtain the values of the covariate at the data points,
when the covariate is a pixel image
(object of class <code>"im"</code>).
If <code>interpolate=FALSE</code>, the covariate value for each data point
is simply the value of the covariate image at the pixel centre that
is nearest to the data point. If <code>interpolate=TRUE</code>, the
covariate value for each data point is obtained by interpolating the
nearest pixel values using <code><a href="spatstat.geom.html#topic+interp.im">interp.im</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_dimyx">dimyx</code>, <code id="rhohat_+3A_eps">eps</code>, <code id="rhohat_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Arguments controlling the pixel
resolution at which the covariate will be evaluated.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth or bandwidth rule
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_adjust">adjust</code></td>
<td>

<p>Smoothing bandwidth adjustment factor
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_n">n</code>, <code id="rhohat_+3A_from">from</code>, <code id="rhohat_+3A_to">to</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code> to
control the number and range of values at which the function
will be estimated.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_bwref">bwref</code></td>
<td>

<p>Optional. An alternative value of <code>bw</code> to use when smoothing
the reference density (the density of the covariate values
observed at all locations in the window).
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
or <code><a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_covname">covname</code></td>
<td>

<p>Optional. Character string to use as the name of the covariate.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level for confidence intervals.
A number between 0 and 1.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_positiveci">positiveCI</code></td>
<td>

<p>Logical value.
If <code>TRUE</code>, confidence limits are always positive numbers;
if <code>FALSE</code>, the lower limit of the
confidence interval may sometimes be negative.
Default is <code>FALSE</code> if <code>smoother="kernel"</code>
and <code>TRUE</code> if <code>smoother="local"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints for the piecewise-constant function
computed when <code>smoother='piecewise'</code>.
Either a vector of numeric values specifying the breakpoints,
or a single integer specifying the number of equally-spaced
breakpoints. There is a sensible default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command estimates the relationship between
point process intensity and a given spatial covariate.
Such a relationship is sometimes called a
<em>resource selection function</em> (if the points are organisms
and the covariate is a descriptor of habitat) or
a <em>prospectivity index</em> (if the points are mineral deposits
and the covariate is a geological variable). 
This command uses nonparametric methods which do not assume a
particular form for the relationship.  
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is missing or
null, this command assumes that <code>object</code> is a realisation of a
point process with intensity function
<code class="reqn">\lambda(u)</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u))</code>
</p>

<p>where <code class="reqn">Z</code> is the spatial
covariate function given by <code>covariate</code>, and
<code class="reqn">\rho(z)</code> is the resource selection function
or prospectivity index.
A nonparametric estimator of the function <code class="reqn">\rho(z)</code> is computed.
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is given,
then the intensity function is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u)) B(u)</code>
</p>

<p>where <code class="reqn">B(u)</code> is the baseline intensity at location <code class="reqn">u</code>.
A nonparametric estimator of the relative intensity  <code class="reqn">\rho(z)</code>
is computed.
</p>
<p>If <code>object</code> is a fitted point process model, suppose <code>X</code> is
the original data point pattern to which the model was fitted. Then
this command assumes <code>X</code> is a realisation of a Poisson point
process with intensity function of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u) = \rho(Z(u)) \kappa(u)
  </code>
</p>

<p>where <code class="reqn">\kappa(u)</code> is the intensity of the fitted model
<code>object</code>. A nonparametric estimator of
the relative intensity <code class="reqn">\rho(z)</code> is computed.
</p>
<p>The nonparametric estimation procedure is controlled by the
arguments <code>smoother</code>, <code>method</code> and <code>horvitz</code>.
</p>
<p>The argument <code>smoother</code> selects the type of estimation technique.
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code> (the default),
the nonparametric estimator is a <em>kernel smoothing estimator</em>
of <code class="reqn">\rho(z)</code> (Guan, 2008; Baddeley et al, 2012).
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code> which takes nonnegative values.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, 
the nonparametric estimator is a <em>local regression estimator</em>
of <code class="reqn">\rho(z)</code> (Baddeley et al, 2012) obtained using
local likelihood.
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code>.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="increasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is increasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="decreasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is decreasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="mountain"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with an inverted U shape,
with a single peak at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and a decreasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
increasing and then decreasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="valley"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with a U shape,
with a single minimum at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and an increasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
decreasing and then increasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="piecewise"</code>, the estimate of
<code class="reqn">\rho(z)</code> is piecewise constant.
The range of covariate values is divided into several intervals
(ranges or bands). The endpoints of these intervals are the
breakpoints, which may be specified by the argument <code>breaks</code>;
there is a sensible default. The estimate of 
<code class="reqn">\rho(z)</code> takes a constant value on each interval.
The estimate of <code class="reqn">\rho(z)</code> in each interval of covariate
values is simply the average intensity
(number of points per unit area) in the relevant sub-region.
If <code>do.CI=TRUE</code> (the default),
confidence bands are computed assuming a Poisson process.
</p>
</li></ul>

<p>See Baddeley (2018) for a comparison of these estimation techniques
(except for <code>"mountain"</code> and <code>"valley"</code>).
</p>
<p>If the argument <code>weights</code> is present, then the contribution
from each data point <code>X[i]</code> to the estimate of <code class="reqn">\rho</code> is
multiplied by <code>weights[i]</code>.
</p>
<p>If the argument <code>subset</code> is present, then the calculations are
performed using only the data inside this spatial region.
</p>
<p>This technique assumes that <code>covariate</code> has continuous values.
It is not applicable to covariates with categorical (factor) values
or discrete values such as small integers.
For a categorical covariate, use
<code>intensity.quadratcount</code> applied to the result of
<code>quadratcount(X, tess=covariate)</code>.
</p>
<p>The argument <code>covariate</code> should be a pixel image, or a function,
or one of the strings <code>"x"</code> or <code>"y"</code> signifying the
cartesian coordinates. It will be evaluated on a fine grid of locations,
with spatial resolution controlled by the arguments
<code>dimyx,eps,rule.eps</code> which are passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the estimated values of <code class="reqn">\rho</code>
(and confidence limits) for a sequence of values of <code class="reqn">Z</code>.
Also belongs to the class <code>"rhohat"</code>
which has special methods for <code>print</code>, <code>plot</code>
and <code>predict</code>.
</p>


<h3>Smooth estimates</h3>

<p>Smooth estimators of <code class="reqn">\rho(z)</code>
were proposed by Baddeley and Turner (2005) and Baddeley et al (2012).
Similar estimators were proposed by Guan (2008) and in the literature
on relative distributions (Handcock and Morris, 1999).
</p>
<p>The estimated function <code class="reqn">\rho(z)</code> will be a smooth function
of <code class="reqn">z</code>.
</p>
<p>The smooth estimation procedure involves computing several density estimates
and combining them. The algorithm used to compute density estimates is 
determined by <code>smoother</code>:
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code>,
the smoothing procedure is based on
fixed-bandwidth kernel density estimation,
performed by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, the smoothing procedure
is based on local likelihood density estimation, performed by
<code><a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</li></ul>

<p>The argument <code>method</code> determines how the density estimates will be
combined to obtain an estimate of <code class="reqn">\rho(z)</code>:
</p>

<ul>
<li>
<p>If <code>method="ratio"</code>, then <code class="reqn">\rho(z)</code> is
estimated by the ratio of two density estimates,
The numerator is a (rescaled) density estimate obtained by
smoothing the values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>. The denominator
is a density estimate of the reference distribution of <code class="reqn">Z</code>.
See Baddeley et al (2012), equation (8). This is similar but not
identical to an estimator proposed by Guan (2008).
</p>
</li>
<li>
<p>If <code>method="reweight"</code>, then <code class="reqn">\rho(z)</code> is
estimated by applying density estimation to the 
values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>,
with weights inversely proportional to the reference density of
<code class="reqn">Z</code>.
See Baddeley et al (2012), equation (9).
</p>
</li>
<li> 
<p>If <code>method="transform"</code>,
the smoothing method is variable-bandwidth kernel
smoothing, implemented by applying the Probability Integral Transform
to the covariate values, yielding values in the range 0 to 1,
then applying edge-corrected density estimation on the interval
<code class="reqn">[0,1]</code>, and back-transforming.
See Baddeley et al (2012), equation (10).
</p>
</li></ul>

<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>Pointwise confidence intervals for the true value of <code class="reqn">\rho(z)</code>
are also calculated for each <code class="reqn">z</code>,
and will be plotted as grey shading.
The confidence intervals are derived using the central limit theorem,
based on variance calculations which assume a Poisson point process. 
If <code>positiveCI=FALSE</code>, the lower limit of the confidence
interval may sometimes be negative, because the confidence intervals
are based on a normal approximation to the estimate of <code class="reqn">\rho(z)</code>.
If <code>positiveCI=TRUE</code>, the confidence limits are always
positive, because the confidence interval is based on a normal
approximation to the estimate of <code class="reqn">\log(\rho(z))</code>.
For consistency with earlier versions, the default is
<code>positiveCI=FALSE</code> for <code>smoother="kernel"</code>
and <code>positiveCI=TRUE</code> for <code>smoother="local"</code>.
</p>


<h3>Monotone estimates</h3>

<p>The nonparametric maximum likelihood estimator
of a monotone function <code class="reqn">\rho(z)</code> was described by Sager (1982).
This method assumes that
<code class="reqn">\rho(z)</code> is either an increasing
function of <code class="reqn">z</code>, or a decreasing function of <code class="reqn">z</code>.
The estimated function will be a step function,
increasing or decreasing as a function of <code class="reqn">z</code>.
</p>
<p>This estimator is chosen by specifying
<code>smoother="increasing"</code> or <code>smoother="decreasing"</code>.
The argument <code>method</code> is ignored this case.
</p>
<p>To compute the estimate of <code class="reqn">\rho(z)</code>, the algorithm first
computes several primitive step-function estimates, and then takes
the maximum of these primitive functions.
</p>
<p>If <code>smoother="decreasing"</code>, each primitive step function
takes the form <code class="reqn">\rho(z) = \lambda</code> when <code class="reqn">z \le t</code>,
and <code class="reqn">\rho(z) = 0</code> when <code class="reqn">z &gt; t</code>, where
and <code class="reqn">\lambda</code> is a primitive estimate of intensity
based on the data for <code class="reqn">Z \le t</code>. The jump location <code class="reqn">t</code>
will be the value of the covariate <code class="reqn">Z</code> at one of the
data points. The primitive estimate <code class="reqn">\lambda</code>
is the average intensity (number of points divided by area)
for the region of space where the covariate value is less than
or equal to <code class="reqn">t</code>.
</p>
<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>Confidence intervals are not available
for the monotone estimators.
</p>


<h3>Unimodal estimators</h3>

<p>If <code>smoother="valley"</code> then we estimate a U-shaped function.
A function <code class="reqn">\rho(z)</code> is U-shaped if it is
decreasing when <code class="reqn">z &lt; z_0</code> and
increasing when <code class="reqn">z &gt; z_0</code>, where <code class="reqn">z_0</code> is
called the critical value. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over <code class="reqn">z_0</code>. 
The algorithm considers all possible candidate values of the critical value 
<code class="reqn">z_0</code>, and estimates the function <code class="reqn">\rho(z)</code>
separately on the left and right of <code class="reqn">z_0</code> using the monotone
estimators described above. These function estimates are combined into
a single function, and the Poisson point process likelihood is
computed. The optimal value of <code class="reqn">z_0</code>
is the one which maximises the Poisson point process likelihood.
</p>
<p>If <code>smoother="mountain"</code>  then we estimate a function which has
an inverted U shape. A function <code class="reqn">\rho(z)</code> is
inverted-U-shaped if it is
increasing when <code class="reqn">z &lt; z_0</code> and
decreasing when <code class="reqn">z &gt; z_0</code>. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over
<code class="reqn">z_0</code> using the same technique <em>mutatis mutandis</em>.
</p>
<p>Confidence intervals are not available for the unimodal estimators.
</p>


<h3>Randomisation</h3>

<p>By default, <code>rhohat</code> adds a small amount of random noise to the
data. This is designed to suppress the effects of
discretisation in pixel images.
</p>
<p>This strategy means that <code>rhohat</code>
does not produce exactly the same result when the computation is
repeated. If you need the results to be exactly reproducible, set
<code>jitter=FALSE</code>.
</p>
<p>By default, the values of the covariate at the data points
will be randomly perturbed by adding a small amount
of noise using the function <code><a href="base.html#topic+jitter">jitter</a></code>. To reduce this
effect, set <code>jitterfactor</code> to a number smaller than 1. To
suppress this effect entirely, set <code>jitter=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Smoothing algorithm by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, 
Ya-Mei Chang, Yong Song, 
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>
<p>Nonparametric maximum likelihood algorithm by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2012)
Nonparametric estimation of the dependence of a point
process on spatial covariates.
<em>Statistics and Its Interface</em> <b>5</b> (2), 221&ndash;236.
</p>
<p>Baddeley, A. and Turner, R. (2005)
Modelling spatial point patterns in R.
In: A. Baddeley, P. Gregori, J. Mateu, R. Stoica, and D. Stoyan,
editors, <em>Case Studies in Spatial Point Pattern Modelling</em>,
Lecture Notes in Statistics number 185. Pages 23&ndash;74.
Springer-Verlag, New York, 2006. 
ISBN: 0-387-28311-0.  
</p>
<p>Baddeley, A. (2018)
A statistical commentary on mineral prospectivity analysis.
Chapter 2, pages 25&ndash;65
in <em>Handbook of Mathematical Geosciences: Fifty Years of IAMG</em>,
edited by B.S. Daya Sagar, Q. Cheng and F.P. Agterberg.
Springer, Berlin.
</p>
<p>Guan, Y. (2008) On consistent nonparametric intensity estimation
for inhomogeneous spatial point processes.
<em>Journal of the American Statistical Association</em>
<b>103</b>, 1238&ndash;1247.
</p>
<p>Handcock, M.S. and Morris, M. (1999)
<em>Relative Distribution Methods in the Social Sciences</em>.
Springer, New York.
</p>
<p>Sager, T.W. (1982) 
Nonparametric maximum likelihood estimation of
spatial patterns. <em>Annals of Statistics</em> <b>10</b>, 1125&ndash;1136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rho2hat">rho2hat</a></code>,
<code><a href="#topic+methods.rhohat">methods.rhohat</a></code>,
<code><a href="spatstat.model.html#topic+parres">parres</a></code>.
</p>
<p>See <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> for a parametric method for the same problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;-  rpoispp(function(x,y){exp(3+3*x)})
  rho &lt;- rhohat(X, "x")
  rho &lt;- rhohat(X, function(x,y){x})
  plot(rho)
  curve(exp(3+3*x), lty=3, col=4, lwd=2, add=TRUE)

  rhoB &lt;- rhohat(X, "x", method="reweight")
  rhoC &lt;- rhohat(X, "x", method="transform")

  rhoI &lt;- rhohat(X, "x", smoother="increasing")
  rhoM &lt;- rhohat(X, "x", smoother="mountain")

  plot(rhoI, add=TRUE, .y ~ .x, col=6)
  legend("top", lty=c(3, 1), col=c(4, 6), lwd=c(2, 1),
         legend=c("true", "increasing"))

  


</code></pre>

<hr>
<h2 id='roc'>
Receiver Operating Characteristic
</h2><span id='topic+roc'></span><span id='topic+roc.ppp'></span>

<h3>Description</h3>

<p>Computes the Receiver Operating Characteristic curve
for a point pattern or a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> roc(X, ...)

## S3 method for class 'ppp'
roc(X, covariate, ..., high = TRUE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>)
or fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="roc_+3A_covariate">covariate</code></td>
<td>

<p>Spatial covariate. Either a <code>function(x,y)</code>,
a pixel image (object of class <code>"im"</code>), or
one of the strings <code>"x"</code> or <code>"y"</code> indicating the
Cartesian coordinates.    
</p>
</td></tr>
<tr><td><code id="roc_+3A_high">high</code></td>
<td>

<p>Logical value indicating whether the threshold operation
should favour high or low values of the covariate.
</p>
</td></tr>
<tr><td><code id="roc_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes Receiver Operating
Characteristic curve. The area under the ROC is computed by <code><a href="#topic+auc">auc</a></code>.
</p>
<p>For a point pattern <code>X</code> and a covariate <code>Z</code>, the
ROC is a plot showing the ability of the 
covariate to separate the spatial domain
into areas of high and low density of points.
For each possible threshold <code class="reqn">z</code>, the algorithm calculates
the fraction <code class="reqn">a(z)</code> of area in the study region where the
covariate takes a value greater than <code class="reqn">z</code>, and the
fraction <code class="reqn">b(z)</code> of data points for which the covariate value
is greater than <code class="reqn">z</code>. The ROC is a plot of <code class="reqn">b(z)</code> against
<code class="reqn">a(z)</code> for all thresholds <code class="reqn">z</code>. 
</p>
<p>For a fitted point process model, 
the ROC shows the ability of the
fitted model intensity to separate the spatial domain
into areas of high and low density of points.
The ROC is <b>not</b> a diagnostic for the goodness-of-fit of the model
(Lobo et al, 2007).
</p>
<p>(For spatial logistic regression models (class <code>"slrm"</code>)
replace &ldquo;intensity&rdquo; by &ldquo;probability of presence&rdquo;
in the text above.)
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>)
which can be plotted to show the ROC curve.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(roc(swedishpines, "x"))
</code></pre>

<hr>
<h2 id='rose'>Rose Diagram</h2><span id='topic+rose'></span><span id='topic+rose.default'></span><span id='topic+rose.histogram'></span><span id='topic+rose.density'></span><span id='topic+rose.fv'></span>

<h3>Description</h3>

<p>Plots a rose diagram (rose of directions),
the analogue of a histogram or density plot for angular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose(x, ...)

## Default S3 method:
rose(x, breaks = NULL, ...,
                       weights=NULL,
                       nclass = NULL,
                       unit = c("degree", "radian"),
                       start=0, clockwise=FALSE,
                       main)

## S3 method for class 'histogram'
rose(x, ...,
                       unit = c("degree", "radian"),
                       start=0, clockwise=FALSE,
                       main, labels=TRUE, at=NULL, do.plot = TRUE)

## S3 method for class 'density'
rose(x, ..., 
                  unit = c("degree", "radian"), 
                  start=0, clockwise=FALSE,
                  main, labels=TRUE, at=NULL, do.plot = TRUE)

## S3 method for class 'fv'
rose(x, ..., 
                  unit = c("degree", "radian"),
                  start=0, clockwise=FALSE,
                  main, labels=TRUE, at=NULL, do.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_+3A_x">x</code></td>
<td>

<p>Data to be plotted.
A numeric vector containing angles,
or a <code>histogram</code> object containing a histogram of
angular values, or a <code>density</code> object containing a
smooth density estimate for angular data,
or an <code>fv</code> object giving a function
of an angular argument.
</p>
</td></tr>
<tr><td><code id="rose_+3A_breaks">breaks</code>, <code id="rose_+3A_nclass">nclass</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code> to determine
the histogram breakpoints.
</p>
</td></tr>
<tr><td><code id="rose_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>
controlling the appearance of the plot
(or passed from <code>rose.default</code> to <code><a href="graphics.html#topic+hist">hist</a></code>
to control the calculation of the histogram).
</p>
</td></tr>
<tr><td><code id="rose_+3A_unit">unit</code></td>
<td>

<p>The unit in which the angles are expressed.
</p>
</td></tr>
<tr><td><code id="rose_+3A_start">start</code></td>
<td>

<p>The starting direction for measurement of angles,
that is, the spatial direction which corresponds to a measured angle
of zero. Either a character string giving a compass direction
(<code>"N"</code> for north, <code>"S"</code> for south, <code>"E"</code> for east,
or <code>"W"</code> for west) or a number giving the angle from the
the horizontal (East) axis to the starting direction. For example,
if <code>unit="degree"</code> and <code>clockwise=FALSE</code>,
then <code>start=90</code> and <code>start="N"</code> are equivalent.
The default is to measure angles anti-clockwise from the
horizontal axis (East direction).
</p>
</td></tr>
<tr><td><code id="rose_+3A_clockwise">clockwise</code></td>
<td>

<p>Logical value indicating whether angles increase in the clockwise
direction (<code>clockwise=TRUE</code>) or anti-clockwise,
counter-clockwise direction (<code>clockwise=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="rose_+3A_weights">weights</code></td>
<td>

<p>Optional vector of numeric weights associated with <code>x</code>.
</p>
</td></tr>
<tr><td><code id="rose_+3A_main">main</code></td>
<td>

<p>Optional main title for the plot.
</p>
</td></tr>
<tr><td><code id="rose_+3A_labels">labels</code></td>
<td>

<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.
</p>
</td></tr>
<tr><td><code id="rose_+3A_at">at</code></td>
<td>

<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.
</p>
</td></tr>
<tr><td><code id="rose_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to really perform the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A rose diagram or rose of directions is the analogue of
a histogram or bar chart for data which represent angles
in two dimensions. The bars of the bar chart are replaced by
circular sectors in the rose diagram.
</p>
<p>The function <code>rose</code> is generic, with a default method
for numeric data, and methods for histograms and function tables.
</p>
<p>If <code>x</code> is a numeric vector, it must contain angular values
in the range 0 to 360 (if <code>unit="degree"</code>)
or in the range 0 to <code>2 * pi</code> (if <code>unit="radian"</code>).
A histogram of the data will first be computed using
<code><a href="graphics.html#topic+hist">hist</a></code>. Then the rose diagram of this histogram
will be plotted by <code>rose.histogram</code>.
</p>
<p>If <code>x</code> is an object of class <code>"histogram"</code> produced by
the function <code><a href="graphics.html#topic+hist">hist</a></code>, representing the histogram
of angular data, then the rose diagram of the densities
(rather than the counts) in this histogram object will be plotted. 
</p>
<p>If <code>x</code> is an object of class <code>"density"</code> produced by
<code><a href="#topic+circdensity">circdensity</a></code> or <code><a href="stats.html#topic+density.default">density.default</a></code>,
representing a kernel smoothed density estimate of angular data,
then the rose diagram of the density estimate will be plotted. 
</p>
<p>If <code>x</code> is a function value table (object of class <code>"fv"</code>)
then the argument of the function will be interpreted as an angle,
and the value of the function will be interpreted as the radius.
</p>
<p>By default, angles are interpreted using the mathematical convention
where the zero angle is the horizontal <code class="reqn">x</code> axis, and angles
increase anti-clockwise. Other conventions can be specified
using the arguments <code>start</code> and <code>clockwise</code>.
Standard compass directions are obtained by setting <code>unit="degree"</code>,
<code>start="N"</code> and <code>clockwise=TRUE</code>.  
</p>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) containing the plotted region.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fv">fv</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="#topic+circdensity">circdensity</a></code>,
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ang &lt;- runif(1000, max=360)
  rose(ang, col="grey")
  rose(ang, col="grey", start="N", clockwise=TRUE)
</code></pre>

<hr>
<h2 id='rotmean'>
Rotational Average of a Pixel Image
</h2><span id='topic+rotmean'></span>

<h3>Description</h3>

<p>Compute the average pixel value over all rotations of the image
about the origin, as a function of distance from the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmean(X, ..., origin, padzero=TRUE, Xname, result=c("fv", "im"), adjust=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotmean_+3A_x">X</code></td>
<td>

<p>A pixel image.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_origin">origin</code></td>
<td>

<p>Optional. Origin about which the rotations should be performed.
Either a numeric vector or a character string as described
in the help for <code>shift.owin</code>.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_padzero">padzero</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the value of <code>X</code>
is assumed to be zero outside the window of <code>X</code>.
If <code>FALSE</code>, the value of <code>X</code> is taken to be undefined
outside the window of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_xname">Xname</code></td>
<td>

<p>Optional name for <code>X</code> to be used in the
function labels.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_result">result</code></td>
<td>

<p>Character string specifying the kind of result required:
either a function object or a pixel image.
</p>
</td></tr>
<tr><td><code id="rotmean_+3A_adjust">adjust</code></td>
<td>

<p>Adjustment factor for bandwidth used in kernel smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes, for each possible distance <code class="reqn">r</code>,
the average pixel value of the pixels lying at
distance <code class="reqn">r</code> from the origin. Kernel smoothing is used
to obtain a smooth function of <code class="reqn">r</code>.
</p>
<p>If <code>result="fv"</code> (the default) the result is a function
object of class <code>"fv"</code> giving the mean pixel value of <code>X</code>
as a function of distance from the origin.
</p>
<p>If <code>result="im"</code> the result is a pixel image, with the same
dimensions as <code>X</code>, giving the mean value of <code>X</code>
over all pixels lying at the same distance from the origin
as the current pixel.
</p>
<p>If <code>padzero=TRUE</code> (the default), the value of <code>X</code>
is assumed to be zero outside the window of <code>X</code>. The rotational
mean at a given distance <code class="reqn">r</code> is the average value of the image
<code>X</code> over the <em>entire</em> circle of radius <code class="reqn">r</code>,
including zero values outside the window if the circle
lies partly outside the window.
</p>
<p>If <code>padzero=FALSE</code>, the value of <code>X</code> is taken to be
undefined outside the window of <code>X</code>. The rotational mean
is the average of the <code>X</code> values over the <em>subset</em> of the circle
of radius <code class="reqn">r</code> that lies entirely inside the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> or <code>"im"</code>,
with the same coordinate units as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radcumint">radcumint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  resolution &lt;- if(online) 128 else 32
  Z &lt;- setcov(square(1), dimyx=resolution)
  f &lt;- rotmean(Z)
  if(online) {
    plot(rotmean(Z))
    plot(rotmean(Z, result="im"))
  }
</code></pre>

<hr>
<h2 id='scan.test'>
Spatial Scan Test
</h2><span id='topic+scan.test'></span>

<h3>Description</h3>

<p>Performs the Spatial Scan Test for clustering
in a spatial point pattern, or for clustering of one type of point
in a bivariate spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.test(X, r, ...,
          method = c("poisson", "binomial"),
          nsim = 19,
          baseline = NULL,
          case = 2, 
          alternative = c("greater", "less", "two.sided"),
          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.test_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_r">r</code></td>
<td>

<p>Radius of circle to use. A single number or a numeric vector.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_...">...</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine the
spatial resolution of the computations.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_method">method</code></td>
<td>

<p>Either <code>"poisson"</code> or <code>"binomial"</code>
specifying the type of likelihood.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations for computing Monte Carlo p-value.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_baseline">baseline</code></td>
<td>

<p>Baseline for the Poisson intensity, if <code>method="poisson"</code>.
A pixel image or a function.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_case">case</code></td>
<td>

<p>Which type of point should be interpreted as a case,
if <code>method="binomial"</code>.
Integer or character string.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_alternative">alternative</code></td>
<td>

<p>Alternative hypothesis: <code>"greater"</code> if the alternative
postulates that the mean number of points inside the circle
will be greater than expected under the null.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial scan test (Kulldorf, 1997) is applied
to the point pattern <code>X</code>.
</p>
<p>In a nutshell,
</p>

<ul>
<li>
<p>If <code>method="poisson"</code> then 
a significant result would mean that there is a circle of radius
<code>r</code>, located somewhere in the spatial domain of the data,
which contains a significantly higher than
expected number of points of <code>X</code>. That is, the
pattern <code>X</code> exhibits spatial clustering.
</p>
</li>
<li> 
<p>If <code>method="binomial"</code> then <code>X</code> must be a bivariate (two-type)
point pattern. By default, the first type of point is interpreted as
a control (non-event) and the second type of point as a case (event).
A significant result would mean that there is a
circle of radius <code>r</code> which contains a significantly higher than
expected number of cases. That is, the cases are clustered together,
conditional on the locations of all points.
</p>
</li></ul>

<p>Following is a more detailed explanation.
</p>

<ul>
<li> 
<p>If <code>method="poisson"</code> then the scan test based on Poisson
likelihood is performed (Kulldorf, 1997).
The dataset <code>X</code> is treated as an unmarked point pattern.
By default (if <code>baseline</code> is not specified) 
the null hypothesis is complete spatial randomness CSR
(i.e. a uniform Poisson process).
The alternative hypothesis is a Poisson process with
one intensity <code class="reqn">\beta_1</code> inside some circle of radius
<code>r</code> and another intensity <code class="reqn">\beta_0</code> outside the
circle.
If <code>baseline</code> is given, then it should be a pixel image
or a <code>function(x,y)</code>. The null hypothesis is
an inhomogeneous Poisson process with intensity proportional
to <code>baseline</code>. The alternative hypothesis is an inhomogeneous
Poisson process with intensity
<code>beta1 * baseline</code> inside some circle of radius <code>r</code>,
and <code>beta0 * baseline</code> outside the circle.
</p>
</li>
<li>
<p>If <code>method="binomial"</code> then the scan test based on
binomial likelihood is performed (Kulldorf, 1997).
The dataset <code>X</code> must be a bivariate point pattern,
i.e. a multitype point pattern with two types.
The null hypothesis is that all permutations of the type labels are
equally likely.
The alternative hypothesis is that some circle of radius
<code>r</code> has a higher proportion of points of the second type,
than expected under the null hypothesis.
</p>
</li></ul>

<p>The result of <code>scan.test</code> is a hypothesis test
(object of class <code>"htest"</code>) which can be plotted to
report the results. The component <code>p.value</code> contains the
<code class="reqn">p</code>-value.
</p>
<p>The result of <code>scan.test</code> can also be plotted (using the plot
method for the class <code>"scan.test"</code>). The plot is
a pixel image of the Likelihood Ratio Test Statistic
(2 times the log likelihood ratio) as a function
of the location of the centre of the circle.
This pixel image can be extracted from the object
using <code><a href="#topic+as.im.scan.test">as.im.scan.test</a></code>.
The Likelihood Ratio Test Statistic is computed by
<code><a href="#topic+scanLRTS">scanLRTS</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> (hypothesis test)
which also belongs to the class <code>"scan.test"</code>.
Printing this object gives the result of the test.
Plotting this object displays the Likelihood Ratio Test Statistic
as a function of the location of the centre of the circle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997)
A spatial scan statistic.
<em>Communications in Statistics &mdash; Theory and Methods</em>
<b>26</b>, 1481&ndash;1496.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.scan.test">plot.scan.test</a></code>,
<code><a href="#topic+as.im.scan.test">as.im.scan.test</a></code>,
<code><a href="#topic+relrisk">relrisk</a></code>,
<code><a href="#topic+scanLRTS">scanLRTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nsim &lt;- if(interactive()) 19 else 2
   rr &lt;- if(interactive()) seq(0.5, 1, by=0.1) else c(0.5, 1)
   scan.test(redwood, 0.1 * rr, method="poisson", nsim=nsim)
   scan.test(chorley, rr, method="binomial", case="larynx", nsim=nsim)
</code></pre>

<hr>
<h2 id='scanLRTS'>
Likelihood Ratio Test Statistic for Scan Test
</h2><span id='topic+scanLRTS'></span>

<h3>Description</h3>

<p>Calculate the Likelihood Ratio Test Statistic for the Scan Test,
at each spatial location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanLRTS(X, r, ...,
   method = c("poisson", "binomial"),
   baseline = NULL, case = 2,
   alternative = c("greater", "less", "two.sided"),
   saveopt = FALSE,
   Xmask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scanLRTS_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_r">r</code></td>
<td>

<p>Radius of circle to use. A single number or a numeric vector.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_...">...</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine the
spatial resolution of the computations.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_method">method</code></td>
<td>

<p>Either <code>"poisson"</code> or <code>"binomial"</code>
specifying the type of likelihood.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_baseline">baseline</code></td>
<td>

<p>Baseline for the Poisson intensity, if <code>method="poisson"</code>.
A pixel image or a function.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_case">case</code></td>
<td>

<p>Which type of point should be interpreted as a case,
if <code>method="binomial"</code>.
Integer or character string.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_alternative">alternative</code></td>
<td>

<p>Alternative hypothesis: <code>"greater"</code> if the alternative
postulates that the mean number of points inside the circle
will be greater than expected under the null.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_saveopt">saveopt</code></td>
<td>

<p>Logical value indicating to save the optimal value of <code>r</code>
at each location.
</p>
</td></tr>
<tr><td><code id="scanLRTS_+3A_xmask">Xmask</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes, for all spatial locations <code>u</code>,
the Likelihood Ratio Test Statistic <code class="reqn">\Lambda(u)</code>
for a test of homogeneity at the location <code class="reqn">u</code>, as described
below. The result is a pixel image giving the values of
<code class="reqn">\Lambda(u)</code> at each pixel. 
</p>
<p>The <b>maximum</b> value of <code class="reqn">\Lambda(u)</code> over all locations
<code class="reqn">u</code> is the <em>scan statistic</em>, which is the basis of
the   <em>scan test</em> performed by <code><a href="#topic+scan.test">scan.test</a></code>.
</p>

<ul>
<li> 
<p>If <code>method="poisson"</code> then the test statistic is based on Poisson
likelihood.
The dataset <code>X</code> is treated as an unmarked point pattern.
By default (if <code>baseline</code> is not specified) 
the null hypothesis is complete spatial randomness CSR
(i.e. a uniform Poisson process).
At the spatial location <code class="reqn">u</code>,
the alternative hypothesis is a Poisson process with
one intensity <code class="reqn">\beta_1</code> inside the circle of radius
<code>r</code> centred at <code class="reqn">u</code>,
and another intensity <code class="reqn">\beta_0</code> outside the
circle.
If <code>baseline</code> is given, then it should be a pixel image
or a <code>function(x,y)</code>. The null hypothesis is
an inhomogeneous Poisson process with intensity proportional
to <code>baseline</code>. The alternative hypothesis is an inhomogeneous
Poisson process with intensity
<code>beta1 * baseline</code> inside the circle,
and <code>beta0 * baseline</code> outside the circle.
</p>
</li>
<li>
<p>If <code>method="binomial"</code> then the test statistic is based on
binomial likelihood.
The dataset <code>X</code> must be a bivariate point pattern,
i.e. a multitype point pattern with two types.
The null hypothesis is that all permutations of the type labels are
equally likely.
The alternative hypothesis is that the circle of radius
<code>r</code> centred at <code class="reqn">u</code>
has a higher proportion of points of the second type,
than expected under the null hypothesis.
</p>
</li></ul>

<p>If <code>r</code> is a vector of more than one value for the radius,
then the calculations described above are performed for
every value of <code>r</code>. Then the maximum over <code>r</code> is taken
for each spatial location <code class="reqn">u</code>.
The resulting pixel value of <code>scanLRTS</code> at a location
<code class="reqn">u</code> is the profile maximum of the Likelihood Ratio Test Statistic,
that is, the maximum of the
Likelihood Ratio Test Statistic for circles of all radii,
centred at the same location <code class="reqn">u</code>.
</p>
<p>If you have already performed a scan test using
<code><a href="#topic+scan.test">scan.test</a></code>, the  Likelihood Ratio Test Statistic
can be extracted from the test result using the 
function <code><a href="#topic+as.im.scan.test">as.im.scan.test</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose pixel values
are the values of the (profile) Likelihood Ratio Test Statistic at each
spatial location. 
</p>


<h3>Warning: window size</h3>

<p>Note that the result of <code>scanLRTS</code> is a pixel image
on a larger window than the original window of <code>X</code>.
The expanded window contains the centre of any circle
of radius <code>r</code>
that has nonempty intersection with the original window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997)
A spatial scan statistic.
<em>Communications in Statistics &mdash; Theory and Methods</em>
<b>26</b>, 1481&ndash;1496.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan.test">scan.test</a></code>,
<code><a href="#topic+as.im.scan.test">as.im.scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(scanLRTS(redwood, 0.1, method="poisson"))
   sc &lt;- scanLRTS(chorley, 1, method="binomial", case="larynx") 
   plot(sc)
   scanstatchorley &lt;- max(sc)
</code></pre>

<hr>
<h2 id='sdr'>
Sufficient Dimension Reduction
</h2><span id='topic+sdr'></span><span id='topic+sdr.ppp'></span>

<h3>Description</h3>

<p>Given a point pattern and a set of predictors,
find a minimal set of new predictors, each constructed as
a linear combination of the original predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdr(X, covariates, ...)

## S3 method for class 'ppp'
sdr(X, covariates,
                  method = c("DR", "NNIR", "SAVE", "SIR", "TSE"),
                  Dim1 = 1, Dim2 = 1, predict=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdr_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="sdr_+3A_covariates">covariates</code></td>
<td>

<p>A list of pixel images (objects of class <code>"im"</code>)
to serve as predictor variables.
</p>
</td></tr>
<tr><td><code id="sdr_+3A_method">method</code></td>
<td>

<p>Character string indicating which method to use. See Details.
</p>
</td></tr>
<tr><td><code id="sdr_+3A_dim1">Dim1</code></td>
<td>

<p>Dimension of the first order Central Intensity Subspace
(applicable when <code>method</code> is <code>"DR"</code>, <code>"NNIR"</code>,
<code>"SAVE"</code> or <code>"TSE"</code>). 
</p>
</td></tr>
<tr><td><code id="sdr_+3A_dim2">Dim2</code></td>
<td>

<p>Dimension of the second order Central Intensity Subspace
(applicable when <code>method="TSE"</code>).
</p>
</td></tr>
<tr><td><code id="sdr_+3A_predict">predict</code></td>
<td>

<p>Logical value indicating whether to compute the new predictors
as well.
</p>
</td></tr>
<tr><td><code id="sdr_+3A_...">...</code></td>
<td>

<p>Additional arguments (ignored by <code>sdr.ppp</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a point pattern <code class="reqn">X</code> and predictor variables
<code class="reqn">Z_1, \dots, Z_p</code>,
Sufficient Dimension Reduction methods
(Guan and Wang, 2010) attempt to find a minimal set
of new predictor variables, each constructed by taking a linear combination
of the original predictors, which explain the dependence of
<code class="reqn">X</code> on   <code class="reqn">Z_1, \dots, Z_p</code>.
The methods do not assume any particular form of dependence
of the point pattern on the predictors.
The predictors are assumed to
be Gaussian random fields.
</p>
<p>Available methods are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>method="DR"</code> </td><td style="text-align: left;"> directional regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="NNIR"</code> </td><td style="text-align: left;"> nearest neighbour inverse regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="SAVE"</code> </td><td style="text-align: left;"> sliced average variance estimation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="SIR"</code> </td><td style="text-align: left;"> sliced inverse regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="TSE"</code> </td><td style="text-align: left;"> two-step estimation </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The result includes a matrix <code>B</code> whose columns are estimates
of the basis vectors of the space of new predictors. That is,
the <code>j</code>th column of <code>B</code> expresses the <code>j</code>th new
predictor as a linear combination of the original predictors.
</p>
<p>If <code>predict=TRUE</code>, the new predictors are also evaluated.
They can also be evaluated using <code><a href="#topic+sdrPredict">sdrPredict</a></code>.
</p>


<h3>Value</h3>

<p>A list with components <code>B, M</code>
or <code>B, M1, M2</code> where
<code>B</code> is a matrix whose columns are estimates of the basis vectors
for the space, and <code>M</code> or <code>M1,M2</code> are matrices containing
estimates of the kernel.
</p>
<p>If <code>predict=TRUE</code>, the result also includes a component
<code>Y</code> which is a list of pixel images giving the values of the
new predictors.
</p>


<h3>Author(s)</h3>

<p>Matlab original by Yongtao Guan,
translated to <span class="rlang"><b>R</b></span> by Suman Rakshit.
</p>


<h3>References</h3>

<p>Guan, Y. and Wang, H. (2010)
Sufficient dimension reduction for spatial point
processes directed by Gaussian random fields.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 367&ndash;387.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdrPredict">sdrPredict</a></code> to compute the new predictors from the
coefficient matrix.
</p>
<p><code><a href="#topic+dimhat">dimhat</a></code> to estimate the subspace dimension.
</p>
<p><code><a href="#topic+subspaceDistance">subspaceDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- sdr(bei, bei.extra, predict=TRUE)
   A
   Y1 &lt;- A$Y[[1]]
   plot(Y1)
   points(bei, pch=".", cex=2)
   # investigate likely form of dependence
   plot(rhohat(bei, Y1))
</code></pre>

<hr>
<h2 id='sdrPredict'>
Compute Predictors from Sufficient Dimension Reduction
</h2><span id='topic+sdrPredict'></span>

<h3>Description</h3>

<p>Given the result of a Sufficient Dimension Reduction method,
compute the new predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sdrPredict(covariates, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdrPredict_+3A_covariates">covariates</code></td>
<td>

<p>A list of pixel images (objects of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="sdrPredict_+3A_b">B</code></td>
<td>

<p>Either a matrix of coefficients for the covariates, or the result of
a call to <code><a href="#topic+sdr">sdr</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that <code><a href="#topic+sdr">sdr</a></code> has already been used to
find a minimal set of predictors based on the <code>covariates</code>.
The argument <code>B</code> should be either the result of <code><a href="#topic+sdr">sdr</a></code>
or the coefficient matrix returned as one of the
results of <code><a href="#topic+sdr">sdr</a></code>. The columns of this matrix define linear
combinations of the <code>covariates</code>. This function evaluates those
linear combinations, and returns a list of pixel images containing the
new predictors.
</p>


<h3>Value</h3>

<p>A list of pixel images  (objects of class <code>"im"</code>)
with one entry for each column of <code>B</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdr">sdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- sdr(bei, bei.extra)
   Y &lt;- sdrPredict(bei.extra, A)
   Y
</code></pre>

<hr>
<h2 id='segregation.test'>
Test of Spatial Segregation of Types
</h2><span id='topic+segregation.test'></span><span id='topic+segregation.test.ppp'></span>

<h3>Description</h3>

<p>Performs a Monte Carlo test of spatial segregation of the types
in a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segregation.test(X, ...)

## S3 method for class 'ppp'
segregation.test(X, ..., nsim = 19,
       permute = TRUE, verbose = TRUE, Xname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segregation.test_+3A_x">X</code></td>
<td>

<p>Multitype point pattern (object of class <code>"ppp"</code>
with factor-valued marks).
</p>
</td></tr>
<tr><td><code id="segregation.test_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+relrisk.ppp">relrisk.ppp</a></code>
to control the smoothing parameter or bandwidth selection.
</p>
</td></tr>
<tr><td><code id="segregation.test_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations for the Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="segregation.test_+3A_permute">permute</code></td>
<td>

<p>Argument passed to <code>rlabel</code>. If <code>TRUE</code> (the
default), randomisation is performed by randomly permuting the
labels of <code>X</code>. If <code>FALSE</code>, randomisation is performing
by resampling the labels with replacement.
</p>
</td></tr>
<tr><td><code id="segregation.test_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="segregation.test_+3A_xname">Xname</code></td>
<td>

<p>Optional character string giving the name of the dataset <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Monte Carlo test of spatial segregation of types,
proposed by Kelsall and Diggle (1995)
and Diggle et al (2005), is applied to the point pattern <code>X</code>.
The test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
    T = \sum_i \sum_m \left( \widehat p(m \mid x_i) - \overline p_m
    \right)^2
  </code>
</p>

<p>where <code class="reqn">\widehat p(m \mid x_i)</code> is the
leave-one-out kernel smoothing estimate of the probability that the
<code class="reqn">i</code>-th data point has type <code class="reqn">m</code>, and
<code class="reqn">\overline p_m</code> is the average fraction of data points
which are of type <code class="reqn">m</code>.
The statistic <code class="reqn">T</code> is evaluated for the data and
for <code>nsim</code> randomised versions of <code>X</code>, generated by
randomly permuting or resampling the marks.
</p>
<p>Note that, by default, automatic bandwidth selection will be
performed separately for each randomised pattern. This computation
can be very time-consuming but is necessary for the test to be
valid in most conditions. A short-cut is to specify the value of
the smoothing bandwidth <code>sigma</code> as shown in the examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> representing the result of the test.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Kelsall, J.E. and Diggle, P.J. (1995)
Kernel estimation of relative risk.
<em>Bernoulli</em> <b>1</b>, 3&ndash;16.
</p>
<p>Diggle, P.J., Zheng, P. and Durr, P. (2005)
Non-parametric estimation of spatial segregation in a
multivariate point process: bovine tuberculosis in
Cornwall, UK. 
<em>Applied Statistics</em> <b>54</b>, 645&ndash;658.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relrisk">relrisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  segregation.test(hyytiala, 5)

  if(interactive()) segregation.test(hyytiala, hmin=0.05) 
</code></pre>

<hr>
<h2 id='sharpen'>Data Sharpening of Point Pattern</h2><span id='topic+sharpen'></span><span id='topic+sharpen.ppp'></span>

<h3>Description</h3>

<p>Performs Choi-Hall data sharpening of a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharpen(X, ...)
## S3 method for class 'ppp'
sharpen(X, sigma=NULL, ...,
                      varcov=NULL, edgecorrect=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharpen_+3A_x">X</code></td>
<td>
<p>A marked point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="sharpen_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of isotropic Gaussian smoothing kernel.
</p>
</td></tr>
<tr><td><code id="sharpen_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic Gaussian kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="sharpen_+3A_edgecorrect">edgecorrect</code></td>
<td>

<p>Logical value indicating whether to apply
edge effect bias correction.
</p>
</td></tr>
<tr><td><code id="sharpen_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the pixel resolution of the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Choi and Hall (2001) proposed a procedure for
<em>data sharpening</em> of spatial point patterns.
This procedure is appropriate for earthquake epicentres
and other point patterns which are believed to exhibit
strong concentrations of points along a curve. Data sharpening
causes such points to concentrate more tightly along the curve.
</p>
<p>If the original data points are 
<code class="reqn">X_1, \ldots, X_n</code>
then the sharpened points are
</p>
<p style="text-align: center;"><code class="reqn">
    \hat X_i = \frac{\sum_j X_j k(X_j-X_i)}{\sum_j k(X_j - X_i)}
  </code>
</p>

<p>where <code class="reqn">k</code> is a smoothing kernel in two dimensions.
Thus, the new point <code class="reqn">\hat X_i</code> is a
vector average of the nearby points <code class="reqn">X[j]</code>.
</p>
<p>The function <code>sharpen</code> is generic. It currently has only one
method, for two-dimensional point patterns (objects of class
<code>"ppp"</code>).
</p>
<p>If <code>sigma</code> is given, the smoothing kernel is the
isotropic two-dimensional Gaussian density with standard deviation
<code>sigma</code> in each axis. If <code>varcov</code> is given, the smoothing
kernel is the Gaussian density with variance-covariance matrix
<code>varcov</code>.
</p>
<p>The data sharpening procedure tends to cause the point pattern
to contract away from the boundary of the window. That is,
points <code class="reqn">X_i</code> that lie 'quite close to the edge of the window
of the point pattern tend to be displaced inward. 
If <code>edgecorrect=TRUE</code> then the algorithm is modified to
correct this vector bias. 
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>) in the same window
as the original pattern <code>X</code>, and with the same marks as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Choi, E. and Hall, P. (2001)
Nonparametric analysis of earthquake point-process data.
In M. de Gunst, C. Klaassen and A. van der Vaart (eds.)
<em>State of the art in probability and statistics:
Festschrift for Willem R. van Zwet</em>,
Institute of Mathematical Statistics, Beachwood, Ohio.
Pages 324&ndash;344.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- unmark(shapley)
   
   Y &lt;- sharpen(X, sigma=0.5)
   Z &lt;- sharpen(X, sigma=0.5, edgecorrect=TRUE)
   opa &lt;- par(mar=rep(0.2, 4))
   plot(solist(X, Y, Z), main= " ",
        main.panel=c("data", "sharpen", "sharpen, correct"),
        pch=".", equal.scales=TRUE, mar.panel=0.2)
   par(opa)
</code></pre>

<hr>
<h2 id='Smooth'>Spatial smoothing of data</h2><span id='topic+Smooth'></span>

<h3>Description</h3>

<p>Generic function to perform spatial smoothing of spatial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Smooth(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth_+3A_x">X</code></td>
<td>
<p>Some kind of spatial data</p>
</td></tr>
<tr><td><code id="Smooth_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function calls an appropriate method
to perform spatial smoothing on the spatial dataset <code>X</code>.
</p>
<p>Methods for this function include
</p>

<ul>
<li> <p><code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> for point patterns
</p>
</li>
<li> <p><code><a href="spatstat.model.html#topic+Smooth.msr">Smooth.msr</a></code> for measures
</p>
</li>
<li> <p><code><a href="#topic+Smooth.fv">Smooth.fv</a></code> for function value tables
</p>
</li></ul>



<h3>Value</h3>

<p>An object containing smoothed values of the input data,
in an appropriate format. See the documentation for the methods.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>,
<code><a href="#topic+Smooth.im">Smooth.im</a></code>,
<code><a href="spatstat.model.html#topic+Smooth.msr">Smooth.msr</a></code>,
<code><a href="#topic+Smooth.fv">Smooth.fv</a></code>.
</p>

<hr>
<h2 id='Smooth.fv'>
Apply Smoothing to Function Values
</h2><span id='topic+Smooth.fv'></span>

<h3>Description</h3>

<p>Applies smoothing to the values
in selected columns of a function value table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
Smooth(X, which = "*", ...,
          method=c("smooth.spline", "loess"),
          xinterval=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.fv_+3A_x">X</code></td>
<td>

<p>Values to be smoothed.
A function value table (object of class <code>"fv"</code>,
see <code><a href="#topic+fv.object">fv.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Smooth.fv_+3A_which">which</code></td>
<td>

<p>Character vector identifying which columns of the table
should be smoothed. Either a vector containing names
of columns, or one of the wildcard strings <code>"*"</code> or <code>"."</code>
explained below.
</p>
</td></tr>
<tr><td><code id="Smooth.fv_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
or <code><a href="stats.html#topic+loess">loess</a></code> to control the smoothing.
</p>
</td></tr>
<tr><td><code id="Smooth.fv_+3A_method">method</code></td>
<td>

<p>Smoothing algorithm. A character string, partially matched
to either <code>"smooth.spline"</code> or <code>"loess"</code>.
</p>
</td></tr>
<tr><td><code id="Smooth.fv_+3A_xinterval">xinterval</code></td>
<td>

<p>Optional. Numeric vector of length 2 specifying a range of
<code class="reqn">x</code> values. Smoothing will be performed only on the part of the
function corresponding to this range.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>Smooth.fv</code>
applies smoothing to the function values in
a function value table (object of class <code>"fv"</code>).
</p>
<p><code>Smooth.fv</code> is a method for the generic function
<code><a href="#topic+Smooth">Smooth</a></code>.
</p>
<p>The smoothing is performed either by 
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or by
<code><a href="stats.html#topic+loess">loess</a></code>.
</p>
<p>Smoothing is applied to every column
(or to each of the selected columns) of function values in turn,
using the function argument as the <code class="reqn">x</code> coordinate
and the selected column as the <code class="reqn">y</code> coordinate.
The original function values are then replaced by the corresponding
smooth interpolated function values.
</p>
<p>The optional argument <code>which</code> specifies which of the
columns of function values in <code>x</code> will be smoothed.
The default (indicated by the wildcard <code>which="*"</code>)
is to smooth all function values, i.e.\ all columns except the
function argument. Alternatively <code>which="."</code> designates
the subset of function values that are displayed in the default plot.
Alternatively <code>which</code> can be a character vector containing the
names of columns of <code>x</code>.
</p>
<p>If the argument <code>xinterval</code> is given, then
smoothing will be performed only in the specified range 
of <code class="reqn">x</code> values. 
</p>


<h3>Value</h3>

<p>Another function value table (object of class <code>"fv"</code>)
of the same format.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smooth">Smooth</a></code>,
<code><a href="#topic+with.fv">with.fv</a></code>,
<code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   G &lt;- Gest(cells)
   plot(G)
   plot(Smooth(G, df=9), add=TRUE)
</code></pre>

<hr>
<h2 id='Smooth.ppp'>Spatial smoothing of observations at irregular points</h2><span id='topic+Smooth.ppp'></span><span id='topic+markmean'></span><span id='topic+markvar'></span>

<h3>Description</h3>

<p>Performs spatial smoothing of numeric values observed
at a set of irregular locations. Uses kernel smoothing
and least-squares cross-validated bandwidth selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
Smooth(X, sigma=NULL,
                     ...,
                     weights = rep(1, npoints(X)),
                     at = "pixels", leaveoneout=TRUE, 
                     adjust = 1, varcov = NULL, 
                     edge = TRUE, diggle = FALSE,
                     kernel = "gaussian",
                     scalekernel = is.character(kernel),
                     se = FALSE,
                     loctype = c("random", "fixed"),
                     wtype = c("multiplicity", "importance"),
                     geometric = FALSE)

markmean(X, ...)

markvar(X, sigma=NULL, ..., weights=NULL, varcov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.ppp_+3A_x">X</code></td>
<td>
<p>A marked point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth.
A single positive number, a numeric vector of length 2,
or a function that selects the bandwidth automatically.
See <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to
<code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code> and <code><a href="#topic+density.ppp">density.ppp</a></code>
to control the kernel smoothing and
the pixel resolution of the result.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional weights attached to the observations.
A numeric vector, a <code>function(x,y)</code>, a pixel image,
or an <code>expression</code>. See <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the smoothed values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_edge">edge</code>, <code id="Smooth.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to
determine the edge correction.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the bandwidth <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix. An alternative
to <code>sigma</code>. See <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_kernel">kernel</code></td>
<td>

<p>The smoothing kernel.
A character string specifying the smoothing kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>),
or a pixel image (object of class <code>"im"</code>)
containing values of the kernel, or a <code>function(x,y)</code> which
yields values of the kernel.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_scalekernel">scalekernel</code></td>
<td>

<p>Logical value.
If <code>scalekernel=TRUE</code>, then the kernel will be rescaled
to the bandwidth determined by <code>sigma</code> and <code>varcov</code>:
this is the default behaviour when <code>kernel</code> is a character string.
If <code>scalekernel=FALSE</code>, then <code>sigma</code> and <code>varcov</code>
will be ignored: this is the default behaviour when <code>kernel</code> is a
function or a pixel image.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_se">se</code></td>
<td>

<p>Logical value specifying whether to calculate standard errors.
This calculation is experimental.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_loctype">loctype</code></td>
<td>

<p>Character string (partially matched) specifying whether the
point locations are assumed to be fixed or random, in the
calculation of standard error. Experimental.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_wtype">wtype</code></td>
<td>

<p>Character string (partially matched) specifying whether the
weights should be interpreted as multiplicities or as importance
weights, in the calculation of standard error. Experimental.
</p>
</td></tr>
<tr><td><code id="Smooth.ppp_+3A_geometric">geometric</code></td>
<td>

<p>Logical value indicating whether to perform geometric mean
smoothing instead of arithmetic mean smoothing. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Smooth.ppp</code>
performs spatial smoothing of numeric values
observed at a set of irregular locations. The functions
<code>markmean</code> and <code>markvar</code> are wrappers for <code>Smooth.ppp</code>
which compute the spatially-varying mean and variance of the marks of
a point pattern.
</p>
<p><code>Smooth.ppp</code> is a method for the generic function
<code><a href="#topic+Smooth">Smooth</a></code> for the class <code>"ppp"</code> of point patterns.
Thus you can type simply <code>Smooth(X)</code>.
</p>
<p>Smoothing is performed by kernel weighting, using the Gaussian kernel
by default. If the observed values are <code class="reqn">v_1,\ldots,v_n</code>
at locations <code class="reqn">x_1,\ldots,x_n</code> respectively,
then the smoothed value at a location <code class="reqn">u</code> is
(ignoring edge corrections)
</p>
<p style="text-align: center;"><code class="reqn">
    g(u) = \frac{\sum_i k(u-x_i) v_i}{\sum_i k(u-x_i)}
  </code>
</p>

<p>where <code class="reqn">k</code> is the kernel (a Gaussian kernel by default).
This is known as the
Nadaraya-Watson smoother (Nadaraya, 1964, 1989; Watson, 1964).
By default, the smoothing kernel bandwidth is chosen by
least squares cross-validation (see below).
</p>
<p>The argument <code>X</code> must be a marked point pattern (object
of class <code>"ppp"</code>, see <code>ppp.object</code>).
The points of the pattern are taken to be the
observation locations <code class="reqn">x_i</code>, and the marks of the pattern
are taken to be the numeric values <code class="reqn">v_i</code> observed at these
locations.
</p>
<p>The marks are allowed to be a data frame (in
<code>Smooth.ppp</code>
and <code>markmean</code>). Then the smoothing procedure is applied to each
column of marks. 
</p>
<p>The numerator and denominator are computed by <code><a href="#topic+density.ppp">density.ppp</a></code>.
The arguments <code>...</code> control the smoothing kernel parameters
and determine whether edge correction is applied.
The smoothing kernel bandwidth can be specified by either of the arguments
<code>sigma</code> or <code>varcov</code> which are passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
If neither of these arguments is present, then by default the
bandwidth is selected by least squares cross-validation,
using <code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code>. 
</p>
<p>The optional argument <code>weights</code> allows numerical weights to
be applied to the data. If a weight <code class="reqn">w_i</code>
is associated with location <code class="reqn">x_i</code>, then the smoothed
function is 
(ignoring edge corrections)
</p>
<p style="text-align: center;"><code class="reqn">
    g(u) = \frac{\sum_i k(u-x_i) v_i w_i}{\sum_i k(u-x_i) w_i}
  </code>
</p>

<p>If <code>geometric=TRUE</code> then geometric mean smoothing
is performed instead of arithmetic mean smoothing.
The mark values must be non-negative numbers.
The logarithm of the mark values is computed; these logarithmic values are
kernel-smoothed as described above; then the exponential function
is applied to the smoothed values.
</p>
<p>An alternative to kernel smoothing is inverse-distance weighting,
which is performed by <code><a href="#topic+idw">idw</a></code>.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
Pixel values are values of the interpolated function.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p>The return value has attributes
<code>"sigma"</code> and <code>"varcov"</code> which report the smoothing
bandwidth that was used.
</p>


<h3>Very small bandwidth</h3>

<p>If the chosen bandwidth <code>sigma</code> is very small,
kernel smoothing is mathematically equivalent
to nearest-neighbour interpolation; the result will
be computed by <code>nnmark</code>. This is
unless <code>at="points"</code> and <code>leaveoneout=FALSE</code>,
when the original mark values are returned.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Nadaraya, E.A. (1964) On estimating regression.
<em>Theory of Probability and its Applications</em>
<b>9</b>, 141&ndash;142.
</p>
<p>Nadaraya, E.A. (1989) 
<em>Nonparametric estimation of probability densities
and regression curves</em>.
Kluwer, Dordrecht.
</p>
<p>Watson, G.S. (1964)
Smooth regression analysis.
<em>Sankhya A</em> <b>26</b>, 359&ndash;372.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smooth">Smooth</a></code>,
</p>
<p><code><a href="#topic+density.ppp">density.ppp</a></code>,
<code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code>,
<code>nnmark</code>,
<code>ppp.object</code>,
<code>im.object</code>.
</p>
<p>See <code><a href="#topic+idw">idw</a></code> for inverse-distance weighted smoothing.
</p>
<p>To perform interpolation, see also the <code>akima</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Longleaf data - tree locations, marked by tree diameter
   # Local smoothing of tree diameter (automatic bandwidth selection)
   Z &lt;- Smooth(longleaf)
   # Kernel bandwidth sigma=5
   plot(Smooth(longleaf, 5))
   # mark variance
   plot(markvar(longleaf, sigma=5))
   # data frame of marks: trees marked by diameter and height
   plot(Smooth(finpines, sigma=2))
   head(Smooth(finpines, sigma=2, at="points"))
</code></pre>

<hr>
<h2 id='Smooth.ssf'>
Smooth a Spatially Sampled Function
</h2><span id='topic+Smooth.ssf'></span>

<h3>Description</h3>

<p>Applies kernel smoothing to a spatially sampled function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ssf'
Smooth(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.ssf_+3A_x">X</code></td>
<td>

<p>Object of class <code>"ssf"</code>.
</p>
</td></tr>
<tr><td><code id="Smooth.ssf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>
to control the smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ssf"</code> represents a real-valued or
vector-valued function that has been evaluated or sampled at an
irregular set of points.
</p>
<p>The function values will be smoothed using a Gaussian
kernel.
</p>


<h3>Value</h3>

<p>A pixel image or a list of pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssf">ssf</a></code>,
<code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- ssf(redwood, nndist(redwood))
   Smooth(f, sigma=0.1)
</code></pre>

<hr>
<h2 id='Smoothfun.ppp'>
Smooth Interpolation of Marks as a Spatial Function
</h2><span id='topic+Smoothfun'></span><span id='topic+Smoothfun.ppp'></span>

<h3>Description</h3>

<p>Perform spatial smoothing of numeric values observed
at a set of irregular locations, and return the result
as a function of spatial location.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smoothfun(X, ...)

## S3 method for class 'ppp'
Smoothfun(X, sigma = NULL, ...,
                        weights = NULL, edge = TRUE, diggle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smoothfun.ppp_+3A_x">X</code></td>
<td>

<p>Marked point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="Smoothfun.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth, or bandwidth selection function,
passed to <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smoothfun.ppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smoothfun.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional vector of weights associated with the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="Smoothfun.ppp_+3A_edge">edge</code>, <code id="Smoothfun.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Logical arguments controlling the edge correction.
Arguments passed to <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The commands <code>Smoothfun</code> and <code><a href="#topic+Smooth">Smooth</a></code>
both perform kernel-smoothed spatial interpolation
of numeric values observed at irregular spatial locations.
The difference is that <code><a href="#topic+Smooth">Smooth</a></code> returns a pixel image,
containing the interpolated values at a grid of locations, while
<code>Smoothfun</code> returns a <code>function(x,y)</code> which can be used
to compute the interpolated value at <em>any</em> spatial location.
For purposes such as model-fitting it is more accurate to
use <code>Smoothfun</code> to interpolate data.
</p>


<h3>Value</h3>

<p>A <code>function</code> with arguments <code>x,y</code>.
The function also belongs to the class <code>"Smoothfun"</code> which has
methods for <code>print</code> and <code>as.im</code>.
It also belongs to the class <code>"funxy"</code> which has methods
for <code>plot</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smooth">Smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- Smoothfun(longleaf)
  f
  f(120, 80)
  plot(f)
</code></pre>

<hr>
<h2 id='spatcov'>
Estimate the Spatial Covariance Function of a Random Field
</h2><span id='topic+spatcov'></span>

<h3>Description</h3>

<p>Given a pixel image, calculate an estimate of the spatial
covariance function. Given two pixel images, calculate an estimate of their
spatial cross-covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatcov(X, Y=X, ..., correlation=FALSE, isotropic = TRUE,
        clip = TRUE, pooling=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatcov_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_y">Y</code></td>
<td>

<p>Optional. Another pixel image.
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_correlation">correlation</code></td>
<td>

<p>Logical value specifying whether to standardise
so that the spatial correlation function is returned.
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_isotropic">isotropic</code></td>
<td>

<p>Logical value specifying whether to assume the covariance
is isotropic, so that the result is a function of the lag distance.
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_clip">clip</code></td>
<td>

<p>Logical value specifying whether to restrict the results to
the range of spatial lags where the estimate is reliable.
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_pooling">pooling</code></td>
<td>

<p>Logical value specifying the estimation method when <code>isotropic=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="spatcov_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In normal usage, only the first argument <code>X</code> is given.
Then the pixel image <code>X</code> is treated as a realisation of a stationary
random field, and its spatial covariance function is estimated.
</p>
<p>Alternatively if <code>Y</code> is given,
then <code>X</code> and <code>Y</code> are assumed to be
jointly stationary random fields, and their spatial cross-covariance
function is estimated.
</p>
<p>For any random field <code>X</code>, the spatial covariance
is defined for any two spatial locations <code class="reqn">u</code> and <code class="reqn">v</code> by
</p>
<p style="text-align: center;"><code class="reqn">
    C(u,v) = \mbox{cov}(X(u), X(v))
  </code>
</p>

<p>where <code class="reqn">X(u)</code> and <code class="reqn">X(v)</code> are the values of the random field
at those locations. Here<code class="reqn">\mbox{cov}</code> denotes the
statistical covariance, defined for any random variables
<code class="reqn">A</code> and <code class="reqn">B</code> by
<code class="reqn">\mbox{cov}(A,B) = E(AB) - E(A) E(B)</code>
where <code class="reqn">E(A)</code> denotes the expected value of <code class="reqn">A</code>.
</p>
<p>If the random field is assumed to be stationary (at least second-order
stationary) then the spatial covariance <code class="reqn">C(u,v)</code>
depends only on the lag vector <code class="reqn">v-u</code>:
</p>
<p style="text-align: center;"><code class="reqn">
    C(u,v) = C_2(v-u)
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    C(u,v) = C2(v-u)
  </code>
</p>

<p>where <code class="reqn">C_2</code> is a function of a single vector argument.
</p>
<p>If the random field is stationary and isotropic, then the spatial
covariance depends only on the lag distance
<code class="reqn">\| v - u \|</code>:
</p>
<p style="text-align: center;"><code class="reqn">
    C_2(v-u) = C_1(\|v-u\|)
  </code>
</p>

<p>where <code class="reqn">C_1</code> is a function of distance.
</p>
<p>The function <code>spatcov</code> computes estimates of the
covariance function <code class="reqn">C_1</code> or <code class="reqn">C_2</code> as follows:
</p>

<ul>
<li> 
<p>If <code>isotropic=FALSE</code>, an estimate of the 
covariance function <code class="reqn">C_2</code> is computed,
assuming the random field is stationary, using the naive
moment estimator,
<code>C2 = imcov(X-mean(X))/setcov(Window(X))</code>.
The result is a pixel image.
</p>
</li>
<li> 
<p>If <code>isotropic=TRUE</code> (the default)
an estimate of the covariance function <code class="reqn">C_1</code>
is computed, assuming the random field is stationary and isotropic.
</p>

<ul>
<li> 
<p>When <code>pooling=FALSE</code>, the estimate of <code class="reqn">C_1</code>
is the rotational average of the naive estimate of <code class="reqn">C_2</code>.
</p>
</li>
<li> 
<p>When <code>pooling=TRUE</code> (the default), the  estimate of <code class="reqn">C_1</code>
is the ratio of the rotational averages of the numerator and
denominator which form the naive estimate of  <code class="reqn">C_2</code>.
</p>
</li></ul>

<p>The result is a function object (class <code>"fv"</code>).
</p>
</li></ul>

<p>If the argument <code>Y</code> is given, it should be a pixel image
compatible with <code>X</code>. An estimate of the spatial cross-covariance function
between <code>X</code> and <code>Y</code> will be computed.
</p>


<h3>Value</h3>

<p>If <code>isotropic=TRUE</code> (the default), the result is a function value
table (object of class <code>"fv"</code>) giving the estimated values of the
covariance function or spatial correlation function
for a sequence of values of the spatial lag
distance <code>r</code>.
</p>
<p>If <code>isotropic=FALSE</code>, the result is a pixel image
(object of class <code>"im"</code>) giving the estimated values of the
spatial covariance function or spatial correlation function
for a grid of values of the spatial lag vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>imcov</code>, <code>setcov</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(offline &lt;- !interactive()) op &lt;- spatstat.options(npixel=32)

  D &lt;- density(cells)
  plot(spatcov(D))

if(offline) spatstat.options(op)
</code></pre>

<hr>
<h2 id='spatialcdf'>
Spatial Cumulative Distribution Function
</h2><span id='topic+spatialcdf'></span>

<h3>Description</h3>

<p>Compute the spatial cumulative distribution function of a
spatial covariate, optionally using spatially-varying weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialcdf(Z, weights = NULL, normalise = FALSE, ..., W = NULL, Zname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialcdf_+3A_z">Z</code></td>
<td>

<p>Spatial covariate.
A pixel image or a <code>function(x,y,...)</code>
</p>
</td></tr>
<tr><td><code id="spatialcdf_+3A_weights">weights</code></td>
<td>

<p>Spatial weighting for different locations.
A pixel image, a <code>function(x,y,...)</code>, a window, a constant value,
or a fitted point process model (object of class <code>"ppm"</code> or
<code>"kppm"</code>).
</p>
</td></tr>
<tr><td><code id="spatialcdf_+3A_normalise">normalise</code></td>
<td>

<p>Logical. Whether the weights should be normalised so that they
sum to 1.
</p>
</td></tr>
<tr><td><code id="spatialcdf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine the pixel
resolution, or extra arguments passed to <code>Z</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="spatialcdf_+3A_w">W</code></td>
<td>

<p>Optional window (object of class <code>"owin"</code>) defining the spatial
domain.
</p>
</td></tr>
<tr><td><code id="spatialcdf_+3A_zname">Zname</code></td>
<td>

<p>Optional character string for the name of the covariate <code>Z</code>
used in plots.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>weights</code> is missing or <code>NULL</code>, it defaults to 1.
The values of the covariate <code>Z</code>
are computed on a grid of pixels. The weighted cumulative distribution
function of <code>Z</code> values is computed, taking each value with weight
equal to the pixel area. The resulting function <code class="reqn">F</code> is such that
<code class="reqn">F(t)</code> is the area of the region of space where
<code class="reqn">Z \le t</code>.
</p>
<p>If <code>weights</code> is a pixel image or a function, then the
values of <code>weights</code> and of the covariate <code>Z</code>
are computed on a grid of pixels. The
<code>weights</code> are multiplied by the pixel area.
Then the weighted empirical cumulative distribution function
of <code>Z</code> values
is computed using <code>ewcdf</code>. The resulting function
<code class="reqn">F</code> is such that <code class="reqn">F(t)</code> is the total weight (or weighted area)
of the region of space where <code class="reqn">Z \le t</code>.
</p>
<p>If <code>weights</code> is a fitted point process model, then it should
be a Poisson process. The fitted intensity of the model,
and the value of the covariate <code>Z</code>, are evaluated at the
quadrature points used to fit the model. The <code>weights</code> are
multiplied by the weights of the quadrature points.
Then the weighted empirical cumulative distribution of <code>Z</code> values
is computed using <code>ewcdf</code>. The resulting function
<code class="reqn">F</code> is such that <code class="reqn">F(t)</code> is the expected number of points
in the point process that will fall in the region of space
where <code class="reqn">Z \le t</code>.
</p>
<p>If <code>normalise=TRUE</code>, the function is normalised so that its
maximum value equals 1, so that it gives the cumulative
<em>fraction</em> of weight or cumulative fraction of points.
</p>
<p>The result can be printed, plotted, and used as a function.
</p>


<h3>Value</h3>

<p>A cumulative distribution function object
belonging to the classes <code>"spatialcdf"</code>,
<code>"ewcdf"</code>, <code>"ecdf"</code> (only if <code>normalise=TRUE</code>)
and <code>"stepfun"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>ewcdf</code>,
<code><a href="#topic+cdf.test">cdf.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   with(bei.extra, {
     plot(spatialcdf(grad))
     if(require("spatstat.model")) {  
       fit &lt;- ppm(bei ~ elev)
       plot(spatialcdf(grad, predict(fit)))
       A &lt;- spatialcdf(grad, fit)
       A(0.1)
     }
  })
  plot(spatialcdf("x", W=letterR))
</code></pre>

<hr>
<h2 id='SpatialMedian.ppp'>
Spatially Weighted Median of Values at Points
</h2><span id='topic+SpatialMedian.ppp'></span>

<h3>Description</h3>

<p>Given a spatial point pattern with numeric marks,
compute a weighted median of the mark values,
with spatially-varying weights that depend on distance to the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
SpatialMedian(X, sigma = NULL, ...,
        type = 4, at = c("pixels", "points"), leaveoneout = TRUE,
        weights = NULL, edge = TRUE, diggle = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialMedian.ppp_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>)
with numeric marks.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth, passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> controlling the
spatial smoothing.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of median
(using the convention of <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>;
see Details).
Only types 1 and 4 are currently implemented.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_at">at</code></td>
<td>

<p>Character string indicating whether to compute the median
at every pixel of a pixel image (<code>at="pixels"</code>, the default)
or at every data point of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional vector of numeric weights attached to the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_edge">edge</code>, <code id="SpatialMedian.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to
determine the edge correction.
</p>
</td></tr>
<tr><td><code id="SpatialMedian.ppp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports
during the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>X</code> should be a spatial point pattern
(object of class <code>"ppp"</code>) with numeric marks.
</p>
<p>The algorithm computes the weighted median of the mark values
at each desired spatial location, using spatially-varying weights
which depend on distance to the data points.
</p>
<p>Suppose the data points are at spatial locations
<code class="reqn">x_1,\ldots,x_n</code>
and have mark values 
<code class="reqn">y_1,\ldots,y_n</code>.
For a query location <code class="reqn">u</code>, the smoothed median is defined
as the weighted median of the mark values
<code class="reqn">y_1,\ldots,y_n</code> with weights
<code class="reqn">w_1,\ldots,w_n</code>,
where
</p>
<p style="text-align: center;"><code class="reqn">
    w_i = \frac{k(u,x_i)}{\sum_{j=1}^n k(u,x_j)}
  </code>
</p>

<p>where <code class="reqn">k(u,v)</code> is the smoothing kernel with bandwidth <code>sigma</code>
</p>
<p>If <code>at="points"</code> and <code>leaveoneout=TRUE</code>, then
a leave-one-out calculation is performed, which means that
when the query location is a data point <code class="reqn">x_i</code>,
the value at the data point is ignored, and 
the weighted median is computed from the values <code class="reqn">y_j</code>
for all <code class="reqn">j</code> not equal to <code class="reqn">i</code>.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p>The return value has attributes
<code>"sigma"</code> and <code>"varcov"</code> which report the smoothing
bandwidth that was used.
</p>
<p>The calculation of the median value depends on the argument
<code>type</code> which is interpreted in the same way as for
<code><a href="stats.html#topic+quantile.default">quantile.default</a></code>. Currently, only types 1 and 4
are implemented. 
If <code>type=1</code>, the median is always
one of the mark values (one of the values in <code>marks(x)</code>).
If <code>type=4</code> (the default),
the median value is obtained by linearly interpolating
between mark values.
Note that the default values of <code>type</code>
in <code>SpatialMedian.ppp</code> and <code><a href="#topic+SpatialQuantile.ppp">SpatialQuantile.ppp</a></code>
are different.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p>Generic function <code><a href="#topic+SpatialMedian">SpatialMedian</a></code>.
</p>
<p><code><a href="#topic+SpatialQuantile">SpatialQuantile</a></code> and <code><a href="#topic+SpatialQuantile.ppp">SpatialQuantile.ppp</a></code>
for other quantiles.
</p>
<p><code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> for the spatially weighted average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- longleaf
   if(!interactive()) {
    ## mark values rounded to nearest multiple of 10 to reduce check time
    marks(X) &lt;- round(marks(X), -1)
   }
   Z &lt;- SpatialMedian(X, sigma=30)
   ZX &lt;- SpatialMedian(X, sigma=30, at="points")
</code></pre>

<hr>
<h2 id='SpatialQuantile'>
Spatially Weighted Median or Quantile
</h2><span id='topic+SpatialMedian'></span><span id='topic+SpatialQuantile'></span>

<h3>Description</h3>

<p>Compute a weighted median or weighted quantile of spatial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> SpatialMedian(X, ...)

 SpatialQuantile(X, prob = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialQuantile_+3A_x">X</code></td>
<td>

<p>A spatial data object.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile_+3A_prob">prob</code></td>
<td>

<p>Probability for which the quantile is required.
A single numeric value between 0 and 1.
Default is to calculate the median.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>SpatialMedian</code> and <code>SpatialQuantile</code>
are generic. They calculate spatially weighted medians
and quantiles of spatial data. The details depend on the class of
<code>X</code>.
</p>
<p>There are methods for spatial point patterns (class <code>"ppp"</code>)
and possibly for other objects.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p>Methods <code><a href="#topic+SpatialMedian.ppp">SpatialMedian.ppp</a></code>, <code><a href="#topic+SpatialQuantile.ppp">SpatialQuantile.ppp</a></code>.
</p>
<p><code><a href="#topic+Smooth">Smooth</a></code> for the spatially weighted average.
</p>

<hr>
<h2 id='SpatialQuantile.ppp'>
Spatially Weighted Quantile of Values at Points
</h2><span id='topic+SpatialQuantile.ppp'></span>

<h3>Description</h3>

<p>Given a spatial point pattern with numeric marks,
compute a weighted quantile of the mark values,
with spatially-varying weights that depend on distance to the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
SpatialQuantile(X, prob = 0.5, sigma = NULL, ...,
        type = 1, at = c("pixels", "points"), leaveoneout = TRUE,
        weights = NULL, edge = TRUE, diggle = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialQuantile.ppp_+3A_x">X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>)
with numeric marks.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_prob">prob</code></td>
<td>

<p>Probability for which the quantile is required.
A single numeric value between 0 and 1.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth, passed to <code><a href="#topic+density.ppp">density.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> controlling the
spatial smoothing.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of median
(using the convention of <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>;
see Details).
Only types 1 and 4 are currently implemented.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_at">at</code></td>
<td>

<p>Character string indicating whether to compute the quantile
at every pixel of a pixel image (<code>at="pixels"</code>, the default)
or at every data point of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional vector of numeric weights attached to the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_edge">edge</code>, <code id="SpatialQuantile.ppp_+3A_diggle">diggle</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.ppp">density.ppp</a></code> to
determine the edge correction.
</p>
</td></tr>
<tr><td><code id="SpatialQuantile.ppp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports
during the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>X</code> should be a spatial point pattern
(object of class <code>"ppp"</code>) with numeric marks.
</p>
<p>The algorithm computes the weighted quantile of the mark values
at each desired spatial location, using spatially-varying weights
which depend on distance to the data points.
</p>
<p>Suppose the data points are at spatial locations
<code class="reqn">x_1,\ldots,x_n</code>
and have mark values 
<code class="reqn">y_1,\ldots,y_n</code>.
For a query location <code class="reqn">u</code>, the smoothed quantile is defined
as the weighted quantile of the mark values
<code class="reqn">y_1,\ldots,y_n</code> with weights
<code class="reqn">w_1(u),\ldots,w_n(u)</code>,
where
</p>
<p style="text-align: center;"><code class="reqn">
    w_i(u) = \frac{k(u,x_i)}{\sum_{j=1}^n k(u,x_j)}
  </code>
</p>

<p>where <code class="reqn">k(u,v)</code> is the smoothing kernel with bandwidth <code>sigma</code>.
</p>
<p>If <code>at="points"</code> and <code>leaveoneout=TRUE</code>, then
a leave-one-out calculation is performed, which means that
when the query location is a data point <code class="reqn">x_i</code>,
the value at the data point is ignored, and 
the weighted quantile is computed from the values <code class="reqn">y_j</code>
for all <code class="reqn">j</code> not equal to <code class="reqn">i</code>.
</p>
<p>The calculation of the quantile value depends on the argument
<code>type</code> which is interpreted in the same way as for
<code><a href="stats.html#topic+quantile.default">quantile.default</a></code>. Currently, only types 1 and 4
are implemented. 
If <code>type=1</code> (the default), the quantile value is
one of the mark values (one of the values in <code>marks(x)</code>).
If <code>type=4</code>, the quantile value is obtained by linearly interpolating
between mark values.
Note that the default values of <code>type</code>
in <code>SpatialQuantile.ppp</code> and <code><a href="#topic+SpatialMedian.ppp">SpatialMedian.ppp</a></code>
are different.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p>The return value has attributes
<code>"sigma"</code> and <code>"varcov"</code> which report the smoothing
bandwidth that was used.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SpatialMedian.ppp">SpatialMedian.ppp</a></code>, <code><a href="#topic+SpatialMedian">SpatialMedian</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- longleaf
   if(!interactive()) {
    ## mark values rounded to nearest multiple of 10 to reduce check time
    marks(X) &lt;- round(marks(X), -1)
   }
   Z &lt;- SpatialQuantile(X, prob=0.25, sigma=30)
   ZX &lt;- SpatialQuantile(X, prob=0.25, sigma=30, at="points")
</code></pre>

<hr>
<h2 id='spatstat.explore-deprecated'>Deprecated spatstat.explore functions</h2><span id='topic+evalCovar'></span><span id='topic+which.max.im'></span>

<h3>Description</h3>

<p>Deprecated spatstat.explore functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalCovar(model, covariate, ...)
which.max.im(x)
</code></pre>


<h3>Details</h3>

<p>These functions are deprecated, and will eventually be deleted from
the <span class="pkg">spatstat.explore</span> package.
</p>
<p><code>which.max.im(x)</code> is replaced by
<code>im.apply(x, which.max)</code>.
</p>
<p>The internal function <code>evalCovar</code>
is replaced by the internal function <code>spatialCovariateEvidence</code>.
</p>


<h3>Value</h3>

<p><code>which.max.im</code> returns an integer.
</p>

<hr>
<h2 id='spatstat.explore-internal'>Internal spatstat.explore functions</h2><span id='topic++5B.localpcfmatrix'></span><span id='topic++5B.rat'></span><span id='topic+adjust.ratfv'></span><span id='topic+ang2rad'></span><span id='topic+as.data.frame.bw.optim'></span><span id='topic+as.data.frame.fv'></span><span id='topic+assemble.plot.objects'></span><span id='topic+bandwidth.is.infinite'></span><span id='topic+BartCalc'></span><span id='topic+bermantestCalc'></span><span id='topic+bermantestEngine'></span><span id='topic+bind.ratfv'></span><span id='topic+bw.optim'></span><span id='topic+calc.DR'></span><span id='topic+calc.NNIR'></span><span id='topic+calc.SAVE'></span><span id='topic+calc.SIR'></span><span id='topic+calc.TSE'></span><span id='topic+censtimeCDFest'></span><span id='topic+check.testfun'></span><span id='topic+circticks'></span><span id='topic+clarkevansCalc'></span><span id='topic+compatible.rat'></span><span id='topic+conform.ratfv'></span><span id='topic+CressieReadStatistic'></span><span id='topic+CressieReadSymbol'></span><span id='topic+CressieReadName'></span><span id='topic+cutoff2Dkernel'></span><span id='topic+CVforPCF'></span><span id='topic+Deviation'></span><span id='topic+densitycrossEngine'></span><span id='topic+densitypointsEngine'></span><span id='topic+digestCovariates'></span><span id='topic+digital.volume'></span><span id='topic+dim.fasp'></span><span id='topic+dimnames.fasp'></span><span id='topic+dimnames+3C-.fasp'></span><span id='topic+distributecbind'></span><span id='topic+ensure.listarg'></span><span id='topic+envelopeEngine'></span><span id='topic+envelopeProgressData'></span><span id='topic+envelopeTest'></span><span id='topic+envelope.hasenvelope'></span><span id='topic+envelope.matrix'></span><span id='topic+evaluateCovariate'></span><span id='topic+evaluateCovariateAtPoints'></span><span id='topic+evaluateCovariateAtPixels'></span><span id='topic+evaluate2Dkernel'></span><span id='topic+ExpSmoothLog'></span><span id='topic+exactppm'></span><span id='topic+extractAtomicQtests'></span><span id='topic+fasp'></span><span id='topic+f3engine'></span><span id='topic+f3Cengine'></span><span id='topic+findbestlegendpos'></span><span id='topic+findcbind'></span><span id='topic+flatfname'></span><span id='topic+FormatFaspFormulae'></span><span id='topic+fvexprmap'></span><span id='topic+fvlabels'></span><span id='topic+fvlabels+3C-'></span><span id='topic+fvlabelmap'></span><span id='topic+fvlegend'></span><span id='topic+g3engine'></span><span id='topic+g3Cengine'></span><span id='topic+getSumFun'></span><span id='topic+good.correction.K'></span><span id='topic+hasenvelope'></span><span id='topic+implemented.for.K'></span><span id='topic+is.atomicQtest'></span><span id='topic+is.poisson.exactppm'></span><span id='topic+is.scov'></span><span id='topic+is.stationary.exactppm'></span><span id='topic+k3engine'></span><span id='topic+Kborder.engine'></span><span id='topic+Knone.engine'></span><span id='topic+Krect.engine'></span><span id='topic+Kount'></span><span id='topic+Kwtsum'></span><span id='topic+km.rs.opt'></span><span id='topic+localKengine'></span><span id='topic+localKmultiEngine'></span><span id='topic+localpcfengine'></span><span id='topic+localpcfmatrix'></span><span id='topic+lookup2DkernelInfo'></span><span id='topic+makefvlabel'></span><span id='topic+maskLaslett'></span><span id='topic+match2DkernelName'></span><span id='topic+match.kernel'></span><span id='topic+mctestSigtraceEngine'></span><span id='topic+meanlistfv'></span><span id='topic+names+3C-.fv'></span><span id='topic+nncleanEngine'></span><span id='topic+pairs.listof'></span><span id='topic+pairs.solist'></span><span id='topic+pcf3engine'></span><span id='topic+pcfmulti.inhom'></span><span id='topic+plot.bw.frac'></span><span id='topic+plot.bw.optim'></span><span id='topic+plot.localpcfmatrix'></span><span id='topic+plot.plotpairsim'></span><span id='topic+plot.spatialcdf'></span><span id='topic+polyLaslett'></span><span id='topic+predict.exactppm'></span><span id='topic+prefixfv'></span><span id='topic+print.bw.frac'></span><span id='topic+print.bw.optim'></span><span id='topic+print.densityfun'></span><span id='topic+print.envelope'></span><span id='topic+print.exactppm'></span><span id='topic+print.fasp'></span><span id='topic+print.fv'></span><span id='topic+print.fvfun'></span><span id='topic+print.hasenvelope'></span><span id='topic+print.laslett'></span><span id='topic+print.localpcfmatrix'></span><span id='topic+print.plotpairsim'></span><span id='topic+print.quadrattest'></span><span id='topic+print.rat'></span><span id='topic+print.Smoothfun'></span><span id='topic+print.summary.bw.optim'></span><span id='topic+print.summary.ssf'></span><span id='topic+quadrat.testEngine'></span><span id='topic+ratfv'></span><span id='topic+rebadge.as.crossfun'></span><span id='topic+rebadge.as.dotfun'></span><span id='topic+rebadge.fv'></span><span id='topic+rebadgeLabels'></span><span id='topic+reconcile.fv'></span><span id='topic+RelevantDeviation'></span><span id='topic+rename.fv'></span><span id='topic+resolve.2D.kernel'></span><span id='topic+resolve.foxall.window'></span><span id='topic+resolve.lambda'></span><span id='topic+resolve.lambda.ppp'></span><span id='topic+resolve.lambdacross'></span><span id='topic+resolve.lambdacross.ppp'></span><span id='topic+resolve.reciplambda'></span><span id='topic+resolve.reciplambda.ppp'></span><span id='topic+resolveEinfo'></span><span id='topic+rhohatEngine'></span><span id='topic+rhohatCalc'></span><span id='topic+rmax.Rigid'></span><span id='topic+rmax.rule'></span><span id='topic+rocData'></span><span id='topic+rocModel'></span><span id='topic+roseContinuous'></span><span id='topic+scanmeasure'></span><span id='topic+scanmeasure.ppp'></span><span id='topic+scanmeasure.im'></span><span id='topic+scanBinomLRTS'></span><span id='topic+scanPoisLRTS'></span><span id='topic+second.moment.calc'></span><span id='topic+second.moment.engine'></span><span id='topic+sewpcf'></span><span id='topic+sewsmod'></span><span id='topic+shift.quadrattest'></span><span id='topic+simulrecipe'></span><span id='topic+StieltjesCalc'></span><span id='topic+StieltjesCalc.stepfun'></span><span id='topic+StieltjesCalc.fv'></span><span id='topic+Smooth.solist'></span><span id='topic+smoothcrossEngine'></span><span id='topic+smoothpointsEngine'></span><span id='topic+spatialCDFframe'></span><span id='topic+spatialCDFtest'></span><span id='topic+spatialCDFtestCalc'></span><span id='topic+spatialCovariateEvidence'></span><span id='topic+spatialCovariateEvidence.exactppm'></span><span id='topic+spatialCovariateEvidence.ppp'></span><span id='topic+sphere.volume'></span><span id='topic+summary.envelope'></span><span id='topic+summary.bw.optim'></span><span id='topic+tweak.fv.entry'></span><span id='topic+tweak.ratfv.entry'></span><span id='topic+twostage.test'></span><span id='topic+twostage.envelope'></span><span id='topic+updateData'></span><span id='topic+updateData.default'></span><span id='topic+validate2Dkernel'></span><span id='topic+validate.angles'></span><span id='topic+validate.weights'></span><span id='topic+vanilla.fv'></span><span id='topic+weightedclosepairs'></span><span id='topic+X2testEngine'></span>

<h3>Description</h3>

<p>Internal spatstat.explore functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'localpcfmatrix'
x[i, ...]
## S3 method for class 'rat'
x[...]
adjust.ratfv(f, columns, numfactor, denfactor)
ang2rad(ang, unit, start, clockwise)
## S3 method for class 'bw.optim'
as.data.frame(x, ...)
## S3 method for class 'fv'
as.data.frame(x, ...)
assemble.plot.objects(xlim, ylim, ..., lines, polygon)
bandwidth.is.infinite(sigma)
BartCalc(fY, fK)
bermantestCalc(fram, which, alternative, ...)
bermantestEngine(model, covariate, which, alternative, ...,
                 modelname, covname, dataname)
bind.ratfv(x, numerator, denominator, labl, desc, preferred,
           ratio, quotient)
bw.optim(cv, h, iopt, ..., cvname, hname, criterion,
         optimum, warnextreme, hargnames, yexp, unitname,
         template, exponent, hword)
calc.DR(COV, z, Dim)
calc.NNIR(COV, z, pos, Dim)
calc.SAVE(COV, z, Dim)
calc.SIR(COV, z)
calc.TSE(COV, z, pos, Dim1, Dim2)
censtimeCDFest(o, cc, d, breaks, ...,
     KM, RS, HAN, RAW, han.denom, tt, pmax, fname, fexpr)
check.testfun(f, f1, X)
circticks(R, at, unit, start, clockwise, labels)
clarkevansCalc(X, correction, clipregion, working)
## S3 method for class 'rat'
compatible(A, B, ...)
conform.ratfv(x)
CressieReadStatistic(OBS,EXP,lambda,normalise,named)
CressieReadSymbol(lambda)
CressieReadName(lambda)
cutoff2Dkernel(kernel, sigma, varcov, ..., scalekernel, cutoff, fatal)
CVforPCF(bw, stuff)
Deviation(x, ref, leaveout, n, xi)
densitycrossEngine(Xdata, Xquery, sigma, ...,
                    kernel, scalekernel,
                    weights, edge, varcov,
                    diggle, sorted, cutoff,
                    se, kerpow)
densitypointsEngine(x, sigma, ...,
                    kernel, scalekernel, kerpow,
                    weights, edge, varcov,
                    leaveoneout, diggle, sorted, spill, cutoff,
                    debug)
digestCovariates(..., W)
digital.volume(range, nval, vside)
## S3 method for class 'fasp'
dim(x)
## S3 method for class 'fasp'
dimnames(x)
## S3 replacement method for class 'fasp'
dimnames(x) &lt;- value
distributecbind(x)
ensure.listarg(x, n, singletypes, xtitle, things)
envelopeEngine(X, fun, simul,
           nsim, nrank, ..., funargs, funYargs,
           verbose, clipdata, 
           transform, global, ginterval, use.theory,
           alternative, scale, clamp,
           savefuns, savepatterns, saveresultof,
           weights,
           nsim2, VARIANCE, nSD,
           Yname,
           maxnerr, rejectNA, silent, maxerr.action,
           internal, cl,
           envir.user, expected.arg, do.pwrong,
           foreignclass, collectrubbish)
envelopeProgressData(X, fun, ..., exponent,
                     alternative, leaveout, scale, clamp,
                     normalize, deflate, rmin, 
                     save.envelope, savefuns, savepatterns)
envelopeTest(X, ..., exponent, alternative,
            rinterval, leaveout, scale, clamp, tie.rule,
            interpolate, save.interpolant,
            save.envelope, savefuns, savepatterns,
            Xname, badXfatal, verbose)
## S3 method for class 'hasenvelope'
envelope(Y, ..., Yname)
## S3 method for class 'matrix'
envelope(Y, ..., argvals, rvals,
  observed, theory, funX, nsim, nsim2, jsim, jsim.mean,
  type, alternative, scale, clamp, csr, use.theory, nrank, ginterval, nSD,
  savefuns, check, Yname, argname, arg.desc,
  do.pwrong, weights, precomputed, gaveup)
evaluateCovariate(covariate, locations, ...)
evaluateCovariateAtPixels(covariate, locations, ...,
                          types, eps, dimyx, rule.eps)
evaluateCovariateAtPoints(covariate, locations, ..., allow.column)
evaluate2Dkernel(kernel, x, y, sigma, varcov, ..., scalekernel)
ExpSmoothLog(X, ..., at, weights, se)
exactppm(X, baseline, ..., subset, eps, dimyx, rule.eps)
extractAtomicQtests(x)
fasp(fns, which, formulae, dataname, title, rowNames, colNames, checkfv)
f3engine(x, y, z, box, vside, range, nval, correction)
f3Cengine(x, y, z, box, vside, rmax, nrval)
findbestlegendpos(...)
findcbind(root, depth, maxdepth)
flatfname(x)
FormatFaspFormulae(f, argname)
fvexprmap(x)
fvlabels(x, expand=FALSE)
fvlabels(x) &lt;- value
fvlabelmap(x, dot=TRUE)
fvlegend(object, elang)
g3engine(x, y, z, box, rmax, nrval, correction)
g3Cengine(x, y, z, box, rmax, nrval)
getSumFun(abbreviation, classname, ismarked, fatal)
good.correction.K(X)
hasenvelope(X, E)
implemented.for.K(correction, windowtype, explicit)
is.atomicQtest(x)
## S3 method for class 'exactppm'
is.poisson(x)
is.scov(x)
## S3 method for class 'exactppm'
is.stationary(x)
k3engine(x, y, z, box, rmax, nrval, correction)
Kborder.engine(X, rmax, nr, correction, weights, ratio)
Knone.engine(X, rmax, nr, weights, ratio)
Krect.engine(X, rmax, nr, correction, weights,
             ratio, fname, use.integers)
Kount(dIJ, bI, b, breaks)
Kwtsum(dIJ, bI, wIJ, b, w, breaks, fatal)
km.rs.opt(o, cc, d, breaks, KM, RS)
localKengine(X, ..., wantL, lambda, rmax, correction, verbose, rvalue)
localKmultiEngine(X, from, to,
           lambdaFrom, lambdaTo, ..., rmax, wantL,
           correction, verbose, rvalue, sigma, varcov,
           lambdaX, update, leaveoneout,
           Iexplain, Jexplain, Ikey, Jkey)
localpcfengine(X, ..., delta, rmax, nr, stoyan, lambda, rvalue)
localpcfmatrix(X, i, ..., lambda, delta, rmax, nr, stoyan)
lookup2DkernelInfo(kernel)
makefvlabel(op, accent, fname, sub, argname)
maskLaslett(X, ..., eps, dimyx, xy, rule.eps, oldX, verbose, plotit)
match.kernel(kernel)
match2DkernelName(kernel)
mctestSigtraceEngine(R, devdata, devsim, ...,
     interpolate, confint, alpha, exponent, unitname)
meanlistfv(z, ...)
## S3 replacement method for class 'fv'
names(x) &lt;- value
nncleanEngine(kthNND, k, d, ..., tol, maxit,
              plothist, lineargs, verbose, Xname)
## S3 method for class 'listof'
pairs(..., plot=TRUE)
## S3 method for class 'solist'
pairs(..., plot=TRUE)
pcf3engine(x, y, z, box, rmax, nrval, correction, delta)
pcfmulti.inhom(X, I, J, lambdaI, lambdaJ, ...,
               lambdaX, r, breaks, kernel,
               bw, adjust.bw, stoyan, correction,
               sigma, adjust.sigma, varcov, update, leaveoneout, 
               Iname, Jname)
## S3 method for class 'bw.frac'
plot(x, ...)
## S3 method for class 'bw.optim'
plot(x, ..., showopt, optargs)
## S3 method for class 'localpcfmatrix'
plot(x, ...)
## S3 method for class 'plotpairsim'
plot(x, ...)
## S3 method for class 'spatialcdf'
plot(x, ..., xlab, ylab, do.points)
polyLaslett(X, ..., oldX, verbose, plotit)
## S3 method for class 'exactppm'
predict(object, locations, ..., eps, dimyx, rule.eps)
prefixfv(x, tagprefix, descprefix, lablprefix, whichtags)
## S3 method for class 'bw.frac'
print(x, ...)
## S3 method for class 'bw.optim'
print(x, ...)
## S3 method for class 'densityfun'
print(x, ...)
## S3 method for class 'envelope'
print(x, ...)
## S3 method for class 'exactppm'
print(x, ...)
## S3 method for class 'fasp'
print(x, ...)
## S3 method for class 'fv'
print(x, ..., tight)
## S3 method for class 'fvfun'
print(x, ...)
## S3 method for class 'hasenvelope'
print(x, ...)
## S3 method for class 'laslett'
print(x, ...)
## S3 method for class 'localpcfmatrix'
print(x, ...)
## S3 method for class 'plotpairsim'
print(x, ...)
## S3 method for class 'quadrattest'
print(x, ...)
## S3 method for class 'rat'
print(x, ...)
## S3 method for class 'Smoothfun'
print(x, ...)
## S3 method for class 'summary.bw.optim'
print(x, ..., digits)
## S3 method for class 'summary.ssf'
print(x, ...)
quadrat.testEngine(X, nx, ny, alternative, method, conditional, CR, 
     ..., nsim, Xcount, xbreaks, ybreaks, tess, fit, df.est, Xname, fitname)
ratfv(df, numer, denom, ..., ratio)
rebadge.as.crossfun(x, main, sub, i, j)
rebadge.as.dotfun(x, main, sub, i)
rebadge.fv(x, new.ylab, new.fname, tags, new.desc, new.labl, new.yexp,
           new.dotnames, new.preferred, new.formula, new.tags)
rebadgeLabels(x, new.fname)
reconcile.fv(...)
RelevantDeviation(x, alternative, clamp, scaling)
rename.fv(x, fname, ylab, yexp)
resolve.2D.kernel(...,
            sigma, varcov, x, mindist, adjust, bwfun, allow.zero)
resolve.foxall.window(X, Y, W, warn.trim)
resolve.lambda(X, lambda, ...)
## S3 method for class 'ppp'
resolve.lambda(X, lambda, ...,
               sigma, varcov, leaveoneout, update, check)
resolve.lambdacross(X, I, J, lambdaI, lambdaJ, ...)
## S3 method for class 'ppp'
resolve.lambdacross(X, I, J, lambdaI, lambdaJ, ...,
         lambdaX, sigma, varcov, leaveoneout, update, lambdaIJ,
         Iexplain, Jexplain)
resolve.reciplambda(X, lambda, reciplambda, ...)
## S3 method for class 'ppp'
resolve.reciplambda(X, lambda, reciplambda, ...,
                    sigma, varcov, leaveoneout, update, check)
resolveEinfo(x, what, fallback, warn, atomic)
rhohatEngine(model, covariate, reference, volume, ...,
               subset, weights, method, horvitz, smoother,
               resolution, spatCovarArgs,
               n, bw, adjust, from, to, 
               bwref, covname, covunits, confidence,
               breaks,
               modelcall, callstring)
rhohatCalc(ZX, Zvalues, lambda, denom, ...,
           weights, lambdaX,
           method, horvitz, smoother, do.CI, 
           n, bw, adjust, from, to, 
           bwref, covname, confidence, breaks, positiveCI, markovCI,
           covunits, modelcall, callstring, savestuff)
rmax.Rigid(X, g)
rmax.rule(fun, W, lambda)
rocData(covariate, nullmodel, ..., high, p)
rocModel(lambda, nullmodel, ..., high, p)
roseContinuous(ang, rad, unit, ...,
               start, clockwise, main, labels, at, do.plot)
scanmeasure(X, ...)
## S3 method for class 'ppp'
scanmeasure(X, r, ..., method) 
## S3 method for class 'im'
scanmeasure(X, r, ...)
scanPoisLRTS(nZ, nG, muZ, muG, alternative)
scanBinomLRTS(nZ, nG, muZ, muG, alternative)
second.moment.calc(x, sigma, edge, what, ...,
                   varcov, expand, obswin, npts, debug)
second.moment.engine(x, sigma, edge, what, ...,
      kernel, scalekernel, kerpow,
      obswin, varcov, npts, debug, fastgauss)
sewpcf(d, w, denargs, lambda2area, divisor)
sewsmod(d, ff, wt, Ef, rvals, method="smrep", ..., nwtsteps=500)
## S3 method for class 'quadrattest'
shift(X, ...)
simulrecipe(type, expr, envir, csr, pois, constraints)
StieltjesCalc(M, f, ...)
## S3 method for class 'stepfun'
StieltjesCalc(M, f, ...)
## S3 method for class 'fv'
StieltjesCalc(M, f, ...)
## S3 method for class 'solist'
Smooth(X, ...)
smoothcrossEngine(Xdata, Xquery, values, sigma, ...,
                    weights, varcov,
                    kernel, scalekernel, sorted, cutoff)
smoothpointsEngine(x, values, sigma, ...,
                   kernel, scalekernel,
                   weights, varcov, leaveoneout, sorted, cutoff, debug)
spatialCDFframe(model, covariate, ..., jitter, covariateAtPoints,
                make.quantile.function)
spatialCDFtest(model, covariate, test, ...,
         dimyx, eps, rule.eps, interpolate, jitter,
         nsim, verbose, modelname, covname, dataname)
spatialCDFtestCalc(fra, test, ..., details)
spatialCovariateEvidence(model, covariate, ...)
## S3 method for class 'exactppm'
spatialCovariateEvidence(model, covariate, ..., lambdatype,
          dimyx, eps, rule.eps, interpolate, jitter, jitterfactor,
          modelname, covname, dataname, subset, clip.predict) 
## S3 method for class 'ppp'
spatialCovariateEvidence(model, covariate, ..., lambdatype,
          dimyx, eps, rule.eps, interpolate, jitter, jitterfactor,
          modelname, covname, dataname, subset, clip.predict)
sphere.volume(range, nval = 10)
## S3 method for class 'bw.optim'
summary(object, ...)
## S3 method for class 'envelope'
summary(object,...)
tweak.fv.entry(x, current.tag, new.labl, new.desc, new.tag)
tweak.ratfv.entry(x, ...)
twostage.test(X, ..., exponent, nsim, nsimsub,
              alternative, reuse, leaveout, interpolate,
              savefuns, savepatterns, verbose, badXfatal, testblurb)
twostage.envelope(X, ..., nsim, nsimsub, nrank,
                  alternative, reuse, leaveout, interpolate,
                  savefuns, savepatterns, verbose, badXfatal, testlabel)
updateData(model, X, ...)
## Default S3 method:
updateData(model, X, ..., warn)
validate2Dkernel(kernel, fatal)
validate.angles(angles, unit, guess)
validate.weights(x, recip, how, allowzero, allowinf)
vanilla.fv(x)
weightedclosepairs(X, r, correction, what)
X2testEngine(OBS, EXP, ..., method, CR, df, nsim,
     conditional, alternative, testname, dataname)




</code></pre>


<h3>Details</h3>

<p>These internal <span class="pkg">spatstat.explore</span> functions should not be called
directly by the user. Their names and capabilities may change
without warning from one version of <span class="pkg">spatstat.explore</span> to the next.
</p>


<h3>Value</h3>

<p>The return values of these functions are not documented,
and may change without warning.
</p>

<hr>
<h2 id='spatstat.explore-package'>The spatstat.explore Package</h2><span id='topic+spatstat.explore-package'></span><span id='topic+spatstat.explore'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.explore</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the core functionality
for statistical analysis and modelling of spatial data.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span class="rlang"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.explore</span> contains the 
user-level functions
that perform exploratory data analysis and
nonparametric data analysis of spatial data.
</p>
<p>(The main exception is that functions for linear networks
are in the separate sub-package <span class="pkg">spatstat.linnet</span>.)
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the functionality
for exploratory data analysis and nonparametric analysis of spatial data.
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the functionality
for statistical modelling, model-fitting, formal statistical
inference  and informal model diagnostics.
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li></ul>

<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
</p>
<p>For an overview of all the functions available in
the sub-packages of <span class="pkg">spatstat</span>,
see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package.
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li></ul>

<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Overview of Functionality in <span class="pkg">spatstat.explore</span></h3>

<p>The <span class="pkg">spatstat</span> family of packages
is designed to support a complete statistical analysis
of spatial data. It supports
</p>

<ul>
<li><p> creation, manipulation and plotting of point patterns;
</p>
</li>
<li><p> exploratory data analysis;
</p>
</li>
<li><p> spatial random sampling;
</p>
</li>
<li><p> simulation of point process models;
</p>
</li>
<li><p> parametric model-fitting;
</p>
</li>
<li><p> non-parametric smoothing and regression;
</p>
</li>
<li><p> formal inference (hypothesis tests, confidence intervals);
</p>
</li>
<li><p> model diagnostics.
</p>
</li></ul>

<p>For an overview, see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package. 
</p>
<p>Following is a list of the functionality provided in the
<span class="pkg">spatstat.explore</span> package only.
</p>
<p><b>To simulate a random point pattern:</b>
</p>
<p>Functions for generating random point patterns
are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p><b>To interrogate a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+density.ppp">density.ppp</a></code> </td><td style="text-align: left;">
	kernel estimation of point pattern intensity</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code> </td><td style="text-align: left;">
	diffusion kernel estimation of point pattern intensity</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> </td><td style="text-align: left;">
	kernel smoothing of marks of point pattern</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+sharpen.ppp">sharpen.ppp</a></code> </td><td style="text-align: left;">
	data sharpening</td>
</tr>
<tr>
 <td style="text-align: left;">
      </td>
</tr>

</table>

<p><b>Manipulation of pixel images:</b>
</p>
<p>An object of class <code>"im"</code> represents a pixel image.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+blur">blur</a></code> </td><td style="text-align: left;"> apply Gaussian blur to image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Smooth.im">Smooth.im</a></code> </td><td style="text-align: left;"> apply Gaussian blur to image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+transect.im">transect.im</a></code> </td><td style="text-align: left;"> line transect of image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="spatstat.geom.html#topic+pixelcentres">pixelcentres</a></code> </td><td style="text-align: left;"> extract centres of pixels </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="spatstat.random.html#topic+rnoise">rnoise</a></code> </td><td style="text-align: left;"> random pixel noise
     </td>
</tr>

</table>

<p><b>Line segment patterns</b>
</p>
<p>An object of class <code>"psp"</code> represents a pattern of straight line
segments.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+density.psp">density.psp</a></code> </td><td style="text-align: left;"> kernel smoothing of line segments</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+rpoisline">rpoisline</a></code> </td><td style="text-align: left;"> generate a realisation of the
      Poisson line process inside a window
    </td>
</tr>

</table>

<p><b>Tessellations</b>
</p>
<p>An object of class <code>"tess"</code> represents a tessellation.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code> </td><td style="text-align: left;"> generate tessellation using Poisson line
      process 
    </td>
</tr>

</table>

<p><b>Three-dimensional point patterns</b>
</p>
<p>An object of class <code>"pp3"</code> represents a three-dimensional
point pattern in a rectangular box. The box is represented by
an object of class <code>"box3"</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+runifpoint3">runifpoint3</a></code> </td><td style="text-align: left;"> generate uniform random points in 3-D </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+rpoispp3">rpoispp3</a></code> </td><td style="text-align: left;"> generate Poisson random points in 3-D </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+envelope.pp3">envelope.pp3</a></code> </td><td style="text-align: left;"> generate simulation envelopes for
      3-D pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Multi-dimensional space-time point patterns</b>
</p>
<p>An object of class <code>"ppx"</code> represents a 
point pattern in multi-dimensional space and/or time.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+runifpointx">runifpointx</a></code> </td><td style="text-align: left;"> generate uniform random points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.random.html#topic+rpoisppx">rpoisppx</a></code> </td><td style="text-align: left;"> generate Poisson random points 
    </td>
</tr>

</table>

<p><b>Classical exploratory tools:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clarkevans">clarkevans</a></code> </td><td style="text-align: left;"> Clark and Evans aggregation index </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fryplot">fryplot</a></code> </td><td style="text-align: left;"> Fry plot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+miplot">miplot</a></code> </td><td style="text-align: left;"> Morisita Index plot
  </td>
</tr>

</table>

<p><b>Smoothing:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density.ppp">density.ppp</a></code> </td><td style="text-align: left;"> kernel smoothed density/intensity</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+relrisk">relrisk</a></code> </td><td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> </td><td style="text-align: left;"> spatial interpolation of marks  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.diggle">bw.diggle</a></code> </td><td style="text-align: left;"> cross-validated bandwidth selection
                               for <code><a href="#topic+density.ppp">density.ppp</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.ppl">bw.ppl</a></code> </td><td style="text-align: left;"> likelihood cross-validated bandwidth selection
                               for <code><a href="#topic+density.ppp">density.ppp</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.CvL">bw.CvL</a></code> </td><td style="text-align: left;"> Cronie-Van Lieshout bandwidth selection
                                for density estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.scott">bw.scott</a></code> </td><td style="text-align: left;"> Scott's rule of thumb 
                                for density estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.abram">bw.abram</a></code> </td><td style="text-align: left;"> Abramson's rule for adaptive bandwidths</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.relrisk">bw.relrisk</a></code> </td><td style="text-align: left;"> cross-validated bandwidth selection
                               for <code><a href="#topic+relrisk">relrisk</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.smoothppp">bw.smoothppp</a></code> </td><td style="text-align: left;"> cross-validated bandwidth selection
                               for <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.frac">bw.frac</a></code> </td><td style="text-align: left;"> bandwidth selection using window geometry</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.stoyan">bw.stoyan</a></code> </td><td style="text-align: left;"> Stoyan's rule of thumb for bandwidth
                               for <code><a href="#topic+pcf">pcf</a></code>
  </td>
</tr>

</table>

<p><b>Modern exploratory tools:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clusterset">clusterset</a></code> </td><td style="text-align: left;"> Allard-Fraley feature detection  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnclean">nnclean</a></code> </td><td style="text-align: left;"> Byers-Raftery feature detection  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sharpen.ppp">sharpen.ppp</a></code> </td><td style="text-align: left;"> Choi-Hall data sharpening </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rhohat">rhohat</a></code> </td><td style="text-align: left;"> Kernel estimate of covariate effect</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rho2hat">rho2hat</a></code> </td><td style="text-align: left;"> Kernel estimate of effect of two covariates</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+spatialcdf">spatialcdf</a></code> </td><td style="text-align: left;"> Spatial cumulative distribution function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+roc">roc</a></code> </td><td style="text-align: left;"> Receiver operating characteristic curve
  </td>
</tr>

</table>

<p><b>Summary statistics for a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Fest">Fest</a></code> </td><td style="text-align: left;"> empty space function <code class="reqn">F</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gest">Gest</a></code> </td><td style="text-align: left;"> nearest neighbour distribution function <code class="reqn">G</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Jest">Jest</a></code> </td><td style="text-align: left;"> <code class="reqn">J</code>-function <code class="reqn">J = (1-G)/(1-F)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kest">Kest</a></code> </td><td style="text-align: left;"> Ripley's <code class="reqn">K</code>-function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lest">Lest</a></code> </td><td style="text-align: left;"> Besag <code class="reqn">L</code>-function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Tstat">Tstat</a></code> </td><td style="text-align: left;"> Third order <code class="reqn">T</code>-function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+allstats">allstats</a></code> </td><td style="text-align: left;"> all four functions <code class="reqn">F</code>, <code class="reqn">G</code>, <code class="reqn">J</code>, <code class="reqn">K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcf">pcf</a></code> </td><td style="text-align: left;"> 	pair correlation function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kinhom">Kinhom</a></code> </td><td style="text-align: left;"> <code class="reqn">K</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Linhom">Linhom</a></code> </td><td style="text-align: left;"> <code class="reqn">L</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfinhom">pcfinhom</a></code> </td><td style="text-align: left;"> pair correlation for inhomogeneous patterns</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Finhom">Finhom</a></code> </td><td style="text-align: left;"> <code class="reqn">F</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Ginhom">Ginhom</a></code> </td><td style="text-align: left;"> <code class="reqn">G</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Jinhom">Jinhom</a></code> </td><td style="text-align: left;"> <code class="reqn">J</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localL">localL</a></code> </td><td style="text-align: left;"> Getis-Franklin neighbourhood density function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localK">localK</a></code> </td><td style="text-align: left;"> neighbourhood K-function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localpcf">localpcf</a></code> </td><td style="text-align: left;"> local pair correlation function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localKinhom">localKinhom</a></code> </td><td style="text-align: left;"> local <code class="reqn">K</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localLinhom">localLinhom</a></code> </td><td style="text-align: left;"> local <code class="reqn">L</code> for inhomogeneous point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localpcfinhom">localpcfinhom</a></code> </td><td style="text-align: left;"> local pair correlation for inhomogeneous patterns</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Ksector">Ksector</a></code> </td><td style="text-align: left;"> Directional <code class="reqn">K</code>-function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kscaled">Kscaled</a></code> </td><td style="text-align: left;"> locally scaled <code class="reqn">K</code>-function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kest.fft">Kest.fft</a></code> </td><td style="text-align: left;"> fast <code class="reqn">K</code>-function using FFT for large datasets </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kmeasure">Kmeasure</a></code> </td><td style="text-align: left;"> reduced second moment measure </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope">envelope</a></code> </td><td style="text-align: left;"> simulation envelopes for a summary
    function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+varblock">varblock</a></code> </td><td style="text-align: left;"> variances and confidence intervals</td>
</tr>
<tr>
 <td style="text-align: left;">
                   </td><td style="text-align: left;"> for a summary function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lohboot">lohboot</a></code> </td><td style="text-align: left;"> bootstrap for a summary function 
  </td>
</tr>

</table>

<p>Related facilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.fv">plot.fv</a></code> </td><td style="text-align: left;"> plot a summary function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+eval.fv">eval.fv</a></code> </td><td style="text-align: left;"> evaluate any expression involving
    summary functions</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+harmonise.fv">harmonise.fv</a></code> </td><td style="text-align: left;"> make functions compatible </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+eval.fasp">eval.fasp</a></code> </td><td style="text-align: left;"> evaluate any expression involving
    an array of functions</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+with.fv">with.fv</a></code> </td><td style="text-align: left;"> evaluate an expression for a 
    summary function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Smooth.fv">Smooth.fv</a></code> </td><td style="text-align: left;"> apply smoothing to a summary function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+deriv.fv">deriv.fv</a></code> </td><td style="text-align: left;"> calculate derivative of a summary function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pool.fv">pool.fv</a></code> </td><td style="text-align: left;"> pool several estimates of a summary function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density.ppp">density.ppp</a></code> </td><td style="text-align: left;"> kernel smoothed density</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityHeat.ppp">densityHeat.ppp</a></code> </td><td style="text-align: left;"> diffusion kernel smoothed density</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Smooth.ppp">Smooth.ppp</a></code> </td><td style="text-align: left;"> spatial interpolation of marks  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+relrisk">relrisk</a></code> </td><td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sharpen.ppp">sharpen.ppp</a></code> </td><td style="text-align: left;"> data sharpening  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rknn">rknn</a></code> </td><td style="text-align: left;"> theoretical distribution of nearest
    neighbour distance
 </td>
</tr>

</table>

<p><b>Summary statistics for a multitype point pattern:</b>
A multitype point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> such that <code>marks(X)</code> is a factor. 
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+relrisk">relrisk</a></code> </td><td style="text-align: left;"> kernel estimation of relative risk  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+scan.test">scan.test</a></code> </td><td style="text-align: left;"> spatial scan test of elevated risk  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gcross">Gcross</a>,<a href="#topic+Gdot">Gdot</a>,<a href="#topic+Gmulti">Gmulti</a></code> </td><td style="text-align: left;">
    multitype nearest neighbour distributions 
    <code class="reqn">G_{ij}, G_{i\bullet}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kcross">Kcross</a>,<a href="#topic+Kdot">Kdot</a>, <a href="#topic+Kmulti">Kmulti</a></code> </td><td style="text-align: left;">
    multitype <code class="reqn">K</code>-functions 
    <code class="reqn">K_{ij}, K_{i\bullet}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lcross">Lcross</a>,<a href="#topic+Ldot">Ldot</a></code> </td><td style="text-align: left;">
    multitype <code class="reqn">L</code>-functions 
    <code class="reqn">L_{ij}, L_{i\bullet}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Jcross">Jcross</a>,<a href="#topic+Jdot">Jdot</a>,<a href="#topic+Jmulti">Jmulti</a></code> </td><td style="text-align: left;">
    multitype <code class="reqn">J</code>-functions
    <code class="reqn">J_{ij}, J_{i\bullet}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfcross">pcfcross</a></code> </td><td style="text-align: left;">
    multitype pair correlation function <code class="reqn">g_{ij}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfdot">pcfdot</a></code> </td><td style="text-align: left;">
    multitype pair correlation function <code class="reqn">g_{i\bullet}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfmulti">pcfmulti</a></code> </td><td style="text-align: left;">
    general pair correlation function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markconnect">markconnect</a></code> </td><td style="text-align: left;">
    marked connection function <code class="reqn">p_{ij}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+alltypes">alltypes</a></code> </td><td style="text-align: left;">  estimates of the above
    for all <code class="reqn">i,j</code> pairs </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Iest">Iest</a></code> </td><td style="text-align: left;">  multitype <code class="reqn">I</code>-function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kcross.inhom">Kcross.inhom</a>,<a href="#topic+Kdot.inhom">Kdot.inhom</a></code> </td><td style="text-align: left;">
    inhomogeneous counterparts of <code>Kcross</code>, <code>Kdot</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Lcross.inhom">Lcross.inhom</a>,<a href="#topic+Ldot.inhom">Ldot.inhom</a></code> </td><td style="text-align: left;">
    inhomogeneous counterparts of <code>Lcross</code>, <code>Ldot</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfcross.inhom">pcfcross.inhom</a>,<a href="#topic+pcfdot.inhom">pcfdot.inhom</a></code> </td><td style="text-align: left;">
    inhomogeneous counterparts of <code>pcfcross</code>, <code>pcfdot</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localKcross">localKcross</a>,<a href="#topic+localKdot">localKdot</a></code> </td><td style="text-align: left;">
    local counterparts of <code>Kcross</code>, <code>Kdot</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localLcross">localLcross</a>,<a href="#topic+localLdot">localLdot</a></code> </td><td style="text-align: left;">
    local counterparts of <code>Lcross</code>, <code>Ldot</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localKcross.inhom">localKcross.inhom</a>,<a href="#topic+localLcross.inhom">localLcross.inhom</a></code> </td><td style="text-align: left;">
    local counterparts of <code>Kcross.inhom</code>, <code>Lcross.inhom</code> 
  </td>
</tr>

</table>

<p><b>Summary statistics for a marked point pattern:</b>
A marked point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> with a component <code>X$marks</code>.
The entries in the vector <code>X$marks</code> may be numeric, complex,
string or any other atomic type. For numeric marks, there are the
following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markmean">markmean</a></code> </td><td style="text-align: left;"> smoothed local average of marks </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markvar">markvar</a></code> </td><td style="text-align: left;"> smoothed local variance of marks </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markcorr">markcorr</a></code> </td><td style="text-align: left;"> mark correlation function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markcrosscorr">markcrosscorr</a></code> </td><td style="text-align: left;"> mark cross-correlation function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markvario">markvario</a></code> </td><td style="text-align: left;"> mark variogram </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markmarkscatter">markmarkscatter</a></code> </td><td style="text-align: left;"> mark-mark scatterplot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kmark">Kmark</a></code> </td><td style="text-align: left;"> mark-weighted <code class="reqn">K</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Emark">Emark</a></code> </td><td style="text-align: left;"> mark independence diagnostic <code class="reqn">E(r)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Vmark">Vmark</a></code> </td><td style="text-align: left;"> mark independence diagnostic <code class="reqn">V(r)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnmean">nnmean</a></code> </td><td style="text-align: left;"> nearest neighbour mean index </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnvario">nnvario</a></code> </td><td style="text-align: left;"> nearest neighbour mark variance index 
  </td>
</tr>

</table>

<p>For marks of any type, there are the following:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gmulti">Gmulti</a></code> </td><td style="text-align: left;"> multitype nearest neighbour distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kmulti">Kmulti</a></code> </td><td style="text-align: left;"> multitype <code class="reqn">K</code>-function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Jmulti">Jmulti</a></code> </td><td style="text-align: left;"> multitype <code class="reqn">J</code>-function 
  </td>
</tr>

</table>

<p>Alternatively use <code><a href="spatstat.geom.html#topic+cut.ppp">cut.ppp</a></code> to convert a marked point pattern
to a multitype point pattern.
</p>
<p><b>Programming tools:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+marktable">marktable</a></code> </td><td style="text-align: left;"> tabulate the marks of neighbours
    in a point pattern 
  </td>
</tr>

</table>

<p><b>Summary statistics for a three-dimensional point pattern:</b>
</p>
<p>These are for 3-dimensional point pattern objects (class <code>pp3</code>).
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+F3est">F3est</a></code> </td><td style="text-align: left;"> empty space function <code class="reqn">F</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+G3est">G3est</a></code> </td><td style="text-align: left;"> nearest neighbour function <code class="reqn">G</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+K3est">K3est</a></code> </td><td style="text-align: left;"> <code class="reqn">K</code>-function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcf3est">pcf3est</a></code> </td><td style="text-align: left;"> pair correlation function
  </td>
</tr>

</table>

<p>Related facilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope.pp3">envelope.pp3</a></code> </td><td style="text-align: left;"> simulation envelopes 
  </td>
</tr>

</table>

<p><b>Summary statistics for random sets:</b>
</p>
<p>These work for point patterns (class <code>ppp</code>),
line segment patterns (class <code>psp</code>)
or windows (class <code>owin</code>).
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Hest">Hest</a></code> </td><td style="text-align: left;"> spherical contact distribution <code class="reqn">H</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gfox">Gfox</a></code> </td><td style="text-align: left;"> Foxall <code class="reqn">G</code>-function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Jfox">Jfox</a></code> </td><td style="text-align: left;"> Foxall <code class="reqn">J</code>-function
  </td>
</tr>

</table>

<p><b>Model fitting</b>
</p>
<p>Functions for fitting point process models
are now contained in the <span class="pkg">spatstat.model</span> package.
</p>
<p><b>Simulation</b>
</p>
<p>There are many ways to generate a random point pattern,
line segment pattern, pixel image or tessellation
in <span class="pkg">spatstat</span>. 
</p>
<p><b>Random point patterns:</b>
Functions for random generation are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p>See also <code><a href="#topic+varblock">varblock</a></code> for estimating the variance
of a summary statistic by block resampling, and
<code><a href="#topic+lohboot">lohboot</a></code> for another bootstrap technique.
</p>
<p><b>Fitted point process models:</b>
</p>
<p>If you have fitted a point process model to a point pattern dataset,
the fitted model can be simulated.
</p>
<p>Methods for simulating a fitted model are now
contained in the <span class="pkg">spatstat.model</span> package.
</p>
<p><b>Other random patterns:</b>
Functions for random generation are now contained in the
<span class="pkg">spatstat.random</span> package.
</p>
<p><b>Simulation-based inference</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope">envelope</a></code> </td><td style="text-align: left;"> critical envelope for Monte Carlo
    test of goodness-of-fit </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bits.envelope">bits.envelope</a></code> </td><td style="text-align: left;"> critical envelope for balanced
    two-stage Monte Carlo test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.model.html#topic+qqplot.ppm">qqplot.ppm</a></code> </td><td style="text-align: left;"> diagnostic plot for interpoint
    interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+scan.test">scan.test</a></code> </td><td style="text-align: left;"> spatial scan statistic/test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+studpermu.test">studpermu.test</a></code> </td><td style="text-align: left;"> studentised permutation test</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+segregation.test">segregation.test</a></code> </td><td style="text-align: left;"> test of segregation of types 
  </td>
</tr>

</table>

<p><b>Hypothesis tests:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quadrat.test">quadrat.test</a></code> </td><td style="text-align: left;"> <code class="reqn">\chi^2</code> goodness-of-fit
    test on quadrat counts </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clarkevans.test">clarkevans.test</a></code> </td><td style="text-align: left;"> Clark and Evans test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cdf.test">cdf.test</a></code> </td><td style="text-align: left;"> Spatial distribution goodness-of-fit test</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+berman.test">berman.test</a></code> </td><td style="text-align: left;"> Berman's goodness-of-fit tests</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope">envelope</a></code> </td><td style="text-align: left;"> critical envelope for Monte Carlo
    test of goodness-of-fit </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+scan.test">scan.test</a></code> </td><td style="text-align: left;"> spatial scan statistic/test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dclf.test">dclf.test</a></code> </td><td style="text-align: left;"> Diggle-Cressie-Loosmore-Ford test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mad.test">mad.test</a></code> </td><td style="text-align: left;"> Mean Absolute Deviation test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.model.html#topic+anova.ppm">anova.ppm</a></code> </td><td style="text-align: left;"> Analysis of Deviance for
    point process models 
  </td>
</tr>

</table>

<p><b>More recently-developed tests:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dg.test">dg.test</a></code> </td><td style="text-align: left;"> Dao-Genton test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bits.test">bits.test</a></code> </td><td style="text-align: left;"> Balanced independent two-stage test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dclf.progress">dclf.progress</a></code> </td><td style="text-align: left;"> Progress plot for DCLF test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mad.progress">mad.progress</a></code> </td><td style="text-align: left;"> Progress plot for MAD test </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><b>Model diagnostics:</b>
</p>
<p>Classical measures of model sensitivity such as leverage and
influence, and classical model diagnostic tools such as 
residuals, partial residuals, and effect estimates,
have been adapted to point process models. 
These capabilities are now provided in the <span class="pkg">spatstat.model</span> package.
</p>
<p><b>Resampling and randomisation procedures</b>
</p>
<p>You can build your own tests based on randomisation
and resampling using the following capabilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+quadratresample">quadratresample</a></code> </td><td style="text-align: left;"> block resampling </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rshift">rshift</a></code> </td><td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning  
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ottmar Cronie,
Tilman Davies,
Julian Gilbey, 
Yongtao Guan,
Ute Hahn,
Kassel Hingee,
Abdollah Jalilian,
Marie-Colette van Lieshout,
Greg McSwiggan,
Tuomas Rajala,
Suman Rakshit,
Dominic Schuhmacher,
Rasmus Waagepetersen
and
Hangsheng Wang
made substantial contributions of code.
</p>
<p>For comments, corrections, bug alerts and suggestions, we thank
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Ben Madin,
Martin Maechler,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='ssf'>
Spatially Sampled Function
</h2><span id='topic+ssf'></span>

<h3>Description</h3>

<p>Create an object that represents a spatial function
which has been evaluated or sampled at an irregular set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ssf(loc, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssf_+3A_loc">loc</code></td>
<td>

<p>The spatial locations at which the function has been evaluated.
A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="ssf_+3A_val">val</code></td>
<td>

<p>The function values at these locations.
A numeric vector with one entry for each point of <code>loc</code>,
or a data frame with one row for each point of <code>loc</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ssf"</code> represents a real-valued or
vector-valued function that has been evaluated or sampled at an
irregular set of points. An example would be a spatial covariate
that has only been measured at certain locations.
</p>
<p>An object of this class also inherits the class <code>"ppp"</code>,
and is essentially the same as a marked point pattern, except
for the class membership which enables it to be 
handled in a different way.
</p>
<p>There are methods for <code>plot</code>, <code>print</code> etc; see
<code><a href="#topic+plot.ssf">plot.ssf</a></code> and <code><a href="#topic+methods.ssf">methods.ssf</a></code>.
</p>
<p>Use <code><a href="spatstat.geom.html#topic+unmark">unmark</a></code> to extract only the point
locations, and <code><a href="#topic+marks.ssf">marks.ssf</a></code> to extract only the function values.
</p>


<h3>Value</h3>

<p>Object of class <code>"ssf"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ssf">plot.ssf</a></code>, 
<code><a href="#topic+methods.ssf">methods.ssf</a></code>, 
<code><a href="#topic+Smooth.ssf">Smooth.ssf</a></code>, 
<code><a href="#topic+with.ssf">with.ssf</a></code>,
<code><a href="#topic++5B.ssf">[.ssf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ssf(cells, nndist(cells, k=1:3))
</code></pre>

<hr>
<h2 id='stieltjes'>Compute Integral of Function Against Cumulative Distribution</h2><span id='topic+stieltjes'></span>

<h3>Description</h3>

<p>Computes the Stieltjes integral 
of a function <code class="reqn">f</code> with respect to a function <code class="reqn">M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stieltjes(f, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stieltjes_+3A_f">f</code></td>
<td>

<p>The integrand. A function in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="stieltjes_+3A_m">M</code></td>
<td>

<p>The cumulative function against which <code>f</code> will be
integrated. An object of class <code>"fv"</code> or <code>"stepfun"</code>.
</p>
</td></tr>
<tr><td><code id="stieltjes_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the Stieltjes integral
</p>
<p style="text-align: center;"><code class="reqn">I = \int f(x) dM(x)</code>
</p>

<p>of a real-valued function <code class="reqn">f(x)</code>
with respect to a nondecreasing function <code class="reqn">M(x)</code>.
</p>
<p>One common use of the Stieltjes integral is
to find the mean value of a random variable from its
cumulative distribution function <code class="reqn">F(x)</code>. The mean value is
the Stieltjes integral of <code class="reqn">f(x)=x</code> with respect to <code class="reqn">F(x)</code>.
</p>
<p>The argument <code>f</code> should be a <code>function</code> in the <span class="rlang"><b>R</b></span> language.
It should accept a numeric vector argument <code>x</code> and should return
a numeric vector of the same length.
</p>
<p>The argument <code>M</code> should be either a step function
(object of class <code>"stepfun"</code>) or a function value table
(object of class <code>"fv"</code> 
).
Objects of class <code>"stepfun"</code> are returned by
<code><a href="stats.html#topic+ecdf">ecdf</a></code>, <code>ewcdf</code>,

and other utilities.


</p>


<h3>Value</h3>

<p>A list containing the value of the Stieltjes integral
computed using each of the versions of the function <code>M</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(100)
  w &lt;- runif(100)
  H &lt;- ewcdf(x, w)
  stieltjes(function(x) { x^2 }, H)











</code></pre>

<hr>
<h2 id='stienen'>
Stienen Diagram
</h2><span id='topic+stienen'></span><span id='topic+stienenSet'></span>

<h3>Description</h3>

<p>Draw the Stienen diagram of a point pattern,
or compute the region covered by the Stienen diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stienen(X, ..., bg = "grey", border = list(bg = NULL))
stienenSet(X, edge=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stienen_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="stienen_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>plot.ppp</code>
to control the plot.
</p>
</td></tr>
<tr><td><code id="stienen_+3A_bg">bg</code></td>
<td>

<p>Fill colour for circles.
</p>
</td></tr>
<tr><td><code id="stienen_+3A_border">border</code></td>
<td>

<p>Either a list of arguments passed to <code>plot.ppp</code>
to control the display of circles at the border of the diagram,
or the value <code>FALSE</code>
indicating that the border circles should not be plotted.
</p>
</td></tr>
<tr><td><code id="stienen_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to include the circles at the
border of the diagram.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stienen diagram of a point pattern (Stienen, 1982)
is formed by drawing a circle around each point of the pattern,
with diameter equal to the nearest-neighbour distance for that point.
These circles do not overlap. If two points are nearest neighbours
of each other, then the corresponding circles touch.
</p>
<p><code>stienenSet(X)</code> computes the union of these circles and
returns it as a window (object of class <code>"owin"</code>).
</p>
<p><code>stienen(X)</code> generates a plot of the Stienen diagram of
the point pattern <code>X</code>. By default, circles are shaded in grey
if they lie inside the window of <code>X</code>, and are not shaded
otherwise.
</p>


<h3>Value</h3>

<p>The plotting function <code>stienen</code> returns <code>NULL</code>.
</p>
<p>The return value of <code>stienenSet</code> is a window (object of class
<code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Stienen, H. (1982)
<em>Die Vergroeberung von Karbiden in reinen Eisen-Kohlenstoff
Staehlen</em>.
Dissertation, RWTH Aachen.
</p>


<h3>See Also</h3>

<p><code>nndist</code>,
<code>plot.ppp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- stienenSet(cells)
  stienen(redwood)
  stienen(redwood, border=list(bg=NULL, lwd=2, cols="red"))
</code></pre>

<hr>
<h2 id='studpermu.test'>
Studentised Permutation Test
</h2><span id='topic+studpermu.test'></span>

<h3>Description</h3>

<p>Perform a studentised permutation test for a difference between
groups of point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   studpermu.test(X, formula, summaryfunction = Kest,
       ..., rinterval = NULL, nperm = 999,
        use.Tbar = FALSE, minpoints = 20, rsteps = 128,
        r = NULL, arguments.in.data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="studpermu.test_+3A_x">X</code></td>
<td>

<p>Data. Either a <code>hyperframe</code> or a list of lists of point patterns.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_formula">formula</code></td>
<td>

<p>Formula describing the grouping, when <code>X</code> is a hyperframe.
The left side of the formula identifies which column of <code>X</code>
contains the point patterns.
The right side identifies the grouping factor. 
If the formula is missing, the grouping variable is taken to be the
first column of <code>X</code> that contains a factor, and the point
patterns are taken from the first column that contains point patterns.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_summaryfunction">summaryfunction</code></td>
<td>

<p>Summary function applicable to point patterns.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>summaryfunction</code>.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_rinterval">rinterval</code></td>
<td>

<p>Interval of distance values <code class="reqn">r</code> over which the
summary function should be evaluated and over which the test
statistic will be integrated. If <code>NULL</code>, the default
range of the summary statistic is used (taking the intersection
of these ranges over all patterns).
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_nperm">nperm</code></td>
<td>

<p>Number of random permutations for the test.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_use.tbar">use.Tbar</code></td>
<td>

<p>Logical value indicating choice of test statistic.
If <code>TRUE</code>, use the alternative test statistic,
which is appropriate for summary functions with
roughly constant variance, such as <code class="reqn">K(r)/r</code> or <code class="reqn">L(r)</code>.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_minpoints">minpoints</code></td>
<td>

<p>Minimum permissible number of points in a point pattern
for inclusion in the test calculation.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_rsteps">rsteps</code></td>
<td>

<p>Number of discretisation steps in the <code>rinterval</code>.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_r">r</code></td>
<td>

<p>Optional vector of distance values as the argument for
<code>summaryfunction</code>. Should not usually be given.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="studpermu.test_+3A_arguments.in.data">arguments.in.data</code></td>
<td>

<p>Logical. If <code>TRUE</code>, individual extra arguments to
<code>summaryfunction</code> will be taken from <code>X</code>
(which must be a hyperframe). This assumes that 
the first argument of <code>summaryfunction</code> is the
point pattern dataset.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the studentized permutation test
of Hahn (2012) for a difference between groups of point patterns.
</p>
<p>The first argument <code>X</code> should be either
</p>

<dl>
<dt>a list of lists of point patterns.</dt><dd>
<p>Each element of <code>X</code> will be interpreted as a group of
point patterns, assumed to be replicates of the same point process.
</p>
</dd>
<dt>a hyperframe:</dt><dd>
<p>One column of the hyperframe should contain point patterns,
and another column should contain a factor indicating the
grouping. The argument <code>formula</code> should be a formula in the
<span class="rlang"><b>R</b></span> language specifying the grouping: it should be of the form
<code>P ~ G</code> where <code>P</code> is the name of the column of point
patterns, and <code>G</code> is the name of the factor.
</p>
</dd>
</dl>

<p>A group needs to contain at least two point patterns with at least
<code>minpoints</code> points in each pattern.
</p>
<p>The function returns an object of class <code>"htest"</code>
and <code>"studpermutest"</code> that can be printed and plotted.
The printout shows the test result and <code class="reqn">p</code>-value.
The plot shows the summary functions for the
groups (and the group means if requested).
</p>


<h3>Value</h3>

<p>Object of class <code>"studpermutest"</code>.
</p>


<h3>Author(s)</h3>

<p>Ute Hahn.
</p>
<p>Modified for <code>spatstat</code> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Hahn, U. (2012) 
A studentized permutation test for the comparison of
spatial point patterns.
<em>Journal of the American Statistical Association</em>
<b>107</b> (498), 754&ndash;764.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.studpermutest">plot.studpermutest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  np &lt;- if(interactive()) 99 else 19
  testpyramidal &lt;- studpermu.test(pyramidal, Neurons ~ group, nperm=np)
  testpyramidal
</code></pre>

<hr>
<h2 id='subspaceDistance'>
Distance Between Linear Spaces
</h2><span id='topic+subspaceDistance'></span>

<h3>Description</h3>

<p>Evaluate the distance between two linear subspaces
using the measure proposed by Li, Zha and Chiaromonte (2005). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subspaceDistance(B0, B1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subspaceDistance_+3A_b0">B0</code></td>
<td>

<p>Matrix whose columns are a basis for the first subspace.
</p>
</td></tr>
<tr><td><code id="subspaceDistance_+3A_b1">B1</code></td>
<td>

<p>Matrix whose columns are a basis for the second subspace.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm calculates the maximum absolute value of the
eigenvalues of <code class="reqn">P1-P0</code> where <code class="reqn">P0,P1</code> are the projection
matrices onto the subspaces generated by <code>B0,B1</code>.
This measure of distance was proposed by Li, Zha and Chiaromonte
(2005). See also Xia (2007).
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Matlab original by Yongtao Guan,
translated to <span class="rlang"><b>R</b></span> by Suman Rakshit.
</p>


<h3>References</h3>

<p>Guan, Y. and Wang, H. (2010)
Sufficient dimension reduction for spatial point
processes directed by Gaussian random fields.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 367&ndash;387.
</p>
<p>Li, B., Zha, H. and Chiaromonte, F. (2005) Contour regression: a
general approach to dimension reduction. 
<em>Annals of Statistics</em> <b>33</b>, 1580&ndash;1616.
</p>
<p>Xia, Y. (2007)
A constructive approach to the estimation of dimension reduction
directions. 
<em>Annals of Statistics</em> <b>35</b>, 2654&ndash;2690.
</p>

<hr>
<h2 id='thresholdCI'>
Confidence Interval for Threshold of Numerical Predictor
</h2><span id='topic+thresholdCI'></span>

<h3>Description</h3>

<p>Given a point pattern and a spatial covariate that has some predictive
value for the point pattern,
compute a confidence interval for the optimal value of the threshold
that should be used to convert the covariate to a binary predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdCI(X, Z, confidence = 0.95, nsim = 1000, parametric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresholdCI_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="thresholdCI_+3A_z">Z</code></td>
<td>

<p>Spatial covariate with numerical values.
Either a pixel image (object of class <code>"im"</code>),
a distance function (object of class <code>"distfun"</code>)
or a <code>function(x,y)</code> in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="thresholdCI_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level. A number between 0 and 1.
</p>
</td></tr>
<tr><td><code id="thresholdCI_+3A_nsim">nsim</code></td>
<td>

<p>Number of bootstrap simulations to perform.
</p>
</td></tr>
<tr><td><code id="thresholdCI_+3A_parametric">parametric</code></td>
<td>

<p>Logical value specifying whether to use the parametric bootstrap.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial covariate <code>Z</code> is assumed to have some utility as a
predictor of the point pattern <code>X</code>.
</p>
<p>This code computes a bootstrap confidence interval
for the best threshold value <code class="reqn">z</code> for converting the
numerical predictor to a binary predictor, for use in
techniques such as Weights of Evidence.
</p>


<h3>Value</h3>

<p>A matrix containing upper and lower limits for the
threshold <code>z</code> and the corresponding upper and lower limits for
the fraction of area of the study region.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Brown, W., Milne, R.K., Nair, G.,
Rakshit, S., Lawrence, T., Phatak, A. and Fu, S.C. (2021)
Optimal thresholding of predictors in mineral prospectivity analysis.
<em>Natural Resources Research</em> <b>30</b> 923&ndash;969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thresholdSelect">thresholdSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  gold &lt;- rescale(murchison$gold, 1000, "km")
  faults &lt;- rescale(murchison$faults, 1000, "km")
  distfault &lt;- distfun(faults)
  Nsim &lt;- if(interactive()) 250 else 25
  thresholdCI(gold, distfault, nsim=Nsim)
</code></pre>

<hr>
<h2 id='thresholdSelect'>
Select Threshold to Convert Numerical Predictor to Binary Predictor
</h2><span id='topic+thresholdSelect'></span>

<h3>Description</h3>

<p>Given a point pattern and a spatial covariate that has some predictive
value for the point pattern,
determine the optimal value of the threshold for converting
the covariate to a binary predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdSelect(X, Z, method = c("Y", "LL", "AR", "t", "C"), Zname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresholdSelect_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="thresholdSelect_+3A_z">Z</code></td>
<td>

<p>Spatial covariate with numerical values.
Either a pixel image (object of class <code>"im"</code>),
a distance function (object of class <code>"distfun"</code>)
or a <code>function(x,y)</code> in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="thresholdSelect_+3A_method">method</code></td>
<td>

<p>Character string (partially matched)
specifying the method to be used to select the
optimal threshold value. See Details.
</p>
</td></tr>
<tr><td><code id="thresholdSelect_+3A_zname">Zname</code></td>
<td>

<p>Optional character string giving a short name for the covariate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial covariate <code>Z</code> is assumed to have some utility as a
predictor of the point pattern <code>X</code>.
</p>
<p>This code chooses the best threshold value <code class="reqn">v</code> for converting the
numerical predictor <code>Z</code> to a binary predictor, for use in
techniques such as Weights of Evidence.
</p>
<p>The best threshold is selected by maximising the criterion
specified by the argument <code>method</code>. Options are:
</p>

<ul>
<li> <p><code>method="Y"</code> (the default): the Youden criterion 
</p>
</li>
<li> <p><code>method="LL"</code>: log-likelihood 
</p>
</li>
<li> <p><code>method="AR"</code>: the Akman-Raftery criterion
</p>
</li>
<li> <p><code>method="t"</code>: the Studentised Weights-of-Evidence contrast
</p>
</li>
<li> <p><code>method="C"</code>: the Weights-of-Evidence contrast
</p>
</li></ul>

<p>These criteria are explained in Baddeley et al (2021).
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the criterion used to select
the threshold.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Brown, W., Milne, R.K., Nair, G.,
Rakshit, S., Lawrence, T., Phatak, A. and Fu, S.C. (2021)
Optimal thresholding of predictors in mineral prospectivity analysis.
<em>Natural Resources Research</em> <b>30</b> 923&ndash;969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thresholdCI">thresholdCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  gold &lt;- rescale(murchison$gold, 1000, "km")
  faults &lt;- rescale(murchison$faults, 1000, "km")
  distfault &lt;- distfun(faults)
  z &lt;- thresholdSelect(gold, distfault)
  z
  plot(z, xlim=c(0, 20))
</code></pre>

<hr>
<h2 id='transect.im'>
Pixel Values Along a Transect
</h2><span id='topic+transect.im'></span>

<h3>Description</h3>

<p>Extract the pixel values of a pixel image at each point along
a linear transect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transect.im(X, ..., from="bottomleft", to="topright",
            nsample=512, click=FALSE, add=FALSE, curve=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transect.im_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_from">from</code>, <code id="transect.im_+3A_to">to</code></td>
<td>

<p>Optional. Start point and end point of the transect.
Pairs of <code class="reqn">(x,y)</code> coordinates
in a format acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>,
or keywords <code>"bottom"</code>, <code>"left"</code>, <code>"top"</code>,
<code>"right"</code>, <code>"bottomleft"</code> etc.
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_nsample">nsample</code></td>
<td>

<p>Integer. Number of sample locations along the transect.
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_click">click</code></td>
<td>

<p>Optional.
Logical value.
If <code>TRUE</code>, the linear transect is determined interactively
by the user, who clicks two points on the current plot.
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_add">add</code></td>
<td>

<p>Logical. If <code>click=TRUE</code>, this argument determines
whether to perform interactive tasks on the current plot (<code>add=TRUE</code>)
or to start by plotting <code>X</code> (<code>add=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="transect.im_+3A_curve">curve</code></td>
<td>

<p>Optional. A specification of a curved transect. See the section
on Curved Transect.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pixel values of the image <code>X</code> along a line segment 
will be extracted. The result is a function table (<code>"fv"</code> object)
which can be plotted directly.
</p>
<p>If <code>click=TRUE</code>, then the user is prompted to click two points on
the plot of <code>X</code>. These endpoints define the transect.
</p>
<p>Otherwise, the transect is defined by the endpoints
<code>from</code> and <code>to</code>. The default is a diagonal transect from
bottom left to top right of the frame.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> which can be plotted.
</p>


<h3>Curved Transect</h3>

<p>If <code>curve</code> is given, then the transect will be a curve.
The argument <code>curve</code> should be a list with the following
arguments:
</p>

<dl>
<dt>f</dt><dd><p>A function in the <span class="rlang"><b>R</b></span> language with one argument <code>t</code>.</p>
</dd>
<dt>tlim</dt><dd><p>A numeric vector of length 2 giving the range of values
of the argument <code>t</code>.</p>
</dd>
<dt>tname</dt><dd><p>(Optional) a character string giving the symbolic name
of the function argument <code>t</code>; defaults to <code>"t"</code>.</p>
</dd>
<dt>tdescrip</dt><dd><p>(Optional) a character string giving a short
description of the function argument <code>t</code>; defaults to
<code>"curve parameter"</code>.</p>
</dd>
</dl>

<p>The function <code>f</code> must return a 2-column matrix or data frame
specifying the spatial coordinates <code>(x,y)</code> of locations along the
curve, determined by the values of the input argument <code>t</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>im</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- bei.extra$elev
  plot(transect.im(Z))
</code></pre>

<hr>
<h2 id='Tstat'>
Third order summary statistic
</h2><span id='topic+Tstat'></span>

<h3>Description</h3>

<p>Computes the third order summary statistic <code class="reqn">T(r)</code>
of a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tstat(X, ..., r = NULL, rmax = NULL,
    correction = c("border", "translate"), ratio = FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tstat_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">T(r)</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td></tr>
<tr><td><code id="Tstat_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Tstat_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">T(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default.
</p>
</td></tr>
<tr><td><code id="Tstat_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Numeric. The maximum value of <code class="reqn">r</code> for which
<code class="reqn">T(r)</code> should be estimated.
</p>
</td></tr>
<tr><td><code id="Tstat_+3A_correction">correction</code></td>
<td>

<p>Optional. A character vector containing any selection of the
options <code>"none"</code>, <code>"border"</code>, <code>"bord.modif"</code>,
<code>"translate"</code>, <code>"translation"</code>, or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Tstat_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
<tr><td><code id="Tstat_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, an estimate of the computation time
is printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command calculates the 
third-order summary statistic <code class="reqn">T(r)</code> for a spatial point patterns,
defined by Schladitz and Baddeley (2000).
</p>
<p>The definition of <code class="reqn">T(r)</code> is similar to the definition of Ripley's
<code class="reqn">K</code> function <code class="reqn">K(r)</code>, except that <code class="reqn">K(r)</code> counts pairs of
points while <code class="reqn">T(r)</code> counts triples of points. 
Essentially <code class="reqn">T(r)</code> is a rescaled cumulative
distribution function of the diameters of triangles in the
point pattern. The diameter of a triangle is the length of its
longest side.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code><a href="#topic+fv.object">fv.object</a></code>,
which can be plotted directly using <code><a href="#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Computation time</h3>

<p>If the number of points is large, the algorithm can take a very long time
to inspect all possible triangles. A rough estimate
of the total computation time will be printed at the beginning
of the calculation. If this estimate seems very large,
stop the calculation using the user interrupt signal, and
call <code>Tstat</code> again, using <code>rmax</code> to restrict the
range of <code>r</code> values,
thus reducing the number of triangles to be inspected.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Schladitz, K. and Baddeley, A. (2000)
A third order point process characteristic.
<em>Scandinavian Journal of Statistics</em> <b>27</b> (2000) 657&ndash;671.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(Tstat(redwood))
</code></pre>

<hr>
<h2 id='varblock'>
Estimate Variance of Summary Statistic by Subdivision
</h2><span id='topic+varblock'></span>

<h3>Description</h3>

<p>This command estimates the variance of
any summary statistic (such as the <code class="reqn">K</code>-function)
by spatial subdivision of a single point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varblock(X, fun = Kest,
         blocks = quadrats(X, nx = nx, ny = ny),
         ...,
         nx = 3, ny = nx,
         confidence=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varblock_+3A_x">X</code></td>
<td>

<p>Point pattern dataset (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="varblock_+3A_fun">fun</code></td>
<td>

<p>Function that computes the summary statistic.
</p>
</td></tr>
<tr><td><code id="varblock_+3A_blocks">blocks</code></td>
<td>

<p>Optional. A tessellation that specifies the division of
the space into blocks.
</p>
</td></tr>
<tr><td><code id="varblock_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="varblock_+3A_nx">nx</code>, <code id="varblock_+3A_ny">ny</code></td>
<td>

<p>Optional. Number of rectangular blocks
in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
Incompatible with <code>blocks</code>.
</p>
</td></tr>
<tr><td><code id="varblock_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level, as a fraction between 0 and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes an estimate of the variance of
the summary statistic <code>fun(X)</code> from a single point pattern
dataset <code>X</code> using a subdivision method.
It can be used to plot <b>confidence intervals</b>
for the true value of a summary function such as the <code class="reqn">K</code>-function.
</p>
<p>The window containing <code>X</code> is divided into pieces by
an <code>nx * ny</code> array of rectangles
(or is divided into pieces of more general shape,
according to the argument <code>blocks</code> if it is present).
The summary statistic <code>fun</code> is applied to each of the
corresponding sub-patterns of <code>X</code> as described below.
Then the pointwise
sample mean, sample variance and sample standard deviation
of these summary statistics are computed. Then
pointwise confidence intervals are computed, for the specified level
of confidence, defaulting to 95 percent.
</p>
<p>The variance is estimated by equation (4.21) of Diggle (2003, page 52).
This assumes that the point pattern <code>X</code> is stationary.
For further details see Diggle (2003, pp 52&ndash;53).
</p>
<p>The estimate of the summary statistic
from each block is computed as follows.
For most functions <code>fun</code>,
the estimate from block <code>B</code>
is computed by finding the subset of <code>X</code> consisting of
points that fall inside <code>B</code>,
and applying <code>fun</code> to these points, by calling <code>fun(X[B])</code>.
</p>
<p>However if <code>fun</code> is the <code class="reqn">K</code>-function <code><a href="#topic+Kest">Kest</a></code>,
or any function which has an argument called <code>domain</code>,
the estimate for each block <code>B</code> is computed
by calling <code>fun(X, domain=B)</code>. In the case of the
<code class="reqn">K</code>-function this means that the estimate from block <code>B</code>
is computed by counting pairs of
points in which the <em>first</em> point lies in <code>B</code>,
while the second point may lie anywhere. 
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
that contains the result of <code>fun(X)</code> as well as
the sample mean, sample variance and sample standard deviation
of the block estimates, together with 
the upper and lower two-standard-deviation confidence limits.
</p>


<h3>Errors</h3>

<p>If the blocks are too small, there may be insufficient data
in some blocks, and the function <code>fun</code> may report an error.
If this happens, you need to take larger blocks.
</p>
<p>An error message about incompatibility may occur.
The different function estimates may be incompatible in some cases,
for example, because they use different default edge corrections
(typically because the tiles of the tessellation are not the same kind
of geometric object as the window of <code>X</code>, or because the default
edge correction depends on the number of points). To prevent
this, specify the choice of edge correction,
in the <code>correction</code> argument to <code>fun</code>, if it has one.
</p>
<p>An alternative to <code>varblock</code> is Loh's mark bootstrap
<code><a href="#topic+lohboot">lohboot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>


<h3>See Also</h3>

<p><code>tess</code>,
<code>quadrats</code> for basic manipulation.
</p>
<p><code><a href="#topic+lohboot">lohboot</a></code> for an alternative bootstrap technique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   v &lt;- varblock(amacrine, Kest, nx=4, ny=2)
   v &lt;- varblock(amacrine, Kcross, nx=4, ny=2)
   if(interactive()) plot(v, iso ~ r, shade=c("hiiso", "loiso"))
</code></pre>

<hr>
<h2 id='Window.quadrattest'>Extract Window of Spatial Object</h2><span id='topic+Window.quadrattest'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract the window
in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
 ## S3 method for class 'quadrattest'
Window(X, ...)



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window.quadrattest_+3A_x">X</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
<tr><td><code id="Window.quadrattest_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code>Window</code>
which extract the spatial window in which the object <code>X</code>
is defined. 
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code>owin.object</code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>Window</code>,
<code>Window.ppp</code>,
<code>Window.psp</code>.
</p>
<p><code>owin.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- quadrat.test(cells, 4)
   Window(A)
</code></pre>

<hr>
<h2 id='with.fv'>Evaluate an Expression in a Function Table</h2><span id='topic+with.fv'></span>

<h3>Description</h3>

<p>Evaluate an R expression in a 
function value table (object of class <code>"fv"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fv'
with(data, expr, ..., fun = NULL, enclos=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.fv_+3A_data">data</code></td>
<td>
<p>A function value table (object of class <code>"fv"</code>)
in which the expression will be evaluated.
</p>
</td></tr>
<tr><td><code id="with.fv_+3A_expr">expr</code></td>
<td>
<p>The expression to be evaluated. An <span class="rlang"><b>R</b></span> language
expression, which may involve the names of columns in <code>data</code>,
the special abbreviations <code>.</code>, <code>.x</code> and <code>.y</code>,
and global constants or functions.
</p>
</td></tr>
<tr><td><code id="with.fv_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="with.fv_+3A_fun">fun</code></td>
<td>
<p>Logical value, specifying whether the result
should be interpreted as another function (<code>fun=TRUE</code>)
or simply returned as a numeric vector or array (<code>fun=FALSE</code>).
See Details.
</p>
</td></tr>
<tr><td><code id="with.fv_+3A_enclos">enclos</code></td>
<td>

<p>An environment in which to search for variables that are
not found in <code>data</code>. Defaults to <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic command <code><a href="base.html#topic+with">with</a></code>
for an object of class <code>"fv"</code> (function value table).
</p>
<p>An object of class <code>"fv"</code> is a convenient way of storing and
plotting several different estimates of the same function. It is
effectively a data frame with extra attributes. 
See <code><a href="#topic+fv.object">fv.object</a></code> for further explanation.
</p>
<p>This command makes it possible to perform computations that involve
different estimates of the same function. For example we use it to compute
the arithmetic difference between two different edge-corrected
estimates of the <code class="reqn">K</code> function of a point pattern.
</p>
<p>The argument <code>expr</code> should be an <span class="rlang"><b>R</b></span> language expression. The expression
may involve
</p>

<ul>
<li><p> the name of any column in <code>data</code>, referring to
one of the estimates of the function;
</p>
</li>
<li><p> the symbol <code>.</code> which stands for all
the available estimates of the function;
</p>
</li>
<li><p> the symbol <code>.y</code> which stands for the recommended
estimate of the function (in an <code>"fv"</code> object, one of the
estimates is always identified as the recommended estimate);
</p>
</li>
<li><p> the symbol <code>.x</code> which stands for the argument of the function;
</p>
</li>
<li><p> global constants or functions.
</p>
</li></ul>

<p>See the Examples.
The expression should be capable of handling
vectors and matrices.
</p>
<p>The interpretation of the argument <code>fun</code> is as follows:
</p>

<ul>
<li>
<p>If <code>fun=FALSE</code>, the result of evaluating the expression
<code>expr</code> will be returned as a numeric vector, matrix or 
data frame.
</p>
</li>
<li>
<p>If <code>fun=TRUE</code>, then the result of evaluating <code>expr</code>
will be interpreted as containing the values of a new function.
The return value will be an object of class <code>"fv"</code>.
(This can only happen if the result has the right dimensions.)
</p>
</li>
<li> 
<p>The default is <code>fun=TRUE</code> if the result of evaluating
<code>expr</code> has more than one column, and <code>fun=FALSE</code> otherwise.
</p>
</li></ul>

<p>To perform calculations involving <em>several</em> objects of
class <code>"fv"</code>, use <code><a href="#topic+eval.fv">eval.fv</a></code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
or a numeric vector or data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+with">with</a></code>,
<code><a href="#topic+fv.object">fv.object</a></code>,
<code><a href="#topic+eval.fv">eval.fv</a></code>,
<code><a href="#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # compute 4 estimates of the K function
  X &lt;- runifrect(42)
  K &lt;- Kest(X)
  plot(K)

  # derive 4 estimates of the L function L(r) = sqrt(K(r)/pi)
  L &lt;- with(K, sqrt(./pi))
  plot(L)

  # compute 4 estimates of V(r) = L(r)/r
  V &lt;- with(L, ./.x)
  plot(V)

  # compute the maximum absolute difference between
  # the isotropic and translation correction estimates of K(r)
  D &lt;- with(K, max(abs(iso - trans)))
</code></pre>

<hr>
<h2 id='with.ssf'>
Evaluate Expression in a Spatially Sampled Function
</h2><span id='topic+with.ssf'></span><span id='topic+apply.ssf'></span>

<h3>Description</h3>

<p>Given a spatially sampled function,
evaluate an expression involving the function values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  apply.ssf(X, ...)

  ## S3 method for class 'ssf'
with(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.ssf_+3A_x">X</code>, <code id="with.ssf_+3A_data">data</code></td>
<td>

<p>A spatially sampled function (object of class <code>"ssf"</code>).
</p>
</td></tr>
<tr><td><code id="with.ssf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+with.default">with.default</a></code> or
<code><a href="base.html#topic+apply">apply</a></code> specifying what to compute.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ssf"</code> represents a
function (real- or vector-valued) that has been
sampled at a finite set of points.
It contains a data frame
which provides the function values
at the sample points. 
</p>
<p>In <code>with.ssf</code>, the expression specified by <code>...</code>
will be evaluated in this dataframe.
In <code>apply.ssf</code>, the dataframe will be subjected to
the <code><a href="base.html#topic+apply">apply</a></code> operator using the additional arguments
<code>...</code>. 
</p>
<p>If the result of evaluation
is a data frame with one row for each data point,
or a numeric vector with one entry for each data point,
then the result will be an object of class <code>"ssf"</code>
containing this information. Otherwise, the result will be
a numeric vector.
</p>


<h3>Value</h3>

<p>An object of class <code>"ssf"</code> or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssf">ssf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- ssf(cells, data.frame(d=nndist(cells), i=1:npoints(cells)))
  with(a, i/d)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
