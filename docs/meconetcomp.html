<!DOCTYPE html><html><head><title>Help for package meconetcomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {meconetcomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cal_module'><p>Assign modules to each network</p></a></li>
<li><a href='#cal_network_attr'><p>Calculate network topological property for each network</p></a></li>
<li><a href='#cohesionclass'><p>Calculate the cohesion of samples for each network</p></a></li>
<li><a href='#edge_comp'><p>Generate a <code>microtable</code> object with paired nodes distributions of edges across networks</p></a></li>
<li><a href='#edge_node_distance'><p>Perform the distance distribution of paired nodes in edges across networks.</p></a></li>
<li><a href='#edge_tax_comp'><p>Taxonomic sum of linked nodes in edges across networks</p></a></li>
<li><a href='#get_edge_table'><p>Get edge property table for each network</p></a></li>
<li><a href='#get_node_table'><p>Get node property table for each network</p></a></li>
<li><a href='#meconetcomp'><p>Introduction to meconetcomp package (<a href="https://github.com/ChiLiubio/meconetcomp">https://github.com/ChiLiubio/meconetcomp</a>)</p></a></li>
<li><a href='#node_comp'><p>Generate a microtable object with node distributions across networks</p></a></li>
<li><a href='#robustness'><p>Calculate robustness across networks.</p></a></li>
<li><a href='#soil_amp'><p>The soil_amp data</p></a></li>
<li><a href='#soil_amp_network'><p>The soil_amp_network data</p></a></li>
<li><a href='#soil_measure_diversity'><p>The soil_measure_diversity data</p></a></li>
<li><a href='#stool_met'><p>The stool_met data</p></a></li>
<li><a href='#subnet_property'><p>Calculate properties of sub-networks selected according to features in samples</p></a></li>
<li><a href='#subset_network'><p>Extract subset of network according to the edge intersection of networks</p></a></li>
<li><a href='#vulnerability'><p>Calculate the vulnerability of each node for each network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compare Microbial Networks of 'trans_network' Class of
'microeco' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Chi Liu [aut, cre],
  Minjie Yao [ctb],
  Xiangzhen Li [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chi Liu &lt;liuchi0426@126.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compare microbial co-occurrence networks created from 'trans_network' class of 'microeco' package <a href="https://github.com/ChiLiubio/microeco">https://github.com/ChiLiubio/microeco</a>.
    This package is the extension of 'trans_network' class of 'microeco' package and especially useful when different networks are constructed and analyzed simultaneously.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ChiLiubio/meconetcomp">https://github.com/ChiLiubio/meconetcomp</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, microeco (&ge; 1.3.0), magrittr, dplyr, igraph, reshape2,
ggpubr, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgexf, ape, file2meco, agricolae</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-30 02:21:40 UTC; Chi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-30 05:00:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
</table>
<hr>
<h2 id='cal_module'>Assign modules to each network</h2><span id='topic+cal_module'></span>

<h3>Description</h3>

<p>Calculating modularity of networks and assign the modules to nodes for each network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_module(
  network_list,
  undirected_method = "cluster_fast_greedy",
  directed_method = "cluster_optimal",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_module_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
<tr><td><code id="cal_module_+3A_undirected_method">undirected_method</code></td>
<td>
<p>default &quot;cluster_fast_greedy&quot;; the modularity algorithm for undirected network; 
see <code>cal_module</code> function of <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class for more algorithms.</p>
</td></tr>
<tr><td><code id="cal_module_+3A_directed_method">directed_method</code></td>
<td>
<p>default 'cluster_optimal'; the modularity algorithm for directed network.</p>
</td></tr>
<tr><td><code id="cal_module_+3A_...">...</code></td>
<td>
<p>other parameters (except for method) passed to <code>cal_module</code> function of <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>, with module attribute in nodes of each network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil_amp_network)
soil_amp_network &lt;- cal_module(soil_amp_network)

</code></pre>

<hr>
<h2 id='cal_network_attr'>Calculate network topological property for each network</h2><span id='topic+cal_network_attr'></span>

<h3>Description</h3>

<p>Calculate the topological properties of all the networks and merge the results into one table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_network_attr(network_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_network_attr_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil_amp_network)
test &lt;- cal_network_attr(soil_amp_network)

</code></pre>

<hr>
<h2 id='cohesionclass'>Calculate the cohesion of samples for each network</h2><span id='topic+cohesionclass'></span>

<h3>Description</h3>

<p>The cohesion is a method for quantifying the connectivity of microbial communities &lt;doi:10.1038/ismej.2017.91&gt;.
It is defined:
</p>
<p style="text-align: center;"><code class="reqn">C_{j}^{pos} = \sum_{i=1}^{n} a_{i} \cdot \bar{r_{i}}_{|r&gt;0}</code>
</p>

<p style="text-align: center;"><code class="reqn">C_{j}^{neg} = \sum_{i=1}^{n} a_{i} \cdot \bar{r_{i}}_{|r&lt;0}</code>
</p>

<p>where <code class="reqn">C_{j}^{pos}</code> is the positive cohesion, and <code class="reqn">C_{j}^{neg}</code> is the negative cohesion.
<code class="reqn">a_{i}</code> is the relative abundance of species i in sample j.
<code class="reqn">\bar{r_{i}}_{|r&gt;0}</code> denotes the mean weight (correlation coefficient, interaction strength) of all the edges (related with species i) with positive association.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-cohesionclass-new"><code>cohesionclass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-cohesionclass-cal_diff"><code>cohesionclass$cal_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-cohesionclass-plot"><code>cohesionclass$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-cohesionclass-clone"><code>cohesionclass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-cohesionclass-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>cohesionclass$new(network_list)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_list</code></dt><dd><p>a list with multiple networks; all the networks should be <code>trans_network</code> object 
created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of microeco package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_list</code>, stored in the object.
It includes two tables: res_feature and res_sample. In res_feature, the r_pos and r_neg columns mean the <code class="reqn">\bar{r_{i}}_{|r&gt;0}</code> and <code class="reqn">\bar{r_{i}}_{|r&lt;0}</code>.
In res_sample, the c_pos and c_neg columns denote <code class="reqn">C_{j}^{pos}</code> and <code class="reqn">C_{j}^{neg}</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1 &lt;- cohesionclass$new(soil_amp_network)

</pre>
</div>


<hr>
<a id="method-cohesionclass-cal_diff"></a>



<h4>Method <code>cal_diff()</code></h4>

<p>Differential test.
</p>


<h5>Usage</h5>

<div class="r"><pre>cohesionclass$cal_diff(
  measure = "c_pos",
  method = c("anova", "KW", "KW_dunn", "wilcox", "t.test")[1],
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measure</code></dt><dd><p>default &quot;c_pos&quot;; &quot;c_pos&quot; or &quot;c_neg&quot; in the <code>res_list$sample</code>; &quot;r_pos&quot; or &quot;r_neg&quot; in the <code>res_list$feature</code>.</p>
</dd>
<dt><code>method</code></dt><dd><p>default &quot;anova&quot;; see the following available options:
</p>

<dl>
<dt><strong>'anova'</strong></dt><dd><p>Duncan's multiple range test for anova</p>
</dd>
<dt><strong>'KW'</strong></dt><dd><p>KW: Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2)</p>
</dd>
<dt><strong>'KW_dunn'</strong></dt><dd><p>Dunn's Kruskal-Wallis Multiple Comparisons, see <code>dunnTest</code> function in <code>FSA</code> package</p>
</dd>
<dt><strong>'wilcox'</strong></dt><dd><p>Wilcoxon Rank Sum and Signed Rank Tests for all paired groups </p>
</dd>
<dt><strong>'t.test'</strong></dt><dd><p>Student's t-Test for all paired groups</p>
</dd>
</dl>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>cal_diff</code> function of <code>trans_alpha</code> class of <code>microeco</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_diff</code> in object. See the Return of <code>cal_diff</code> function in <code>trans_alpha</code> class of <code>microeco</code> package.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_diff(method = "wilcox")
}
</pre>
</div>


<hr>
<a id="method-cohesionclass-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the result.
</p>


<h5>Usage</h5>

<div class="r"><pre>cohesionclass$plot(measure = "c_pos", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measure</code></dt><dd><p>default &quot;c_pos&quot;; &quot;c_pos&quot; or &quot;c_neg&quot; in the <code>res_list$sample</code>; &quot;r_pos&quot; or &quot;r_neg&quot; in the <code>res_list$feature</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code>plot_alpha</code> function of <code>trans_alpha</code> class of <code>microeco</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot(boxplot_add = "none", add_sig = TRUE)
}
</pre>
</div>


<hr>
<a id="method-cohesionclass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>cohesionclass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `cohesionclass$new`
## ------------------------------------------------

t1 &lt;- cohesionclass$new(soil_amp_network)


## ------------------------------------------------
## Method `cohesionclass$cal_diff`
## ------------------------------------------------


t1$cal_diff(method = "wilcox")


## ------------------------------------------------
## Method `cohesionclass$plot`
## ------------------------------------------------


t1$plot(boxplot_add = "none", add_sig = TRUE)

</code></pre>

<hr>
<h2 id='edge_comp'>Generate a <code>microtable</code> object with paired nodes distributions of edges across networks</h2><span id='topic+edge_comp'></span>

<h3>Description</h3>

<p>Generate a <code>microtable</code> object with paired nodes distributions of edges across networks. Useful for the edge comparisons across different networks.
The return <code>otu_table</code> in <code>microtable</code> object has the binary numbers in which 1 represents the presence of the edge in the corresponding network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_comp(network_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_comp_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of microeco package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>microtable</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil_amp_network)
test &lt;- edge_comp(soil_amp_network)
# test is a microtable object

</code></pre>

<hr>
<h2 id='edge_node_distance'>Perform the distance distribution of paired nodes in edges across networks.</h2><span id='topic+edge_node_distance'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of analysis on the distance values 
of paired nodes in edges across networks, including distance matrix conversion, the differential test and the visualization.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-edge_node_distance-new"><code>edge_node_distance$new()</code></a>
</p>
</li>
<li> <p><a href="#method-edge_node_distance-cal_diff"><code>edge_node_distance$cal_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-edge_node_distance-plot"><code>edge_node_distance$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-edge_node_distance-clone"><code>edge_node_distance$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-edge_node_distance-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>edge_node_distance$new(
  network_list,
  dis_matrix = NULL,
  label = "+",
  with_module = FALSE,
  module_thres = 2
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_list</code></dt><dd><p>a list with multiple networks; all the networks should be <code>trans_network</code> object 
created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of microeco package.</p>
</dd>
<dt><code>dis_matrix</code></dt><dd><p>default NULL; the distance matrix of nodes, used for the value extraction; 
must be a symmetrical matrix with both colnames and rownames (i.e. feature names).</p>
</dd>
<dt><code>label</code></dt><dd><p>default &quot;+&quot;; &quot;+&quot; or &quot;-&quot; or <code>c("+", "-")</code>; the edge label used for the selection of edges.</p>
</dd>
<dt><code>with_module</code></dt><dd><p>default FALSE; whether show the module classification of nodes in the result.</p>
</dd>
<dt><code>module_thres</code></dt><dd><p>default 2; the threshold of the nodes number of modules remained when <code>with_module = TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_table</code>, stored in the object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(soil_amp_network)
data(soil_amp)
# filter useless features to speed up the calculation
node_names &lt;- unique(unlist(lapply(soil_amp_network, function(x){colnames(x$data_abund)})))
filter_soil_amp &lt;- microeco::clone(soil_amp)
filter_soil_amp$otu_table &lt;- filter_soil_amp$otu_table[node_names, ]
filter_soil_amp$tidy_dataset()
# obtain phylogenetic distance matrix
phylogenetic_distance &lt;- as.matrix(cophenetic(filter_soil_amp$phylo_tree))
# choose the positive labels
t1 &lt;- edge_node_distance$new(network_list = soil_amp_network, 
	 dis_matrix = phylogenetic_distance, label = "+")
}
</pre>
</div>


<hr>
<a id="method-edge_node_distance-cal_diff"></a>



<h4>Method <code>cal_diff()</code></h4>

<p>Differential test across networks.
</p>


<h5>Usage</h5>

<div class="r"><pre>edge_node_distance$cal_diff(
  method = c("anova", "KW", "KW_dunn", "wilcox", "t.test")[1],
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;anova&quot;; see the following available options:
</p>

<dl>
<dt><strong>'anova'</strong></dt><dd><p>Duncan's multiple range test for anova</p>
</dd>
<dt><strong>'KW'</strong></dt><dd><p>KW: Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2)</p>
</dd>
<dt><strong>'KW_dunn'</strong></dt><dd><p>Dunn's Kruskal-Wallis Multiple Comparisons, see <code>dunnTest</code> function in <code>FSA</code> package</p>
</dd>
<dt><strong>'wilcox'</strong></dt><dd><p>Wilcoxon Rank Sum and Signed Rank Tests for all paired groups </p>
</dd>
<dt><strong>'t.test'</strong></dt><dd><p>Student's t-Test for all paired groups</p>
</dd>
</dl>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>cal_diff</code> function of <code>trans_alpha</code> class of <code>microeco</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_diff</code> in object. See the Return of <code>cal_diff</code> function in <code>trans_alpha</code> class of <code>microeco</code> package.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_diff(method = "wilcox")
}
</pre>
</div>


<hr>
<a id="method-edge_node_distance-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the distance.
</p>


<h5>Usage</h5>

<div class="r"><pre>edge_node_distance$plot(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters pass to <code>plot_alpha</code> function of <code>trans_alpha</code> class of <code>microeco</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot(boxplot_add = "none", add_sig = TRUE)
}
</pre>
</div>


<hr>
<a id="method-edge_node_distance-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>edge_node_distance$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `edge_node_distance$new`
## ------------------------------------------------


data(soil_amp_network)
data(soil_amp)
# filter useless features to speed up the calculation
node_names &lt;- unique(unlist(lapply(soil_amp_network, function(x){colnames(x$data_abund)})))
filter_soil_amp &lt;- microeco::clone(soil_amp)
filter_soil_amp$otu_table &lt;- filter_soil_amp$otu_table[node_names, ]
filter_soil_amp$tidy_dataset()
# obtain phylogenetic distance matrix
phylogenetic_distance &lt;- as.matrix(cophenetic(filter_soil_amp$phylo_tree))
# choose the positive labels
t1 &lt;- edge_node_distance$new(network_list = soil_amp_network, 
	 dis_matrix = phylogenetic_distance, label = "+")


## ------------------------------------------------
## Method `edge_node_distance$cal_diff`
## ------------------------------------------------


t1$cal_diff(method = "wilcox")


## ------------------------------------------------
## Method `edge_node_distance$plot`
## ------------------------------------------------


t1$plot(boxplot_add = "none", add_sig = TRUE)

</code></pre>

<hr>
<h2 id='edge_tax_comp'>Taxonomic sum of linked nodes in edges across networks</h2><span id='topic+edge_tax_comp'></span>

<h3>Description</h3>

<p>Taxonomic sum of linked nodes in edges across networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_tax_comp(network_list, taxrank = "Phylum", label = "+", rel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_tax_comp_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
<tr><td><code id="edge_tax_comp_+3A_taxrank">taxrank</code></td>
<td>
<p>default &quot;Phylum&quot;; Which taxonomic level is used for the sum of nodes in edges.</p>
</td></tr>
<tr><td><code id="edge_tax_comp_+3A_label">label</code></td>
<td>
<p>default &quot;+&quot;; &quot;+&quot; or &quot;-&quot; or <code>c("+", "-")</code>; the edge label used for the selection of edges for the sum.</p>
</td></tr>
<tr><td><code id="edge_tax_comp_+3A_rel">rel</code></td>
<td>
<p>default <code>TRUE</code>; <code>TRUE</code> represents using ratio, the denominator is the number of selected edges; 
<code>FALSE</code> represents the absolute number of the sum of edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil_amp_network)
test &lt;- edge_tax_comp(soil_amp_network)
# test is a microtable object

</code></pre>

<hr>
<h2 id='get_edge_table'>Get edge property table for each network</h2><span id='topic+get_edge_table'></span>

<h3>Description</h3>

<p>Get edge property table for each network in the list with multiple networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edge_table(network_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_edge_table_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>, with <code>res_edge_table</code> in each network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil_amp_network)
soil_amp_network &lt;- get_edge_table(soil_amp_network)

</code></pre>

<hr>
<h2 id='get_node_table'>Get node property table for each network</h2><span id='topic+get_node_table'></span>

<h3>Description</h3>

<p>Get node property table for each network in the list with multiple networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node_table(network_list, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_node_table_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
<tr><td><code id="get_node_table_+3A_...">...</code></td>
<td>
<p>parameter passed to get_node_table function of <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>, with <code>res_node_table</code> in each network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soil_amp_network)
soil_amp_network &lt;- get_node_table(soil_amp_network, node_roles = FALSE)

</code></pre>

<hr>
<h2 id='meconetcomp'>Introduction to meconetcomp package (<a href="https://github.com/ChiLiubio/meconetcomp">https://github.com/ChiLiubio/meconetcomp</a>)</h2><span id='topic+meconetcomp'></span>

<h3>Description</h3>

<p>For the detailed tutorial on meconetcomp package, please follow the links:<br />
Online tutorial website: <a href="https://chiliubio.github.io/microeco_tutorial/meconetcomp-package.html">https://chiliubio.github.io/microeco_tutorial/meconetcomp-package.html</a> <br />
Download tutorial: <a href="https://github.com/ChiLiubio/microeco_tutorial/releases">https://github.com/ChiLiubio/microeco_tutorial/releases</a>
</p>
<p>Please open the help document by using <code>help</code> function or by clicking the following links collected:<br />
<code><a href="#topic+cal_module">cal_module</a></code><br />
<code><a href="#topic+cal_network_attr">cal_network_attr</a></code><br />
<code><a href="#topic+get_node_table">get_node_table</a></code><br />
<code><a href="#topic+get_edge_table">get_edge_table</a></code><br />
<code><a href="#topic+node_comp">node_comp</a></code><br />
<code><a href="#topic+edge_comp">edge_comp</a></code><br />
<code><a href="#topic+edge_node_distance">edge_node_distance</a></code><br />
<code><a href="#topic+edge_tax_comp">edge_tax_comp</a></code><br />
<code><a href="#topic+subset_network">subset_network</a></code><br />
<code><a href="#topic+subnet_property">subnet_property</a></code><br />
<code><a href="#topic+robustness">robustness</a></code><br />
<code><a href="#topic+vulnerability">vulnerability</a></code><br />
</p>
<p>To report bugs or discuss questions, please use Github Issues (<a href="https://github.com/ChiLiubio/meconetcomp/issues">https://github.com/ChiLiubio/meconetcomp/issues</a>).
Before creating a new issue, 
please read the guideline (<a href="https://chiliubio.github.io/microeco_tutorial/notes.html#github-issues">https://chiliubio.github.io/microeco_tutorial/notes.html#github-issues</a>).
</p>
<p>To cite meconetcomp package in publications, please run the following command to get the reference: <code>citation("meconetcomp")</code><br />
</p>
<p>Reference:<br />
Chi Liu, Chaonan Li, Yanqiong Jiang, Raymond Jianxiong Zeng, Minjie Yao, and Xiangzhen Li. 2023.
A guide for comparing microbial co-occurrence networks. iMeta. 2(1): e71.
</p>

<hr>
<h2 id='node_comp'>Generate a microtable object with node distributions across networks</h2><span id='topic+node_comp'></span>

<h3>Description</h3>

<p>Generate a microtable object with node distributions across networks. Useful for the node information comparisons across different networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_comp(network_list, property = "name")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_comp_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
<tr><td><code id="node_comp_+3A_property">property</code></td>
<td>
<p>default &quot;name&quot;; a colname of <code>res_node_table</code> in each network; 
the default &quot;name&quot; represents using node presence/absence information in the otu_table of final output, in which
1 represents presence of the node in the corresponding network; 
For other options (such as degree), the results in the output otu_table are the actual values of <code>res_node_table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>microtable</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soil_amp_network)
test &lt;- node_comp(soil_amp_network)
# test is a microtable object

</code></pre>

<hr>
<h2 id='robustness'>Calculate robustness across networks.</h2><span id='topic+robustness'></span>

<h3>Description</h3>

<p>This class is a wrapper for robustness calculation and visualization.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-robustness-new"><code>robustness$new()</code></a>
</p>
</li>
<li> <p><a href="#method-robustness-plot"><code>robustness$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-robustness-clone"><code>robustness$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-robustness-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>robustness$new(
  network_list,
  remove_strategy = c("edge_rand", "edge_strong", "edge_weak", "node_rand", "node_hub",
    "node_degree_high", "node_degree_low")[1],
  remove_ratio = seq(0, 1, 0.1),
  measure = c("Eff", "Eigen", "Pcr")[1],
  run = 10
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_list</code></dt><dd><p>a list with multiple networks; all the networks should be <code>trans_network</code> object 
created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of microeco package.</p>
</dd>
<dt><code>remove_strategy</code></dt><dd><p>default &quot;edge_rand&quot;; 
</p>

<dl>
<dt><strong>&quot;edge_rand&quot;</strong></dt><dd><p>edges are randomly removed.</p>
</dd>
<dt><strong>&quot;edge_strong&quot;</strong></dt><dd><p>edges are removed in decreasing order of weight.</p>
</dd>
<dt><strong>&quot;edge_weak&quot;</strong></dt><dd><p>edges are removed in increasing order of weight.</p>
</dd>
<dt><strong>&quot;node_rand&quot;</strong></dt><dd><p>nodes are removed randomly.</p>
</dd>
<dt><strong>&quot;node_hub&quot;</strong></dt><dd><p>node hubs are removed. The hubs include network hubs and module hubs.</p>
</dd>
<dt><strong>&quot;node_degree_high&quot;</strong></dt><dd><p>nodes are removed in decreasing order of degree.</p>
</dd>
<dt><strong>&quot;node_degree_low&quot;</strong></dt><dd><p>nodes are removed in increasing order of degree.</p>
</dd>
</dl>
</dd>
<dt><code>remove_ratio</code></dt><dd><p>default seq(0, 1, 0.1).</p>
</dd>
<dt><code>measure</code></dt><dd><p>default &quot;Eff&quot;; network robustness measures. 
</p>

<dl>
<dt><strong>&quot;Eff&quot;</strong></dt><dd><p>network efficiency. The average efficiency of the network is defined:
</p>
<p style="text-align: center;"><code class="reqn">Eff = \frac{1}{N(N - 1)} \sum_{i \neq j \in G}\frac{1}{d(i, j)}</code>
</p>

<p>where N is the total number of nodes and <em>d(i,j)</em> is the shortest path between node i and node j. 
When the weight is found in the edge attributes, <code class="reqn">d(i,j)</code> denotes the weighted shortest path between node i and node j.
For more details, please read the references &lt;doi: 10.1007/s11704-016-6108-z&gt; and &lt;doi: 10.1038/s41598-020-60298-7&gt;.
</p>
</dd>
<dt><strong>&quot;Eigen&quot;</strong></dt><dd><p>natural connectivity &lt;doi: 10.1007/s11704-016-6108-z&gt;.
The natural connectivity can be regarded as an average eigenvalue that changes strictly monotonically with the addition or deletion of edges. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">\bar{\lambda} = \ln(\frac{1}{N} \sum_{i=1}^{N} e^{\lambda~i~})</code>
</p>

<p>where <code class="reqn">\lambda~i~</code> is the <code class="reqn">i</code>th eigenvalue of the graph adjacency matrix. The larger the value of <code class="reqn">\bar{\lambda}</code> is, the more robust the network is.
</p>
</dd>
<dt><strong>&quot;Pcr&quot;</strong></dt><dd><p>critical removal fraction of vertices (edges) for the disintegration of networks 
&lt;doi: 10.1007/s11704-016-6108-z&gt; &lt;doi: 10.1103/PhysRevE.72.056130&gt;.
This is a robustness measure based on random graph theory.
The critical fraction against random attacks is labeled as <code class="reqn">P_{c}^r</code>. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">P_{c}^r = 1 - \frac{1}{\frac{\langle k^2 \rangle}{\langle k \rangle} - 1}</code>
</p>

<p>where <code class="reqn">\langle k \rangle</code> is the average nodal degree of the original network, and <code class="reqn">\langle k^2 \rangle</code> is the average of square of nodal degree. 
</p>
</dd>
</dl>
</dd>
<dt><code>run</code></dt><dd><p>default 10. Replication number applied for the sampling method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_table</code>, stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>tmp &lt;- robustness$new(soil_amp_network, remove_strategy = c("edge_rand"), 
  measure = c("Eff"), run = 3, remove_ratio = c(0.1, 0.5, 0.9))

</pre>
</div>


<hr>
<a id="method-robustness-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the simulation results.
</p>


<h5>Usage</h5>

<div class="r"><pre>robustness$plot(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  show_point = TRUE,
  point_size = 1,
  point_alpha = 0.6,
  show_errorbar = TRUE,
  errorbar_position = position_dodge(0),
  errorbar_size = 1,
  errorbar_width = 0.1,
  add_fitting = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>colors used for presentation.</p>
</dd>
<dt><code>show_point</code></dt><dd><p>default TRUE; whether show the point.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default .3; point size value.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default .6; point alpha value.</p>
</dd>
<dt><code>show_errorbar</code></dt><dd><p>default TRUE; whether show the errorbar by using the SD result.</p>
</dd>
<dt><code>errorbar_position</code></dt><dd><p>default position_dodge(0); Position adjustment, either as a string (such as &quot;identity&quot;), 
or the result of a call to a position adjustment function.</p>
</dd>
<dt><code>errorbar_size</code></dt><dd><p>default 1; errorbar size.</p>
</dd>
<dt><code>errorbar_width</code></dt><dd><p>default 0.1; errorbar width.</p>
</dd>
<dt><code>add_fitting</code></dt><dd><p>default FALSE; whether add fitted smooth line. FALSE denotes add line segment among points.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to ggplot2::geom_line (when add_fitting = FALSE) or ggplot2::geom_smooth (when add_fitting = TRUE).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
tmp$plot(linewidth = 1)
}
</pre>
</div>


<hr>
<a id="method-robustness-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>robustness$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `robustness$new`
## ------------------------------------------------

tmp &lt;- robustness$new(soil_amp_network, remove_strategy = c("edge_rand"), 
  measure = c("Eff"), run = 3, remove_ratio = c(0.1, 0.5, 0.9))


## ------------------------------------------------
## Method `robustness$plot`
## ------------------------------------------------


tmp$plot(linewidth = 1)

</code></pre>

<hr>
<h2 id='soil_amp'>The soil_amp data</h2><span id='topic+soil_amp'></span>

<h3>Description</h3>

<p>The soil_amp data is the 16S rRNA gene amplicon sequencing dataset of Chinese wetland soils.
Reference: An et al. 2019 &lt;doi:10.1016/j.geoderma.2018.09.035&gt;; Liu et al. 2022 &lt;10.1016/j.geoderma.2022.115866&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil_amp)
</code></pre>

<hr>
<h2 id='soil_amp_network'>The soil_amp_network data</h2><span id='topic+soil_amp_network'></span>

<h3>Description</h3>

<p>The soil_amp_network data is a list storing three trans_network objects created based on soil_amp data.
Three networks are created for IW, CW and TW groups, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil_amp_network)
</code></pre>

<hr>
<h2 id='soil_measure_diversity'>The soil_measure_diversity data</h2><span id='topic+soil_measure_diversity'></span>

<h3>Description</h3>

<p>The soil_measure_diversity data is a table storing all the abiotic factors and functional diversity based on the metagenomic sequencing and MetaCyc pathway analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil_measure_diversity)
</code></pre>

<hr>
<h2 id='stool_met'>The stool_met data</h2><span id='topic+stool_met'></span>

<h3>Description</h3>

<p>The stool_met data is the metagenomic species abundance dataset of stool samples selected from R ExperimentHub package.
It has 198 samples, collected from the people with alcohol drinking habit, and 92 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stool_met)
</code></pre>

<hr>
<h2 id='subnet_property'>Calculate properties of sub-networks selected according to features in samples</h2><span id='topic+subnet_property'></span>

<h3>Description</h3>

<p>Extracting sub-network according to the presence of features in each sample across networks and calculate the sub-network properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subnet_property(network_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subnet_property_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soil_amp_network)
test &lt;- subnet_property(soil_amp_network)

</code></pre>

<hr>
<h2 id='subset_network'>Extract subset of network according to the edge intersection of networks</h2><span id='topic+subset_network'></span>

<h3>Description</h3>

<p>Extracting a network according to the edge intersection of networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_network(network_list, venn = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_network_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be <code>trans_network</code> object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of microeco package.</p>
</td></tr>
<tr><td><code id="subset_network_+3A_venn">venn</code></td>
<td>
<p>default NULL; a <code>microtable</code> object which must be converted by <code>trans_comm</code> function of <code>trans_venn</code> class.</p>
</td></tr>
<tr><td><code id="subset_network_+3A_name">name</code></td>
<td>
<p>default NULL; integer or character; must be a number or one of colnames of the <code>otu_table</code> in the input <code>venn</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trans_network</code> object, with only the extracted edges in the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soil_amp_network)
# first obtain edge distribution
tmp &lt;- edge_comp(soil_amp_network)
# obtain edge intersection using trans_venn class
tmp1 &lt;- microeco::trans_venn$new(tmp)
# convert intersection result to microtable object
tmp2 &lt;- tmp1$trans_comm()
# extract the intersection of all the three networks ("IW", "TW" and "CW")
test &lt;- subset_network(soil_amp_network, venn = tmp2, name = "IW&amp;TW&amp;CW")
# test is a trans_network object

</code></pre>

<hr>
<h2 id='vulnerability'>Calculate the vulnerability of each node for each network</h2><span id='topic+vulnerability'></span>

<h3>Description</h3>

<p>The vulnerability of each node represents the influence of the node on the global efficiency of the network, i.e. the efficiency of network after removing the targeted node.
For the detailed defination of global efficiency, please see the &quot;Eff&quot; option of measure parameter in <code><a href="#topic+robustness">robustness</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vulnerability(network_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vulnerability_+3A_network_list">network_list</code></td>
<td>
<p>a list with multiple networks; all the networks should be trans_network object created from <code><a href="microeco.html#topic+trans_network">trans_network</a></code> class of <code>microeco</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soil_amp_network)
vulnerability_table &lt;- vulnerability(soil_amp_network)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
