<!DOCTYPE html><html><head><title>Help for package Tplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Tplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Tplyr'><p>A grammar of summary data for clinical reports</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_anti_join'><p>Add an anti-join onto a tplyr_meta object</p></a></li>
<li><a href='#add_column_headers'><p>Attach column headers to a Tplyr output</p></a></li>
<li><a href='#add_layer'><p>Attach a layer to a <code>tplyr_table</code> object</p></a></li>
<li><a href='#add_missing_subjects_row'><p>Add a missing subject row into a count summary.</p></a></li>
<li><a href='#add_risk_diff'><p>Add risk difference to a count layer</p></a></li>
<li><a href='#add_total_row'><p>Add a Total row into a count summary.</p></a></li>
<li><a href='#add_treat_grps'><p>Combine existing treatment groups for summary</p></a></li>
<li><a href='#add_variables'><p>Add variables to a tplyr_meta object</p></a></li>
<li><a href='#append_metadata'><p>Append the Tplyr table metadata dataframe</p></a></li>
<li><a href='#apply_conditional_format'><p>Conditional reformatting of a pre-populated string of numbers</p></a></li>
<li><a href='#apply_formats'><p>Apply Format Strings outside of a Tplyr table</p></a></li>
<li><a href='#apply_row_masks'><p>Replace repeating row label variables with blanks in preparation for display.</p></a></li>
<li><a href='#build'><p>Trigger the execution of the <code>tplyr_table</code></p></a></li>
<li><a href='#collapse_row_labels'><p>Collapse row labels into a single column</p></a></li>
<li><a href='#f_str'><p>Create a <code>f_str</code> object</p></a></li>
<li><a href='#get_by'><p>Set or return by layer binding</p></a></li>
<li><a href='#get_data_labels'><p>Get Data Labels</p></a></li>
<li><a href='#get_desc_layer_formats'><p>Get or set the default format strings for descriptive statistics layers</p></a></li>
<li><a href='#get_meta_result'><p>Extract the result metadata of a Tplyr table</p></a></li>
<li><a href='#get_meta_subset'><p>Extract the subset of data based on result metadata</p></a></li>
<li><a href='#get_metadata'><p>Get the metadata dataframe from a tplyr_table</p></a></li>
<li><a href='#get_numeric_data'><p>Retrieve the numeric data from a tplyr objects</p></a></li>
<li><a href='#get_precision_by'><p>Set or return precision_by layer binding</p></a></li>
<li><a href='#get_precision_on'><p>Set or return precision_on layer binding</p></a></li>
<li><a href='#get_stats_data'><p>Get statistics data</p></a></li>
<li><a href='#get_target_var'><p>Set or return treat_var binding</p></a></li>
<li><a href='#get_tplyr_regex'><p>Retrieve one of Tplyr's regular expressions</p></a></li>
<li><a href='#get_where.tplyr_layer'><p>Set or return where binding for layer or table</p></a></li>
<li><a href='#group_count'><p>Create a <code>count</code>, <code>desc</code>, or <code>shift</code> layer for discrete count</p>
based summaries, descriptive statistics summaries, or shift count summaries</a></li>
<li><a href='#header_n'><p>Return or set header_n binding</p></a></li>
<li><a href='#keep_levels'><p>Select levels to keep in a count layer</p></a></li>
<li><a href='#new_layer_template'><p>Create, view, extract, remove, and use Tplyr layer templates</p></a></li>
<li><a href='#pop_data'><p>Return or set population data bindings</p></a></li>
<li><a href='#pop_treat_var'><p>Return or set pop_treat_var binding</p></a></li>
<li><a href='#process_formatting'><p>Process layers to get formatted and pivoted tables.</p></a></li>
<li><a href='#process_metadata'><p>Process layers to get metadata tables</p></a></li>
<li><a href='#process_statistic_data'><p>Process a tplyr_statistic object</p></a></li>
<li><a href='#process_statistic_formatting'><p>Process string formatting on a tplyr_statistic object</p></a></li>
<li><a href='#process_summaries'><p>Process layers to get numeric results of layer</p></a></li>
<li><a href='#replace_leading_whitespace'><p>Reformat strings with leading whitespace for HTML</p></a></li>
<li><a href='#set_custom_summaries'><p>Set custom summaries to be performed within a descriptive statistics layer</p></a></li>
<li><a href='#set_denom_ignore'><p>Set values the denominator calculation will ignore</p></a></li>
<li><a href='#set_denom_where'><p>Set Logic for denominator subsetting</p></a></li>
<li><a href='#set_denoms_by'><p>Set variables used in pct denominator calculation</p></a></li>
<li><a href='#set_distinct_by'><p>Set counts to be distinct by some grouping variable.</p></a></li>
<li><a href='#set_format_strings'><p>Set the format strings and associated summaries to be performed in a layer</p></a></li>
<li><a href='#set_indentation'><p>Set the option to prefix the row_labels in the inner count_layer</p></a></li>
<li><a href='#set_limit_data_by'><p>Set variables to limit reported data values only to those that exist rather</p>
than fully completing all possible levels</a></li>
<li><a href='#set_missing_count'><p>Set the display for missing strings</p></a></li>
<li><a href='#set_missing_subjects_row_label'><p>Set the label for the missing subjects row</p></a></li>
<li><a href='#set_nest_count'><p>Set the option to nest count layers</p></a></li>
<li><a href='#set_numeric_threshold'><p>Set a numeric cutoff</p></a></li>
<li><a href='#set_order_count_method'><p>Set the ordering logic for the count layer</p></a></li>
<li><a href='#set_outer_sort_position'><p>Set the value of a outer nested count layer to Inf or -Inf</p></a></li>
<li><a href='#set_precision_data'><p>Set precision data</p></a></li>
<li><a href='#set_stats_as_columns'><p>Set descriptive statistics as columns</p></a></li>
<li><a href='#set_total_row_label'><p>Set the label for the total row</p></a></li>
<li><a href='#str_extract_fmt_group'><p>Extract format group strings or numbers</p></a></li>
<li><a href='#str_indent_wrap'><p>Wrap strings to a specific width with hyphenation while preserving</p>
indentation</a></li>
<li><a href='#tplyr_adae'><p>ADAE Data</p></a></li>
<li><a href='#tplyr_adas'><p>ADAS Data</p></a></li>
<li><a href='#tplyr_adlb'><p>ADLB Data</p></a></li>
<li><a href='#tplyr_adpe'><p>ADPE Data</p></a></li>
<li><a href='#tplyr_adsl'><p>ADSL Data</p></a></li>
<li><a href='#tplyr_layer'><p>Create a <code>tplyr_layer</code> object</p></a></li>
<li><a href='#tplyr_meta'><p>Tplyr Metadata Object</p></a></li>
<li><a href='#tplyr_table'><p>Create a Tplyr table object</p></a></li>
<li><a href='#treat_var'><p>Return or set the treatment variable binding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Traceability Focused Grammar of Clinical Data Summary</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A traceability focused tool created to simplify the data manipulation necessary to create clinical summaries.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/atorus-research/Tplyr">https://github.com/atorus-research/Tplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/atorus-research/Tplyr/issues">https://github.com/atorus-research/Tplyr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.4.6), assertthat (&ge; 0.2.1), magrittr (&ge; 1.5),
dplyr (&ge; 1.0.0), purrr (&ge; 0.3.3), stringr (&ge; 1.4.0), tidyr
(&ge; 1.0.2), tidyselect (&ge; 1.1.0), tibble (&ge; 3.0.1),
lifecycle, forcats (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), haven (&ge; 2.2.0), knitr, rmarkdown,
huxtable, tidyverse, readr, kableExtra, pharmaRTF, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 21:00:25 UTC; mike.stackhouse</td>
</tr>
<tr>
<td>Author:</td>
<td>Eli Miller <a href="https://orcid.org/0000-0002-2127-9456"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mike Stackhouse <a href="https://orcid.org/0000-0001-6030-723X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ashley Tarasiewicz [aut],
  Nathan Kosiba <a href="https://orcid.org/0000-0001-5359-4234"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sadchla Mascary [ctb],
  Andrew Bates [ctb],
  Shiyu Chen [ctb],
  Oleksii Mikryukov [ctb],
  Atorus Research LLC [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Stackhouse &lt;mike.stackhouse@atorusresearch.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Tplyr'>A grammar of summary data for clinical reports</h2><span id='topic+Tplyr'></span><span id='topic+Tplyr-package'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;experimental&quot;)'
</p>


<h3>Details</h3>

<p>'Tplyr' is a package dedicated to simplifying the data manipulation necessary
to create clinical reports. Clinical data summaries can often be broken down
into two factors - counting discrete variables (or counting shifts in state),
and descriptive statistics around a continuous variable. Many of the reports
that go into a clinical report are made up of these two scenarios. By
abstracting this process away, 'Tplyr' allows you to rapidly build these
tables without worrying about the underlying data manipulation.
</p>
<p>'Tplyr' takes this process a few steps further by abstracting away most of
the programming that goes into proper presentation, which is where a great
deal of programming time is spent. For example, 'Tplyr' allows you to easily
control:
</p>
 <dl>
<dt><strong>String formatting</strong></dt><dd><p>Different reports warrant
different presentation of your strings. Programming this can get tedious, as
you typically want to make sure that your decimals properly align. 'Tplyr'
abstracts this process away and provides you with a simple interface to
specify how you want your data presented</p>
</dd> <dt><strong>Treatment
groups</strong></dt><dd><p>Need a total column? Need to group summaries of multiple treatments?
'Tplyr' makes it simple to add additional treatment groups into your report</p>
</dd>
<dt><strong>Denominators</strong></dt><dd><p>n (%) counts often vary based on the summary
being performed. 'Tplyr' allows you to easily control what denominators are
used based on a few common scenarios</p>
</dd> <dt><strong>Sorting</strong></dt><dd><p>Summarizing
data is one thing, but ordering it for presentation. Tplyr automatically
derives sorting variable to give you the data you need to order your table
properly. This process is flexible so you can easily get what you want by
leveraging your data or characteristics of R.</p>
</dd> </dl>

<p>Another powerful aspect of 'Tplyr' are the objects themselves. 'Tplyr' does
more than format your data. Metadata about your table is kept under the hood,
and functions allow you to access information that you need. For example,
'Tplyr' allows you to calculate and access the raw numeric data of
calculations as well, and easily pick out just the pieces of information that
you need.
</p>
<p>Lastly, 'Tplyr' was built to be flexible, yet intuitive. A common pitfall of
building tools like this is over automation. By doing to much, you end up not
doing enough. 'Tplyr' aims to hit the sweet spot in between. Additionally, we
designed our function interfaces to be clean. Modifier functions offer you
flexibility when you need it, but defaults can be set to keep the code
concise. This allows you to quickly assemble your table, and easily make
changes where necessary.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mike Stackhouse <a href="mailto:mike.stackhouse@atorusresearch.com">mike.stackhouse@atorusresearch.com</a> (<a href="https://orcid.org/0000-0001-6030-723X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Eli Miller <a href="mailto:Eli.Miller@AtorusResearch.com">Eli.Miller@AtorusResearch.com</a> (<a href="https://orcid.org/0000-0002-2127-9456">ORCID</a>)
</p>
</li>
<li><p> Ashley Tarasiewicz <a href="mailto:Ashley.Tarasiewicz@atorusresearch.com">Ashley.Tarasiewicz@atorusresearch.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nathan Kosiba <a href="mailto:Nathan.Kosiba@atorusresearch.com">Nathan.Kosiba@atorusresearch.com</a> (<a href="https://orcid.org/0000-0001-5359-4234">ORCID</a>) [contributor]
</p>
</li>
<li><p> Sadchla Mascary <a href="mailto:sadchla.mascary@atorusresearch.com">sadchla.mascary@atorusresearch.com</a> [contributor]
</p>
</li>
<li><p> Andrew Bates <a href="mailto:andrew.bates@atorusresearch.com">andrew.bates@atorusresearch.com</a> [contributor]
</p>
</li>
<li><p> Shiyu Chen <a href="mailto:shiyu.chen@atorusresearch.com">shiyu.chen@atorusresearch.com</a> [contributor]
</p>
</li>
<li><p> Oleksii Mikryukov <a href="mailto:alex.mikryukov@atorusresearch.com">alex.mikryukov@atorusresearch.com</a> [contributor]
</p>
</li>
<li><p> Atorus Research LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/atorus-research/Tplyr">https://github.com/atorus-research/Tplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/atorus-research/Tplyr/issues">https://github.com/atorus-research/Tplyr/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

# Use just the defaults
tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(mpg, by=cyl)
  ) %&gt;%
  add_layer(
    group_count(carb, by=cyl)
  ) %&gt;%
  build()

# Customize and modify
tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(mpg, by=cyl) %&gt;%
      set_format_strings(
        "n"         = f_str("xx", n),
        "Mean (SD)" = f_str("a.a+1 (a.a+2)", mean, sd, empty='NA'),
        "Median"    = f_str("a.a+1", median),
        "Q1, Q3"    = f_str("a, a", q1, q3, empty=c(.overall='NA')),
        "Min, Max"  = f_str("a, a", min, max),
        "Missing"   = f_str("xx", missing)
      )
  ) %&gt;%
  add_layer(
    group_count(carb, by=cyl) %&gt;%
      add_risk_diff(
        c('5', '3'),
        c('4', '3')
      ) %&gt;%
      set_format_strings(
        n_counts = f_str('xx (xx%)', n, pct),
        riskdiff = f_str('xx.xxx (xx.xxx, xx.xxx)', dif, low, high)
      ) %&gt;%
      set_order_count_method("bycount") %&gt;%
      set_ordering_cols('4') %&gt;%
      set_result_order_var(pct)
  ) %&gt;%
  build()

# A Shift Table
tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl) %&gt;%
    set_format_strings(f_str("xxx (xx.xx%)", n, pct))
  ) %&gt;%
  build()

</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='add_anti_join'>Add an anti-join onto a tplyr_meta object</h2><span id='topic+add_anti_join'></span>

<h3>Description</h3>

<p>An anti-join allows a tplyr_meta object to refer to data that should be
extracted from a separate dataset, like the population data of a Tplyr table,
that is unavailable in the target dataset. The primary use case for this is
the presentation of missing subjects, which in a Tplyr table is presented
using the function <code>add_missing_subjects_row()</code>. The missing subjects
themselves are not present in the target data, and are thus only available in
the population data. The <code>add_anti_join()</code> function allows you to provide the
meta information relevant to the population data, and then specify the <code>on</code>
variable that should be used to join with the target dataset and find the
values present in the population data that are missing from the target data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_anti_join(meta, join_meta, on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_anti_join_+3A_meta">meta</code></td>
<td>
<p>A tplyr_meta object referring to the target data</p>
</td></tr>
<tr><td><code id="add_anti_join_+3A_join_meta">join_meta</code></td>
<td>
<p>A tplyr_meta object referring to the population data</p>
</td></tr>
<tr><td><code id="add_anti_join_+3A_on">on</code></td>
<td>
<p>A list of quosures containing symbols - most likely set to USUBJID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tplyr_meta object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tm &lt;- tplyr_meta(
  rlang::quos(TRT01A, SEX, ETHNIC, RACE),
  rlang::quos(TRT01A == "Placebo", TRT01A == "SEX", ETHNIC == "HISPANIC OR LATINO")
)

tm %&gt;%
  add_anti_join(
    tplyr_meta(
      rlang::quos(TRT01A, ETHNIC),
      rlang::quos(TRT01A == "Placebo", ETHNIC == "HISPANIC OR LATINO")
    ),
    on = rlang::quos(USUBJID)
  )
</code></pre>

<hr>
<h2 id='add_column_headers'>Attach column headers to a Tplyr output</h2><span id='topic+add_column_headers'></span>

<h3>Description</h3>

<p>When working with 'huxtable' tables, column headers can be controlled as if they are rows in the data frame.
<code>add_column_headers</code> eases the process of introducing these headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_column_headers(.data, s, header_n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_column_headers_+3A_.data">.data</code></td>
<td>
<p>The data.frame/tibble on which the headers shall be attached</p>
</td></tr>
<tr><td><code id="add_column_headers_+3A_s">s</code></td>
<td>
<p>The text containing the intended header string</p>
</td></tr>
<tr><td><code id="add_column_headers_+3A_header_n">header_n</code></td>
<td>
<p>A header_n or generic data.frame to use for binding count values.
This is required if you are using the token replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Headers are created by providing a single string. Columns are specified by delimitting each header with a '|' symbol.
Instead of specifying the destination of each header, <code>add_column_headers</code> assumes that you have organized the columns
of your data frame before hand. This means that after you use <code>Tplyr::build()</code>, if you'd like to reorganize the
default column order (which is simply alphabetical), simply pass the build output to a <code>dplyr::select</code> or <code>dplyr::relocate</code>
statement before passing into <code>add_column_headers</code>.
</p>
<p>Spanning headers are also supported. A spanning header is an overarching header that sits across multiple columns.
Spanning headers are introduced to <code>add_column_header</code> by providing the spanner text (i.e. the text that
you'd like to sit in the top row), and then the spanned text (the bottom row) within curly brackets ('{}). For example,
take the iris dataset. We have the names:
</p>
<p><code>"Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"</code>
</p>
<p>If we wanted to provide a header string for this dataset, with spanners to help with categorization of
the variables, we could provide the following string:
</p>
<p><code>"Sepal {Length | Width} | Petal {Length | Width} | Species"</code>
</p>


<h3>Value</h3>

<p>A data.frame with the processed header string elements attached as the top rows
</p>


<h3>Important note</h3>

<p>Make sure you are aware of the order of your variables prior to passing in to <code>add_column_headers</code>. The only requirement
is that the number of column match. The rest is up to you.
</p>


<h3>Development notes</h3>

<p>There are a few features of <code>add_column_header</code> that are intended but not yet supported:
</p>

<ul>
<li><p>Nested spanners are not yet supported. Only a spanning row and a bottom row can currently be created
</p>
</li>
<li><p>Different delimiters and indicators for a spanned group may be used in the future. The current choices were intuitive,
but based on feedback it could be determined that less common characters may be necessary.
</p>
</li></ul>



<h3>Token Replacement</h3>

<p>This function has support for reading values from the header_n object in a Tplyr table
and adding them in the column headers. Note: The order of the parameters
passed in the token is important. They should be first the treatment variable
then any <code>cols</code> variables in the order they were passed in the table construction.
</p>
<p>Use a double asterisk &quot;**&quot; at the begining to start the token and another
double asterisk to close it. You can separate column parameters in the token
with a single underscore. For example, **group1_flag2_param3** will pull the count
from the header_n binding for group1 in the <code>treat_var</code>, flag2 in the first <code>cols</code>
argument, and param3 in the second <code>cols</code> argument.
</p>
<p>You can pass fewer arguments in the token to get the sum of multiple columns.
For example, **group1** would get the sum of the group1 treat_var,
and all cols from the header_n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)
library(dplyr)
header_string &lt;- "Sepal {Length | Width} | Petal {Length | Width} | Species"

iris2 &lt;- iris %&gt;%
  mutate_all(as.character)

iris2 %&gt;% add_column_headers(header_string)

# Example with counts
mtcars2 &lt;- mtcars %&gt;%
  mutate_all(as.character)

t &lt;- tplyr_table(mtcars2, vs, cols = am) %&gt;%
  add_layer(
    group_count(cyl)
  )

b_t &lt;- build(t) %&gt;%
  mutate_all(as.character)

count_string &lt;- paste0(" | V N=**0** {auto N=**0_0** | man N=**0_1**} |",
                       " S N=**1** {auto N=**1_0** | man N=**1_1**} | | ")

add_column_headers(b_t, count_string, header_n(t))
</code></pre>

<hr>
<h2 id='add_layer'>Attach a layer to a <code>tplyr_table</code> object</h2><span id='topic+add_layer'></span><span id='topic+add_layers'></span>

<h3>Description</h3>

<p><code>add_layer</code> attaches a <code>tplyr_layer</code> to a <code>tplyr_table</code> object. This allows
for a tidy style of programming (using <code>magrittr</code> piping, i.e. <code>%&gt;%</code>) with a
secondary advantage - the construction of the layer object may consist of a series of piped
functions itself.
</p>
<p><code>Tplyr</code> encourages a user to view the construction of a table as a series of &quot;layers&quot;.
The construction of each of these layers are isolated and independent of one another - but
each of these layers are children of the table itself. <code>add_layer</code> isolates the construction
of an individual layer and allows the user to construct that layer and insert it back into the
parent. The syntax for this is intuitive and allows for tidy piping. Simply pipe the current
table object in, and write the code to construct your layer within the <code>layer</code> parameter.
</p>
<p><code>add_layers</code> is another approach to attaching layers to a <code>tplyr_table</code>. Instead of
constructing the entire table at once, <code>add_layers</code> allows you to construct layers as
different objects. These layers can then be attached into the <code>tplyr_table</code> all at
once.
</p>
<p><code>add_layer</code> and <code>add_layers</code> both additionally allow you to name the layers as you
attach them. This is helpful when using functions like <code><a href="#topic+get_numeric_data">get_numeric_data</a></code> or
<code><a href="#topic+get_stats_data">get_stats_data</a></code> when you can access information from a layer directly.
<code>add_layer</code> has a name parameter, and layers can be named in <code>add_layers</code> by
submitting the layer as a named argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_layer(parent, layer, name = NULL)

add_layers(parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_layer_+3A_parent">parent</code></td>
<td>
<p>A <code>tplyr_table</code> or <code>tplyr_layer</code>/<code>tplyr_subgroup_layer</code> object</p>
</td></tr>
<tr><td><code id="add_layer_+3A_layer">layer</code></td>
<td>
<p>A layer construction function and associated modifier functions</p>
</td></tr>
<tr><td><code id="add_layer_+3A_name">name</code></td>
<td>
<p>A name to provide the layer in the table layers container</p>
</td></tr>
<tr><td><code id="add_layer_+3A_...">...</code></td>
<td>
<p>Layers to be added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tplyr_table</code> or <code>tplyr_layer</code>/<code>tplyr_subgroup_layer</code> with a new layer inserted into the <code>layer</code>
binding
</p>


<h3>See Also</h3>

<p>[tplyr_table(), tplyr_layer(), group_count(), group_desc(), group_shift()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

## Single layer
t &lt;- tplyr_table(mtcars, cyl) %&gt;%
  add_layer(
    group_desc(target_var=mpg)
  )

## Single layer with name
t &lt;- tplyr_table(mtcars, cyl) %&gt;%
  add_layer(name='mpg',
    group_desc(target_var=mpg)
  )

# Using add_layers
t &lt;- tplyr_table(mtcars, cyl)
l1 &lt;- group_desc(t, target_var=mpg)
l2 &lt;- group_count(t, target_var=cyl)

t &lt;- add_layers(t, l1, 'cyl' = l2)

</code></pre>

<hr>
<h2 id='add_missing_subjects_row'>Add a missing subject row into a count summary.</h2><span id='topic+add_missing_subjects_row'></span>

<h3>Description</h3>

<p>This function calculates the number of subjects missing from a particular
group of results. The calculation is done by examining the total number of
subjects potentially available from the Header N values within the result
column, and finding the difference with the total number of subjects present
in the result group. Note that for accurate results, the subject variable
needs to be defined using the 'set_distinct_by()' function. As with other
methods, this function instructs how distinct results should be identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_missing_subjects_row(e, fmt = NULL, sort_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_missing_subjects_row_+3A_e">e</code></td>
<td>
<p>A 'count_layer' object</p>
</td></tr>
<tr><td><code id="add_missing_subjects_row_+3A_fmt">fmt</code></td>
<td>
<p>An f_str object used to format the total row. If none is provided,
display is based on the layer formatting.</p>
</td></tr>
<tr><td><code id="add_missing_subjects_row_+3A_sort_value">sort_value</code></td>
<td>
<p>The value that will appear in the ordering column for total
rows. This must be a numeric value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      add_missing_subjects_row(f_str("xxxx", n))
   ) %&gt;%
   build()
</code></pre>

<hr>
<h2 id='add_risk_diff'>Add risk difference to a count layer</h2><span id='topic+add_risk_diff'></span>

<h3>Description</h3>

<p>A very common requirement for summary tables is to calculate the risk difference between treatment
groups. <code>add_risk_diff</code> allows you to do this. The underlying risk difference calculations
are performed using the Base R function <code><a href="stats.html#topic+prop.test">prop.test</a></code> - so prior to using this function,
be sure to familiarize yourself with its functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_risk_diff(layer, ..., args = list(), distinct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_risk_diff_+3A_layer">layer</code></td>
<td>
<p>Layer upon which the risk difference will be attached</p>
</td></tr>
<tr><td><code id="add_risk_diff_+3A_...">...</code></td>
<td>
<p>Comparison groups, provided as character vectors where the first group is the comparison,
and the second is the reference</p>
</td></tr>
<tr><td><code id="add_risk_diff_+3A_args">args</code></td>
<td>
<p>Arguments passed directly into <code><a href="stats.html#topic+prop.test">prop.test</a></code></p>
</td></tr>
<tr><td><code id="add_risk_diff_+3A_distinct">distinct</code></td>
<td>
<p>Logical - Use distinct counts (if available).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_risk_diff</code> can only be attached to a count layer, so the count layer must be constructed
first. <code>add_risk_diff</code> allows you to compare the difference between treatment group, so all
comparisons should be based upon the values within the specified <code>treat_var</code> in your
<code>tplyr_table</code> object.
</p>
<p>Comparisons are specified by providing two-element character vectors. You can provide as many of
these groups as you want. You can also use groups that have been constructed using
<code><a href="#topic+add_treat_grps">add_treat_grps</a></code> or <code><a href="#topic+add_total_group">add_total_group</a></code>. The first element provided will be considered
the 'reference' group (i.e. the left side of the comparison), and the second group will be considered
the 'comparison'. So if you'd like to see the risk difference of 'T1 - Placebo', you would specify
this as <code>c('T1', 'Placebo')</code>.
</p>
<p>Tplyr forms your two-way table in the background, and then runs <code><a href="stats.html#topic+prop.test">prop.test</a></code> appropriately.
Similar to way that the display of layers are specified, the exact values and format of how you'd like
the risk difference display are set using <code><a href="#topic+set_format_strings">set_format_strings</a></code>. This controls both the values
and the format of how the risk difference is displayed. Risk difference formats are set within
<code><a href="#topic+set_format_strings">set_format_strings</a></code> by using the name 'riskdiff'.
</p>
<p>You have 5 variables to choose from in your data presentation:
</p>

<dl>
<dt><strong>comp</strong></dt><dd><p>Probability of the left hand side group (i.e. comparison)</p>
</dd>
<dt><strong>ref</strong></dt><dd><p>Probability of the right hand side group (i.e. reference)</p>
</dd>
<dt><strong>dif</strong></dt><dd><p>Difference of comparison - reference</p>
</dd>
<dt><strong>low</strong></dt><dd><p>Lower end of the confidence interval (default is 95%, override with the <code>args</code> paramter)</p>
</dd>
<dt><strong>high</strong></dt><dd><p>Upper end of the confidence interval (default is 95%, override with the <code>args</code> paramter)</p>
</dd>
</dl>

<p>Use these variable names when forming your <code><a href="#topic+f_str">f_str</a></code> objects. The default presentation, if no
string format is specified, will be:
</p>
<p><code>f_str('xx.xxx (xx.xxx, xx.xxx)', dif, low, high)</code>
</p>
<p>Note - within Tplyr, you can account for negatives by allowing an extra space within your integer
side settings. This will help with your alignment.
</p>
<p>If columns are specified on a Tplyr table, risk difference comparisons still only take place between
groups within the <code>treat_var</code> variable - but they are instead calculated treating the <code>cols</code>
variables as by variables. Just like the tplyr layers themselves, the risk difference will then be transposed
and display each risk difference as separate variables by each of the <code>cols</code> variables.
</p>
<p>If <code>distinct</code> is TRUE (the default), all calculations will take place on the distinct counts, if
they are available. Otherwise, non-distinct counts will be used.
</p>
<p>One final note - <code><a href="stats.html#topic+prop.test">prop.test</a></code> may throw quite a few warnings. This is natural, because it
alerts you when there's not enough data for the approximations to be correct. This may be unnerving
coming from a SAS programming world, but this is R is trying to alert you that the values provided
don't have enough data to truly be statistically accurate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

## Two group comparisons with default options applied
t &lt;- tplyr_table(mtcars, gear)

# Basic risk diff for two groups, using defaults
l1 &lt;- group_count(t, carb) %&gt;%
  # Compare 3 vs. 4, 3 vs. 5
  add_risk_diff(
    c('3', '4'),
    c('3', '5')
  )

# Build and show output
add_layers(t, l1) %&gt;% build()

## Specify custom formats and display variables
t &lt;- tplyr_table(mtcars, gear)

# Create the layer with custom formatting
l2 &lt;- group_count(t, carb) %&gt;%
  # Compare 3 vs. 4, 3 vs. 5
  add_risk_diff(
    c('3', '4'),
    c('3', '5')
  ) %&gt;%
  set_format_strings(
    'n_counts' = f_str('xx (xx.x)', n, pct),
    'riskdiff' = f_str('xx.xxx, xx.xxx, xx.xxx, xx.xxx, xx.xxx', comp, ref, dif, low, high)
  )

# Build and show output
add_layers(t, l2) %&gt;% build()

## Passing arguments to prop.test
t &lt;- tplyr_table(mtcars, gear)

# Create the layer with args option
l3 &lt;- group_count(t, carb) %&gt;%
  # Compare 3 vs. 4, 4 vs. 5
  add_risk_diff(
    c('3', '4'),
    c('3', '5'),
    args = list(conf.level = 0.9, correct=FALSE, alternative='less')
  )

# Build and show output
add_layers(t, l3) %&gt;% build()
</code></pre>

<hr>
<h2 id='add_total_row'>Add a Total row into a count summary.</h2><span id='topic+add_total_row'></span>

<h3>Description</h3>

<p>Adding a total row creates an additional observation in the count summary
that presents the total counts (i.e. the n's that are summarized). The format
of the total row will be formatted in the same way as the other count
strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_total_row(e, fmt = NULL, count_missings = TRUE, sort_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_total_row_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="add_total_row_+3A_fmt">fmt</code></td>
<td>
<p>An f_str object used to format the total row. If none is provided,
display is based on the layer formatting.</p>
</td></tr>
<tr><td><code id="add_total_row_+3A_count_missings">count_missings</code></td>
<td>
<p>Whether or not to ignore the named arguments passed in
'set_count_missing()' when calculating counts total row. This is useful if
you need to exclude/include the missing counts in your total row. Defaults
to TRUE meaning total row will not ignore any values.</p>
</td></tr>
<tr><td><code id="add_total_row_+3A_sort_value">sort_value</code></td>
<td>
<p>The value that will appear in the ordering column for total
rows. This must be a numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Totals are calculated using all grouping variables, including treat_var and
cols from the table level. If by variables are included, the grouping of the
total and the application of denominators becomes ambiguous. You will be
warned specifically if a percent is included in the format. To rectify this,
use <code>set_denoms_by()</code>, and the grouping of <code>add_total_row()</code> will
be updated accordingly.
</p>
<p>Note that when using <code>add_total_row()</code> with <code>set_pop_data()</code>, you
should call <code>add_total_row()</code> AFTER calling <code>set_pop_data()</code>,
otherwise there is potential for unexpected behaivior with treatment groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in Pipe
library(magrittr)

tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      add_total_row(f_str("xxxx", n))
   ) %&gt;%
   build()
</code></pre>

<hr>
<h2 id='add_treat_grps'>Combine existing treatment groups for summary</h2><span id='topic+add_treat_grps'></span><span id='topic+add_total_group'></span><span id='topic+treat_grps'></span>

<h3>Description</h3>

<p>Summary tables often present individual treatment groups, but may
additionally have a &quot;Treatment vs. Placebo&quot; or &quot;Total&quot; group added to show
grouped summary statistics or counts. This set of functions offers an
interface to add these groups at a table level and be consumed by subsequent
layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_treat_grps(table, ...)

add_total_group(table, group_name = "Total")

treat_grps(table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_treat_grps_+3A_table">table</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="add_treat_grps_+3A_...">...</code></td>
<td>
<p>A named vector where names will become the new treatment group
names, and values will be used to construct those treatment groups</p>
</td></tr>
<tr><td><code id="add_treat_grps_+3A_group_name">group_name</code></td>
<td>
<p>The treatment group name used for the constructed 'Total' group</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_treat_grps</code> allows you to specify specific groupings. This is done
by supplying named arguments, where the name becomes the new treatment
group's name, and those treatment groups are made up of the argument's
values.
</p>
<p><code>add_total_group</code> is a simple wrapper around <code>add_treat_grps</code>.
Instead of producing custom groupings, it produces a &quot;Total&quot; group by the
supplied name, which defaults to &quot;Total&quot;. This &quot;Total&quot; group is made up of
all existing treatment groups within the population dataset.
</p>
<p>Note that when using <code>add_treat_grps</code> or <code>add_total_row()</code> with
<code>set_pop_data()</code>, you should call <code>add_total_row()</code> AFTER calling
<code>set_pop_data()</code>, otherwise there is potential for unexpected behaivior
with treatment groups.
</p>
<p>The function <code>treat_grps</code> allows you to see the custom treatment groups
available in your <code>tplyr_table</code> object
</p>


<h3>Value</h3>

<p>The modified table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(iris, Species)

# A custom group
add_treat_grps(tab, "Not Setosa" = c("versicolor", "virginica"))

# Add a total group
add_total_group(tab)

treat_grps(tab)
# Returns:
# $`Not Setosa`
#[1] "versicolor" "virginica"
#
#$Total
#[1] "setosa"     "versicolor" "virginica"
</code></pre>

<hr>
<h2 id='add_variables'>Add variables to a tplyr_meta object</h2><span id='topic+add_variables'></span><span id='topic+add_filters'></span>

<h3>Description</h3>

<p>Add additional variable names to a <code>tplyr_meta()</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_variables(meta, names)

add_filters(meta, filters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_variables_+3A_meta">meta</code></td>
<td>
<p>A tplyr_meta object</p>
</td></tr>
<tr><td><code id="add_variables_+3A_names">names</code></td>
<td>
<p>A list of names, providing variable names of interest. Provide
as a list of quosures using <code>rlang::quos()</code></p>
</td></tr>
<tr><td><code id="add_variables_+3A_filters">filters</code></td>
<td>
<p>A list of symbols, providing variable names of interest. Provide
as a list of quosures using 'rlang::quos()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tplyr_meta object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- tplyr_meta()
m &lt;- add_variables(m, rlang::quos(a, b, c))
m &lt;- add_filters(m, rlang::quos(a==1, b==2, c==3))
m
</code></pre>

<hr>
<h2 id='append_metadata'>Append the Tplyr table metadata dataframe</h2><span id='topic+append_metadata'></span>

<h3>Description</h3>

<p><code>append_metadata()</code> allows a user to extend the Tplyr metadata data frame
with user provided data. In some tables, Tplyr may be able to provided most
of the data, but a user may have to extend the table with other summaries,
statistics, etc. This function allows the user to extend the tplyr_table's
metadata with their own metadata content using custom data frames created
using the <code>tplyr_meta</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_metadata(t, meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_metadata_+3A_t">t</code></td>
<td>
<p>A tplyr_table object</p>
</td></tr>
<tr><td><code id="append_metadata_+3A_meta">meta</code></td>
<td>
<p>A dataframe fitting the specifications of the details section of
this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As this is an advanced feature of Tplyr, ownership is on the user to make
sure the metadata data frame is assembled properly. The only restrictions
applied by <code>append_metadata()</code> are that <code>meta</code> must have a column named
<code>row_id</code>, and the values in <code>row_id</code> cannot be duplicates of any <code>row_id</code>
value already present in the Tplyr metadata dataframe. <code>tplyr_meta()</code> objects
align with constructed dataframes using the <code>row_id</code> and output dataset
column name. As such, <code>tplyr_meta()</code> objects should be inserted into a data
frame using a list column.
</p>


<h3>Value</h3>

<p>A tplyr_table object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(wt)
  )

t %&gt;%
  build(metadata=TRUE)

m &lt;- tibble::tibble(
  row_id = c('x1_1'),
  var1_3 = list(tplyr_meta(rlang::quos(a, b, c), rlang::quos(a==1, b==2, c==3)))
)

append_metadata(t, m)
</code></pre>

<hr>
<h2 id='apply_conditional_format'>Conditional reformatting of a pre-populated string of numbers</h2><span id='topic+apply_conditional_format'></span>

<h3>Description</h3>

<p>This function allows you to conditionally re-format a string of numbers based
on a numeric value within the string itself. By selecting a &quot;format group&quot;,
which is targeting a specific number within the string, a user can establish
a condition upon which a provided replacement string can be used. Either the
entire replacement can be used to replace the entire string, or the
replacement text can refill the &quot;format group&quot; while preserving the original
width and alignment of the target string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_conditional_format(
  string,
  format_group,
  condition,
  replacement,
  full_string = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_conditional_format_+3A_string">string</code></td>
<td>
<p>Target character vector where text may be replaced</p>
</td></tr>
<tr><td><code id="apply_conditional_format_+3A_format_group">format_group</code></td>
<td>
<p>An integer representing the targeted numeric field within
the string, numbered from left to right</p>
</td></tr>
<tr><td><code id="apply_conditional_format_+3A_condition">condition</code></td>
<td>
<p>An expression, using the variable name 'x' as the target
variable within the condition</p>
</td></tr>
<tr><td><code id="apply_conditional_format_+3A_replacement">replacement</code></td>
<td>
<p>A string to use as the replacement value</p>
</td></tr>
<tr><td><code id="apply_conditional_format_+3A_full_string">full_string</code></td>
<td>
<p>TRUE if the full string should be replaced, FALSE if the
replacement should be done within the format group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
string &lt;- c(" 0  (0.0%)", " 8  (9.3%)", "78 (90.7%)")

apply_conditional_format(string, 2, x == 0, " 0        ", full_string=TRUE)

apply_conditional_format(string, 2, x &lt; 1, "(&lt;1%)")

</code></pre>

<hr>
<h2 id='apply_formats'>Apply Format Strings outside of a Tplyr table</h2><span id='topic+apply_formats'></span>

<h3>Description</h3>

<p>The <code>f_str</code> object in Tplyr is used to drive formatting of the outputs
strings within a Tplyr table. This function allows a user to use the same
interface to apply formatted string on any data frame within a
<code>dplyr::mutate()</code> context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_formats(format_string, ..., empty = c(.overall = ""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_formats_+3A_format_string">format_string</code></td>
<td>
<p>The desired display format. X's indicate digits. On the
left, the number of x's indicates the integer length. On the right, the
number of x's controls decimal precision and rounding. Variables are
inferred by any separation of the 'x' values other than a decimal.</p>
</td></tr>
<tr><td><code id="apply_formats_+3A_...">...</code></td>
<td>
<p>The variables to be formatted using the format specified in
<code>format_string</code>. These must be numeric variables.</p>
</td></tr>
<tr><td><code id="apply_formats_+3A_empty">empty</code></td>
<td>
<p>The string to display when the numeric data is not available.
Use a single element character vector, with the element named '.overall' to
instead replace the whole string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that auto-precision is not currently supported within <code>apply_formats()</code>
</p>


<h3>Value</h3>

<p>Character vector of formatted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

mtcars %&gt;%
  head() %&gt;%
  mutate(
    fmt_example = apply_formats('xxx (xx.x)', hp, wt)
  )
</code></pre>

<hr>
<h2 id='apply_row_masks'>Replace repeating row label variables with blanks in preparation for display.</h2><span id='topic+apply_row_masks'></span>

<h3>Description</h3>

<p>Depending on the display package being used, row label values may need to be
blanked out if they are repeating. This gives the data frame supporting the
table the appearance of the grouping variables being grouped together in
blocks. <code>apply_row_masks</code> does this work by blanking out the value of
any row_label variable where the current value is equal to the value
before it. Note - <code>apply_row_masks</code> assumes that the data frame has
already be sorted and therefore should only be applied once the data frame is
in its final sort sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_row_masks(dat, row_breaks = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_row_masks_+3A_dat">dat</code></td>
<td>
<p>Data.frame / tibble to mask repeating row_labels</p>
</td></tr>
<tr><td><code id="apply_row_masks_+3A_row_breaks">row_breaks</code></td>
<td>
<p>Boolean - set to TRUE to insert row breaks</p>
</td></tr>
<tr><td><code id="apply_row_masks_+3A_...">...</code></td>
<td>
<p>Variable used to determine where row-breaks should be inserted.
Breaks will be inserted when this group of variables changes values. This
is determined by dataset order, so sorting should be done prior to using
<code>apply_row_masks</code>. If left empty, <code>ord_layer_index</code> will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally, <code>apply_row_masks</code> can add row breaks for you between each
layer. Row breaks are inserted as blank rows. This relies on the &quot;break by&quot;
variables (submitted via <code>...</code>) constructed in <code>build</code> still being
attached to the dataset. An additional order variable is attached named
<code>ord_break</code>, but the output dataset is sorted to properly insert the row
breaks between layers.
</p>


<h3>Value</h3>

<p>tibble with blanked out rows where values are repeating
</p>

<hr>
<h2 id='build'>Trigger the execution of the <code>tplyr_table</code></h2><span id='topic+build'></span>

<h3>Description</h3>

<p>The functions used to assemble a <code>tplyr_table</code> object and
each of the layers do not trigger the processing of any data. Rather, a lazy
execution style is used to allow you to construct your table and then
explicitly state when the data processing should happen. <code>build</code>
triggers this event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build(x, metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_+3A_x">x</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="build_+3A_metadata">metadata</code></td>
<td>
<p>Trigger to build metadata. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>build</code> command is executed, all of the data
processing commences. Any pre-processing necessary within the table
environment takes place first. Next, each of the layers begins executing.
Once the layers complete executing, the output of each layer is stacked into
the resulting data frame.
</p>
<p>Once this process is complete, any post-processing necessary within the table
environment takes place, and the final output can be delivered. Metadata and
traceability information are kept within each of the layer environments,
which allows an investigation into the source of the resulting datapoints.
For example, numeric data from any summaries performed is maintained and
accessible within a layer using <code><a href="#topic+get_numeric_data">get_numeric_data</a></code>.
</p>
<p>The 'metadata' option of build will trigger the construction of traceability
metadata for the constructed data frame. Essentially, for every &quot;result&quot; that
Tplyr produces, Tplyr can also generate the steps necessary to obtain the
source data which produced that result from the input. For more information,
see vignette(&quot;metadata&quot;).
</p>


<h3>Value</h3>

<p>An executed <code>tplyr_table</code>
</p>


<h3>See Also</h3>

<p>tplyr_table, tplyr_layer, add_layer, add_layers, layer_constructors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in Pipe
library(magrittr)

tplyr_table(iris, Species) %&gt;%
  add_layer(
    group_desc(Sepal.Length, by = "Sepal Length")
  ) %&gt;%
  add_layer(
    group_desc(Sepal.Width, by = "Sepal Width")
  ) %&gt;%
  build()

</code></pre>

<hr>
<h2 id='collapse_row_labels'>Collapse row labels into a single column</h2><span id='topic+collapse_row_labels'></span>

<h3>Description</h3>

<p>This is a generalized post processing function that allows you to take groups
of by variables and collapse them into a single column. Repeating values are
split into separate rows, and for each level of nesting, a specified
indentation level can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_row_labels(x, ..., indent = "  ", target_col = row_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_row_labels_+3A_x">x</code></td>
<td>
<p>Input data frame</p>
</td></tr>
<tr><td><code id="collapse_row_labels_+3A_...">...</code></td>
<td>
<p>Row labels to be collapsed</p>
</td></tr>
<tr><td><code id="collapse_row_labels_+3A_indent">indent</code></td>
<td>
<p>Indentation string to be used, which is multiplied at each indentation level</p>
</td></tr>
<tr><td><code id="collapse_row_labels_+3A_target_col">target_col</code></td>
<td>
<p>The desired name of the output column containing collapsed row labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with row labels collapsed into a single column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
~row_label1, ~row_label2, ~row_label3, ~row_label4, ~var1,
  "A",         "C",         "G",         "M",        1L,
  "A",         "C",         "G",         "N",        2L,
  "A",         "C",         "H",         "O",        3L,
  "A",         "D",         "H",         "P",        4L,
  "A",         "D",         "I",         "Q",        5L,
  "A",         "D",         "I",         "R",        6L,
  "B",         "E",         "J",         "S",        7L,
  "B",         "E",         "J",         "T",        8L,
  "B",         "E",         "K",         "U",        9L,
  "B",         "F",         "K",         "V",        10L,
  "B",         "F",         "L",         "W",        11L
)


collapse_row_labels(x, row_label1, row_label2, row_label3, row_label4)

collapse_row_labels(x, row_label1, row_label2, row_label3)

collapse_row_labels(x, row_label1, row_label2, indent = "    ", target_col = rl)

</code></pre>

<hr>
<h2 id='f_str'>Create a <code>f_str</code> object</h2><span id='topic+f_str'></span>

<h3>Description</h3>

<p><code>f_str</code> objects are intended to be used within the function
<code>set_format_strings</code>. The <code>f_str</code> object carries information that powers a
significant amount of layer processing. The <code>format_string</code> parameter is
capable of controlling the display of a data point and decimal precision. The
variables provided in <code>...</code> control which data points are used to populate
the string formatted output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_str(format_string, ..., empty = c(.overall = ""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_str_+3A_format_string">format_string</code></td>
<td>
<p>The desired display format. X's indicate digits. On the
left, the number of x's indicates the integer length. On the right, the
number of x's controls decimal precision and rounding. Variables are
inferred by any separation of the 'x' values other than a decimal.</p>
</td></tr>
<tr><td><code id="f_str_+3A_...">...</code></td>
<td>
<p>The variables to be formatted using the format specified in
<code>format_string</code>.</p>
</td></tr>
<tr><td><code id="f_str_+3A_empty">empty</code></td>
<td>
<p>The string to display when the numeric data is not available.
For desc layers, an unnamed character vector will populate within the
provided format string, set to the same width as the fitted numbers. Use a
single element character vector, with the element named '.overall' to
instead replace the whole string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Format strings are one of the most powerful components of 'Tplyr'.
Traditionally, converting numeric values into strings for presentation can
consume a good deal of time. Values and decimals need to align between
rows, rounding before trimming is sometimes forgotten - it can become a
tedious mess that is realistically not an important part of the analysis
being performed. 'Tplyr' makes this process as simple as we can, while
still allowing flexibility to the user.
</p>
<p>Tplyr provides both manual and automatic decimal precision formatting. The
display of the numbers in the resulting data frame is controlled by the
<code>format_string</code> parameter. For manual precision, just like dummy values may
be presented on your mocks, integer and decimal precision is specified by
the user providing a string of 'x's for how you'd like your numbers
formatted. If you'd like 2 integers with 3 decimal places, you specify your
string as 'xx.xxx'. 'Tplyr' does the work to get the numbers in the right
place.
</p>
<p>To take this a step further, automatic decimal precision can also be
obtained based on the collected precision within the data. When creating
tables where results vary by some parameter, different results may call for
different degrees of precision. To use automatic precision, use a single
'a' on either the integer and decimal side. If you'd like to use increased
precision (i.e. you'd like mean to be collected precision +1), use 'a+1'.
So if you'd like both integer and and decimal precision to be based on the
data as collected, you can use a format like 'a.a' - or for collected+1
decimal precision, 'a.a+1'.  You can mix and match this with manual formats
as well, making format strings such as 'xx.a+1'.
</p>
<p>If you want two numbers on the same line, you provide two sets of x's. For
example, if you're presenting a value like &quot;mean (sd)&quot; - you could provide
the string 'xx.xx (xx.xxx)', or perhaps 'a.a+1 (a.a+2). Note that you're
able to provide different integer lengths and different decimal precision
for the two values. Each format string is independent and relates only to
the format specified.
</p>
<p>As described above, when using 'x' or 'a', any other character within the
format string will stay stationary. So for example, if your format string
is 'xx (xxx.x)', your number may format as '12 ( 34.5)'. So the left side
parenthesis stays fixed. In some displays, you may want the parenthesis to
'hug' your number. Following this example, when allotting 3 spaces for the
integer within parentheses, the parentehsis should shift to the right,
making the numbers appear '12  (34.5)'. Using <code>f_str()</code> you can achieve
this by using a capital 'X' or 'A'. For this example, the format string
would be 'xx (XXX.x)'.
</p>
<p>There are a two rules when using 'parenthesis hugging':
</p>

<ul>
<li><p> Capital letters should only be used on the integer side of a number
</p>
</li>
<li><p> A character must precede the capital letter, otherwise there's no
character to 'hug'
</p>
</li></ul>

<p>The other parameters of the <code>f_str</code> call specify what values should fill
the x's. <code>f_str</code> objects are used slightly differently between different
layers. When declaring a format string within a count layer, <code>f_str()</code>
expects to see the values <code>n</code> or <code>distinct_n</code> for event or distinct counts,
<code>pct</code> or <code>distinct_pct</code> for event or distinct percentages, or <code>total</code> or
<code>distinct_total</code> for denominator calculations. Note that in an <code>f_str()</code>
for a count layer 'A' or 'a' are based on n counts, and therefore don't
make sense to use in percentages. But in descriptive statistic layers,
<code>f_str</code> parameters refer to the names of the summaries being performed,
either by built in defaults, or custom summaries declared using
<code><a href="#topic+set_custom_summaries">set_custom_summaries()</a></code>. See <code><a href="#topic+set_format_strings">set_format_strings()</a></code> for some more notes
about layers specific implementation.
</p>
<p>An <code>f_str()</code> may also be used outside of a Tplyr table. The function
<code><a href="#topic+apply_formats">apply_formats()</a></code> allows you to apply an <code>f_str</code> within the context of
<code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> or more generally a vectorized function.
</p>


<h3>Value</h3>

<p>A <code>f_str</code> object
</p>


<h3>Valid <code>f_str()</code> Variables by Layer Type</h3>

<p>Valid variables allowed within the <code>...</code> parameter of <code>f_str()</code> differ by
layer type.
</p>

<ul>
<li><p> Count layers
</p>

<ul>
<li> <p><code>n</code>
</p>
</li>
<li> <p><code>pct</code>
</p>
</li>
<li> <p><code>total</code>
</p>
</li>
<li> <p><code>distinct_n</code>
</p>
</li>
<li> <p><code>distinct_pct</code>
</p>
</li>
<li> <p><code>distinct_total</code>
</p>
</li></ul>

</li>
<li><p> Shift layers
</p>

<ul>
<li> <p><code>n</code>
</p>
</li>
<li> <p><code>pct</code>
</p>
</li>
<li> <p><code>total</code>
</p>
</li></ul>

</li>
<li><p> Desc layers
</p>

<ul>
<li> <p><code>n</code>
</p>
</li>
<li> <p><code>mean</code>
</p>
</li>
<li> <p><code>sd</code>
</p>
</li>
<li> <p><code>median</code>
</p>
</li>
<li> <p><code>var</code>
</p>
</li>
<li> <p><code>min</code>
</p>
</li>
<li> <p><code>max</code>
</p>
</li>
<li> <p><code>iqr</code>
</p>
</li>
<li> <p><code>q1</code>
</p>
</li>
<li> <p><code>q3</code>
</p>
</li>
<li> <p><code>missing</code>
</p>
</li>
<li><p> Custom summaries created by <code><a href="#topic+set_custom_summaries">set_custom_summaries()</a></code>
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
f_str("xx.x (xx.x)", mean, sd)

f_str("a.a+1 (a.a+2)", mean, sd)

f_str("xx.a (xx.a+1)", mean, sd)

f_str("xx.x, xx.x, xx.x", q1, median, q3)

f_str("xx (XXX.x%)", n, pct)

f_str("a.a+1 (A.a+2)", mean, sd)

</code></pre>

<hr>
<h2 id='get_by'>Set or return by layer binding</h2><span id='topic+get_by'></span><span id='topic+set_by'></span>

<h3>Description</h3>

<p>Set or return by layer binding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_by(layer)

set_by(layer, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_by_+3A_layer">layer</code></td>
<td>
<p>A <code>tplyr_layer</code> object</p>
</td></tr>
<tr><td><code id="get_by_+3A_by">by</code></td>
<td>
<p>A string, a variable name, or a list of variable names supplied
using <code>dplyr::vars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_by</code>, the <code>by</code> binding of the supplied layer. For
<code>set_by</code> the modified layer environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)
iris$Species2 &lt;- iris$Species
lay &lt;- tplyr_table(iris, Species) %&gt;%
  group_count(Species) %&gt;%
  set_by(vars(Species2, Sepal.Width))
</code></pre>

<hr>
<h2 id='get_data_labels'>Get Data Labels</h2><span id='topic+get_data_labels'></span>

<h3>Description</h3>

<p>Get labels for data sets included in Tplyr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_labels(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_labels_+3A_data">data</code></td>
<td>
<p>A Tplyr data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns 'name' and 'label' containing the names and labels of each column.
</p>

<hr>
<h2 id='get_desc_layer_formats'>Get or set the default format strings for descriptive statistics layers</h2><span id='topic+get_desc_layer_formats'></span><span id='topic+set_desc_layer_formats'></span><span id='topic+get_count_layer_formats'></span><span id='topic+set_count_layer_formats'></span><span id='topic+get_shift_layer_formats'></span><span id='topic+set_shift_layer_formats'></span>

<h3>Description</h3>

<p>Tplyr provides you with the ability to set table-wide defaults of format
strings. You may wish to reuse the same format strings across numerous
layers. <code>set_desc_layer_formats</code> and <code>set_count_layer_formats</code>
allow you to apply your desired format strings within the entire scope of the
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_desc_layer_formats(obj)

set_desc_layer_formats(obj, ...)

get_count_layer_formats(obj)

set_count_layer_formats(obj, ...)

get_shift_layer_formats(obj)

set_shift_layer_formats(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_desc_layer_formats_+3A_obj">obj</code></td>
<td>
<p>A tplyr_table object</p>
</td></tr>
<tr><td><code id="get_desc_layer_formats_+3A_...">...</code></td>
<td>
<p>formats to pass forward</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For descriptive statistic layers, you can also use <code>set_format_strings</code>
and <code>set_desc_layer_formats</code> together within a table, but not within the
same layer. In the absence of specified format strings, first the table will
be checked for any available defaults, and otherwise the
<code>tplyr.desc_layer_default_formats</code> option will be used.
<code>set_format_strings</code> will always take precedence over either. Defaults
cannot be combined between <code>set_format_strings</code>,
<code>set_desc_layer_formats</code>, and the
<code>tplyr.desc_layer_default_formats</code> because the order of presentation of
results is controlled by the format strings, so relying on combinations of
these setting would not be intuitive.
</p>
<p>For count layers, you can override the <code>n_counts</code> or <code>riskdiff</code>
format strings separately, and the narrowest scope available will be used
from layer, to table, to default options.
</p>

<hr>
<h2 id='get_meta_result'>Extract the result metadata of a Tplyr table</h2><span id='topic+get_meta_result'></span>

<h3>Description</h3>

<p>Given a row_id value and a result column, this function will return the
tplyr_meta object associated with that 'cell'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta_result(x, row_id, column, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meta_result_+3A_x">x</code></td>
<td>
<p>A built Tplyr table or a dataframe</p>
</td></tr>
<tr><td><code id="get_meta_result_+3A_row_id">row_id</code></td>
<td>
<p>The row_id value of the desired cell, provided as a character
string</p>
</td></tr>
<tr><td><code id="get_meta_result_+3A_column">column</code></td>
<td>
<p>The result column of interest, provided as a character string</p>
</td></tr>
<tr><td><code id="get_meta_result_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a Tplyr table is built with the <code>metadata=TRUE</code> option specified, then
metadata is assembled behind the scenes to provide traceability on each
result cell derived. The functions <code>get_meta_result()</code> and
<code>get_meta_subset()</code> allow you to access that metadata by using an ID provided
in the row_id column and the column name of the result you'd like to access.
The purpose is of the row_id variable instead of a simple row index is to
provide a sort resistant reference of the originating column, so the output
Tplyr table can be sorted in any order but the metadata are still easily
accessible.
</p>
<p>The <code>tplyr_meta</code> object provided a list with two elements - names and
filters. The metadata contain every column from the target data.frame of the
Tplyr table that factored into the specified result cell, and the filters
contains all the necessary filters to subset to data summarized to create the
specified result cell. <code>get_meta_subset()</code> additionally provides a parameter to
specify any additional columns you would like to include in the returned
subset data frame.
</p>


<h3>Value</h3>

<p>A tplyr_meta object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tplyr_table(mtcars, cyl) %&gt;%
  add_layer(
    group_desc(hp)
  )

dat &lt;- t %&gt;% build(metadata = TRUE)

get_meta_result(t, 'd1_1', 'var1_4')

m &lt;- t$metadata
dat &lt;- t$target

get_meta_result(t, 'd1_1', 'var1_4')
</code></pre>

<hr>
<h2 id='get_meta_subset'>Extract the subset of data based on result metadata</h2><span id='topic+get_meta_subset'></span><span id='topic+get_meta_subset.data.frame'></span><span id='topic+get_meta_subset.tplyr_table'></span>

<h3>Description</h3>

<p>Given a row_id value and a result column, this function will return the
subset of data referenced by the tplyr_meta object associated with that
'cell', which provides traceability to tie a result to its source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta_subset(x, row_id, column, add_cols = vars(USUBJID), ...)

## S3 method for class 'data.frame'
get_meta_subset(
  x,
  row_id,
  column,
  add_cols = vars(USUBJID),
  target = NULL,
  pop_data = NULL,
  ...
)

## S3 method for class 'tplyr_table'
get_meta_subset(x, row_id, column, add_cols = vars(USUBJID), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meta_subset_+3A_x">x</code></td>
<td>
<p>A built Tplyr table or a dataframe</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_row_id">row_id</code></td>
<td>
<p>The row_id value of the desired cell, provided as a character
string</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_column">column</code></td>
<td>
<p>The result column of interest, provided as a character string</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_add_cols">add_cols</code></td>
<td>
<p>Additional columns to include in subset data.frame output</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_target">target</code></td>
<td>
<p>A data frame to be subset (if not pulled from a Tplyr table)</p>
</td></tr>
<tr><td><code id="get_meta_subset_+3A_pop_data">pop_data</code></td>
<td>
<p>A data frame to be subset through an anti-join (if not pulled
from a Tplyr table)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a Tplyr table is built with the <code>metadata=TRUE</code> option specified, then
metadata is assembled behind the scenes to provide traceability on each
result cell derived. The functions <code>get_meta_result()</code> and
<code>get_meta_subset()</code> allow you to access that metadata by using an ID provided
in the row_id column and the column name of the result you'd like to access.
The purpose is of the row_id variable instead of a simple row index is to
provide a sort resistant reference of the originating column, so the output
Tplyr table can be sorted in any order but the metadata are still easily
accessible.
</p>
<p>The <code>tplyr_meta</code> object provided a list with two elements - names and
filters. The metadata contain every column from the target data.frame of the
Tplyr table that factored into the specified result cell, and the filters
contains all the necessary filters to subset to data summarized to create the
specified result cell. <code>get_meta_subset()</code> additionally provides a parameter
to specify any additional columns you would like to include in the returned
subset data frame.
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tplyr_table(mtcars, cyl) %&gt;%
  add_layer(
    group_desc(hp)
  )


dat &lt;- t %&gt;% build(metadata = TRUE)

get_meta_subset(t, 'd1_1', 'var1_4', add_cols = dplyr::vars(carb))

m &lt;- t$metadata
dat &lt;- t$target

get_meta_subset(t, 'd1_1', 'var1_4', add_cols = dplyr::vars(carb), target = target)
</code></pre>

<hr>
<h2 id='get_metadata'>Get the metadata dataframe from a tplyr_table</h2><span id='topic+get_metadata'></span>

<h3>Description</h3>

<p>Pull out the metadata dataframe from a tplyr_table to work with it directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metadata_+3A_t">t</code></td>
<td>
<p>A Tplyr table with metadata built</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tplyr metadata dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(wt)
  )

t %&gt;%
  build(metadata=TRUE)

get_metadata(t)
</code></pre>

<hr>
<h2 id='get_numeric_data'>Retrieve the numeric data from a tplyr objects</h2><span id='topic+get_numeric_data'></span>

<h3>Description</h3>

<p><code>get_numeric_data</code> provides access to the un-formatted numeric data for
each of the layers within a <code>tplyr_table</code>, with options to allow you to
extract distinct layers and filter as desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_numeric_data(x, layer = NULL, where = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_numeric_data_+3A_x">x</code></td>
<td>
<p>A tplyr_table or tplyr_layer object</p>
</td></tr>
<tr><td><code id="get_numeric_data_+3A_layer">layer</code></td>
<td>
<p>Layer name or index to select out specifically</p>
</td></tr>
<tr><td><code id="get_numeric_data_+3A_where">where</code></td>
<td>
<p>Subset criteria passed to dplyr::filter</p>
</td></tr>
<tr><td><code id="get_numeric_data_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass forward</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used on a <code>tplyr_table</code> object, this method will aggregate the
numeric data from all Tplyr layers. The data will be returned to the user in
a list of data frames. If the data has already been processed (i.e.
<code>build</code> has been run), the numeric data is already available and will be
returned without reprocessing. Otherwise, the numeric portion of the layer
will be processed.
</p>
<p>Using the layer and where parameters, data for a specific layer can be
extracted and subset. This is most clear when layers are given text names
instead of using a layer index, but a numeric index works as well.
</p>


<h3>Value</h3>

<p>Numeric data from the Tplyr layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

t &lt;- tplyr_table(mtcars, gear) %&gt;%
 add_layer(name='drat',
           group_desc(drat)
 ) %&gt;%
 add_layer(name='cyl',
           group_count(cyl)
 )

 # Return a list of the numeric data frames
 get_numeric_data(t)

 # Get the data from a specific layer
 get_numeric_data(t, layer='drat')
 get_numeric_data(t, layer=1)

 # Choose multiple layers by name or index
 get_numeric_data(t, layer=c('cyl', 'drat'))
 get_numeric_data(t, layer=c(2, 1))

 # Get the data and filter it
 get_numeric_data(t, layer='drat', where = gear==3)

</code></pre>

<hr>
<h2 id='get_precision_by'>Set or return precision_by layer binding</h2><span id='topic+get_precision_by'></span><span id='topic+set_precision_by'></span>

<h3>Description</h3>

<p>The precision_by variables are used to collect the integer and decimal
precision when auto-precision is used. These by variables are used to group
the input data and identify the maximum precision available within the
dataset for each by group. The precision_by variables must be a subset of the
by variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_precision_by(layer)

set_precision_by(layer, precision_by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_precision_by_+3A_layer">layer</code></td>
<td>
<p>A <code>tplyr_layer</code> object</p>
</td></tr>
<tr><td><code id="get_precision_by_+3A_precision_by">precision_by</code></td>
<td>
<p>A string, a variable name, or a list of variable names supplied
using <code>dplyr::vars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_precision_by</code>, the precision_by binding of the supplied
layer. For <code>set_precision_by</code> the modified layer environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)
lay &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(mpg, by=vars(carb, am)) %&gt;%
    set_precision_by(carb)
  )
</code></pre>

<hr>
<h2 id='get_precision_on'>Set or return precision_on layer binding</h2><span id='topic+get_precision_on'></span><span id='topic+set_precision_on'></span>

<h3>Description</h3>

<p>The precision_on variable is the variable used to establish numeric
precision. This variable must be included in the list of <code>target_var</code>
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_precision_on(layer)

set_precision_on(layer, precision_on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_precision_on_+3A_layer">layer</code></td>
<td>
<p>A <code>tplyr_layer</code> object</p>
</td></tr>
<tr><td><code id="get_precision_on_+3A_precision_on">precision_on</code></td>
<td>
<p>A string, a variable name, or a list of variable names
supplied using <code>dplyr::vars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_precision_on</code>, the precision_on binding of the supplied
layer. For <code>set_precision_on</code> the modified layer environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)
lay &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(vars(mpg, disp), by=vars(carb, am)) %&gt;%
    set_precision_on(disp)
  )
</code></pre>

<hr>
<h2 id='get_stats_data'>Get statistics data</h2><span id='topic+get_stats_data'></span>

<h3>Description</h3>

<p>Like the layer numeric data, Tplyr also stores the numeric data produced from
statistics like risk difference. This helper function gives you access to
obtain that data from the environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stats_data(x, layer = NULL, statistic = NULL, where = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stats_data_+3A_x">x</code></td>
<td>
<p>A tplyr_table or tplyr_layer object</p>
</td></tr>
<tr><td><code id="get_stats_data_+3A_layer">layer</code></td>
<td>
<p>Layer name or index to select out specifically</p>
</td></tr>
<tr><td><code id="get_stats_data_+3A_statistic">statistic</code></td>
<td>
<p>Statistic name or index to select</p>
</td></tr>
<tr><td><code id="get_stats_data_+3A_where">where</code></td>
<td>
<p>Subset criteria passed to dplyr::filter</p>
</td></tr>
<tr><td><code id="get_stats_data_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to dispatch</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used on a <code>tplyr_table</code> object, this method will aggregate the
numeric data from all Tplyr layers and calculate all statistics. The data
will be returned to the user in a list of data frames. If the data has
already been processed (i.e. <code>build</code> has been run), the numeric data is
already available and the statistic data will simply be returned. Otherwise,
the numeric portion of the layer will be processed.
</p>
<p>Using the layer, where, and statistic parameters, data for a specific layer
statistic can be extracted and subset, allowing you to directly access data
of interest. This is most clear when layers are given text names instead of
using a layer index, but a numeric index works as well. If just a statistic
is specified, that statistic will be collected and returned in a list of data
frames, allowing you to grab, for example, just the risk difference
statistics across all layers.
</p>


<h3>Value</h3>

<p>The statistics data of the supplied layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(name='drat',
            group_desc(drat)
  ) %&gt;%
  add_layer(name="cyl",
            group_count(cyl)
  ) %&gt;%
  add_layer(name="am",
            group_count(am) %&gt;%
              add_risk_diff(c('4', '3'))
  ) %&gt;%
  add_layer(name="carb",
            group_count(carb) %&gt;%
              add_risk_diff(c('4', '3'))
  )

 # Returns a list of lists, containing stats data from each layer
 get_stats_data(t)

 # Returns just the riskdiff statistics from each layer - NULL
 # for layers without riskdiff
 get_stats_data(t, statistic="riskdiff")

 # Return the statistic data for just the "am" layer - a list
 get_stats_data(t, layer="am")
 get_stats_data(t, layer=3)

 # Return the statistic data for just the "am" and "cyl", layer - a
 # list of lists
 get_stats_data(t, layer=c("am", "cyl"))
 get_stats_data(t, layer=c(3, 2))

 # Return just the statistic data for "am" and "cyl" - a list
 get_stats_data(t, layer=c("am", "cyl"), statistic="riskdiff")
 get_stats_data(t, layer=c(3, 2), statistic="riskdiff")


 # Return the riskdiff for the "am" layer - a data frame
 get_stats_data(t, layer="am", statistic="riskdiff")

 # Return and filter the riskdiff for the am layer - a data frame
 get_stats_data(t, layer="am", statistic="riskdiff", where = summary_var==1)

</code></pre>

<hr>
<h2 id='get_target_var'>Set or return treat_var binding</h2><span id='topic+get_target_var'></span><span id='topic+set_target_var'></span>

<h3>Description</h3>

<p>Set or return treat_var binding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_var(layer)

set_target_var(layer, target_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_target_var_+3A_layer">layer</code></td>
<td>
<p>A <code>tplyr_layer</code> object</p>
</td></tr>
<tr><td><code id="get_target_var_+3A_target_var">target_var</code></td>
<td>
<p>A symbol to perform the analysis on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>treat_var</code>, the treatment variable binding of the layer
object. For <code>set_treat_var</code>, the modified layer environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)
iris$Species2 &lt;- iris$Species
lay &lt;- tplyr_table(iris, Species) %&gt;%
  group_count(Species) %&gt;%
  set_target_var(Species2)
</code></pre>

<hr>
<h2 id='get_tplyr_regex'>Retrieve one of Tplyr's regular expressions</h2><span id='topic+get_tplyr_regex'></span>

<h3>Description</h3>

<p>This function allows you to extract important regular expressions used inside
Tplyr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tplyr_regex(rx = c("format_string", "format_group"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tplyr_regex_+3A_rx">rx</code></td>
<td>
<p>A character string with either the value 'format_string' or
'format_group'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two important regular expressions used within Tplyr. The
format_string expression is the expression to parse format strings. This is
what is used to make sense out of strings like 'xx (XX.x%)' or 'a+1 (A.a+2)'
by inferring what the user is specifying about number formatting.
</p>
<p>The 'format_group' regex is the opposite of this, and when given a string of
numbers, such as ' 5 (34%) [9]' will return the separate segments of numbers
broken into their format groups, which in this example would be ' 5',
'(34%)', and '[9]'.
</p>


<h3>Value</h3>

<p>A regular expression object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_tplyr_regex('format_string')

get_tplyr_regex('format_group')

</code></pre>

<hr>
<h2 id='get_where.tplyr_layer'>Set or return where binding for layer or table</h2><span id='topic+get_where.tplyr_layer'></span><span id='topic+set_where.tplyr_layer'></span><span id='topic+get_where'></span><span id='topic+get_where.tplyr_table'></span><span id='topic+set_where'></span><span id='topic+set_where.tplyr_table'></span><span id='topic+set_pop_where'></span><span id='topic+get_pop_where'></span>

<h3>Description</h3>

<p>Set or return where binding for layer or table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tplyr_layer'
get_where(obj)

## S3 method for class 'tplyr_layer'
set_where(obj, where)

get_where(obj)

## S3 method for class 'tplyr_table'
get_where(obj)

set_where(obj, where)

## S3 method for class 'tplyr_table'
set_where(obj, where)

set_pop_where(obj, where)

get_pop_where(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_where.tplyr_layer_+3A_obj">obj</code></td>
<td>
<p>A <code>tplyr_layer</code> or <code>tplyr_table</code> object.</p>
</td></tr>
<tr><td><code id="get_where.tplyr_layer_+3A_where">where</code></td>
<td>
<p>An expression (i.e. syntax) to be used to subset the data.
Supply as programming logic (i.e. x &lt; 5 &amp; y == 10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>where</code>, the where binding of the supplied object.
For <code>set_where</code>, the modified object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

iris$Species2 &lt;- iris$Species
lay &lt;- tplyr_table(iris, Species) %&gt;%
  group_count(Species) %&gt;%
  set_where(Petal.Length &gt; 3) %&gt;%
  # Set logic for pop_data as well
  set_pop_where(Petal.Length &gt; 3)

</code></pre>

<hr>
<h2 id='group_count'>Create a <code>count</code>, <code>desc</code>, or <code>shift</code> layer for discrete count
based summaries, descriptive statistics summaries, or shift count summaries</h2><span id='topic+group_count'></span><span id='topic+group_desc'></span><span id='topic+group_shift'></span>

<h3>Description</h3>

<p>This family of functions specifies the type of summary that is
to be performed within a layer. <code>count</code> layers are used to create
summary counts of some discrete variable. <code>desc</code> layers create summary
statistics, and <code>shift</code> layers summaries the counts of different
changes in states. See the &quot;details&quot; section below for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_count(parent, target_var, by = vars(), where = TRUE, ...)

group_desc(parent, target_var, by = vars(), where = TRUE, ...)

group_shift(parent, target_var, by = vars(), where = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_count_+3A_parent">parent</code></td>
<td>
<p>Required. The parent environment of the layer. This must be the
<code>tplyr_table</code> object that the layer is contained within.</p>
</td></tr>
<tr><td><code id="group_count_+3A_target_var">target_var</code></td>
<td>
<p>Symbol. Required, The variable name(s) on which the summary
is to be performed. Must be a variable within the target dataset. Enter
unquoted - i.e. target_var = AEBODSYS. You may also provide multiple
variables with <code><a href="dplyr.html#topic+vars">vars</a></code>.</p>
</td></tr>
<tr><td><code id="group_count_+3A_by">by</code></td>
<td>
<p>A string, a variable name, or a list of variable names supplied
using <code><a href="dplyr.html#topic+vars">vars</a></code></p>
</td></tr>
<tr><td><code id="group_count_+3A_where">where</code></td>
<td>
<p>Call. Filter logic used to subset the target data when
performing a summary.</p>
</td></tr>
<tr><td><code id="group_count_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass forward</p>
</td></tr>
</table>


<h3>Details</h3>

 <dl>
<dt>Count Layers</dt><dd><p>Count layers allow you to create
summaries based on counting values with a variable. Additionally, this
layer allows you to create n (%) summaries where you're also summarizing
the proportion of instances a value occurs compared to some denominator.
Count layers are also capable of producing counts of nested relationships.
For example, if you want to produce counts of an overall outside group, and
then the subgroup counts within that group, you can specify the target
variable as vars(OutsideVariable, InsideVariable). This allows you to do
tables like Adverse Events where you want to see the Preferred Terms within
Body Systems, all in one layer. Further control over denominators is
available using the function <code><a href="#topic+set_denoms_by">set_denoms_by</a></code> and distinct
counts can be set using <code><a href="#topic+set_distinct_by">set_distinct_by</a></code></p>
</dd> <dt>Descriptive
Statistics Layers</dt><dd><p>Descriptive statistics layers perform summaries on
continuous variables. There are a number of summaries built into Tplyr
already that you can perform, including n, mean, median, standard
deviation, variance, min, max, inter-quartile range, Q1, Q3, and missing
value counts. From these available summaries, the default presentation of a
descriptive statistic layer will output 'n', 'Mean (SD)', 'Median', 'Q1, Q3',
'Min, Max', and 'Missing'. You can change these summaries using
<code><a href="#topic+set_format_strings">set_format_strings</a></code>, and you can also add your own summaries
using <code><a href="#topic+set_custom_summaries">set_custom_summaries</a></code>. This allows you to implement any
additional summary statistics you want presented.</p>
</dd> <dt>Shift Layers</dt><dd><p>A
shift layer displays an endpoint's 'shift' throughout the duration of the
study. It is an abstraction over the count layer, however we have provided
an interface that is more efficient and intuitive. Targets are passed as
named symbols using <code>dplyr::vars</code>. Generally the baseline is passed
with the name 'row' and the shift is passed with the name 'column'. Both
counts (n) and percentages (pct) are supported and can be specified with
the <code><a href="#topic+set_format_strings">set_format_strings</a></code> function. To allow for flexibility
when defining percentages, you can define the denominator using the
<code><a href="#topic+set_denoms_by">set_denoms_by</a></code> function. This function takes variable names and
uses those to determine the denominator for the counts.</p>
</dd> </dl>



<h3>Value</h3>

<p>An <code>tplyr_layer</code> environment that is a child of the specified
parent. The environment contains the object as listed below.
</p>
<p>A <code>tplyr_layer</code> object
</p>


<h3>See Also</h3>

<p>[<a href="#topic+add_layer">add_layer</a>, <a href="#topic+add_layers">add_layers</a>, <a href="#topic+tplyr_table">tplyr_table</a>, <a href="#topic+tplyr_layer">tplyr_layer</a>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

t &lt;- tplyr_table(iris, Species) %&gt;%
  add_layer(
    group_desc(target_var=Sepal.Width)
  )

t &lt;- tplyr_table(iris, Species) %&gt;%
  add_layer(
    group_desc(target_var=Sepal.Width)
  )

t &lt;- tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl)
  )
</code></pre>

<hr>
<h2 id='header_n'>Return or set header_n binding</h2><span id='topic+header_n'></span><span id='topic+header_n+3C-'></span><span id='topic+set_header_n'></span>

<h3>Description</h3>

<p>The 'header_n()' functions can be used to automatically pull the header_n
derivations from the table or change them for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header_n(table)

header_n(x) &lt;- value

set_header_n(table, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header_n_+3A_table">table</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="header_n_+3A_x">x</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="header_n_+3A_value">value</code></td>
<td>
<p>A data.frame with columns with the treatment variable, column
variabes, and a variable with counts named 'n'.</p>
</td></tr>
<tr><td><code id="header_n_+3A_header_n">header_n</code></td>
<td>
<p>A data.frame with columns with the treatment variable, column
variabes, and a variable with counts named 'n'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'header_n' object is created by Tplyr when a table is built and intended
to be used by the 'add_column_headers()' function when displaying table level
population totals. These methods are intended to be used for calling the
population totals calculated by Tplyr, and to overwrite them if a user
chooses to.
</p>
<p>If you have a need to change the header Ns that appear in your table headers,
say you know you are working with a subset of the data that doesn't represent
the totals, you can replace the data used with 'set_header_n()'.
</p>


<h3>Value</h3>

<p>For <code>tplyr_header_n</code> the header_n binding of the
<code>tplyr_table</code> object. For <code>tplyr_header_n&lt;-</code> and
<code>set_tplyr_header_n</code> the modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(mtcars, gear)

header_n(tab) &lt;- data.frame(
  gear = c(3, 4, 5),
  n = c(10, 15, 45)
)



</code></pre>

<hr>
<h2 id='keep_levels'>Select levels to keep in a count layer</h2><span id='topic+keep_levels'></span>

<h3>Description</h3>

<p>In certain cases you only want a layer to include certain values of a factor.
The 'keep_levels()' function allows you to pass character values to be
included in the layer. The others are ignored.
**NOTE: Denominator calculation is unaffected by this function, see the
examples on how to include this logic in your percentages'**
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_levels(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_levels_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="keep_levels_+3A_...">...</code></td>
<td>
<p>Character values to count int he layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Tplyr layer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
mtcars &lt;- mtcars %&gt;%
  mutate_all(as.character)

t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      keep_levels("4", "8") %&gt;%
      set_denom_where(cyl %in% c("4", "8"))
 ) %&gt;%
 build()

</code></pre>

<hr>
<h2 id='new_layer_template'>Create, view, extract, remove, and use Tplyr layer templates</h2><span id='topic+new_layer_template'></span><span id='topic+remove_layer_template'></span><span id='topic+get_layer_template'></span><span id='topic+get_layer_templates'></span><span id='topic+use_template'></span>

<h3>Description</h3>

<p>There are several scenarios where a layer template may be useful. Some
tables, like demographics tables, may have many layers that will all
essentially look the same. Categorical variables will have the same count
layer settings, and continuous variables will have the same desc layer
settings. A template allows a user to build those settings once per layer,
then reference the template when the Tplyr table is actually built.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_layer_template(name, template)

remove_layer_template(name)

get_layer_template(name)

get_layer_templates()

use_template(name, ..., add_params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_layer_template_+3A_name">name</code></td>
<td>
<p>Template name</p>
</td></tr>
<tr><td><code id="new_layer_template_+3A_template">template</code></td>
<td>
<p>Template layer syntax, starting with a layer constructor
<code>group_count|desc|shift</code>. This function should be called with an ellipsis
argument (i.e. group_count(...)).</p>
</td></tr>
<tr><td><code id="new_layer_template_+3A_...">...</code></td>
<td>
<p>Arguments passed directly into a layer constructor, matching the
target, by, and where parameters.</p>
</td></tr>
<tr><td><code id="new_layer_template_+3A_add_params">add_params</code></td>
<td>
<p>Additional parameters passed into layer modifier functions.
These arguments are specified in a template within curly brackets such as
{param}. Supply as a named list, where the element name is the parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This suite of functions allows a user to create and use layer templates.
Layer templates allow a user to pre-build and reuse an entire layer
configuration, from the layer constructor down to all modifying functions.
Furthermore, users can specify parameters they may want to be
interchangeable. Additionally, layer templates are extensible, so a template
can be use and then further extended with additional layer modifying
functions.
</p>
<p>Layers are created using <code>new_layer_template()</code>. To use a layer, use the
function <code>use_template()</code> in place of <code>group_count|desc|shift()</code>. If you want
to view a specific template, use <code>get_layer_template()</code>. If you want to view
all templates, use <code>get_layer_templates()</code>. And to remove a layer template use
<code>remove_layer_template()</code>. Layer templates themselves are stored in the
option <code>tplyr.layer_templates</code>, but a user should not access this directly
and instead use the Tplyr supplied functions.
</p>
<p>When providing the template layer syntax, the layer must start with a layer
constructor. These are one of the function <code>group_count()</code>, <code>group_desc()</code>,
or <code>group_shift()</code>. Instead of passing arguments into these function,
templates are specified using an ellipsis in the constructor, i.e.
<code>group_count(...)</code>. This is required, as after the template is built a user
supplies these arguments via <code>use_template()</code>
</p>
<p><code>use_template()</code> takes the <code>group_count|desc|shift()</code> arguments by default.
If a user specified additional arguments in the template, these are provided
in a list throught the argument <code>add_params</code>. Provide these arguments exactly
as you would in a normal layer. When creating the template, these parameters
can be specified by using curly brackets. See the examples for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
op &lt;- options()

new_layer_template(
  "example_template",
  group_count(...) %&gt;%
    set_format_strings(f_str('xx (xx%)', n, pct))
)

get_layer_templates()

get_layer_template("example_template")

tplyr_table(mtcars, vs) %&gt;%
  add_layer(
    use_template("example_template", gear)
  ) %&gt;%
  build()

remove_layer_template("example_template")

new_layer_template(
  "example_template",
  group_count(...) %&gt;%
    set_format_strings(f_str('xx (xx%)', n, pct)) %&gt;%
    set_order_count_method({sort_meth}) %&gt;%
    set_ordering_cols({sort_cols})
)

get_layer_template("example_template")

tplyr_table(mtcars, vs) %&gt;%
  add_layer(
    use_template("example_template", gear, add_params =
                   list(
                     sort_meth = "bycount",
                     sort_cols = `1`
                   ))
  ) %&gt;%
  build()

remove_layer_template("example_template")

options(op)
</code></pre>

<hr>
<h2 id='pop_data'>Return or set population data bindings</h2><span id='topic+pop_data'></span><span id='topic+pop_data+3C-'></span><span id='topic+set_pop_data'></span>

<h3>Description</h3>

<p>The population data is used to gather information that may not be available
from the target dataset. For example, missing treatment groups, population N
counts, and proper N counts for denominators will be provided through the
population dataset. The population dataset defaults to the target dataset
unless otherwise specified using <code>set_pop_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_data(table)

pop_data(x) &lt;- value

set_pop_data(table, pop_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_data_+3A_table">table</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="pop_data_+3A_x">x</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="pop_data_+3A_value">value</code></td>
<td>
<p>A data.frame with population level information</p>
</td></tr>
<tr><td><code id="pop_data_+3A_pop_data">pop_data</code></td>
<td>
<p>A data.frame with population level information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>tplyr_pop_data</code> the pop_data binding of the
<code>tplyr_table</code> object. For <code>tplyr_pop_data&lt;-</code> nothing is returned,
the pop_data binding is set silently. For <code>set_tplyr_pop_data</code> the
modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(iris, Species)

pop_data(tab) &lt;- mtcars

tab &lt;- tplyr_table(iris, Species) %&gt;%
  set_pop_data(mtcars)
</code></pre>

<hr>
<h2 id='pop_treat_var'>Return or set pop_treat_var binding</h2><span id='topic+pop_treat_var'></span><span id='topic+set_pop_treat_var'></span>

<h3>Description</h3>

<p>The treatment variable used in the target data may be different than the
variable within the population dataset. <code>set_pop_treat_var</code> allows you
to change this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_treat_var(table)

set_pop_treat_var(table, pop_treat_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_treat_var_+3A_table">table</code></td>
<td>
<p>A <code>tplyr_table</code> object</p>
</td></tr>
<tr><td><code id="pop_treat_var_+3A_pop_treat_var">pop_treat_var</code></td>
<td>
<p>Variable containing treatment group assignments within the <code>pop_data</code> binding. Supply unquoted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>tplyr_pop_treat_var</code> the pop_treat_var binding of the
<code>tplyr_table</code> object. For <code>set_tplyr_pop_treat_var</code> the modified
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(iris, Species)

pop_data(tab) &lt;- mtcars
set_pop_treat_var(tab, mpg)

</code></pre>

<hr>
<h2 id='process_formatting'>Process layers to get formatted and pivoted tables.</h2><span id='topic+process_formatting'></span>

<h3>Description</h3>

<p>This is an internal method, but is exported to support S3 dispatch. Not intended for direct use by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_formatting(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_formatting_+3A_x">x</code></td>
<td>
<p>A tplyr_layer object</p>
</td></tr>
<tr><td><code id="process_formatting_+3A_...">...</code></td>
<td>
<p>arguments passed to dispatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formatted_table object that is bound to the layer
</p>

<hr>
<h2 id='process_metadata'>Process layers to get metadata tables</h2><span id='topic+process_metadata'></span>

<h3>Description</h3>

<p>This is an internal method, but is exported to support S3 dispatch. Not intended for direct use by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_metadata(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_metadata_+3A_x">x</code></td>
<td>
<p>A tplyr_layer object</p>
</td></tr>
<tr><td><code id="process_metadata_+3A_...">...</code></td>
<td>
<p>arguments passed to dispatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formatted_meta object that is bound to the layer
</p>

<hr>
<h2 id='process_statistic_data'>Process a tplyr_statistic object</h2><span id='topic+process_statistic_data'></span>

<h3>Description</h3>

<p>This is an internal function that is not meant for use externally, but must be exported.
Use with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_statistic_data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_statistic_data_+3A_x">x</code></td>
<td>
<p>A tplyr_statistic environment</p>
</td></tr>
<tr><td><code id="process_statistic_data_+3A_...">...</code></td>
<td>
<p>Additional pass through parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric statistc data from a tplyr statistc
</p>

<hr>
<h2 id='process_statistic_formatting'>Process string formatting on a tplyr_statistic object</h2><span id='topic+process_statistic_formatting'></span>

<h3>Description</h3>

<p>This is an internal function that is not meant for use externally, but must be exported.
Use with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_statistic_formatting(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_statistic_formatting_+3A_x">x</code></td>
<td>
<p>A tplyr_statistic environment</p>
</td></tr>
<tr><td><code id="process_statistic_formatting_+3A_...">...</code></td>
<td>
<p>Additional pass through parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted tplyr_statistic data
</p>

<hr>
<h2 id='process_summaries'>Process layers to get numeric results of layer</h2><span id='topic+process_summaries'></span>

<h3>Description</h3>

<p>This is an internal method, but is exported to support S3 dispatch. Not intended for direct use by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_summaries(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_summaries_+3A_x">x</code></td>
<td>
<p>a tplyr_layer object</p>
</td></tr>
<tr><td><code id="process_summaries_+3A_...">...</code></td>
<td>
<p>arguments passed to dispatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tplyr_layer object with a 'built_table' binding
</p>

<hr>
<h2 id='replace_leading_whitespace'>Reformat strings with leading whitespace for HTML</h2><span id='topic+replace_leading_whitespace'></span>

<h3>Description</h3>

<p>Reformat strings with leading whitespace for HTML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_leading_whitespace(x, tab_width = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_leading_whitespace_+3A_x">x</code></td>
<td>
<p>Target string</p>
</td></tr>
<tr><td><code id="replace_leading_whitespace_+3A_tab_width">tab_width</code></td>
<td>
<p>Number of spaces to compensate for tabs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with &amp;nbsp; replaced for leading whitespace
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(" Hello there", "  Goodbye Friend ",  "\tNice to meet you",
"  \t What are you up to? \t \t ")
replace_leading_whitespace(x)

replace_leading_whitespace(x, tab=2)

</code></pre>

<hr>
<h2 id='set_custom_summaries'>Set custom summaries to be performed within a descriptive statistics layer</h2><span id='topic+set_custom_summaries'></span>

<h3>Description</h3>

<p>This function allows a user to define custom summaries to be performed in a
call to <code>dplyr::summarize()</code>. A custom summary by the same name as a
default summary will override the default. This allows the user to override
the default behavior of summaries built into 'Tplyr', while also adding new
desired summary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_custom_summaries(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_custom_summaries_+3A_e">e</code></td>
<td>
<p><code>desc</code> layer on which the summaries should be bound</p>
</td></tr>
<tr><td><code id="set_custom_summaries_+3A_...">...</code></td>
<td>
<p>Named parameters containing syntax to be used in a call to
<code>dplyr::summarize()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When programming the logic of the summary function, use the variable name
<code>.var</code> to within your summary functions. This allows you apply the
summary function to each variable when multiple target variables are
declared.
</p>
<p>An important, yet not immediately obvious, part of using
<code>set_custom_summaries</code> is to understand the link between the named
parameters you set in <code>set_custom_summaries</code> and the names called in
<code><a href="#topic+f_str">f_str</a></code> objects within <code><a href="#topic+set_format_strings">set_format_strings</a></code>. In
<code><a href="#topic+f_str">f_str</a></code>, after you supply the string format you'd like your
numbers to take, you specify the summaries that fill those strings.
</p>
<p>When you go to set your format strings, the name you use to declare a summary
in <code>set_custom_summaries</code> is the same name that you use in your
<code><a href="#topic+f_str">f_str</a></code> call. This is necessary because
<code><a href="#topic+set_format_strings">set_format_strings</a></code> needs some means of putting two summaries in
the same value, and setting a row label for the summary being performed.
</p>
<p>Review the examples to see this put into practice. Note the relationship
between the name created in <code>set_custom_summaries</code> and the name used in
<code><a href="#topic+set_format_strings">set_format_strings</a></code> within the <code><a href="#topic+f_str">f_str</a></code> call
</p>


<h3>Value</h3>

<p>Binds a variable <code>custom_summaries</code> to the specified layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load in pipe
library(magrittr)

tplyr_table(iris, Species) %&gt;%
  add_layer(
    group_desc(Sepal.Length, by = "Sepal Length") %&gt;%
      set_custom_summaries(
        geometric_mean = exp(sum(log(.var[.var &gt; 0]),
                                     na.rm=TRUE) / length(.var))
      ) %&gt;%
      set_format_strings(
        'Geometric Mean' = f_str('xx.xx', geometric_mean)
      )
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_denom_ignore'>Set values the denominator calculation will ignore</h2><span id='topic+set_denom_ignore'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;defunct&quot;)'
</p>
<p>This is generally used for missing values. Values like &quot;&quot;, NA, &quot;NA&quot; are
common ways missing values are presented in a data frame. In certain cases,
percentages do not use &quot;missing&quot; values in the denominator. This function
notes different values as &quot;missing&quot; and excludes them from the denominators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_denom_ignore(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_denom_ignore_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_denom_ignore_+3A_...">...</code></td>
<td>
<p>Values to exclude from the percentage calculation. If you use
'set_missing_counts()' this should be the name of the parameters instead of
the values, see the example below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified layer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
mtcars2 &lt;- mtcars
mtcars2[mtcars$cyl == 6, "cyl"] &lt;- NA
mtcars2[mtcars$cyl == 8, "cyl"] &lt;- "Not Found"

tplyr_table(mtcars2, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_missing_count(f_str("xx ", n), Missing = c(NA, "Not Found"))
      # This function is currently deprecated. It was replaced with an
      # argument in set_missing_count
      # set_denom_ignore("Missing")
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_denom_where'>Set Logic for denominator subsetting</h2><span id='topic+set_denom_where'></span>

<h3>Description</h3>

<p>By default, denominators in count layers are subset based on the layer level
where logic. In some cases this might not be correct. This functions allows
the user to override this behavior and pass custom logic that will be used to
subset the target dataset when calculating denominators for the layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_denom_where(e, denom_where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_denom_where_+3A_e">e</code></td>
<td>
<p>A <code>count_layer/shift_layer</code> object</p>
</td></tr>
<tr><td><code id="set_denom_where_+3A_denom_where">denom_where</code></td>
<td>
<p>An expression (i.e. syntax) to be used to subset the
target dataset for calculating layer denominators. Supply as programming
logic (i.e. x &lt; 5 &amp; y == 10). To remove the layer where parameter
subsetting for the total row and thus the percentage denominators,
pass 'TRUE' to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Tplyr layer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
t10 &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl, where = cyl != 6) %&gt;%
    set_denom_where(TRUE)
    # The denominators will be based on all of the values, including 6
  ) %&gt;%
 build()

</code></pre>

<hr>
<h2 id='set_denoms_by'>Set variables used in pct denominator calculation</h2><span id='topic+set_denoms_by'></span>

<h3>Description</h3>

<p>This function is used when calculating pct in count or shift layers. The
percentages default to the treatment variable and any column variables but
can be calculated on any variables passed to target_var, treat_var, by, or
cols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_denoms_by(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_denoms_by_+3A_e">e</code></td>
<td>
<p>A count/shift layer object</p>
</td></tr>
<tr><td><code id="set_denoms_by_+3A_...">...</code></td>
<td>
<p>Unquoted variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified layer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# Default has matrix of treatment group, additional columns,
# and by variables sum to 1
tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl) %&gt;%
      set_format_strings(f_str("xxx (xx.xx%)", n, pct))
  ) %&gt;%
  build()

tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl) %&gt;%
      set_format_strings(f_str("xxx (xx.xx%)", n, pct)) %&gt;%
      set_denoms_by(cyl, gear) # Row % sums to 1
  ) %&gt;%
  build()

tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl) %&gt;%
      set_format_strings(f_str("xxx (xx.xx%)", n, pct)) %&gt;%
      set_denoms_by(cyl, gear, am) # % within treatment group sums to 1
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_distinct_by'>Set counts to be distinct by some grouping variable.</h2><span id='topic+set_distinct_by'></span>

<h3>Description</h3>

<p>In some situations, count summaries may want to see distinct counts by a
variable like subject. For example, the number of subjects in a population
who had a particular adverse event. <code>set_distinct_by</code> allows you to set
the by variables used to determine a distinct count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_distinct_by(e, distinct_by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_distinct_by_+3A_e">e</code></td>
<td>
<p>A <code>count_layer/shift_layer</code> object</p>
</td></tr>
<tr><td><code id="set_distinct_by_+3A_distinct_by">distinct_by</code></td>
<td>
<p>Variable(s) to get the distinct data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a <code>distinct_by</code> value is set, distinct counts will be used by
default. If you wish to combine distinct and not distinct counts, you can
choose which to display in your <code>f_str()</code> objects using <code>n</code>,
<code>pct</code>, <code>distinct_n</code>, and <code>distinct_pct</code>. Additionally, denominators
may be presented using <code>total</code> and <code>distinct_total</code>
</p>


<h3>Value</h3>

<p>The layer object with
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load in pipe
library(magrittr)

tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_distinct_by(carb)
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_format_strings'>Set the format strings and associated summaries to be performed in a layer</h2><span id='topic+set_format_strings'></span><span id='topic+set_format_strings.desc_layer'></span><span id='topic+set_format_strings.count_layer'></span>

<h3>Description</h3>

<p>'Tplyr' gives you extensive control over how strings are presented.
<code>set_format_strings</code> allows you to apply these string formats to your
layer. This behaves slightly differently between layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_format_strings(e, ...)

## S3 method for class 'desc_layer'
set_format_strings(e, ..., cap = getOption("tplyr.precision_cap"))

## S3 method for class 'count_layer'
set_format_strings(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_format_strings_+3A_e">e</code></td>
<td>
<p>Layer on which to bind format strings</p>
</td></tr>
<tr><td><code id="set_format_strings_+3A_...">...</code></td>
<td>
<p>Named parameters containing calls to <code>f_str</code> to set the format strings</p>
</td></tr>
<tr><td><code id="set_format_strings_+3A_cap">cap</code></td>
<td>
<p>A named character vector containing an 'int' element for the cap
on integer precision, and a 'dec' element for the cap on decimal precision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Format strings are one of the most powerful components of 'Tplyr'.
Traditionally, converting numeric values into strings for presentation can
consume a good deal of time. Values and decimals need to align between
rows, rounding before trimming is sometimes forgotten - it can become a
tedious mess that, in the grand scheme of things, is not an important part
of the analysis being performed. 'Tplyr' makes this process as simple as we
can, while still allowing flexibility to the user.
</p>
<p>In a count layer, you can simply provide a single <code><a href="#topic+f_str">f_str</a></code>
object to specify how you want your n's, percentages, and denominators formatted.
If you are additionally supplying a statistic, like risk difference using
<code><a href="#topic+add_risk_diff">add_risk_diff</a></code>, you specify the count formats using the name
'n_counts'. The risk difference formats would then be specified using the
name 'riskdiff'. In a descriptive statistic layer,
<code>set_format_strings</code> allows you to do a couple more things:
</p>

<ul>
<li><p>By naming parameters with character strings, those character strings
become a row label in the resulting data frame
</p>
</li>
<li><p>The actual summaries that are performed come from the variable names
used within the <code><a href="#topic+f_str">f_str</a></code> calls
</p>
</li>
<li><p>Using multiple summaries (declared by your <code><a href="#topic+f_str">f_str</a></code>
calls), multiple summary values can appear within the same line. For
example, to present &quot;Mean (SD)&quot; like displays.
</p>
</li>
<li><p>Format strings in the desc layer also allow you to configure how
empty values should be presented. In the <code>f_str</code> call, use the
<code>empty</code> parameter to specify how missing values should present. A
single element character vector should be provided. If the vector is
unnamed, that value will be used in the format string and fill the space
similar to how the numbers will display. Meaning - if your empty string is
'NA' and your format string is 'xx (xxx)', the empty values will populate
as 'NA ( NA)'. If you name the character vector in the 'empty' parameter
'.overall', like <code>empty = c(.overall='')</code>, then that exact string will
fill the value instead. For example, providing 'NA' will instead create the
formatted string as 'NA' exactly.
</p>
</li></ul>

<p>See the <code><a href="#topic+f_str">f_str</a></code> documentation for more details about how this
implementation works.
</p>


<h3>Value</h3>

<p>The layer environment with the format string binding added
</p>
<p>tplyr_layer object with formats attached
</p>
<p>Returns the modified layer object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

# In a count layer
tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_format_strings(f_str('xx (xx%)', n, pct))
  ) %&gt;%
  build()

# In a descriptive statistics layer
tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(mpg) %&gt;%
      set_format_strings(
        "n"         = f_str("xx", n),
        "Mean (SD)" = f_str("xx.x", mean, empty='NA'),
        "SD"        = f_str("xx.xx", sd),
        "Median"    = f_str("xx.x", median),
        "Q1, Q3"    = f_str("xx, xx", q1, q3, empty=c(.overall='NA')),
        "Min, Max"  = f_str("xx, xx", min, max),
        "Missing"   = f_str("xx", missing)
      )
  ) %&gt;%
  build()

# In a shift layer
tplyr_table(mtcars, am) %&gt;%
  add_layer(
    group_shift(vars(row=gear, column=carb), by=cyl) %&gt;%
    set_format_strings(f_str("xxx (xx.xx%)", n, pct))
  ) %&gt;%
  build()

</code></pre>

<hr>
<h2 id='set_indentation'>Set the option to prefix the row_labels in the inner count_layer</h2><span id='topic+set_indentation'></span>

<h3>Description</h3>

<p>When a count layer uses nesting (i.e. triggered by <code><a href="#topic+set_nest_count">set_nest_count</a></code>),
the <code>indentation</code> argument's value will be used as a prefix for the inner layer's
records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_indentation(e, indentation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_indentation_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_indentation_+3A_indentation">indentation</code></td>
<td>
<p>A character to prefix the row labels in an inner
count layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified count_layer environment
</p>

<hr>
<h2 id='set_limit_data_by'>Set variables to limit reported data values only to those that exist rather
than fully completing all possible levels</h2><span id='topic+set_limit_data_by'></span>

<h3>Description</h3>

<p>This function allows you to select a combination of by variables or
potentially target variables for which you only want to display values
present in the data. By default, Tplyr will create a cartesian combination of
potential values of the data. For example, if you have 2 by variables
present, then each potential combination of those by variables will have a
row present in the final table. <code>set_limit_data_by()</code> allows you to choose
the by variables whose combination you wish to limit to values physically
present in the available data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_limit_data_by(e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_limit_data_by_+3A_e">e</code></td>
<td>
<p>A tplyr_layer</p>
</td></tr>
<tr><td><code id="set_limit_data_by_+3A_...">...</code></td>
<td>
<p>Subset of variables within by or target variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tplyr_table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tplyr_table(tplyr_adpe, TRT01A) %&gt;%
  add_layer(
    group_desc(AVAL, by = vars(PECAT, PARAM, AVISIT))
  ) %&gt;%
  build()

tplyr_table(tplyr_adpe, TRT01A) %&gt;%
  add_layer(
    group_desc(AVAL, by = vars(PECAT, PARAM, AVISIT)) %&gt;%
      set_limit_data_by(PARAM, AVISIT)
  ) %&gt;%
  build()

tplyr_table(tplyr_adpe, TRT01A) %&gt;%
  add_layer(
    group_count(AVALC, by = vars(PECAT, PARAM, AVISIT)) %&gt;%
      set_limit_data_by(PARAM, AVISIT)
  ) %&gt;%
  build()

tplyr_table(tplyr_adpe, TRT01A) %&gt;%
  add_layer(
    group_count(AVALC, by = vars(PECAT, PARAM, AVISIT)) %&gt;%
      set_limit_data_by(PECAT, PARAM, AVISIT)
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_missing_count'>Set the display for missing strings</h2><span id='topic+set_missing_count'></span>

<h3>Description</h3>

<p>Controls how missing counts are handled and displayed in the layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_missing_count(e, fmt = NULL, sort_value = NULL, denom_ignore = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_missing_count_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_missing_count_+3A_fmt">fmt</code></td>
<td>
<p>An f_str object to change the display of the missing counts</p>
</td></tr>
<tr><td><code id="set_missing_count_+3A_sort_value">sort_value</code></td>
<td>
<p>A numeric value that will be used in the ordering column.
This should be numeric. If it is not supplied the ordering column will be
the maximum value of what appears in the table plus one.</p>
</td></tr>
<tr><td><code id="set_missing_count_+3A_denom_ignore">denom_ignore</code></td>
<td>
<p>A boolean. Specifies Whether or not to include the
missing counts specified within the ... parameter within denominators. If
set to TRUE, the values specified within ... will be ignored.</p>
</td></tr>
<tr><td><code id="set_missing_count_+3A_...">...</code></td>
<td>
<p>Parameters used to note which values to describe as missing.
Generally NA and &quot;Missing&quot; would be used here. Parameters can be named
character vectors where the names become the row label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(dplyr)
  mtcars2 &lt;- mtcars %&gt;%
mutate_all(as.character)
mtcars2[mtcars$cyl == 6, "cyl"] &lt;- NA

tplyr_table(mtcars2, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_missing_count(f_str("xx ", n), Missing = NA)
  ) %&gt;%
  build()
</code></pre>

<hr>
<h2 id='set_missing_subjects_row_label'>Set the label for the missing subjects row</h2><span id='topic+set_missing_subjects_row_label'></span>

<h3>Description</h3>

<p>Set the label for the missing subjects row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_missing_subjects_row_label(e, missing_subjects_row_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_missing_subjects_row_label_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_missing_subjects_row_label_+3A_missing_subjects_row_label">missing_subjects_row_label</code></td>
<td>
<p>A character to label the total row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code>count_layer</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      add_missing_subjects_row() %&gt;%
      set_missing_subjects_row_label("Missing")
  )
build(t)
</code></pre>

<hr>
<h2 id='set_nest_count'>Set the option to nest count layers</h2><span id='topic+set_nest_count'></span>

<h3>Description</h3>

<p>If set to TRUE, the second variable specified in <code>target_var</code>
will be nested inside of the first variable. This allows you to create
displays like those commonly used in adverse event tables, where
one column holds both the labels of the outer categorical variable
and the inside event variable (i.e. AEBODSYS and AEDECOD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_nest_count(e, nest_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_nest_count_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_nest_count_+3A_nest_count">nest_count</code></td>
<td>
<p>A logical value to set the nest option</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified layer
</p>

<hr>
<h2 id='set_numeric_threshold'>Set a numeric cutoff</h2><span id='topic+set_numeric_threshold'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>In certain tables, it may be necessary to only include rows that meet numeric
conditions. Rows that are less than a certain cutoff can be suppressed from
the output. This function allows you to pass a cutoff, a cutoff stat(n,
distinct_n, pct, or distinct_pct) to supress values that are lesser than the
cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_numeric_threshold(e, numeric_cutoff, stat, column = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_numeric_threshold_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_numeric_threshold_+3A_numeric_cutoff">numeric_cutoff</code></td>
<td>
<p>A numeric value where only values greater than or equal
to will be displayed.</p>
</td></tr>
<tr><td><code id="set_numeric_threshold_+3A_stat">stat</code></td>
<td>
<p>The statistic to use when filtering out rows. Either 'n',
'distinct_n', or 'pct' are allowable</p>
</td></tr>
<tr><td><code id="set_numeric_threshold_+3A_column">column</code></td>
<td>
<p>If only a particular column should be used to cutoff values, it
can be supplied here as a character value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified Tplyr layer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
tplyr_table(gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_numeric_threshold(10, "n") %&gt;%
      add_total_row() %&gt;%
      set_order_count_method("bycount")
  )
</code></pre>

<hr>
<h2 id='set_order_count_method'>Set the ordering logic for the count layer</h2><span id='topic+set_order_count_method'></span><span id='topic+set_ordering_cols'></span><span id='topic+set_result_order_var'></span>

<h3>Description</h3>

<p>The sorting of a table can greatly vary depending on the
situation at hand. For count layers, when creating tables like adverse
event summaries, you may wish to order the table by descending occurrence
within a particular treatment group. But in other situations, such as AEs
of special interest, or subject disposition, there may be a specific order
you wish to display values. Tplyr offers solutions to each of these
situations.
</p>
<p>Instead of allowing you to specify a custom sort order, Tplyr instead
provides you with order variables that can be used to sort your table after
the data are summarized. Tplyr has a default order in which the table will
be returned, but the order variables will always persist. This allows you
to use powerful sorting functions like <code><a href="dplyr.html#topic+arrange">arrange</a></code>
to get your desired order, and in double programming situations, helps your
validator understand the how you achieved a particular sort order and where
discrepancies may be coming from.
</p>
<p>When creating order variables for a layer, for each 'by' variable Tplyr
will search for a &lt;VAR&gt;N version of that variable (i.e. VISIT &lt;-&gt; VISITN,
PARAM &lt;-&gt; PARAMN). If available, this variable will be used for sorting. If
not available, Tplyr will created a new ordered factor version of that
variable to use in alphanumeric sorting. This allows the user to control a
custom sorting order by leaving an existing &lt;VAR&gt;N variable in your dataset
if it exists, or create one based on the order in which you wish to sort -
no custom functions in Tplyr required.
</p>
<p>Ordering of results is where things start to differ. Different situations
call for different methods. Descriptive statistics layers keep it simple -
the order in which you input your formats using
<code><a href="#topic+set_format_strings">set_format_strings</a></code> is the order in which the results will
appear (with an order variable added). For count layers, Tplyr offers three
solutions: If there is a &lt;VAR&gt;N version of your target variable, use that.
If not, if the target variable is a factor, use the factor orders. Finally,
you can use a specific data point from your results columns. The result
column can often have multiple data points, between the n counts, percent,
distinct n, and distinct percent. Tplyr allows you to choose which of these
values will be used when creating the order columns for a specified result
column (i.e. based on the <code>treat_var</code> and <code>cols</code> arguments). See
the 'Sorting a Table' section for more information.
</p>
<p>Shift layers sort very similarly to count layers, but to order your row
shift variable, use an ordered factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_order_count_method(e, order_count_method, break_ties = NULL)

set_ordering_cols(e, ...)

set_result_order_var(e, result_order_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_order_count_method_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_order_count_method_+3A_order_count_method">order_count_method</code></td>
<td>
<p>The logic determining how the rows in the final
layer output will be indexed. Options are 'bycount', 'byfactor', and
'byvarn'.</p>
</td></tr>
<tr><td><code id="set_order_count_method_+3A_break_ties">break_ties</code></td>
<td>
<p>In certain cases, a 'bycount' sort will result in conflicts
if the counts aren't unique. break_ties will add a decimal to the sorting
column so resolve conflicts. A character value of 'asc' will add a decimal
based on the alphabetical sorting. 'desc' will do the same
but sort descending in case that is the intention.</p>
</td></tr>
<tr><td><code id="set_order_count_method_+3A_...">...</code></td>
<td>
<p>Unquoted variables used to select the columns whose values will be
extracted for ordering.</p>
</td></tr>
<tr><td><code id="set_order_count_method_+3A_result_order_var">result_order_var</code></td>
<td>
<p>The numeric value the ordering will be done on.
This can be either n, distinct_n, pct, or distinct_pct. Due to the
evaluation of the layer you can add a value that isn't actually being
evaluated, if this happens this will only error out in the ordering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the modified layer object. The 'ord_' columns are added
during the build process.
</p>


<h3>Sorting a Table</h3>

<p>When a table is built, the output has several
ordering(ord_) columns that are appended. The first represents the layer
index. The index is determined by the order the layer was added to the
table. Following are the indices for the by variables and the target
variable. The by variables are ordered based on:
</p>

<ol>
<li><p>The 'by' variable is a factor in the target dataset
</p>
</li>
<li><p>If the variable isn't a factor, but has a &lt;VAR&gt;N variable (i.e. VISIT
-&gt; VISITN, TRT -&gt; TRTN)
</p>
</li>
<li><p>If the variable is not a factor in the target dataset, it is coerced
to one and ordered alphabetically.
</p>
</li></ol>

<p>The target variable is ordered depending on the type of layer. See more
below.
</p>


<h3>Ordering a Count Layer</h3>

<p>There are many ways to order a count layer
depending on the preferences of the table programmer. <code>Tplyr</code> supports
sorting by a descending amount in a column in the table, sorting by a
&lt;VAR&gt;N variable, and sorting by a custom order. These can be set using the
'set_order_count_method' function. </p>
 <dl>
<dt>Sorting by a numeric
count</dt><dd><p>A selected numeric value from a selected column will be indexed
based on the descending numeric value. The numeric value extracted defaults
to 'n' but can be changed with 'set_result_order_var'. The column selected
for sorting defaults to the first value in the treatment group variable. If
there were arguments passed to the 'cols' argument in the table those must
be specified with 'set_ordering_columns'.</p>
</dd> <dt>Sorting by a 'varn'
variable</dt><dd><p>If the treatment variable has a &lt;VAR&gt;N variable. It can be
indexed to that variable.</p>
</dd> <dt>Sorting by a factor(Default)</dt><dd><p>If a factor
is found for the target variable in the target dataset that is used to
order, if no factor is found it is coerced to a factor and sorted
alphabetically.</p>
</dd> <dt>Sorting a nested count layer</dt><dd><p>If two variables are
targeted by a count layer, two methods can be passed to 'set_order_count'.
If two are passed, the first is used to sort the blocks, the second is used
to sort the &quot;inside&quot; of the blocks. If one method is passed, that will be
used to sort both.</p>
</dd> </dl>



<h3>Ordering a Desc Layer</h3>

<p>The order of a desc layer is mostly set
during the object construction. The by variables are resolved and index
with the same logic as the count layers. The target variable is ordered
based on the format strings that were used when the layer was created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Default sorting by factor
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl)
  )
build(t)

# Sorting by &lt;VAR&gt;N
mtcars$cylN &lt;- mtcars$cyl
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_order_count_method("byvarn")
  )

# Sorting by row count
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_order_count_method("bycount") %&gt;%
      # Orders based on the 6 gear group
      set_ordering_cols(6)
  )

# Sorting by row count by percentages
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      set_order_count_method("bycount") %&gt;%
      set_result_order_var(pct)
  )

# Sorting when you have column arguments in the table
t &lt;- tplyr_table(mtcars, gear, cols = vs) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      # Uses the fourth gear group and the 0 vs group in ordering
      set_ordering_cols(4, 0)
  )

# Using a custom factor to order
mtcars$cyl &lt;- factor(mtcars$cyl, c(6, 4, 8))
t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      # This is the default but can be used to change the setting if it is
      #set at the table level.
      set_order_count_method("byfactor")
  )
</code></pre>

<hr>
<h2 id='set_outer_sort_position'>Set the value of a outer nested count layer to Inf or -Inf</h2><span id='topic+set_outer_sort_position'></span>

<h3>Description</h3>

<p>Set the value of a outer nested count layer to Inf or -Inf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_outer_sort_position(e, outer_sort_position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_outer_sort_position_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_outer_sort_position_+3A_outer_sort_position">outer_sort_position</code></td>
<td>
<p>Either 'asc' or 'desc'. If desc the final ordering helper
will be set to Inf, if 'asc' the ordering helper is set to -Inf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified count layer.
</p>

<hr>
<h2 id='set_precision_data'>Set precision data</h2><span id='topic+set_precision_data'></span>

<h3>Description</h3>

<p>In some cases, there may be organizational standards surrounding decimal precision.
For example, there may be a specific standard around the representation of precision relating
to lab results. As such, <code>set_precision_data()</code> provides an interface to provide integer and
decimal precision from an external data source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_precision_data(layer, prec, default = c("error", "auto"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_precision_data_+3A_layer">layer</code></td>
<td>
<p>A <code>tplyr_layer</code> object</p>
</td></tr>
<tr><td><code id="set_precision_data_+3A_prec">prec</code></td>
<td>
<p>A dataframe following the structure specified in the function details</p>
</td></tr>
<tr><td><code id="set_precision_data_+3A_default">default</code></td>
<td>
<p>Handling of unspecified by variable groupings. Defaults to 'error'. Set to 'auto' to automatically infer any missing groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ultimate behavior of this feature is just that of the existing auto precision method, except
that the precision is specified in the provided precision dataset rather than inferred from the source data.
At a minimum, the precision dataset must contain the integer variables <code>max_int</code> and <code>max_dec</code>. If by variables
are provided, those variables must be available in the layer by variables.
</p>
<p>When the table is built, by default Tplyr will error if the precision dataset is missing by variable groupings
that exist in the target dataset. This can be overriden using the <code>default</code> parameter. If <code>default</code> is set to
&quot;auto&quot;, any missing values will be automatically inferred from the source data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prec &lt;- tibble::tribble(
  ~vs, ~max_int, ~max_dec,
  0,        1,        1,
  1,        2,        2
)

tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(wt, by = vs) %&gt;%
      set_format_strings(
        'Mean (SD)' = f_str('a.a+1 (a.a+2)', mean, sd)
      ) %&gt;%
      set_precision_data(prec) %&gt;%
      set_precision_on(wt)
  ) %&gt;%
  build()

</code></pre>

<hr>
<h2 id='set_stats_as_columns'>Set descriptive statistics as columns</h2><span id='topic+set_stats_as_columns'></span>

<h3>Description</h3>

<p>In many cases, treatment groups are represented as columns within a table.
But some tables call for a transposed presentation, where the treatment
groups displayed by row, and the descriptive statistics are represented as
columns. <code>set_stats_as_columns()</code> allows Tplyr to output a built table
using this transposed format and deviate away from the standard
representation of treatment groups as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_stats_as_columns(e, stats_as_columns = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_stats_as_columns_+3A_e">e</code></td>
<td>
<p><code>desc_layer</code> on descriptive statistics summaries should be represented as columns</p>
</td></tr>
<tr><td><code id="set_stats_as_columns_+3A_stats_as_columns">stats_as_columns</code></td>
<td>
<p>Boolean to set stats as columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function leaves all specified by variables intact. The only switch that
happens during the build process is that the provided descriptive statistics
are transposed as columns and the treatment variable is left as rows. Column
variables will remain represented as columns, and multiple target variables
will also be respected properly.
</p>


<h3>Value</h3>

<p>The input tplyr_layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_desc(wt, by = vs) %&gt;%
      set_format_strings(
        "n"        = f_str("xx", n),
        "sd"       = f_str("xx.x", sd, empty = c(.overall = "BLAH")),
        "Median"   = f_str("xx.x", median),
        "Q1, Q3"   = f_str("xx, xx", q1, q3),
        "Min, Max" = f_str("xx, xx", min, max),
        "Missing"  = f_str("xx", missing)
      ) %&gt;%
      set_stats_as_columns()
  ) %&gt;%
  build()

</code></pre>

<hr>
<h2 id='set_total_row_label'>Set the label for the total row</h2><span id='topic+set_total_row_label'></span>

<h3>Description</h3>

<p>The row label for a total row defaults to &quot;Total&quot;, however this can be
overriden using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_total_row_label(e, total_row_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_total_row_label_+3A_e">e</code></td>
<td>
<p>A <code>count_layer</code> object</p>
</td></tr>
<tr><td><code id="set_total_row_label_+3A_total_row_label">total_row_label</code></td>
<td>
<p>A character to label the total row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code>count_layer</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in pipe
library(magrittr)

t &lt;- tplyr_table(mtcars, gear) %&gt;%
  add_layer(
    group_count(cyl) %&gt;%
      add_total_row() %&gt;%
      set_total_row_label("Total Cyl")
  )
build(t)
</code></pre>

<hr>
<h2 id='str_extract_fmt_group'>Extract format group strings or numbers</h2><span id='topic+str_extract_fmt_group'></span><span id='topic+str_extract_num'></span>

<h3>Description</h3>

<p>These functions allow you to extract segments of information from within a
result string by targetting specific format groups. <code>str_extract_fmt_group()</code>
allows you to pull out the individual format group string, while
<code>str_extract_num()</code> allows you to pull out that specific numeric result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_fmt_group(string, format_group)

str_extract_num(string, format_group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_extract_fmt_group_+3A_string">string</code></td>
<td>
<p>A string of number results from which to extract format groups</p>
</td></tr>
<tr><td><code id="str_extract_fmt_group_+3A_format_group">format_group</code></td>
<td>
<p>An integer representing format group that should be
extracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Format groups refer to individual segments of a string. For example, given
the string ' 5 (34.4%) [9]', there are three separate format groups, which
are ' 5', '(34.4%)', and '[9]'.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
string &lt;- c(" 0  (0.0%)", " 8  (9.3%)", "78 (90.7%)")

str_extract_fmt_group(string, 2)

str_extract_num(string, 2)

</code></pre>

<hr>
<h2 id='str_indent_wrap'>Wrap strings to a specific width with hyphenation while preserving
indentation</h2><span id='topic+str_indent_wrap'></span>

<h3>Description</h3>

<p><code>str_indent_wrap()</code> leverages <code>stringr::str_wrap()</code> under the hood, but takes
some extra steps to preserve any indentation that has been applied to a
character element, and use hyphenated wrapping of single words that run
longer than the allotted wrapping width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_indent_wrap(x, width = 10, tab_width = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_indent_wrap_+3A_x">x</code></td>
<td>
<p>An input character vector</p>
</td></tr>
<tr><td><code id="str_indent_wrap_+3A_width">width</code></td>
<td>
<p>The desired width of elements within the output character vector</p>
</td></tr>
<tr><td><code id="str_indent_wrap_+3A_tab_width">tab_width</code></td>
<td>
<p>The number of spaces to which tabs should be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>stringr::str_wrap()</code> is highly efficient, but in the
context of table creation there are two select features missing - hyphenation
for long running strings that overflow width, and respect for pre-indentation
of a character element. For example, in an adverse event table, you may have
body system rows as an un-indented column, and preferred terms as indented
columns. These strings may run long and require wrapping to not surpass the
column width. Furthermore, for crowded tables a single word may be longer
than the column width itself.
</p>
<p>This function takes steps to resolve these two issues, while trying to
minimize additional overhead required to apply the wrapping of strings.
</p>
<p>Note: This function automatically converts tabs to spaces. Tab width varies
depending on font, so width cannot automatically be determined within a data
frame. As such, users can specify the width
</p>


<h3>Value</h3>

<p>A character vector with string wrapping applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex_text1 &lt;- c("RENAL AND URINARY DISORDERS", "   NEPHROLITHIASIS")
ex_text2 &lt;- c("RENAL AND URINARY DISORDERS", "\tNEPHROLITHIASIS")

cat(paste(str_indent_wrap(ex_text1, width=8), collapse="\n\n"),"\n")
cat(paste(str_indent_wrap(ex_text2, tab_width=4), collapse="\n\n"),"\n")
</code></pre>

<hr>
<h2 id='tplyr_adae'>ADAE Data</h2><span id='topic+tplyr_adae'></span>

<h3>Description</h3>

<p>A subset of the PHUSE Test Data Factory ADAE data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_adae
</code></pre>


<h3>Format</h3>

<p>A data.frame with 276 rows and 55 columns.
</p>


<h3>Source</h3>

<p>https://github.com/phuse-org/TestDataFactory
</p>


<h3>See Also</h3>

<p>[get_data_labels()]
</p>

<hr>
<h2 id='tplyr_adas'>ADAS Data</h2><span id='topic+tplyr_adas'></span>

<h3>Description</h3>

<p>A subset of the PHUSE Test Data Factory ADAS data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_adas
</code></pre>


<h3>Format</h3>

<p>A data.frame with 1,040 rows and 40 columns.
</p>


<h3>Source</h3>

<p>https://github.com/phuse-org/TestDataFactory
</p>


<h3>See Also</h3>

<p>[get_data_labels()]
</p>

<hr>
<h2 id='tplyr_adlb'>ADLB Data</h2><span id='topic+tplyr_adlb'></span>

<h3>Description</h3>

<p>A subset of the PHUSE Test Data Factory ADLB data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_adlb
</code></pre>


<h3>Format</h3>

<p>A data.frame with 311 rows and 46 columns.
</p>


<h3>Source</h3>

<p>https://github.com/phuse-org/TestDataFactory
</p>


<h3>See Also</h3>

<p>[get_data_labels()]
</p>

<hr>
<h2 id='tplyr_adpe'>ADPE Data</h2><span id='topic+tplyr_adpe'></span>

<h3>Description</h3>

<p>A mock-up dataset that is fit for testing data limiting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_adpe
</code></pre>


<h3>Format</h3>

<p>A data.frame with 21 rows and 8 columns.
</p>

<hr>
<h2 id='tplyr_adsl'>ADSL Data</h2><span id='topic+tplyr_adsl'></span>

<h3>Description</h3>

<p>A subset of the PHUSE Test Data Factory ADSL data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_adsl
</code></pre>


<h3>Format</h3>

<p>A data.frame with 254 rows and 49 columns.
</p>


<h3>Source</h3>

<p>https://github.com/phuse-org/TestDataFactory
</p>


<h3>See Also</h3>

<p>[get_data_labels()]
</p>

<hr>
<h2 id='tplyr_layer'>Create a <code>tplyr_layer</code> object</h2><span id='topic+tplyr_layer'></span>

<h3>Description</h3>

<p>This object is the workhorse of the <code>tplyr</code> package. A
<code>tplyr_layer</code> can be thought of as a block, or &quot;layer&quot; of a table.
Summary tables typically consist of different sections that require different
summaries. When programming these section, your code will create different
layers that need to be stacked or merged together. A <code>tplyr_layer</code> is
the container for those isolated building blocks.
</p>
<p>When building the <code>tplyr_table</code>, each layer will execute independently.
When all of the data processing has completed, the layers are brought
together to construct the output.
</p>
<p><code>tplyr_layer</code> objects are not created directly, but are rather created
using the layer constructor functions <code><a href="#topic+group_count">group_count</a></code>,
<code><a href="#topic+group_desc">group_desc</a></code>, and <code><a href="#topic+group_shift">group_shift</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_layer(parent, target_var, by, where, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tplyr_layer_+3A_parent">parent</code></td>
<td>
<p><code>tplyr_table</code> or <code>tplyr_layer</code>. Required. The parent
environment of the layer. This must be either the <code>tplyr_table</code> object
that the layer is contained within, or another <code>tplyr_layer</code> object of
which the layer is a subgroup.</p>
</td></tr>
<tr><td><code id="tplyr_layer_+3A_target_var">target_var</code></td>
<td>
<p>Symbol. Required, The variable name on which the summary is
to be performed. Must be a variable within the target dataset. Enter
unquoted - i.e. target_var = AEBODSYS.</p>
</td></tr>
<tr><td><code id="tplyr_layer_+3A_by">by</code></td>
<td>
<p>A string, a variable name, or a list of variable names supplied
using <code>dplyr::vars</code></p>
</td></tr>
<tr><td><code id="tplyr_layer_+3A_where">where</code></td>
<td>
<p>Call. Filter logic used to subset the target data when
performing a summary.</p>
</td></tr>
<tr><td><code id="tplyr_layer_+3A_type">type</code></td>
<td>
<p>&quot;count&quot;, &quot;desc&quot;, or &quot;shift&quot;. Required. The category of layer -
either &quot;counts&quot; for categorical counts, &quot;desc&quot; for descriptive statistics,
or &quot;shift&quot; for shift table counts</p>
</td></tr>
<tr><td><code id="tplyr_layer_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tplyr_layer</code> environment that is a child of the specified
parent. The environment contains the object as listed below.
</p>


<h3><code>tplyr_layer</code> Core Object Structure</h3>


<dl>
<dt><code>type</code></dt><dd><p>This is an attribute. A string indicating the layer
type, which controls the summary that will be performed.</p>
</dd>
<dt><code>target_var</code></dt><dd><p>A quosure of a name, which is the variable on
which a summary will be performed.</p>
</dd> <dt><code>by</code></dt><dd><p>A list of quosures
representing either text labels or variable names used in grouping.
Variable names must exist within the target dataset Text strings submitted
do not need to exist in the target dataset.</p>
</dd> <dt><code>cols</code></dt><dd><p>A list of
quosures used to determine the variables that are used to display in
columns.</p>
</dd> <dt><code>where</code></dt><dd><p>A quosure of a call that containers the
filter logic used to subset the target dataset. This filtering is in
addition to any subsetting done based on <code>where</code> criteria specified in
<code><a href="#topic+tplyr_table">tplyr_table</a></code></p>
</dd> <dt><code>layers</code></dt><dd><p>A list with class
<code>tplyr_layer_container</code>. Initialized as empty, but serves as the
container for any sublayers of the current layer. Used internally.</p>
</dd> </dl>

<p>Different layer types will have some different bindings specific to that
layer's needs.
</p>


<h3>See Also</h3>

<p><a href="#topic+tplyr_table">tplyr_table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(iris, Sepal.Width)

l &lt;- group_count(tab, by=vars('Label Text', Species),
                 target_var=Species, where= Sepal.Width &lt; 5.5,
                 cols = Species)


</code></pre>

<hr>
<h2 id='tplyr_meta'>Tplyr Metadata Object</h2><span id='topic+tplyr_meta'></span>

<h3>Description</h3>

<p>If a Tplyr table is built with the 'metadata=TRUE' option specified, then
metadata is assembled behind the scenes to provide traceability on each
result cell derived. The functions 'get_meta_result()' and
'get_meta_subset()' allow you to access that metadata by using an ID provided
in the row_id column and the column name of the result you'd like to access.
The purpose is of the row_id variable instead of a simple row index is to
provide a sort resistant reference of the originating column, so the output
Tplyr table can be sorted in any order but the metadata are still easily
accessible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_meta(names = list(), filters = exprs())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tplyr_meta_+3A_names">names</code></td>
<td>
<p>List of symbols</p>
</td></tr>
<tr><td><code id="tplyr_meta_+3A_filters">filters</code></td>
<td>
<p>List of expressions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'tplyr_meta' object provided a list with two elements - names and
filters. The names contain every column from the target data.frame of the
Tplyr table that factored into the specified result cell, and the filters
contains all the necessary filters to subset the target data to create the
specified result cell. 'get_meta_subset()' additionally provides a parameter to
specify any additional columns you would like to include in the returned
subset data frame.
</p>


<h3>Value</h3>

<p>tplyr_meta object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tplyr_meta(
   names = rlang::quos(x, y, z),
   filters = rlang::quos(x == 1, y==2, z==3)
 )

</code></pre>

<hr>
<h2 id='tplyr_table'>Create a Tplyr table object</h2><span id='topic+tplyr_table'></span>

<h3>Description</h3>

<p>The <code>tplyr_table</code> object is the main container upon which a Tplyr table is constructed. Tplyr tables are made up of
one or more layers. Each layer contains an instruction for a summary to be performed. The <code>tplyr_table</code> object contains
those layers, and the general data, metadata, and logic necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tplyr_table(target, treat_var, where = TRUE, cols = vars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tplyr_table_+3A_target">target</code></td>
<td>
<p>Dataset upon which summaries will be performed</p>
</td></tr>
<tr><td><code id="tplyr_table_+3A_treat_var">treat_var</code></td>
<td>
<p>Variable containing treatment group assignments. Supply unquoted.</p>
</td></tr>
<tr><td><code id="tplyr_table_+3A_where">where</code></td>
<td>
<p>A general subset to be applied to all layers. Supply as programming logic (i.e. x &lt; 5 &amp; y == 10)</p>
</td></tr>
<tr><td><code id="tplyr_table_+3A_cols">cols</code></td>
<td>
<p>A grouping variable to summarize data by column (in addition to treat_var). Provide multiple
column variables by using <code><a href="dplyr.html#topic+vars">vars</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a <code>tplyr_table</code> is created, it will contain the following bindings:
</p>

<ul>
<li><p>target - The dataset upon which summaries will be performed
</p>
</li>
<li><p>pop_data - The data containing population information. This defaults to the target dataset
</p>
</li>
<li><p>cols - A categorical variable to present summaries grouped by column (in addition to treat_var)
</p>
</li>
<li><p>table_where - The <code>where</code> parameter provided, used to subset the target data
</p>
</li>
<li><p>treat_var - Variable used to distinguish treatment groups.
</p>
</li>
<li><p>header_n - Default header N values based on <code>treat_var</code>
</p>
</li>
<li><p>pop_treat_var - The treatment variable for <code>pop_data</code> (if different)
</p>
</li>
<li><p>layers - The container for individual layers of a <code>tplyr_table</code>
</p>
</li>
<li><p>treat_grps - Additional treatment groups to be added to the summary (i.e. Total)
</p>
</li></ul>

<p><code>tplyr_table</code> allows you a basic interface to instantiate the object. Modifier functions are available to change
individual parameters catered to your analysis. For example, to add a total group, you can use the
<code><a href="#topic+add_total_group">add_total_group</a></code>.
</p>
<p>In future releases, we will provide vignettes to fully demonstrate these capabilities.
</p>


<h3>Value</h3>

<p>A <code>tplyr_table</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tab &lt;- tplyr_table(iris, Species, where = Sepal.Length &lt; 5.8)

</code></pre>

<hr>
<h2 id='treat_var'>Return or set the treatment variable binding</h2><span id='topic+treat_var'></span><span id='topic+set_treat_var'></span>

<h3>Description</h3>

<p>Return or set the treatment variable binding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treat_var(table)

set_treat_var(table, treat_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treat_var_+3A_table">table</code></td>
<td>
<p>A <code>tplyr_table</code> object to set or return treatment variable
the table is split by.</p>
</td></tr>
<tr><td><code id="treat_var_+3A_treat_var">treat_var</code></td>
<td>
<p>Variable containing treatment group assignments. Supply unquoted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>tplyr_treat_var</code> the treat_var binding of the <code>tplyr_table</code>
object. For <code>set_tplyr_treat_var</code> the modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tplyr_table(mtcars, cyl)

set_treat_var(tab, gear)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
