<!DOCTYPE html><html><head><title>Help for package fBasics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fBasics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fBasics-package'><p>Portfolio modelling, optimization and backtesting</p></a></li>
<li><a href='#acfPlot'><p>Autocorrelation function plots</p></a></li>
<li><a href='#akimaInterp'><p>Bivariate Spline Interpolation</p></a></li>
<li><a href='#baseMethods'><p>Generic functions extensions</p></a></li>
<li><a href='#BasicStatistics'><p>Basic time series statistics</p></a></li>
<li><a href='#BoxPlot'><p>Time series box plots</p></a></li>
<li><a href='#characterTable'><p>Table of characters</p></a></li>
<li><a href='#colorLocator'><p>Named colors in R</p></a></li>
<li><a href='#colorPalette'><p>Color palettes</p></a></li>
<li><a href='#colorTable'><p>Table of colors</p></a></li>
<li><a href='#colVec'><p>Column and row vectors</p></a></li>
<li><a href='#correlationTest'><p>Correlation tests</p></a></li>
<li><a href='#decor'><p>Functions for decorating plots</p></a></li>
<li><a href='#distCheck'><p>Distribution check</p></a></li>
<li><a href='#DistributionFits'><p>Parametric fit of a distribution</p></a></li>
<li><a href='#fBasics_reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#fBasics-deprecated'><p>Deprecated functions in package fBasics</p></a></li>
<li><a href='#fBasicsData'><p>fBasics data sets</p></a></li>
<li><a href='#fDISTFIT-class'><p>Class <code>"fDISTFIT"</code></p></a></li>
<li><a href='#fHTEST-class'><p>Class <code>"fHTEST"</code></p></a></li>
<li><a href='#getS4'><p>General S4 Class Extractor Functions</p></a></li>
<li><a href='#gh'><p>Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#ghFit'><p>GH Distribution Fit</p></a></li>
<li><a href='#ghMode'><p>Generalized Hyperbolic Mode</p></a></li>
<li><a href='#ghMoments'><p>Generalized Hyperbolic Distribution Moments</p></a></li>
<li><a href='#ghRobMoments'><p>Robust Moments for the GH</p></a></li>
<li><a href='#ghSlider'><p>Generalized Hyperbolic Distribution Slider</p></a></li>
<li><a href='#ght'><p>Generalized Hyperbolic Student-t distribution</p></a></li>
<li><a href='#ghtFit'><p>GHT distribution fit</p></a></li>
<li><a href='#ghtMode'><p>Generalized Hyperbolic Student-t Mode</p></a></li>
<li><a href='#ghtMoments'><p>Generalized Hyperbolic Student-t Moments</p></a></li>
<li><a href='#ghtRobMoments'><p>Robust Moments for the GHT</p></a></li>
<li><a href='#gld'><p>Generalized Lambda Distribution</p></a></li>
<li><a href='#gldFit'><p>GH Distribution Fit</p></a></li>
<li><a href='#gldMode'><p>Generalized Lambda Distribution Mode</p></a></li>
<li><a href='#gldRobMoments'><p>Robust Moments for the GLD</p></a></li>
<li><a href='#gridVector'><p>Grid vector coordinates</p></a></li>
<li><a href='#Heaviside'><p>Heaviside and related functions</p></a></li>
<li><a href='#hilbert'><p>Hilbert matrix</p></a></li>
<li><a href='#HistogramPlot'><p>Histogram and density plots</p></a></li>
<li><a href='#hyp'><p>Hyperbolic distribution</p></a></li>
<li><a href='#hypFit'><p>Fit a Hyperbolic distribution</p></a></li>
<li><a href='#hypMode'><p>Hyperbolic mode</p></a></li>
<li><a href='#hypMoments'><p>Hyperbolic distribution moments</p></a></li>
<li><a href='#hypRobMoments'><p>Robust moments for the HYP</p></a></li>
<li><a href='#hypSlider'><p>Hyperbolic distribution slider</p></a></li>
<li><a href='#Ids'><p>Set and retrieve column/row names</p></a></li>
<li><a href='#interactivePlot'><p>Interactive Plot Utility</p></a></li>
<li><a href='#inv'><p>The inverse of a matrix</p></a></li>
<li><a href='#krigeInterp'><p>Bivariate Krige Interpolation</p></a></li>
<li><a href='#kron'><p>Kronecker product</p></a></li>
<li><a href='#ks2Test'><p>Two sample Kolmogorov-Smirnov test</p></a></li>
<li><a href='#lcg'><p>Generator for Portable random innovations</p></a></li>
<li><a href='#linearInterp'><p>Bivariate Linear Interpolation</p></a></li>
<li><a href='#listFunctions'><p>List exported functions in a package</p></a></li>
<li><a href='#locationTest'><p>Two sample location tests</p></a></li>
<li><a href='#maxdd'><p>Drawdown statistics</p></a></li>
<li><a href='#nig'><p>Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#nigFit'><p>Fit of a Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#nigMode'><p>Normal Inverse Gaussian Mode</p></a></li>
<li><a href='#nigMoments'><p>Moments for the Normal Inverse Gaussian</p></a></li>
<li><a href='#nigRobMoments'><p>Robust Moments for the NIG</p></a></li>
<li><a href='#nigShapeTriangle'><p>NIG Shape Triangle</p></a></li>
<li><a href='#nigSlider'><p>nigerbolic Distribution Slider</p></a></li>
<li><a href='#norm'><p>Matrix norm</p></a></li>
<li><a href='#NormalityTests'><p>Tests for normality</p></a></li>
<li><a href='#normRobMoments'><p>Robust moments for the Normal distribution</p></a></li>
<li><a href='#pascal'><p>Pascal matrix</p></a></li>
<li><a href='#pdl'><p>Polynomial distributed lags</p></a></li>
<li><a href='#positiveDefinite'><p>Positive definite matrices</p></a></li>
<li><a href='#print'><p>Print control</p></a></li>
<li><a href='#QuantileQuantilePlots'><p>Quantile-Quantile plots</p></a></li>
<li><a href='#ReturnSeriesGUI'><p>Return series plots</p></a></li>
<li><a href='#rk'><p>The rank of a matrix</p></a></li>
<li><a href='#rowStats'><p>Row statistics</p></a></li>
<li><a href='#sampleLMoments'><p>Sample L-moments</p></a></li>
<li><a href='#sampleRobMoments'><p>Robust moments for the GLD</p></a></li>
<li><a href='#scaleTest'><p>Two sample scale tests</p></a></li>
<li><a href='#ScalingLawPlot'><p>Scaling law behaviour</p></a></li>
<li><a href='#sgh'><p>Standardized Generalized Hyperbolic Distribution</p></a></li>
<li><a href='#sghFit'><p>Standardized GH distribution fit</p></a></li>
<li><a href='#sght'><p>Standardized generalized hyperbolic Student-t Distribution</p></a></li>
<li><a href='#snig'><p>Standardized Normal Inverse Gaussian Distribution</p></a></li>
<li><a href='#snigFit'><p>Fit of a Standardized NIG Distribution</p></a></li>
<li><a href='#ssd'><p>Spline Smoothed Distribution</p></a></li>
<li><a href='#ssdFit'><p>Fit density using smoothing splines</p></a></li>
<li><a href='#StableSlider'><p>Slider GUI for Stable Distribution</p></a></li>
<li><a href='#symbolTable'><p>Table of symbols</p></a></li>
<li><a href='#TimeSeriesPlots'><p>Financial time series plots</p></a></li>
<li><a href='#tr'><p>Trace of a matrix</p></a></li>
<li><a href='#triang'><p>Upper and lower triangular matrices</p></a></li>
<li><a href='#tsHessian'><p>Two sided approximated Hessian</p></a></li>
<li><a href='#tslag'><p>Lagged or leading vector/matrix</p></a></li>
<li><a href='#varianceTest'><p>Two sample variance tests</p></a></li>
<li><a href='#vec'><p>Stacking vectors and matrices</p></a></li>
<li><a href='#volatility'><p>Compute volatility</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Rmetrics - Markets and Basic Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>4032.96</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of functions to 
    explore and to investigate basic properties of financial returns 
    and related quantities.
    The covered fields include techniques of explorative data analysis
    and the investigation of distributional properties, including
    parameter estimation and hypothesis testing. Even more there are
    several utility functions for data handling and management.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>timeDate, timeSeries (&ge; 4021.105), stats, grDevices,
graphics, methods, utils, MASS, spatial, gss, stabledist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>interp, RUnit, tcltk</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/fBasicsDoc/">https://geobosh.github.io/fBasicsDoc/</a> (doc),
<a href="https://r-forge.r-project.org/scm/viewvc.php/pkg/fBasics/?root=rmetrics">https://r-forge.r-project.org/scm/viewvc.php/pkg/fBasics/?root=rmetrics</a>
(devel), <a href="https://www.rmetrics.org">https://www.rmetrics.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics">https://r-forge.r-project.org/projects/rmetrics</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-03 15:29:06 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Diethelm Wuertz [aut] (original code),
  Tobias Setz [aut],
  Yohan Chalabi [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  CRAN Team [ctb],
  Georgi N. Boshnakov [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-03 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fBasics-package'>Portfolio modelling, optimization and backtesting</h2><span id='topic+fBasics-package'></span><span id='topic+fBasics'></span>

<h3>Description</h3>

<p>The Rmetrics <span class="pkg">fBasics</span> package is a collection of functions to 
explore and to investigate basic properties of financial returns 
and related quantities.
</p>
<p>The covered fields include techniques of explorative data analysis
and the investigation of distributional properties, including
parameter estimation and hypothesis testing. Evenmore there are
several utility functions for data handling and managemnet.
</p>


<h3>1 Introduction</h3>

<p>The fBasics package contains <em>basics tools</em> often required
in computational finance and financial engineering. The topics
are: basic statistics functions, financial return distributions,
hypothesis testing, plotting routines, matrix computations and 
linear algebra, and some usefule utility functions.
</p>


<h3>2 Basic Statistics Functions</h3>

<p><em>Financial Return Statistics</em>
</p>

<pre> 
    basicStats            Returns a basic statistics summary
    </pre>
<p><em>Distribution Function of Maximum Drawdowns</em>
</p>

<pre>
    dmaxdd                Density function of mean Max-Drawdowns
    pmaxdd                Probability function of mean Max-Drawdowns
    rmaxdd                Random Variates of mean Max-Drawdowns
    maxddStats            Expectation of Drawdowns for BM with drift
    </pre>
<p><em>Calculation of Sample Moments</em>
</p>

<pre> 
    sampleLmoments        Computes sample L-moments
    sampleMED             Returns sample median
    sampleIQR             returns sample inter quartal range
    sampleSKEW            returns robust sample skewness
    sampleKURT            returns robust sample kurtosis
    </pre>
<p><em>Bivariate Interpolation:</em>
</p>

<pre> 
    akimaInterp           Interpolates irregularly spaced points
    akimaInterpp          Interpolates and smoothes pointwise
    krigeInterp           Kriges irregularly spaced data points
    linearInterp          Interpolates irregularly spaced points
    linearInterpp         Interpolates linearly pointwise
    </pre>
<p><em>Utility Statistics Functions:</em>
</p>
<pre>
    colStats              Computes sample statistics by col
    colSums               Computes sums of values in each col
    colMeans              Computes means of values in each col
    colSds                Computes standard deviation of each col
    colVars               Computes sample variance by col
    colSkewness           Computes sample skewness by col
    colKurtosis           Computes sample kurtosis by col
    colMaxs               Computes maximum values in each col
    colMins               Computes minimum values in each col
    colProds              Computes product of values in each col
    colQuantiles          Computes product of values in each col
    </pre>

<pre>
    rowStats              Computes sample statistics by row
    rowSums               Computes sums of values in each row
    rowMeans              Computes means of values in each row
    rowSds                Computes standard deviation of each row
    rowVars               Computes sample variance by row
    rowSkewness           Computes sample skewness by row
    rowKurtosis           Computes sample kurtosis by row
    rowMaxs               Computes maximum values in each row
    rowMins               Computes minimum values in each row
    rowProds              Computes product of values in each row
    rowQuantiles          Computes product of values in each row
    </pre>


<h3>3 Financial Return Distributions</h3>

<p><em>Generalized Hyperbolic Distribution:</em>
</p>


<pre>
    dghReturns            Density for the GH distribution
    pghreturns            Probability for the GH distribution
    qghreturns            Quantiles for the GH distribution
    rghreturns            Random variates for the GH distribution
    ghFitFits             Fits parameters of the GH distribution
    ghMode                Computes mode of the GH distribution. 
    ghMean                Returns true mean of the GH distribution
    ghVar                 Returns true variance of the GH distribution
    ghSkew                Returns true skewness of the GH distribution
    ghKurt                Returns true kurtosis of the GH distribution
    ghMoments             Returns true n-th moment of the GH distribution
    ghMED                 Returns true median of te GH distribution
    ghIQR                 Returns true inter quartal range of te GH
    ghSKEW                Returns true robust skewness of te GH
    ghKURT                Returns true robust kurtosis of te GH
    </pre> 
<p><em>Hyperbolic Distribution:</em>
</p>


<pre>
    dhyp                  Returns density for the HYP distribution
    phyp                  Returns probability for the HYP distribution
    qhyp                  Returns quantiles for the HYP distribution
    rhyp                  Returns random variates for the HYP distribution
    hypFit                Fits parameters of the HYP distribution
    hypMode               Computes mode of the HYP distribution
    hypMean               Returns true mean of the HYP distribution
    hypVar R              Returns true variance of the HYP distribution
    hypSkew               Returns true skewness of the HYP distribution
    hypKurt               Returns true kurtosis of the HYP distribution
    hypMoments            Returns true n-th moment of the HYP distribution
    hypMED                Returns true median of the HYP distribution
    hypIQR                Returns true inter quartal range of the HYP
    hypSKEW               Returns true robust skewness of the HYP
    hypKURT               Returns true robust kurtosis of the HYP
    </pre>
<p><em>Normal Inverse Gaussian:</em>
</p>


<pre>
    dnig                  Returns density for the NIG distribution
    pnig                  Returns probability for the NIG distribution
    qnig                  Returns quantiles for the NIG distribution
    rnig                  Returns random variates for the NIG distribution
      .pnigC              fast C Implementation of function pnig()
      .qnigC              fast CImplementation of function qnig()
    nigFit                Fits parameters of a NIG distribution
      .nigFit.mle         Uses max Log-likelihood estimation
      .nigFit.gmm         Uses generalized method of moments
      .nigFit.mps         Maximum product spacings estimation
      .nigFit.vmps        Minimum variance mps estimation
    nigMode               Computes mode of the NIG distribution
    nigMean               Returns true mean of the NIG distribution
    nigVar                Returns true variance of the NIG distribution
    nigSkew               Returns true skewness of the NIG distribution
    nigKurt               Returns true kurtosis of the NIG distribution
    nigMoments            Returns true n-th moment of the NIG distribution
    nigMED                Returns true median of the NIG distribution
    nigIQR                Returns true inter quartal range of the NIG
    nigSKEW               Returns true robust skewness of the NIG
    nigKURT               Returns true robust kurtosis of the NIG
    </pre>
<p><em>Generalized Hyperbolic Student-t Distribution:</em>
</p>


<pre>
    dght                  Returns density for the GHT distribution
    pght                  Returns probability for the GHT distribution
    qght                  Returns quantiles for the GHT distribution
    rght                  Returns random variates for the GHT distribution
    ghtFit                Fits parameters of the GHT distribution
    ghtMode               Computes mode of the GHT distribution
    ghtMean               Returns true mean of the NIG distribution
    ghtVar                Returns true variance of the GHT distribution
    ghtSkew               Returns true skewness of the GHT distribution
    ghtKurt               Returns true kurtosis of the GHT distribution
    ghtMoments            Returns true n-th moment of the GHT distribution
    ghtMED                Returns true median of the GHT distribution
    ghtIQR                Returns true inter quartal range of the GHT
    ghtSKEW               Returns true robust skewness of the GHT
    ghtKURT               Returns true robust kurtosis of the GHT
    </pre>
<p><em>Stable Distribution:</em>
</p>

<pre>
    dstable               Returns density for the stable distribution
    pstable               Returns probability for the stable distribution
    qstable               Returns quantiles for the stable distribution
    rstable               Returns random variates for the dtsble distribution
    stableFit             Fits parameters of a the stable distribution
      .phiStable          Creates contour table for McCulloch estimators
      .PhiStable          Contour table created by function .phiStable()
      .qStableFit         Estimates parameters by McCulloch's approach
      .mleStableFit       Estimates stable parameters by MLE approach
      .stablePlot         Plots results of stable parameter estimates
    stableMode            Computes mode of the stable distribution
    </pre>
<p><em>Generalized Lambda Distribution:</em>
</p>


<pre>
    dgld                  Returns density for the GLD distribution
    pgld                  Returns probability for the GLD distribution
    qgld                  Returns quantiles for the GLD distribution
    rgld                  Returns random variates for the GLD distribution
    gldFit                Fits parameters of the GLD distribution
      .gldFit.mle         fits GLD using maximum log-likelihood
      .gldFit.mps         fits GLD using maximum product spacings 
      .gldFit.gof         fits GLD using Goodness of Fit statistics
                          
                          
                          
      .gldFit.hist        fits GLD using a histogram fit
      .gldFit.rob         fits GLD using robust moments fit
    gldMode               Computes mode of the GLD distribution.
    gldMED                Returns true median of the GLD distribution
    gldIQR                Returns true inter quartal range of the GLD
    gldSKEW               Returns true robust skewness of the GLD
    gldKURT               Returns true robust kurtosis of the GLD
    </pre>
<p><em>Spline Smoothed Distribution:</em>
</p>

<pre>
    dssd                  Returns spline smoothed density function
    pssd                  Returns spline smoothed probability function
    qssd                  Returns spline smoothed quantile function
    rssd                  Returns spline smoothed random variates.
    ssdFit                Fits parameters for a spline smoothed distribution
    </pre>


<h3>4 Hypthesis Testing</h3>

<p><em>One Sample Nornality Tests:</em>
</p>

<pre>
    ksnormTest            One sample Kolmogorov-Smirnov normality test
    shapiroTest           Shapiro-Wilk normality test
    jarqueberaTest        Jarque-Bera normality test
    normalTest            Normality tests S-Plus compatible call
    dagoTest              D'Agostino normality test
    adTest                Anderson-Darling normality test
    cvmTest               Cramer-von Mises normality test
    lillieTest            Lilliefors (KS) normality test 
    pchiTest              Pearson chi-square normality test 
    sfTest                Shapiro-Francia normality test     
    jbTest                Finite sample adjusted JB LM and ALM test
    </pre>
<p><em>One Sample Location, Scale and variance Tests:</em>
</p>

<pre>
    locationTest          Performs locations tests on two samples
      .tTest              Unpaired t test for differences in mean
      .kw2Test            Kruskal-Wallis test for differences in locations
    scaleTest             Performs scale tests on two samples
      .ansariTest         Ansari-Bradley test for differences in scale
      .moodTest           Mood test for differences in scale
    varianceTest          Performs variance tests on two samples
      .varfTest           F test for differences in variances
      .bartlett2Test      Bartlett's test for differences in variances
      .fligner2Test       Fligner-Killeen test for differences in variances
    </pre>
<p><em>Two Sample Tests:</em>
</p>

<pre>
    ks2Test               Performs a two sample Kolmogorov-Smirnov test
    correlationTest       Performs correlation tests on two samples
    pearsonTest           Pearson product moment correlation coefficient
    kendallTest           Kendall's tau correlation test
    spearmanTest          Spearman's rho correlation test
    </pre>
<p><em>Test Utilities:</em>
</p>

<pre>
    'fHTEST'              S4 Class Representation
    show.fHTEST           S4 Print Method
      .jbALM              Jarque Bera Augmented Lagrange Multiplier Data
      .jbLM               Jarque-Bera Lagrange Multiplier Data
      .jbTable            Finite sample p values for the Jarque Bera test
      .jbPlot             Plots probabilities
      .pjb                Returns probabilities for JB given quantiles
      .qjb                Returns quantiles for JB given probabilities
    </pre>


<h3>5 Plotting Routines</h3>

<p><em>Financial Time Series Plots:</em>
</p>

<pre>
    seriesPlot            Dispalys a time series plot
    cumulatedPlot         Displays cumulated series give returns
    returnPlot            Displays returns given cumulated series
    drawdownPlot          Displays drawdown series from returns
    </pre>
<p><em>Correlation Plots:</em>
</p>

<pre>
    acfPlot               Displays tailored ACF plot
    pacfPlot              Displays tailored partial ACF plot
    teffectPlot           Displays the Taylor effect
    lacfPlot              Displays lagged autocorrelations
    </pre>
<p><em>Distribution Plots:</em>
</p>

<pre>
    histPlot              Returns tailored histogram plot
    densityPlot           Returns tailored density plot 
    logDensityPlot        Returns tailored log density plot
    boxPlot               Returns side-by-side standard box plot
    boxPercentile         Plotreturns box-percentile plot
    qqnormPlot            Returns normal quantile-quantile plot
    qqnigPlot             Returns NIG quantile-quantile plot
    qqghtPlot             Rreturns  GHT quantile-quantile plot
    qqgldPlot             Returns GLD quantile-quantile plot
    </pre>
<p><em> Time Series Aggregation Plots:</em>
</p>

<pre>
    scalinglawPlot        Displays scaling law behavior
    </pre>


<h3>5. Matrix Computations and Linear Algebra</h3>

<p><em>Elementar Matrix Operation Addons:</em>
</p>

<pre>
    kron                  Returns the Kronecker product
    vec                   Stacks a matrix as column vector
    vech                  Stacks a lower triangle matrix
    pdl                   Returns regressor matrix for polynomial lags
    tslag                 Returns Lagged/leading vector/matrix
    </pre>
<p><em>Linear Algebra Addons:</em>
</p>

<pre>
    inv                   Returns the inverse of a matrix
    norm                  Returns the norm of a matrix
    rk                    Returns the rank of a matrix
    tr                    Returns the trace of a matrix
    </pre>
<p><em>General Matrix Utility Addons:</em>
</p>


<pre>
    isPositiveDefinite    Checks if a matrix is positive definite
    makePositiveDefinite  Forces a matrix to be positive definite
    colVec                Creates a column vector from a data vector
    rowVec                Creates a row vector from a data vector
    gridVector            Creates from two vectors rectangular grid
    triang                Extracs lower tridiagonal part from a matrix
    Triang                Extracs upper tridiagonal part from a matrix
    </pre>
<p><em>Selected Matrix Examples:</em>
</p>

<pre>
    hilbert               Creates a Hilbert matrix
    pascal                Creates a Pascal matrix
    </pre>


<h3>6 Utility Functions</h3>

<p><em>Color Utilities:</em>
</p>

<pre>
    colorLocator            Plots Rs 657 named colors for selection
    colorMatrix             Returns matrix of R's color names.
    colorTable              Table of Color Codes and Plot Colors itself
    rainbowPalette          Contiguous rainbow color palette
    heatPalette             Contiguous heat color palette
    terrainPalette          Contiguous terrain color palette
    topoPalette             Contiguous topo color palette
    cmPalette               Contiguous cm color palette
    greyPalette             R's gamma-corrected gray palette
    timPalette              Tim's Matlab like color palette
    rampPalette             Color ramp palettes
    seqPalette              Sequential color brewer palettes
    divPalette              Diverging color brewer palettes
    qualiPalette            Qualified color brewer palettes
    focusPalette            Red, green blue focus palettes
    monoPalette             Red, green blue mono palettes
    </pre>
<p><em>Graphics Utilities:</em>
</p>


<pre>
    symbolTable             Shows a table of plot symbols
    characterTable          Shows a table of character codes
    decor                   Adds horizontal grid and L shaped box
    hgrid                   Adds horizontal grid lines
    vgrid                   Adds vertical grid lines
    boxL                    Adds L-shaped box
    box                     Adds unterlined box
      .xrug                 Adds rugs on x axis
      .yrug                 Adds rugs on y axis
    copyright               Adds copyright notice
    interactivePlot         Plots several graphs interactively
    </pre>
<p><em>Special Function Utilities:</em>
</p>

<pre>
    Heaviside               Computes Heaviside unit step function
    Sign                    Another signum function
    Delta                   Computes delta function
    Boxcar                  Computes boxcar function
    Ramp                    Computes ramp function
    tsHessian               Computes Two Sided Hessian matrix
    </pre>
<p><em>Other Utilities:</em>
</p>

<pre>
    .unirootNA              Computes zero of a function without error exit
    getModel                Extracts the model slot from a S4 object
    getTitle                Extracts the title slot from a S4 object
    getDescription          Extracts the description slot
    getSlot                 Extracts a specified slot from a S4 object
    </pre>


<h3>About Builtin Functions</h3>

<p>Builtin functions are borrowed from contributed R packages and other 
sources.
There are several reasons why we have modified and copied code from 
other sources and included in this package.
</p>
<p>* The builtin code is not available on Debian, so that Linux users
have no easy acces to this code.
</p>
<p>* The original code conflicts with other code from this package or 
conflicts with Rmetrics design objectives.
</p>
<p>* We only need a very small piece of functionality from the original
package which may depend on other packages which are not needed.
</p>
<p>* The package from which we builtin the code is under current 
development, so that the functions often change and thus leads
to unexpectect behavior in the Rmetrics packages.
</p>
<p>* The package may be incompatible since it uses other time date
and time series classes than the 'timeDate' and 'timeSeries' objects
and methods from Rmetrics.
</p>
<p>We put the code in script files named <em>builtin-funPackage.R</em>
where &quot;fun&quot; denotes the (optional) major function name, and 
&quot;Package&quot; the name of the contributed package from which we 
copied the original code.
</p>
<p>Builtin functions include:
</p>
<pre>
    gelGmm                gll function from gmm package
    gmmGMM                gmm function from gmm package
    kweightsSandwhich     kweights from sandwhich package
    glGld                 gl functions from gld package
    ssdenGss              ssden from the gss package
    hypHyperbolicDist     hyp from HyperbolicDist package
    </pre>


<h3>Compiled Fortran and C Code:</h3>

<pre>
    gld.c                 source code from gld package
    nig.c                 source code from Kersti Aas
    gss.f                 source code fromsandwhich package
    </pre>


<h3>About Rmetrics:</h3>

<p>The <code>fBasics</code> Rmetrics package is written for educational 
support in teaching &quot;Computational Finance and Financial Engineering&quot; 
and licensed under the GPL.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz [aut] (original code),
Tobias Setz [aut],
Yohan Chalabi [aut],
Martin Maechler [ctb] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
Georgi N. Boshnakov [cre, ctb]
CRAN Team [ctb]
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>

<hr>
<h2 id='acfPlot'>Autocorrelation function plots</h2><span id='topic+acfPlot'></span><span id='topic+pacfPlot'></span><span id='topic+teffectPlot'></span><span id='topic+lacfPlot'></span>

<h3>Description</h3>

<p>Returns plots of autocorrelations including
the autocorrelation function ACF, the partial
ACF, the lagged ACF, and the Taylor effect plot.
<br />
</p>
<p>The functions to display stylized facts are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>acfPlot</code> </td><td style="text-align: left;"> autocorrelation function plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>pacfPlot</code> </td><td style="text-align: left;"> partial autocorrelation function plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lacfPlot</code> </td><td style="text-align: left;"> lagged autocorrelation function plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>teffectPlot</code> </td><td style="text-align: left;"> Taylor effect plot.</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>acfPlot(x, labels = TRUE, ...)
pacfPlot(x, labels = TRUE, ...) 

lacfPlot(x, n = 12, lag.max = 20, type = c("returns", "values"),
    labels = TRUE, ...)

teffectPlot(x, deltas = seq(from = 0.2, to = 3, by = 0.2), lag.max = 10, 
    ymax = NA, standardize = TRUE, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfPlot_+3A_x">x</code></td>
<td>

<p>an uni- or multivariate return series of class <code>timeSeries</code> or
any other object which can be transformed by the function
<code>as.timeSeries()</code> into an object of class <code>timeSeries</code>.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_labels">labels</code></td>
<td>

<p>a logical value. Whether or not x- and y-axes should be
automatically labeled and a default main title should be added to
the plot.  By default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_n">n</code></td>
<td>

<p>an integer value, the number of lags.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_lag.max">lag.max</code></td>
<td>

<p>maximum lag for which the autocorrelation should be calculated, an
integer.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_type">type</code></td>
<td>

<p>a character string which specifies the type of the input series,
either &quot;returns&quot; or series &quot;values&quot;. In the case of a return series
as input, the required value series is computed by cumulating the
financial returns: <code>exp(colCumsums(x))</code>
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_deltas">deltas</code></td>
<td>

<p>the exponents, a numeric vector, by default ranging from 0.2 to 3.0
in steps of 0.2.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_ymax">ymax</code></td>
<td>

<p>maximum y-axis value on plot. If <code>NA</code>, then the value is
selected automatically.
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_standardize">standardize</code></td>
<td>

<p>a logical value. Should the vector <code>x</code> be standardized?
</p>
</td></tr>
<tr><td><code id="acfPlot_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Autocorrelation Functions:</b>
<br /><br />
The functions <code>acfPlot</code> and <code>pacfPlot</code>, plot and estimate 
autocorrelation and partial autocorrelation function. The functions 
allow to get a first view on correlations within the time series. 
The functions are synonym function calls for R's <code>acf</code> and 
<code>pacf</code> from the the <code>ts</code> package.
<br />
</p>
<p><b>Taylor Effect:</b>
<br /><br />
The &quot;Taylor Effect&quot; describes the fact that absolute returns of
speculative assets have significant serial correlation over long
lags. Even more, autocorrelations of absolute returns are
typically greater than those of squared returns. From these 
observations the Taylor effect states, that that the autocorrelations
of absolute returns to the the power of <code>delta</code>, 
<code>abs(x-mean(x))^delta</code> reach their maximum at <code>delta=1</code>.
The function <code>teffect</code> explores this behaviour. A plot is
created which shows for each lag (from 1 to <code>max.lag</code>) the 
autocorrelations as a function of the exponent <code>delta</code>. 
In the case that the above formulated hypothesis is supported,
all the curves should peak at the same value around <code>delta=1</code>.
</p>


<h3>Value</h3>

<p>for <code>acfPlot</code> and <code>pacfplot</code>,
an object of class <code>"acf"</code>, see <code><a href="stats.html#topic+acf">acf</a></code>;
</p>
<p>for <code>teffectPlot</code>, a numeric matrix
of order <code>deltas</code> by <code>max.lag</code> with
the values of the autocorrelations;
</p>
<p>for <code>lacfPlot</code>, a list with the following two elements:
</p>
<table>
<tr><td><code>Rho</code></td>
<td>
<p>the autocorrelation function,</p>
</td></tr>
<tr><td><code>lagged</code></td>
<td>
<p>the lagged correlations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taylor S.J. (1986); 
<em>Modeling Financial Time Series</em>,
John Wiley and Sons, Chichester.
</p>
<p>Ding Z., Granger C.W.J., Engle R.F. (1993); 
<em>A long memory property of stock market returns and a new model</em>,
Journal of Empirical Finance 1, 83.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## data - 
   data(LPP2005REC, package = "timeSeries")
   SPI &lt;- LPP2005REC[, "SPI"]
   plot(SPI, type = "l", col = "steelblue", main = "SP500")
   abline(h = 0, col = "grey")

## teffectPlot -
   # Taylor Effect:
   teffectPlot(SPI)
</code></pre>

<hr>
<h2 id='akimaInterp'>Bivariate Spline Interpolation</h2><span id='topic+akimaInterp'></span><span id='topic+akimaInterpp'></span>

<h3>Description</h3>

<p>Interpolates bivariate data sets using Akima
spline interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>akimaInterp(x, y = NULL, z = NULL, gridPoints = 21,
    xo = seq(min(x), max(x), length = gridPoints),
    yo = seq(min(y), max(y), length = gridPoints), extrap = FALSE)

akimaInterpp(x, y = NULL, z = NULL, xo, yo, extrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="akimaInterp_+3A_x">x</code>, <code id="akimaInterp_+3A_y">y</code>, <code id="akimaInterp_+3A_z">z</code></td>
<td>

<p>for <code>akimaInterp</code> the arguments <code>x</code> and <code>y</code> are
two numeric vectors of grid pounts, and <code>z</code> is a numeric
matrix or any other rectangular object which can be transformed
by the function <code>as.matrix</code> into a matrix object.
For <code>akimaInterpp</code> we  consider either three numeric vectors
of equal length or if  <code>y</code> and <code>z</code> are NULL, a list with
entries <code>x</code>, <code>y</code>, <code>z</code>, or named data frame with
<code>x</code> in the first, <code>y</code> in the second, and <code>z</code> in
the third column.
</p>
</td></tr>
<tr><td><code id="akimaInterp_+3A_gridpoints">gridPoints</code></td>
<td>

<p>an integer value specifying the number of grid points in <code>x</code>
and <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="akimaInterp_+3A_xo">xo</code>, <code id="akimaInterp_+3A_yo">yo</code></td>
<td>

<p>for <code>akimaInterp</code>
two numeric vectors of data points spanning the grid, and
for <code>akimaInterpp</code>
two numeric vectors of data points building pairs for pointwise
interpolation.
</p>
</td></tr>
<tr><td><code id="akimaInterp_+3A_extrap">extrap</code></td>
<td>

<p>a logical, if <code>TRUE</code> then the data points are extrapolated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two options are available: gridded and pointwise interpolation.
</p>
<p><code>akimaInterp</code> is a wrapper to <code>interp</code> provided by the
contributed R package <code>akima</code>.  The Fortran code of the Akima
spline interpolation routine was written by H. Akima.
</p>
<p>Linear surface fitting and krige surface fitting are provided by the
functions <code><a href="#topic+linearInterp">linearInterp</a></code> and <code><a href="#topic+krigeInterp">krigeInterp</a></code>.
</p>


<h3>Value</h3>


<dl>
<dt>akimaInterp</dt><dd>
<p>returns a list with at least three entries, <code>x</code>, <code>y</code>
and <code>z</code>. Note, that the returned values, can be directly
used by the  <code>persp</code> and <code>contour</code> 3D plotting methods.
</p>
</dd>
<dt>akimaInterpp</dt><dd>
<p>returns a data.frame with columns <code>"x"</code>, <code>"y"</code>,
and <code>"z"</code>.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Package <code>akima</code> is no longer needed. Equivalent functions from
package <code>interp</code> are now called instead.
</p>


<h3>References</h3>

<p>Akima H., 1978,
<em>A Method of Bivariate Interpolation and Smooth Surface Fitting for
Irregularly Distributed Data Points</em>,
ACM Transactions on Mathematical Software 4, 149-164.
</p>
<p>Akima H., 1996,
<em>Algorithm 761: Scattered-Data Surface Fitting that has the Accuracy
of a Cubic Polynomial</em>,
ACM Transactions on Mathematical Software 22, 362-371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearInterp">linearInterp</a></code>,
<code><a href="#topic+krigeInterp">krigeInterp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Does not run for r-solaris-x86
## akimaInterp -- Akima Interpolation:
if (requireNamespace("interp")) {
  set.seed(1953)
  x &lt;- runif(999) - 0.5
  y &lt;- runif(999) - 0.5
  z &lt;- cos(2*pi*(x^2+y^2))
  ans &lt;- akimaInterp(x, y, z, gridPoints = 41, extrap = FALSE)
  persp(ans, theta = -40, phi = 30, col = "steelblue",
       xlab = "x", ylab = "y", zlab = "z")
  contour(ans)
}

## Use spatial as alternative on r-solaris-x86
## spatialInterp - Generate Kriged Grid Data:
if (requireNamespace("spatial")) {
  RNGkind(kind = "Marsaglia-Multicarry", normal.kind = "Inversion")
  set.seed(4711, kind = "Marsaglia-Multicarry")
  x &lt;- runif(999)-0.5
  y &lt;- runif(999)-0.5
  z &lt;- cos(2*pi*(x^2+y^2))
  ans &lt;- krigeInterp(x, y, z, extrap = FALSE)
  persp(ans)
  title(main = "Kriging")
  contour(ans)
  title(main = "Kriging")
}

</code></pre>

<hr>
<h2 id='baseMethods'>Generic functions extensions</h2><span id='topic+baseMethods'></span><span id='topic+termPlot'></span><span id='topic+termPlot.default'></span><span id='topic+stdev'></span><span id='topic+stdev.default'></span>

<h3>Description</h3>

<p>Basic extensions which add and/or modify additional functionality
which is not available in R's basic packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
stdev(x, na.rm = FALSE)

## Default S3 method:
termPlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseMethods_+3A_model">model</code></td>
<td>

<p>a fitted model object.
</p>
</td></tr>
<tr><td><code id="baseMethods_+3A_x">x</code></td>
<td>

<p>an object for which to compute the standard deviation.
</p>
</td></tr>
<tr><td><code id="baseMethods_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value - should the NA values be removed.
</p>
</td></tr>  
<tr><td><code id="baseMethods_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdev</code> and <code>termPlot</code> are generic functions with default
methods <code>stats::sd</code> and <code>stats::termplot</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>,
<code><a href="stats.html#topic+termplot">termplot</a></code>
</p>

<hr>
<h2 id='BasicStatistics'>Basic time series statistics</h2><span id='topic+basicStats'></span>

<h3>Description</h3>

<p>Computes basic financial time series statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
basicStats(x, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BasicStatistics_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code> or any other object which can
be transformed by the function <code>as.timeSeries</code> into an object
of class <code>"timeSeries"</code>. The latter case, other than
<code>"timeSeries"</code> objects, is more or less untested.
</p>
</td></tr>  
<tr><td><code id="BasicStatistics_+3A_ci">ci</code></td>
<td>

<p>confidence interval, a numeric value, by default 0.95, i.e. 95%.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a number of sample statistics for each column of
<code>x</code>. The statistics should be clear from the row names of the
returned data frame.
</p>
<p><code>"LCL"</code> and <code>"UCL"</code> stand for lower/upper confidence limits,
computed under the null hypothesis of i.i.d.
</p>
<p><code>"Kurtosis"</code> represents the <em>excess kurtosis</em>, so its
theoretical value for the normal distribution is zero, not 3.
</p>
<p>These statistics are often computed as a first step in the study of
returns on financial assets. In that case any inference on these
statistics (including the confidence intervals for the mean) should be
considered exploratory, since returns are virtually never i.i.d.
</p>


<h3>Value</h3>

<p>a data frame with one column for each column of <code>x</code> and the
following rows:
</p>
<table>
<tr><td><code>"nobs"</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>"NAs"</code></td>
<td>
<p>number of <code>NA</code>s</p>
</td></tr>
<tr><td><code>"Minimum"</code></td>
<td>
<p>minimum,</p>
</td></tr>
<tr><td><code>"Maximum "</code></td>
<td>
<p>maximum,</p>
</td></tr>
<tr><td><code>"1. Quartile"</code></td>
<td>
<p>lower quartile,</p>
</td></tr>
<tr><td><code>"3. Quartile"</code></td>
<td>
<p>upper quartile,</p>
</td></tr>
<tr><td><code>"Mean"</code></td>
<td>
<p>mean, </p>
</td></tr>
<tr><td><code>"Median"</code></td>
<td>
<p>median,</p>
</td></tr>
<tr><td><code>"Sum"</code></td>
<td>
<p>sum of the values,</p>
</td></tr>
<tr><td><code>"SE Mean"</code></td>
<td>
<p>standard error of the mean,</p>
</td></tr>
<tr><td><code>"LCL Mean"</code></td>
<td>
<p>lower limit of the CI for the mean,</p>
</td></tr>
<tr><td><code>"UCL Mean"</code></td>
<td>
<p>upper limit of the CI for the mean,</p>
</td></tr>
<tr><td><code>"Variance"</code></td>
<td>
<p>variance, </p>
</td></tr>
<tr><td><code>"Stdev"</code></td>
<td>
<p>standard deviation,</p>
</td></tr>
<tr><td><code>"Skewness"</code></td>
<td>
<p>skewness coefficient,</p>
</td></tr>
<tr><td><code>"Kurtosis"</code></td>
<td>
<p>excess kurtosis.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## basicStats -
   # Simulated Monthly Return Data:
   tS = timeSeries(matrix(rnorm(12)), timeDate::timeCalendar())
   basicStats(tS)
</code></pre>

<hr>
<h2 id='BoxPlot'>Time series box plots</h2><span id='topic+boxPlot'></span><span id='topic+boxPercentilePlot'></span>

<h3>Description</h3>

<p>Produce  a box plot or a box percentile plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
boxPlot(x, col = "steelblue", title = TRUE, ...)
boxPercentilePlot(x, col = "steelblue", title = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxPlot_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code> or any other object which can
be transformed by the function <code>as.timeSeries</code> into an object
of class <code>timeSeries</code>. The latter case, other then
<code>timeSeries</code> objects, is more or less untested.
</p>
</td></tr>  
<tr><td><code id="BoxPlot_+3A_col">col</code></td>
<td>

<p>the color for the series. In the univariate case use just a color
name like the default, <code>col="steelblue"</code>, in the multivariate
case we recommend to select the colors from a color palette,
e.g. <code>col=heat.colors(ncol(x))</code>.
</p>
</td></tr>
<tr><td><code id="BoxPlot_+3A_title">title</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a default title added
to the plot?
</p>
</td></tr>
<tr><td><code id="BoxPlot_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>boxPlot</code> produces a side-by-side standard box plot,
</p>
<p><code>boxPercentilePlot</code> produces a side-by-side box-percentile plot.
</p>


<h3>Value</h3>

<p><code>NULL</code>, 
displays a time series plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data - 
   data(LPP2005REC, package = "timeSeries")
   LPP &lt;- LPP2005REC[, 1:6]
   plot(LPP, type = "l", col = "steelblue", main = "SP500")
   abline(h = 0, col = "grey")
   
## boxPlot -
   boxPlot(LPP) 
</code></pre>

<hr>
<h2 id='characterTable'>Table of characters</h2><span id='topic+characterTable'></span>

<h3>Description</h3>

<p>Displays a table of numerical equivalents to Latin characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
characterTable(font = 1, cex = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="characterTable_+3A_cex">cex</code></td>
<td>

<p>a numeric value, determines the character size, the default 
size is 0.7.
</p>
</td></tr>  
<tr><td><code id="characterTable_+3A_font">font</code></td>
<td>

<p>an integer value, the number of the <code>font</code>, by default font
number 1.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>displays a table with the characters of the requested font.  The
character on line <code>"xy"</code> and column <code>"z"</code> of the table has
code <code>"\xyz"</code>, e.g <code>cat("\126")</code> prints: V for font number
1. These codes can be used as any other characters.
</p>


<h3>Note</h3>

<p>What happens with non-ASCII characters in plots is system dependent
and depends on the graphics device, as well. Use of such characters is
not recommended for portable code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorTable">colorTable</a></code>,
<code><a href="#topic+symbolTable">symbolTable</a></code>
</p>
<p><code><a href="graphics.html#topic+points">points</a></code> for use of characters in plotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Character Table for Font 1:
# characterTable(font = 1)
</code></pre>

<hr>
<h2 id='colorLocator'>Named colors in R</h2><span id='topic+colorLocator'></span><span id='topic+colorMatrix'></span>

<h3>Description</h3>

<p>Displays <span class="rlang"><b>R</b></span>'s 657 named colors for selection and
returns optionally <span class="rlang"><b>R</b></span>'s color names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorLocator(locator = FALSE, cex.axis = 0.7)
colorMatrix()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorLocator_+3A_locator">locator</code></td>
<td>

<p>logical, if true, <code><a href="graphics.html#topic+locator">locator</a></code> is used for interactive
selection of color names, default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="colorLocator_+3A_cex.axis">cex.axis</code></td>
<td>

<p>size of axis labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Color Locator:
</p>
<p>The <code>colorLocator</code> function plots R's 657 named colors.  If
<code>locator=TRUE</code> then you can interactively point and click to
select the colors for which you want names. To end selection, right
click on the mouse and select 'Stop', then R returns the selected
color names.
</p>
<p>The functions used here are wrappers to the functions provided by
Tomas Aragon in the contributed R package <code>epitools</code>.
</p>


<h3>Value</h3>

<p>Color Locator:
</p>
<p><code>colorsLocator()</code> generates a plot with R colors and, when
<code>locator</code> is true, returns matrix with graph coordinates and
names of colors selected.
<code>colorsMatrix()</code> quietly returns the matrix of names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorPalette">colorPalette</a></code>,
<code><a href="#topic+colorTable">colorTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> colorLocator()
</code></pre>

<hr>
<h2 id='colorPalette'>Color palettes</h2><span id='topic+colorPalette'></span><span id='topic+rainbowPalette'></span><span id='topic+heatPalette'></span><span id='topic+terrainPalette'></span><span id='topic+topoPalette'></span><span id='topic+cmPalette'></span><span id='topic+greyPalette'></span><span id='topic+timPalette'></span><span id='topic+rampPalette'></span><span id='topic+seqPalette'></span><span id='topic+divPalette'></span><span id='topic+qualiPalette'></span><span id='topic+focusPalette'></span><span id='topic+monoPalette'></span>

<h3>Description</h3>

<p>Functions to create color palettes.
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>rainbowPalette</code> </td><td style="text-align: left;"> Contiguous rainbow color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>heatPalette</code> </td><td style="text-align: left;"> Contiguous heat color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>terrainPalette</code> </td><td style="text-align: left;"> Contiguous terrain color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>topoPalette</code> </td><td style="text-align: left;"> Contiguous topo color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cmPalette</code> </td><td style="text-align: left;"> Contiguous cm color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>greyPalette</code> </td><td style="text-align: left;"> R's gamma-corrected gray palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>timPalette</code> </td><td style="text-align: left;"> Tim's Matlab like color palette, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rampPalette</code> </td><td style="text-align: left;"> Color ramp palettes, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>seqPalette</code> </td><td style="text-align: left;"> Sequential color brewer palettes, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>divPalette</code> </td><td style="text-align: left;"> Diverging color brewer palettes, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>qualiPalette</code> </td><td style="text-align: left;"> Qualified color brewer palettes, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>focusPalette</code> </td><td style="text-align: left;"> Red, green blue focus palettes, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>monoPalette</code> </td><td style="text-align: left;"> Red, green blue mono palettes. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'> 
rainbowPalette(n = 64, ...) 
heatPalette(n = 64, ...) 
terrainPalette(n = 64, ...) 
topoPalette(n = 64, ...) 
cmPalette(n = 64, ...) 

greyPalette(n = 64, ...)
timPalette(n = 64)

rampPalette(n, name = c("blue2red", "green2red", "blue2green",     
    "purple2green", "blue2yellow", "cyan2magenta"))
    
seqPalette(n, name = c(
    "Blues", "BuGn", "BuPu", "GnBu", "Greens", "Greys", "Oranges", 
    "OrRd", "PuBu", "PuBuGn", "PuRd", "Purples", "RdPu", "Reds", 
    "YlGn", "YlGnBu", "YlOrBr", "YlOrRd"))
divPalette(n, name = c(
    "BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", 
    "Spectral"))   
qualiPalette(n, name = c(
    "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", 
    "Set3")) 
    
focusPalette(n, name = c("redfocus", "greenfocus", "bluefocus"))
monoPalette(n, name = c("redmono", "greenmono", "bluemono"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorPalette_+3A_n">n</code></td>
<td>

<p>an integer, giving the number of greys or colors to be constructed.
</p>
</td></tr> 
<tr><td><code id="colorPalette_+3A_name">name</code></td>
<td>

<p>a character string, the name of the color set.
</p>
</td></tr>    
<tr><td><code id="colorPalette_+3A_...">...</code></td>
<td>

<p>arguments to be passed, see the details section
</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>All Rmetrics' color sets are named as <code>fooPalette</code>, where the 
prefix <code>foo</code> denotes the name of the underlying color set.
</p>


<h4>R's Contiguous Color Palettes:</h4>

<p>Palettes for <code>n</code> contiguous colors are implemented in the
<code>grDevices</code> package. To conform with Rmetrics' naming
convention for color palettes we have build wrappers around the
underlying functions. These are the <code>rainbowPalette</code>,
<code>heatPalette</code>, <code>terrainPalette</code>, <code>topoPalette</code>, and
the <code>cmPalette</code>.
</p>
<p>Conceptually, all of these functions actually use (parts of) a
line cut out of the 3-dimensional color space, parametrized by the
function <code>hsv(h,s,v,gamma)</code>, where <code>gamma=1</code> for the
<code>fooPalette</code> function, and hence, equispaced hues in RGB
space tend to cluster at the red, green and blue primaries.
</p>
<p>Some applications, such as contouring, require a palette of colors
which do not wrap around to give a final color close to the
starting one. To pass additional arguments to the underlying
functions see <code>help(rainbow)</code>.  With rainbow, the parameters
<code>start</code> and <code>end</code> can be used to specify particular
subranges of hues. Synonym function calls are <code>rainbow</code>,
<code>heat.colors</code>, <code>terrain.colors</code>, <code>topo.colors</code>, and
<code>cm.colors</code>.
</p>



<h4>R's Gamma-Corrected Gray Palette:</h4>

<p><code>grayPalette</code> chooses a series of <code>n</code> gamma-corrected
gray levels. The range of the gray levels can be optionally
monitored through the <code>...</code> arguments, for details see
<code>help(gray.colors)</code>, which is a synonym function call in the
<code>grDevices</code> package.
</p>



<h4>Tim's Matlab like Color Palette:</h4>

<p><code>timPalette</code> creates a color set ranging from blue to red,
and passes through the colors cyan, yellow, and orange. It comes
from the Matlab software, originally used in fluid dynamics
simulations. The function here is a copy from R's contributed
package <code>fields</code> doing a spline interpolation on <code>n=64</code>
color points.
</p>



<h4>Color Ramp Palettes:</h4>

<p><code>rampPalette</code> creates several color ramps. The function is
implemented from Tim Keitt's contributed R package
<code>colorRamps</code>.  Supported through the argument <code>name</code> are
the following color ramps: <code>"blue2red"</code>, <code>"green2red"</code>,
<code>"blue2green"</code>, <code>"purple2green"</code>, <code>"blue2yellow"</code>,
<code>"cyan2magenta"</code>.
</p>



<h4>Color Brewer Palettes:</h4>

<p>The functions <code>seqPalette</code>, <code>divPalette</code>, and
<code>qualiPalette</code> create color sets according to R's contributed
<code>RColorBrewer</code> package. The first letter in the function name
denotes the type of the color set: &quot;s&quot; for sequential palettes,
&quot;d&quot; for diverging palettes, and &quot;q&quot; for qualitative palettes.
</p>
<p><em>Sequential palettes</em> are suited to ordered data that
progress from low to high. Lightness steps dominate the look of
these schemes, with light colors for low data values to dark
colors for high data values. The sequential palettes names are:
Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu,
PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd.
</p>
<p><em>Diverging palettes</em> put equal emphasis on mid-range critical
values and extremes at both ends of the data range. The critical
class or break in the middle of the legend is emphasized with
light colors and low and high extremes are emphasized with dark
colors that have contrasting hues.  The diverging palettes names
are: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral.
</p>
<p><em>Qualitative palettes</em> do not imply magnitude differences
between legend classes, and hues are used to create the primary
visual differences between classes. Qualitative schemes are best
suited to representing nominal or categorical data.  The
qualitative palettes names are: Accent, Dark2, Paired, Pastel1,
Pastel2, Set1, Set2, Set3.
</p>
<p>In contrast to the original color brewer palettes, the palettes
here are created by spline interpolation from the color variation
with the most different values, i.e for the sequential palettes
these are 9 values, for the diverging palettes these are 11
values, and for the qualitative palettes these are between 8 and
12 values dependeing on the color set.
</p>



<h4>Graph Color Palettes</h4>

<p>The function <code>perfanPalette</code> creates color sets inspired by
R's contributed package <code>Performance Analytics</code>.  These color
palettes have been designed to create readable, comparable line
and bar graphs with specific objectives.
</p>

<dl>
<dt>Focused Color Palettes</dt><dd>
<p>Color sets designed to provide focus to the data graphed as the
first element. This palette is best used when there is clearly
an important data set for the viewer to focus on, with the
remaining data being secondary, tertiary, etc. Later elements
graphed in diminishing values of gray.
</p>
</dd>
<dt>Monochrome Color Palettes</dt><dd>
<p>These include color sets for monochrome color displays.
</p>
</dd>
</dl>




<h3>Value</h3>

<p>a character string of color strings
</p>


<h3>Note</h3>

<p>The palettes are wrapper functions provided in several contributed 
R packages. These include:
</p>
<p>Cynthia Brewer and Mark Harrower for the brewer palettes, <br />
Peter Carl and Brian G. Peterson for the &quot;PerformanceAnalytics&quot; package, <br />
Tim Keitt for the &quot;colorRamps&quot; package, <br />
Ross Ihaka for the &quot;colorspace&quot; package, <br />
Tomas Aragon for the &quot;epitools&quot; package, <br />
Doug Nychka for the &quot;fields&quot; package, <br />
Erich Neuwirth for the &quot;RColorBrewer&quot; package.
<br />
</p>
<p>Additional undocumented hidden functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    
    
    <code>.asRGB</code> </td><td style="text-align: left;"> Converts any R color to RGB (red/green/blue), </td>
</tr>
<tr>
 <td style="text-align: left;">
    
    
    <code>.chcode</code> </td><td style="text-align: left;"> Changes from one to another number system, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>.hex.to.dec</code> </td><td style="text-align: left;"> Converts heximal numbers do decimal numbers, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>.dec.to.hex</code> </td><td style="text-align: left;"> Converts decimal numbers do heximal numbers.</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>## GreyPalette:
   greyPalette()
</code></pre>

<hr>
<h2 id='colorTable'>Table of colors</h2><span id='topic+colorTable'></span>

<h3>Description</h3>

<p>Displays a table of color codes and plots the colors themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
colorTable(cex = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorTable_+3A_cex">cex</code></td>
<td>

<p>a numeric value, determines the character size in the color plot,
the default is 0.7.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>a table of plot colors with the associated color numbers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterTable">characterTable</a></code>,
<code><a href="#topic+symbolTable">symbolTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## Color Table:
   colorTable()
</code></pre>

<hr>
<h2 id='colVec'>Column and row vectors</h2><span id='topic+colVec'></span><span id='topic+rowVec'></span>

<h3>Description</h3>

<p>Creates a column or row vector from a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colVec(x)
rowVec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colVec_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>colVec</code> and <code>rowVec</code> transform a vector into a column and
row vector, respectively. A column vector is a matrix object with one
column, and a row vector is a matrix object with one row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a numeric Vector:
   x = rnorm(5)
   
## Column and Row Vectors:
   colVec(x)
   rowVec(x)                        
</code></pre>

<hr>
<h2 id='correlationTest'>Correlation tests</h2><span id='topic+correlationTest'></span><span id='topic+pearsonTest'></span><span id='topic+kendallTest'></span><span id='topic+spearmanTest'></span>

<h3>Description</h3>

<p>Tests if two series are correlated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
correlationTest(x, y, method = c("pearson", "kendall", "spearman"), 
    title = NULL, description = NULL)

pearsonTest(x, y, title = NULL, description = NULL) 
kendallTest(x, y, title = NULL, description = NULL)
spearmanTest(x, y, title = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlationTest_+3A_x">x</code>, <code id="correlationTest_+3A_y">y</code></td>
<td>

<p>numeric vectors of data values.
</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_method">method</code></td>
<td>

<p>a character string naming which test should be applied.
</p>
</td></tr> 
<tr><td><code id="correlationTest_+3A_title">title</code></td>
<td>

<p>an optional title string, if not specified the input's data 
name is deparsed.
</p>
</td></tr>
<tr><td><code id="correlationTest_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>These functions test for association/correlation between paired
samples based on the Pearson's product moment correlation coefficient
(a.k.a. sample correlation), Kendall's tau, and Spearman's rho
coefficients.
</p>
<p><code>pearsonTest</code>, <code>kendallTest</code>, and <code>spearmanTest</code> are
wrappers of base R's <code><a href="stats.html#topic+cor.test">cor.test</a></code> with simplified
interface.  They provide 'exact' and approximate p-values for all
three alternatives (two-sided, less, and greater), as well as 95%
confidence intervals. This is particularly convenient in interactive
use.
</p>
<p>Instead of calling the individual functions, one can use
<code>correlationTest</code> and specify the required test with argument
<code>method</code>.
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>


<h3>References</h3>

<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>Lehmann E.L. (1986); 
<em>Testing Statistical Hypotheses</em>, 
John Wiley and Sons, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locationTest">locationTest</a></code>,
<code><a href="#topic+scaleTest">scaleTest</a></code>,
<code><a href="#topic+varianceTest">varianceTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## x, y -
   x = rnorm(50)
   y = rnorm(50)
  
## correlationTest - 
   correlationTest(x, y, "pearson")
   correlationTest(x, y, "kendall")
   spearmanTest(x, y)
</code></pre>

<hr>
<h2 id='decor'>Functions for decorating plots</h2><span id='topic+decor'></span><span id='topic+hgrid'></span><span id='topic+vgrid'></span><span id='topic+boxL'></span><span id='topic+box_'></span><span id='topic+copyright'></span>

<h3>Description</h3>

<p>Functions for decorating plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decor()

hgrid(ny = NULL, ...) 
vgrid(nx = NULL, ...) 

boxL(col = "white") 
box_(col = c("white", "black")) 

copyright()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decor_+3A_col">col</code></td>
<td>

<p>the color of the background, <code>"black"</code> and foreground
<code>"white"</code> lines of the box.
</p>
</td></tr>
<tr><td><code id="decor_+3A_nx">nx</code>, <code id="decor_+3A_ny">ny</code></td>
<td>

<p>number of cells of the grid in <code>x</code> or <code>y</code> direction. When <code>NULL</code>, 
as per default, the grid aligns with the tick marks on the 
corresponding default axis (i.e., tick marks as computed by axTicks). 
</p>
</td></tr> 
<tr><td><code id="decor_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the <code>grid()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>decor</code> is equivalent to <code>hgrid()</code> followed by <code>boxL()</code>.
</p>
<p><code>hgrid</code> creates horizontal grid lines.
</p>
<p><code>vgrid</code> creates vertical grid lines.
</p>
<p><code>boxL</code>  creates an L-shaped box
</p>
<p><code>box_</code> creates a bottom line box.
</p>
<p><code>copyright</code> adds Rmetrics copyright to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(x = rnorm(100), type = "l", col = "red", 
     xlab = "", ylab = "Variates", las = 1)
title("Normal Deviates", adj = 0)
hgrid()
boxL()
copyright()
</code></pre>

<hr>
<h2 id='distCheck'>Distribution check</h2><span id='topic+distCheck'></span>

<h3>Description</h3>

<p>Tests properties of an <span class="rlang"><b>R</b></span> implementation of a distribution, i.e., of
all four of its &ldquo;dpqr&rdquo; functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distCheck(fun = "norm", n = 1000, robust = TRUE, subdivisions = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distCheck_+3A_fun">fun</code></td>
<td>

<p>a character string, the name of the distribution.
</p>
</td></tr>
<tr><td><code id="distCheck_+3A_n">n</code></td>
<td>

<p>an integer specifying the number of random variates to be
generated.
</p>
</td></tr>
<tr><td><code id="distCheck_+3A_robust">robust</code></td>
<td>

<p>logical flag, should robust estimates be used? By default
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="distCheck_+3A_subdivisions">subdivisions</code></td>
<td>

<p>integer specifying the numbers of subdivisions in integration.
</p>
</td></tr>
<tr><td><code id="distCheck_+3A_...">...</code></td>
<td>

<p>the distributional parameters.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>distCheck("norm", mean = 1, sd = 1)

distCheck("lnorm", meanlog = 0.5, sdlog = 2, robust=FALSE)
## here, true E(X) = exp(mu + 1/2 sigma^2) = exp(.5 + 2) = exp(2.5) = 12.182
## and      Var(X) = exp(2*mu + sigma^2)*(exp(sigma^2) - 1) =       7954.67
</code></pre>

<hr>
<h2 id='DistributionFits'>Parametric fit of a distribution</h2><span id='topic+DistributionFits'></span><span id='topic+nFit'></span><span id='topic+tFit'></span><span id='topic+stableFit'></span>

<h3>Description</h3>

<p>A collection and description of moment and maximum 
likelihood estimators to fit the parameters of a 
distribution. 
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>nFit</code> </td><td style="text-align: left;"> MLE parameter fit for a normal distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>tFit</code> </td><td style="text-align: left;"> MLE parameter fit for a Student t-distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>stableFit</code> </td><td style="text-align: left;"> MLE and Quantile Method stable parameter fit. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>nFit(x, doplot = TRUE, span = "auto", title = NULL, description = NULL, ...)

tFit(x, df = 4, doplot = TRUE, span = "auto", trace = FALSE, title = NULL, 
    description = NULL, ...)
    
stableFit(x, alpha = 1.75, beta = 0, gamma = 1, delta = 0, 
    type = c("q", "mle"), doplot = TRUE, control = list(),
    trace = FALSE, title = NULL, description = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistributionFits_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
    times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and right endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_control">control</code></td>
<td>

<p>a list of control parameters, see function <code>nlminb</code>.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_alpha">alpha</code>, <code id="DistributionFits_+3A_beta">beta</code>, <code id="DistributionFits_+3A_gamma">gamma</code>, <code id="DistributionFits_+3A_delta">delta</code></td>
<td>

<p>The parameters are <code>alpha</code>, <code>beta</code>, <code>gamma</code>, 
and <code>delta</code>:<br />
value of the index parameter <code>alpha</code> with <code>alpha = (0,2]</code>;
skewness parameter <code>beta</code>, in the range [-1, 1];
scale parameter <code>gamma</code>; and
shift parameter <code>delta</code>.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_df">df</code></td>
<td>

<p>the number of degrees of freedom for the Student distribution, 
<code>df &gt; 2</code>, maybe non-integer. By default a value of 4 is
assumed.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_type">type</code></td>
<td>

<p>a character string which allows to select the method for
parameter estimation: <code>"mle"</code>, the maximum log likelihood
approach, or <code>"qm"</code>, McCulloch's quantile method.
</p>
</td></tr>
<tr><td><code id="DistributionFits_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Stable Parameter Estimation:</b>
</p>
<p>Estimation techniques based on the quantiles of an empirical sample 
were first suggested by Fama and Roll [1971]. However their technique 
was limited to symmetric distributions and suffered from a small 
asymptotic bias. McCulloch [1986] developed a technique that uses 
five quantiles from a sample to estimate <code>alpha</code> and <code>beta</code>
without asymptotic bias. Unfortunately, the estimators provided by
McCulloch have restriction <code>alpha&gt;0.6</code>.
</p>
<p><em>Remark:</em> The parameter estimation for the stable distribution
via the maximum Log-Likelihood approach may take a quite long time.
</p>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
## nFit -
   # Simulate random normal variates N(0.5, 2.0):
   set.seed(1953)
   s = rnorm(n = 1000, 0.5, 2) 

## nigFit -  
   # Fit Parameters:
   nFit(s, doplot = TRUE) 
</code></pre>

<hr>
<h2 id='fBasics_reexports'>Objects exported from other packages</h2><span id='topic+as.timeSeries'></span><span id='topic+kurtosis'></span><span id='topic+skewness'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lagged</dt><dd><p><code><a href="timeSeries.html#topic+as.timeSeries">as.timeSeries</a></code></p>
</dd>
<dt>kurtosis</dt><dd><p><code><a href="timeDate.html#topic+kurtosis">kurtosis</a></code></p>
</dd>
<dt>skewness</dt><dd><p><code><a href="timeDate.html#topic+skewness">skewness</a></code></p>
</dd>
</dl>


<hr>
<h2 id='fBasics-deprecated'>Deprecated functions in package fBasics</h2><span id='topic+fBasics-deprecated'></span><span id='topic+.acfPlot'></span><span id='topic+.contourPlot'></span><span id='topic+.distCheck'></span><span id='topic+.firePlot'></span><span id='topic+.mrlPlot'></span><span id='topic+.pacfPlot'></span><span id='topic+.perspPlot'></span><span id='topic+.plot'></span><span id='topic+.predict'></span><span id='topic+.qStableFit'></span><span id='topic+.residualsPlot'></span><span id='topic+.responsesPlot'></span><span id='topic+.sliderMenu'></span><span id='topic+.unirootNA'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
the package only, and may be defunct as soon as of the next release.
</p>


<h3>Details</h3>






<p>There are none currently.
</p>
<p><code><a href="stabledist.html#topic+dstable">dstable</a></code>, etc., now are defunct, as they have
been available from <span class="pkg">stabledist</span> since early 2011.





</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>, <code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='fBasicsData'>fBasics data sets</h2><span id='topic+fBasicsData'></span><span id='topic+Capitalization'></span><span id='topic+cars2'></span><span id='topic+DowJones30'></span><span id='topic+HedgeFund'></span><span id='topic+msft.dat'></span><span id='topic+nyse'></span><span id='topic+PensionFund'></span><span id='topic+swissEconomy'></span><span id='topic+SWXLP'></span><span id='topic+usdthb'></span>

<h3>Description</h3>

<p>The following data sets are part of this package:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>Capitalization</code> </td><td style="text-align: left;"> Market capitalization of domestic companies, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cars2</code> </td><td style="text-align: left;"> Data for various car models, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>DowJones30</code> </td><td style="text-align: left;"> Down Jones 30 stocks, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>HedgeFund</code> </td><td style="text-align: left;"> Hennessee Hedge Fund Indices, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>msft.dat</code> </td><td style="text-align: left;"> Daily Microsoft OHLC prices and volume, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nyse</code> </td><td style="text-align: left;"> NYSE composite Index, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>PensionFund</code> </td><td style="text-align: left;"> Swiss Pension Fund LPP-2005, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>swissEconomy</code> </td><td style="text-align: left;"> Swiss Economic Data, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>SWXLP</code> </td><td style="text-align: left;"> Swiss Pension Fund LPP-2000, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>usdthb</code> </td><td style="text-align: left;"> Tick data of USD to THB.
  </td>
</tr>

</table>
    


<h3>Details</h3>

<p>All datasets are data frames. A brief description is given below.
</p>
<p><b>Capitalization:</b><br />
<code>Capitalization</code>
contains market capitalization of 13 domestic companies for 6 years
(from 2003 to 2008) in USD millions. Each row contains the data for
one company/stock exchange.
</p>
<p><b>cars2:</b><br />
<code>cars2</code>
contains columns <code>rowNames</code> (model), <code>Price</code>,
<code>Country</code>, <code>Reliability</code>, <code>Mileage</code>, (<code>Type</code>),
(<code>Weight</code>), <code>Disp.</code> (engine displacement) and <code>HP</code>
(<code>net horsepower</code>) reprsenting the indicated properties of 60 car
models.
</p>
<p><b>DowJones30:</b><br />
<code>DowJones30</code>
contains 2529 daily observations from the &lsquo;Dow Jones 30&rsquo; Index
series.  The first row contains the dates (from 1990-12-31 to
2001-01-02). Each of the remaining thirty columns represents the
closing price of a stock in the Index.
</p>
<p><b>HedgeFund:</b><br />
<code>HedgeFund</code>
contains monthly percentage returns of 16 hedge fund strategies from
Hennessee Group LLC for year 2005.
</p>
<p><b>msft.dat:</b><br />
<code>msft.dat</code>
contains daily prices (open, high, low and close) and volumes for the
Microsoft stocks.  It is a data frame with column names
<code>"%Y-%m-%d"</code>, <code>"Open"</code>, <code>"High"</code>, <code>"Low"</code>,
<code>"Close"</code>, <code>"Volume"</code>.
</p>
<p><em>Note:</em> there is a dataset, <code>MSFT</code>, in package
<span class="pkg">timeSeries</span> which contains the same data but is of class
<code>"timeSeries"</code>.
</p>
<p><b>nyse:</b><br />
<code>nyse</code>
contains daily records of the NYSE Composite Index from 1966-01-04 to
2002-12-31 (9311 observations). The data is in column <code>"NYSE"</code>
(second column). The first column contains the dates.
</p>
<p><b>PensionFund:</b><br />
<code>PensionFund</code>
is a daily data set of the Swiss pension fund benchmark LPP-2005.
The data set ranges from 2005-11-01 to 2007-04-11.
The columns are named: SBI, SPI, SII, LMI, MPI, ALT, LPP25, LPP40, LPP60.
</p>
<p><b>swissEconomy:</b><br />
<code>swissEconomy</code>
contains the GDP per capita (<code>GDPR</code>), exports (<code>EXPO</code>),
imports (<code>IMPO</code>), interest rates (<code>INTR</code>), inflation
(<code>INFL</code>), unemployment (<code>UNEM</code>) and population (<code>POPU</code>)
foryears 1964 to 1999 for Switzerland.
</p>
<p><b>SWXLP:</b><br />
<code>SWXLP</code>
is a daily data set of the Swiss pension fund benchmark LPP-2000.  The
data set ranges from 2000-01-03 to 2007-05-08 (1917 observations). The
first column contains the dates. The remaining columns are named: SBI,
SPI, SII, LP25, LP40, LP60.
</p>
<p><b>usdthb:</b><br />
<code>usdthb</code>
Tick data of US Dollar (USD) in Thailand Bhat (THB) collected from
Reuters. The date is in the first column in YYYYMMDDhhmm format. The
remaining columns contain: delay time (<code>DELAY</code>), contributor
(<code>CONTRIBUTOR</code>), bid (<code>BID</code>) and ask (<code>ASK</code>) prices,
and quality flag (<code>FLAG</code>). It covers the Asia FX crisis in June
1997.
</p>


<h3>References</h3>

<p><b>Capitalization:</b><br />
<em>World Federation of Stock Exchanges</em>,
http://www.world-exchanges.org/statistics.
</p>
<p><b>cars2:</b><br />
Derived from the car90 dataset within the rpart package.
The car90 dataset is based on the car.all dataset in S-PLUS.
Original data comes from:
April 1990, <em>Consumer Reports Magazine</em>,
pages 235-255, 281-285 and 287-288.





</p>
<p><b>DowJones30</b><br />
https://www.yahoo.com.
</p>
<p><b>HedgeFund:</b><br />
http://www.hennesseegroup.com/indices/returns/year/2005.html.
</p>
<p><b>msft.dat:</b><br />
https://www.yahoo.com.
</p>
<p><b>nyse:</b><br />
https://www.nyse.com.
</p>
<p><b>PensionFund:</b><br />
SBI, SPI, SII: SIX (Swiss Exchange Zurich);
LPP25, LPP40, LPP60: Banque Pictet Geneva;
LMI, MPI, ALT: Recalculated from the indices and benchmarks.
</p>
<p><b>swissEconomy:</b><br />
https://www.oecd.org/ and https://www.imf.org/.
</p>
<p><b>SWXLP:</b><br />
SBI, SPI, SII: SIX (Swiss Exchange Zurich);
LPP25, LPP40, LPP60: Banque Pictet Geneva.
</p>
<p><b>usdthb:</b><br />
Reuters Select Feed Terminal (1997).
</p>






<h3>Examples</h3>

<pre><code class='language-R'>## Plot DowJones30 Example Data Set
   series &lt;- timeSeries::as.timeSeries(DowJones30)
   head(series)
   plot(series[,1:6], type = "l")

## msft.dat contains (almost?) the same data as MSFT in package timeSeries
data(MSFT, package = "timeSeries")

m1 &lt;- as.matrix(msft.dat[, -1]) # drop date stamps in column 1
m2 &lt;- as.matrix(MSFT)
all.equal(m1, m2, check.attributes = FALSE) # TRUE
## compare the dates:
all.equal(format(msft.dat[ , 1]), format(time(MSFT))) # TRUE
</code></pre>

<hr>
<h2 id='fDISTFIT-class'>Class <code>"fDISTFIT"</code></h2><span id='topic+fDISTFIT-class'></span><span id='topic+show+2CfDISTFIT-method'></span>

<h3>Description</h3>

<p>S4 class representing fitted distributions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fDISTFIT", ...)</code>
but are typically created by functions fitting distributions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>title</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>description</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>

<p>Slot <code>fit</code> is a list with components:
</p>

<dl>
<dt>estimate</dt><dd>
<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</dd>
<dt>minimum</dt><dd>
<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</dd>
<dt>code</dt><dd>
<p>an integer indicating why the optimization process terminated.
</p>
</dd>
<dt>gradient</dt><dd>
<p>the gradient at the estimated maximum.
</p>
</dd>
</dl>

<p>The above description of slot <code>fit</code> is taken from the
documentation for <code><a href="#topic+tFit">tFit</a></code>, <code><a href="#topic+nFit">nFit</a></code> and
<code><a href="#topic+stableFit">stableFit</a></code>. <strong>TODO:</strong> needs checking and also is it the same for
other distribution fitting functions.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fDISTFIT")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("fDISTFIT")
</code></pre>

<hr>
<h2 id='fHTEST-class'>Class <code>"fHTEST"</code></h2><span id='topic+fHTEST-class'></span><span id='topic+fHTEST'></span><span id='topic+show+2CfHTEST-method'></span>

<h3>Description</h3>

<p>An S4 class representing the outcome of a statistical test.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by some statistical test functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd>
<p>the function call.
</p>
</dd>
<dt><code>data</code>:</dt><dd>
<p>the data as specified by the input argument(s).
</p>
</dd>
<dt><code>test</code>:</dt><dd>
<p>a list whose elements contain the results from the statistical
test. The information provided is similar to a list object of
class <code>"htest"</code>.
</p>
</dd>
<dt><code>title</code>:</dt><dd>
<p>a character string with the name of the test. This can be
overwritten specifying a user defined input argument.
</p>
</dd>
<dt><code>description</code>:</dt><dd>
<p>a character string with an optional user defined description.  By
default just the current date when the test was applied will be
returned.
</p>
</dd>
</dl>

<p>Slot <code>@test</code> is an object of class <code>"list"</code> containing at
least the following elements:
</p>

<dl>
<dt>statistic</dt><dd>
<p>the value(s) of the test statistic.
</p>
</dd>
<dt>p.value</dt><dd>
<p>the p-value(s) of the test.
</p>
</dd>
<dt>parameters</dt><dd>
<p>a numeric value or vector of parameters.
</p>
</dd>
<dt>estimate</dt><dd>
<p>a numeric value or vector of sample estimates.
</p>
</dd>
<dt>conf.int</dt><dd>
<p>a numeric two row vector or matrix of 95% confidence levels.
</p>
</dd>
<dt>method</dt><dd>
<p>a character string indicating what type of test was performed.
</p>
</dd>
<dt>data.name</dt><dd>
<p>a character string giving the name(s) of the data.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fHTEST")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>for functions returning objects from class <code>"fHTEST"</code>, see
<code><a href="#topic+scaleTest">scaleTest</a></code>,
<code><a href="#topic+correlationTest">correlationTest</a></code>,
<code><a href="#topic+ks2Test">ks2Test</a></code>,
<code><a href="#topic+locationTest">locationTest</a></code>,
<code><a href="#topic+NormalityTests">NormalityTests</a></code>,
<code><a href="#topic+varianceTest">varianceTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("fHTEST")
</code></pre>

<hr>
<h2 id='getS4'>General S4 Class Extractor Functions</h2><span id='topic+getS4'></span><span id='topic+getCall'></span><span id='topic+getCall+2CANY-method'></span><span id='topic+getModel'></span><span id='topic+getModel.default'></span><span id='topic+getTitle'></span><span id='topic+getDescription'></span><span id='topic+getSlot'></span><span id='topic+getArgs'></span>

<h3>Description</h3>

<p>A collection and description of functions to extract
slots from S4 class objects.
<br />
</p>
<p>The extractor functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    
    <code>getModel</code> </td><td style="text-align: left;"> Extracts the model slot from a S4 object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getTitle</code> </td><td style="text-align: left;"> Extracts the title slot from a S4 object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getDescription</code> </td><td style="text-align: left;"> Extracts the description slot from a S4 object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getSlot</code> </td><td style="text-align: left;"> Extracts a specified slot from a S4 object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getArgs</code> </td><td style="text-align: left;"> Shows the arguments of a S4 function. </td>
</tr>

</table>

<p>Since <span class="rlang"><b>R</b></span> version 2.14.0, a generic <code>getCall()</code> is part of <span class="rlang"><b>R</b></span>;
for earlier versions, we had provided a simple version for S4 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModel(object)
getTitle(object)
getDescription(object)

getSlot(object, slotName)

getArgs(f, signature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getS4_+3A_f">f</code></td>
<td>
<p>a generic function or the character-string name of one.</p>
</td></tr>
<tr><td><code id="getS4_+3A_object">object</code></td>
<td>

<p>an object of class S4.

</p>
</td></tr>
<tr><td><code id="getS4_+3A_signature">signature</code></td>
<td>

<p>the signature of classes to match to the arguments of <code>f</code>
</p>
</td></tr>
<tr><td><code id="getS4_+3A_slotname">slotName</code></td>
<td>

<p>a character string, the name of the slot to be extracted from the
S4 object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for
<code>getModel</code>, <code>getTitle</code>, <code>getDescription</code>, and
<code>getSlot</code>
- the content of the corresponding slot.
</p>
<p>for <code>getArgs</code> the names of the arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example S4 Representation:
   # Hyothesis Testing with Control Settings
   setClass("hypTest",
     representation(
       call = "call",
       data = "numeric",
       test = "list",
       description = "character")
   )

## Shapiro Wilk Normaility Test
   swTest = function(x, description = "") {
     ans = shapiro.test(x)
     class(ans) = "list"
     new("hypTest",
       call = match.call(),
       data = x,
       test = ans,
       description = description)
   }
   test = swTest(x = rnorm(500), description = "500 RVs")

## Extractor Functions:
   isS4(test)
   getCall(test)
   getDescription(test)

## get arguments
args(returns)
getArgs(returns)
getArgs("returns")
getArgs(returns, "timeSeries")
getArgs("returns", "timeSeries")
</code></pre>

<hr>
<h2 id='gh'>Generalized Hyperbolic Distribution</h2><span id='topic+gh'></span><span id='topic+dgh'></span><span id='topic+pgh'></span><span id='topic+qgh'></span><span id='topic+rgh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the generalized hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgh(x, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2, log = FALSE)
pgh(q, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
qgh(p, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
rgh(n, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gh_+3A_x">x</code>, <code id="gh_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="gh_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="gh_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="gh_+3A_alpha">alpha</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="gh_+3A_beta">beta</code></td>
<td>

<p>second shape parameter, should in the range <code>(0, alpha).</code>
</p>
</td></tr>
<tr><td><code id="gh_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="gh_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="gh_+3A_lambda">lambda</code></td>
<td>

<p>defines the sublclass, by default <code class="reqn">-1/2</code>.
</p>
</td></tr>
<tr><td><code id="gh_+3A_log">log</code></td>
<td>

<p>a logical flag by default <code>FALSE</code>. 
Should labels and a main title drawn to the plot?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dgh</code> gives the density,
<code>pgh</code> gives the distribution function,
<code>qgh</code> gives the quantile function, and
<code>rgh</code> generates random deviates.
</p>
<p>The meanings of the parameters correspond to the first
parameterization, <code>pm=1</code>, which is the default parameterization
for this distribution.
</p>
<p>In the second parameterization, <code>pm=2</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>zeta</code> and <code>rho</code>.
</p>
<p>In the third parameterization, <code>pm=3</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>xi</code> and <code>chi</code>.
</p>
<p>In the fourth parameterization, <code>pm=4</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>a.bar</code> and <code>b.bar</code>.
</p>
<p>The generator <code>rgh</code> is based on the GH algorithm given
by Scott (2004).
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>David Scott for code implemented from <span class="rlang"><b>R</b></span>'s 
contributed package <code>HyperbolicDist</code>.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## rgh -
   set.seed(1953)
   r = rgh(5000, alpha = 1, beta = 0.3, delta = 1)
   plot(r, type = "l", col = "steelblue",
     main = "gh: alpha=1 beta=0.3 delta=1")
 
## dgh - 
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   x = seq(-5, 5, 0.25)
   lines(x, dgh(x, alpha = 1, beta = 0.3, delta = 1))
 
## pgh -  
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, pgh(x, alpha = 1, beta = 0.3, delta = 1))
   
## qgh -
   # Compute Quantiles:
   qgh(pgh(seq(-5, 5, 1), alpha = 1, beta = 0.3, delta = 1), 
     alpha = 1, beta = 0.3, delta = 1) 
</code></pre>

<hr>
<h2 id='ghFit'>GH Distribution Fit</h2><span id='topic+ghFit'></span>

<h3>Description</h3>

<p>Estimates the distrinbutional parameters for a 
generalized hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghFit(x, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2, 
    scale = TRUE, doplot = TRUE, span = "auto", trace = TRUE, 
    title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_alpha">alpha</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_beta">beta</code></td>
<td>

<p>second shape parameter, should in the range <code>(0, alpha).</code>
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_lambda">lambda</code></td>
<td>

<p>defines the sublclass, by default <code class="reqn">-1/2</code>.
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series
be scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>        
<tr><td><code id="ghFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values automatically
selected and ranging between the 0.001, and 0.999
quantiles. Alternatively, you can specify the range by an expression
like <code>span=seq(min, max, times = n)</code>, where, <code>min</code> and
<code>max</code> are the left and right endpoints of the range, and
<code>n</code> gives the number of the intermediate points.
</p>
</td></tr>        
<tr><td><code id="ghFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>     
<tr><td><code id="ghFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="ghFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meanings of the parameters correspond to the first
parameterization, see <code><a href="#topic+gh">gh</a></code> for further details.
</p>
<p>The function <code><a href="stats.html#topic+nlm">nlm</a></code> is used to minimize the &quot;negative&quot;
maximum log-likelihood function. <code>nlm</code> carries out a minimization
using a Newton-type algorithm.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## ghFit -
   # Simulate Random Variates:
   set.seed(1953)
   s = rgh(n = 1000, alpha = 1.5, beta = 0.3, delta = 0.5, mu = -1.0) 

## ghFit -  
   # Fit Parameters:
   ghFit(s, alpha = 1, beta = 0, delta = 1, mu = mean(s), doplot = TRUE) 
</code></pre>

<hr>
<h2 id='ghMode'>Generalized Hyperbolic Mode</h2><span id='topic+ghMode'></span>

<h3>Description</h3>

<p>Computes the mode of the generalized hyperbolic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghMode(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghMode_+3A_alpha">alpha</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="ghMode_+3A_beta">beta</code></td>
<td>

<p>second shape parameter, should in the range <code>(0, alpha).</code>
</p>
</td></tr>
<tr><td><code id="ghMode_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ghMode_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ghMode_+3A_lambda">lambda</code></td>
<td>

<p>defines the sublclass, by default <code class="reqn">-1/2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meanings of the parameters correspond to the first
parameterization, see <code><a href="#topic+gh">gh</a></code> for further details.
</p>


<h3>Value</h3>

<p>a numeric value, the mode of the generalized hyperbolic distribution
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ghMode -
   ghMode()
</code></pre>

<hr>
<h2 id='ghMoments'>Generalized Hyperbolic Distribution Moments</h2><span id='topic+ghMoments'></span><span id='topic+ghMean'></span><span id='topic+ghVar'></span><span id='topic+ghSkew'></span><span id='topic+ghKurt'></span><span id='topic+ghMoments'></span>

<h3>Description</h3>

<p>Calculates moments of the generalized hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghMean(alpha=1, beta=0, delta=1, mu=0, lambda=-1/2)
ghVar(alpha=1, beta=0, delta=1, mu=0, lambda=-1/2)
ghSkew(alpha=1, beta=0, delta=1, mu=0, lambda=-1/2)
ghKurt(alpha=1, beta=0, delta=1, mu=0, lambda=-1/2)

ghMoments(order, type = c("raw", "central", "mu"),
    alpha = 1, beta=0, delta=1, mu=0, lambda=-1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghMoments_+3A_alpha">alpha</code></td>
<td>

<p>numeric value, the first shape parameter.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_beta">beta</code></td>
<td>

<p>numeric value, the second shape parameter in the range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_delta">delta</code></td>
<td>

<p>numeric value, the scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_mu">mu</code></td>
<td>

<p>numeric value, the location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_lambda">lambda</code></td>
<td>

<p>numeric value, defines the sublclass, by default <code class="reqn">-1/2</code>.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_order">order</code></td>
<td>

<p>an integer value, the order of the moment.
</p>
</td></tr>
<tr><td><code id="ghMoments_+3A_type">type</code></td>
<td>

<p>a character value, 
<code>"raw"</code> gives the moments about zero,
<code>"central"</code> gives the central moments about the mean, and
<code>"mu"</code> gives the moments about the location parameter <code>mu</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one
of <code>mean</code>, <code>var</code>, <code>skew</code>, or <code>kurt</code>, obtained by
dropping the <code>nig</code> prefix from the name of the corresponding
function and lowercasing it.
</p>
<p>for <code>ghMoments</code>, the name is obtained by <code>paste0("m", order, type)</code>.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>References</h3>

<p>Scott, D. J., Wuertz, D. and Tran, T. T. (2008) 
<em>Moments of the Generalized Hyperbolic Distribution</em>. 
Preprint. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ghMean -
   ghMean(alpha=1.1, beta=0.1, delta=0.8, mu=-0.3, lambda=1)
   
## ghKurt -
   ghKurt(alpha=1.1, beta=0.1, delta=0.8, mu=-0.3, lambda=1)
   
## ghMoments -
   ghMoments(4, 
     alpha=1.1, beta=0.1, delta=0.8, mu=-0.3, lambda=1)
   ghMoments(4, "central",
     alpha=1.1, beta=0.1, delta=0.8, mu=-0.3, lambda=1)
</code></pre>

<hr>
<h2 id='ghRobMoments'>Robust Moments for the GH</h2><span id='topic+ghRobMoments'></span><span id='topic+ghMED'></span><span id='topic+ghIQR'></span><span id='topic+ghSKEW'></span><span id='topic+ghKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the generalized hyperbolic
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghMED(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
ghIQR(alpha= 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
ghSKEW(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
ghKURT(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghRobMoments_+3A_alpha">alpha</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="ghRobMoments_+3A_beta">beta</code></td>
<td>

<p>second shape parameter, should in the range <code>(0, alpha).</code>
</p>
</td></tr>
<tr><td><code id="ghRobMoments_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ghRobMoments_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ghRobMoments_+3A_lambda">lambda</code></td>
<td>

<p>defines the sublclass, by default <code class="reqn">-1/2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meanings of the parameters correspond to the first
parameterization, see <code><a href="#topic+gh">gh</a></code> for further details.
</p>


<h3>Value</h3>

<p>a named numerical value.  The name is
one of <code>MED</code>, <code>IQR</code>, <code>SKEW</code>, or <code>KURT</code>, obtained
by dropping the <code>gh</code> prefix from the name of the corresponding
function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ghMED -
   # Median:
   ghMED(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)

## ghIQR -
   # Inter-quartile Range:
   ghIQR(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)

## ghSKEW -
   # Robust Skewness:
   ghSKEW(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)

## ghKURT -
   # Robust Kurtosis:
   ghKURT(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)

</code></pre>

<hr>
<h2 id='ghSlider'>Generalized Hyperbolic Distribution Slider</h2><span id='topic+ghSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the 
generalized hyperbolic distribution on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghSlider()
</code></pre>


<h3>Value</h3>

<p>a tcl/tk based graphical user interface.
</p>
<p>This is a nice display for educational purposes to investigate
the densities and probabilities of the generalized hyperbolic 
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ghSlider -
   # ghSlider()
</code></pre>

<hr>
<h2 id='ght'>Generalized Hyperbolic Student-t distribution</h2><span id='topic+dght'></span><span id='topic+pght'></span><span id='topic+qght'></span><span id='topic+rght'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the generalized hyperbolic Student-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dght(x, beta = 0.1, delta = 1, mu = 0, nu = 10, log = FALSE)
pght(q, beta = 0.1, delta = 1, mu = 0, nu = 10)
qght(p, beta = 0.1, delta = 1, mu = 0, nu = 10)
rght(n, beta = 0.1, delta = 1, mu = 0, nu = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ght_+3A_x">x</code>, <code id="ght_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="ght_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="ght_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
<tr><td><code id="ght_+3A_beta">beta</code></td>
<td>

<p>numeric value, the skewness parameter in the range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="ght_+3A_delta">delta</code></td>
<td>

<p>numeric value, the scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ght_+3A_mu">mu</code></td>
<td>

<p>numeric value, the location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ght_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.  Note,
<code>alpha</code> takes the limit of <code>abs(beta)</code>, and <code>lambda=-nu/2</code>.
</p>
</td></tr>
<tr><td><code id="ght_+3A_log">log</code></td>
<td>

<p>a logical, if TRUE, probabilities <code>p</code> are given as <code>log(p)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dght</code> gives the density,
<code>pght</code> gives the distribution function,
<code>qght</code> gives the quantile function, and
<code>rght</code> generates random deviates.
</p>
<p>The parameters are as in the first parameterization.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ght -
   #
</code></pre>

<hr>
<h2 id='ghtFit'>GHT distribution fit</h2><span id='topic+ghtFit'></span>

<h3>Description</h3>

<p>Estimates the distributional parameters for a 
generalized hyperbolic Student-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
ghtFit(x, beta = 0.1, delta = 1, mu = 0, nu = 10, 
    scale = TRUE, doplot = TRUE, span = "auto", trace = TRUE, 
    title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghtFit_+3A_beta">beta</code>, <code id="ghtFit_+3A_delta">delta</code>, <code id="ghtFit_+3A_mu">mu</code></td>
<td>

<p>numeric values.
<code>beta</code> is the skewness parameter in the range <code>(0, alpha)</code>;
<code>delta</code> is the scale parameter, must be zero or positive; 
<code>mu</code> is the location parameter, by default 0.
These are the parameters in the first parameterization.
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_nu">nu</code></td>
<td>

<p>defines the number of degrees of freedom. 
Note, <code>alpha</code> takes the limit of <code>abs(beta)</code>, 
and <code>lambda=-nu/2</code>.
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series
be scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>        
<tr><td><code id="ghtFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
        times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and right endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>        
<tr><td><code id="ghtFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>     
<tr><td><code id="ghtFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="ghtFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="stats.html#topic+nlm">nlm</a></code> is used to minimize the &quot;negative&quot;
maximum log-likelihood function. <code>nlm</code> carries out a minimization
using a Newton-type algorithm.
</p>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
</p>
<p>Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## ghtFit -
   # Simulate Random Variates:
   set.seed(1953)
   
## ghtFit -  
   # Fit Parameters:
</code></pre>

<hr>
<h2 id='ghtMode'>Generalized Hyperbolic Student-t Mode</h2><span id='topic+ghtMode'></span>

<h3>Description</h3>

<p>Computes the mode of the generalized hyperbolic Student-t
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghtMode(beta = 0.1, delta = 1, mu = 0, nu = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghtMode_+3A_beta">beta</code></td>
<td>
<p>the skewness parameter in the range <code>(0, alpha).</code></p>
</td></tr>
<tr><td><code id="ghtMode_+3A_delta">delta</code></td>
<td>
<p>the scale parameter, must be zero or positive.</p>
</td></tr>
<tr><td><code id="ghtMode_+3A_mu">mu</code></td>
<td>
<p>the location parameter, by default 0.</p>
</td></tr>
<tr><td><code id="ghtMode_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.
Note, <code>alpha</code> takes the limit of <code>abs(beta)</code>, 
and <code>lambda=-nu/2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the parameters in the first parameterization.
</p>


<h3>Value</h3>

<p>a numeric value, the mode for the generalized hyperbolic Student-t
distribution.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ghtMode -
   ghtMode()
</code></pre>

<hr>
<h2 id='ghtMoments'>Generalized Hyperbolic Student-t Moments</h2><span id='topic+ghtMoments'></span><span id='topic+ghtMean'></span><span id='topic+ghtVar'></span><span id='topic+ghtSkew'></span><span id='topic+ghtKurt'></span><span id='topic+ghtMoments'></span>

<h3>Description</h3>

<p>Calculates moments of the generalized hyperbolic Student-t
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghtMean(beta=0.1, delta=1, mu=0, nu=10)
ghtVar(beta=0.1, delta=1, mu=0, nu=10)
ghtSkew(beta=0.1, delta=1, mu=0, nu=10)
ghtKurt(beta=0.1, delta=1, mu=0, nu=10)

ghtMoments(order, type = c("raw", "central", "mu"),
    beta=0.1, delta=1, mu=0, nu=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghtMoments_+3A_beta">beta</code></td>
<td>

<p>numeric value, the skewness parameter in the range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="ghtMoments_+3A_delta">delta</code></td>
<td>

<p>numeric value, the scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="ghtMoments_+3A_mu">mu</code></td>
<td>

<p>numeric value, the location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="ghtMoments_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.
Note, <code>alpha</code> takes the limit of <code>abs(beta)</code>, 
and <code>lambda=-nu/2</code>.
</p>
</td></tr>
<tr><td><code id="ghtMoments_+3A_order">order</code></td>
<td>

<p>an integer value, the order of the moment.
</p>
</td></tr>
<tr><td><code id="ghtMoments_+3A_type">type</code></td>
<td>

<p>a character string, 
<code>"raw"</code> returns the moments about zero,
<code>"central"</code> returns the central moments about the mean, and
<code>"mu"</code> returns the moments about the location parameter <code>mu</code>.
</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one
of <code>mean</code>, <code>var</code>, <code>skew</code>, or <code>kurt</code>, obtained by
dropping the <code>nig</code> prefix from the name of the corresponding
function and lowercasing it.
</p>
<p>for <code>ghtMoments</code>, the name is obtained by <code>paste0("m", order, type)</code>.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>References</h3>

<p>Scott, D.J., Wuertz, D. and Tran, T.T. (2008) 
<em>Moments of the Generalized Hyperbolic Distribution</em>. 
Preprint. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ghtMean -
   ghtMean(beta=0.2, delta=1.2, mu=-0.5, nu=4)
   
## ghtKurt -
   ghtKurt(beta=0.2, delta=1.2, mu=-0.5, nu=4)
   
## ghtMoments -
   ghtMoments(4, 
     beta=0.2, delta=1.2, mu=-0.5, nu=4)
   ghtMoments(4, "central",
     beta=0.2, delta=1.2, mu=-0.5, nu=4)
</code></pre>

<hr>
<h2 id='ghtRobMoments'>Robust Moments for the GHT</h2><span id='topic+ghtRobMoments'></span><span id='topic+ghtMED'></span><span id='topic+ghtIQR'></span><span id='topic+ghtSKEW'></span><span id='topic+ghtKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the
generalized hyperbolic Student-t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghtMED(beta = 0.1, delta = 1, mu = 0, nu = 10)
ghtIQR(beta = 0.1, delta = 1, mu = 0, nu = 10)
ghtSKEW(beta = 0.1, delta = 1, mu = 0, nu = 10)
ghtKURT(beta = 0.1, delta = 1, mu = 0, nu = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghtRobMoments_+3A_beta">beta</code></td>
<td>
<p>skewness parameter in the range <code>(0, alpha)</code>.</p>
</td></tr>
<tr><td><code id="ghtRobMoments_+3A_delta">delta</code></td>
<td>
<p>scale parameter, must be zero or positive.</p>
</td></tr>
<tr><td><code id="ghtRobMoments_+3A_mu">mu</code></td>
<td>
<p>location parameter, by default 0.</p>
</td></tr>
<tr><td><code id="ghtRobMoments_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.
Note, <code>alpha</code> takes the limit of <code>abs(beta)</code>,
and <code>lambda=-nu/2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters are those of the first parameterization.
</p>


<h3>Value</h3>

<p>a named numerical value.  The name is
one of <code>MED</code>, <code>IQR</code>, <code>SKEW</code>, or <code>KURT</code>, obtained
by dropping the <code>ght</code> prefix from the name of the corresponding
function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ghtMED -
   # Median:
   ghtMED(beta = 0.1, delta = 1, mu = 0, nu = 10)

## ghtIQR -
   # Inter-quartile Range:
   ghtIQR(beta = 0.1, delta = 1, mu = 0, nu = 10)

## ghtSKEW -
   # Robust Skewness:
   ghtSKEW(beta = 0.1, delta = 1, mu = 0, nu = 10)

## ghtKURT -
   # Robust Kurtosis:
   ghtKURT(beta = 0.1, delta = 1, mu = 0, nu = 10)

</code></pre>

<hr>
<h2 id='gld'>Generalized Lambda Distribution</h2><span id='topic+gld'></span><span id='topic+dgld'></span><span id='topic+pgld'></span><span id='topic+qgld'></span><span id='topic+rgld'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the generalized lambda distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgld(x, lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8, log = FALSE)
pgld(q, lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
qgld(p, lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
rgld(n, lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gld_+3A_lambda1">lambda1</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="gld_+3A_lambda2">lambda2</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="gld_+3A_lambda3">lambda3</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="gld_+3A_lambda4">lambda4</code></td>
<td>

<p>second shape parameter.
</p>
</td></tr>
<tr><td><code id="gld_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="gld_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="gld_+3A_x">x</code>, <code id="gld_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="gld_+3A_log">log</code></td>
<td>

<p>a logical, if TRUE, probabilities <code>p</code> are given as
<code>log(p)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dgld</code> gives the density,
<code>pgld</code> gives the distribution function,
<code>qgld</code> gives the quantile function, and
<code>rgld</code> generates random deviates.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Chong Gu for code implemented from <span class="rlang"><b>R</b></span>'s contributed package <code>gld</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## rgld -
   set.seed(1953)
   r = rgld(500, 
     lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8)
   plot(r, type = "l", col = "steelblue",
     main = "gld: lambda1=0 lambda2=-1 lambda3/4=-1/8")
 
## dgld - 
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", 
     col = "steelblue")
   x = seq(-5, 5, 0.25)
   lines(x, dgld(x, 
     lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8))
 
## pgld -  
   # Plot df and compare with true df:
   plot(sort(r), ((1:500)-0.5)/500, main = "Probability", 
     col = "steelblue")
   lines(x, pgld(x, 
     lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8))
   
## qgld -
   # Compute Quantiles:
   qgld(pgld(seq(-5, 5, 1), 
     lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8), 
     lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8) 
</code></pre>

<hr>
<h2 id='gldFit'>GH Distribution Fit</h2><span id='topic+gldFit'></span>

<h3>Description</h3>

<p>Estimates the distrinbutional parameters for a 
generalized lambda distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldFit(x, lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8, 
    method = c("mle", "mps", "gof", "hist", "rob"),
    scale = NA, doplot = TRUE, add = FALSE, span = "auto", trace = TRUE, 
    title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="gldFit_+3A_lambda1">lambda1</code>, <code id="gldFit_+3A_lambda2">lambda2</code>, <code id="gldFit_+3A_lambda3">lambda3</code>, <code id="gldFit_+3A_lambda4">lambda4</code></td>
<td>

<p>are numeric values where
<code>lambda1</code> is the location parameter,
<code>lambda2</code> is the location parameter,
<code>lambda3</code> is the first shape parameter, and
<code>lambda4</code> is the second shape parameter.
</p>
</td></tr>
<tr><td><code id="gldFit_+3A_method">method</code></td>
<td>

<p>a character string, the estimation approach to
fit the distributional parameters, see details.
</p>
</td></tr>
<tr><td><code id="gldFit_+3A_scale">scale</code></td>
<td>

<p>not used.



</p>
</td></tr>
<tr><td><code id="gldFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>    
<tr><td><code id="gldFit_+3A_add">add</code></td>
<td>

<p>a logical flag. Should a new fit added to an existing plot?
</p>
</td></tr>     
<tr><td><code id="gldFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
    times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and rigldt endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>        
<tr><td><code id="gldFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="gldFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>     
<tr><td><code id="gldFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="gldFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="stats.html#topic+nlminb">nlminb</a></code> is used to minimize the objective 
function. The following approaches have been implemented:
</p>
<p><code>"mle"</code>, maximimum log likelihoo estimation.
</p>
<p><code>"mps"</code>, maximum product spacing estimation.
</p>
<p><code>"gof"</code>, goodness of fit approaches, 
<code>type="ad"</code> Anderson-Darling, 
<code>type="cvm"</code> Cramer-vonMise,
<code>type="ks"</code> Kolmogorov-Smirnov.
</p>
<p><code>"hist"</code>, histogram binning approaches,   
<code>"fd"</code> Freedman-Diaconis binning,
<code>"scott"</code>, Scott histogram binning,
<code>"sturges"</code>, Sturges histogram binning.
</p>
<p><code>"rob"</code>, robust moment matching.
</p>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
</p>
<p>Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## gldFit -
   # Simulate Random Variates:
   set.seed(1953)
   s = rgld(n = 1000, lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8) 

## gldFit -  
   # Fit Parameters:
   gldFit(s, lambda1=0, lambda2=-1, lambda3=-1/8, lambda4=-1/8, 
     doplot = TRUE, trace = TRUE) 
</code></pre>

<hr>
<h2 id='gldMode'>Generalized Lambda Distribution Mode</h2><span id='topic+gldMode'></span>

<h3>Description</h3>

<p>Computes the mode of the generalized lambda distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldMode(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldMode_+3A_lambda1">lambda1</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="gldMode_+3A_lambda2">lambda2</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="gldMode_+3A_lambda3">lambda3</code></td>
<td>

<p>first shape parameter.
</p>
</td></tr>
<tr><td><code id="gldMode_+3A_lambda4">lambda4</code></td>
<td>

<p>second shape parameter.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Implemented by Diethelm Wuertz
</p>

<hr>
<h2 id='gldRobMoments'>Robust Moments for the GLD</h2><span id='topic+gldRobMoments'></span><span id='topic+gldMED'></span><span id='topic+gldIQR'></span><span id='topic+gldSKEW'></span><span id='topic+gldKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the
Generalized Lambda Distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldMED(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
gldIQR(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
gldSKEW(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
gldKURT(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldRobMoments_+3A_lambda1">lambda1</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="gldRobMoments_+3A_lambda2">lambda2</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="gldRobMoments_+3A_lambda3">lambda3</code></td>
<td>
<p>first shape parameter</p>
</td></tr>
<tr><td><code id="gldRobMoments_+3A_lambda4">lambda4</code></td>
<td>
<p>second shape parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is
one of <code>MED</code>, <code>IQR</code>, <code>SKEW</code>, or <code>KURT</code>, obtained
by dropping the <code>gld</code> prefix from the name of the corresponding
function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## gldMED -
   # Median:
   gldMED(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
 
## gldIQR - 
   # Inter-quartile Range:
   gldIQR(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
 
## gldSKEW -  
   # Robust Skewness:
   gldSKEW(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
   
## gldKURT -
   # Robust Kurtosis:
   gldKURT(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)
</code></pre>

<hr>
<h2 id='gridVector'>Grid vector coordinates</h2><span id='topic+gridVector'></span>

<h3>Description</h3>

<p>Creates rectangular grid coordinates from two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridVector(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridVector_+3A_x">x</code>, <code id="gridVector_+3A_y">y</code></td>
<td>

<p>numeric vectors
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grid is obtained by pairing each element of <code>y</code> with all
elements of <code>x</code>. The <code>X</code> and <code>Y</code> coordinates of the
points are stored in separate vectors. This is convenient, for
example, for plotting. It can be useful also for brute force
optimisation or simulation.
</p>
<p>If <code>y</code> is <code>NULL</code>, the default, then <code>y = x</code>.
</p>


<h3>Value</h3>

<p>a list with two components, <code>X</code> and <code>Y</code>, giving the
coordinates which span the bivariate grid.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a small grid vector with row and col transformations
gridVector(0:2)
data.frame(gridVector(0:2))
do.call("rbind", gridVector(0:2))

gridVector(0:2, 0:3)

## grid over a unit square
gridVector((0:10)/10) # equivalently: gridVector((0:10)/10, (0:10)/10)
</code></pre>

<hr>
<h2 id='Heaviside'>Heaviside and related functions</h2><span id='topic+Heaviside'></span><span id='topic+Sign'></span><span id='topic+Delta'></span><span id='topic+Boxcar'></span><span id='topic+Ramp'></span>

<h3>Description</h3>

<p>Functions which compute the Heaviside and related functions. These
include the Heaviside function, the sign function, the delta
function, the boxcar function, and the ramp function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heaviside(x, a = 0)
Sign(x, a = 0)
Delta(x, a = 0)
Boxcar(x, a = 0.5)
Ramp(x, a = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Heaviside_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr>
<tr><td><code id="Heaviside_+3A_a">a</code></td>
<td>

<p>a numeric value, the location of the break.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Heaviside</code>  computes the Heaviside unit step function. 
<code>Heaviside</code> is 1 for <code>x &gt; a</code>, 
<code>1/2</code> for <code>x = a</code>, and <code>0</code> for <code>x &lt; a</code>.
</p>
<p><code>Sign</code> computes
the sign function. <code>Sign</code> is <code>1</code> for <code>x &gt; a</code>, 
<code>0</code> for <code>x = a</code>, and <code>-1</code> for <code>x &lt; a</code>.
</p>
<p><code>Delta</code> computes the delta function.
<code>Delta</code> is defined as: <code>Delta(x) = d/dx H(x-a)</code>.
</p>
<p><code>Boxcar</code> computes the boxcar function.
<code>Boxcar</code> is defined as: <code>Boxcar(x) = H(x+a) - H(x-a)</code>.
</p>
<p><code>Ramp</code> computes ramp function. 
The ramp function is defined as: <code>Ramp(x) = (x-a) * H(x-a)</code>.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Note</h3>

<p>The Heaviside function is used in the implementation of the skew
Normal, Student-t, and Generalized Error distributions, distributions
functions which play an important role in modelling GARCH processes.
</p>


<h3>References</h3>

<p>Weisstein W. (2004);
<em>http://mathworld.wolfram.com/HeavisideStepFunction.html</em>,
Mathworld.
</p>


<h3>See Also</h3>

<p><code>GarchDistribution</code>,
<code>GarchDistributionFits</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Heaviside -
   x = sort(round(c(-1, -0.5, 0, 0.5, 1, 5*rnorm(5)), 2))
   h = Heaviside(x)
    
## Sign -
   s = Sign(x)
   
## Delta -
   d = Delta(x)
   
## Boxcar -
   Pi = Boxcar(x)

## Ramp - 
   r = Ramp(x)
   cbind(x = x, Step = h, Signum = s, Delta = d, Pi = Pi, R = r)        
</code></pre>

<hr>
<h2 id='hilbert'>Hilbert matrix</h2><span id='topic+hilbert'></span>

<h3>Description</h3>

<p>Creates a Hilbert matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_n">n</code></td>
<td>

<p>an integer value, the dimension of the square matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code class="reqn">n,n</code> matrix with <code class="reqn">(i,j)</code>th element equal to
<code class="reqn">1/(i+j-1)</code> is said to be a Hilbert matrix of order <code class="reqn">n</code>.
Hilbert matrices are symmetric and positive definite.
</p>
<p>They are canonical examples of ill-conditioned matrices, making them
notoriously difficult to use in numerical computation. For example,
the 2-norm condition number of a 5x5 Hilbert matrix above is about
4.8e5.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>References</h3>

<p>Hilbert D., 
<em>Collected papers</em>, vol. II, article 21.
</p>
<p>Beckermann B, (2000);
<em>The condition number of real Vandermonde, Krylov and positive 
definite Hankel matrices</em>, 
Numerische Mathematik 85, 553&ndash;577, 2000.
</p>
<p>Choi, M.D., (1983);
<em>Tricks or Treats with the Hilbert Matrix</em>,
American Mathematical Monthly 90, 301&ndash;312, 1983.
</p>
<p>Todd, J., (1954);
<em>The Condition Number of the Finite Segment of the Hilbert Matrix</em>,
National Bureau of Standards, Applied Mathematics Series 39, 109&ndash;116. 
</p>
<p>Wilf, H.S., (1970);
<em>Finite Sections of Some Classical Inequalities</em>, 
Heidelberg, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a Hilbert Matrix:
   H = hilbert(5)
   H                              
</code></pre>

<hr>
<h2 id='HistogramPlot'>Histogram and density plots</h2><span id='topic+HistogramPlot'></span><span id='topic+histPlot'></span><span id='topic+densityPlot'></span><span id='topic+logDensityPlot'></span>

<h3>Description</h3>

<p>Produce tailored histogram plots and kernel density/log-density
estimate plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>        
histPlot(x, labels = TRUE, col = "steelblue", fit = TRUE, 
    title = TRUE, grid = TRUE, rug = TRUE, skip = FALSE, ...) 
densityPlot(x, labels = TRUE, col = "steelblue", fit = TRUE, hist = TRUE, 
    title = TRUE, grid = TRUE, rug = TRUE, skip = FALSE, ...)    
logDensityPlot(x, labels = TRUE, col = "steelblue", robust = TRUE,  
    title = TRUE, grid = TRUE, rug = TRUE, skip = FALSE, ...)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HistogramPlot_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code>.
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_labels">labels</code></td>
<td>

<p>a logical flag, should the plot be returned with default labels
and decorated in an automated way? By default <code>TRUE</code>.
</p>
</td></tr>   
<tr><td><code id="HistogramPlot_+3A_col">col</code></td>
<td>

<p>the color for the series. In the univariate case use just a color
name like the default, <code>col="steelblue"</code>, in the multivariate
case we recommend to select the colors from a color palette,
e.g. <code>col=heat.colors(ncol(x))</code>.
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_fit">fit</code></td>
<td>

<p>a logical flag, should a fit be added to the plot?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_hist">hist</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a histogram be laid
under the plot?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_title">title</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a default title be
added to the plot?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_grid">grid</code></td>
<td>

<p>a logical flag, should a grid be added to the plot?  By default
<code>TRUE</code>. To plot a horizontal lines only use <code>grid="h"</code> and
for vertical lines use <code>grid="h"</code>, respectively.
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_rug">rug</code></td>
<td>

<p>a logical flag, by default TRUE. Should a rug representation of the
data be added to the plot?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_skip">skip</code></td>
<td>

<p>a logical flag, should zeros be skipped in the return Series?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_robust">robust</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a robust fit be added
to the plot?
</p>
</td></tr>
<tr><td><code id="HistogramPlot_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed on.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>histPlot</code> produces a tailored histogram plot.
</p>
<p><code>densityPlot</code> produces a tailored kernel density estimate plot.
</p>
<p><code>logDensityPlot</code> produces a tailored log kernel density estimate plot.
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly. The functions are used for the side effect of
producing a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data - 
   data(LPP2005REC, package = "timeSeries")
   SPI &lt;- LPP2005REC[, "SPI"]
   plot(SPI, type = "l", col = "steelblue", main = "SP500")
   abline(h = 0, col = "grey")
   
## histPlot -
   histPlot(SPI) 
   
## densityPlot -
   densityPlot(SPI) 
</code></pre>

<hr>
<h2 id='hyp'>Hyperbolic distribution</h2><span id='topic+hyp'></span><span id='topic+dhyp'></span><span id='topic+phyp'></span><span id='topic+qhyp'></span><span id='topic+rhyp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function 
and random generation for the hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhyp(x, alpha = 1, beta = 0, delta = 1, mu = 0, pm = 1, log = FALSE)
phyp(q, alpha = 1, beta = 0, delta = 1, mu = 0, pm = 1, ...)
qhyp(p, alpha = 1, beta = 0, delta = 1, mu = 0, pm = 1, ...)
rhyp(n, alpha = 1, beta = 0, delta = 1, mu = 0, pm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyp_+3A_x">x</code>, <code id="hyp_+3A_q">q</code></td>
<td>

<p>numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_p">p</code></td>
<td>

<p>numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="hyp_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter, a positive number. <code>alpha</code> can also be a
vector of length four, containing <code>alpha</code>, <code>beta</code>,
<code>delta</code> and <code>mu</code> (in that order).
</p>
</td></tr>
<tr><td><code id="hyp_+3A_beta">beta</code></td>
<td>

<p>skewness parameter, <code>abs(beta)</code> is in the 
range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_pm">pm</code></td>
<td>

<p>integer number specifying the parameterisation, one of
<code>1</code>, <code>2</code>, <code>3</code>, or <code>4</code>. The default is the
first parameterization.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_log">log</code></td>
<td>

<p>a logical value, if <code>TRUE</code>, probabilities <code>p</code> are given as
<code>log(p)</code>.
</p>
</td></tr>
<tr><td><code id="hyp_+3A_...">...</code></td>
<td>

<p>arguments to be passed to the function <code>integrate</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dhyp</code> gives the density,
<code>phyp</code> gives the distribution function,
<code>qhyp</code> gives the quantile function, and
<code>rhyp</code> generates random deviates.
</p>
<p>The meaning of the parameters given above corresponds to the first
parameterization, <code>pm = 1</code>, which is the default.
</p>
<p>In the second parameterization, <code>pm=2</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>zeta</code> and <code>rho</code>.
</p>
<p>In the third parameterization, <code>pm=3</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>xi</code> and <code>chi</code>.
</p>
<p>In the fourth parameterization, <code>pm=4</code>, <code>alpha</code> and
<code>beta</code> take the meaning of the shape parameters (usually named)
<code>a.bar</code> and <code>b.bar</code>.
</p>
<p>The generator <code>rhyp</code> is based on the HYP algorithm given by
Atkinson (1982).
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>David Scott for code implemented from <span class="rlang"><b>R</b></span>'s contributed package
<span class="pkg">HyperbolicDist</span>.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## hyp -
   set.seed(1953)
   r = rhyp(5000, alpha = 1, beta = 0.3, delta = 1)
   plot(r, type = "l", col = "steelblue",
     main = "hyp: alpha=1 beta=0.3 delta=1")
 
## hyp - 
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   x = seq(-5, 5, 0.25)
   lines(x, dhyp(x, alpha = 1, beta = 0.3, delta = 1))
 
## hyp -  
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, phyp(x, alpha = 1, beta = 0.3, delta = 1))
   
## hyp -
   # Compute Quantiles:
   qhyp(phyp(seq(-5, 5, 1), alpha = 1, beta = 0.3, delta = 1), 
     alpha = 1, beta = 0.3, delta = 1) 
</code></pre>

<hr>
<h2 id='hypFit'>Fit a Hyperbolic distribution</h2><span id='topic+hypFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
hypFit(x, alpha = 1, beta = 0, delta = 1, mu = 0, 
    scale = TRUE, doplot = TRUE, span = "auto", trace = TRUE, 
    title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter, a positive number.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_beta">beta</code></td>
<td>

<p>skewness parameter, <code>abs(beta)</code> is in the 
range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series be
scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values automatically
selected and ranging between the 0.001, and 0.999
quantiles. Alternatively, you can specify the range by an expression
like <code>span=seq(min, max, times = n)</code>, where, <code>min</code> and
<code>max</code> are the left and right endpoints of the range, and
<code>n</code> gives the number of the intermediate points.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="hypFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meaning of the parameters given above corresponds to the first
parameterization, see <code><a href="#topic+dhyp">dhyp</a></code> for details.
</p>
<p>The function <code><a href="stats.html#topic+nlm">nlm</a></code> is used to minimize the &quot;negative&quot; 
maximum log-likelihood function. <code>nlm</code> carries out a minimization 
using a Newton-type algorithm.
</p>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood function
is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the log
liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## rhyp -
   # Simulate Random Variates:
   set.seed(1953)
   s = rhyp(n = 1000, alpha = 1.5, beta = 0.3, delta = 0.5, mu = -1.0) 

## hypFit -  
   # Fit Parameters:
   hypFit(s, alpha = 1, beta = 0, delta = 1, mu = mean(s), doplot = TRUE) 
</code></pre>

<hr>
<h2 id='hypMode'>Hyperbolic mode</h2><span id='topic+hypMode'></span>

<h3>Description</h3>

<p>Computes the mode of the hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypMode(alpha = 1, beta = 0, delta = 1, mu = 0, pm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypMode_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter, a positive number. <code>alpha</code> can also be a
vector of length four, containing <code>alpha</code>, <code>beta</code>,
<code>delta</code> and <code>mu</code> (in that order).
</p>
</td></tr>
<tr><td><code id="hypMode_+3A_beta">beta</code></td>
<td>

<p>skewness parameter, <code>abs(beta)</code> is in the 
range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="hypMode_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="hypMode_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="hypMode_+3A_pm">pm</code></td>
<td>

<p>an integer value between <code>1</code> and <code>4</code> for the selection of
the parameterization. The default takes the first parameterization.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value, the mode in the appropriate parameterization for the
hyperbolic distribution.
</p>


<h3>Author(s)</h3>

<p>David Scott for code implemented from <span class="rlang"><b>R</b></span>'s contributed package
<code>HyperbolicDist</code>.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## hypMode -
   hypMode()
</code></pre>

<hr>
<h2 id='hypMoments'>Hyperbolic distribution moments</h2><span id='topic+hypMoments'></span><span id='topic+hypMean'></span><span id='topic+hypVar'></span><span id='topic+hypSkew'></span><span id='topic+hypKurt'></span><span id='topic+hypMoments'></span>

<h3>Description</h3>

<p>Calculates moments of the hyperbolic distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypMean(alpha=1, beta=0, delta=1, mu=0)
hypVar(alpha=1, beta=0, delta=1, mu=0)
hypSkew(alpha=1, beta=0, delta=1, mu=0)
hypKurt(alpha=1, beta=0, delta=1, mu=0)

hypMoments(order, type = c("raw", "central", "mu"),
    alpha=1, beta=0, delta=1, mu=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypMoments_+3A_alpha">alpha</code></td>
<td>

<p>numeric value, the first shape parameter.
</p>
</td></tr>
<tr><td><code id="hypMoments_+3A_beta">beta</code></td>
<td>

<p>numeric value, the second shape parameter in the range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="hypMoments_+3A_delta">delta</code></td>
<td>

<p>numeric value, the scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="hypMoments_+3A_mu">mu</code></td>
<td>

<p>numeric value, the location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="hypMoments_+3A_order">order</code></td>
<td>

<p>an integer value, the order of the moment.
</p>
</td></tr>
<tr><td><code id="hypMoments_+3A_type">type</code></td>
<td>

<p>a character string, 
<code>"raw"</code> returns the moments about zero,
<code>"central"</code> returns the central moments about the mean, and
<code>"mu"</code> returns the moments about the location parameter <code>mu</code>.
</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one
of <code>mean</code>, <code>var</code>, <code>skew</code>, or <code>kurt</code>, obtained by
dropping the <code>hyp</code> prefix from the name of the corresponding
function and lowercasing it.
</p>
<p>for <code>hypMoments</code>, the name is obtained by <code>paste0("m", order, type)</code>.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>References</h3>

<p>Scott, D. J., Wuertz, D. and Tran, T. T. (2008) 
<em>Moments of the Generalized Hyperbolic Distribution</em>. 
Preprint. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## hypMean -
   hypMean(alpha=1.1, beta=0.1, delta=0.8, mu=-0.3)
   
## ghKurt -
   hypKurt(alpha=1.1, beta=0.1, delta=0.8, mu=-0.3)
   
## hypMoments -
   hypMoments(4, alpha=1.1, beta=0.1, delta=0.8, mu=-0.3)
   hypMoments(4, "central", alpha=1.1, beta=0.1, delta=0.8, mu=-0.3)
</code></pre>

<hr>
<h2 id='hypRobMoments'>Robust moments for the HYP</h2><span id='topic+hypRobMoments'></span><span id='topic+hypMED'></span><span id='topic+hypIQR'></span><span id='topic+hypSKEW'></span><span id='topic+hypKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the hyperbolic
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypMED(alpha = 1, beta = 0, delta = 1, mu = 0)
hypIQR(alpha = 1, beta = 0, delta = 1, mu = 0)
hypSKEW(alpha = 1, beta = 0, delta = 1, mu = 0)
hypKURT(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypRobMoments_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter, a positive number. <code>alpha</code> can also be a
vector of length four, containing <code>alpha</code>, <code>beta</code>,
<code>delta</code> and <code>mu</code> (in that order).
</p>
</td></tr>
<tr><td><code id="hypRobMoments_+3A_beta">beta</code></td>
<td>

<p>skewness parameter, <code>abs(beta)</code> is in the 
range <code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="hypRobMoments_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="hypRobMoments_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is
one of <code>MED</code>, <code>IQR</code>, <code>SKEW</code>, or <code>KURT</code>, obtained
by dropping the <code>hyp</code> prefix from the name of the corresponding
function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## hypMED -
   # Median:
   hypMED(alpha = 1, beta = 0, delta = 1, mu = 0)

## hypIQR -
   # Inter-quartile Range:
   hypIQR(alpha = 1, beta = 0, delta = 1, mu = 0)

## hypSKEW -
   # Robust Skewness:
   hypSKEW(alpha = 1, beta = 0, delta = 1, mu = 0)

## hypKURT -
   # Robust Kurtosis:
   hypKURT(alpha = 1, beta = 0, delta = 1, mu = 0)

</code></pre>

<hr>
<h2 id='hypSlider'>Hyperbolic distribution slider</h2><span id='topic+hypSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the 
hyperbolic distribution on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypSlider()
</code></pre>


<h3>Value</h3>

<p>a tcl/tk based graphical user interface.
</p>
<p>This is a nice display for educational purposes to investigate
the densities and probabilities of the hyperbolic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## hypSlider -
   #
</code></pre>

<hr>
<h2 id='Ids'>Set and retrieve column/row names</h2><span id='topic+Ids'></span><span id='topic+colIds'></span><span id='topic+rowIds'></span><span id='topic+colIds+3C-'></span><span id='topic+rowIds+3C-'></span>

<h3>Description</h3>

<p>Sets and retrieves column and row names. The functions
are for compatibility with SPlus. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colIds(x, ...)
rowIds(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ids_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
<tr><td><code id="Ids_+3A_...">...</code></td>
<td>

<p>passed on to <code>colnames</code> or <code>rownames</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually in R the functions <code>colnames</code> and <code>rownames</code> are 
used to retrieve and set the names of matrices. The functions 
<code>rowIds</code> and <code>colIds</code>, are S-Plus like synonyms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pascal -
   # Create Pascal Matrix:
   P = pascal(3)
   P
 
## rownames -  
   rownames(P) &lt;- letters[1:3]
   P   
   
## colIds&lt;- -  
   colIds(P) &lt;- as.character(1:3)
   P                            
</code></pre>

<hr>
<h2 id='interactivePlot'>Interactive Plot Utility</h2><span id='topic+interactivePlot'></span>

<h3>Description</h3>

<p>Plots with emphasis on interactive plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactivePlot(x, choices = paste("Plot", 1:9), 
    plotFUN = paste("plot.", 1:9, sep = ""), which = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactivePlot_+3A_x">x</code></td>
<td>

<p>an object to be plotted. 
</p>
</td></tr>
<tr><td><code id="interactivePlot_+3A_choices">choices</code></td>
<td>

<p>a character vector of length at most 9, giving descriptive names of
the plots for the menu presented to the user.
</p>
</td></tr>
<tr><td><code id="interactivePlot_+3A_plotfun">plotFUN</code></td>
<td>

<p>a vector of the same length as <code>choices</code>, containing functions
and/or names of functions. <code>plotFUN[[i]]</code> is called to produce
the plot corresponding to <code>choice[i]</code>.
</p>
</td></tr> 
<tr><td><code id="interactivePlot_+3A_which">which</code></td>
<td>

<p>Which graph(s) should be displayed?
One of the character strings <code>"ask"</code> (ask the user) or
<code>"all"</code> (produce all plots), or a logical vector in which the
positions of the <code>TRUE</code> values designating the plots to
produce.
</p>
</td></tr>
<tr><td><code id="interactivePlot_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the FUN or plot function.
(2023-10-21 GNB: currently the <code>"..."</code> arguments are not
really passed on to the plotting functions.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>"which"</code> is the character string <code>"ask"</code>, then the user
is presented with a menu to interactively choose which plot(s) to
show.  Argument <code>choices</code> is used for the choices in the menu, so
they should be informative.
</p>
<p>If <code>"which"</code> is equal to <code>"all"</code> all plots are drawn. If
<code>"which"</code> is a logical vector, the indicate plots are displayed.
</p>
<p>Note that if more plots are to be shown in one window, the arrangement
should be made in advance (and cleaned up afterwards), see the
examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test Plot Function:
   testPlot = function(x, which = "all", ...) {   
     # Plot Function and Addons:
     plot.1 &lt;&lt;- function(x, ...) plot(x, ...)      
     plot.2 &lt;&lt;- function(x, ...) acf(x, ...)
     plot.3 &lt;&lt;- function(x, ...) hist(x, ...)      
     plot.4 &lt;&lt;- function(x, ...) qqnorm(x, ...)
     # Plot:
     interactivePlot(x,
       choices = c("Series Plot", "ACF", "Histogram", "QQ Plot"),
       plotFUN = c("plot.1", "plot.2", "plot.3", "plot.4"),
       which = which, ...)       
     # Return Value:
     invisible()
   }
## Plot:
   # prepare the window and store its previous state
   op &lt;- par(mfrow = c(2, 2), cex = 0.7)
   # produce the plot
   testPlot(rnorm(500))            
   # restore the previous state
   par(op)

   # Try:
   # par(mfrow = c(1,1))
   # testPlot(rnorm(500), which = "ask")

## similar to above but using functions for plotFUN
   testPlot_2 = function(x, which = "all", ...) {   
     interactivePlot(x,
       choices = c("Series Plot", "ACF", "Histogram", "QQ Plot"),
       plotFUN = c(plot.1 = function(x, ...) plot(x, ...),
                   plot.2 = function(x, ...) acf(x, ...),
                   plot.3 = function(x, ...) hist(x, ...),
                   plot.4 = function(x, ...) qqnorm(x, ...) ),
       which = which, ...)       
   
       # Return Value:
       invisible()
   }
   # produce the plot
   op &lt;- par(mfrow = c(2, 2), cex = 0.7)
   testPlot_2(rnorm(500))            
   par(op)
</code></pre>

<hr>
<h2 id='inv'>The inverse of a matrix</h2><span id='topic+inv'></span>

<h3>Description</h3>

<p>Computes the inverse of a matrix.      
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>References</h3>

<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(5)
   P
         
## Compute the Inverse Matrix:
   inv(P)
   
## Check:
   inv(P) %*% P    
   
## Alternatives:
   chol2inv(chol(P))
   solve(P)                     
</code></pre>

<hr>
<h2 id='krigeInterp'>Bivariate Krige Interpolation</h2><span id='topic+krigeInterp'></span>

<h3>Description</h3>

<p>Bivariate Krige Interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeInterp(x, y = NULL, z = NULL, gridPoints = 21,
    xo = seq(min(x), max(x), length = gridPoints),
    yo = seq(min(y), max(y), length = gridPoints),
    extrap = FALSE, polDegree = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeInterp_+3A_x">x</code>, <code id="krigeInterp_+3A_y">y</code>, <code id="krigeInterp_+3A_z">z</code></td>
<td>

<p>the arguments <code>x</code> and <code>y</code> are
two numeric vectors of grid pounts, and <code>z</code> is a numeric
matrix or any other rectangular object which can be transformed
by the function <code>as.matrix</code> into a matrix object.
</p>
</td></tr>
<tr><td><code id="krigeInterp_+3A_gridpoints">gridPoints</code></td>
<td>

<p>an integer value specifying the number of grid points in <code>x</code>
and <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="krigeInterp_+3A_xo">xo</code>, <code id="krigeInterp_+3A_yo">yo</code></td>
<td>

<p>two numeric vectors of data points spanning the grid.
</p>
</td></tr>
<tr><td><code id="krigeInterp_+3A_extrap">extrap</code></td>
<td>

<p>a logical, if <code>TRUE</code> then the data points are extrapolated.
</p>
</td></tr>
<tr><td><code id="krigeInterp_+3A_poldegree">polDegree</code></td>
<td>

<p>the polynomial krige degree, an integer ranging between 1 and 6.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with at least three entries, <code>x</code>, <code>y</code> and
<code>z</code>. The returned values can be used directly in
<code><a href="graphics.html#topic+persp">persp</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code> 3D plotting methods.
</p>


<h3>Note</h3>

<p><code>krigeInterp()</code> requires package <span class="pkg">spatial</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+akimaInterp">akimaInterp</a></code>,
<code><a href="#topic+linearInterp">linearInterp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The akima library is not auto-installed because of a different licence.
## krigeInterp -  Kriging:
set.seed(1953)
x = runif(999) - 0.5
y = runif(999) - 0.5
z = cos(2*pi*(x^2+y^2))
ans = krigeInterp(x, y, z, extrap = FALSE)
persp(ans, theta = -40, phi = 30, col = "steelblue",
    xlab = "x", ylab = "y", zlab = "z")
contour(ans)

</code></pre>

<hr>
<h2 id='kron'>Kronecker product</h2><span id='topic+kron'></span>

<h3>Description</h3>

<p>Computes the Kronecker product of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kron(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kron_+3A_x">x</code>, <code id="kron_+3A_y">y</code></td>
<td>

<p>numeric matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>Kronecker product</em> can be computed using the operator 
<code>%x%</code> or alternatively using the function <code>kron</code>
for SPlus compatibility.
</p>


<h3>Note</h3>

<p><code>kron</code> is a synonym to <code>%x%</code>.
</p>


<h3>References</h3>

<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(3)
   P
   
## Return the Kronecker Product                     
   kron(P, diag(3))
   P %x% diag(3)                        
                           
</code></pre>

<hr>
<h2 id='ks2Test'>Two sample Kolmogorov-Smirnov test</h2><span id='topic+ks2Test'></span>

<h3>Description</h3>

<p>Tests if two series are distributionally equivalent using two sample
Kolmogorov-Smirnov test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks2Test(x, y, title = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks2Test_+3A_x">x</code>, <code id="ks2Test_+3A_y">y</code></td>
<td>

<p>numeric vectors of data values.
</p>
</td></tr>
<tr><td><code id="ks2Test_+3A_title">title</code></td>
<td>

<p>an optional title string, if not specified the inputs data 
name is deparsed.
</p>
</td></tr>
<tr><td><code id="ks2Test_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The test <code>ks2Test</code> performs a Kolmogorov-Smirnov two sample
test that the two data samples, <code>x</code> and <code>y</code>, come from the
same distribution, not necessarily a normal distribution. That means
that it is not specified what that common distribution is.
</p>
<p><code>ks2Test</code> calls several times base R's <code><a href="stats.html#topic+ks.test">ks.test</a></code>
p-values for all three alternatives (two-sided, less, and greater),
as well as the exact p-value for the two-sided case.
</p>
<p>Note that the p-values are computed under a hypothesis of i.i.d.,
which is rarely the case for time series. So, the results should be
interpreted cautiosly if that is the case. The same applies when the
data are residuals from fitted models.
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>


<h3>References</h3>

<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>Lehmann E.L. (1986); 
<em>Testing Statistical Hypotheses</em>, 
John Wiley and Sons, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## rnorm - 
   # Generate Series:
   x = rnorm(50)
   y = rnorm(50)
  
## ks2Test - 
   ks2Test(x, y)
</code></pre>

<hr>
<h2 id='lcg'>Generator for Portable random innovations</h2><span id='topic+lcg'></span><span id='topic+set.lcgseed'></span><span id='topic+get.lcgseed'></span><span id='topic+runif.lcg'></span><span id='topic+rnorm.lcg'></span><span id='topic+rt.lcg'></span>

<h3>Description</h3>

<p>Functions to generate portable random innovations. 
The functions run under R and S-Plus and generate 
the same sequence of random numbers. Supported 
are uniform, normal and Student-t distributed 
random numbers.
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>set.lcgseed</code> </td><td style="text-align: left;"> Set initial random seed, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>get.lcgseed</code> </td><td style="text-align: left;"> Get the current valus of the random seed, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>runif.lcg</code> </td><td style="text-align: left;"> Uniform linear congruational generator, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rnorm.lcg</code> </td><td style="text-align: left;"> Normal linear congruational generator, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rt.lcg</code> </td><td style="text-align: left;"> Student-t linear congruential generator. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>set.lcgseed(seed = 4711)
get.lcgseed()

runif.lcg(n, min = 0, max = 1)
rnorm.lcg(n, mean = 0, sd = 1)
rt.lcg(n, df)   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcg_+3A_seed">seed</code></td>
<td>

<p>an integer value, the random number seed.
</p>
</td></tr>
<tr><td><code id="lcg_+3A_n">n</code></td>
<td>

<p>an integer, the number of random innovations to be generated.
</p>
</td></tr>
<tr><td><code id="lcg_+3A_df">df</code></td>
<td>

<p>degrees of freedom, a positive number, may be non-integer.
</p>
</td></tr>
<tr><td><code id="lcg_+3A_mean">mean</code>, <code id="lcg_+3A_sd">sd</code></td>
<td>

<p>mean and standard deviation of the normally distributed 
innovations.
</p>
</td></tr>
<tr><td><code id="lcg_+3A_min">min</code>, <code id="lcg_+3A_max">max</code></td>
<td>

<p>lower and upper limits of the uniformly distributed 
innovations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple portable random number generator for use in R and 
SPlus. We recommend to use this generator only for comparisons 
of calculations in R and Splus.
</p>
<p>The generator is a linear congruential generator with parameters
<code>LCG(a=13445, c=0, m=2^31-1, X=0)</code>. It is a simple random 
number generator which passes the bitwise randomness test.
</p>


<h3>Value</h3>

<p>A vector of generated random innovations. The value of the
current seed is stored in the variable <code>lcg.seed</code>.
</p>


<h3>References</h3>

<p>Altman, N.S. (1988);
<em>Bitwise Behavior of Random Number Generators</em>,
SIAM J. Sci. Stat. Comput., 9(5), September, 941&ndash;949.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set.lcgseed -
   set.lcgseed(seed = 65890)
 
## runif.lcg - rnorm.lcg - rt.lcg -
   cbind(runif.lcg(10), rnorm.lcg(10), rt.lcg(10, df = 4))

## get.lcgseed -
   get.lcgseed()  
   
## Note, to overwrite rnorm, use
   # rnorm = rnorm.lcg
   # Going back to rnorm
   # rm(rnorm)
</code></pre>

<hr>
<h2 id='linearInterp'>Bivariate Linear Interpolation</h2><span id='topic+linearInterp'></span><span id='topic+linearInterpp'></span>

<h3>Description</h3>

<p>Bivariate Linear Interpolation. Options are available for gridded and
pointwise interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
linearInterp(x, y = NULL, z = NULL, gridPoints = 21,
    xo = seq(min(x), max(x), length = gridPoints),
    yo = seq(min(y), max(y), length = gridPoints))
    
linearInterpp(x, y = NULL, z = NULL, xo, yo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearInterp_+3A_x">x</code>, <code id="linearInterp_+3A_y">y</code>, <code id="linearInterp_+3A_z">z</code></td>
<td>

<p>for <code>linearInterp</code> the arguments <code>x</code> and <code>y</code> are 
two numeric vectors of grid pounts, and <code>z</code> is a numeric 
matrix or any other rectangular object which can be transformed 
by the function <code>as.matrix</code> into a matrix object.  
For <code>linearInterpp</code> we  consider either three numeric vectors 
of equal length or if  <code>y</code> and <code>z</code> are NULL, a list with 
entries <code>x</code>, <code>y</code>, <code>z</code>, or named data frame with 
<code>x</code> in the first, <code>y</code> in the second, and <code>z</code> in 
the third column. 
</p>
</td></tr>
<tr><td><code id="linearInterp_+3A_gridpoints">gridPoints</code></td>
<td>

<p>an integer value specifying the number of grid points in <code>x</code> 
and <code>y</code> direction.
</p>
</td></tr> 
<tr><td><code id="linearInterp_+3A_xo">xo</code>, <code id="linearInterp_+3A_yo">yo</code></td>
<td>

<p>for <code>linearInterp</code>
two numeric vectors of data points spanning the grid, and
for <code>linearInterpp</code>
two numeric vectors of data points building pairs for pointwise
interpolation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>linearInterp</code>, a list with at least three entries,
<code>x</code>, <code>y</code> and <code>z</code>. The returned values, can be used
directly in <code>persp</code> and <code>contour</code> 3D plotting methods.
</p>
<p>for <code>linearInterpp</code>, a <code>data.frame</code> with columns
<code>"x"</code>, <code>"y"</code>, and <code>"z"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+akimaInterp">akimaInterp</a></code> and <code><a href="#topic+krigeInterp">krigeInterp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## linearInterp -
   # Linear Interpolation:    
   if (requireNamespace("interp")) {
     set.seed(1953)
     x = runif(999) - 0.5
     y = runif(999) - 0.5
     z = cos(2*pi*(x^2+y^2))
     ans = linearInterp(x, y, z, gridPoints = 41)
     persp(ans, theta = -40, phi = 30, col = "steelblue",
        xlab = "x", ylab = "y", zlab = "z")
     contour(ans)
   }
</code></pre>

<hr>
<h2 id='listFunctions'>List exported functions in a package</h2><span id='topic+listFunctions'></span><span id='topic+countFunctions'></span><span id='topic+listIndex'></span>

<h3>Description</h3>

<p>Utilities to list and count exported functions in a package, 
list the contents of the description file of a package, and 
</p>
<p>Prints the content of an index file for a package (a list of the
objects exported by a package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listFunctions(package, character.only = FALSE)
countFunctions(package, character.only = FALSE)

listIndex(package, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listFunctions_+3A_package">package</code></td>
<td>

<p>a literal character string or a character string denoting the name
of a package.
</p>
</td></tr>
<tr><td><code id="listFunctions_+3A_character.only">character.only</code></td>
<td>

<p>a logical indicating whether 'package' can be assumed to be
a character string.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>listFunctions</code>, a character vector containing the names of
the exported functions in a package,
</p>
<p>for <code>countFunctions</code>, a named numeric value giving the number of
the exported functions in a package.
</p>
<p><code>listIndex</code> doesn't return a useful value. It is used for the
side effect of printing the description or index.
</p>


<h3>Note</h3>

<p>Be aware that <code>listFunctions</code> and <code>countFunctions</code> attach
the package to the search path. 
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+packageDescription">packageDescription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## listFunctions -
   listFunctions("fBasics")
   
## countFunctions -
   countFunctions("fBasics")
</code></pre>

<hr>
<h2 id='locationTest'>Two sample location tests</h2><span id='topic+locationTest'></span>

<h3>Description</h3>

<p>Tests if two series differ in their distributional location parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locationTest(x, y, method = c("t", "kw2"), title = NULL,
    description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locationTest_+3A_x">x</code>, <code id="locationTest_+3A_y">y</code></td>
<td>

<p>numeric vectors of data values.
</p>
</td></tr>
<tr><td><code id="locationTest_+3A_method">method</code></td>
<td>

<p>a character string naming which test should be applied.
</p>
</td></tr> 
<tr><td><code id="locationTest_+3A_title">title</code></td>
<td>

<p>an optional title string, if not specified the input's data 
name is deparsed.
</p>
</td></tr>
<tr><td><code id="locationTest_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>method = "t"</code> can be used to determine if the two sample 
means are equal for unpaired data sets. Two variants are used,
assuming equal or unequal variances. 
</p>
<p>The <code>method = "kw2"</code> performs a Kruskal-Wallis rank sum 
test of the null hypothesis that the central tendencies or medians of 
two samples are the same. The alternative is that they differ. 
Note, that it is not assumed that the two samples are drawn from the 
same distribution. It is also worth to know that the test assumes 
that the variables under consideration have underlying continuous 
distributions.
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>


<h3>Note</h3>

<p>Some of the test implementations are selected from <span class="rlang"><b>R</b></span>'s <code>ctest</code>
package.
</p>


<h3>Author(s)</h3>

<p>R-core team for hypothesis tests implemented from <span class="rlang"><b>R</b></span>'s 
package <code>ctest</code>.
</p>


<h3>References</h3>

<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>Lehmann E.L. (1986); 
<em>Testing Statistical Hypotheses</em>, 
John Wiley and Sons, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## rnorm - 
   # Generate Series:
   x = rnorm(50)
   y = rnorm(50)
  
## locationTest -
   locationTest(x, y, "t")
   locationTest(x, y, "kw2")

</code></pre>

<hr>
<h2 id='maxdd'>Drawdown statistics</h2><span id='topic+maxdd'></span><span id='topic+dmaxdd'></span><span id='topic+pmaxdd'></span><span id='topic+rmaxdd'></span><span id='topic+maxddStats'></span>

<h3>Description</h3>

<p>A collection of functions which compute drawdown statistics.  Included
are density, distribution function, and random generation for the
maximum drawdown distribution. In addition the expectation of
drawdowns for Brownian motion can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmaxdd(x, sd = 1, horizon = 100, N = 1000) 
pmaxdd(q, sd = 1, horizon = 100, N = 1000) 
rmaxdd(n, mean = 0, sd = 1, horizon = 100)

maxddStats(mean = 0, sd = 1, horizon = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxdd_+3A_x">x</code>, <code id="maxdd_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>  
<tr><td><code id="maxdd_+3A_n">n</code></td>
<td>

<p>an integer value, the number of observations.
</p>
</td></tr>   
<tr><td><code id="maxdd_+3A_mean">mean</code>, <code id="maxdd_+3A_sd">sd</code></td>
<td>

<p>two numeric values, the mean and standard deviation.
</p>
</td></tr>
<tr><td><code id="maxdd_+3A_horizon">horizon</code></td>
<td>

<p>an integer value, the (run time) horizon of the investor.
</p>
</td></tr>
<tr><td><code id="maxdd_+3A_n">N</code></td>
<td>

<p>an integer value, the precession index for summations. 
Before you change this value please inspect Magdon-Ismail
et. al. (2003).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmaxdd</code> computes the density function of the maximum drawdown
distribution.  <code>pmaxdd</code> computes the distribution function.
<code>rmaxdd</code> generates random numbers from that distribution.
<code>maxddStats</code> computes the expectation of drawdowns.
</p>
<p><code>dmaxdd</code> returns for a trendless Brownian process <code>mean=0</code>
and standard deviation &quot;sd&quot;
the density from
the probability that the maximum drawdown &quot;D&quot; is larger or equal to
&quot;h&quot; in the interval [0,T], where &quot;T&quot; denotes the time <code>horizon</code>
of the investor.
</p>
<p><code>pmaxdd</code> returns for a trendless Brownian process <code>mean=0</code>
and standard deviation &quot;sd&quot;
the probability that the maximum drawdown &quot;D&quot; is larger or equal to
&quot;h&quot; in the interval [0,T], where &quot;T&quot; denotes the time <code>horizon</code>
of the investor.
</p>
<p><code>rmaxdd</code> returns for a Brownian Motion process with mean
<code>mean</code> and standard deviation <code>sd</code> random variates of
maximum drawdowns.
</p>
<p><code>maxddStats</code> returns the expected value, E[D], of maximum
drawdowns of Brownian Motion for a given drift <code>mean</code>, variance
<code>sd</code>, and runtime <code>horizon</code> of the Brownian Motion process.
</p>


<h3>Note</h3>

<p>Currrently, only the driftless case is implemented.
</p>


<h3>References</h3>

<p>Magdon-Ismail M., Atiya A.F., Pratap A., Abu-Mostafa Y.S. (2003);
<em>On the Maximum Drawdown of a Brownian Motion</em>,
Preprint, CalTech, Pasadena USA, p. 24. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rmaxdd -
   # Set a random seed
   set.seed(1953)               
   # horizon of the investor, time T
   horizon = 1000               
   # number of MC samples, N -&gt; infinity
   samples = 1000               
   # Range of expected Drawdons
   xlim = c(0, 5)*sqrt(horizon) 
   # Plot Histogram of Simulated Max Drawdowns:
   r = rmaxdd(n = samples, mean = 0, sd = 1, horizon = horizon)
   hist(x = r, n = 40, probability = TRUE, xlim = xlim, 
     col = "steelblue4", border = "white", main = "Max. Drawdown Density") 
   points(r, rep(0, samples), pch = 20, col = "orange", cex = 0.7)
   
## dmaxdd - 
   x = seq(0, xlim[2], length = 200)
   d = dmaxdd(x = x, sd = 1, horizon = horizon, N = 1000)
   lines(x, d, lwd = 2)
    
## pmaxdd -
   # Count Frequencies of Drawdowns Greater or Equal to "h":
   n = 50
   x = seq(0, xlim[2], length = n)
   g = rep(0, times = n)
   for (i in 1:n) g[i] = length (r[r &gt; x[i]]) / samples
   plot(x, g, type ="h", lwd = 3,
     xlab = "q", main = "Max. Drawdown Probability")
   # Compare with True Probability "G_D(h)":
   x = seq(0, xlim[2], length = 5*n)
   p = pmaxdd(q = x, sd = 1, horizon = horizon, N = 5000)
   lines(x, p, lwd = 2, col="steelblue4") 
   
## maxddStats -
   # Compute expectation Value E[D]:
   maxddStats(mean = -0.5, sd = 1, horizon = 10^(1:4))
   maxddStats(mean =  0.0, sd = 1, horizon = 10^(1:4))
   maxddStats(mean =  0.5, sd = 1, horizon = 10^(1:4))
</code></pre>

<hr>
<h2 id='nig'>Normal Inverse Gaussian Distribution</h2><span id='topic+nig'></span><span id='topic+dnig'></span><span id='topic+pnig'></span><span id='topic+qnig'></span><span id='topic+rnig'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the normal inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnig(x, alpha = 1, beta = 0, delta = 1, mu = 0, log = FALSE)
pnig(q, alpha = 1, beta = 0, delta = 1, mu = 0)
qnig(p, alpha = 1, beta = 0, delta = 1, mu = 0)
rnig(n, alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nig_+3A_x">x</code>, <code id="nig_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="nig_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="nig_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="nig_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter.
</p>
</td></tr>
<tr><td><code id="nig_+3A_beta">beta</code></td>
<td>

<p>skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the range
<code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="nig_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="nig_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="nig_+3A_log">log</code></td>
<td>

<p>a logical flag by default <code>FALSE</code>.  Should labels and a main
title be drawn to the plot?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dnig</code> gives the density.
<code>pnig</code> gives the distribution function.
<code>qnig</code> gives the quantile function, and
<code>rnig</code> generates random deviates.
</p>
<p>The parameters <code>alpha, beta, delta, mu</code> are in the first
parameterization of the distribution.
</p>
<p>The random deviates are calculated with the method described by
Raible (2000).
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>David Scott for code implemented from <span class="rlang"><b>R</b></span>'s contributed package
<code>HyperbolicDist</code>.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## nig -
   set.seed(1953)
   r = rnig(5000, alpha = 1, beta = 0.3, delta = 1)
   plot(r, type = "l", col = "steelblue",
     main = "nig: alpha=1 beta=0.3 delta=1")
 
## nig - 
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   x = seq(-5, 5, 0.25)
   lines(x, dnig(x, alpha = 1, beta = 0.3, delta = 1))
 
## nig -  
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, pnig(x, alpha = 1, beta = 0.3, delta = 1))
   
## nig -
   # Compute Quantiles:
   qnig(pnig(seq(-5, 5, 1), alpha = 1, beta = 0.3, delta = 1), 
     alpha = 1, beta = 0.3, delta = 1) 
</code></pre>

<hr>
<h2 id='nigFit'>Fit of a Normal Inverse Gaussian Distribution</h2><span id='topic+nigFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a normal inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   
nigFit(x, alpha = 1, beta = 0, delta = 1, mu = 0, 
    method = c("mle", "gmm", "mps", "vmps"), scale = TRUE, doplot = TRUE, 
    span = "auto", trace = TRUE, title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nigFit_+3A_alpha">alpha</code>, <code id="nigFit_+3A_beta">beta</code>, <code id="nigFit_+3A_delta">delta</code>, <code id="nigFit_+3A_mu">mu</code></td>
<td>

<p>The parameters are <code>alpha</code>, <code>beta</code>, <code>delta</code>, and
<code>mu</code>:<br />
shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_method">method</code></td>
<td>

<p>a character string. Either 
<code>"mle"</code>, Maximum Likelihood Estimation, the default, 
<code>"gmm"</code> Gemeralized Method of Moments Estimation, 
<code>"mps"</code> Maximum Product Spacings Estimation, or
<code>"vmps"</code> Minimum Variance Product Spacings Estimation.
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series
be scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
      times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and right endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="nigFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
</p>
<p>Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## nigFit -
   # Simulate Random Variates:
   set.seed(1953)
   s = rnig(n = 1000, alpha = 1.5, beta = 0.3, delta = 0.5, mu = -1.0) 

## nigFit -  
   # Fit Parameters:
   nigFit(s, alpha = 1, beta = 0, delta = 1, mu = mean(s), doplot = TRUE) 
</code></pre>

<hr>
<h2 id='nigMode'>Normal Inverse Gaussian Mode</h2><span id='topic+nigMode'></span>

<h3>Description</h3>

<p>Computes the mode of the norm inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigMode(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nigMode_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter.
</p>
</td></tr>
<tr><td><code id="nigMode_+3A_beta">beta</code></td>
<td>

<p>skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the range
<code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="nigMode_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="nigMode_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value, the mode of the normal inverse Gaussian distribution
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## nigMode -
   nigMode()
</code></pre>

<hr>
<h2 id='nigMoments'>Moments for the Normal Inverse Gaussian</h2><span id='topic+nigMoments'></span><span id='topic+nigMean'></span><span id='topic+nigVar'></span><span id='topic+nigSkew'></span><span id='topic+nigKurt'></span>

<h3>Description</h3>

<p>Computes the first four moments for the
normal inverse Gaussian distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigMean(alpha = 1, beta = 0, delta = 1, mu = 0)
nigVar(alpha = 1, beta = 0, delta = 1, mu = 0)
nigSkew(alpha = 1, beta = 0, delta = 1, mu = 0)
nigKurt(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nigMoments_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter.
</p>
</td></tr>
<tr><td><code id="nigMoments_+3A_beta">beta</code></td>
<td>

<p>skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the range
<code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="nigMoments_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="nigMoments_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one
of <code>mean</code>, <code>var</code>, <code>skew</code>, or <code>kurt</code>, obtained by
dropping the <code>nig</code> prefix from the name of the corresponding
function and lowercasing it.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz.
</p>


<h3>References</h3>

<p>Scott, D. J., Wuertz, D. and Tran, T. T. (2008) 
<em>Moments of the Generalized Hyperbolic Distribution</em>. 
Preprint. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## nigMean -
   # Median:
   nigMean(alpha = 1, beta = 0, delta = 1, mu = 0)
 
## nigVar - 
   # Inter-quartile Range:
   nigVar(alpha = 1, beta = 0, delta = 1, mu = 0)
 
## nigSKEW -  
   # Robust Skewness:
   nigSkew(alpha = 1, beta = 0, delta = 1, mu = 0)
   
## nigKurt -
   # Robust Kurtosis:
   nigKurt(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>

<hr>
<h2 id='nigRobMoments'>Robust Moments for the NIG</h2><span id='topic+nigRobMoments'></span><span id='topic+nigMED'></span><span id='topic+nigIQR'></span><span id='topic+nigSKEW'></span><span id='topic+nigKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the
Normal Inverse Gaussian Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigMED(alpha = 1, beta = 0, delta = 1, mu = 0)
nigIQR(alpha = 1, beta = 0, delta = 1, mu = 0)
nigSKEW(alpha = 1, beta = 0, delta = 1, mu = 0)
nigKURT(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nigRobMoments_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter.
</p>
</td></tr>
<tr><td><code id="nigRobMoments_+3A_beta">beta</code></td>
<td>

<p>skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the range
<code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="nigRobMoments_+3A_delta">delta</code></td>
<td>

<p>scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="nigRobMoments_+3A_mu">mu</code></td>
<td>

<p>location parameter, by default 0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is
one of <code>MED</code>, <code>IQR</code>, <code>SKEW</code>, or <code>KURT</code>, obtained
by dropping the <code>nig</code> prefix from the name of the corresponding
function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## nigMED -
   # Median:
   nigMED(alpha = 1, beta = 0, delta = 1, mu = 0)

## nigIQR -
   # Inter-quartile Range:
   nigIQR(alpha = 1, beta = 0, delta = 1, mu = 0)

## nigSKEW -
   # Robust Skewness:
   nigSKEW(alpha = 1, beta = 0, delta = 1, mu = 0)

## nigKURT -
   # Robust Kurtosis:
   nigKURT(alpha = 1, beta = 0, delta = 1, mu = 0)
</code></pre>

<hr>
<h2 id='nigShapeTriangle'>NIG Shape Triangle</h2><span id='topic+nigShapeTriangle'></span>

<h3>Description</h3>

<p>Plots the normal inverse Gaussian Shape Triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigShapeTriangle(object, add = FALSE, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nigShapeTriangle_+3A_object">object</code></td>
<td>

<p>an object of class <code>"fDISTFIT"</code> as returned by the function
<code>nigFit</code>.
</p>
</td></tr> 
<tr><td><code id="nigShapeTriangle_+3A_add">add</code></td>
<td>

<p>a logical value. Should another point added to the NIG
shape triangle? By default FALSE, a new plot will be created.
</p>
</td></tr> 
<tr><td><code id="nigShapeTriangle_+3A_labels">labels</code></td>
<td>

<p>a logical flag by default <code>TRUE</code>. 
Should the logarithm of the density be returned?
</p>
</td></tr>
<tr><td><code id="nigShapeTriangle_+3A_...">...</code></td>
<td>

<p>arguments to be passed to the function <code>integrate</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>displays the parameters of fitted distributions in the
NIG shape triangle.
</p>


<h3>Author(s)</h3>

<p>David Scott for code implemented from <span class="rlang"><b>R</b></span>'s contributed package
<code>HyperbolicDist</code>.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1982); 
<em>The simulation of generalized inverse Gaussian and hyperbolic 
random variables</em>,
SIAM J. Sci. Stat. Comput. 3, 502&ndash;515. 
</p>
<p>Barndorff-Nielsen O. (1977);
<em>Exponentially decreasing distributions for the logarithm of 
particle size</em>, 
Proc. Roy. Soc. Lond., A353, 401&ndash;419. 
</p>
<p>Barndorff-Nielsen O., Blaesild, P. (1983); 
<em>Hyperbolic distributions. In Encyclopedia of Statistical 
Sciences</em>, 
Eds., Johnson N.L., Kotz S. and Read C.B., 
Vol. 3, pp. 700&ndash;707. New York: Wiley. 
</p>
<p>Raible S. (2000);
<em>Levy Processes in Finance: Theory, Numerics and Empirical Facts</em>,
PhD Thesis, University of Freiburg, Germany, 161 pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## nigShapeTriangle -
   #
</code></pre>

<hr>
<h2 id='nigSlider'>nigerbolic Distribution Slider</h2><span id='topic+nigSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the 
nigerbolic distribution on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nigSlider()
</code></pre>


<h3>Value</h3>

<p>a tcl/tk based graphical user interface.
</p>
<p>This is a nice display for educational purposes to investigate
the densities and probabilities of the invetrse Gaussian 
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## nigSlider -
   # nigSlider()
</code></pre>

<hr>
<h2 id='norm'>Matrix norm</h2><span id='topic+norm2'></span>

<h3>Description</h3>

<p>Computes the norm of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
<tr><td><code id="norm_+3A_p">p</code></td>
<td>

<p>an integer value, <code>1</code>, <code>2</code> or <code>Inf</code>, see section
&lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>norm2</code> computes the norm of a matrix. Three choices
are possible:
</p>

<dl>
<dt><code>p=1</code></dt><dd>
<p>The maximum absolute column sum norm which is defined as the
maximum of the sum of the absolute valued elements of columns of
the matrix.
</p>
</dd>
<dt><code>p=2</code></dt><dd>
<p>The spectral norm is &quot;the norm&quot; of a matrix <code>X</code>.  This value
is computed as the square root of the maximum eigenvalue of
<code>CX</code>, where <code>C</code> is the conjugate transpose.
</p>
</dd>
<dt><code>p=Inf</code></dt><dd>
<p>The maximum absolute row sum norm is defined as the maximum of the
sum of the absolute valued elements of rows of the matrix.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>the requested norm of the matrix, a non-negative number
</p>


<h3>Note</h3>

<p>Since <code>base::norm()</code> has become available in the R base
environment, the function <code>fBasics::norm()</code> has become obsolete.
To avoid conflicts with <code>norm()</code> we have renamed the fBasics' one
to <code>norm2</code>.
</p>


<h3>References</h3>

<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P &lt;- pascal(5)
   P                  
     
## Return the Norm of the Matrix:                      
   norm2(P)                                                       
</code></pre>

<hr>
<h2 id='NormalityTests'>Tests for normality</h2><span id='topic+NormalityTests'></span><span id='topic+normalTest'></span><span id='topic+ksnormTest'></span><span id='topic+shapiroTest'></span><span id='topic+jarqueberaTest'></span><span id='topic+dagoTest'></span><span id='topic+jbTest'></span><span id='topic+adTest'></span><span id='topic+cvmTest'></span><span id='topic+lillieTest'></span><span id='topic+pchiTest'></span><span id='topic+sfTest'></span>

<h3>Description</h3>

<p>A collection of functions of one sample tests for testing normality
of financial return series.
<br />
</p>
<p>The functions for testing normality are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>ksnormTest</code> </td><td style="text-align: left;"> Kolmogorov-Smirnov normality test, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>shapiroTest</code> </td><td style="text-align: left;"> Shapiro-Wilk's test for normality, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>jarqueberaTest</code> </td><td style="text-align: left;"> Jarque-Bera test for normality, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dagoTest</code> </td><td style="text-align: left;"> D'Agostino normality test. </td>
</tr>

</table>

<p>Functions for high precision Jarque Bera LM and ALM tests:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>jbTest</code> </td><td style="text-align: left;"> Performs finite sample adjusted JB, LM and ALM test. </td>
</tr>

</table>

<p>Additional functions for testing normality from the 'nortest' package:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>adTest</code> </td><td style="text-align: left;"> Anderson--Darling normality test, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cvmTest</code> </td><td style="text-align: left;"> Cramer--von Mises normality test, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>lillieTest</code> </td><td style="text-align: left;"> Lilliefors (Kolmogorov-Smirnov) normality test, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pchiTest</code> </td><td style="text-align: left;"> Pearson chi-square normality test, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>sfTest</code> </td><td style="text-align: left;"> Shapiro-Francia normality test. </td>
</tr>

</table>

<p>For SPlus/Finmetrics Compatibility:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>normalTest</code> </td><td style="text-align: left;"> test suite for some normality tests. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>ksnormTest(x, title = NULL, description = NULL)

jbTest(x, title = NULL, description = NULL)
shapiroTest(x, title = NULL, description = NULL)
normalTest(x, method = c("sw", "jb"), na.rm = FALSE)

jarqueberaTest(x, title = NULL, description = NULL)
dagoTest(x, title = NULL, description = NULL)

adTest(x, title = NULL, description = NULL)
cvmTest(x, title = NULL, description = NULL)
lillieTest(x, title = NULL, description = NULL)
pchiTest(x, title = NULL, description = NULL)
sfTest(x, title = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalityTests_+3A_x">x</code></td>
<td>

<p>a numeric vector of data values or an S4 object of class
<code>"timeSeries"</code>.
</p>
</td></tr>
<tr><td><code id="NormalityTests_+3A_title">title</code></td>
<td>

<p>an optional character string, if not specified the inputs data name
is deparsed.
</p>
</td></tr>
<tr><td><code id="NormalityTests_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr>
<tr><td><code id="NormalityTests_+3A_method">method</code></td>
<td>

<p>for <code>normalTest</code> only, indicates one of four different methods
for the normality test, one of <code>"ks"</code> (Kolmogorov-Smirnov
one-sample test, the the default), <code>"sw"</code> (Shapiro-Wilk test),
<code>"jb"</code> (Jarque-Bera Test), and <code>"da"</code> (D'Agostino Test).
</p>
</td></tr>
<tr><td><code id="NormalityTests_+3A_na.rm">na.rm</code></td>
<td>

<p>for <code>normalTest</code> only, a logical value. Should missing values
removed before computing the tests? The default value is
<code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypothesis tests may be of interest for many financial
and economic applications, especially for the investigation
of univariate time series returns.
</p>
<p>Several tests for testing if the records from a data set are normally
distributed are available. The input to all these functions may be
just a vector <code>x</code> or a univariate time series object <code>x</code>
of class <code>timeSeries</code>.
</p>
<p>First, there exists a wrapper function which allows to call one from
two normal tests either the Shapiro&ndash;Wilks test or the Jarque&ndash;Bera
test. This wrapper was introduced for compatibility with S-Plus'
FinMetrics package.
</p>
<p>Also available are the Kolmogorov&ndash;Smirnov one sample test and the
D'Agostino normality test.
</p>
<p>The remaining five normal tests are the Anderson&ndash;Darling test,
the Cramer&ndash;von Mises test, the Lilliefors (Kolmogorov&ndash;Smirnov)
test, the Pearson chi&ndash;square test, and the Shapiro&ndash;Francia test.
They are calling functions from R's contributed package <code>nortest</code>.
The difference to the original test functions implemented in R and
from contributed R packages is that the Rmetrics functions accept
time series objects as input and give a more detailed output report.
</p>
<p>The Anderson-Darling test is used to test if a sample of data came
from a population with a specific distribution, here the normal
distribution. The <code>adTest</code> goodness-of-fit test can be
considered as a modification of the Kolmogorov&ndash;Smirnov test which
gives more weight to the tails than does the <code>ksnormTest</code>.
</p>
<p>Note that <code>jarqueBeraTest</code> computes the asymptotic statistic
and p-value, while <code>jbTesT</code> gives final sample approximations.
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>
<p>Slot <code>test</code> is a list containing the following (optionally empty)
elements (in addition to those described in <code><a href="#topic+fHTEST">fHTEST</a></code>):
</p>

<dl>
<dt>ksnormTest</dt><dd>
<p>the 'D' statistic and p-values for the three alternatives
'two-sided, 'less' and 'greater'.
</p>
</dd>
<dt>shapiroTest</dt><dd>
<p>the 'W' statistic and the p-value.
</p>
</dd>
<dt>jarqueberaTest</dt><dd>
<p>no additional elements.
</p>
</dd>
<dt>jbTest</dt><dd>
<p>the 'Chi-squared' statistic with 2 degrees of freedom and the
asymptotic p-value. <code>jbTest</code> is the finite sample version of
the Jarque Bera Lagrange multiplier, LM, and adjusted Lagrange
multiplier test, ALM.
</p>
</dd>
<dt>dagoTest</dt><dd>
<p>the 'Chi-squared', the 'Z3' (Skewness) and 'Z4' (Kurtosis)
statistic together with the corresponding p values.
</p>
</dd>
<dt>adTest</dt><dd>
<p>the 'A' statistic and the p-value.
</p>
</dd>
<dt>cvmTest</dt><dd>
<p>the 'W' statistic and the p-value.
</p>
</dd>
<dt>lillieTest</dt><dd>
<p>the 'D' statistic and the p-value.
</p>
</dd>
<dt>pchiTest</dt><dd>
<p>the value for the 'P' statistic and the p-values for the adjusted
and not adjusted test cases.  In addition the number of classes is
printed, taking the default value due to Moore (1986) computed
from the expression <code>n.classes = ceiling(2 * (n^(2/5)))</code>,
where <code>n</code> is the number of observations.
</p>
</dd>
<dt>sfTest</dt><dd>
<p>the 'W' statistic and the p-value.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Some of the test implementations are selected from R's <code>ctest</code>
and <code>nortest</code> packages.
</p>


<h3>Author(s)</h3>

<p>R-core team for the tests from <span class="rlang"><b>R</b></span>'s ctest package,<br />
Adrian Trapletti for the runs test from <span class="rlang"><b>R</b></span>'s tseries package,<br />
Juergen Gross for the normal tests from <span class="rlang"><b>R</b></span>'s nortest package,<br />
James Filliben for the Fortran program producing the runs report,<br />
Diethelm Wuertz and Helmut Katzgraber for the finite sample JB tests, <br />
Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port. <br />
Earlier versions of theses functions  were based on Fortran code of Paul Johnson.
</p>


<h3>References</h3>

<p>Anderson T.W., Darling D.A. (1954);
<em>A Test of Goodness of Fit</em>,
JASA 49:765&ndash;69.
</p>
<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>D'Agostino R.B., Pearson E.S. (1973);
<em>Tests for Departure from Normality</em>,
Biometrika 60, 613&ndash;22.
</p>
<p>D'Agostino R.B., Rosman B. (1974);
<em>The Power of Geary's Test of Normality</em>,
Biometrika 61, 181&ndash;84.
</p>
<p>Durbin J. (1961);
<em>Some Methods of Constructing Exact Tests</em>,
Biometrika 48, 41&ndash;55.
</p>
<p>Durbin,J. (1973);
<em>Distribution Theory Based on the Sample Distribution Function</em>,
SIAM, Philadelphia.
</p>
<p>Geary R.C. (1947);
<em>Testing for Normality</em>;
Biometrika 36, 68&ndash;97.
</p>
<p>Lehmann E.L. (1986);
<em>Testing Statistical Hypotheses</em>,
John Wiley and Sons, New York.
</p>
<p>Linnet K. (1988);
<em>Testing Normality of Transformed Data</em>,
Applied Statistics 32, 180&ndash;186.
</p>
<p>Moore, D.S. (1986);
<em>Tests of the chi-squared type</em>,
In: D'Agostino, R.B. and Stephens, M.A., eds.,
Goodness-of-Fit Techniques, Marcel Dekker, New York.
</p>
<p>Shapiro S.S., Francia R.S. (1972);
<em>An Approximate Analysis of Variance Test for Normality</em>,
JASA 67, 215&ndash;216.
</p>
<p>Shapiro S.S., Wilk M.B., Chen V. (1968);
<em>A Comparative Study of Various Tests for Normality</em>,
JASA 63, 1343&ndash;72.
</p>
<p>Thode H.C. (2002);
<em>Testing for Normality</em>,
Marcel Dekker, New York.
</p>
<p>Weiss M.S. (1978);
<em>Modification of the Kolmogorov-Smirnov
Statistic for Use with Correlated Data</em>,
JASA 73, 872&ndash;75.
</p>
<p>Wuertz D., Katzgraber H.G. (2005);
<em>Precise finite-sample quantiles of the
Jarque-Bera adjusted Lagrange multiplier test</em>,
ETHZ Preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Series:
   x = rnorm(100)

## ksnormTests -
   # Kolmogorov - Smirnov One-Sampel Test
   ksnormTest(x)

## shapiroTest - Shapiro-Wilk Test
   shapiroTest(x)

## jarqueberaTest -
   # Jarque - Bera Test
   # jarqueberaTest(x)
   # jbTest(x)
</code></pre>

<hr>
<h2 id='normRobMoments'>Robust moments for the Normal distribution</h2><span id='topic+normRobMoments'></span><span id='topic+normMED'></span><span id='topic+normIQR'></span><span id='topic+normSKEW'></span><span id='topic+normKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the
Normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normMED(mean = 0, sd = 1)
normIQR(mean = 0, sd = 1)
normSKEW(mean = 0, sd = 1)
normKURT(mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normRobMoments_+3A_mean">mean</code></td>
<td>

<p>locaiton parameter.
</p>
</td></tr>
<tr><td><code id="normRobMoments_+3A_sd">sd</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one of <code>MED</code>, <code>IQR</code>,
<code>SKEW</code>, or <code>KURT</code>, obtained by dropping the <code>gh</code> prefix
from the name of the corresponding function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normMED -
   # Median:
   normMED(mean = 0, sd = 1)

## normIQR -
   # Inter-quartile Range:
   normIQR(mean = 0, sd = 1)

## normSKEW -
   # Robust Skewness:
   normSKEW(mean = 0, sd = 1)

## normKURT -
   # Robust Kurtosis:
   normKURT(mean = 0, sd = 1)

</code></pre>

<hr>
<h2 id='pascal'>Pascal matrix</h2><span id='topic+pascal'></span>

<h3>Description</h3>

<p>Creates a Pascal matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pascal(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pascal_+3A_n">n</code></td>
<td>

<p>an integer value, the dimension of the square matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pascal</code> generates a Pascal matrix of order <code>n</code>
which is a symmetric positive definite matrix with integer entries
made up from Pascal's triangle. The determinant of a Pascal matrix is
1.  The inverse of a Pascal matrix has integer entries. If
<code>lambda</code> is an eigenvalue of a Pascal matrix, then
<code>1/lambda</code> is also an eigenvalue of the matrix. Pascal matrices
are ill-conditioned.
</p>


<h3>References</h3>

<p>Call G.S., Velleman D.J., (1993);
<em>Pascal's matrices</em>, 
American Mathematical Monthly 100, 372&ndash;376.
</p>
<p>Edelman A., Strang G., (2004);
<em>Pascal Matrices</em>, 
American Mathematical Monthly 111, 361&ndash;385.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(5)
   P 
   
## Determinant
   det(pascal(5)) 
   det(pascal(10))   
   det(pascal(15))   
   det(pascal(20))                                       
</code></pre>

<hr>
<h2 id='pdl'>Polynomial distributed lags</h2><span id='topic+pdl'></span>

<h3>Description</h3>

<p>Creates a regressor matrix for polynomial distributed lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdl(x, d = 2, q = 3, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdl_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr> 
<tr><td><code id="pdl_+3A_d">d</code></td>
<td>

<p>an integer specifying the order of the polynomial. 
</p>
</td></tr>
<tr><td><code id="pdl_+3A_q">q</code></td>
<td>

<p>an integer specifying the number of lags to use in creating
polynomial distributed lags. This must be greater than <code>d</code>.
</p>
</td></tr>   
<tr><td><code id="pdl_+3A_trim">trim</code></td>
<td>

<p>a logical flag; if <code>TRUE</code>, the missing values at the beginning
of the returned matrix will be trimmed.
</p>
</td></tr>   
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tslag">tslag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pdl -
   #                                      
</code></pre>

<hr>
<h2 id='positiveDefinite'>Positive definite matrices</h2><span id='topic+positiveDefinite'></span><span id='topic+isPositiveDefinite'></span><span id='topic+makePositiveDefinite'></span>

<h3>Description</h3>

<p>Checks if a matrix is positive definite and/or forces a matrix to be
positive definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPositiveDefinite(x)
makePositiveDefinite(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positiveDefinite_+3A_x">x</code></td>
<td>

<p>a square numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>isPositiveDefinite</code> checks if a square matrix is
positive definite.
</p>
<p>The function <code>makePositiveDefinite</code> forces a matrix to be
positive definite.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## isPositiveDefinite - 
   # the 3x3 Pascal Matrix is positive define 
   isPositiveDefinite(pascal(3))                
</code></pre>

<hr>
<h2 id='print'>Print control</h2><span id='topic+print.control'></span>

<h3>Description</h3>

<p>Unlists and prints a control object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'control'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>the object to be printed.      
</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints control
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## print -
   control = list(n = 211, seed = 54, name = "generator")
   print(control) 
   class(control) = "control"
   print(control)  
</code></pre>

<hr>
<h2 id='QuantileQuantilePlots'>Quantile-Quantile plots</h2><span id='topic+qqnormPlot'></span><span id='topic+qqnigPlot'></span><span id='topic+qqghtPlot'></span><span id='topic+qqgldPlot'></span>

<h3>Description</h3>

<p>Returns quantile-quantile plots for the normal,
the normal inverse Gaussian, the generalized 
hyperbolic Student-t and the generalized lambda
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     
qqnormPlot(x, labels = TRUE, col = "steelblue", pch = 19,
    title = TRUE, mtext = TRUE, grid = FALSE, rug = TRUE, 
    scale = TRUE, ...) 
qqnigPlot(x, labels = TRUE, col = "steelblue", pch = 19,
    title = TRUE, mtext = TRUE, grid = FALSE, rug = TRUE, 
    scale = TRUE, ...) 
qqghtPlot(x, labels = TRUE, col = "steelblue", pch = 19,
    title = TRUE, mtext = TRUE, grid = FALSE, rug = TRUE, 
    scale = TRUE, ...) 
qqgldPlot(x, labels = TRUE, col = "steelblue", pch = 19,
    title = TRUE, mtext = TRUE, grid = FALSE, rug = TRUE, 
    scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantileQuantilePlots_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code> or any other object which can
be transformed by<code>as.timeSeries</code> into an object of class
<code>"timeSeries"</code>. The latter case, other then <code>"timeSeries"</code>
objects, is more or less untested.
</p>
</td></tr>  
<tr><td><code id="QuantileQuantilePlots_+3A_labels">labels</code></td>
<td>

<p>a logical flag, should the plot be returned with default labels and
decorated in an automated way? By default <code>TRUE</code>.
</p>
</td></tr>  
<tr><td><code id="QuantileQuantilePlots_+3A_col">col</code></td>
<td>

<p>the color for the series. In the univariate case use just a color
name like the default, <code>col="steelblue"</code>, in the multivariate
case we recommend to select the colors from a color palette,
e.g. <code>col=heat.colors(ncol(x))</code>.
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_pch">pch</code></td>
<td>

<p>an integer value, by default 19. Which plot character should be used
in the plot?
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_title">title</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a default title added
to the plot?
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_mtext">mtext</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should a marginal text be
printed on the third site of the graph?
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_grid">grid</code></td>
<td>

<p>a logical flag, should a grid be added to the plot?  By default
<code>TRUE</code>. To plot a horizontal lines only use <code>grid="h"</code> and
for vertical lines use <code>grid="h"</code>, respectively.
</p>
</td></tr> 
<tr><td><code id="QuantileQuantilePlots_+3A_rug">rug</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code> . Should a rug representation
of the data added to the plot?
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series be
scaled for the investigation?
</p>
</td></tr>
<tr><td><code id="QuantileQuantilePlots_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of Functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>qqnormPlot</code> Produces a tailored Normal quantile-quantile plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qqnigPlot</code>  Produces a tailored NIG quantile-quantile plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qqghtPlot</code>  Produces a tailored GHT quantile-quantile plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qqgldPlot</code>  Produces a tailored GLD quantile-quantile plot.</td>
</tr>

</table>



<h3>Value</h3>

<p>displays a quantile-quantile plot.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data - 
   data(LPP2005REC, package = "timeSeries")
   SPI &lt;- LPP2005REC[, "SPI"]
   plot(SPI, type = "l", col = "steelblue", main = "SP500")
   abline(h = 0, col = "grey")
   
## qqPlot -
   qqnormPlot(SPI) 
</code></pre>

<hr>
<h2 id='ReturnSeriesGUI'>Return series plots</h2><span id='topic+returnSeriesGUI'></span>

<h3>Description</h3>

<p>A graphical user interface to display finanical time series plots.
<code>returnSeriesGUI</code> opens a GUI for return series plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
returnSeriesGUI(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReturnSeriesGUI_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code> or any other object which
can be transformed by the function <code>as.timeSeries</code> into an
object of class <code>timeSeries</code>. The latter case, other than
<code>timeSeries</code> objects, is more or less untested.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>For <code>returnSeriesGUI</code> function, besides the graphical
user interface no values are returned.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>

<hr>
<h2 id='rk'>The rank of a matrix</h2><span id='topic+rk'></span>

<h3>Description</h3>

<p>Computes the rank of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rk(x, method = c("qr", "chol"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rk_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
<tr><td><code id="rk_+3A_method">method</code></td>
<td>

<p>a character string. For <code>method = "qr"</code> the rank is computed as
<code>qr(x)\$rank</code>, or alternatively for <code>method = "chol"</code> the
rank is computed as <code>attr(chol(x, pivot = TRUE), "rank")</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rk</code> computes the rank of a matrix which is the
dimension of the range of the matrix corresponding to the number of
linearly independent rows or columns of the matrix, or to the number
of nonzero singular values.
</p>
<p>The rank of a matrix is also named linear map. 
</p>


<h3>References</h3>

<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(5)
   P
   
## Compute the Rank:
   rk(P)
   rk(P, "chol")                                
</code></pre>

<hr>
<h2 id='rowStats'>Row statistics</h2><span id='topic+rowStats'></span><span id='topic+rowSds'></span><span id='topic+rowVars'></span><span id='topic+rowSkewness'></span><span id='topic+rowKurtosis'></span><span id='topic+rowMaxs'></span><span id='topic+rowMins'></span><span id='topic+rowProds'></span><span id='topic+rowQuantiles'></span><span id='topic+rowAvgs'></span><span id='topic+rowStdevs'></span>

<h3>Description</h3>

<p>Functions to compute row statistical properties 
of financial and economic time series data. 
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">  
    <code>rowStats</code></td><td style="text-align: left;"> calculates row statistics, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowSds</code> </td><td style="text-align: left;"> calculates row standard deviations, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowVars</code> </td><td style="text-align: left;"> calculates row variances, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>rowSkewness</code> </td><td style="text-align: left;"> calculates row skewness, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowKurtosis</code> </td><td style="text-align: left;"> calculates row kurtosis, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowMaxs</code> </td><td style="text-align: left;"> calculates maximum values in each row, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowMins</code> </td><td style="text-align: left;"> calculates minimum values in each row, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowProds</code> </td><td style="text-align: left;"> computes product of all values in each row, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rowQuantiles</code> </td><td style="text-align: left;"> computes quantiles of each row. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>rowStats(x, FUN, ...) 


rowSds(x, ...)
rowVars(x, ...)
rowSkewness(x, ...)
rowKurtosis(x, ...)
rowMaxs(x, ...)
rowMins(x, ...)
rowProds(x, ...)
rowQuantiles(x, prob = 0.05, ...)

rowStdevs(x, ...)
rowAvgs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowStats_+3A_fun">FUN</code></td>
<td>

<p>a function name, the statistical function to be applied.
</p>
</td></tr>
<tr><td><code id="rowStats_+3A_prob">prob</code></td>
<td>

<p>a numeric value, the probability with value in [0,1].
</p>
</td></tr>
<tr><td><code id="rowStats_+3A_x">x</code></td>
<td>

<p>a rectangular object which can be transformed into a matrix
by the function <code>as.matrix</code>.  
</p>
</td></tr>
<tr><td><code id="rowStats_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>each function returns a numeric vector of the statistics
</p>


<h3>See Also</h3>

<p><code><a href="timeSeries.html#topic+colStats">colStats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated Return Data in Matrix Form:
   x = matrix(rnorm(10*10), nrow = 10)
     
## rowStats -
   rowStats(x, FUN = mean)
   
## rowMaxs -
   rowMaxs(x)  
</code></pre>

<hr>
<h2 id='sampleLMoments'>Sample L-moments</h2><span id='topic+sampleLMoments'></span><span id='topic+sampleLmoments'></span>

<h3>Description</h3>

<p>Computes L-moments from an empirical sample data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleLmoments(x, rmax = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleLMoments_+3A_x">x</code></td>
<td>

<p>numeric vector, the sample values.
</p>
</td></tr>
<tr><td><code id="sampleLMoments_+3A_rmax">rmax</code></td>
<td>

<p>an integer value, the number of L-moments to be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector of length <code>rmax</code> with names
<code>c("L1", "L2", ..., "L&lt;rmax&gt;")</code>
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## Sample:
   x = rt(100, 4)
   
## sampleLmoments -
   sampleLmoments(x)
</code></pre>

<hr>
<h2 id='sampleRobMoments'>Robust moments for the GLD</h2><span id='topic+sampleRobMoments'></span><span id='topic+sampleMED'></span><span id='topic+sampleIQR'></span><span id='topic+sampleSKEW'></span><span id='topic+sampleKURT'></span>

<h3>Description</h3>

<p>Computes the first four robust moments for the
Normal Inverse Gaussian Distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMED(x)
sampleIQR(x)
sampleSKEW(x)
sampleKURT(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRobMoments_+3A_x">x</code></td>
<td>

<p>numeric vector, the sample values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numerical value.  The name is one of <code>MED</code>, <code>IQR</code>,
<code>SKEW</code>, or <code>KURT</code>, obtained by dropping the <code>sample</code> prefix
from the name of the corresponding function.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## Sample:
   x = rt(100, 4)
   
## sampleMED -
   # Median:
   sampleMED(x)
 
## sampleIQR - 
   # Inter-quartile Range:
   sampleIQR(x)
 
## sampleSKEW -  
   # Robust Skewness:
   sampleSKEW(x)
   
## sampleKURT -
   # Robust Kurtosis:
   sampleKURT(x)
</code></pre>

<hr>
<h2 id='scaleTest'>Two sample scale tests</h2><span id='topic+scaleTest'></span>

<h3>Description</h3>

<p>Tests if two series differ in their distributional scale parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleTest(x, y, method = c("ansari", "mood"), 
    title = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleTest_+3A_x">x</code>, <code id="scaleTest_+3A_y">y</code></td>
<td>

<p>numeric vectors of data values.
</p>
</td></tr>
<tr><td><code id="scaleTest_+3A_method">method</code></td>
<td>

<p>a character string naming which test should be applied.
</p>
</td></tr> 
<tr><td><code id="scaleTest_+3A_title">title</code></td>
<td>

<p>an optional title string, if not specified the inputs data 
name is deparsed.
</p>
</td></tr>
<tr><td><code id="scaleTest_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>method="ansari"</code> performs the Ansari-Bradley two-sample 
test for a difference in scale parameters. The test returns for 
any sizes of the series <code>x</code> and <code>y</code> the exact p value 
together with its asymptotic limit.  
</p>
<p>The <code>method="mood"</code>, is another test which performs a 
two-sample test for a difference in scale parameters. The underlying 
model is that the two samples are drawn from <em>f(x-l)</em> and 
<em>f((x-l)/s)/s</em>, respectively, where <em>l</em> is a common 
location parameter and <em>s</em> is a scale parameter. The null 
hypothesis is <em>s=1</em>. 
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>


<h3>Note</h3>

<p>Some of the test implementations are selected from <span class="rlang"><b>R</b></span>'s <code>ctest</code>
package.
</p>


<h3>Author(s)</h3>

<p>R-core team for hypothesis tests implemented from <span class="rlang"><b>R</b></span>'s 
package <code>ctest</code>.
</p>


<h3>References</h3>

<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>Lehmann E.L. (1986); 
<em>Testing Statistical Hypotheses</em>, 
John Wiley and Sons, New York.
</p>
<p>Moore, D.S. (1986);
<em>Tests of the chi-squared type</em>, 
In: D'Agostino, R.B. and Stephens, M.A., eds., 
Goodness-of-Fit Techniques, Marcel Dekker, New York. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## rnorm - 
   # Generate Series:
   x = rnorm(50)
   y = rnorm(50)
   
## scaleTest -
   scaleTest(x, y, "ansari")
   scaleTest(x, y, "mood")
</code></pre>

<hr>
<h2 id='ScalingLawPlot'>Scaling law behaviour</h2><span id='topic+scalinglawPlot'></span>

<h3>Description</h3>

<p>Evaluates the scaling exponent of a financial return series and plots
the scaling law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalinglawPlot(x, span = ceiling(log(length(x)/252)/log(2)), doplot = TRUE, 
    labels = TRUE, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalingLawPlot_+3A_x">x</code></td>
<td>

<p>an uni- or multivariate return series of class <code>"timeSeries"</code> 
or any other object which can be transformed by the function
<code>as.timeSeries()</code> into an object of class <code>"timeSeries"</code>.
</p>
</td></tr>
<tr><td><code id="ScalingLawPlot_+3A_span">span</code></td>
<td>

<p>an integer value, determines for the <code>qqgaussPlot</code> the 
plot range, by default 5, and for the <code>scalingPlot</code> a
reasonable number of points for the scaling range, by
default daily data with 252 business days per year are
assumed.
</p>
</td></tr>
<tr><td><code id="ScalingLawPlot_+3A_doplot">doplot</code></td>
<td>

<p>a logical value. Should a plot be displayed?
</p>
</td></tr>
<tr><td><code id="ScalingLawPlot_+3A_labels">labels</code></td>
<td>

<p>a logical value. Whether or not x- and y-axes should be automatically 
labeled and a default main title should be added to the plot.
By default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ScalingLawPlot_+3A_trace">trace</code></td>
<td>

<p>a logical value. Should the computation be traced?
</p>
</td></tr>
<tr><td><code id="ScalingLawPlot_+3A_...">...</code></td>
<td>

<p>arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Scaling Behavior:</b>
<br /><br />
The function <code>scalingPlot</code> plots the scaling law of financial 
time series under aggregation and returns an estimate for the scaling 
exponent. The scaling behavior is a very striking effect of the 
foreign exchange market and also other markets expressing a regular
structure for the volatility. Considering the average absolute
return over individual data periods one finds a scaling power law
which relates the mean volatility over given time intervals
to the size of these intervals. The power law is in many cases 
valid over several orders of magnitude in time. Its exponent  
usually deviates significantly from a Gaussian random walk model 
which implies 1/2. 
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>Intercept</code></td>
<td>
<p>intercept,</p>
</td></tr>
<tr><td><code>Exponent</code></td>
<td>
<p>the scaling exponent,</p>
</td></tr>
<tr><td><code>InverseExponent</code></td>
<td>
<p>the inverse of the scaling component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Taylor S.J. (1986); 
<em>Modeling Financial Time Series</em>,
John Wiley and Sons, Chichester.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## data - 
   data(LPP2005REC, package = "timeSeries")
   SPI &lt;- LPP2005REC[, "SPI"]
   plot(SPI, type = "l", col = "steelblue", main = "SP500")
   abline(h = 0, col = "grey")

## teffectPlot -
   # Scaling Law Effect:
   scalinglawPlot(SPI)
</code></pre>

<hr>
<h2 id='sgh'>Standardized Generalized Hyperbolic Distribution</h2><span id='topic+sgh'></span><span id='topic+dsgh'></span><span id='topic+psgh'></span><span id='topic+qsgh'></span><span id='topic+rsgh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the standardized generalized hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsgh(x, zeta = 1, rho = 0, lambda = 1, log = FALSE)
psgh(q, zeta = 1, rho = 0, lambda = 1)
qsgh(p, zeta = 1, rho = 0, lambda = 1)
rsgh(n, zeta = 1, rho = 0, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgh_+3A_x">x</code>, <code id="sgh_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sgh_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="sgh_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="sgh_+3A_zeta">zeta</code></td>
<td>
<p>shape parameter, a positive number.</p>
</td></tr>
<tr><td><code id="sgh_+3A_rho">rho</code></td>
<td>
<p>skewness parameter, a number in the range <code class="reqn">(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="sgh_+3A_lambda">lambda</code></td>
<td>

<p>??
</p>
</td></tr>
<tr><td><code id="sgh_+3A_log">log</code></td>
<td>

<p>a logical flag by default <code>FALSE</code>. 
If <code>TRUE</code>, log values are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsgh</code> gives the density,
<code>psgh</code> gives the distribution function,
<code>qsgh</code> gives the quantile function, and
<code>rsgh</code> generates random deviates.
</p>
<p>The generator <code>rsgh</code> is based on the GH algorithm given by Scott (2004).
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## rsgh -
   set.seed(1953)
   r = rsgh(5000, zeta = 1, rho = 0.5, lambda = 1)
   plot(r, type = "l", col = "steelblue",
     main = "gh: zeta=1 rho=0.5 lambda=1")
 
## dsgh - 
   # Plot empirical density and compare with true density:
   hist(r, n = 50, probability = TRUE, border = "white", col = "steelblue",
     ylim = c(0, 0.6))
   x = seq(-5, 5, length = 501)
   lines(x, dsgh(x, zeta = 1, rho = 0.5, lambda = 1))
 
## psgh -  
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, psgh(x, zeta = 1, rho = 0.5, lambda = 1))
   
## qsgh -
   # Compute Quantiles:
   round(qsgh(psgh(seq(-5, 5, 1), zeta = 1, rho = 0.5), zeta = 1, rho = 0.5), 4)
</code></pre>

<hr>
<h2 id='sghFit'>Standardized GH distribution fit</h2><span id='topic+sghFit'></span>

<h3>Description</h3>

<p>Estimates the distributional parameters for a standardized generalized
hyperbolic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sghFit(x, zeta = 1, rho = 0, lambda = 1, include.lambda = TRUE,
    scale = TRUE, doplot = TRUE, span = "auto", trace = TRUE, 
    title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sghFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_zeta">zeta</code>, <code id="sghFit_+3A_rho">rho</code>, <code id="sghFit_+3A_lambda">lambda</code></td>
<td>

<p>shape parameter <code>zeta</code> is positive,
skewness parameter <code>rho</code> is in the range (-1, 1).
and index parameter <code>lambda</code>, by default 1.
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_include.lambda">include.lambda</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the index
parameter <code>lambda</code> included in the parameter estimate?
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series
be scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>        
<tr><td><code id="sghFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
      times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and right endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>        
<tr><td><code id="sghFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>     
<tr><td><code id="sghFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="sghFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
</p>
<p>Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log likelihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## sghFit -
   # Simulate Random Variates:
   set.seed(1953)
   s = rsgh(n = 2000, zeta = 0.7, rho = 0.5, lambda = 0) 

## sghFit -  
   # Fit Parameters:
   sghFit(s, zeta = 1, rho = 0, lambda = 1, include.lambda = TRUE, 
     doplot = TRUE) 
</code></pre>

<hr>
<h2 id='sght'>Standardized generalized hyperbolic Student-t Distribution</h2><span id='topic+sght'></span><span id='topic+dsght'></span><span id='topic+psght'></span><span id='topic+qsght'></span><span id='topic+rsght'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the standardized generalized hyperbolic Student-t
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsght(x, beta = 0.1, delta = 1, mu = 0, nu = 10, log = FALSE)
psght(q, beta = 0.1, delta = 1, mu = 0, nu = 10)
qsght(p, beta = 0.1, delta = 1, mu = 0, nu = 10)
rsght(n, beta = 0.1, delta = 1, mu = 0, nu = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sght_+3A_x">x</code>, <code id="sght_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sght_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="sght_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
<tr><td><code id="sght_+3A_beta">beta</code></td>
<td>

<p>numeric value, <code>beta</code> is the skewness parameter in the range
<code>(0, alpha)</code>.
</p>
</td></tr>
<tr><td><code id="sght_+3A_delta">delta</code></td>
<td>

<p>numeric value, the scale parameter, must be zero or positive.
</p>
</td></tr>
<tr><td><code id="sght_+3A_mu">mu</code></td>
<td>

<p>numeric value, the location parameter, by default 0.
</p>
</td></tr>
<tr><td><code id="sght_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.  Note,
<code>alpha</code> takes the limit of <code>abs(beta)</code>, and
<code>lambda=-nu/2</code>.
</p>
</td></tr>
<tr><td><code id="sght_+3A_log">log</code></td>
<td>

<p>a logical, if TRUE, probabilities <code>p</code> are given as
<code>log(p)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsght</code> gives the density,
<code>psght</code> gives the distribution function,
<code>qsght</code> gives the quantile function, and
<code>rsght</code> generates random deviates.
</p>
<p>These are the parameters in the first parameterization.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rsght -
   set.seed(1953)
   r = rsght(5000, beta = 0.1, delta = 1, mu = 0, nu = 10)
   plot(r, type = "l", col = "steelblue",
     main = "gh: zeta=1 rho=0.5 lambda=1")

## dsght -
   # Plot empirical density and compare with true density:
   hist(r, n = 50, probability = TRUE, border = "white", col = "steelblue")
   x = seq(-5, 5, length = 501)
   lines(x, dsght(x, beta = 0.1, delta = 1, mu = 0, nu = 10))

## psght -
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, psght(x, beta = 0.1, delta = 1, mu = 0, nu = 10))

## qsght -
   # Compute Quantiles:
   round(qsght(psght(seq(-5, 5, 1), beta = 0.1, delta = 1, mu = 0, nu =10),
               beta = 0.1, delta = 1, mu = 0, nu = 10), 4)
</code></pre>

<hr>
<h2 id='snig'>Standardized Normal Inverse Gaussian Distribution</h2><span id='topic+snig'></span><span id='topic+dsnig'></span><span id='topic+psnig'></span><span id='topic+qsnig'></span><span id='topic+rsnig'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the standardized normal inverse Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsnig(x, zeta = 1, rho = 0, log = FALSE)
psnig(q, zeta = 1, rho = 0)
qsnig(p, zeta = 1, rho = 0)
rsnig(n, zeta = 1, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snig_+3A_x">x</code>, <code id="snig_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="snig_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="snig_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="snig_+3A_zeta">zeta</code></td>
<td>

<p>shape parameter <code>zeta</code> is positive.
</p>
</td></tr>
<tr><td><code id="snig_+3A_rho">rho</code></td>
<td>

<p>skewness parameter, a number in the range <code class="reqn">(-1, 1)</code>.
</p>
</td></tr>
<tr><td><code id="snig_+3A_log">log</code></td>
<td>

<p>a logical flag by default <code>FALSE</code>. 
If TRUE, log values are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsnig</code> gives the density,
<code>psnig</code> gives the distribution function,
<code>qsnig</code> gives the quantile function, and
<code>rsnig</code> generates random deviates.
</p>
<p>The random deviates are calculated with the method described by Raible (2000).
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## snig -
   set.seed(1953)
   r = rsnig(5000, zeta = 1, rho = 0.5)
   plot(r, type = "l", col = "steelblue",
     main = "snig: zeta=1 rho=0.5")
 
## snig - 
   # Plot empirical density and compare with true density:
   hist(r, n = 50, probability = TRUE, border = "white", col = "steelblue")
   x = seq(-5, 5, length = 501)
   lines(x, dsnig(x, zeta = 1, rho = 0.5))
 
## snig -  
   # Plot df and compare with true df:
   plot(sort(r), (1:5000/5000), main = "Probability", col = "steelblue")
   lines(x, psnig(x, zeta = 1, rho = 0.5))
   
## snig -
   # Compute Quantiles:
   qsnig(psnig(seq(-5, 5, 1), zeta = 1, rho = 0.5), zeta = 1, rho = 0.5) 
</code></pre>

<hr>
<h2 id='snigFit'>Fit of a Standardized NIG Distribution</h2><span id='topic+snigFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a standardized normal inverse Gaussian
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   
snigFit(x, zeta = 1, rho = 0, scale = TRUE, doplot = TRUE, 
    span = "auto", trace = TRUE, title = NULL, description = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snigFit_+3A_zeta">zeta</code>, <code id="snigFit_+3A_rho">rho</code></td>
<td>

<p>shape parameter <code>zeta</code> is positive,
skewness parameter <code>rho</code> is in the range (-1, 1).
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_doplot">doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_scale">scale</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the time series
be scaled by its standard deviation to achieve a more stable
optimization?
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_span">span</code></td>
<td>

<p>x-coordinates for the plot, by default 100 values 
automatically selected and ranging between the 0.001, 
and 0.999 quantiles. Alternatively, you can specify
the range by an expression like <code>span=seq(min, max,
      times = n)</code>, where, <code>min</code> and <code>max</code> are the 
left and right endpoints of the range, and <code>n</code> gives 
the number of the intermediate points.
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the parameter estimation process be
traced?
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
<tr><td><code id="snigFit_+3A_...">...</code></td>
<td>

<p>parameters to be parsed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object from class <code>"fDISTFIT"</code>.
</p>
<p>Slot <code>fit</code> is a list with the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>

<p>the point at which the maximum value of the log liklihood 
function is obtained.
</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>

<p>the value of the estimated maximum, i.e. the value of the
log liklihood function.
</p>
</td></tr>
<tr><td><code>code</code></td>
<td>

<p>an integer indicating why the optimization process terminated.<br />
1: relative gradient is close to zero, current iterate is probably 
solution; <br />
2: successive iterates within tolerance, current iterate is probably 
solution; <br />
3: last global step failed to locate a point lower than <code>estimate</code>. 
Either <code>estimate</code> is an approximate local minimum of the 
function or <code>steptol</code> is too small; <br />
4: iteration limit exceeded; <br />
5: maximum step size <code>stepmax</code> exceeded five consecutive times. 
Either the function is unbounded below, becomes asymptotic to a 
finite value from above in some direction or <code>stepmax</code> 
is too small.
</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>

<p>the gradient at the estimated maximum.
</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>

<p>number of function calls.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    
## snigFit -
   # Simulate Random Variates:
   set.seed(1953)
   s = rsnig(n = 2000, zeta = 0.7, rho = 0.5) 

## snigFit -  
   # Fit Parameters:
   snigFit(s, zeta = 1, rho = 0, doplot = TRUE) 
</code></pre>

<hr>
<h2 id='ssd'>Spline Smoothed Distribution</h2><span id='topic+ssd'></span><span id='topic+dssd'></span><span id='topic+pssd'></span><span id='topic+qssd'></span><span id='topic+rssd'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation from smoothing spline estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dssd(x, param, log = FALSE)
pssd(q, param)
qssd(p, param)
rssd(n, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssd_+3A_x">x</code>, <code id="ssd_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="ssd_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="ssd_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr> 
<tr><td><code id="ssd_+3A_param">param</code></td>
<td>

<p>an object as returned by the function <code>ssdFit</code>.
</p>
</td></tr>
<tr><td><code id="ssd_+3A_log">log</code></td>
<td>

<p>a logical flag by default <code>FALSE</code>. 
Should labels and a main title drawn to the plot?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dssd</code> gives the density,
<code>pssd</code> gives the distribution function,
<code>qssd</code> gives the quantile function, and
<code>rssd</code> generates random deviates.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz, Chong Gu for the underlying <code>gss</code> package.
</p>


<h3>References</h3>

<p>Gu, C. (2002), 
<em>Smoothing Spline ANOVA Models</em>, 
New York Springer&ndash;Verlag.
</p>
<p>Gu, C. and Wang, J. (2003), 
<em>Penalized likelihood density estimation: 
Direct cross-validation and scalable approximation</em>,
Statistica Sinica, 13, 811&ndash;826. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## ssdFit -
   set.seed(1953)
   r = rnorm(500)
   hist(r, breaks = "FD", probability = TRUE,
     col = "steelblue", border = "white")
 
## ssdFit - 
   param = ssdFit(r)
   
## dssd -  
   u = seq(min(r), max(r), len = 301)
   v = dssd(u, param)
   lines(u, v, col = "orange", lwd = 2)
</code></pre>

<hr>
<h2 id='ssdFit'>Fit density using smoothing splines</h2><span id='topic+ssdFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a density function using smoothing
splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   
ssdFit(x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssdFit_+3A_x">x</code></td>
<td>

<p>a numeric vector. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>ssdFit</code>, an object of class <code>ssden</code>.  The returned
object can be used to evaluate density, probabilities and quantiles.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz, Chong Gu for the underlying <code>gss</code> package.
</p>


<h3>References</h3>

<p>Gu, C. (2002), 
<em>Smoothing Spline ANOVA Models</em>, 
New York Springer&ndash;Verlag.
</p>
<p>Gu, C. and Wang, J. (2003), 
<em>Penalized likelihood density estimation: 
Direct cross-validation and scalable approximation</em>,
Statistica Sinica, 13, 811&ndash;826. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     
## ssdFit -
   set.seed(1953)
   r = rnorm(500)
   hist(r, breaks = "FD", probability = TRUE,
     col = "steelblue", border = "white")
 
## ssdFit - 
   param = ssdFit(r)
   
## dssd -  
   u = seq(min(r), max(r), len = 301)
   v = dssd(u, param)
   lines(u, v, col = "orange", lwd = 2)
</code></pre>

<hr>
<h2 id='StableSlider'>Slider GUI for Stable Distribution</h2><span id='topic+stableSlider'></span>

<h3>Description</h3>

<p>The <code>stableSlider()</code> function provides interactive displays of
density and probabilities of stable distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stableSlider(col= "steelblue", col.med = "gray30")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StableSlider_+3A_col">col</code></td>
<td>
<p>colour for the density and distributions functions.</p>
</td></tr>
<tr><td><code id="StableSlider_+3A_col.med">col.med</code></td>
<td>
<p>colour for the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>stableSlider()</code> function displays densities and
probabilities of the skew stable distribution, for educational
purposes.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>see those in <code><a href="stabledist.html#topic+dstable">dstable</a></code>, in package <span class="pkg">stabledist</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive())
   stableSlider()
</code></pre>

<hr>
<h2 id='symbolTable'>Table of symbols</h2><span id='topic+symbolTable'></span>

<h3>Description</h3>

<p>Displays a table of plot characters and symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
symbolTable(font = par('font'), cex = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolTable_+3A_cex">cex</code></td>
<td>

<p>a numeric value, determines the character size, the default 
size is 0.7.
</p>
</td></tr>  
<tr><td><code id="symbolTable_+3A_font">font</code></td>
<td>

<p>an integer value, the number of the <code>font</code>, by default font 
number 1.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>displays a table with the plot characters and symbols numbered from 
0 to 255 and returns invisibly the name of the font.
</p>


<h3>Note</h3>

<p>Symbols with codes on the range 128-255 are not legitimate in some
locales, most notably UTF-8. Moreover, what happens with non-ASCII
characters in plots is system dependent and depends on the graphics
device, as well. Use of such characters is not recommended for
portable code.
</p>
<p>From version 4031.95 of package <code>fBasics</code>, the characters are
always defined as Latin1. In particular, in UTF8 locales the system
converts them internally to UTF8. Still some symbols are not usable
and non-ASCII symbols are not recommended, as pointed out above. For
details, see the help page of <code>points()</code>, in particular the
discussion of its argument <code>pch</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterTable">characterTable</a></code>,
<code><a href="#topic+colorTable">colorTable</a></code>
</p>
<p><code><a href="grDevices.html#topic+pdf">pdf</a></code> for discussion of encodings for the pdf
device
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
# symbolTable()
</code></pre>

<hr>
<h2 id='TimeSeriesPlots'>Financial time series plots</h2><span id='topic+seriesPlot'></span><span id='topic+returnPlot'></span><span id='topic+cumulatedPlot'></span><span id='topic+drawdownPlot'></span>

<h3>Description</h3>

<p>Produces an index/price, a cumulated return, a return, or a drawdown
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
seriesPlot(x, labels = TRUE, type = "l", col = "steelblue", 
    title = TRUE, grid = TRUE, box = TRUE, rug = TRUE, ...) 
cumulatedPlot(x, index = 100, labels = TRUE, type = "l", col = "steelblue", 
    title = TRUE, grid = TRUE, box = TRUE, rug = TRUE, ...) 
returnPlot(x, labels = TRUE, type = "l", col = "steelblue", 
    title = TRUE, grid = TRUE, box = TRUE, rug = TRUE, ...) 
drawdownPlot(x, labels = TRUE, type = "l", col = "steelblue", 
    title = TRUE, grid = TRUE, box = TRUE, rug = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeSeriesPlots_+3A_box">box</code></td>
<td>

<p>a logical flag, should a box be added to the plot? 
By default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="TimeSeriesPlots_+3A_col">col</code></td>
<td>

<p>the color for the series. In the univariate case use just a 
color name like the default, <code>col="steelblue"</code>, in the
multivariate case we recommend to select the colors from a 
color palette, e.g. <code>col=heat.colors(ncol(x))</code>. 
</p>
</td></tr> 
<tr><td><code id="TimeSeriesPlots_+3A_grid">grid</code></td>
<td>

<p>a logical flag, should a grid be added to the plot? 
By default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="TimeSeriesPlots_+3A_index">index</code></td>
<td>

<p>a numeric value, by default 100. The function cumulates 
column by colum the returns and multiplies the result with 
the index value: <code>index*exp(colCumsums(x))</code>. 
</p>
</td></tr>
<tr><td><code id="TimeSeriesPlots_+3A_labels">labels</code></td>
<td>

<p>a logical flag, should the plot be returned with default labels
and decorated in an automated way? By default <code>TRUE</code>.
</p>
</td></tr>   
<tr><td><code id="TimeSeriesPlots_+3A_rug">rug</code></td>
<td>

<p>a logical flag, by default TRUE. Should a rug representation 
of the data added to the plot?
</p>
</td></tr>
<tr><td><code id="TimeSeriesPlots_+3A_title">title</code></td>
<td>

<p>a logical flag, by default TRUE. Should a default title added 
to the plot?
</p>
</td></tr>        
<tr><td><code id="TimeSeriesPlots_+3A_type">type</code></td>
<td>

<p>what type of plot should be drawn? By default we use a line plot,
<code>type="l"</code>. An alternative plot style which produces nice 
figures is for example <code>type="h"</code>.
</p>
</td></tr>    
<tr><td><code id="TimeSeriesPlots_+3A_x">x</code></td>
<td>

<p>an object of class <code>"timeSeries"</code> or any other object which
can be transformed by the function <code>as.timeSeries</code> into an
object of class <code>timeSeries</code>. The latter case, other then
<code>timeSeries</code> objects, is more or less untested.
</p>
</td></tr>                
<tr><td><code id="TimeSeriesPlots_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of Functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>seriesPlot</code> </td><td style="text-align: left;"> Returns a tailored return series plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cumulatedPlot</code> </td><td style="text-align: left;"> Displays a cumulated series given the returns, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>returnPlot</code> </td><td style="text-align: left;"> Displays returns given the cumulated series, </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>drawdownPlot</code> </td><td style="text-align: left;"> Displays drawdowns given the return series.</td>
</tr>

</table>

<p>The plot functions can be used to plot univariate and multivariate
time series of class <code>timeSeries</code>.
</p>
<p>The graphical parameters <code>type</code> and <code>col</code> can be set by the
values specified through the argument list. In the case of multivariate
time series <code>col</code> can be specified by the values returned by
a color palette.
</p>
<p>Automated titles including main title, x- and y-lables, grid lines,
box style and rug represenatations cann be selected by setting these
arguments to <code>TRUE</code> which is the default. If the title flag
is unset, then the main title, x-, and y-labels are empty strings.
This allows to set user defined labels with the function <code>title</code>
after the plot is drawn.
</p>
<p>Beside <code>type</code>, <code>col</code>, <code>main</code>, <code>xlab</code> and 
<code>ylab</code>, all other <code>par</code> arguments can be passed to the
<code>plot</code> function.
</p>
<p>If the <code>labels</code> flag is unset to <code>FALSE</code>, then no decorations 
will be added tothe  plot, and the plot can be fully decorated by the
user.
</p>


<h3>Value</h3>

<p>displays a time series plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## seriesPlot -
   data(LPP2005REC, package = "timeSeries")
   tS &lt;- as.timeSeries(LPP2005REC)
   seriesPlot(tS)
</code></pre>

<hr>
<h2 id='tr'>Trace of a matrix</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Computes the trace of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tr</code> computes the trace of a square matrix, i.e., the sum of
its diagonal elements.
</p>
<p>If the matrix is not square, <code>tr</code> returns <code>NA</code>.
</p>


<h3>References</h3>

<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(3)
   P
  
## Trace:
   tr(P)                                  
</code></pre>

<hr>
<h2 id='triang'>Upper and lower triangular matrices</h2><span id='topic+triang'></span><span id='topic+Triang'></span>

<h3>Description</h3>

<p>Extracs the upper or lower triangular part from a matrix.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triang(x)
Triang(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triang_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triang</code> and <code>Triang</code> transform a square matrix to a lower
or upper triangular form. The functions just replace the remaining
values with zeroes and work with non-square matrices, as well.
</p>
<p>A triangular matrix is either an upper triangular matrix or lower
triangular matrix. For the first case all matrix elements
<code>a[i,j]</code> of matrix <code>A</code> are zero for <code>i&gt;j</code>, whereas in
the second case we have just the opposite situation. A lower
triangular matrix is sometimes also called left triangular.
</p>
<p>In fact, triangular matrices are so useful that much of computational
linear algebra begins with factoring or decomposing a general matrix
or matrices into triangular form. Some matrix factorization methods
are the Cholesky factorization and the LU-factorization. Even
including the factorization step, enough later operations are
typically avoided to yield an overall time savings.
</p>
<p>Triangular matrices have the following properties: the inverse of a
triangular matrix is a triangular matrix, the product of two
triangular matrices is a triangular matrix, the determinant of a
triangular matrix is the product of the diagonal elements, the
eigenvalues of a triangular matrix are the diagonal elements.
</p>


<h3>Value</h3>

<p>a matrix of the same dimensions as <code>x</code> with the elements above or
below the main diagonal set to zeroes
</p>


<h3>References</h3>

<p>Higham, N.J., (2002);
<em>Accuracy and Stability of Numerical Algorithms</em>, 
2nd ed., SIAM.
</p>
<p>Golub, van Loan, (1996);
<em>Matrix Computations</em>, 
3rd edition. Johns Hopkins University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(3)
   P
   
## Create lower triangle matrix
   L = triang(P)
   L                                
</code></pre>

<hr>
<h2 id='tsHessian'>Two sided approximated Hessian</h2><span id='topic+tsHessian'></span>

<h3>Description</h3>

<p>Computes two sided (TS) approximated Hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsHessian(x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsHessian_+3A_x">x</code></td>
<td>
<p>argument to be passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="tsHessian_+3A_fun">fun</code></td>
<td>
<p>function.</p>
</td></tr>
<tr><td><code id="tsHessian_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A function borrowed from Kevin Sheppard's Matlab garch toolbox as
implemented by Alexios Ghalanos in his <span class="pkg">rgarch</span> package.
</p>

<hr>
<h2 id='tslag'>Lagged or leading vector/matrix</h2><span id='topic+tslag'></span>

<h3>Description</h3>

<p>Creates a lagged or leading vector/matrix of selected order(s).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslag(x, k = 1, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tslag_+3A_k">k</code></td>
<td>

<p>an integer value, the number of positions the new series is to lag
or to lead the input series.
</p>
</td></tr>
<tr><td><code id="tslag_+3A_x">x</code></td>
<td>

<p>a numeric vector or matrix, missing values are allowed.
</p>
</td></tr>
<tr><td><code id="tslag_+3A_trim">trim</code></td>
<td>

<p>a logical flag, if TRUE, the missing values at the beginning ans/or
end of the returned series will be trimmed.  The default value is
FALSE.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pdl">pdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tslag -
</code></pre>

<hr>
<h2 id='varianceTest'>Two sample variance tests</h2><span id='topic+varianceTest'></span><span id='topic+Ftest'></span>

<h3>Description</h3>

<p>Tests if two series differ in their distributional
variance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
varianceTest(x, y, method = c("varf", "bartlett", "fligner"), 
    title = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varianceTest_+3A_x">x</code>, <code id="varianceTest_+3A_y">y</code></td>
<td>

<p>numeric vectors of data values.
</p>
</td></tr>
<tr><td><code id="varianceTest_+3A_method">method</code></td>
<td>

<p>a character string naming which test should be applied.
</p>
</td></tr> 
<tr><td><code id="varianceTest_+3A_title">title</code></td>
<td>

<p>an optional title string, if not specified the inputs data 
name is deparsed.
</p>
</td></tr>
<tr><td><code id="varianceTest_+3A_description">description</code></td>
<td>

<p>optional description string, or a vector of character strings.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>method="varf"</code> can be used to compare variances of two 
normal samples performing an F test. The null hypothesis is that 
the ratio of the variances of the populations from which they were 
drawn is equal to one. 
</p>
<p>The <code>method="bartlett"</code> performs the Bartlett test of the 
null hypothesis that the variances in each of the samples are the 
same. This fact of equal variances across samples is also called 
<em>homogeneity of variances</em>. Note, that Bartlett's test is 
sensitive to departures from normality. That is, if the samples 
come from non-normal distributions, then Bartlett's test may simply 
be testing for non-normality. The Levene test (not yet implemented)
is an alternative to the Bartlett test that is less sensitive to 
departures from normality. 
</p>
<p>The <code>method="fligner"</code> performs the Fligner-Killeen test of 
the null that the variances in each of the two samples are the same. 
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+fHTEST">fHTEST</a></code>
</p>


<h3>Note</h3>

<p>Some of the test implementations are selected from <span class="rlang"><b>R</b></span>'s <code>ctest</code> 
package.  
</p>


<h3>Author(s)</h3>

<p>R-core team for hypothesis tests implemented from <span class="rlang"><b>R</b></span>'s 
package <code>ctest</code>.
</p>


<h3>References</h3>

<p>Conover, W. J. (1971);
<em>Practical nonparametric statistics</em>,
New York: John Wiley &amp; Sons.
</p>
<p>Lehmann E.L. (1986); 
<em>Testing Statistical Hypotheses</em>, 
John Wiley and Sons, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## rnorm - 
   # Generate Series:
   x = rnorm(50)
   y = rnorm(50)
   
## varianceTest -
   varianceTest(x, y, "varf")
   varianceTest(x, y, "bartlett")
   varianceTest(x, y, "fligner")
</code></pre>

<hr>
<h2 id='vec'>Stacking vectors and matrices</h2><span id='topic+vec'></span><span id='topic+vech'></span>

<h3>Description</h3>

<p>Stacks either a lower triangle matrix or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(x)
vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">x</code></td>
<td>

<p>a numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>vec</code> implements the operator that stacks a matrix
as a column vector, to be more precise in a matrix with one column.
<code class="reqn">vec(X) = (X_{11}, X_{21}, ..., X_{N1}, X_{12}, X_{22}, ..., X_{NN})</code>.
</p>
<p>The function <code>vech</code> implements the operator that stacks the lower
triangle of a NxN matrix as an N(N+1)/2x1 vector:
<code class="reqn">vech(X) =(X_{11}, X_{21}, X_{22}, X_{31}, ..., X_{NN})</code>,
to be more precise in a matrix with one row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create Pascal Matrix:
   P = pascal(3)
   
## Stack a matrix
   vec(P) 
   
## Stack the lower triangle
   vech(P)                                        
</code></pre>

<hr>
<h2 id='volatility'>Compute volatility</h2><span id='topic+volatility'></span><span id='topic+volatility.default'></span>

<h3>Description</h3>

<p>Generic function for volatility computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volatility(object, ...)

## Default S3 method:
volatility(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volatility_+3A_object">object</code></td>
<td>

<p>an object from which to extract or compute the volatility.
</p>
</td></tr>
<tr><td><code id="volatility_+3A_...">...</code></td>
<td>

<p>arguments for methods. Ignored by the default method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>volatility</code> is a generic function, whose default method centers
and squares the values in <code>object</code>. Other packages can (and do)
define methods for it.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
