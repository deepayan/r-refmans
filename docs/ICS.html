<!DOCTYPE html><html lang="en"><head><title>Help for package ICS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ICS-package'>
<p>Tools for Exploring Multivariate Data via ICS/ICA</p></a></li>
<li><a href='#coef.ics'><p>To extract the Unmixing Matrix</p></a></li>
<li><a href='#coef.ICS-S3'><p>To extract the Coefficient Matrix of the ICS Transformation</p></a></li>
<li><a href='#components'><p>To extract the Component Scores of the ICS Transformation</p></a></li>
<li><a href='#cov4'><p>Scatter Matrix based on Fourth Moments</p></a></li>
<li><a href='#cov4.wt'><p>Weighted Scatter Matrix based on Fourth Moments</p></a></li>
<li><a href='#covAxis'><p> One step Tyler Shape Matrix</p></a></li>
<li><a href='#covOrigin'><p>Covariance Matrix with Respect to the Origin</p></a></li>
<li><a href='#covW'><p>One-step M-estimator</p></a></li>
<li><a href='#fitted.ics'><p>Fitted Values of an ICS Object</p></a></li>
<li><a href='#fitted.ICS-S3'><p>Fitted Values of the ICS Transformation</p></a></li>
<li><a href='#gen_kurtosis'><p>To extract the Generalized Kurtosis Values of the ICS Transformation</p></a></li>
<li><a href='#ics'><p> Two Scatter Matrices ICS Transformation</p></a></li>
<li><a href='#ICS_scatter'><p>Location and Scatter Estimates for ICS</p></a></li>
<li><a href='#ics-class'><p>Class ICS</p></a></li>
<li><a href='#ICS-S3'><p>Two Scatter Matrices ICS Transformation</p></a></li>
<li><a href='#ics.components'><p> Extracting ICS Components</p></a></li>
<li><a href='#ics2'>
<p>Two Scatter Matrices ICS Transformation Augmented by Two Location Estimates</p></a></li>
<li><a href='#ics2-class'><p>Class ICS2</p></a></li>
<li><a href='#mean3'><p> Location Estimate based on Third Moments</p></a></li>
<li><a href='#Mean3Cov4'>
<p>Location Vector Based on 3rd Moments and Scatter Matrix Based on 4th Moments</p></a></li>
<li><a href='#MeanCov'><p>Mean Vector and Covariance Matrix</p></a></li>
<li><a href='#mvnorm.kur.test'><p>Test of Multivariate Normality Based on Kurtosis</p></a></li>
<li><a href='#mvnorm.skew.test'><p> Test of Multivariate Normality Based on Skewness</p></a></li>
<li><a href='#plot.ics'><p>Scatterplot for a ICS Object</p></a></li>
<li><a href='#plot.ICS-S3'><p>Scatterplot Matrix of Component Scores from the ICS Transformation</p></a></li>
<li><a href='#print.ics'><p>Basic information of ICS Object</p></a></li>
<li><a href='#print.ICS-S3'><p>Basic information of ICS Object</p></a></li>
<li><a href='#print.ics2'><p>Basic information of ICS2 Object</p></a></li>
<li><a href='#scovq'>
<p>Supervised scatter matrix based on quantiles</p></a></li>
<li><a href='#screeplot.ics'><p>Screeplot for an ICS Object</p></a></li>
<li><a href='#screeplot.ICS-S3'><p>Screeplot for an <code>ICS</code> Object</p></a></li>
<li><a href='#summary.ics'><p>To summarize an ICS object</p></a></li>
<li><a href='#summary.ICS-S3'><p>To summarize an <code>ICS</code> object</p></a></li>
<li><a href='#summary.ics2'><p>To summarize an ICS2 object</p></a></li>
<li><a href='#tM'><p> Joint M-estimation of Location and Scatter for a Multivariate t-distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Exploring Multivariate Data via ICS/ICA</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andreas Alfons <a href="https://orcid.org/0000-0002-2513-3788"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aurore Archimbaud <a href="https://orcid.org/0000-0002-6511-9091"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hannu Oja <a href="https://orcid.org/0000-0002-4945-5976"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Anne Ruiz-Gazen <a href="https://orcid.org/0000-0001-8970-8061"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David E. Tyler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0), methods, mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>survey, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pixmap, robustbase, MASS, ICSNP, testthat (&ge; 3.0.0),
ICSOutlier</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Tyler, Critchley, Duembgen and Oja's (JRSS B, 2009,
            &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2009.00706.x">doi:10.1111/j.1467-9868.2009.00706.x</a>&gt;) and Oja, Sirkia and Eriksson's
            (AJS, 2006, &lt;https://www.ajs.or.at/index.php/ajs/article/view/vol35,%20no2%263%20-%207&gt;) method of two different
            scatter matrices to obtain an invariant coordinate system or independent
            components, depending on the underlying assumptions. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-18 14:43:10 UTC; nordklau</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ICS-package'>
Tools for Exploring Multivariate Data via ICS/ICA
</h2><span id='topic+ICS-package'></span>

<h3>Description</h3>

<p>Implementation of Tyler, Critchley, Duembgen and Oja's (JRSS B, 2009,
            &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;) and Oja, Sirkia and Eriksson's
            (AJS, 2006, &lt;https://www.ajs.or.at/index.php/ajs/article/view/vol35,%20no2%263%20-%207&gt;) method of two different
            scatter matrices to obtain an invariant coordinate system or independent
            components, depending on the underlying assumptions. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ICS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Tools for Exploring Multivariate Data via ICS/ICA</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-03-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@gmail.com",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Andreas", "Alfons", 
             email = "alfons@ese.eur.nl", 
             role = "aut",
             comment = c(ORCID = "0000-0002-2513-3788")),
      person("Aurore", "Archimbaud", 
             email = "aurore.archimbaud@live.fr", 
             role = "aut",
             comment = c(ORCID = "0000-0002-6511-9091")),
      person("Hannu", "Oja", 
             email = "", 
             role = c("aut"),
             comment = c(ORCID = "0000-0002-4945-5976")),
      person("Anne", "Ruiz-Gazen", 
             email = "anne.ruiz-gazen@tse-fr.eu",
             role = "aut", 
             comment = c(ORCID = "0000-0001-8970-8061")),
      person("David E.", "Tyler", 
             email = "", 
             role = c("aut")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> 
    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Andreas Alfons [aut] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), 
    Aurore Archimbaud [aut] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;),
    David E. Tyler [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.5.0), methods, mvtnorm</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> survey, graphics</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> pixmap,
robustbase,
MASS,
ICSNP,
testthat (&gt;= 3.0.0),
ICSOutlier</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementation of Tyler, Critchley, Duembgen and Oja's (JRSS B, 2009,
            &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;) and Oja, Sirkia and Eriksson's
            (AJS, 2006, &lt;https://www.ajs.or.at/index.php/ajs/article/view/vol35,%20no2%263%20-%207&gt;) method of two different
            scatter matrices to obtain an invariant coordinate system or independent
            components, depending on the underlying assumptions. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Config/testthat/edition: </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Some multivariate tests and estimates are not affine equivariant by nature. A possible remedy for the lack of that property is to transform the data points to an invariant coordinate system,
construct tests and estimates from the transformed data, and if needed, retransform the estimates back. The use of two different
scatter matrices to obtain invariant coordinates is implemeted in this package by the function <code>ICS</code>. For an invariant coordinate selection no
assumptions are made about the data or the scatter matrices and it can be seen as a data transformation method. If the data come, however, from a so called independent component model
the <code>ICS</code> function can recover the independent components and estimate the mixing matrix under general assumptions.
Besides, the function <code>ICS</code> provides these package tools to work with objects of this class, and some
scatter matrices which can be used in the <code>ICS</code> function. Furthermore, there are also two tests for multinormality.
Note that starting with version 1.4-0 the functions <code>ics</code> and <code>ics2</code> are not recommended anymore and everything can be done in a more efficient way using the function <code>ICS</code> which combines
the functionality of the original two functions and also provides an improved algorithm for certain scatter combinations. Furthermore, does <code>ICS</code> return
an S3 object and not anymore S4 objects as <code>ics</code> and <code>ics2</code> did. In the long run functions <code>ics</code> and <code>ics2</code> will be removed from the package.
</p>

<p>Index of help topics:
</p>
<pre>
ICS-S3                  Two Scatter Matrices ICS Transformation
ICS-package             Tools for Exploring Multivariate Data via
                        ICS/ICA
ICS_scatter             Location and Scatter Estimates for ICS
Mean3Cov4               Location Vector Based on 3rd Moments and
                        Scatter Matrix Based on 4th Moments
MeanCov                 Mean Vector and Covariance Matrix
coef.ICS-S3             To extract the Coefficient Matrix of the ICS
                        Transformation
coef.ics                To extract the Unmixing Matrix
components              To extract the Component Scores of the ICS
                        Transformation
cov4                    Scatter Matrix based on Fourth Moments
cov4.wt                 Weighted Scatter Matrix based on Fourth Moments
covAxis                 One step Tyler Shape Matrix
covOrigin               Covariance Matrix with Respect to the Origin
covW                    One-step M-estimator
fitted.ICS-S3           Fitted Values of the ICS Transformation
fitted.ics              Fitted Values of an ICS Object
gen_kurtosis            To extract the Generalized Kurtosis Values of
                        the ICS Transformation
ics                     Two Scatter Matrices ICS Transformation
ics-class               Class ICS
ics.components          Extracting ICS Components
ics2                    Two Scatter Matrices ICS Transformation
                        Augmented by Two Location Estimates
ics2-class              Class ICS2
mean3                   Location Estimate based on Third Moments
mvnorm.kur.test         Test of Multivariate Normality Based on
                        Kurtosis
mvnorm.skew.test        Test of Multivariate Normality Based on
                        Skewness
plot.ICS-S3             Scatterplot Matrix of Component Scores from the
                        ICS Transformation
plot.ics                Scatterplot for a ICS Object
print.ICS-S3            Basic information of ICS Object
print.ics               Basic information of ICS Object
print.ics2              Basic information of ICS2 Object
scovq                   Supervised scatter matrix based on quantiles
screeplot.ICS-S3        Screeplot for an 'ICS' Object
screeplot.ics           Screeplot for an ICS Object
summary.ICS-S3          To summarize an 'ICS' object
summary.ics             To summarize an ICS object
summary.ics2            To summarize an ICS2 object
tM                      Joint M-estimation of Location and Scatter for
                        a Multivariate t-distribution
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>ICS</code> </td><td style="text-align: left;"> Tools for Exploring Multivariate Data: The Package ICS (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>


<p>    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Andreas Alfons [aut] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), 
    Aurore Archimbaud [aut] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;),
    David E. Tyler [aut]
</p>
<p>Maintainer: Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Tyler, D.E., Critchley, F., Dümbgen, L. and Oja, H. (2009), Invariant co-ordinate selecetion, <em>Journal of the Royal Statistical Society</em>,Series B, <b>71</b>,  549&ndash;592. &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;.</cite>
</p>
<p><cite>Oja, H., Sirkiä, S. and Eriksson, J. (2006), Scatter matrices and independent component analysis, <em>Austrian Journal of Statistics</em>, <b>35</b>,  175&ndash;189.</cite>
</p>
<p><cite>Nordhausen, K., Oja, H. and Tyler, D.E. (2008), Tools for exploring multivariate data: The package <span class="pkg">ICS</span>, <em>Journal of Statistical Software</em>, <b>28</b>, 1&ndash;31. &lt;doi:10.18637/jss.v028.i06&gt;.</cite>
</p>
<p><cite>Archimbaud, A., Drmac, Z., Nordhausen, K., Radojicic, U. and Ruiz-Gazen, A. (2023), Numerical considerations and a new implementation for ICS, <em>SIAM Journal on Mathematics of Data Science</em>, <b>5</b>, 97&ndash;121.  &lt;doi:10.1137/22M1498759&gt;.</cite>
</p>

<hr>
<h2 id='coef.ics'>To extract the Unmixing Matrix</h2><span id='topic+coef.ics'></span><span id='topic+coef-method'></span><span id='topic+coef+2Cics-method'></span>

<h3>Description</h3>

<p>Extracts the unmixing matrix of a class <code>ics</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.ics_+3A_object">object</code></td>
<td>
<p>object of class <code>ics</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unmixing matrix of a class <code>ics</code> object.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>

<hr>
<h2 id='coef.ICS-S3'>To extract the Coefficient Matrix of the ICS Transformation</h2><span id='topic+coef.ICS-S3'></span><span id='topic+coef.ICS'></span>

<h3>Description</h3>

<p>Extracts the coefficient matrix of a linear transformation to an invariant
coordinate system. Each row of the matrix contains the coefficients of the
transformation to the corresponding component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
coef(object, select = NULL, drop = FALSE, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.ICS-S3_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> containing
results from an ICS transformation.</p>
</td></tr>
<tr><td><code id="coef.ICS-S3_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying for which
components to extract the coefficients, or <code>NULL</code> to extract the
coefficients for all components.</p>
</td></tr>
<tr><td><code id="coef.ICS-S3_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to return a vector rather than a
matrix in case coefficients are extracted for a single component (default
to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="coef.ICS-S3_+3A_index">index</code></td>
<td>
<p>an integer vector specifying for which components to extract
the coefficients, or <code>NULL</code> to extract coefficients for all components.
Note that <code>index</code> is deprecated and may be removed in the future, use
<code>select</code> instead.</p>
</td></tr>
<tr><td><code id="coef.ICS-S3_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix or vector containing the coefficients for the
requested components.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>, <code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+fitted.ICS">fitted</a>()</code>, and <code><a href="#topic+plot.ICS">plot</a>()</code>
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
coef(out)
coef(out, select = c(1,4))
coef(out, select = 1, drop = FALSE)

</code></pre>

<hr>
<h2 id='components'>To extract the Component Scores of the ICS Transformation</h2><span id='topic+components'></span><span id='topic+components.ICS'></span>

<h3>Description</h3>

<p>Extracts the components scores of an invariant coordinate system obtained
via an ICS transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components(x, ...)

## S3 method for class 'ICS'
components(x, select = NULL, drop = FALSE, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> containing results
from an ICS transformation.</p>
</td></tr>
<tr><td><code id="components_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="components_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying which
components to extract, or <code>NULL</code> to extract all components.</p>
</td></tr>
<tr><td><code id="components_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to return a vector rather than a
matrix in case a single component is extracted (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="components_+3A_index">index</code></td>
<td>
<p>an integer vector specifying which components to extract, or
<code>NULL</code> to extract all components.  Note that <code>index</code> is deprecated
and may be removed in the future, use <code>select</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix or vector containing the requested components.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>, <code><a href="#topic+coef.ICS">coef</a>()</code>,
<code><a href="#topic+fitted.ICS">fitted</a>()</code>, and <code><a href="#topic+plot.ICS">plot</a>()</code>
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
components(out)
components(out, select = c(1,4))
components(out, select = 1, drop = FALSE)

</code></pre>

<hr>
<h2 id='cov4'>Scatter Matrix based on Fourth Moments</h2><span id='topic+cov4'></span>

<h3>Description</h3>

<p>Estimates the scatter matrix based on the 4th moments of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov4(X, location = "Mean", na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov4_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe, missing values are not allowed. </p>
</td></tr>
<tr><td><code id="cov4_+3A_location">location</code></td>
<td>
<p>can be either <code>Mean</code>, <code>Origin</code> or numeric. If numeric
the matrix is computed wrt to the given location.</p>
</td></tr>
<tr><td><code id="cov4_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If location is <code>Mean</code> the scatter matrix of 4th moments is computed wrt to the sample mean.
For location = <code>Origin</code> it is the scatter matrix of 4th moments wrt to the origin.
The scatter matrix is standardized in such a way to be consistent for the regular covariance matrix at the multinormal model.
It is given for <code class="reqn">n \times p</code> matrix X by
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{p+2} ave_{i}\{[(x_{i}-\bar{x})S^{-1}(x_{i}-\bar{x})'](x_{i}-\bar{x})'(x_{i}-\bar{x})\},</code>
</p>

<p>where <code class="reqn">\bar{x}</code> is the mean vector and <code class="reqn">S</code> the regular covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix containing the estimated fourth moments scatter.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p>Cardoso, J.F. (1989), Source separation using higher order moments, in <em>Proc. IEEE Conf. on Acoustics, Speech and Signal Processing (ICASSP'89)</em>, 2109&ndash;2112. &lt;doi:10.1109/ICASSP.1989.266878&gt;.
</p>
<p>Oja, H., Sirki?, S. and Eriksson, J. (2006), Scatter matrices and independent component analysis, <em>Austrian Journal of Statistics</em>, <b>35</b>,  175&ndash;189.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
cov4(X)
cov4(X, location="Origin")
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='cov4.wt'>Weighted Scatter Matrix based on Fourth Moments</h2><span id='topic+cov4.wt'></span>

<h3>Description</h3>

<p>Estimates the weighted scatter matrix based on the 4th moments of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov4.wt(x, wt = rep(1/nrow(x), nrow(x)), location = TRUE,
        method = "ML", na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov4.wt_+3A_x">x</code></td>
<td>
<p>numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="cov4.wt_+3A_wt">wt</code></td>
<td>
<p>numeric vector of non-negative weights. At least some weights must be larger than zero.</p>
</td></tr>
<tr><td><code id="cov4.wt_+3A_location">location</code></td>
<td>
<p><code>TRUE</code> if the weighted location vector should be computed. <code>FALSE</code> when taken wrt to the origin.  If numeric
the matrix is computed wrt to the given location.</p>
</td></tr>
<tr><td><code id="cov4.wt_+3A_method">method</code></td>
<td>
<p>Either <code>ML</code> or <code>unbiased</code>. Will be passed on to <code><a href="stats.html#topic+cov.wt">cov.wt</a></code> when the Mahalanobis distance is computed.</p>
</td></tr>
<tr><td><code id="cov4.wt_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location = TRUE</code>, then the scatter matrix is given for a <code class="reqn">n \times p</code> data matrix X by
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{p+2} ave_{i}\{w_i[(x_{i}-\bar{x}_w)S_w^{-1}(x_{i}-\bar{x}_w)'](x_{i}-\bar{x}_w)'(x_{i}-\bar{x}_w)\},</code>
</p>

<p>where <code class="reqn">w_i</code> are the weights standardized such that <code class="reqn">\sum{w_i}=1</code>,
<code class="reqn">\bar{x}_w</code> is the weighted mean vector and <code class="reqn">S_w</code> the weighted covariance matrix.
For details about the weighted mean vector and weighted covariance matrix see <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>.
</p>


<h3>Value</h3>

<p>A matrix containing the estimated weighted fourth moments scatter.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov4">cov4</a></code>, <code><a href="stats.html#topic+cov.wt">cov.wt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix.1 &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X.1 &lt;- rmvnorm(100, c(0,0,0), cov.matrix.1)
cov.matrix.2 &lt;- diag(1,3)
X.2 &lt;- rmvnorm(50, c(1,1,1), cov.matrix.2)
X &lt;- rbind(X.1, X.2)

cov4.wt(X, rep(c(0,1), c(100,50)))
cov4.wt(X, rep(c(1,0), c(100,50)))
</code></pre>

<hr>
<h2 id='covAxis'> One step Tyler Shape Matrix</h2><span id='topic+covAxis'></span>

<h3>Description</h3>

<p>This matrix can be used to get the principal axes from <code><a href="#topic+ics">ics</a></code>,
which is then known as principal axis analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covAxis(X, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covAxis_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe. </p>
</td></tr>
<tr><td><code id="covAxis_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>covAxis</code> matrix <code class="reqn">V</code> is a given for a <code class="reqn">n \times p</code> data matrix X as
</p>
<p style="text-align: center;"><code class="reqn">p \ ave_{i}\{[(x_{i}-\bar{x})S^{-1}(x_{i}-\bar{x})']^{-1}(x_{i}-\bar{x})'(x_{i}-\bar{x})\},</code>
</p>

<p>where <code class="reqn">\bar{x}</code> is the mean vector and <code class="reqn">S</code> the regular covariance matrix.
</p>
<p><code>covAxis</code> can be used to perform a Prinzipal Axis Analysis (Critchley et al. 2006) using the function <code><a href="#topic+ics">ics</a></code>.
In that case, for a centered data matrix X, <code>covAxis</code> can be used as S2 in <code><a href="#topic+ics">ics</a></code>, where S1 should be in that
case the regular covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix containing the estimated one step Tyler shape matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Critchley , F., Pires, A. and Amado, C. (2006),  Principal axis analysis, <em>Technical Report</em>, <b>06/14</b>, The Open University Milton Keynes.</cite>
</p>
<p><cite>Tyler, D.E., Critchley, F., D?mbgen, L. and Oja, H. (2009), Invariant co-ordinate selecetion, <em>Journal of the Royal Statistical Society</em>,Series B, <b>71</b>,  549&ndash;592. &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;.</cite>   </p>


<h3>See Also</h3>

<p><code><a href="#topic+ics">ics</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.centered &lt;- sweep(iris[,1:4], 2, colMeans(iris[,1:4]), "-")
iris.paa &lt;- ics(iris.centered, cov, covAxis, stdKurt = FALSE)
summary(iris.paa)
plot(iris.paa, col=as.numeric(iris[,5]))
mean(iris.paa@gKurt)
emp.align &lt;- iris.paa@gKurt
emp.align

screeplot(iris.paa)
abline(h = 1)



</code></pre>

<hr>
<h2 id='covOrigin'>Covariance Matrix with Respect to the Origin</h2><span id='topic+covOrigin'></span>

<h3>Description</h3>

<p>Estimates the covariance matrix with respect to the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covOrigin(X, location = NULL, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covOrigin_+3A_x">X</code></td>
<td>
<p> a numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="covOrigin_+3A_location">location</code></td>
<td>
<p> optional location value which serves as the center instead of the origin.</p>
</td></tr>
<tr><td><code id="covOrigin_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix <code class="reqn">S_{0}</code> with respect to origin is given for a matrix X with n observations by
</p>
<p style="text-align: center;"><code class="reqn">S_{0}= \frac{1}{n}X'X.</code>
</p>



<h3>Value</h3>

<p>A matrix containing the estimated covariance matrix with respect to the origin.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cov">cov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100,c(0,0,0),cov.matrix)
covOrigin(X)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='covW'>One-step M-estimator</h2><span id='topic+covW'></span>

<h3>Description</h3>

<p>Estimates the scatter matrix based on one-step M-estimator using mean and covariance matrix as starting point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covW(X, na.action = na.fail, alpha = 1, cf = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covW_+3A_x">X</code></td>
<td>
<p>numeric <code class="reqn">n \times p</code> data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="covW_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain 'NA's. Default is to fail.</p>
</td></tr>
<tr><td><code id="covW_+3A_alpha">alpha</code></td>
<td>
<p>parameter of the one-step M-estimator. By default equals to 1.</p>
</td></tr>
<tr><td><code id="covW_+3A_cf">cf</code></td>
<td>
<p>consistency factor of the one-step M-estimator. By default equals to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is given for <code class="reqn">n \times p</code> matrix <code class="reqn">X</code> by
</p>
<p style="text-align: center;"><code class="reqn">COV_{w}(X)=\frac{1}{n} {cf} \sum_{i=1}^n w(D^2(x_i))
(x_i - \bar{ x})^\top(x_i - \bar{ x}),</code>
</p>

<p>where <code class="reqn">\bar{x}</code> is the mean vector, <code class="reqn">D^2(x_i)</code> is the squared
Mahalanobis distance, <code class="reqn">w(d)=d^\alpha</code> is a
non-negative and continuous weight function and <code class="reqn">{cf}</code> is a consistency factor.
Note that the consistency factor, which makes the estimator consistent at the multivariate normal distribution, is in most case unknown and therefore the default is to use simply <code>cf = 1</code>.
</p>

<ul>
<li><p> If <code class="reqn">w(d)=1</code>, we get the covariance matrix <code><a href="stats.html#topic+cov">cov()</a></code> (up to the factor
<code class="reqn">1/(n-1)</code> instead of <code class="reqn">1/n</code>).
</p>
</li>
<li><p> If <code class="reqn">\alpha=-1</code>, we get the <code><a href="#topic+covAxis">covAxis()</a></code>.
</p>
</li>
<li><p> If <code class="reqn">\alpha=1</code>, we get the <code><a href="#topic+cov4">cov4()</a></code> with <code class="reqn">{cf} = \frac{1}{p+2}</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix containing the one-step M-scatter.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Drmac, Z., Nordhausen, K., Radojicic, U. and
Ruiz-Gazen, A. (2023). SIAM Journal on Mathematics of Data Science (SIMODS),
Vol.5(1):97–121. <a href="https://doi.org/10.1137/22M1498759">doi:10.1137/22M1498759</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov()</a></code>, <code><a href="#topic+cov4">cov4()</a></code>, <code><a href="#topic+covAxis">covAxis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- iris[,1:4]

# Equivalence with covAxis
covW(X, alpha = -1, cf = ncol(X))
covAxis(X)

# Equivalence with cov4
covW(X, alpha = 1, cf = 1/(ncol(X)+2))
cov4(X)

# covW with alpha = 0.5
covW(X, alpha = 0.5)

</code></pre>

<hr>
<h2 id='fitted.ics'>Fitted Values of an ICS Object</h2><span id='topic+fitted.ics'></span><span id='topic+fitted-method'></span><span id='topic+fitted+2Cics-method'></span>

<h3>Description</h3>

<p>Computes the fitted values of an <code>ics</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics'
fitted(object,index=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.ics_+3A_object">object</code></td>
<td>
<p> object of class <code>ics</code>.</p>
</td></tr>
<tr><td><code id="fitted.ics_+3A_index">index</code></td>
<td>
<p>A vector which defines which components should be used to compute the fitted values. The default NULL uses all components. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the fitted values.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    set.seed(123456)
    X1 &lt;- rmvnorm(250, rep(0,8), diag(c(rep(1,6),0.04,0.04)))
    X2 &lt;- rmvnorm(50, c(rep(0,6),2,0), diag(c(rep(1,6),0.04,0.04)))
    X3 &lt;- rmvnorm(200, c(rep(0,7),2), diag(c(rep(1,6),0.04,0.04)))

    X.comps &lt;- rbind(X1,X2,X3)
    A &lt;- matrix(rnorm(64),nrow=8)
    X &lt;- X.comps %*% t(A)

    ics.X.1 &lt;- ics(X)
    fitted(ics.X.1)
    fitted(ics.X.1,index=c(1,2,3,6,7,8))

    rm(.Random.seed)
</code></pre>

<hr>
<h2 id='fitted.ICS-S3'>Fitted Values of the ICS Transformation</h2><span id='topic+fitted.ICS-S3'></span><span id='topic+fitted.ICS'></span>

<h3>Description</h3>

<p>Computes the fitted values based on an invariant coordinate system obtained
via an ICS transformation.  When using all components, computing the fitted
values constitutes a backtransformation to the observed data.  When using
fewer components, the fitted values can often be viewed as reconstructions
of the observed data with noise removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
fitted(object, select = NULL, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.ICS-S3_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> containing
results from an ICS transformation.</p>
</td></tr>
<tr><td><code id="fitted.ICS-S3_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying which
components to use for computing the fitted values, or <code>NULL</code> to compute
the fitted values from all components.</p>
</td></tr>
<tr><td><code id="fitted.ICS-S3_+3A_index">index</code></td>
<td>
<p>an integer vector specifying which components to use for
computing the fitted values, or <code>NULL</code> to compute the fitted values
from all components.  Note that <code>index</code> is deprecated and may be
removed in the future, use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="fitted.ICS-S3_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the fitted values.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>, <code><a href="#topic+coef.ICS">coef</a>()</code>,
<code><a href="#topic+components">components</a>()</code>, and <code><a href="#topic+plot.ICS">plot</a>()</code>
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
fitted(out)
fitted(out, select = 4)

</code></pre>

<hr>
<h2 id='gen_kurtosis'>To extract the Generalized Kurtosis Values of the ICS Transformation</h2><span id='topic+gen_kurtosis'></span><span id='topic+gen_kurtosis.ICS'></span>

<h3>Description</h3>

<p>Extracts the generalized kurtosis values of the components obtained via an
ICS transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_kurtosis(object, ...)

## S3 method for class 'ICS'
gen_kurtosis(object, select = NULL, scale = FALSE, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_kurtosis_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> containing
results from an ICS transformation.</p>
</td></tr>
<tr><td><code id="gen_kurtosis_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="gen_kurtosis_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying for which
components to extract the generalized kurtosis values, or <code>NULL</code> to
extract the generalized kurtosis values of all components.</p>
</td></tr>
<tr><td><code id="gen_kurtosis_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether to scale the generalized kurtosis
values to have product 1 (default to <code>FALSE</code>). See &lsquo;Details&rsquo;
for more information.</p>
</td></tr>
<tr><td><code id="gen_kurtosis_+3A_index">index</code></td>
<td>
<p>an integer vector specifying for which components to extract
the generalized kurtosis values, or <code>NULL</code> to extract the generalized
kurtosis values of all components.  Note that <code>index</code> is deprecated
and may be removed in the future, use <code>select</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>scale</code> is useful when ICS is performed with shape
matrices rather than true scatter matrices. Let <code class="reqn">S_{1}</code> and
<code class="reqn">S_{2}</code> denote the scatter or shape matrices used in ICS.
</p>
<p>If both <code class="reqn">S_{1}</code> and <code class="reqn">S_{2}</code> are true scatter matrices, their
order in principal does not matter. Changing their order will just reverse
the order of the components and invert the corresponding generalized
kurtosis values.
</p>
<p>The same does not hold when at least one of them is a shape matrix rather
than a true scatter matrix. In that case, changing their order will also
reverse the order of the components, but the ratio of the generalized
kurtosis values is no longer 1 but only a constant. This is due to the fact
that when shape matrices are used, the generalized kurtosis values are only
relative ones. It is then useful to scale the generalized kurtosis values
such that their product is 1.
</p>


<h3>Value</h3>

<p>A numeric vector containing the generalized kurtosis values of the
requested components.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+coef.ICS">coef</a>()</code>, <code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+fitted.ICS">fitted</a>()</code>, and <code><a href="#topic+plot.ICS">plot</a>()</code>
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
gen_kurtosis(out)
gen_kurtosis(out, scale = TRUE)
gen_kurtosis(out, select = c(1,4))

</code></pre>

<hr>
<h2 id='ics'> Two Scatter Matrices ICS Transformation </h2><span id='topic+ics'></span>

<h3>Description</h3>

<p>Implements the two scatter matrices transformation to obtain an invariant coordinate sytem or independent
components, depending on the underlying assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics(X, S1 = cov, S2 = cov4, S1args = list(), S2args = list(),
    stdB = "Z", stdKurt = TRUE, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics_+3A_x">X</code></td>
<td>
<p> numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="ics_+3A_s1">S1</code></td>
<td>
<p> name of the first scatter matrix function or a scatter matrix. Default is the regular covariance matrix.</p>
</td></tr>
<tr><td><code id="ics_+3A_s2">S2</code></td>
<td>
<p> name of the second scatter matrix or a scatter matrix. Default is the covariance matrix based on forth order moments.
Note that the type of S2 must be the same as S1.</p>
</td></tr>
<tr><td><code id="ics_+3A_s1args">S1args</code></td>
<td>
<p> list with optional additional arguments for S1. Only considered if S1 is a function.</p>
</td></tr>
<tr><td><code id="ics_+3A_s2args">S2args</code></td>
<td>
<p> list with optional additional arguments for S2. Only considered if S2 is a function.</p>
</td></tr>
<tr><td><code id="ics_+3A_stdb">stdB</code></td>
<td>
<p> either &quot;B&quot; or &quot;Z&quot;. Defines the way to standardize the matrix B. Default is &quot;Z&quot;. Details are given below.</p>
</td></tr>
<tr><td><code id="ics_+3A_stdkurt">stdKurt</code></td>
<td>
<p> Logical, either &quot;TRUE&quot; or &quot;FALSE&quot;. Specifies weather the product of the kurtosis values is 1 or not.</p>
</td></tr>
<tr><td><code id="ics_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seeing this function as a tool for data transformation the result is an invariant coordinate selection which can be used for test and estimation. And
if needed the results can be easily retransformed to the original scale. It is possible to use it also for dimension reduction, in order to find outliers or clusters in the data.
The function can, also be used in a modelling framework. In this case it is assumed that the data were created by mixing independent components which
have different kurtosis values. If the two scatter matrices used have the so-called independence property the function can recover the independent components
by estimating the unmixing matrix.
</p>
<p>By default S1 is the regular covariance matrix <code><a href="stats.html#topic+cov">cov</a></code> and S2 the matrix of fourth moments <code><a href="#topic+cov4">cov4</a></code>. However those can be replaced with any other
scatter matrix the user prefers. The package <span class="pkg">ICS</span> offers for example also <code><a href="#topic+cov4.wt">cov4.wt</a></code>, <code><a href="#topic+covAxis">covAxis</a></code>, <code><a href="#topic+covOrigin">covOrigin</a></code>, <code><a href="#topic+covW">covW</a></code> or <code><a href="#topic+tM">tM</a></code> and the <span class="pkg">ICSNP</span> offers further scatters as <code><a href="ICSNP.html#topic+duembgen.shape">duembgen.shape</a></code>, <code><a href="ICSNP.html#topic+tyler.shape">tyler.shape</a></code>, <code><a href="ICSNP.html#topic+HR.Mest">HR.Mest</a></code> or <code><a href="ICSNP.html#topic+HP1.shape">HP1.shape</a></code>.
But of course also scatters from any other package can be used.
</p>
<p>Note that when function names are submitted, the function should return only a scatter matrix. If the function returns more, the scatter should be computed in advance or
a wrapper written that yields the required output. For example <code><a href="#topic+tM">tM</a></code> returns a list with four elements where the scatter estimate is called V. A simple wrapper would then be
<code>my.tm &lt;- function(x, ...) tM(x, ...)$V</code>.
</p>
<p>For a given choice of S1 and S2, the general idea of the <code>ics</code> function is to find the unmixing matrix B and the invariant coordinates (independent coordinates)
Z in such a way, that:
</p>

<dl>
<dt>(i)</dt><dd><p>The elements of Z are standardized with respect to S1 (S1(Z)=I).</p>
</dd>
<dt>(ii)</dt><dd><p>The elements of Z are uncorrelated with respect to S2. (S2(Z)=D, where D is a diagonal matrix).</p>
</dd>
<dt>(iii)</dt><dd><p>The elements of Z are ordered according to their generalized kurtosis.</p>
</dd>
</dl>

<p>Given those criteria, B is unique up to sign changes of its rows. The function provides two options to decide the exact form of B.
</p>

<dl>
<dt>(i)</dt><dd><p>Method 'Z' standardizes B such, that all components are right skewed. The criterion used is the sign of each componentwise difference of mean vector and
transformation retransformation median. This standardization is prefered in an invariant coordinate framework.</p>
</dd>
<dt>(ii)</dt><dd><p>Method 'B' standardizes B independent of Z such that the maximum element per row is positive and each row has norm 1. Usual way in an independent
component analysis framework.</p>
</dd>
</dl>

<p>In principal, if S1 and S2 are true scatter matrices the order does not matter. It will just reverse and invert the kurtosis value vector.
This is however not true when one or both are shape matrices (and not both of them are scatter matrices). In this case the order of the kurtosis values is also reversed,
the ratio however then is not 1 but only constant. This is due to the fact that when shape matrices are used, the kurtosis values are only relative ones.
Therefore by the default the kurtosis values are standardized such that their product is 1. If no standardization is wanted, the 'stdKurt' argument should be used.
</p>


<h3>Value</h3>

<p>an object of class <code>ics</code>.
</p>


<h3>Note</h3>

<p>Function <code>ics()</code> reached the end of its lifecycle, please use <code><a href="#topic+ICS-S3">ICS</a>()</code> instead. In future versions, <code>ics()</code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Tyler, D.E., Critchley, F., D?mbgen, L. and Oja, H. (2009), Invariant co-ordinate selecetion, <em>Journal of the Royal Statistical Society</em>,Series B, <b>71</b>,  549&ndash;592. &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;.</cite>
</p>
<p><cite>Oja, H., Sirki?, S. and Eriksson, J. (2006), Scatter matrices and independent component analysis, <em>Austrian Journal of Statistics</em>, <b>35</b>,  175&ndash;189.</cite>
</p>
<p><cite>Nordhausen, K., Oja, H. and Tyler, D.E. (2008), Tools for exploring multivariate data: The package ICS, <em>Journal of Statistical Software</em>, <b>28</b>, 1&ndash;31. &lt;doi:10.18637/jss.v028.i06&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS-package">ICS-package</a></code>, <code><a href="#topic+ICS-S3">ICS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # example using two functions
    set.seed(123456)
    X1 &lt;- rmvnorm(250, rep(0,8), diag(c(rep(1,6),0.04,0.04)))
    X2 &lt;- rmvnorm(50, c(rep(0,6),2,0), diag(c(rep(1,6),0.04,0.04)))
    X3 &lt;- rmvnorm(200, c(rep(0,7),2), diag(c(rep(1,6),0.04,0.04)))

    X.comps &lt;- rbind(X1,X2,X3)
    A &lt;- matrix(rnorm(64),nrow=8)
    X &lt;- X.comps %*% t(A)

    ics.X.1 &lt;- ics(X)
    summary(ics.X.1)
    plot(ics.X.1)

    # compare to
    pairs(X)
    pairs(princomp(X,cor=TRUE)$scores)

    # slow:

    # library(ICSNP)
    # ics.X.2 &lt;- ics(X, tyler.shape, duembgen.shape, S1args=list(location=0))
    # summary(ics.X.2)
    # plot(ics.X.2)

    rm(.Random.seed)

    # example using two computed scatter matrices for outlier detection

    library(robustbase)
    ics.wood&lt;-ics(wood,tM(wood)$V,tM(wood,2)$V)
    plot(ics.wood)

    # example using three pictures
    library(pixmap)

    fig1 &lt;- read.pnm(system.file("pictures/cat.pgm", package = "ICS")[1])
    fig2 &lt;- read.pnm(system.file("pictures/road.pgm", package = "ICS")[1])
    fig3 &lt;- read.pnm(system.file("pictures/sheep.pgm", package = "ICS")[1])

    p &lt;- dim(fig1@grey)[2]

    fig1.v &lt;- as.vector(fig1@grey)
    fig2.v &lt;- as.vector(fig2@grey)
    fig3.v &lt;- as.vector(fig3@grey)
    X &lt;- cbind(fig1.v,fig2.v,fig3.v)

    set.seed(4321)
    A &lt;- matrix(rnorm(9), ncol = 3)
    X.mixed &lt;- X %*% t(A)

    ICA.fig &lt;- ics(X.mixed)

    par.old &lt;- par()
    par(mfrow=c(3,3), omi = c(0.1,0.1,0.1,0.1), mai = c(0.1,0.1,0.1,0.1))

    plot(fig1)
    plot(fig2)
    plot(fig3)

    plot(pixmapGrey(X.mixed[,1],ncol=p))
    plot(pixmapGrey(X.mixed[,2],ncol=p))
    plot(pixmapGrey(X.mixed[,3],ncol=p))

    plot(pixmapGrey(ics.components(ICA.fig)[,1],ncol=p))
    plot(pixmapGrey(ics.components(ICA.fig)[,2],ncol=p))
    plot(pixmapGrey(ics.components(ICA.fig)[,3],ncol=p))

    par(par.old)
    rm(.Random.seed)
    </code></pre>

<hr>
<h2 id='ICS_scatter'>Location and Scatter Estimates for ICS</h2><span id='topic+ICS_scatter'></span><span id='topic+ICS_cov'></span><span id='topic+ICS_cov4'></span><span id='topic+ICS_covW'></span><span id='topic+ICS_covAxis'></span><span id='topic+ICS_tM'></span><span id='topic+ICS_scovq'></span>

<h3>Description</h3>

<p>Computes a scatter matrix and an optional location vector to be used in
transforming the data to an invariant coordinate system or independent
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_cov(x, location = TRUE)

ICS_cov4(x, location = c("mean", "mean3", "none"))

ICS_covW(x, location = TRUE, alpha = 1, cf = 1)

ICS_covAxis(x, location = TRUE)

ICS_tM(x, location = TRUE, df = 1, ...)

ICS_scovq(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICS_scatter_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_location">location</code></td>
<td>
<p>for <code>ICS_cov()</code>, <code>ICS_cov4()</code>, <code>ICS_covW()</code>,
and <code>ICS_covAxis()</code>, a logical indicating whether to include the sample
mean as location estimate (default to <code>TRUE</code>).  For <code>ICS_cov4()</code>,
alternatively a character string specifying the location estimate can be
supplied.  Possible values are <code>"mean"</code> for the sample mean (the
default), <code>"mean3"</code> for a location estimate based on third moments,
or <code>"none"</code> to not include a location estimate.  For <code>ICS_tM()</code>
a logical inficating whether to include the M-estimate of location
(default to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_alpha">alpha</code></td>
<td>
<p>parameter of the one-step M-estimator (default to 1).</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_cf">cf</code></td>
<td>
<p>consistency factor of the one-step M-estimator (default to 1).</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_df">df</code></td>
<td>
<p>assumed degrees of freedom of the t-distribution (default to 1,
which corresponds to the Cauchy distribution).</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down to <code><a href="#topic+scovq">scovq</a>()</code>.</p>
</td></tr>
<tr><td><code id="ICS_scatter_+3A_y">y</code></td>
<td>
<p>numerical vector specifying the dependent variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ICS_cov()</code> is a wrapper for the sample covariance matrix as computed
by <code><a href="stats.html#topic+cov">cov</a>()</code>.
</p>
<p><code>ICS_cov4()</code> is a wrapper for the scatter matrix based on fourth
moments as computed by <code><a href="#topic+cov4">cov4</a>()</code>. Note that the scatter matrix
is always computed with respect to the sample mean, even though the returned
location component can be specified to be based on third moments as computed
by <code><a href="#topic+mean3">mean3</a>()</code>.  Setting a location component other than the
sample mean can be used to fix the signs of the invariant coordinates in
<code><a href="#topic+ICS">ICS</a>()</code> based on generalized skewness values, for instance
when using the scatter pair <code>ICS_cov()</code> and <code>ICS_cov4()</code>.
</p>
<p><code>ICS_covW()</code> is a wrapper for the one-step M-estimator of scatter as
computed by <code><a href="#topic+covW">covW</a>()</code>.
</p>
<p><code>ICS_covAxis()</code> is a wrapper for the one-step Tyler shape matrix as
computed by <code><a href="#topic+covAxis">covAxis</a>()</code>, which is can be used to perform
Principal Axis Analysis.
</p>
<p><code>ICS_tM()</code> is a wrapper for the M-estimator of location and scatter
for a multivariate t-distribution, as computed by <code><a href="#topic+tM">tM</a>()</code>.
</p>
<p><code>ICS_scovq()</code> is a wrapper for the supervised scatter matrix based
on quantiles scatter, as computed by <code><a href="#topic+scovq">scovq</a>()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table role = "presentation">
<tr><td><code>location</code></td>
<td>
<p>if requested, a numeric vector giving the location
estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>References</h3>

<p>Arslan, O., Constable, P.D.L. and Kent, J.T. (1995) Convergence behaviour of
the EM algorithm for the multivariate t-distribution, <em>Communications
in Statistics, Theory and Methods</em>, <b>24</b>(12), 2981&ndash;3000.
<a href="https://doi.org/10.1080/03610929508831664">doi:10.1080/03610929508831664</a>.
</p>
<p>Critchley, F., Pires, A. and Amado, C. (2006) Principal Axis Analysis.
Technical Report, <b>06/14</b>. The Open University, Milton Keynes.
</p>
<p>Kent, J.T., Tyler, D.E. and Vardi, Y. (1994) A curious likelihood identity
for the multivariate t-distribution, <em>Communications in Statistics,
Simulation and Computation</em>, <b>23</b>(2), 441&ndash;453.
<a href="https://doi.org/10.1080/03610919408813180">doi:10.1080/03610919408813180</a>.
</p>
<p>Oja, H., Sirkia, S. and Eriksson, J. (2006) Scatter Matrices and Independent
Component Analysis. <em>Austrian Journal of Statistics</em>, <b>35</b>(2&amp;3),
175-189.
</p>
<p>Tyler, D.E., Critchley, F., Duembgen, L. and Oja, H. (2009) Invariant
Co-ordinate Selection. <em>Journal of the Royal Statistical Society,
Series B</em>, <b>71</b>(3), 549&ndash;592. <a href="https://doi.org/10.1111/j.1467-9868.2009.00706.x">doi:10.1111/j.1467-9868.2009.00706.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="base.html#topic+colSums">colMeans</a>()</code>, <code><a href="#topic+mean3">mean3</a>()</code>
</p>
<p><code><a href="stats.html#topic+cov">cov</a>()</code>, <code><a href="#topic+cov4">cov4</a>()</code>, <code><a href="#topic+covW">covW</a>()</code>,
<code><a href="#topic+covAxis">covAxis</a>()</code>, <code><a href="#topic+tM">tM</a>()</code>, <code><a href="#topic+scovq">scovq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
ICS_cov(X)
ICS_cov4(X)
ICS_covW(X, alpha = 1, cf = 1/(ncol(X)+2))
ICS_covAxis(X)
ICS_tM(X)


# The number of explaining variables
p &lt;- 10
# The number of observations
n &lt;- 400
# The error variance
sigma &lt;- 0.5
# The explaining variables
X &lt;- matrix(rnorm(p*n),n,p)
# The error term
epsilon &lt;- rnorm(n, sd = sigma)
# The response
y &lt;- X[,1]^2 + X[,2]^2*epsilon
ICS_scovq(X, y = y)

</code></pre>

<hr>
<h2 id='ics-class'>Class ICS</h2><span id='topic+ics-class'></span>

<h3>Description</h3>

<p>A S4 class to store results from an invariant coordinate system transformation or independent component computation based on two scatter matrices.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ics", ...)</code>. But usually objects are created by the function <code><a href="#topic+ics">ics</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>gKurt</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Gives the generalized kurtosis measures of the components</p>
</dd>
<dt><code>UnMix</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The unmixing matrix.</p>
</dd>
<dt><code>S1</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The first scatter matrix.</p>
</dd>
<dt><code>S2</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The second scatter matrix.</p>
</dd>
<dt><code>S1name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of the first scatter matrix.</p>
</dd>
<dt><code>S2name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of the second scatter matrix.</p>
</dd>
<dt><code>Scores</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. The underlying components in the invariant coordinate system.</p>
</dd>
<dt><code>DataNames</code>:</dt><dd><p>Object of class <code>"character"</code>. Names of the original variables.</p>
</dd>
<dt><code>StandardizeB</code>:</dt><dd><p>Object of class <code>"character"</code>. Names standardization method for UnMix.</p>
</dd>
<dt><code>StandardizegKurt</code>:</dt><dd><p>Object of class <code>"logical"</code>. States wether the generalized kurtosis is standardized or not.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>For this class the following generic functions are available: <code><a href="#topic+print.ics">print.ics</a></code>, <code><a href="#topic+summary.ics">summary.ics</a></code>, <code><a href="#topic+coef.ics">coef.ics</a></code>, <code><a href="#topic+fitted.ics">fitted.ics</a></code> and <code><a href="#topic+plot.ics">plot.ics</a></code>
</p>


<h3>Note</h3>

<p>In case no extractor function for the slots exists, the component can be extracted the usual way using '@'.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics">ics</a></code>
</p>

<hr>
<h2 id='ICS-S3'>Two Scatter Matrices ICS Transformation</h2><span id='topic+ICS-S3'></span><span id='topic+ICS'></span>

<h3>Description</h3>

<p>Transforms the data via two scatter matrices to an invariant coordinate
system or independent components, depending on the underlying assumptions.
Function <code>ICS()</code> is intended as a replacement for <code><a href="#topic+ics">ics</a>()</code>
and <code><a href="#topic+ics2">ics2</a>()</code>, and it combines their functionality into a single
function. Importantly, the results are returned as an
<code><a href="base.html#topic+class">S3</a></code> object rather than an
<code><a href="methods.html#topic+Classes_Details">S4</a></code> object. Furthermore, <code>ICS()</code>
implements recent improvements, such as a numerically stable algorithm based
on the QR algorithm for a common family of scatter pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS(
  X,
  S1 = ICS_cov,
  S2 = ICS_cov4,
  S1_args = list(),
  S2_args = list(),
  algorithm = c("whiten", "standard", "QR"),
  center = FALSE,
  fix_signs = c("scores", "W"),
  na.action = na.fail
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICS-S3_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame containing the data to be
transformed.</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_s1">S1</code></td>
<td>
<p>a numeric matrix containing the first scatter matrix, an object
of class <code>"ICS_scatter"</code> (that typically contains the location vector
and scatter matrix as <code>location</code> and <code>scatter</code> components), or a
function that returns either of those options. The default is function
<code><a href="#topic+ICS_cov">ICS_cov</a>()</code> for the sample covariance matrix.</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_s2">S2</code></td>
<td>
<p>a numeric matrix containing the second scatter matrix, an object
of class <code>"ICS_scatter"</code> (that typically contains the location vector
and scatter matrix as <code>location</code> and <code>scatter</code> components), or a
function that returns either of those options. The default is function
<code><a href="#topic+ICS_cov4">ICS_cov4</a>()</code> for the covariance matrix based on fourth order
moments.</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_s1_args">S1_args</code></td>
<td>
<p>a list containing additional arguments for <code>S1</code> (only
relevant if <code>S1</code> is a function).</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_s2_args">S2_args</code></td>
<td>
<p>a list containing additional arguments for <code>S2</code> (only
relevant if <code>S2</code> is a function).</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string specifying with which algorithm
the invariant coordinate system is computed. Possible values are
<code>"whiten"</code>, <code>"standard"</code> or <code>"QR"</code>.
See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_center">center</code></td>
<td>
<p>a logical indicating whether the invariant coordinates should
be centered with respect to first locattion or not (default to <code>FALSE</code>).
Centering is only applicable if the
first scatter object contains a location component, otherwise this is set to
<code>FALSE</code>. Note that this only affects the scores of the invariant
components (output component <code>scores</code>), but not the generalized
kurtosis values (output component <code>gen_kurtosis</code>).</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_fix_signs">fix_signs</code></td>
<td>
<p>a character string specifying how to fix the signs of the
invariant coordinates. Possible values are <code>"scores"</code> to fix the signs
based on (generalized) skewness values of the coordinates, or <code>"W"</code> to
fix the signs based on the coefficient matrix of the linear transformation.
See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="ICS-S3_+3A_na.action">na.action</code></td>
<td>
<p>a function to handle missing values in the data (default
to <code><a href="stats.html#topic+na.fail">na.fail</a></code>, see its help file for alternatives).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given scatter pair <code class="reqn">S_{1}</code> and <code class="reqn">S_{2}</code>, a matrix
<code class="reqn">Z</code> (in which the columns contain the scores of the respective invariant
coordinates) and a matrix <code class="reqn">W</code> (in which the rows contain the
coefficients of the linear transformation to the respective invariant
coordinates) are found such that:
</p>

<ul>
<li><p> The columns of <code class="reqn">Z</code> are whitened with respect to
<code class="reqn">S_{1}</code>. That is, <code class="reqn">S_{1}(Z) = I</code>, where <code class="reqn">I</code>
denotes the identity matrix.
</p>
</li>
<li><p> The columns of <code class="reqn">Z</code> are uncorrelated with respect to
<code class="reqn">S_{2}</code>. That is, <code class="reqn">S_{2}(Z) = D</code>, where <code class="reqn">D</code>
is a diagonal matrix.
</p>
</li>
<li><p> The columns of <code class="reqn">Z</code> are ordered according to their generalized
kurtosis.
</p>
</li></ul>

<p>Given those criteria, <code class="reqn">W</code> is unique up to sign changes in its rows. The
argument <code>fix_signs</code> provides two ways to ensure uniqueness of <code class="reqn">W</code>:
</p>

<ul>
<li><p> If argument <code>fix_signs</code> is set to <code>"scores"</code>, the signs
in <code class="reqn">W</code> are fixed such that the generalized skewness values of all
components are positive. If <code>S1</code> and <code>S2</code> provide location
components, which are denoted by <code class="reqn">T_{1}</code> and <code class="reqn">T_{2}</code>,
the generalized skewness values are computed as
<code class="reqn">T_{1}(Z) - T_{2}(Z)</code>.
Otherwise, the skewness is computed by subtracting the column medians of
<code class="reqn">Z</code> from the corresponding column means so that all components are
right-skewed. This way of fixing the signs is preferred in an invariant
coordinate selection framework.
</p>
</li>
<li><p> If argument <code>fix_signs</code> is set to <code>"W"</code>, the signs in
<code class="reqn">W</code> are fixed independently of <code class="reqn">Z</code> such that the maximum element
in each row of <code class="reqn">W</code> is positive and that each row has norm 1. This is
the usual way of fixing the signs in an independent component analysis
framework.
</p>
</li></ul>

<p>In principal, the order of <code class="reqn">S_{1}</code> and <code class="reqn">S_{2}</code> does not
matter if both are true scatter matrices. Changing their order will just
reverse the order of the components and invert the corresponding
generalized kurtosis values.
</p>
<p>The same does not hold when at least one of them is a shape matrix rather
than a true scatter matrix. In that case, changing their order will also
reverse the order of the components, but the ratio of the generalized
kurtosis values is no longer 1 but only a constant. This is due to the fact
that when shape matrices are used, the generalized kurtosis values are only
relative ones.
</p>
<p>Different algorithms are available to compute the invariant coordinate
system of a data frame <code class="reqn">X_n</code> with <code class="reqn">n</code> observations:
</p>

<ul>
<li> <p><strong>&quot;whiten&quot;</strong>: whitens the data <code class="reqn">X_n</code> with respect to the first
scatter matrix before computing the second scatter matrix. If <code>S2</code> is not a function, whitening is not applicable.
</p>

<ul>
<li><p> whiten the data <code class="reqn">X_n</code> with respect to the first
scatter matrix: <code class="reqn">Y_n =  X_n S_1(X_n)^{-1/2}</code>
</p>
</li>
<li><p> compute <code class="reqn">S_2</code> for the uncorrelated data: <code class="reqn">S_2(Y_n)</code>
</p>
</li>
<li><p> perform the eigendecomposition of <code class="reqn">S_2(Y_n)</code>: <code class="reqn">S_2(Y_n) = UDU'</code>
</p>
</li>
<li><p> compute <code class="reqn">W</code>: <code class="reqn">W = U' S_1(X_n)^{-1/2}</code>
</p>
</li></ul>

</li>
<li> <p><strong>&quot;standard&quot;</strong>: performs the spectral decomposition of the
symmetric matrix  <code class="reqn">M(X_n)</code>
</p>

<ul>
<li><p> compute <code class="reqn">M(X_n) = S_1(X_n)^{-1/2} S_2(X_n) S_1(X_n)^{-1/2}</code>
</p>
</li>
<li><p> perform the eigendecomposition of <code class="reqn">M(X_n)</code>: <code class="reqn">M(X_n) = UDU'</code>
</p>
</li>
<li><p> compute <code class="reqn">W</code>: <code class="reqn">W = U' S_1(X_n)^{-1/2}</code>
</p>
</li></ul>

</li>
<li> <p><strong>&quot;QR&quot;</strong>: numerically stable algorithm based on the QR algorithm for a
common family of scatter pairs: if <code>S1</code> is <code><a href="#topic+ICS_cov">ICS_cov</a>()</code>
or <code><a href="stats.html#topic+cov">cov</a>()</code>, and if <code>S2</code> is one of
<code><a href="#topic+ICS_cov4">ICS_cov4</a>()</code>, <code><a href="#topic+ICS_covW">ICS_covW</a>()</code>
, <code><a href="#topic+ICS_covAxis">ICS_covAxis</a>()</code>, <code><a href="#topic+cov4">cov4</a>()</code>,
<code><a href="#topic+covW">covW</a>()</code>, or <code><a href="#topic+covAxis">covAxis</a>()</code>.
For other scatter pairs, the QR algorithm is not
applicable.   See Archimbaud et al. (2023)
for details. Note that the QR algorithm requires LAPACK version
<code class="reqn">\geq</code> 3.11.0 to attain better numerical stability.
</p>
</li></ul>

<p>The &quot;whiten&quot; algorithm is the most natural version and therefore the default. The option &quot;standard&quot;
should be only used if the scatters provided are not functions but precomputed matrices.
The option &quot;QR&quot; is mainly of interest when there are numerical issues when &quot;whiten&quot; is used and the
scatter combination allows its usage.
</p>
<p>Note that when the purpose of ICS is outlier detection the package <a href="ICSOutlier.html#topic+ICSOutlier">ICSOutlier</a>
provides additional functionalities as does the package <code>ICSClust</code> in case the
goal of ICS is dimension reduction prior clustering.
</p>


<h3>Value</h3>

<p>An object of class <code>"ICS"</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>gen_kurtosis</code></td>
<td>
<p>a numeric vector containing the generalized kurtosis
values of the invariant coordinates.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>a numeric matrix in which each row contains the coefficients of the
linear transformation to the corresponding invariant coordinate.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>a numeric matrix in which each column contains the scores of
the corresponding invariant coordinate.</p>
</td></tr>
<tr><td><code>gen_skewness</code></td>
<td>
<p>a numeric vector containing the (generalized) skewness
values of the invariant coordinates (only returned if
<code>fix_signs = "scores"</code>).</p>
</td></tr>
<tr><td><code>S1_label</code></td>
<td>
<p>a character string providing a label for the first scatter
matrix to be used by various methods.</p>
</td></tr>
<tr><td><code>S2_label</code></td>
<td>
<p>a character string providing a label for the second scatter
matrix to be used by various methods.</p>
</td></tr>
<tr><td><code>S1_args</code></td>
<td>
<p>a list containing additional arguments used to compute
<code>S1</code> (if a function was supplied).</p>
</td></tr>
<tr><td><code>S2_args</code></td>
<td>
<p>a list containing additional arguments used to compute
<code>S2</code> (if a function was supplied).</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>a character string specifying how the invariant
coordinate is computed.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>a logical indicating whether or not the data were centered
with respect to the first location vector before computing the invariant
coordinates.</p>
</td></tr>
<tr><td><code>fix_signs</code></td>
<td>
<p>a character string specifying how the signs of the
invariant coordinates were fixed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud, based on code for
<code><a href="#topic+ics">ics</a>()</code> and <code><a href="#topic+ics2">ics2</a>()</code> by Klaus Nordhausen
</p>


<h3>References</h3>

<p>Tyler, D.E., Critchley, F., Duembgen, L. and Oja, H. (2009) Invariant
Co-ordinate Selection. <em>Journal of the Royal Statistical Society,
Series B</em>, <b>71</b>(3), 549&ndash;592. <a href="https://doi.org/10.1111/j.1467-9868.2009.00706.x">doi:10.1111/j.1467-9868.2009.00706.x</a>.
</p>
<p>Archimbaud, A., Drmac, Z., Nordhausen, K., Radojcic, U. and Ruiz-Gazen, A.
(2023) Numerical Considerations and a New Implementation for Invariant
Coordinate Selection. <em>SIAM Journal on Mathematics of Data Science</em>,
<b>5</b>(1), 97&ndash;121. <a href="https://doi.org/10.1137/22M1498759">doi:10.1137/22M1498759</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>, <code><a href="#topic+coef.ICS">coef</a>()</code>,
<code><a href="#topic+components">components</a>()</code>, <code><a href="#topic+fitted.ICS">fitted</a>()</code>, and
<code><a href="#topic+plot.ICS">plot</a>()</code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import data
data("iris")
X &lt;- iris[,-5]

# run ICS
out_ICS &lt;- ICS(X)
out_ICS
summary(out_ICS)

# extract generalized eigenvalues
gen_kurtosis(out_ICS)
# Plot
screeplot(out_ICS)

# extract the components
components(out_ICS)
components(out_ICS, select = 1:2)

# Plot
plot(out_ICS)

# equivalence with previous functions
out_ics &lt;- ics(X, S1 = cov, S2 = cov4, stdKurt = FALSE)
out_ics
out_ics2 &lt;- ics2(X, S1 = MeanCov, S2 = Mean3Cov4)
out_ics2
out_ICS


# example using two functions
X1 &lt;- rmvnorm(250, rep(0,8), diag(c(rep(1,6),0.04,0.04)))
X2 &lt;- rmvnorm(50, c(rep(0,6),2,0), diag(c(rep(1,6),0.04,0.04)))
X3 &lt;- rmvnorm(200, c(rep(0,7),2), diag(c(rep(1,6),0.04,0.04)))
X.comps &lt;- rbind(X1,X2,X3)
A &lt;- matrix(rnorm(64),nrow=8)
X &lt;- X.comps %*% t(A)
ics.X.1 &lt;- ICS(X)
summary(ics.X.1)
plot(ics.X.1)
# compare to
pairs(X)
pairs(princomp(X,cor=TRUE)$scores)


# slow:
if (require("ICSNP")) {
  ics.X.2 &lt;- ICS(X, S1 = tyler.shape, S2 = duembgen.shape,
  S1_args = list(location=0))
  summary(ics.X.2)
  plot(ics.X.2)
  # example using three pictures
  library(pixmap)
  fig1 &lt;- read.pnm(system.file("pictures/cat.pgm", package = "ICS")[1],
                   cellres = 1)
  fig2 &lt;- read.pnm(system.file("pictures/road.pgm", package = "ICS")[1],
                   cellres = 1)
  fig3 &lt;- read.pnm(system.file("pictures/sheep.pgm", package = "ICS")[1],
                   cellres = 1)
  p &lt;- dim(fig1@grey)[2]
  fig1.v &lt;- as.vector(fig1@grey)
  fig2.v &lt;- as.vector(fig2@grey)
  fig3.v &lt;- as.vector(fig3@grey)
  X &lt;- cbind(fig1.v, fig2.v, fig3.v)
  A &lt;- matrix(rnorm(9), ncol = 3)
  X.mixed &lt;- X %*% t(A)
  ICA.fig &lt;- ICS(X.mixed)
  par.old &lt;- par()
  par(mfrow=c(3,3), omi = c(0.1,0.1,0.1,0.1), mai = c(0.1,0.1,0.1,0.1))
  plot(fig1)
  plot(fig2)
  plot(fig3)
  plot(pixmapGrey(X.mixed[,1], ncol = p, cellres = 1))
  plot(pixmapGrey(X.mixed[,2], ncol = p, cellres = 1))
  plot(pixmapGrey(X.mixed[,3], ncol = p, cellres = 1))
  plot(pixmapGrey(components(ICA.fig)[,1], ncol = p, cellres = 1))
  plot(pixmapGrey(components(ICA.fig)[,2], ncol = p, cellres = 1))
  plot(pixmapGrey(components(ICA.fig)[,3], ncol = p, cellres = 1))
}
</code></pre>

<hr>
<h2 id='ics.components'> Extracting ICS Components</h2><span id='topic+ics.components'></span>

<h3>Description</h3>

<p>Function to extract the ICS components of a <code>ics</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics.components(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics.components_+3A_object">object</code></td>
<td>
<p>object of class <code>ics</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe that contains the components.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>

<hr>
<h2 id='ics2'>
Two Scatter Matrices ICS Transformation Augmented by Two Location Estimates
</h2><span id='topic+ics2'></span>

<h3>Description</h3>

<p>This function implements the two scatter matrices transformation to obtain an invariant coordinate sytem or independent
components, depending on the underlying assumptions. Differently to <code><a href="#topic+ics">ics</a></code> here, there are also two location functionals used
to fix the signs of the components and to get a measure of skewness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics2(X, S1 = MeanCov, S2 = Mean3Cov4, S1args = list(), S2args = list(),
     na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics2_+3A_x">X</code></td>
<td>
<p> numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="ics2_+3A_s1">S1</code></td>
<td>
<p> name of the function which returns the first location vector T1 and scatter matrix S1. Can be also
a list which has these values already computed. See details for more information. Default is <code><a href="#topic+MeanCov">MeanCov</a></code>.</p>
</td></tr>
<tr><td><code id="ics2_+3A_s2">S2</code></td>
<td>
<p>name of the function which returns the second location vector T2 and scatter matrix S2. Can be also
a list which has these values already computed. See details for more information. Default is <code><a href="#topic+Mean3Cov4">Mean3Cov4</a></code>.</p>
</td></tr>
<tr><td><code id="ics2_+3A_s1args">S1args</code></td>
<td>
<p> list with optional additional arguments when calling function S1.</p>
</td></tr>
<tr><td><code id="ics2_+3A_s2args">S2args</code></td>
<td>
<p> list with optional additional arguments when calling function S2.</p>
</td></tr>
<tr><td><code id="ics2_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a general discussion about ICS see the help for <code><a href="#topic+ics">ics</a></code>. The difference to <code><a href="#topic+ics">ics</a></code> is that <code>S1</code> and <code>S2</code>
are either functions which return a list containing a multivariate location and scatter computed on <code>X</code> or lists containing these measures
computed in advance. Of importance for the resulting lists is that in both cases the location vector is the first element of the list and the scatter matrix
the second element. This means most multivariate location - scatter functions can be used directly without the need to write a wrapper.
</p>
<p>The invariant coordinates Z are then computed such that
(i)   T1(Z) = 0, the origin.
(ii)  S1(Z) = I_p, the identity matrix.
(iii) T2(Z) = S, where S is a vector having positive elements which can be seen as a generalized skewness measure (gSkew).
(iv)  S2(Z) = D, a diagonal matrix with descending elements which can be seen as a generalized kurtosis measure (gKurt).
</p>
<p>Hence in this function there are no options to standardize Z or the transformation matrix B as everything is
specified by <code>S1</code> and <code>S2</code>.
</p>
<p>Note also that <code>ics2</code> makes hardly any input checks.
</p>


<h3>Value</h3>

<p>an object of class <code>ics2</code> inheriting from class <code>ics</code>.
</p>


<h3>Note</h3>

<p>Function <code>ics2()</code> reached the end of its lifecycle, please use <code><a href="#topic+ICS-S3">ICS</a>()</code> instead. In future versions, <code>ics2()</code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Tyler, D.E., Critchley, F., DÃ¼mbgen, L. and Oja, H. (2009), Invariant co-ordinate selecetion, <em>Journal of the Royal Statistical Society</em>,Series B, <b>71</b>,  549&ndash;592. &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;.</cite>
</p>
<p><cite>Nordhausen, K., Oja, H. and Ollila, E. (2011), Multivariate Models and the First Four Moments, In Hunter, D.R., Richards, D.S.R. and Rosenberger, J.L. (editors) &quot;Nonparametric Statistics and Mixture Models:  A Festschrift in Honor of Thomas P. Hettmansperger&quot;, 267&ndash;287, World Scientific, Singapore. &lt;doi:10.1142/9789814340564_0016&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS-S3">ICS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(123456)
 X1 &lt;- rmvnorm(250, rep(0,8), diag(c(rep(1,6),0.04,0.04)))
 X2 &lt;- rmvnorm(50, c(rep(0,6),2,0), diag(c(rep(1,6),0.04,0.04)))
 X3 &lt;- rmvnorm(200, c(rep(0,7),2), diag(c(rep(1,6),0.04,0.04)))

 X.comps &lt;- rbind(X1,X2,X3)
 A &lt;- matrix(rnorm(64),nrow=8)
 X &lt;- X.comps %*% t(A)

 # the default
 ics2.X.1 &lt;- ics2(X2)
 summary(ics2.X.1)

 # using another function as S2 not with its default
 ics2.X.2 &lt;- ics2(X2, S2 = tM, S2args = list(df = 2))
 summary(ics2.X.2)

 # computing in advance S2 and using another S1
 Scauchy &lt;- tM(X)
 ics2.X.2 &lt;- ics2(X2, S1 = tM, S2 = Scauchy, S1args = list(df = 5))
 summary(ics2.X.2)
 plot(ics2.X.2)
</code></pre>

<hr>
<h2 id='ics2-class'>Class ICS2</h2><span id='topic+ics2-class'></span>

<h3>Description</h3>

<p>A S4 class to store results from an invariant coordinate system transformation or independent component computation based on two scatter matrices and two location vectors.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ics2", ...)</code>. But usually objects are created by the function <code><a href="#topic+ics2">ics2</a></code>.
The Class inherits from the <code>ics</code> class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>gSkew</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Gives the generalized skewness measures of the components</p>
</dd>   
<dt><code>gKurt</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Gives the generalized kurtosis measures of the components</p>
</dd>
<dt><code>UnMix</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The unmixing matrix.</p>
</dd>
<dt><code>S1</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The first scatter matrix.</p>
</dd>
<dt><code>S2</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The second scatter matrix.</p>
</dd>
<dt><code>T1</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The first location vector.</p>
</dd>
<dt><code>T2</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The second location vector.</p>
</dd>
<dt><code>S1name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of the first scatter matrix.</p>
</dd>
<dt><code>S2name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of the second scatter matrix.</p>
</dd>
<dt><code>S1args</code>:</dt><dd><p>Object of class <code>"list"</code>. Additional arguments needed when calling function S1.</p>
</dd>
<dt><code>S2args</code>:</dt><dd><p>Object of class <code>"list"</code>. Additional arguments needed when calling function S2.</p>
</dd>
<dt><code>Scores</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. The underlying components in the invariant coordinate system.</p>
</dd>
<dt><code>DataNames</code>:</dt><dd><p>Object of class <code>"character"</code>. Names of the original variables.</p>
</dd>
<dt><code>StandardizeB</code>:</dt><dd><p>Object of class <code>"character"</code>. Names standardization method for UnMix.</p>
</dd>
<dt><code>StandardizegKurt</code>:</dt><dd><p>Object of class <code>"logical"</code>. States wether the generalized kurtosis is standardized or not.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>For this class the following generic functions are available: <code><a href="#topic+print.ics2">print.ics2</a></code>, <code><a href="#topic+summary.ics2">summary.ics2</a></code>
But naturally the other methods like plot, coef, fitted and so from class ics work via inheritance.
</p>


<h3>Note</h3>

<p>In case no extractor function for the slots exists, the component can be extracted the usual way using '@'.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics2">ics2</a></code>
</p>

<hr>
<h2 id='mean3'> Location Estimate based on Third Moments</h2><span id='topic+mean3'></span>

<h3>Description</h3>

<p>Estimates the location based on third moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean3(X, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean3_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe with at least two columns.</p>
</td></tr>
<tr><td><code id="mean3_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This location estimate is defined for a <code class="reqn">n \times p</code> matrix X as
</p>
<p style="text-align: center;"><code class="reqn"> \frac{1}{p} ave_{i}\{[(x_{i}-\bar{x})S^{-1}(x_{i}-\bar{x})'] x_{i}\},</code>
</p>

<p>where <code class="reqn">\bar{x}</code> is the mean vector and <code class="reqn">S</code> the regular covariance matrix.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H., Sirki?, S. and Eriksson, J. (2006), Scatter matrices and independent component analysis, <em>Austrian Journal of Statistics</em>, <b>35</b>,  175&ndash;189.</cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
mean3(X)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='Mean3Cov4'>
Location Vector Based on 3rd Moments and Scatter Matrix Based on 4th Moments
</h2><span id='topic+Mean3Cov4'></span>

<h3>Description</h3>

<p>Returns, for some multivariate data, the location vector based on 3rd moments and the scatter matrix based on 4th moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mean3Cov4(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mean3Cov4_+3A_x">x</code></td>
<td>
<p>a numeric data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the scatter matrix of 4th moments is computed with respect to the mean vector and not with respect to the location vector
based on 3rd moments.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>locations</code></td>
<td>
<p>The location vector based on 3rd moments as computed by <code><a href="#topic+mean3">mean3</a></code>.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>The scatter matrix based on 4th moments as computed by <code><a href="#topic+cov4">cov4</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean3">mean3</a></code>, <code><a href="#topic+cov4">cov4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvnorm(200, 1:3, diag(2:4))
Mean3Cov4(X)
</code></pre>

<hr>
<h2 id='MeanCov'>Mean Vector and Covariance Matrix</h2><span id='topic+MeanCov'></span>

<h3>Description</h3>

<p>Returns, for some multivariate data, the mean vector and covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanCov(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanCov_+3A_x">x</code></td>
<td>
<p>a numeric data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>locations</code></td>
<td>
<p>The mean vector as computed by <code><a href="base.html#topic+colMeans">colMeans</a></code>.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>The covariance matrix as computed by <code><a href="stats.html#topic+cov">cov</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colMeans">colMeans</a></code>, <code><a href="stats.html#topic+cov">cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvnorm(200, 1:3, diag(2:4))
MeanCov(X)
</code></pre>

<hr>
<h2 id='mvnorm.kur.test'>Test of Multivariate Normality Based on Kurtosis</h2><span id='topic+mvnorm.kur.test'></span>

<h3>Description</h3>

<p>Test for multivariate normality which uses as criterion the kurtosis measured by the ratio of regular covariance matrix and matrix of
fourth moments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnorm.kur.test(X, method = "integration", n.simu = 1000, 
                na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvnorm.kur.test_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mvnorm.kur.test_+3A_method">method</code></td>
<td>
<p>defines the method used for the computation of the p-value. The possibilites are
&quot;integration&quot; (default), &quot;satterthwaite&quot; or &quot;simulation&quot;. Details below.</p>
</td></tr>
<tr><td><code id="mvnorm.kur.test_+3A_n.simu">n.simu</code></td>
<td>
<p>if '<code>method</code>=simulation' this specifies the number of replications in the simulation. </p>
</td></tr>
<tr><td><code id="mvnorm.kur.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test implements the multivariate normality test based on kurtosis measured by two different scatter estimates
as described in Kankainen, Taskinen and Oja. The choice here is based on the regular covariance matrix and matrix of
fourth moments (<code><a href="#topic+cov4">cov4</a></code>). 
The limiting distribution of the test statistic W is a linear combination of independent chi-square variables with different degrees of freedom.
Exact limiting p-values or approximated p-values are obtained by using the function <code><a href="survey.html#topic+pchisqsum">pchisqsum</a></code>. However Kankainen et al.
mention that even for n = 200 the convergence can be poor, therefore also p-values simulated under the NULL can be obtained.  
</p>
<p>Note that the test statistic used is a symmetric version of the one in the paper to guarantee affine invariance.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic W.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the test statistic W with their weights or the number of replications depending on the chosen method.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Kankainen, A., Taskinen, S. and Oja, H. (2007), Tests of multinormality based on location vectors and scatter matrices, <em>Statistical Methods and Applications</em>, <b>16</b>,  357&ndash;379. &lt;doi:10.1007/s10260-007-0045-9&gt;.</cite></p>


<h3>See Also</h3>

 <p><code><a href="#topic+mvnorm.skew.test">mvnorm.skew.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-rmvnorm(100, c(2, 4, 5))
mvnorm.kur.test(X)
mvnorm.kur.test(X, method = "satt")
mvnorm.kur.test(X, method = "simu")
</code></pre>

<hr>
<h2 id='mvnorm.skew.test'> Test of Multivariate Normality Based on Skewness</h2><span id='topic+mvnorm.skew.test'></span>

<h3>Description</h3>

<p>Test for multivariate normality that uses as criterion the skewness measured as the difference between
location estimates based on first respectively third moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnorm.skew.test(X, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvnorm.skew.test_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="mvnorm.skew.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test implements the multivariate normality test based on skewness measured by two different location estimates
as described in Kankainen, Taskinen and Oja. The choice here is based on the regular mean vector and the location estimate based on
third moments (<code><a href="#topic+mean3">mean3</a></code>). The scatter matrix used is the regular covariance matrix.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic U.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the statistic U.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Kankainen, A., Taskinen, S. and Oja, H. (2007),Tests of multinormality based on location vectors and scatter matrices, <em>Statistical Methods and Applications</em>, <b>16</b>,  357&ndash;379. &lt;doi:10.1007/s10260-007-0045-9&gt;.</cite></p>


<h3>See Also</h3>

 <p><code><a href="#topic+mvnorm.kur.test">mvnorm.kur.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-rmvnorm(100,c(2,4,5))
mvnorm.skew.test(X)
</code></pre>

<hr>
<h2 id='plot.ics'>Scatterplot for a ICS Object</h2><span id='topic+plot-ics'></span><span id='topic+plot.ics'></span><span id='topic+plot-method'></span><span id='topic+plot+2Cics+2Cmissing-method'></span>

<h3>Description</h3>

<p>Scatterplot matrix for an <code>ics</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics,missing'
plot(x, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ics_+3A_x">x</code></td>
<td>
<p>object of class <code>ics</code></p>
</td></tr>
<tr><td><code id="plot.ics_+3A_index">index</code></td>
<td>
<p>index vector of which components should be plotted. See details for further information</p>
</td></tr>
<tr><td><code id="plot.ics_+3A_...">...</code></td>
<td>
<p>other arguments for <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no index vector is given the function plots the full scatterplots matrix only if there are less than seven components.
Otherwise the three first and three last components will be plotted.
This is because the components with extreme kurtosis are the most interesting ones.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+screeplot.ics">screeplot.ics</a></code>, <code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    set.seed(123456)
    X1 &lt;- rmvnorm(250, rep(0,8), diag(c(rep(1,6),0.04,0.04)))
    X2 &lt;- rmvnorm(50, c(rep(0,6),2,0), diag(c(rep(1,6),0.04,0.04)))
    X3 &lt;- rmvnorm(200, c(rep(0,7),2), diag(c(rep(1,6),0.04,0.04)))

    X.comps &lt;- rbind(X1,X2,X3)
    A &lt;- matrix(rnorm(64),nrow=8)
    X &lt;- X.comps %*% t(A)

    ics.X.1 &lt;- ics(X)
    plot(ics.X.1)
    plot(ics.X.1,index=1:8)
    rm(.Random.seed)
</code></pre>

<hr>
<h2 id='plot.ICS-S3'>Scatterplot Matrix of Component Scores from the ICS Transformation</h2><span id='topic+plot.ICS-S3'></span><span id='topic+plot.ICS'></span>

<h3>Description</h3>

<p>Produces a scatterplot matrix of the component scores of an invariant
coordinate system obtained via an ICS transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
plot(x, select = NULL, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ICS-S3_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> containing results
from an ICS transformation.</p>
</td></tr>
<tr><td><code id="plot.ICS-S3_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying which
components to plot. If <code>NULL</code>, all components are plotted if there are
at most six components, otherwise the first three and the last three
components are plotted (as the components with extreme generalized kurtosis
values are the most interesting ones).</p>
</td></tr>
<tr><td><code id="plot.ICS-S3_+3A_index">index</code></td>
<td>
<p>an integer vector specifying which components to plot, or
<code>NULL</code> to plot all components.  Note that <code>index</code> is deprecated
and may be removed in the future, use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="plot.ICS-S3_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down to
<code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>, <code><a href="#topic+coef.ICS">coef</a>()</code>,
<code><a href="#topic+components">components</a>()</code>, and <code><a href="#topic+fitted.ICS">fitted</a>()</code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
plot(out)
plot(out, select = c(1,4))

</code></pre>

<hr>
<h2 id='print.ics'>Basic information of ICS Object</h2><span id='topic+print.ics'></span><span id='topic+show+2Cics-method'></span>

<h3>Description</h3>

<p>Prints the minimal information of an <code>ics</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ics_+3A_object">object</code></td>
<td>
<p>object of class <code>ics</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>

<hr>
<h2 id='print.ICS-S3'>Basic information of ICS Object</h2><span id='topic+print.ICS-S3'></span><span id='topic+print.ICS'></span>

<h3>Description</h3>

<p>Prints information of an <code>ICS</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
print(x, info = FALSE, digits = 4L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ICS-S3_+3A_x">x</code></td>
<td>
<p>object of class <code>ICS</code>.</p>
</td></tr>
<tr><td><code id="print.ICS-S3_+3A_info">info</code></td>
<td>
<p>Logical, either TRUE or FALSE. If TRUE, print additional
information on arguments used for computing scatter matrices
(only named arguments that contain numeric, character, or logical scalars)
and information on the parameters of the algorithm.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="print.ICS-S3_+3A_digits">digits</code></td>
<td>
<p>number of digits for the numeric output.</p>
</td></tr>
<tr><td><code id="print.ICS-S3_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>print()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
print(out)
print(out, info = TRUE)
</code></pre>

<hr>
<h2 id='print.ics2'>Basic information of ICS2 Object</h2><span id='topic+print.ics2'></span><span id='topic+show+2Cics2-method'></span>

<h3>Description</h3>

<p>Prints the minimal information of an <code>ics2</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics2'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ics2_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics2-class">ics2-class</a></code> and <code><a href="#topic+ics2">ics2</a></code></p>

<hr>
<h2 id='scovq'>
Supervised scatter matrix based on quantiles
</h2><span id='topic+scovq'></span>

<h3>Description</h3>

<p>Function for a supervised scatter matrix that is the weighted
covariance matrix of <code>x</code> with weights 1/(<code>q2-q1</code>) if <code>y</code> is between the
lower (<code>q1</code>) and upper (<code>q2</code>) quantile and 0 otherwise (or vice versa). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scovq(x, y, q1 = 0, q2 = 0.5, pos = TRUE, type = 7, 
      method = "unbiased", na.action = na.fail, 
      check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scovq_+3A_x">x</code></td>
<td>

<p>numeric data matrix with at least two columns.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_y">y</code></td>
<td>

<p>numerical vector specifying the dependent variable.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_q1">q1</code></td>
<td>

<p>percentage for lower quantile of <code>y</code>. With 0 &lt;= <code>q1</code> &lt; <code>q2</code>. See details.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_q2">q2</code></td>
<td>

<p>percentage for upper quantile of <code>y</code>. With <code>q1</code> &lt; <code>q2</code> &lt;= 1. See details.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_pos">pos</code></td>
<td>

<p>logical. If TRUE then the weights are 1/(<code>q2-q1</code>) if <code>y</code> is between the <code>q1</code>- and <code>q2</code>-
quantiles and 0 othervise. If FALSE then the weights are 0 if <code>y</code>
between <code>q1</code>- and <code>q2</code>-quantiles  and 1/(<code>1-q2+q1</code>) otherwise.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_type">type</code></td>
<td>

<p>passed on to function <code><a href="stats.html#topic+quantile">quantile</a></code>. 
</p>
</td></tr>
<tr><td><code id="scovq_+3A_method">method</code></td>
<td>

<p>passed on to function <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>. 
</p>
</td></tr>
<tr><td><code id="scovq_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.
</p>
</td></tr>
<tr><td><code id="scovq_+3A_check">check</code></td>
<td>

<p>logical. Checks if the input should be checked for consistency. If not needed setting
it to FALSE might save some time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights for this supervised scatter matrix for <code>pos=TRUE</code> are
<code class="reqn">w(y) = I(q1-quantile &lt; y &lt; q2-quantile)/(q2-q1)</code>. Then <code>scovq</code> is calculated as
</p>
<p style="text-align: center;"><code class="reqn">scovq = \sum w(y) (x-\bar{x}_w)'(x-\bar{x}_w).</code>
</p>
  
<p>where <code class="reqn">\bar{x}_w = \sum w(y) x</code>.
</p>
<p>To see how this function can be used in the context of supervised invariant coordinate selection
see the example below.
</p>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Liski, E., Nordhausen, K. and Oja, H. (2014), Supervised invariant coordinate selection, <em>Statistics: A Journal of Theoretical and Applied Statistics</em>, <b>48</b>,  711&ndash;731. &lt;doi:10.1080/02331888.2013.800067&gt;.</cite>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cov.wt">cov.wt</a></code> and <code><a href="#topic+ics">ics</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating some data

# The number of explaining variables
p &lt;- 10
# The number of observations
n &lt;- 400
# The error variance
sigma &lt;- 0.5
# The explaining variables 
X &lt;- matrix(rnorm(p*n),n,p)
# The error term
epsilon &lt;- rnorm(n, sd = sigma)
# The response
y &lt;- X[,1]^2 + X[,2]^2*epsilon


# SICS with ics

X.centered &lt;- sweep(X,2,colMeans(X),"-")
SICS &lt;- ics(X.centered, S1=cov, S2=scovq, S2args=list(y=y, q1=0.25, 
        q2=0.75, pos=FALSE), stdKurt=FALSE, stdB="Z")

# Assuming it is known that k=2, then the two directions 
# of interest are choosen as:

k &lt;- 2
KURTS &lt;- SICS@gKurt 
KURTS.max &lt;- ifelse(KURTS &gt;= 1, KURTS, 1/KURTS)
ordKM &lt;- order(KURTS.max, decreasing = TRUE)

indKM &lt;- ordKM[1:k]

# The two variables of interest
Zk &lt;- ics.components(SICS)[,indKM]

# The correspondings transformation matrix
Bk &lt;- coef(SICS)[indKM,]

# The corresponding projection matrix
Pk &lt;- t(Bk) %*% solve(Bk %*% t(Bk)) %*% Bk

# Visualization
pairs(cbind(y,Zk))

# checking the subspace difference

# true projection

B0 &lt;- rbind(rep(c(1,0),c(1,p-1)),rep(c(0,1,0),c(1,1,p-2)))
P0 &lt;- t(B0) %*% solve(B0 %*% t(B0)) %*% B0

# crone and crosby subspace distance measure, should be small
k - sum(diag(P0 %*% Pk))

</code></pre>

<hr>
<h2 id='screeplot.ics'>Screeplot for an ICS Object </h2><span id='topic+screeplot.ics'></span>

<h3>Description</h3>

<p>Plots the kurtosis measures of an <code>ics</code> object against its index number. Two versions of this screeplot are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ics'
screeplot(x, index = NULL, type = "barplot", 
          main = deparse(substitute(x)), ylab = "generalized kurtosis", 
          xlab = "component", names.arg = index, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.ics_+3A_x">x</code></td>
<td>
<p> object of class <code>ics</code>.</p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_index">index</code></td>
<td>
<p>index of the components to be plottes. If NULL all components are used.</p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_type">type</code></td>
<td>
 <p><code>barplot</code> if a barplot or <code>lines</code> if a line plot is preferred.</p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_main">main</code></td>
<td>
<p> main title of the plot. </p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_ylab">ylab</code></td>
<td>
<p> y-axis label. </p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_xlab">xlab</code></td>
<td>
<p> x-axis label. </p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_names.arg">names.arg</code></td>
<td>
<p><code>names.arg</code> argument passed on to <code>barplot</code>. </p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_labels">labels</code></td>
<td>
<p><code>labels</code> argument for the labels of the x-axis passed on to <code>axis</code>. </p>
</td></tr>
<tr><td><code id="screeplot.ics_+3A_...">...</code></td>
<td>
<p>other arguments for the plotting functions. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ics">plot.ics</a></code>, <code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
A &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2),ncol=3)
eigen.A &lt;- eigen(A)
sqrt.A &lt;- eigen.A$vectors %*% (diag(eigen.A$values))^0.5 %*% t(eigen.A$vectors)
normal.ic &lt;- cbind(rnorm(800), rnorm(800), rnorm(800))
mix.ic &lt;- cbind(rt(800,4), rnorm(800), runif(800,-2,2))

data.normal &lt;- normal.ic %*% t(sqrt.A)
data.mix &lt;- mix.ic %*% t(sqrt.A)

par(mfrow=c(1,2))
screeplot(ics(data.normal))
screeplot(ics(data.mix), type="lines")
par(mfrow=c(1,1))
rm(.Random.seed)

screeplot(ics(data.normal), names.arg=paste("IC", 1:ncol(A), sep=""), xlab="")
</code></pre>

<hr>
<h2 id='screeplot.ICS-S3'>Screeplot for an <code>ICS</code> Object</h2><span id='topic+screeplot.ICS-S3'></span><span id='topic+screeplot.ICS'></span>

<h3>Description</h3>

<p>Plots the kurtosis measures of an <code>ICS</code> object against its index number.
Two versions of this screeplot are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
screeplot(
  x,
  index = NULL,
  type = "barplot",
  main = deparse(substitute(x)),
  ylab = "generalized kurtosis",
  xlab = "component",
  names.arg = index,
  labels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.ICS-S3_+3A_x">x</code></td>
<td>
<p>object of class <code>ICS</code></p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_index">index</code></td>
<td>
<p>index of the components to be plottes.
If NULL all components are used.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_type">type</code></td>
<td>
<p>&quot;barplot&quot; if a barplot or &quot;lines&quot; if a line plot is preferred.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_names.arg">names.arg</code></td>
<td>
<p>names.arg argument passed on to &quot;barplot&quot;.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_labels">labels</code></td>
<td>
<p><code>labels</code> argument for the labels of the x-axis passed on to
<code>axis</code>.</p>
</td></tr>
<tr><td><code id="screeplot.ICS-S3_+3A_...">...</code></td>
<td>
<p>other arguments for the plotting functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+gen_kurtosis">gen_kurtosis</a>()</code>  method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)
screeplot(out)
screeplot(out, type = "lines")
</code></pre>

<hr>
<h2 id='summary.ics'>To summarize an ICS object</h2><span id='topic+summary.ics'></span><span id='topic+summary+2Cics-method'></span>

<h3>Description</h3>

<p>Summarizes and prints a <code>ics</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics'
summary(object, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ics_+3A_object">object</code></td>
<td>
<p>object of class <code>ics</code>.</p>
</td></tr>
<tr><td><code id="summary.ics_+3A_digits">digits</code></td>
<td>
<p> number of digits for the numeric output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics-class">ics-class</a></code> and <code><a href="#topic+ics">ics</a></code></p>

<hr>
<h2 id='summary.ICS-S3'>To summarize an <code>ICS</code> object</h2><span id='topic+summary.ICS-S3'></span><span id='topic+summary.ICS'></span>

<h3>Description</h3>

<p>Summarizes and prints an <code>ICS</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ICS-S3_+3A_object">object</code></td>
<td>
<p>object of class <code>ICS</code>.</p>
</td></tr>
<tr><td><code id="summary.ICS-S3_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+print.ICS">print.ICS()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+print.ICS">print.ICS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X &lt;- iris[,-5]
out &lt;- ICS(X)
summary(out)
</code></pre>

<hr>
<h2 id='summary.ics2'>To summarize an ICS2 object</h2><span id='topic+summary.ics2'></span><span id='topic+summary+2Cics2-method'></span>

<h3>Description</h3>

<p>Summarizes and prints a <code>ics2</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ics2'
summary(object, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ics2_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code>.</p>
</td></tr>
<tr><td><code id="summary.ics2_+3A_digits">digits</code></td>
<td>
<p> number of digits for the numeric output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics2-class">ics2-class</a></code> and <code><a href="#topic+ics2">ics2</a></code></p>

<hr>
<h2 id='tM'> Joint M-estimation of Location and Scatter for a Multivariate t-distribution </h2><span id='topic+tM'></span>

<h3>Description</h3>

<p>Implements three EM algorithms to M-estimate the location vector and scatter matrix of a multivariate t-distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tM(X, df = 1, alg = "alg3", mu.init = NULL, V.init = NULL,
        gamma.init = NULL, eps = 1e-06, maxiter = 100,
        na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tM_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe. </p>
</td></tr>
<tr><td><code id="tM_+3A_df">df</code></td>
<td>
<p> assumed degrees of freedom of the t-distribution. Default is <code>1</code> which corresponds to the Cauchy distribution.</p>
</td></tr>
<tr><td><code id="tM_+3A_alg">alg</code></td>
<td>
<p>specifies which algorithm to use. Options are <code>alg1</code>, <code>alg2</code> or <code>alg3</code>. <code>alg3</code> is the default.</p>
</td></tr>
<tr><td><code id="tM_+3A_mu.init">mu.init</code></td>
<td>
<p>initial value for the location vector if available.</p>
</td></tr>
<tr><td><code id="tM_+3A_v.init">V.init</code></td>
<td>
<p>initial value for the scatter matrix if available.</p>
</td></tr>
<tr><td><code id="tM_+3A_gamma.init">gamma.init</code></td>
<td>
<p> initial value for gamma if available. Only needed for <code>alg2</code>.</p>
</td></tr>
<tr><td><code id="tM_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="tM_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="tM_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the EM algorithms described in Kent et al. (1994). The norm used to define convergence is as in Arslan et al. (1995).
</p>
<p>Algorithm 1 is valid for all degrees of freedom <code>df</code> &gt; 0. Algorithm 2 is well defined only for degrees of freedom <code>df</code> &gt; 1.
Algorithm 3 is the limiting case of Algorithm 2 with degrees of freedom <code>df</code> = 1.
</p>
<p>The performance of the algorithms are compared in Arslan et al. (1995).
</p>
<p>Note that <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> in the MASS package implements also a covariance estimate for a multivariate t-distribution.
That function provides for example also the possibility to fix the location. It requires however that the degrees of freedom exceeds 2.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>vector with the estimated loaction.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>matrix of the estimated scatter.</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>estimated value of gamma. Only present when <code>alg2</code> is used.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Kent, J.T., Tyler, D.E. and Vardi, Y. (1994),  A curious likelihood identity for the multivariate t-distribution, <em>Communications in Statistics, Simulation and Computation</em>, <b>23</b>,  441&ndash;453.
&lt;doi:10.1080/03610919408813180&gt;. </cite>
</p>
<p><cite>Arslan, O., Constable, P.D.L.  and Kent, J.T. (1995), Convergence behaviour of the EM algorithm for the multivariate t-distribution, <em>Communications in Statistics, Theory and Methods</em>, <b>24</b>, 2981&ndash;3000. &lt;doi:10.1080/03610929508831664&gt;.</cite></p>


<h3>See Also</h3>

  <p><code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvt(100, cov.matrix, 1)
tM(X)
rm(.Random.seed)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
