<!DOCTYPE html><html lang="en"><head><title>Help for package LNIRT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LNIRT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>.onAttach start message</p></a></li>
<li><a href='#AmsterdamChess'><p>Amsterdam Chess Test (ACT) data</p></a></li>
<li><a href='#CredentialForm1'><p>Credential Form data</p></a></li>
<li><a href='#LNIRT'><p>Log-normal response time IRT modelling</p></a></li>
<li><a href='#LNIRTQ'><p>Log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)</p></a></li>
<li><a href='#LNRT'><p>Log-normal response time modelling</p></a></li>
<li><a href='#LNRTQ'><p>Log-normal response time modelling with variable person speed (intercept, trend, quadratic)</p></a></li>
<li><a href='#simLNIRT'><p>Simulate data for log-normal response time IRT modelling</p></a></li>
<li><a href='#simLNIRTQ'><p>Simulate data for log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)</p></a></li>
<li><a href='#summaryIRTQ'><p>Summary Function for LNIRTQ</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>LogNormal Response Time Item Response Theory Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Paul Fox, Konrad Klotzke, Rinke Klein Entink </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Konrad Klotzke &lt;omd.bms.utwente.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, methods, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, mcmcse</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows the simultaneous analysis of responses and response times in an Item Response Theory (IRT) modelling framework. Supports variable person speed functions (intercept, trend, quadratic), and covariates for item and person (random) parameters. Data missing-by-design can be specified. Parameter estimation is done with a MCMC algorithm. LNIRT replaces the package CIRT, which was written by Rinke Klein Entink. For reference, see the paper by Fox, Klein Entink and Van der Linden (2007), "Modeling of Responses and Response Times with the Package cirt", Journal of Statistical Software, &lt;<a href="https://doi.org/10.18637%2Fjss.v020.i07">doi:10.18637/jss.v020.i07</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-19 18:08:38 UTC; kk</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-19 18:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>.onAttach start message</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>.onAttach start message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>defunct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>

<hr>
<h2 id='AmsterdamChess'>Amsterdam Chess Test (ACT) data</h2><span id='topic+AmsterdamChess'></span>

<h3>Description</h3>

<p>Responses and response time data from the Amsterdam Chess Test (ACT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AmsterdamChess)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 259 rows and 81 variables.
</p>


<h3>Details</h3>

<p>Variables:
</p>

<ul>
<li><p> ELO: Standardized ELO rating (numeric)
</p>
</li>
<li><p> Y1-Y40: item correct score (1 or 0) for scored items 1 – 40 (numeric)
</p>
</li>
<li><p> RT1-RT40: response time (seconds) for scored items 1 – 40 (numeric)
</p>
</li></ul>

<p>Three components of chess expertise are measured: 
</p>

<ul>
<li><p> Tactical skill (20 items): item 1-20
</p>
</li>
<li><p> Positional skill (10 items): item 21-30
</p>
</li>
<li><p> End-game skill (10 items): item 31-40
</p>
</li></ul>



<h3>References</h3>

<p>van der Maas, H. L., &amp; Wagenmakers, E. J. (2005). A psychometric analysis of chess expertise. The American journal of psychology, 118(1), 29-60.
(<a href="https://pubmed.ncbi.nlm.nih.gov/15822609">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  ###
  ### EXAMPLE APPLICATION AMSTERDAM CHESS DATA van der Maas and Wagenmakers (2005).
  ###
  
  library(LNIRT)
  data(AmsterdamChess)
  head(AmsterdamChess)
  
  N &lt;- nrow(AmsterdamChess)
  Y &lt;-as.matrix(AmsterdamChess[c(which(colnames(AmsterdamChess)=="Y1")
                                 :which(colnames(AmsterdamChess)=="Y40"))])
  K &lt;- ncol(Y)
  ## replace missing 9 with NA
  Y[Y==9] &lt;- NA
  ## Test takers with NAs
  ## Y[147,]
  ## Y[201,]
  ## Y[209,]
  
  RT &lt;- as.matrix(AmsterdamChess[c(which(colnames(AmsterdamChess)=="RT1")
                                   :which(colnames(AmsterdamChess)=="RT40"))])
  ## replace missing 10000.000 with NA
  RT[RT==10000.000] &lt;- NA
  RT&lt;-log(RT) #logarithm of RTs
  
  # Define Time Scale
  X &lt;- 1:K
  X &lt;- (X - 1)/K
  
  set.seed(12345) ## used to obtain the results reported in the paper ##
  outchess &lt;- LNIRTQ(Y=Y,RT=RT,X=X,XG=10000)
  summary(outchess)
  
  ## Check MCMC convergence
  ##
  ## check several MCMC chains 
  ## 
  
  library(mcmcse)
  ess(outchess1$MAB[1001:10000,1,1]) ## effective sample size
  mcse(outchess1$MAB[1001:10000,1,1], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(outchess$MAB[1001:10000,1,2]) ## effective sample size
  mcse(outchess$MAB[1001:10000,1,2], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(outchess$MAB[1001:10000,1,3]) ## effective sample size
  mcse(outchess$MAB[1001:10000,1,3], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(outchess$MAB[1001:10000,1,4]) ## effective sample size
  mcse(outchess$MAB[1001:10000,1,4], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(outchess$MSP[1001:10000,1,4]) ## effective sample size
  mcse(outchess$MSP[1001:10000,1,4], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(outchess$MSI[1001:10000,1,4]) ## effective sample size
  mcse(outchess$MSI[1001:10000,1,4], size = 100
       , g = NULL,method = "bm", warn = FALSE) #standard error
  
  ## Convergence Checks
  library(coda) 
  summary(as.mcmc(outchess$MAB[1001:10000,1,1]))
  summary(as.mcmc(outchess$MAB[1001:10000,1,4]))
  summary(as.mcmc(outchess$MSI[1001:10000,1,1]))
  summary(as.mcmc(outchess$MSI[1001:10000,1,4]))
  summary(as.mcmc(outchess$MSP[1001:10000,1,4]))
  summary(as.mcmc(outchess$MSP[1001:10000,1,1]))
  
  ## check some chains on convergence
  geweke.diag(as.mcmc(outchess$MAB[1001:10000,1,1]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(outchess$MAB[1001:10000,1,1]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(outchess$MAB[1001:10000,1,1]), eps=0.1, pvalue=0.05)
  
  geweke.diag(as.mcmc(outchess$MSI[1001:10000,1,1]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(outchess$MSI[1001:10000,1,1]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(outchess$MSI[1001:10000,1,1]), eps=0.1, pvalue=0.05)
  
  geweke.diag(as.mcmc(outchess$MSP[1001:10000,3,3]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(outchess$MSP[1001:10000,3,3]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(outchess$MSP[1001:10000,3,3]), eps=0.1, pvalue=0.05)
  
  ## complete missing data
  outchess$Mtheta[147,]
  
  ######################################################################
  ### THIS PART IS NOT DISCUSSED IN THE PAPER                        ###
  ######################################################################
  
  # PLOT PERSON PARAMETERS
  # ABILITY VS SPEED
  
  par(mar=c(5, 5, 2,4), xpd=F)
  layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE), widths=c(2,2), heights=c(2,2))
  
  plot(outchess$Mtheta[,1],outchess$Mtheta[,2]
       ,xlab=expression(paste("Ability"~~(theta)))
       ,ylab=expression(paste("Intercept"~~(zeta[0]))),
       xlim=c(-2,2),ylim=c(-1,1),bty="l",cex.lab=1.5,cex.axis=1.25)
  abline(lm(outchess$Mtheta[,2]~outchess$Mtheta[,1])) 
  abline(h = 0,lty = 2)
  
  plot(outchess$Mtheta[,1],outchess$Mtheta[,3]
       ,xlab=expression(paste("Ability"~~(theta)))
       ,ylab=expression(paste("Linear slope"~~(zeta[1]))),
       xlim=c(-2,2),ylim=c(-1,1),bty="l",cex.lab=1.5,cex.axis=1.25)
  abline(lm(outchess$Mtheta[,3]~outchess$Mtheta[,1]))
  abline(h = 0,lty = 2)
  
  plot(outchess$Mtheta[,1],outchess$Mtheta[,4]
       ,xlab=expression(paste("Ability"~~(theta)))
       ,ylab=expression(paste("Quadratic slope"~~(zeta[2]))),
       xlim=c(-2,2),ylim=c(-1,1),bty="l",cex.lab=1.5,cex.axis=1.25)
  abline(lm(outchess$Mtheta[,4]~outchess$Mtheta[,1]))
  abline(h = 0,lty = 2)
  
  plot(outchess$Mtheta[,3],outchess$Mtheta[,4]
       ,xlab=expression(paste("Linear slope"~~(zeta[1])))
       ,ylab=expression("Quadratic slope"~~paste((zeta[2]))),
       xlim=c(-0.5,1),ylim=c(-0.5,0.5),bty="l",cex.lab=1.5,cex.axis=1.25)
  abline(lm(outchess$Mtheta[,4]~outchess$Mtheta[,3]))
  abline(h = 0,lty = 2)
  
  ### include residual analysis ###
  
  set.seed(12345)
  outchessr &lt;- LNIRTQ(Y=Y,RT=RT,X=X,XG=10000,burnin=10,XGresid=1000,resid=TRUE)
  summary(outchessr)
  
  ## plot of person-fit scores for RT patterns
  plot(outchessr$lZPT,outchessr$lZP)
  

## End(Not run)
</code></pre>

<hr>
<h2 id='CredentialForm1'>Credential Form data</h2><span id='topic+CredentialForm1'></span>

<h3>Description</h3>

<p>Responses and response time data from the credential data set of Cizek and Wollack (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CredentialForm1)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 1636 rows and 610 variables.
</p>


<h3>Details</h3>

<p>Variables:
</p>

<ul>
<li><p> EID: Examinee ID (character)
</p>
</li>
<li><p> FormID: Test form name (character)
</p>
</li>
<li><p> Flagged: 1/0 variable to indicate whether the test vendor suspects the examinee may have engaged in inappropriate behavior (numeric)
</p>
</li>
<li><p> Pretest: Pretest item set assigned to candidate (numeric) 
</p>
</li>
<li><p> Attempt: Count of the attempt number for the candidate. A score of 1 indicates that candidate is a new, first-time examinee. Any examinee sitting for the exam for the fourth time or more is marked as 4+ (character)
</p>
</li>
<li><p> Country: Country where candidate was educated (character)
</p>
</li>
<li><p> StateCode: 2-digit code corresponding to the state in which the Candidate applied for licensure (numeric)
</p>
</li>
<li><p> School_ID: 4-digit code corresponding to the particular institution in which the Candidate received his/her educational training (numeric)
</p>
</li>
<li><p> Cent_id:  4-digit code corresponding to the particular testing center in which the Candidate sat for the exam (numeric)
</p>
</li>
<li><p> Tot_time: The number of seconds testing (numeric)
</p>
</li>
<li><p> iresp.1-170: item responses (1 to 4 or NA) for scored items 1 – 170 (numeric)
</p>
</li>
<li><p> iresp.171-180: item responses (1 to 4 or NA) for 10 pilot items for pilot set 6 or 9 (numeric)
</p>
</li>
<li><p> iresp.181-190: item responses (1 to 4 or NA) for 10 pilot items for pilot set 7 or 10 (numeric)
</p>
</li>
<li><p> iresp.191-200: item responses (1 to 4 or NA) for 10 pilot items for pilot set 8 or 11 (numeric)
</p>
</li>
<li><p> iraw.1-170: item correct score (1 or 0) for scored items 1 – 170 (numeric)
</p>
</li>
<li><p> iraw.171-180: item correct score (1 or 0) for 10 pilot items for pilot set 6 or 9 (numeric)
</p>
</li>
<li><p> iraw.181-190: item correct score (1 or 0) for 10 pilot items for pilot set 7 or 10 (numeric)
</p>
</li>
<li><p> iraw.191-200: item correct score (1 or 0) for 10 pilot items for pilot set 8 or 11 (numeric)
</p>
</li>
<li><p> idur.1-170: response time (in seconds) for scored items 1 – 170 (numeric)
</p>
</li>
<li><p> idur.171-180: response time (in seconds) for 10 pilot items for pilot set 6 or 9 (numeric)
</p>
</li>
<li><p> idur.181-190: response time (in seconds) for 10 pilot items for pilot set 7 or 10 (numeric)
</p>
</li>
<li><p> idur.191-200: response time (in seconds) for 10 pilot items for pilot set 8 or 11 (numeric)
</p>
</li></ul>



<h3>References</h3>

<p>Cizek GJ, Wollack JA (eds.) (2016). Handbook of Quantitative Methods for Detecting Cheating on Tests. Routledge.
(<a href="https://www.taylorfrancis.com/books/handbook-quantitative-methods-detecting-cheating-tests-gregory-cizek-james-wollack/e/10.4324/9781315743097">Taylor&amp;Francis</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  ###
  ### EXAMPLE APPLICATION CREDENTIAL FORM1 DATA CIZEK and WOLLACK (2016).
  ###
  
  library(LNIRT)
  data(CredentialForm1)
  
  ### DATA OBJECTS FOR LNIRT 
  ### RA Data
  Y &lt;- as.matrix(CredentialForm1[c(which(colnames(CredentialForm1)=="iraw.1")
                                  :which(colnames(CredentialForm1)=="iraw.170"))])
  N &lt;- nrow(Y) 
  
  ### RT Data 
  RT&lt;-as.matrix(CredentialForm1[c(which(colnames(CredentialForm1)=="idur.1")
                                  :which(colnames(CredentialForm1)=="idur.170"))])
  RT[RT==0]&lt;-NA ## zero RTs are coded as missing values
  RT&lt;-log(RT) ## logarithmic transformation of RT
  
  ## RUN LNIRT MODEL 0
  set.seed(12345) ## used to obtain the results reported in the paper ##
  out0 &lt;- LNIRT(RT=RT,Y=Y,XG=5000,burnin=10,ident=2)
  summary(out0)
  
  ## Check MCMC convergence
  
  library(mcmcse)
  ##
  ## check several MCMC chains 
  ## 
  ## effective sample size and effective sample size
  ess(out0$MCMC.Samples$Cov.Person.Ability.Speed[1001:5000]) ## effective sample size
  mcse(out0$MCMC.Samples$Cov.Person.Ability.Speed[1001:5000]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Var.Person.Ability[1001:5000]) ## effective sample size
  mcse(out0$MCMC.Samples$Var.Person.Ability[1001:5000]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Var.Person.Speed[1001:5000]) ## effective sample size
  mcse(out0$MCMC.Samples$Var.Person.Speed[1001:5000]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Item.Discrimination[1001:5000,155]) ## effective sample size
  mcse(out0$MCMC.Samples$Item.Discrimination[1001:5000,155]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Time.Discrimination[1001:5000,1]) ## effective sample size
  mcse(out0$MCMC.Samples$Time.Discrimination[1001:5000,1]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Person.Ability[1001:5000,1]) ## effective sample size
  mcse(out0$MCMC.Samples$Person.Ability[1001:5000,1]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ess(out0$MCMC.Samples$Person.Speed[1001:5000,1]) ## effective sample size
  mcse(out0$MCMC.Samples$Person.Speed[1001:5000,1]
       , size = 100, g = NULL,method = "bm", warn = FALSE) #standard error
  
  ## Convergence Checks
  library(coda) 
  summary(as.mcmc(out0$MCMC.Samples$Cov.Person.Ability.Speed[1001:5000]))
  summary(as.mcmc(out0$MCMC.Samples$Var.Person.Ability[1001:5000]))
  summary(as.mcmc(out0$MCMC.Samples$Var.Person.Speed[1001:5000]))
  summary(as.mcmc(out0$MCMC.Samples$Item.Discrimination[1001:5000,155]))
  summary(as.mcmc(out0$MCMC.Samples$Time.Discrimination[1001:5000,1]))
  summary(as.mcmc(out0$MCMC.Samples$Person.Ability[1001:5000,1]))
  summary(as.mcmc(out0$MCMC.Samples$Person.Speed[1001:5000,1]))
  
  ## check some chains on convergence
  geweke.diag(as.mcmc(out0$MCMC.Samples$Cov.Person.Ability.Speed[500:5000]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(out0$MCMC.Samples$Cov.Person.Ability.Speed[500:5000]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(out0$MCMC.Samples$Cov.Person.Ability.Speed[500:5000], eps=0.1, pvalue=0.05))
  
  geweke.diag(as.mcmc(out0$MCMC.Samples$Item.Discrimination[500:5000,155]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(out0$MCMC.Samples$Item.Discrimination[500:5000,155]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(out0$MCMC.Samples$Item.Discrimination[500:5000,155]), eps=0.1, pvalue=0.05)
  
  geweke.diag(as.mcmc(out0$MCMC.Samples$Person.Ability[500:5000,1]), frac1=0.1, frac2=0.5)
  geweke.plot(as.mcmc(out0$MCMC.Samples$Person.Ability[500:5000,1]), frac1=0.1, frac2=0.5)
  heidel.diag(as.mcmc(out0$MCMC.Samples$Person.Ability[500:5000,1]), eps=0.1, pvalue=0.05)
  
  ## Item parameter estimates
  
  min(apply(out0$MAB[500:5000,,1],2,mean))
  max(apply(out0$MAB[500:5000,,1],2,mean))
  
  min(apply(out0$MAB[500:5000,,2],2,mean))
  max(apply(out0$MAB[500:5000,,2],2,mean))
  
  min(apply(out0$MAB[500:5000,,3],2,mean))
  max(apply(out0$MAB[500:5000,,3],2,mean))
  
  min(apply(out0$MAB[500:5000,,4],2,mean))
  max(apply(out0$MAB[500:5000,,4],2,mean))
  
  plot(apply(out0$MAB[500:5000,,4],2,mean),(apply(RT,2,mean,na.rm=TRUE)))
  
  ### Explanatory Variables Test-takers
  XFT &lt;- data.frame(CredentialForm1[1:10],stringsAsFactors=TRUE) #Background Variables 
  XFT$Tot_time &lt;- (XFT$Tot_time-mean(XFT$Tot_time))/sqrt(var(XFT$Tot_time))
  
  ## DUMMY CODING FOR CATEGORICAL PREDICTORS
  ## Pretest Groups
  XFT$Pgroup &lt;- matrix(0,ncol=2,nrow=N)
  XFT$Pgroup[XFT$Pretest==6,1] &lt;- -1  
  XFT$Pgroup[XFT$Pretest==6,2] &lt;- -1
  XFT$Pgroup[XFT$Pretest==7,1] &lt;- 1
  XFT$Pgroup[XFT$Pretest==8,2] &lt;- 1
  
  ## Countries 
  XFT$Cgroup &lt;- matrix(0,ncol=3,nrow=N)
  XFT$Cgroup[XFT$Country=="USA",1] &lt;- 1 
  XFT$Cgroup[XFT$Country=="Philippines",2] &lt;- 1
  XFT$Cgroup[XFT$Country=="India",3] &lt;- 1
  XFT$Cgroup[c(XFT$Country!="USA" &amp; XFT$Country!="India" &amp; XFT$Country!="Philippines"),1:3] &lt;- -1
  
  XA &lt;- matrix(unlist(XFT[,c("Pgroup","Tot_time")]),ncol=3,nrow=N)
  XT &lt;- matrix(unlist(XFT[,c("Pgroup")]),ncol=2,nrow=N)
  
  ## RUN LNIRT MODEL 1 (Pretest and total test time)
  ## Include residual analysis 
  set.seed(12345) ## used to obtain the results reported in the paper ##
  out1 &lt;- LNIRT(RT=RT,Y=Y,XG=5000,XPA=XA,XPT=XT,residual=TRUE)
  summary(out1)
  
  
  ######################################################################
  ### THIS PART IS NOT DISCUSSED IN THE PAPER                        ###
  ######################################################################
  
  ## RUN LNIRT MODEL 2 (Pretest and Country)
  XA &lt;- matrix(unlist(XFT[,c("Pgroup","Cgroup")]),ncol=5,nrow=N)
  XT &lt;- matrix(unlist(XFT[,c("Pgroup","Cgroup")]),ncol=5,nrow=N)
  
  set.seed(12345) ## 
  out2 &lt;- LNIRT(RT=RT,Y=Y,XG=5000,XPA=XA,XPT=XT)
  summary(out2)
  
  XA &lt;- matrix(unlist(XFT[,c("Pgroup","Cgroup","Tot_time")]),ncol=6,nrow=N)
  XT &lt;- matrix(unlist(XFT[,c("Pgroup","Cgroup")]),ncol=5,nrow=N)
  
  ## RUN LNIRT MODEL 3 
  set.seed(12345) ## 
  out3 &lt;- LNIRT(RT=RT,Y=Y,XG=5000,XPA=XA,XPT=XT)
  summary(out3)
  
  #########################################################################
  #########################################################################
  #########################################################################
  
  
  ######################################################################
  ### THIS PART IS DISCUSSED IN THE PAPER                            ###
  ######################################################################
  
  ## Subsection "Planned Missing By Design"
  ## Include pretest item data
  MBDM&lt;-matrix(rep(0,1636*200),nrow=1636,ncol=200)
  MBDM[XFT$Pretest==6,171:180]&lt;-1
  MBDM[XFT$Pretest==7,181:190]&lt;-1
  MBDM[XFT$Pretest==8,191:200]&lt;-1
  MBDM[,1:170]&lt;-1
  
  Yt &lt;- CredentialForm1[c(which(colnames(CredentialForm1)=="iraw.1")
                          :which(colnames(CredentialForm1)=="iraw.200"))]
  ## transform pretest data to numeric
  Yt[,171:200] &lt;- unlist(lapply(Yt[,171:200]
                                ,function(x) as.numeric(x))) #warnings about NA can be ignored
  Yt &lt;- as.matrix(Yt,ncol=200,nrow=1636)
  
  RTt &lt;- (CredentialForm1[as.numeric(c(which(colnames(CredentialForm1)=="idur.1")
                                       :which(colnames(CredentialForm1)=="idur.200")))])
  RTt[,171:200] &lt;- unlist(lapply(RTt[,171:200]
                   , function(x) as.numeric(as.character(x)))) #warnings about NA can be ignored
  RTt[RTt==0] &lt;- NA ## zero RTs are coded as missing values
  RTt &lt;- log(RTt) ## logarithmic transformation of RT
  RTt &lt;- as.matrix(RTt,ncol=200,nrow=1636)
  
  # To fit the model, item discrimination parameters are restricted to one.  
  alpha1&lt;-rep(1,200) ### Pre-defined item discrimination parameters
  ## RUN LNIRT MODEL 4
  set.seed(12345) ## used to obtain the results reported in the paper ##
  out4 &lt;- LNIRT(RT=RTt,Y=Yt,XG=5000,alpha=alpha1,MBDY=MBDM,MBDT=MBDM)
  summary(out4)
  
  ### Subsection "Model-Fit Analysis"
  ### Return to output of out1
  
  #report fit results
  summary(out1)
  
  ## estimated average residual variance
  mean(out1$Msigma2[500:5000,])
  
  #recoding of number of zero attempts 
  XFT$Attempt[XFT$Attempt==0] &lt;- 1
  
  ## explain heterogeneity in person-fit statistics RA and RT
  summary(lm(out1$PFl ~ as.factor(XFT$Attempt)+(XFT$Cgroup)+(XFT$Pgroup)))
  summary(lm(out1$lZPT ~ as.factor(XFT$Attempt)+(XFT$Cgroup)+(XFT$Pgroup)))
  
  ### overview plot of person fit RA versus person-fit RT per country 
  dev.new()
  plot(out1$PFl,out1$lZPT,xlab="Person-fit Statistic RA",ylab="Person-fit Statistic RT",
       col="black",cex=.5,bty="l",xlim=c(-3,3)
       , ylim=c(0,500),cex.main=.8,cex.axis=.7,cex.lab=.8,pch=15)
  ## US
  set1 &lt;- which(XFT$Country=="USA")
  points(out1$PFl[set1],out1$lZPT[set1],col="blue",pch=10,cex=.5)
  ## India
  set2 &lt;- which(XFT$Country=="India")
  points(out1$PFl[set2],out1$lZPT[set2],col="red",pch=13,cex=.5)
  ## Philippines
  set3 &lt;- which(XFT$Country=="Philippines")
  points(out1$PFl[set3],out1$lZPT[set3],col="green",pch=16,cex=.5)
  abline(h = qchisq(.95, df= 170),lty = 2,col="red")
  abline(v = qnorm(.95),lty = 2,col="red")
  legend(-3,500,c("India","US","Philippines","Other"), 
         col=c("red","blue","green","black"),pch = c(13,10,16,15), bg = "gray95",cex=.7)
  
  ###################################################################################
  ###################################################################################
  ###################################################################################
  

## End(Not run)
</code></pre>

<hr>
<h2 id='LNIRT'>Log-normal response time IRT modelling</h2><span id='topic+LNIRT'></span>

<h3>Description</h3>

<p>Log-normal response time IRT modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LNIRT(
  RT,
  Y,
  data,
  XG = 1000,
  burnin = 10,
  XGresid = 1000,
  guess = FALSE,
  par1 = FALSE,
  residual = FALSE,
  td = TRUE,
  WL = FALSE,
  ident = 2,
  alpha,
  beta,
  phi,
  lambda,
  XPA = NULL,
  XPT = NULL,
  XIA = NULL,
  XIT = NULL,
  MBDY = NULL,
  MBDT = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LNIRT_+3A_rt">RT</code></td>
<td>
<p>a Person-x-Item matrix of log-response times (time spent on solving an item).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_y">Y</code></td>
<td>
<p>a Person-x-Item matrix of responses.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_data">data</code></td>
<td>
<p>either a list or a simLNIRT object containing the response time and response matrices
and optionally the predictors for the item and person parameters.
If a simLNIRT object is provided, in the summary the simulated item and time parameters are shown alongside of the estimates.
If the required variables cannot be found in the list, or if no data object is given, then the variables are taken
from the environment from which LNIRT is called.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xg">XG</code></td>
<td>
<p>the number of MCMC iterations to perform (default: 1000).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_burnin">burnin</code></td>
<td>
<p>the percentage of MCMC iterations to discard as burn-in period (default: 10).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xgresid">XGresid</code></td>
<td>
<p>the number of MCMC iterations to perform before residuals are computed (default: 1000).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_guess">guess</code></td>
<td>
<p>include guessing parameters in the IRT model (default: false).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_par1">par1</code></td>
<td>
<p>use alternative parameterization (default: false).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_residual">residual</code></td>
<td>
<p>compute residuals, &gt;1000 iterations are recommended (default: false).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_td">td</code></td>
<td>
<p>estimate the time-discrimination parameter(default: true).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_wl">WL</code></td>
<td>
<p>define the time-discrimination parameter as measurement error variance parameter (default: false).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_ident">ident</code></td>
<td>
<p>set identification rule (default: 2).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_alpha">alpha</code></td>
<td>
<p>an optional vector of pre-defined item-discrimination parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_beta">beta</code></td>
<td>
<p>an optional vector of pre-defined item-difficulty parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_phi">phi</code></td>
<td>
<p>an optional vector of predefined time discrimination parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_lambda">lambda</code></td>
<td>
<p>an optional vector of predefined time intensity parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xpa">XPA</code></td>
<td>
<p>an optional matrix of predictors for the person ability parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xpt">XPT</code></td>
<td>
<p>an optional matrix of predictors for the person speed parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xia">XIA</code></td>
<td>
<p>an optional matrix of predictors for the item-difficulty parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_xit">XIT</code></td>
<td>
<p>an optional matrix of predictors for the item-intensity parameters.</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_mbdy">MBDY</code></td>
<td>
<p>an optional indicator matrix for response missings due to the test design (0: missing by design, 1: not missing by design).</p>
</td></tr>
<tr><td><code id="LNIRT_+3A_mbdt">MBDT</code></td>
<td>
<p>an optional indicator matrix for response time missings due to the test design (0: missing by design, 1: not missing by design).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LNIRT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Log-normal response time IRT modelling
data &lt;- simLNIRT(N = 500, K = 20, rho = 0.8, WL = FALSE)
out &lt;- LNIRT(RT = RT, Y = Y, data = data, XG = 1500, residual = TRUE, WL = FALSE)
summary(out) # Print results
out$Post.Means$Item.Difficulty # Extract posterior mean estimates

library(coda)
mcmc.object &lt;- as.mcmc(out$MCMC.Samples$Item.Difficulty) # Extract MCMC samples for coda
summary(mcmc.object)
plot(mcmc.object)

## End(Not run)
</code></pre>

<hr>
<h2 id='LNIRTQ'>Log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)</h2><span id='topic+LNIRTQ'></span>

<h3>Description</h3>

<p>Log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LNIRTQ(
  Y,
  RT,
  X,
  data,
  XG = 1000,
  burnin = 10,
  XGresid = 1000,
  residual = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LNIRTQ_+3A_y">Y</code></td>
<td>
<p>a Person-x-Item matrix of responses.</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_rt">RT</code></td>
<td>
<p>a Person-x-Item matrix of log-response times (time spent on solving an item).</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_x">X</code></td>
<td>
<p>explanatory (time) variables for random person speed (default: (1:N.items - 1)/N.items).</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_data">data</code></td>
<td>
<p>either a list or a simLNIRTQ object containing the response time and response matrices
and optionally the predictors for the item and person parameters.
If a simLNIRTQ object is provided, in the summary the simulated item and time parameters are shown alongside of the estimates.
If the required variables cannot be found in the list, or if no data object is given, then the variables are taken
from the environment from which LNIRTQ is called.</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_xg">XG</code></td>
<td>
<p>the number of MCMC iterations to perform (default: 1000).</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_burnin">burnin</code></td>
<td>
<p>the percentage of MCMC iterations to discard as burn-in period (default: 10).</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_xgresid">XGresid</code></td>
<td>
<p>the number of MCMC iterations to perform before residuals are computed (default: 1000).</p>
</td></tr>
<tr><td><code id="LNIRTQ_+3A_residual">residual</code></td>
<td>
<p>compute residuals, &gt;1000 iterations are recommended (default: false).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LNIRTQ.
</p>

<hr>
<h2 id='LNRT'>Log-normal response time modelling</h2><span id='topic+LNRT'></span>

<h3>Description</h3>

<p>Log-normal response time modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LNRT(
  RT,
  data,
  XG = 1000,
  burnin = 10,
  XGresid = 1000,
  residual = FALSE,
  td = TRUE,
  WL = FALSE,
  XPT = NULL,
  XIT = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LNRT_+3A_rt">RT</code></td>
<td>
<p>a Person-x-Item matrix of log-response times (time spent on solving an item).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_data">data</code></td>
<td>
<p>either a list or a simLNIRT object containing the response time matrix.
If a simLNIRT object is provided, in the summary the simulated time parameters are shown alongside of the estimates.
If the RT variable cannot be found in the list, or if no data object is given, then the RT variable is taken
from the environment from which LNRT is called.</p>
</td></tr>
<tr><td><code id="LNRT_+3A_xg">XG</code></td>
<td>
<p>the number of MCMC iterations to perform (default: 1000).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_burnin">burnin</code></td>
<td>
<p>the percentage of MCMC iterations to discard as burn-in period (default: 10).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_xgresid">XGresid</code></td>
<td>
<p>the number of MCMC iterations to perform before residuals are computed (default: 1000).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_residual">residual</code></td>
<td>
<p>compute residuals, &gt;1000 iterations are recommended (default: false).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_td">td</code></td>
<td>
<p>estimate the time-discrimination parameter (default: true).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_wl">WL</code></td>
<td>
<p>define the time-discrimination parameter as measurement error variance parameter (default: false).</p>
</td></tr>
<tr><td><code id="LNRT_+3A_xpt">XPT</code></td>
<td>
<p>an optional matrix of predictors for the person speed parameters.</p>
</td></tr>
<tr><td><code id="LNRT_+3A_xit">XIT</code></td>
<td>
<p>an optional matrix of predictors for the item time intensity parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LNRT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Log-normal response time modelling
data &lt;- simLNIRT(N = 500, K = 20, rho = 0.8, WL = FALSE)
out &lt;- LNRT(RT = RT, data = data, XG = 1500, residual = TRUE, td = TRUE, WL = FALSE)
summary(out) # Print results
out$Post.Means$Time.Intensity # Extract posterior mean estimates

library(coda)
mcmc.object &lt;- as.mcmc(out$MCMC.Samples$Time.Intensity) # Extract MCMC samples for coda
summary(mcmc.object)
plot(mcmc.object)

## End(Not run)
</code></pre>

<hr>
<h2 id='LNRTQ'>Log-normal response time modelling with variable person speed (intercept, trend, quadratic)</h2><span id='topic+LNRTQ'></span>

<h3>Description</h3>

<p>Log-normal response time modelling with variable person speed (intercept, trend, quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LNRTQ(RT, X, data, XG = 1000, burnin = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LNRTQ_+3A_rt">RT</code></td>
<td>
<p>a Person-x-Item matrix of log-response times (time spent on solving an item).</p>
</td></tr>
<tr><td><code id="LNRTQ_+3A_x">X</code></td>
<td>
<p>explanatory (time) variables for random person speed (default: (1:N.items - 1)/N.items).</p>
</td></tr>
<tr><td><code id="LNRTQ_+3A_data">data</code></td>
<td>
<p>either a list or a simLNIRTQ object containing the response time matrix.
If a simLNIRTQ object is provided, in the summary the simulated time parameters are shown alongside of the estimates.
If the RT variable cannot be found in the list, or if no data object is given, then the RT variable is taken
from the environment from which LNRTQ is called.</p>
</td></tr>
<tr><td><code id="LNRTQ_+3A_xg">XG</code></td>
<td>
<p>the number of MCMC iterations to perform (default: 1000).</p>
</td></tr>
<tr><td><code id="LNRTQ_+3A_burnin">burnin</code></td>
<td>
<p>the percentage of MCMC iterations to discard as burn-in period (default: 10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LNRTQ.
</p>

<hr>
<h2 id='simLNIRT'>Simulate data for log-normal response time IRT modelling</h2><span id='topic+simLNIRT'></span>

<h3>Description</h3>

<p>Simulate data for log-normal response time IRT modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLNIRT(N, K, rho, td = FALSE, WL = FALSE, kpa, kpt, kia, kit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simLNIRT_+3A_n">N</code></td>
<td>
<p>the number of persons.</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_k">K</code></td>
<td>
<p>the number of items.</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_rho">rho</code></td>
<td>
<p>the correlation between the person ability and person speed parameter.</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_td">td</code></td>
<td>
<p>set time-discrimination to one (default: false).</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_wl">WL</code></td>
<td>
<p>define the time-discrimination parameter as measurement error variance parameter (default: false).</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_kpa">kpa</code></td>
<td>
<p>the number of predictors for the person ability parameters (optional).</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_kpt">kpt</code></td>
<td>
<p>the number of predictors for the person speed parameters (optional).</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_kia">kia</code></td>
<td>
<p>the number of predictors for the item-difficulty parameters (optional).</p>
</td></tr>
<tr><td><code id="simLNIRT_+3A_kit">kit</code></td>
<td>
<p>the number of predictors for the item time intensity parameters (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class simLNIRT.
</p>

<hr>
<h2 id='simLNIRTQ'>Simulate data for log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)</h2><span id='topic+simLNIRTQ'></span>

<h3>Description</h3>

<p>Simulate data for log-normal response time IRT modelling with variable person speed (intercept, trend, quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLNIRTQ(N, K, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simLNIRTQ_+3A_n">N</code></td>
<td>
<p>the number of persons.</p>
</td></tr>
<tr><td><code id="simLNIRTQ_+3A_k">K</code></td>
<td>
<p>the number of items.</p>
</td></tr>
<tr><td><code id="simLNIRTQ_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class simLNIRTQ.
</p>

<hr>
<h2 id='summaryIRTQ'>Summary Function for LNIRTQ</h2><span id='topic+summaryIRTQ'></span>

<h3>Description</h3>

<p>Summary Function for LNIRTQ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryIRTQ(out, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryIRTQ_+3A_out">out</code></td>
<td>
<p>a LNIRTQ object (the fitted model)</p>
</td></tr>
<tr><td><code id="summaryIRTQ_+3A_data">data</code></td>
<td>
<p>a simLNIRTQ object (the simulated data, optional)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
