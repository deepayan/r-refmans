<!DOCTYPE html><html lang="en"><head><title>Help for package rje</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rje}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#and0'><p>Fast pairwise logical operators</p></a></li>
<li><a href='#armijo'><p>Generic functions to aid finding local minima given search direction</p></a></li>
<li><a href='#combinations'><p>Combinations of Integers</p></a></li>
<li><a href='#conditionMatrix'><p>Find conditional probability table</p></a></li>
<li><a href='#cubeHelix'><p>Cube Helix colour palette</p></a></li>
<li><a href='#designMatrix'><p>Orthogonal Design Matrix</p></a></li>
<li><a href='#Dirichlet'><p>The Dirichlet Distribution</p></a></li>
<li><a href='#expit'><p>Expit and Logit.</p></a></li>
<li><a href='#fastHadamard'><p>Compute fast Hadamard-transform of vector</p></a></li>
<li><a href='#fastMobius'><p>Fast Moebius and inverse Moebius transforms</p></a></li>
<li><a href='#fsapply'><p>Fast and loose application of function over list.</p></a></li>
<li><a href='#greaterThan'><p>Comparing numerical values</p></a></li>
<li><a href='#inclusionMax'><p>Get inclusion maximal subsets from a list</p></a></li>
<li><a href='#indexBox'><p>Get indices of adjacent entries in array</p></a></li>
<li><a href='#int2set'><p>Alternate between sets and integers representing sets of integers via bits</p></a></li>
<li><a href='#interventionMatrix'><p>Calculate interventional distributions.</p></a></li>
<li><a href='#is.subset'><p>Check subset inclusion</p></a></li>
<li><a href='#is.wholenumber'><p>Determine whether number is integral or not.</p></a></li>
<li><a href='#kronPower'><p>Kronecker power of a matrix or vector</p></a></li>
<li><a href='#last'><p>Last element of a vector or list</p></a></li>
<li><a href='#marginTable'><p>Compute margin of a table faster</p></a></li>
<li><a href='#patternRepeat'><p>Complex repetitions</p></a></li>
<li><a href='#powerSet'><p>Power Set</p></a></li>
<li><a href='#printPercentage'><p>Print Percentage of Activity Completed to stdout</p></a></li>
<li><a href='#quickSort'><p>Quicksort for Partial Orderings</p></a></li>
<li><a href='#rowMins'><p>Row-wise minima and maxima</p></a></li>
<li><a href='#rprobdist'><p>Generate a joint (or conditional) probability distribution</p></a></li>
<li><a href='#schur'><p>Obtain generalized Schur complement</p></a></li>
<li><a href='#setmatch'><p>Set Operations</p></a></li>
<li><a href='#subsetMatrix'><p>Matrix of Subset Indicators</p></a></li>
<li><a href='#subsetOrder'><p>Compare sets for inclusion.</p></a></li>
<li><a href='#subtable'><p>Subset an array</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Useful Functions for Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.12.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A series of functions in some way considered useful to the author.  These 
    include methods for subsetting tables and generating indices for arrays, 
    conditioning and intervening in probability distributions, generating 
    combinations, fast transformations, and more...</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0),</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-11 13:08:55 UTC; evans</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Evans [aut, cre],
  Mathias Drton [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Evans &lt;evans@stats.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-12 01:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='and0'>Fast pairwise logical operators</h2><span id='topic+and0'></span><span id='topic+or0'></span>

<h3>Description</h3>

<p>Fast but loose implementations of AND and OR logical operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>and0(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="and0_+3A_x">x</code>, <code id="and0_+3A_y">y</code></td>
<td>
<p>logical or numerical vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns pairwise application of logical operators AND and OR.  Vectors are
recycled as usual.
</p>


<h3>Value</h3>

<p>A logical vector of length <code>max(length(x), length(y))</code> with
entries <code>x[1] &amp; x[2]</code> etc.; each entry of <code>x</code> or <code>y</code> is
<code>TRUE</code> if it is non-zero.
</p>


<h3>Note</h3>

<p>These functions should only be used with well understood vectors, and
may not deal with unusual cases correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
and0(c(0,1,0), c(1,1,0))
## Not run: 
set.seed(1234)
x = rbinom(5000, 1, 0.5)
y = rbinom(5000, 1, 0.5)

# 3 to 4 times improvement over `&amp;`
system.time(for (i in 1:5000) and0(x,y))
system.time(for (i in 1:5000) x &amp; y)

## End(Not run)

</code></pre>

<hr>
<h2 id='armijo'>Generic functions to aid finding local minima given search direction</h2><span id='topic+armijo'></span><span id='topic+coarseLine'></span>

<h3>Description</h3>

<p>Allows use of an Armijo rule or coarse line search as part of minimisation
(or maximisation) of a differentiable function of multiple arguments (via
gradient descent or similar).  Repeated application of one of these rules
should (hopefully) lead to a local minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armijo(
  fun,
  x,
  dx,
  beta = 3,
  sigma = 0.5,
  grad,
  maximise = FALSE,
  searchup = TRUE,
  adj.start = 1,
  ...
)

coarseLine(fun, x, dx, beta = 3, maximise = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="armijo_+3A_fun">fun</code></td>
<td>
<p>a function whose first argument is a numeric vector</p>
</td></tr>
<tr><td><code id="armijo_+3A_x">x</code></td>
<td>
<p>a starting value to be passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="armijo_+3A_dx">dx</code></td>
<td>
<p>numeric vector containing feasible direction for search; defaults
to <code>-grad</code> for ordinary gradient descent</p>
</td></tr>
<tr><td><code id="armijo_+3A_beta">beta</code></td>
<td>
<p>numeric value (greater than 1) giving factor by which to adjust
step size</p>
</td></tr>
<tr><td><code id="armijo_+3A_sigma">sigma</code></td>
<td>
<p>numeric value (less than 1) giving steepness criterion for move</p>
</td></tr>
<tr><td><code id="armijo_+3A_grad">grad</code></td>
<td>
<p>numeric gradient of <code>f</code> at <code>x</code> (will be estimated if
not provided)</p>
</td></tr>
<tr><td><code id="armijo_+3A_maximise">maximise</code></td>
<td>
<p>logical: if set to <code>TRUE</code> search is for a maximum
rather than a minimum.</p>
</td></tr>
<tr><td><code id="armijo_+3A_searchup">searchup</code></td>
<td>
<p>logical: if set to <code>TRUE</code> method will try to find
largest move satisfying Armijo criterion, rather than just accepting the
first it sees</p>
</td></tr>
<tr><td><code id="armijo_+3A_adj.start">adj.start</code></td>
<td>
<p>an initial adjustment factor for the step size.</p>
</td></tr>
<tr><td><code id="armijo_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coarseLine</code> performs a stepwise search and tries to find the integer
<code class="reqn">k</code> minimising <code class="reqn">f(x_k)</code> where </p>
<p style="text-align: center;"><code class="reqn">x_k = x + \beta^k dx.</code>
</p>
<p> Note
<code class="reqn">k</code> may be negative.  This is genearlly quicker and dirtier
than the Armijo rule.
</p>
<p><code>armijo</code> implements an Armijo rule for moving, which is to say that
</p>
<p style="text-align: center;"><code class="reqn">f(x_k) - f(x) &lt; - \sigma \beta^k dx \cdot \nabla_x f.</code>
</p>
<p> This has better convergence guarantees than a
simple line search, but may be slower in practice.  See Bertsekas (1999) for
theory underlying the Armijo rule.
</p>
<p>Each of these rules should be applied repeatedly to achieve convergence (see
example below).
</p>


<h3>Value</h3>

<p>A list comprising </p>
<table role = "presentation">
<tr><td><code>best</code></td>
<td>
<p>the value of the function at the final
point of evaluation</p>
</td></tr> <tr><td><code>adj</code></td>
<td>
<p>the constant in the step, i.e.
<code class="reqn">\beta^n</code></p>
</td></tr> <tr><td><code>move</code></td>
<td>
<p>the final move; i.e. <code class="reqn">\beta^n dx</code></p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>an integer indicating the result of the function; 0 = returned
OK, 1 = very small move suggested, may be at minimum already, 2 = failed to
find minimum: function evaluated to <code>NA</code> or was always larger than
<code class="reqn">f(x)</code> (direction might be infeasible), 3 = failed to find minimum:
stepsize became too small or large without satisfying rule.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>coarseLine</code>: Coarse line search
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>References</h3>

<p>Bertsekas, D.P. <em>Nonlinear programming</em>, 2nd Edition.
Athena, 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# minimisation of simple function of three variables
x = c(0,-1,4)
f = function(x) ((x[1]-3)^2 + sin(x[2])^2 + exp(x[3]) - x[3])

tol = .Machine$double.eps
mv = 1

while (mv &gt; tol) {
  # or replace with coarseLine()
  out = armijo(f, x, sigma=0.1)
  x = out$x
  mv = sum(out$move^2)
}

# correct solution is c(3,0,0) (or c(3,k*pi,0) for any integer k)
x


</code></pre>

<hr>
<h2 id='combinations'>Combinations of Integers</h2><span id='topic+combinations'></span><span id='topic+powerSetMat'></span>

<h3>Description</h3>

<p>Returns a matrix containing each possible combination of one entry from
vectors of the lengths provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinations(p)
powerSetMat(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinations_+3A_p">p</code></td>
<td>
<p>vector of non-negative integers.</p>
</td></tr>
<tr><td><code id="combinations_+3A_n">n</code></td>
<td>
<p>non-negative integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a matrix, each row being one possible combination of integers from
the vectors <code class="reqn">(0, 1, \ldots, p_i-1)</code>, for <code class="reqn">i</code>
between 1 and <code>length(p)</code>.
</p>
<p>Based on <code>bincombinations</code> from package <code>e1071</code>, which provides
the binary case.
</p>
<p><code>powerSetMat</code> is just a wrapper for <code>combinations(rep(2, n))</code>.
</p>


<h3>Value</h3>

<p>A matrix with number of columns equal to the length of <code>p</code>, and
number of rows equal to <code class="reqn">p_1 \times \cdots \times p_k</code>,
each row corresponding to a different combination.  Ordering is
reverse-lexographic.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
combinations(c(2,3,3))

powerSetMat(3)

</code></pre>

<hr>
<h2 id='conditionMatrix'>Find conditional probability table</h2><span id='topic+conditionMatrix'></span><span id='topic+conditionTable'></span><span id='topic+conditionTable2'></span><span id='topic+condition.table'></span><span id='topic+condition.table2'></span>

<h3>Description</h3>

<p>Given a numeric array or matrix (of probabilities), calculates margins of
some dimensions conditional on particular values of others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditionMatrix(
  x,
  variables,
  condition = NULL,
  condition.value = NULL,
  dim = NULL,
  incols = FALSE,
  undef = NaN
)

conditionTable(
  x,
  variables,
  condition = NULL,
  condition.value = NULL,
  undef = NaN,
  order = TRUE
)

conditionTable2(x, variables, condition, undef = NaN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditionMatrix_+3A_x">x</code></td>
<td>
<p>A numeric array.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_variables">variables</code></td>
<td>
<p>An integer vector containing the margins of interest from
<code>x</code>.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_condition">condition</code></td>
<td>
<p>An integer vector containing the dimensions of <code>x</code> to
condition on.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_condition.value">condition.value</code></td>
<td>
<p>An integer vector or list of the same length as
<code>condition</code>, containing the values to condition with.  If <code>NULL</code>,
then the full conditional distribution is returned.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_dim">dim</code></td>
<td>
<p>Integer vector containing dimensions of variables.  Assumed all
binary if not specified.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_incols">incols</code></td>
<td>
<p>Logical specifying whether not the distributions are stored as
the columns in the matrix; assumed to be rows by default.</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_undef">undef</code></td>
<td>
<p>if conditional probability is undefined, what should the value
be given as</p>
</td></tr>
<tr><td><code id="conditionMatrix_+3A_order">order</code></td>
<td>
<p>logical - if <code>TRUE</code> conditioned variables come last, if 
<code>FALSE</code> variables are in original order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conditionTable</code> calculates the marginal distribution over the
dimensions in <code>variables</code> for each specified value of the dimensions in
<code>condition</code>.  Single or multiple values of each dimension in
<code>condition</code> may be specified in <code>condition.value</code>; in the case of
multiple values, <code>condition.value</code> must be a list.
</p>
<p>The sum over the dimensions in <code>variables</code> is normalized to 1 for each
value of <code>condition</code>.
</p>
<p><code>conditionTable2</code> is just a wrapper which returns the conditional
distribution as an array of the same dimensions and ordering as the original
<code>x</code>.  Values are repeated as necessary.
</p>
<p><code>conditionMatrix</code> takes a matrix whose rows (or columns if <code>incols
= TRUE</code>) each represent a separate multivariate probability distribution and
finds the relevant conditional distribution in each case.  These are then
returned in the same format.  The order of the variables under
<code>conditionMatrix</code> is always as in the original distribution, unlike for
<code>conditionTable</code> above.
</p>
<p>The probabilities are assumed in reverse lexicographic order, as
in a flattened R array: i.e. the first value changes fastest: (1,1,1),
(2,1,1), (1,2,1), ..., (2,2,2).
</p>
<p><code>condition.table</code> and <code>condition.table2</code> are identical to
<code>conditionTable</code> and <code>conditionTable2</code>.
</p>


<h3>Value</h3>

<p><code>conditionTable</code> returns an array whose first
<code>length(variables)</code> corresponds to the dimensions in <code>variables</code>,
and the remainder (if any) to dimensions in <code>condition</code> with a
corresponding entry in <code>condition.value</code> of length &gt; 1.
</p>
<p><code>conditionTable2</code> always returns an array of the same dimensions as
<code>x</code>, with the variables in the same order.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>conditionMatrix</code>: Conditioning in matrix of distributions
</p>
</li>
<li> <p><code>conditionTable2</code>: Conditioning whilst preserving all dimensions
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Mathias Drton, Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginTable">marginTable</a></code>, <code><a href="base.html#topic+margin.table">margin.table</a></code>,
<code><a href="#topic+interventionTable">interventionTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = array(1:16, rep(2,4))
x = x/sum(x) # probability distribution on 4 binary variables x1, x2, x3, x4.

# distribution of x2, x3 given x1 = 1 and x4=2.
conditionTable(x, c(2,3), c(1,4), c(1,2))
# x2, x3 given x1 = 1,2 and x4 = 2.
conditionTable(x, c(2,3), c(1,4), list(1:2,2))

# complete conditional of x2, x3 given x1, x4
conditionTable(x, c(2,3), c(1,4))

# conditionTable2 leaves dimensions unchanged
tmp = conditionTable2(x, c(2,3), c(1,4))
aperm(tmp, c(2,3,1,4))

####
set.seed(2314)
# set of 10 2x2x2 probability distributions
x = rdirichlet(10, rep(1,8))

conditionMatrix(x, 3, 1)
conditionMatrix(x, 3, 1, 2)

</code></pre>

<hr>
<h2 id='cubeHelix'>Cube Helix colour palette</h2><span id='topic+cubeHelix'></span>

<h3>Description</h3>

<p>Cube Helix is a colour scheme designed to be appropriate for screen display
of intensity images.  The scheme is intended to be monotonically increasing
in brightness when displayed in greyscale.  This might also provide improved
visualisation for colour blindness sufferers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeHelix(n, start = 0.5, r = -1.5, hue = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubeHelix_+3A_n">n</code></td>
<td>
<p>integer giving the number of colours in the scale</p>
</td></tr>
<tr><td><code id="cubeHelix_+3A_start">start</code></td>
<td>
<p>numeric: start gives the initial angle (in radians) of the
helix</p>
</td></tr>
<tr><td><code id="cubeHelix_+3A_r">r</code></td>
<td>
<p>numeric: number of rotations of the helix over the scale; can be
negative</p>
</td></tr>
<tr><td><code id="cubeHelix_+3A_hue">hue</code></td>
<td>
<p>numeric controling the saturation of colour: 0 gives pure
greyscale, defaults to 1</p>
</td></tr>
<tr><td><code id="cubeHelix_+3A_gamma">gamma</code></td>
<td>
<p>numeric which can be used to emphasise lower or higher
intensity values, defaults to 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates a helix which moves through the RGB &quot;cube&quot;, beginning
at black (0,0,0) and finishing at white (1,1,1).  Evenly spaced points on
this helix in the cube are returned as RGB colours.  This provides a colour
palette in which intensity increases monotonically, which makes for good
transfer to greyscale displays or printouts. This also may have advantages
for colour blindeness sufferers.  See references for further details.
</p>


<h3>Value</h3>

<p>Vector of RGB colours (strings) of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Dave Green
</p>
<p>Robin Evans
</p>


<h3>References</h3>

<p>Green, D. A., 2011, A colour scheme for the display of
astronomical intensity images. <em>Bulletin of the Astronomical Society of
India</em>, 39, 289.  <a href="https://ui.adsabs.harvard.edu/abs/2011BASI...39..289G/abstract">https://ui.adsabs.harvard.edu/abs/2011BASI...39..289G/abstract</a>
</p>
<p>See Dave Green's page at <a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/">https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/</a> for
other details.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rainbow">rainbow</a></code> (for other colour palettes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cubeHelix(21)

## Not run: 
cols = cubeHelix(101)

plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
axis(side=1)
for (i in 1:101) {
  rect((i-1)/101,0,(i+0.1)/101,1, col=cols[i], lwd=0)
}

## End(Not run)

## Not run: 
require(grDevices)
# comparison with other palettes
n = 101
cols = cubeHelix(n)
heat = heat.colors(n)
rain = rainbow(n)
terr = terrain.colors(n)

plot.new()
plot.window(xlim=c(-0.5,1), ylim=c(0,4))
axis(side=1, at=c(0,1))
axis(side=2, at=1:4-0.5, labels=1:4, pos=0)
for (i in 1:n) {
  rect((i-1)/n,3,(i+0.1)/n,3.9, col=cols[i], lwd=0)
  rect((i-1)/n,2,(i+0.1)/n,2.9, col=heat[i], lwd=0)
  rect((i-1)/n,1,(i+0.1)/n,1.9, col=rain[i], lwd=0)
  rect((i-1)/n,0,(i+0.1)/n,0.9, col=terr[i], lwd=0)
}
legend(-0.6,4,legend=c("4. cube helix", "3. heat", "2. rainbow", "1. terrain"), box.lwd=0)

## End(Not run)

</code></pre>

<hr>
<h2 id='designMatrix'>Orthogonal Design Matrix</h2><span id='topic+designMatrix'></span>

<h3>Description</h3>

<p>Produces a matrix whose rows correspond to an orthogonal binary design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designMatrix(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="designMatrix_+3A_n">n</code></td>
<td>
<p>integer containing the number of elements in the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix of dimension 2^n by 2^n containing 1 and -1.
</p>


<h3>Note</h3>

<p>The output matrix has orthogonal columns and is symmetric, so (up to a constant) is its own inverse.
Operations with this matrix can be performed more efficiently using the fast Hadamard transform.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combinations">combinations</a></code>, <code><a href="#topic+subsetMatrix">subsetMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
designMatrix(3)

</code></pre>

<hr>
<h2 id='Dirichlet'>The Dirichlet Distribution</h2><span id='topic+Dirichlet'></span><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density function and random generation for Dirichlet distribution with 
parameter vector <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha, log = FALSE, tol = 1e-10) 
rdirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dirichlet_+3A_x">x</code></td>
<td>
<p>vector (or matrix) of points in sample space.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>vector of Dirichlet hyper parameters.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, natural logarithm of density is returned.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_tol">tol</code></td>
<td>
<p>tolerance of vectors not summing to 1 and negative values.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>number of random variables to be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, each row is taken to be a different point whose 
density is to be evaluated.  If the number of columns in (or length of, in
the 
<code>alpha</code>, the 
vector sum to 1.
</p>
<p>The <em>k</em>-dimensional Dirichlet distribution has density
</p>
<p style="text-align: center;"><code class="reqn">\frac{\Gamma\left(\sum_i \alpha_i\right)}{\prod_i \Gamma(\alpha_i)}
\prod_{i=1}^k x_i^{\alpha_i-1}</code>
</p>

<p>assuming that <code class="reqn">x_i &gt; 0</code> and <code class="reqn">\sum_i x_i = 1</code>, and zero otherwise.
</p>
<p>If the sum of row entries in <code>x</code> differs from 1 by more than
<code>tol</code>, 
is assumed to be 
</p>


<h3>Value</h3>

<p><code>rdirichlet</code> returns a matrix, each row of which is an
independent draw 
<code>alpha</code>.
</p>
<p><code>ddirichlet</code> returns a vector, each entry being the density of the 
corresponding row of <code>x</code>.  If <code>x</code> is a vector, then the output 
will have length 1.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">https://en.wikipedia.org/wiki/Dirichlet_distribution</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rdirichlet(10, c(1,2,3))
x

# Find densities at random points.
ddirichlet(x, c(1,2,3))
# Last column to be inferred.
ddirichlet(x[,c(1,2)], c(1,2,3))
ddirichlet(x, matrix(c(1,2,3), 10, 3, byrow=TRUE))

</code></pre>

<hr>
<h2 id='expit'>Expit and Logit.</h2><span id='topic+expit'></span><span id='topic+logit'></span>

<h3>Description</h3>

<p>Functions to take the expit and logit of numerical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)

logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>vector of real numbers; for <code>logit</code> to return a sensible value
these should be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>logit</code> implements the usual logit function, which is </p>
<p style="text-align: center;"><code class="reqn">logit(x) =
\log\frac{x}{1-x},</code>
</p>
<p> and <code>expit</code> its inverse:
</p>
<p style="text-align: center;"><code class="reqn">expit(x) = \frac{e^x}{1+e^x}.</code>
</p>
<p> It is assumed
that <code>logit(0) = -Inf</code> and <code>logit(1) = Inf</code>, and correspondingly
for <code>expit</code>.
</p>


<h3>Value</h3>

<p>A real vector corresponding to the expits or logits of <code>x</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>logit</code>: logit function
</p>
</li></ul>


<h3>Warning </h3>

<p>Choosing very large (positive or negative) values to
apply to <code>expit</code> may result in inaccurate inversion (see example
below).
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c(5, -2, 0.1)
y = expit(x)
logit(y)

# Beware large values!
logit(expit(100))
</code></pre>

<hr>
<h2 id='fastHadamard'>Compute fast Hadamard-transform of vector</h2><span id='topic+fastHadamard'></span>

<h3>Description</h3>

<p>Passes vector through Hadamard orthogonal design matrix.  Also known
as the Fast Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastHadamard(x, pad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastHadamard_+3A_x">x</code></td>
<td>
<p>vector of values to be transformed</p>
</td></tr>
<tr><td><code id="fastHadamard_+3A_pad">pad</code></td>
<td>
<p>optional logical asking whether vector not of length <code class="reqn">2^k</code> should be
padded with zeroes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is equivalent to multiplying by <code>designMatrix(log2(length(x)))</code> 
but should run much faster
</p>


<h3>Value</h3>

<p>A vector of the same length as x
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+designMatrix">designMatrix</a></code>, <code><a href="#topic+subsetMatrix">subsetMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fastHadamard(1:8)
fastHadamard(1:5, pad=TRUE)

</code></pre>

<hr>
<h2 id='fastMobius'>Fast Moebius and inverse Moebius transforms</h2><span id='topic+fastMobius'></span><span id='topic+invMobius'></span>

<h3>Description</h3>

<p>Uses the fast method of Kennes and Smets (1990) to obtain Moebius and 
inverse Moebius transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastMobius(x, pad = FALSE)

invMobius(x, pad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastMobius_+3A_x">x</code></td>
<td>
<p>vector to transform</p>
</td></tr>
<tr><td><code id="fastMobius_+3A_pad">pad</code></td>
<td>
<p>logical, should vector not of length 2^k be padded with zeroes?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are respectively equivalent to multiplying <code>abs(subsetMatrix(k))</code> 
and <code>subsetMatrix(k)</code> by <code>x</code>, when <code>x</code> has length <code class="reqn">2^k</code>, but is 
much faster if <code class="reqn">k</code> is large.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>invMobius</code>: inverse transform
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,0,-1,2,4,3,2,1)
M &lt;- subsetMatrix(3)
M %*% abs(M) %*% x
invMobius(fastMobius(x))

</code></pre>

<hr>
<h2 id='fsapply'>Fast and loose application of function over list.</h2><span id='topic+fsapply'></span>

<h3>Description</h3>

<p>Faster highly stripped down version of <code>sapply()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsapply(x, FUN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsapply_+3A_x">x</code></td>
<td>
<p>a vector (atomic or list) or an expression object.</p>
</td></tr>
<tr><td><code id="fsapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each element of <code>x</code>. In the
case of functions like <code>+</code>, the function name must be backquoted or
quoted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper for <code>unlist(lapply(x, FUN))</code>, which will behave
as <code>sapply</code> if <code>FUN</code> returns an atomic vector of length 1 each
time.
</p>
<p>Speed up over sapply is not dramatic, but can be useful in time critical
code.
</p>


<h3>Value</h3>

<p>A vector of results of applying <code>FUN</code> to <code>x</code>.
</p>


<h3>Warning </h3>

<p>Very loose version of <code>sapply</code> which should really
only by used if you're confident about how <code>FUN</code> is applied to each
entry in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = list(1:1000)
tmp = fsapply(x, sin)

## Not run: 
x = list()
set.seed(142313)
for (i in 1:1000) x[[i]] = rnorm(100)

system.time(for (i in 1:100) sapply(x, function(x) last(x)))
system.time(for (i in 1:100) fsapply(x, function(x) last(x)))

## End(Not run)

</code></pre>

<hr>
<h2 id='greaterThan'>Comparing numerical values</h2><span id='topic+greaterThan'></span>

<h3>Description</h3>

<p>Just a wrapper for comparing numerical values, for use with quicksort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greaterThan(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greaterThan_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="greaterThan_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just returns <code>-1</code> if <code>x</code> is less than <code>y</code>, <code>1</code> if
<code>x</code> is greater, and <code>0</code> if they are equal (according to
<code>==</code>).  The vectors wrap as usual if they are of different lengths.
</p>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code>`&lt;`</code> for traditional Boolean operator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
greaterThan(4,6)

# Use in sorting algorithm.
quickSort(c(5,2,9,7,6), f=greaterThan)
order(c(5,2,9,7,6))

</code></pre>

<hr>
<h2 id='inclusionMax'>Get inclusion maximal subsets from a list</h2><span id='topic+inclusionMax'></span>

<h3>Description</h3>

<p>Get inclusion maximal subsets from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusionMax(x, right = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inclusionMax_+3A_x">x</code></td>
<td>
<p>list containing the subsets</p>
</td></tr>
<tr><td><code id="inclusionMax_+3A_right">right</code></td>
<td>
<p>logical indicating whether right-most entry is always inclusion maximal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the inclusion maximal elements of <code>x</code>.  The 
indicator <code>right</code> may be set to <code>TRUE</code> in order to indicate
that the right-most entry is always an inclusion maximal set over all earlier 
sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>letlist &lt;- list(LETTERS[1:2], LETTERS[2:4], LETTERS[1:3])
inclusionMax(letlist)

</code></pre>

<hr>
<h2 id='indexBox'>Get indices of adjacent entries in array</h2><span id='topic+indexBox'></span>

<h3>Description</h3>

<p>Determines the relative vector positions of entries which are adjacent in an
array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexBox(upp, lwr, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indexBox_+3A_upp">upp</code></td>
<td>
<p>A vector of non-negative integers, giving the distance in the
positive direction from the centre in each co-ordinate.</p>
</td></tr>
<tr><td><code id="indexBox_+3A_lwr">lwr</code></td>
<td>
<p>A vector of non-positive integers, giving the negative distance
from the centre.</p>
</td></tr>
<tr><td><code id="indexBox_+3A_dim">dim</code></td>
<td>
<p>integer vector of array dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a particular cell in an array, which are the entries within (for
example) 1 unit in any direction?  This function gives the (relative) value
of such indices.  See examples.
</p>
<p>Indices may be repeated if the range exceeds the size of the array in any
dimension.
</p>


<h3>Value</h3>

<p>An integer vector giving relative positions of the indices.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+arrayInd">arrayInd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
arr = array(1:144, dim=c(3,4,3,4))
arr[2,2,2,3]
# which are entries within 1 unit each each direction of 2,2,2,3?

inds = 89 + indexBox(1,-1,c(3,4,3,4))
inds = inds[inds &gt; 0 &amp; inds &lt;= 144]
arrayInd(inds, c(3,4,3,4))

# what about just in second dimension?
inds = 89 + indexBox(c(0,1,0,0),c(0,-1,0,0),c(3,4,3,4))
inds = inds[inds &gt; 0 &amp; inds &lt;= 144]
arrayInd(inds, c(3,4,3,4))

</code></pre>

<hr>
<h2 id='int2set'>Alternate between sets and integers representing sets of integers via bits</h2><span id='topic+int2set'></span><span id='topic+set2int'></span>

<h3>Description</h3>

<p>Alternate between sets and integers representing sets of integers via bits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2set(n, index = 1, simplify = FALSE)

set2int(x, index = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int2set_+3A_n">n</code></td>
<td>
<p>integer respresenting a set</p>
</td></tr>
<tr><td><code id="int2set_+3A_index">index</code></td>
<td>
<p>integer to start from</p>
</td></tr>
<tr><td><code id="int2set_+3A_simplify">simplify</code></td>
<td>
<p>logical: return a single list if <code>n</code> has length 1?</p>
</td></tr>
<tr><td><code id="int2set_+3A_x">x</code></td>
<td>
<p>list of sets</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts an integer into its binary representation and 
interprets this as a set of integers.  Cannot handle sets with more
than 31 elements.
</p>


<h3>Value</h3>

<p>For <code>int2set</code> a list of sets one for each integer 
supplied, for <code>set2int</code> a vector of the same length as the number 
of sets supplied.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>set2int</code>: Convert sets to integers
</p>
</li></ul>

<hr>
<h2 id='interventionMatrix'>Calculate interventional distributions.</h2><span id='topic+interventionMatrix'></span><span id='topic+interventionTable'></span><span id='topic+intervention.table'></span>

<h3>Description</h3>

<p>Calculate interventional distributions from a probability table or matrix of
multivariate probability distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interventionMatrix(x, variables, condition, dim = NULL, incols = FALSE)

interventionTable(x, variables, condition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interventionMatrix_+3A_x">x</code></td>
<td>
<p>An array of probabilities.</p>
</td></tr>
<tr><td><code id="interventionMatrix_+3A_variables">variables</code></td>
<td>
<p>The margin for the intervention.</p>
</td></tr>
<tr><td><code id="interventionMatrix_+3A_condition">condition</code></td>
<td>
<p>The dimensions to be conditioned upon.</p>
</td></tr>
<tr><td><code id="interventionMatrix_+3A_dim">dim</code></td>
<td>
<p>Integer vector containing dimensions of variables.  Assumed all
binary if not specified.</p>
</td></tr>
<tr><td><code id="interventionMatrix_+3A_incols">incols</code></td>
<td>
<p>Logical specifying whether not the distributions are stored as
the columns in the matrix; assumed to be rows by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This just divides the joint distribution <code class="reqn">p(x)</code> by <code class="reqn">p(v | c)</code>, where
<code class="reqn">v</code> is <code>variables</code> and <code class="reqn">c</code> is <code>condition</code>.
</p>
<p>Under certain causal assumptions this is the interventional distribution
<code class="reqn">p(x \,|\, do(v))</code> (i.e. if the direct causes of <code class="reqn">v</code> are precisely
<code class="reqn">c</code>.)
</p>
<p><code>intervention.table()</code> is identical to <code>interventionTable()</code>.
</p>


<h3>Value</h3>

<p>A numerical array of the same dimension as <code class="reqn">x</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>interventionMatrix</code>: Interventions in matrix of distributions
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>References</h3>

<p>Pearl, J., <em>Causality</em>, 2nd Edition. Cambridge University
Press, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditionTable">conditionTable</a></code>, <code><a href="#topic+marginTable">marginTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(413)
# matrix of distributions
p = rdirichlet(10, rep(1,16))
interventionMatrix(p, 3, 2)

# take one in an array
ap = array(p[1,], rep(2,4))
interventionTable(ap, 3, 2)

</code></pre>

<hr>
<h2 id='is.subset'>Check subset inclusion</h2><span id='topic+is.subset'></span><span id='topic++25subof+25'></span>

<h3>Description</h3>

<p>Determines whether one vector contains all the elements of another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.subset(x, y)

x %subof% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.subset_+3A_x">x</code></td>
<td>
<p>vector.</p>
</td></tr>
<tr><td><code id="is.subset_+3A_y">y</code></td>
<td>
<p>vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines whether or not every element of <code>x</code> is also found in
<code>y</code>. Returns <code>TRUE</code> if so, and <code>FALSE</code> if not.
</p>


<h3>Value</h3>

<p>A logical of length 1.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>%subof%</code>: operator version
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setmatch">setmatch</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.subset(1:2, 1:3)
is.subset(1:2, 2:3)
1:2 %subof% 1:3
1:2 %subof% 2:3

</code></pre>

<hr>
<h2 id='is.wholenumber'>Determine whether number is integral or not.</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Checks whether a numeric value is integral, up to machine or other specified
prescision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>numeric vector to be tested.</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>The desired precision.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as <code>x</code>, containing the
results of the test.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c(0.5, 1, 2L, 1e-20)
is.wholenumber(x)

</code></pre>

<hr>
<h2 id='kronPower'>Kronecker power of a matrix or vector</h2><span id='topic+kronPower'></span>

<h3>Description</h3>

<p>Kronecker power of a matrix or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronPower(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kronPower_+3A_x">x</code></td>
<td>
<p>matrix or vector</p>
</td></tr>
<tr><td><code id="kronPower_+3A_n">n</code></td>
<td>
<p>integer containing power to take</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes <code>x %x% ... %x% x</code> 
for <code>n</code> 
instances of <code>x</code>.
</p>

<hr>
<h2 id='last'>Last element of a vector or list</h2><span id='topic+last'></span>

<h3>Description</h3>

<p>Returns the last element of a list or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="last_+3A_x">x</code></td>
<td>
<p>a list or vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed to be faster than using <code>tail()</code> or <code>rev()</code>, and cleaner
than writing <code>x[length(x)]</code>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> of length 1 (or empty if
<code>x</code> is empty).
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="base.html#topic+rev">rev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
last(1:10)

</code></pre>

<hr>
<h2 id='marginTable'>Compute margin of a table faster</h2><span id='topic+marginTable'></span><span id='topic+propTable'></span><span id='topic+marginMatrix'></span>

<h3>Description</h3>

<p>Computes the margin of a contingency table given as an array, by summing out
over the dimensions not specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginTable(x, margin = NULL, order = TRUE) 
marginMatrix(x, margin, dim = NULL, incols = FALSE, order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginTable_+3A_x">x</code></td>
<td>
<p>a numeric array</p>
</td></tr>
<tr><td><code id="marginTable_+3A_margin">margin</code></td>
<td>
<p>integer vector giving margin to be calculated (1 for rows,
etc.)</p>
</td></tr>
<tr><td><code id="marginTable_+3A_order">order</code></td>
<td>
<p>logical - should indices of output be ordered as in the vector
<code>margin</code>?  Defaults to <code>TRUE</code> for marginTable, <code>FALSE</code> for 
marginMatrix.</p>
</td></tr>
<tr><td><code id="marginTable_+3A_dim">dim</code></td>
<td>
<p>Integer vector containing dimensions of variables.  Assumed all
binary if not specified.</p>
</td></tr>
<tr><td><code id="marginTable_+3A_incols">incols</code></td>
<td>
<p>Logical specifying whether not the distributions are stored as
the columns in the matrix; assumed to be rows by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>order = TRUE</code> this is the same as the base function
<code>margin.table()</code>, but faster.
</p>
<p>With <code>order = FALSE</code> the function is even faster, but the indices in
the margin are returned in their original order, regardless of the way they
are specified in <code>margin</code>.
</p>
<p><code>propTable()</code> returns a renormalized contingency table whose entries
sum to 1. It is equivalent to <code>prop.table()</code>, but faster.
</p>


<h3>Value</h3>

<p>The relevant marginal table.  The class of <code>x</code> is copied to the
output table, except in the summation case.
</p>


<h3>Note</h3>

<p>Original functions are <code><a href="base.html#topic+margin.table">margin.table</a></code> and
<code><a href="base.html#topic+prop.table">prop.table</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(1:4, 2)
marginTable(m, 1)
marginTable(m, 2)

propTable(m, 2)

# 3-way example
m &lt;- array(1:8, rep(2,3))
marginTable(m, c(2,3))
marginTable(m, c(3,2))
marginTable(m, c(3,2), order=FALSE)

#' set.seed(2314)
# set of 10 2x2x2 probability distributions
x = rdirichlet(10, rep(1,8))

marginMatrix(x, c(1,3))
marginMatrix(t(x), c(1,3), incols=TRUE)

</code></pre>

<hr>
<h2 id='patternRepeat'>Complex repetitions</h2><span id='topic+patternRepeat'></span><span id='topic+patternRepeat0'></span>

<h3>Description</h3>

<p>Recreate patterns for collapsed arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patternRepeat(x, which, n, careful = TRUE, keep.order = FALSE)

patternRepeat0(which, n, careful = TRUE, keep.order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patternRepeat_+3A_x">x</code></td>
<td>
<p>A vector to be repeated.</p>
</td></tr>
<tr><td><code id="patternRepeat_+3A_which">which</code></td>
<td>
<p>Which indices of the implicit array are given in <code>x</code>.</p>
</td></tr>
<tr><td><code id="patternRepeat_+3A_n">n</code></td>
<td>
<p>Dimensions of implicit array.</p>
</td></tr>
<tr><td><code id="patternRepeat_+3A_careful">careful</code></td>
<td>
<p>logical indicating whether to check vailidty of arguments,
but therefore slow things down.</p>
</td></tr>
<tr><td><code id="patternRepeat_+3A_keep.order">keep.order</code></td>
<td>
<p>logical indicating whether to respect the ordering of the
entries in the vector <code>which</code>, in which case data are permuted before
replication.  In other words, does <code>x</code> change fastest in
<code>which[1]</code>, or in the minimal entry for <code>which</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions allow for the construction of complex repeating patterns
corresponding to those obtained by unwrapping arrays.  Consider an array
with dimensions <code>n</code>; then for each value of the dimensions in
<code>which</code>, this function returns a vector which places the corresponding
entry of <code>x</code> into every place which would match this pattern when the
full array is unwrapped.
</p>
<p>For example, if a full 4-way array has dimensions 2*2*2*2 and we consider
the margin of variables 2 and 4, then the function returns the pattern
c(1,1,2,2,1,1,2,2,3,3,4,4,3,3,4,4).  The entries 1,2,3,4 correspond to the
patterns (0,0), (1,0), (0,1) and (1,1) for the 2nd and 4th indices.
</p>
<p>In <code>patternRepeat()</code> the argument <code>x</code> is repeated according to the
pattern, while <code>patternRepeat0()</code> just returns the indexing pattern.
So <code>patternRepeat(x,which,n)</code> is effectively equivalent to
<code>x[patternRepeat0(which,n)]</code>.
</p>
<p>The length of <code>x</code> must be equal to <code>prod(n[which])</code>.
</p>


<h3>Value</h3>

<p>Both return a vector of length <code>prod(n)</code>;
<code>patternRepeat()</code> one containing suitably repeated and ordered elements
of <code>x</code>, for <code>patternRepeat0()</code> it is always the integers from 1 up
to <code>prod(n[which])</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>patternRepeat0</code>: Stripped down version that just gives indices
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
patternRepeat(1:4, c(1,2), c(2,2,2))
c(array(1:4, c(2,2,2)))

patternRepeat0(c(1,3), c(2,2,2))
patternRepeat0(c(2,3), c(2,2,2))

patternRepeat0(c(3,1), c(2,2,2))
patternRepeat0(c(3,1), c(2,2,2), keep.order=TRUE)

patternRepeat(letters[1:4], c(1,3), c(2,2,2))

</code></pre>

<hr>
<h2 id='powerSet'>Power Set</h2><span id='topic+powerSet'></span><span id='topic+powerSetCond'></span>

<h3>Description</h3>

<p>Produces the power set of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerSet(x, m, rev = FALSE)

powerSetCond(x, y, m, rev = FALSE, sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerSet_+3A_x">x</code></td>
<td>
<p>vector of elements (the set).</p>
</td></tr>
<tr><td><code id="powerSet_+3A_m">m</code></td>
<td>
<p>maximum cardinality of subsets</p>
</td></tr>
<tr><td><code id="powerSet_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether to reverse the order of subsets.</p>
</td></tr>
<tr><td><code id="powerSet_+3A_y">y</code></td>
<td>
<p>set to condition on</p>
</td></tr>
<tr><td><code id="powerSet_+3A_sort">sort</code></td>
<td>
<p>logical: should sets be sorted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a list containing every subset 
of the elements of the vector <code>x</code>.
</p>
<p><code>powerSet</code> returns subsets up to size <code>m</code> (if this is specified).  
<code>powerSetCond</code> includes some non-empty subset of <code>x</code> in every set.
</p>


<h3>Value</h3>

<p>A list of vectors of the same type as <code>x</code>.
</p>
<p>With <code>rev = FALSE</code> (the default) the list is ordered such that all
subsets containing the last element of <code>x</code> come after those which do
not, and so on.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>powerSetCond</code>: Add sets that can't be empty
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+powerSetMat">powerSetMat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
powerSet(1:3)
powerSet(letters[3:5], rev=TRUE)
powerSet(1:5, m=2)

powerSetCond(2:3, y=1)

</code></pre>

<hr>
<h2 id='printPercentage'>Print Percentage of Activity Completed to stdout</h2><span id='topic+printPercentage'></span><span id='topic+printCount'></span>

<h3>Description</h3>

<p>Prints percentage (or alternatively just a count) of loop or similar process
which has been completed to the standard output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printPercentage(i, n, dp = 0, first = 1, last = n, prev = i - 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printPercentage_+3A_i">i</code></td>
<td>
<p>the number of iterations completed.</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_n">n</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_dp">dp</code></td>
<td>
<p>number of decimal places to display.</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_first">first</code></td>
<td>
<p>number of the first iteration for which this percentage was
displayed</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_last">last</code></td>
<td>
<p>number of the final iteration for which this percentage will be
displayed</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_prev">prev</code></td>
<td>
<p>number of the previous iteration for which this percentage was
displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>printPercentage</code> will use <code>cat</code> to print the proportion of loops
which have been completed (i.e. <code>i/n</code>) to the standard output.  In
doing so it will erase the previous such percentage, except when <code>i =
first</code>.  A new line is added when <code>i = last</code>, assuming that the loop is
finished.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Warning</h3>

<p>This will fail to work nicely if other information is
printed to the standard output 
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = numeric(100)

for (i in 1:100) {
  x[i] = mean(rnorm(1e5))
  printPercentage(i,100)
}


i = 0
repeat {
  i = i+1
  if (runif(1) &gt; 0.99) {
    break
  }
  printCount(i)
}
print("\n")

</code></pre>

<hr>
<h2 id='quickSort'>Quicksort for Partial Orderings</h2><span id='topic+quickSort'></span>

<h3>Description</h3>

<p>Implements the quicksort algorithm for partial orderings based on pairwise
comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickSort(x, f = greaterThan, ..., random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickSort_+3A_x">x</code></td>
<td>
<p>A list or vector of items to be sorted.</p>
</td></tr>
<tr><td><code id="quickSort_+3A_f">f</code></td>
<td>
<p>A function on two arguments for comparing elements of <code>x</code>.
Returns <code>-1</code> if the first argument is less than the second, <code>1</code>
for the reverse, and <code>0</code> if they are equal or incomparable.</p>
</td></tr>
<tr><td><code id="quickSort_+3A_...">...</code></td>
<td>
<p>other arguments to <code>f</code></p>
</td></tr>
<tr><td><code id="quickSort_+3A_random">random</code></td>
<td>
<p>logical - should a random pivot be chosen? (this is
recommended) Otherwise middle element is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the usual quicksort algorithm, but may return the same positions
for items which are incomparable (or equal).  Does not test the validity of
<code>f</code> as a partial order.
</p>
<p>If <code>x</code> is a numeric vector with distinct entries, this behaves just
like <code><a href="base.html#topic+rank">rank</a></code>.
</p>


<h3>Value</h3>

<p>Returns an integer vector giving each element's position in the
order (minimal element(s) is 1, etc).
</p>


<h3>Warning</h3>

<p>Output may not be consistent for certain partial orderings
(using random pivot), see example below.  All results will be consistent
with a total ordering which is itselft consistent with the true partial
ordering.
</p>
<p><code>f</code> is not checked to see that it returns a legitimate partial order,
so results may be meaningless if it is not.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
quickSort(powerSet(1:3), f=subsetOrder)
quickSort(powerSet(1:3), f=subsetOrder)
# slightly different answers, but both correposnding
# to a legitimate total ordering.

</code></pre>

<hr>
<h2 id='rowMins'>Row-wise minima and maxima</h2><span id='topic+rowMins'></span><span id='topic+rowMaxs'></span>

<h3>Description</h3>

<p>Row-wise minima and maxima
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMins(x)
rowMaxs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowMins_+3A_x">x</code></td>
<td>
<p>a numeric (or logical) matrix or data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function coerces <code>x</code> to be a data frame and then
uses <code>pmin</code> (<code>pmax</code>) on it.  This is the same as
<code>apply(x, 1, min)</code> but generally faster if the number of rows
is large.
</p>


<h3>Value</h3>

<p>numeric vector of length <code>nrow(x)</code> giving the row-wise minima (or maxima) of <code>x</code>.
</p>

<hr>
<h2 id='rprobdist'>Generate a joint (or conditional) probability distribution</h2><span id='topic+rprobdist'></span>

<h3>Description</h3>

<p>Wrapper functions to quickly generate discrete joint
(or conditional) distributions using Dirichlets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprobdist(dim, d, cond, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rprobdist_+3A_dim">dim</code></td>
<td>
<p>the joint dimension of the probability table</p>
</td></tr>
<tr><td><code id="rprobdist_+3A_d">d</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="rprobdist_+3A_cond">cond</code></td>
<td>
<p>optionally, vertices to condition upon</p>
</td></tr>
<tr><td><code id="rprobdist_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet hyper parameter, defaults to 1 (flat density).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rprobdist</code> gives an array of dimension <code>dim</code>
(recycled as necessary to have length <code>d</code>, if this is
supplied) whose entries are probabilities drawn from a Dirichlet
distribution whose parameter vector has entries equal to
<code>alpha</code> (appropriately recycled).
</p>


<h3>Value</h3>

<p>an array of appropriate dimensions
</p>


<h3>Side Effects</h3>

<p>Uses as many gamma random variables as cells
in the table, so will alter the random seed accordingly.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rprobdist(2, 4)     # 2x2x2x2 table
rprobdist(c(2,3,2)) # 2x3x2 table

rprobdist(2, 4, alpha=1/16)     # using unit information prior

# get variables 2 and 4 conditioned upon
rprobdist(2, 4, cond=c(2,4), alpha=1/16) 

</code></pre>

<hr>
<h2 id='schur'>Obtain generalized Schur complement</h2><span id='topic+schur'></span>

<h3>Description</h3>

<p>Obtain generalized Schur complement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schur(M, x, y, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="schur_+3A_m">M</code></td>
<td>
<p>symmetric positive definite matrix</p>
</td></tr>
<tr><td><code id="schur_+3A_x">x</code>, <code id="schur_+3A_y">y</code>, <code id="schur_+3A_z">z</code></td>
<td>
<p>indices of M to calculate with (see below)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates <code class="reqn">M_{xy} - M_{xz} M^{zz} M_{zy}</code>, which
(if M is a Gaussian covariance matrix) is the covariance between
x and y after conditioning on z.
</p>
<p>y defaults to equal x, and z to be the complement of <code class="reqn">x \cup y</code>.
</p>

<hr>
<h2 id='setmatch'>Set Operations</h2><span id='topic+setmatch'></span><span id='topic+subsetmatch'></span><span id='topic+setsetdiff'></span><span id='topic+setsetequal'></span><span id='topic+supersetmatch'></span>

<h3>Description</h3>

<p>Series of functions extending existing vector operations to lists of
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setmatch(x, y, nomatch = NA_integer_)

setsetequal(x, y)

setsetdiff(x, y)

subsetmatch(x, y, nomatch = NA_integer_)

supersetmatch(x, y, nomatch = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setmatch_+3A_x">x</code></td>
<td>
<p>list of vectors.</p>
</td></tr>
<tr><td><code id="setmatch_+3A_y">y</code></td>
<td>
<p>list of vectors.</p>
</td></tr>
<tr><td><code id="setmatch_+3A_nomatch">nomatch</code></td>
<td>
<p>value to be returned in the case when no match is found. Note
that it is coerced to integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setmatch</code> checks whether each vector in the list <code>x</code> is also
contained in the list <code>y</code>, and if so returns position of the first such
vector in <code>y</code>.  The ordering of the elements of the vector is
irrelevant, as they are considered to be sets.
</p>
<p><code>subsetmatch</code> is similar to <code>setmatch</code>, except vectors in <code>x</code>
are searched to see if they are subsets of vectors in <code>y</code>.  Similarly
<code>supersetmatch</code> consideres if vectors in <code>x</code> are supersets of
vectors in <code>y</code>.
</p>
<p><code>setsetdiff</code> is a setwise version of <code>setdiff</code>, and
<code>setsetequal</code> a setwise version of <code>setequal</code>.
</p>


<h3>Value</h3>

<p><code>setmatch</code> and <code>subsetmatch</code> return a vector of integers
of length the same as the list <code>x</code>.
</p>
<p><code>setsetdiff</code> returns a sublist <code>x</code>.
</p>
<p><code>setsetequal</code> returns a logical of length 1.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>setsetequal</code>: Test for equality of sets
</p>
</li>
<li> <p><code>setsetdiff</code>: Setdiff for lists
</p>
</li>
<li> <p><code>subsetmatch</code>: Test for subsets
</p>
</li>
<li> <p><code>supersetmatch</code>: Test for supersets
</p>
</li></ul>


<h3>Note</h3>

<p>These functions are not recursive, in the sense that they cannot be
used to test lists of lists.  They also do not reduce to the vector case.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>, <code><a href="base.html#topic+setequal">setequal</a></code>, <code><a href="base.html#topic+setdiff">setdiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = list(1:2, 1:3)
y = list(1:4, 1:3)
setmatch(x, y)
subsetmatch(x, y)
setsetdiff(x, y)

x = list(1:3, 1:2)
y = list(2:1, c(2,1,3))
setsetequal(x, y)

</code></pre>

<hr>
<h2 id='subsetMatrix'>Matrix of Subset Indicators</h2><span id='topic+subsetMatrix'></span>

<h3>Description</h3>

<p>Produces a matrix whose rows indicate what subsets of a set are included in
which other subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetMatrix(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsetMatrix_+3A_n">n</code></td>
<td>
<p>integer containing the number of elements in the set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a matrix, with each row and column corresponding to a
subset of a hypothetical set of size <code>n</code>, ordered lexographically.  The
entry in row <code>i</code>, column <code>j</code> corresponds to whether or not the
subset associated with <code>i</code> is a superset of that associated with
<code>j</code>.
</p>
<p>A 1 or -1 indicates that <code>i</code> is a superset of <code>j</code>, with the sign
referring to the number of fewer elements in <code>j</code>.  0 indicates that
<code>i</code> is not a superset of <code>j</code>.
</p>


<h3>Value</h3>

<p>An integer matrix of dimension 2^n by 2^n.
</p>


<h3>Note</h3>

<p>The inverse of the output matrix is just <code>abs(subsetMatrix(n))</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combinations">combinations</a></code>, <code><a href="#topic+powerSet">powerSet</a></code>,  <code><a href="#topic+designMatrix">designMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
subsetMatrix(3)

</code></pre>

<hr>
<h2 id='subsetOrder'>Compare sets for inclusion.</h2><span id='topic+subsetOrder'></span>

<h3>Description</h3>

<p>A wrapper for <code>is.subset</code> which returns set inclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetOrder(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsetOrder_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="subsetOrder_+3A_y">y</code></td>
<td>
<p>A vector of the same type as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a subset of <code>y</code>, returns <code>-1</code>, for the reverse
returns <code>1</code>.  If sets are equal or incomparable, it returns <code>0</code>.
</p>


<h3>Value</h3>

<p>A single integer, 0, -1 or 1.
</p>


<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.subset">is.subset</a></code>, <code><a href="#topic+inclusionMax">inclusionMax</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
subsetOrder(2:4, 1:4)
subsetOrder(2:4, 3:5)

</code></pre>

<hr>
<h2 id='subtable'>Subset an array</h2><span id='topic+subtable'></span><span id='topic+subarray'></span><span id='topic+subarray+3C-'></span><span id='topic+subtable+3C-'></span>

<h3>Description</h3>

<p>More flexible calls of <code>[</code> on an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtable(x, variables, levels, drop = TRUE)

subarray(x, levels, drop = TRUE)

subtable(x, variables, levels) &lt;- value

subarray(x, levels) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtable_+3A_x">x</code></td>
<td>
<p>An array.</p>
</td></tr>
<tr><td><code id="subtable_+3A_variables">variables</code></td>
<td>
<p>An integer vector containing the dimensions of <code>x</code> to
subset.</p>
</td></tr>
<tr><td><code id="subtable_+3A_levels">levels</code></td>
<td>
<p>A list or vector containing values to retain.</p>
</td></tr>
<tr><td><code id="subtable_+3A_drop">drop</code></td>
<td>
<p>Logical indicating whether dimensions with only 1 retained
should be dropped.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="subtable_+3A_value">value</code></td>
<td>
<p>Value to assign to entries in table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially just allows more flexible calls of <code>[</code> on an array.
</p>
<p><code>subarray</code> requires the values for each dimension should be specified,
so for a <code class="reqn">2 \times 2 \times 2</code> array <code>x</code>,
<code>subarray(x, list(1,2,1:2))</code> is just <code>x[1,2,1:2]</code>.
</p>
<p><code>subtable</code> allows unspecified dimensions to be retained automatically.
Thus, for example <code>subtable(x, c(2,3), list(1, 1:2))</code> is
<code>x[,1,1:2]</code>.
</p>


<h3>Value</h3>

<p>Returns an array of dimension <code>sapply(value, length)</code> if
<code>drop=TRUE</code>, otherwise <em>specified</em> dimensions of size 1 are
dropped.  Dimensions which are unspecified in <code>subtable</code> are never
dropped.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>subarray</code>: Flexible subsetting
</p>
</li>
<li> <p><code>subtable&lt;-</code>: Assignment in a table
</p>
</li>
<li> <p><code>subarray&lt;-</code>: Assignment in an array
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Mathias Drton, Robin Evans
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Extract">Extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = array(1:8, rep(2,3))
subarray(x, c(2,1,2)) == x[2,1,2]

x[2,1:2,2,drop=FALSE]
subarray(x, list(2,1:2,2), drop=FALSE)

subtable(x, c(2,3), list(1, 1:2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
