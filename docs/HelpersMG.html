<!DOCTYPE html><html><head><title>Help for package HelpersMG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HelpersMG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HelpersMG-package'><p>Tools for Environmental Analyses, Ecotoxicology and Various R Functions</p></a></li>
<li><a href='#addS3Class'><p>Add a S3 class to an object.</p></a></li>
<li><a href='#as.mcmc.mcmcComposite'><p>Extract mcmc object from a mcmcComposite object</p></a></li>
<li><a href='#as.parameters'><p>Extract parameters from mcmcComposite object</p></a></li>
<li><a href='#as.quantiles'><p>Extract quantile distribution from mcmcComposite object</p></a></li>
<li><a href='#asc'><p>Return the codes (in UTF-8) of a string</p></a></li>
<li><a href='#barplot_errbar'><p>Plot a barplot graph with error bar on y</p></a></li>
<li><a href='#cArrows'><p>Draw curved lines with arrowhead</p></a></li>
<li><a href='#ChangeCoordinate'><p>Return a value in a changed coordinate</p></a></li>
<li><a href='#char'><p>Return the characters defined by the codes</p></a></li>
<li><a href='#compare'><p>Run a shiny application for basic functions of comparison</p></a></li>
<li><a href='#compare_AIC'><p>Compares the AIC of several outputs</p></a></li>
<li><a href='#compare_AICc'><p>Compares the AICc of several outputs</p></a></li>
<li><a href='#compare_BIC'><p>Compares the BIC of several outputs</p></a></li>
<li><a href='#contingencyTable.compare'><p>Contingency table comparison using Akaike weight</p></a></li>
<li><a href='#convert.tz'><p>Convert one Date-Time from one timezone to another</p></a></li>
<li><a href='#cutter'><p>Distribution of the fitted distribution without cut.</p></a></li>
<li><a href='#d'><p>Write an ASCII Representation of a vector object</p></a></li>
<li><a href='#dbeta_new'><p>Density for the Beta distributions.</p></a></li>
<li><a href='#dcutter'><p>Distribution of the fitted distribution without cut.</p></a></li>
<li><a href='#dggamma'><p>Generalized gamma distribution.</p></a></li>
<li><a href='#DIx'><p>Return an index of quantitative asymmetry and complexity named Developmental Instability Index (DIx)</p></a></li>
<li><a href='#dnbinom_new'><p>Random numbers for the negative binomial distribution.</p></a></li>
<li><a href='#dSnbinom'><p>Distribution of the sum independent negative binomial random variables.</p></a></li>
<li><a href='#duplicated_packages'><p>List the duplicated packages with their locations</p></a></li>
<li><a href='#ellipse'><p>Plot an ellipse</p></a></li>
<li><a href='#ExtractAIC.glm'><p>Return AIC, AICc or BIC from a glm object</p></a></li>
<li><a href='#fitdistrquantiles'><p>Parameters of beta, normal or gamma distribution based on quantiles.</p></a></li>
<li><a href='#flexit'><p>Return the flexit</p></a></li>
<li><a href='#format_ncdf'><p>Return an array with ncdf data</p></a></li>
<li><a href='#FormatCompareAIC'><p>Format data to be used with compare_AIC()</p></a></li>
<li><a href='#IC_clean_data'><p>Clean the dataframe before to be used with IC_threshold_matrix</p></a></li>
<li><a href='#IC_correlation_simplify'><p>Simplify the correlation matrix</p></a></li>
<li><a href='#IC_threshold_matrix'><p>Calculate correlation matrix</p></a></li>
<li><a href='#iCutter'><p>Run a shiny application to fit bone section</p></a></li>
<li><a href='#ind_long_lat'><p>Return or the index in ncdf object from lat/longitude or inverse</p></a></li>
<li><a href='#index.periodic'><p>Estimate indices in periodic timeseries based on anchored minimum and maximum</p></a></li>
<li><a href='#inside'><p>Search a string within files of a folder</p></a></li>
<li><a href='#invlogit'><p>Return the inverse logit</p></a></li>
<li><a href='#LD50'><p>Estimate the parameters that best describe LD50</p></a></li>
<li><a href='#LD50_MHmcmc'><p>Metropolis-Hastings algorithm for LD50</p></a></li>
<li><a href='#LD50_MHmcmc_p'><p>Generates set of parameters to be used with LD50_MHmcmc()</p></a></li>
<li><a href='#list.packages'><p>List the installed packages with their locations</p></a></li>
<li><a href='#local.search'><p>Return path of file searched for in local disk based on its file name</p></a></li>
<li><a href='#logit'><p>Return the logit</p></a></li>
<li><a href='#logLik.compareAIC'><p>Return Log Likelihood generated by FormatCompareAIC</p></a></li>
<li><a href='#logLik.cutter'><p>Return log likelihood of a cutter fitted model</p></a></li>
<li><a href='#logLik.LD50'><p>Return Log Likelihood of a fit generated by LD50</p></a></li>
<li><a href='#merge.mcmcComposite'><p>Merge two mcmcComposite results</p></a></li>
<li><a href='#MHalgoGen'><p>Monte-Carlo Markov-chain with Metropolis-Hastings algorithm</p></a></li>
<li><a href='#minmax.periodic'><p>Search for minimum and maximum indices in periodic timeseries</p></a></li>
<li><a href='#modeled.hist'><p>Return the theoretical value for the histogram bar</p></a></li>
<li><a href='#modifyVector'><p>Modifies Elements of a Vector</p></a></li>
<li><a href='#moon.info'><p>Moon phase based on a date</p></a></li>
<li><a href='#MovingWindow'><p>Return a moving average of a vector.</p></a></li>
<li><a href='#NagelkerkeScaledR2'><p>Return the scaled R2 defined by Nagelkerke (1991)</p></a></li>
<li><a href='#newcompassRose'><p>Display a compass rose</p></a></li>
<li><a href='#newmap.scale'><p>Add Scale to Existing Unprojected Map</p></a></li>
<li><a href='#openwd'><p>Open a finder window with current working directory in MacOS X and windows</p></a></li>
<li><a href='#plot_add'><p>Add a plot to a previous one</p></a></li>
<li><a href='#plot_errbar'><p>Plot a xy graph with error bar on x and/or y</p></a></li>
<li><a href='#plot.cutter'><p>Plot results of cutter that best describe distribution</p></a></li>
<li><a href='#plot.IconoCorel'><p>Clean the dataframe before to be used with IC_threshold_matrix</p></a></li>
<li><a href='#plot.LD50'><p>Plot results of LD50() that best describe LD50</p></a></li>
<li><a href='#plot.mcmcComposite'><p>Plot the result of a mcmcComposite object</p></a></li>
<li><a href='#plot.PriorsmcmcComposite'><p>Plot a prior defined with setPriors function</p></a></li>
<li><a href='#predict.LD50'><p>Estimate survival according to doses</p></a></li>
<li><a href='#print.cutter'><p>Print results of cutter that best describe distribution</p></a></li>
<li><a href='#qvlmer'><p>Quasi Variances for lmer Model Coefficients</p></a></li>
<li><a href='#r2norm'><p>Random generation for Gaussian distributions different at left and right</p></a></li>
<li><a href='#RandomFromHessianOrMCMC'><p>Random numbers based on Hessian matrix or MCMC</p></a></li>
<li><a href='#rcutter'><p>Random values of unobserved values of cut distribution.</p></a></li>
<li><a href='#read_folder'><p>Read files present in a folder and creates a list with the content of these files</p></a></li>
<li><a href='#RectangleRegression'><p>Return parameters of rectangle regression</p></a></li>
<li><a href='#RM_add'><p>Create a results managment or add a value in a results managment to an object</p></a></li>
<li><a href='#RM_delete'><p>Delete a results managment or a result within a results managment from an object</p></a></li>
<li><a href='#RM_duplicate'><p>Duplicate a results managment within an object.</p></a></li>
<li><a href='#RM_get'><p>Get a value in a results managment to an object</p></a></li>
<li><a href='#RM_list'><p>Return the list of results managment of an object.</p></a></li>
<li><a href='#rmnorm'><p>Generate random numbers from the multivariate normal distribution</p></a></li>
<li><a href='#rnbinom_new'><p>Random numbers for the negative binomial distribution.</p></a></li>
<li><a href='#ScalePreviousPlot'><p>Return the scale of the previous plot</p></a></li>
<li><a href='#SEfromHessian'><p>Standard error of parameters based on Hessian matrix</p></a></li>
<li><a href='#series.compare'><p>Data series comparison using Akaike weight</p></a></li>
<li><a href='#setPriors'><p>Set priors for MHalgoGen()</p></a></li>
<li><a href='#show_name'><p>Show the name of a point</p></a></li>
<li><a href='#similar'><p>Test if two vectors contains the same elements independently of their order</p></a></li>
<li><a href='#specify_decimal'><p>Return a number as character with specified number of decimals</p></a></li>
<li><a href='#summary.mcmcComposite'><p>Summarize the result of a mcmcComposite object</p></a></li>
<li><a href='#sun.info'><p>Estimate the time of sunrise and sunset according to longitude, latitude and date</p></a></li>
<li><a href='#symbol.Female'><p>Plot a female symbol in the plotting region</p></a></li>
<li><a href='#symbol.Male'><p>Plot a male symbol in the plotting region</p></a></li>
<li><a href='#symmetricize'><p>Make a matrix symmetric</p></a></li>
<li><a href='#tide.info'><p>Annual tide calendar for one particular location</p></a></li>
<li><a href='#tnirp'><p>Read an ASCII text representation of a named or not vector object</p></a></li>
<li><a href='#universalmclapply'><p>Run the function FUN on X using parallel computing</p></a></li>
<li><a href='#wget'><p>Download a file from internet and save it locally</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Environmental Analyses, Ecotoxicology and Various R
Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Girondot</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Girondot &lt;marc.girondot@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), MASS, ggplot2, rlang, coda, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4, RNetCDF, ncdf4, maps, fields, shiny, ppcor, pbmcapply,
pbapply, parallel, visNetwork, igraph, shinyWidgets, cranlogs</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains miscellaneous functions useful for managing 'NetCDF' files (see <a href="https://en.wikipedia.org/wiki/NetCDF">https://en.wikipedia.org/wiki/NetCDF</a>), get moon phase and time for sun rise and fall, tide level, analyse and reconstruct periodic time series of temperature with irregular sinusoidal pattern, show scales and wind rose in plot with change of color of text, Metropolis-Hastings algorithm for Bayesian MCMC analysis, plot graphs or boxplot with error bars, search files in disk by there names or their content, read the contents of all files from a folder at one time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 13:16:45 UTC; marcgirondot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 15:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='HelpersMG-package'>Tools for Environmental Analyses, Ecotoxicology and Various R Functions</h2><span id='topic+HelpersMG'></span><span id='topic+HelpersMG-package'></span>

<h3>Description</h3>

<p>Contains miscellaneous functions useful for managing <br />
'NetCDF' files (see http://en.wikipedia.org/wiki/NetCDF), <br />
get tide levels on any point of the globe, <br />
get moon phase and time for sun rise and fall, <br />
analyse and reconstruct daily time series of temperature <br />
with irregular sinusoidal pattern, <br />
show scales and wind rose in plot with change of color of text, <br />
Metropolis-Hastings algorithm for Bayesian MCMC analysis, <br />
plot graphs or boxplot with error bars, <br />
search files in disk by there names or their content, <br />
read the contents of all files from a folder at one time, <br />
calculate IC50 for ecotoxicological studies, <br />
calculate the probability mass function of the sum of negative binomial <br />
distributions, calculate distribution of unobserved values in censored or
truncated distributions.<br />
The latest version of this package can always be installed using:<br />
install.packages(&quot;https://hebergement.universite-paris-saclay.fr/marcgirondot/CRAN/HelpersMG.tar.gz&quot;,
repos=NULL, type=&quot;source&quot;)<br />
<img src="../help/figures/TB.png" alt="HelpersMG logo" />

</p>


<h3>Details</h3>

<p>Helpers functions for several packages
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> HelpersMG</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 6.1 build 1527</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
print('----------------------------------')
print('Examples for mcmcComposite objects')
print('----------------------------------')
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(x, par) return(-sum(dnorm(x, mean=par['mean'], sd=par['sd'], log=TRUE)))
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=100000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
# Optimal rejection rate should be 0.234
rejectionRate(mcmcforcoda)
heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=10000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=10000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)
print('------------------------------------------')
print('Examples for Daily patterns of temperature')
print('------------------------------------------')
# Generate a timeserie of time
time.obs &lt;- NULL
for (i in 0:9) time.obs &lt;- c(time.obs, c(0, 6, 12, 18)+i*24)
# For these time, generate a timeseries of temperatures
temp.obs &lt;- rep(NA, length(time.obs))
temp.obs[3+(0:9)*4] &lt;- rnorm(10, 25, 3)
temp.obs[1+(0:9)*4] &lt;- rnorm(10, 10, 3)
for (i in 1:(length(time.obs)-1)) 
  if (is.na(temp.obs[i])) 
  temp.obs[i] &lt;- mean(c(temp.obs[i-1], temp.obs[i+1]))
  if (is.na(temp.obs[length(time.obs)])) 
  temp.obs[length(time.obs)] &lt;- temp.obs[length(time.obs)-1]/2
observed &lt;- data.frame(time=time.obs, temperature=temp.obs)
# Search for the minimum and maximum values
r &lt;- minmax.periodic(time.minmax.daily=c(Min=2, Max=15), 
observed=observed, period=24)

# Estimate all the temperatures for these values
t &lt;- temperature.periodic(minmax=r)

plot_errbar(x=t[,"time"], y=t[,"temperature"],
errbar.y=ifelse(is.na(t[,"sd"]), 0, 2*t[,"sd"]),
type="l", las=1, bty="n", errbar.y.polygon = TRUE, 
xlab="hours", ylab="Temperatures", ylim=c(0, 35), 
errbar.y.polygon.list = list(col="grey"))

plot_add(x=t[,"time"], y=t[,"temperature"], type="l")

# How many times this package has been download
library(cranlogs)
HelpersMG &lt;- cran_downloads("HelpersMG", from = "2015-04-07", 
                            to = Sys.Date() - 1) 
sum(HelpersMG$count)
plot(HelpersMG$date, HelpersMG$count, type="l", bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='addS3Class'>Add a S3 class to an object.</h2><span id='topic+addS3Class'></span>

<h3>Description</h3>

<p>Add a S3 class as first class to an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addS3Class(x, class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addS3Class_+3A_x">x</code></td>
<td>
<p>The object to add class.</p>
</td></tr>
<tr><td><code id="addS3Class_+3A_class">class</code></td>
<td>
<p>The class to add.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>addS3Class add a S3 class to an object
</p>


<h3>Value</h3>

<p>The same object with the new class as first class
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print.CF &lt;- function(x) {cat("print.CF ", x)}
result &lt;- "Je suis donc je pense"
result &lt;- addS3Class(result, class="CF")
class(result)
print(result)
result &lt;- addS3Class(result, class=c("ECF", "OCF"))
class(result)
print(result)
</code></pre>

<hr>
<h2 id='as.mcmc.mcmcComposite'>Extract mcmc object from a mcmcComposite object</h2><span id='topic+as.mcmc.mcmcComposite'></span>

<h3>Description</h3>

<p>Take a mcmcComposite object and create a mcmc.list object to be used with coda package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcComposite'
as.mcmc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.mcmcComposite_+3A_x">x</code></td>
<td>
<p>A mcmcComposite obtained as a result of <code>MHalgoGen()</code> function</p>
</td></tr>
<tr><td><code id="as.mcmc.mcmcComposite_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>as.mcmc Extract mcmc object from the result of phenology_MHmcmc to be used with coda package
</p>


<h3>Value</h3>

<p>A mcmc.list object
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.parameters'>Extract parameters from mcmcComposite object</h2><span id='topic+as.parameters'></span>

<h3>Description</h3>

<p>Take a mcmcComposite object and create a vector object with parameter value at specified iteration.<br />
If <code>index="best"</code>, the function will return the parameters for the highest likelihood. It also indicates at which iteration the maximum lihelihood has been observed.<br />
If <code>index="last"</code>, the function will return the parameters for the last likelihood.<br />
If <code>index="median"</code>, the function will return the median value of the parameter.<br />
if <code>index="quantile"</code>, the function will return the <code>probs</code> defined by quantiles parameter.<br />
If <code>index="mode"</code>, the function will return the mode value of the parameter based on Asselin de Beauville (1978) method.<br />
<code>index</code> can also be a numeric value.<br />
This function uses the complete iterations available except the adaptation part,
even if thin parameter is not equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.parameters(x, index = "best", chain = 1, probs = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.parameters_+3A_x">x</code></td>
<td>
<p>A mcmcComposite obtained as a result of <code>MHalgoGen()</code> function</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_index">index</code></td>
<td>
<p>At which iteration the parameters must be taken, see description</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_chain">chain</code></td>
<td>
<p>The number of the chain in which to get parameters</p>
</td></tr>
<tr><td><code id="as.parameters_+3A_probs">probs</code></td>
<td>
<p>Quantiles to be returned, see description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with parameters at maximum likelihood or index position
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Asselin de Beauville J.-P. (1978). Estimation non paramétrique de la densité et du mode,
exemple de la distribution Gamma. Revue de Statistique Appliquée, 26(3):47-70.
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
                              Prior1=c(10, 0.5), 
                              Prior2=c(2, 0.5), 
                              SDProp=c(1, 1), 
                              Min=c(-3, 0), 
                              Max=c(100, 10), 
                              Init=c(10, 2), 
                              stringsAsFactors = FALSE, 
                              row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
                      likelihood=dnormx, n.chains=1, n.adapt=100, 
                      thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)

# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp

# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
                       likelihood=dnormx, n.chains=1, n.adapt=1, 
                       thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)

####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
                       likelihood=dnormx, n.chains=1, n.adapt=0, 
                       thin=1, trace=1)
# With index being median, it returns the median value for each parameter
as.parameters(mcmc_run3, index="median")
as.parameters(mcmc_run3, index="mode")
as.parameters(mcmc_run3, index="best")
as.parameters(mcmc_run3, index="quantile", probs=0.025)
as.parameters(mcmc_run3, index="quantile", probs=0.975)
as.parameters(mcmc_run3, index="quantile", probs=c(0.025, 0.975))

## End(Not run)
</code></pre>

<hr>
<h2 id='as.quantiles'>Extract quantile distribution from mcmcComposite object</h2><span id='topic+as.quantiles'></span>

<h3>Description</h3>

<p>Extract quantile distribution from mcmcComposite object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.quantiles(
  x,
  chain = 1,
  fun = function(...) return(as.numeric(list(...))),
  probs = c(0.025, 0.975),
  xlim = NULL,
  nameparxlim = NULL,
  namepar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.quantiles_+3A_x">x</code></td>
<td>
<p>A mcmcComposite obtained as a result of <code>MHalgoGen()</code> function</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_chain">chain</code></td>
<td>
<p>The number of the chain in which to get parameters</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_fun">fun</code></td>
<td>
<p>The function to apply the parameters</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_probs">probs</code></td>
<td>
<p>The probability to get quantiles</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_xlim">xlim</code></td>
<td>
<p>The values to apply in fun</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_nameparxlim">nameparxlim</code></td>
<td>
<p>The name of the parameter for xlim</p>
</td></tr>
<tr><td><code id="as.quantiles_+3A_namepar">namepar</code></td>
<td>
<p>The name of parameters from mcmc object to be used in fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with quantiles
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=10000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
k &lt;- as.quantiles(x=mcmc_run, namepar="mean")
k &lt;- as.quantiles(x=mcmc_run, namepar="mean", 
                 xlim=c(1:5), nameparxlim="sd", 
                 fun=function(...) return(sum(as.numeric(list(...)))))

## End(Not run)
</code></pre>

<hr>
<h2 id='asc'>Return the codes (in UTF-8) of a string</h2><span id='topic+asc'></span>

<h3>Description</h3>

<p>Return the codes (in UTF-8) of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asc_+3A_x">x</code></td>
<td>
<p>The string to be analyzed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>asc returns the codes (in UTF-8) of a string
</p>


<h3>Value</h3>

<p>A vector with ITF-8 codes of a string
</p>


<h3>Author(s)</h3>

<p>Based on this blog: http://datadebrief.blogspot.com/2011/03/ascii-code-table-in-r.html
</p>


<h3>See Also</h3>

<p>Other Characters: 
<code><a href="#topic+char">char</a>()</code>,
<code><a href="#topic+d">d</a>()</code>,
<code><a href="#topic+tnirp">tnirp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asc("abcd")
asc("ABCD")
</code></pre>

<hr>
<h2 id='barplot_errbar'>Plot a barplot graph with error bar on y</h2><span id='topic+barplot_errbar'></span>

<h3>Description</h3>

<p>To plot data, just use it as a normal barplot but add the errbar.y
values or errbar.y.minus, errbar.y.plus if bars for y axis are
asymetric. Use y.plus and y.minus to set absolut limits for
error bars. Note that y.plus and y.minus have priority over errbar.y,
errbar.y.minus and errbar.y.plus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barplot_errbar(
  ...,
  errbar.y = NULL,
  errbar.y.plus = NULL,
  errbar.y.minus = NULL,
  y.plus = NULL,
  y.minus = NULL,
  errbar.tick = 1/50,
  errbar.lwd = par("lwd"),
  errbar.lty = par("lty"),
  errbar.col = par("fg"),
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot_errbar_+3A_...">...</code></td>
<td>
<p>Parameters for barplot() such as main= or ylim=</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.y">errbar.y</code></td>
<td>
<p>The length of error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.y.plus">errbar.y.plus</code></td>
<td>
<p>The length of positive error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.y.minus">errbar.y.minus</code></td>
<td>
<p>The length of negative error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_y.plus">y.plus</code></td>
<td>
<p>The absolut position of the positive error bar for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_y.minus">y.minus</code></td>
<td>
<p>The absolut position of the nagative error bar for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.tick">errbar.tick</code></td>
<td>
<p>Size of small ticks at the end of error bars defined as a proportion of total width or height graph size.</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.lwd">errbar.lwd</code></td>
<td>
<p>Error bar line width, see par(&quot;lwd&quot;)</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.lty">errbar.lty</code></td>
<td>
<p>Error bar line type, see par(&quot;lwd&quot;)</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_errbar.col">errbar.col</code></td>
<td>
<p>Error bar line color, see par(&quot;col&quot;)</p>
</td></tr>
<tr><td><code id="barplot_errbar_+3A_add">add</code></td>
<td>
<p>If true, add the graph to the previous one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>barplot_errbar plot a barplot with error bar on y
</p>


<h3>Value</h3>

<p>A numeric vector (or matrix, when beside = TRUE), say mp, giving the coordinates of all the bar midpoints drawn, useful for adding to the graph.<br />
If beside is true, use colMeans(mp) for the midpoints of each group of bars, see example.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>plot_errorbar</code>
</p>
<p>Other plot and barplot functions: 
<code><a href="#topic+ScalePreviousPlot">ScalePreviousPlot</a>()</code>,
<code><a href="#topic+plot_add">plot_add</a>()</code>,
<code><a href="#topic+plot_errbar">plot_errbar</a>()</code>,
<code><a href="#topic+show_name">show_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
barplot_errbar(rnorm(10, 10, 3), 
	xlab="axe x", ylab="axe y", bty="n", 
		errbar.y.plus=rnorm(10, 1, 0.1), col=rainbow(10), 
		names.arg=paste("Group",1:10), cex.names=0.6)
y &lt;- rnorm(10, 10, 3)
barplot_errbar(y, 
               	xlab="axe x", ylab="axe y", bty="n", 
            		y.plus=y+2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cArrows'>Draw curved lines with arrowhead</h2><span id='topic+cArrows'></span>

<h3>Description</h3>

<p>Draw a curved line with arrowhead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cArrows(
  x1,
  y1,
  x2,
  y2,
  code = 2,
  size = 1,
  width = 1.2/4/cin,
  open = TRUE,
  sh.adj = 0.1,
  sh.lwd = 1,
  sh.col = par("fg"),
  sh.lty = 1,
  h.col = sh.col,
  h.col.bo = sh.col,
  h.lwd = sh.lwd,
  h.lty = sh.lty,
  curved = FALSE,
  beautiful.arrow = 2/3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cArrows_+3A_x1">x1</code></td>
<td>
<p>coordinates of points from which to draw.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_y1">y1</code></td>
<td>
<p>coordinates of points from which to draw.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_x2">x2</code></td>
<td>
<p>coordinates of points to which to draw.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_y2">y2</code></td>
<td>
<p>coordinates of points to which to draw.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_code">code</code></td>
<td>
<p>integer code (1, 2, or 3), determining kind of arrows to be drawn.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_size">size</code></td>
<td>
<p>size of the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_width">width</code></td>
<td>
<p>width of the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_open">open</code></td>
<td>
<p>shape of the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_sh.adj">sh.adj</code></td>
<td>
<p>Shift the beginning of the line.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_sh.lwd">sh.lwd</code></td>
<td>
<p>width of the line.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_sh.col">sh.col</code></td>
<td>
<p>color of the line.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_sh.lty">sh.lty</code></td>
<td>
<p>type of line.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_h.col">h.col</code></td>
<td>
<p>color of the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_h.col.bo">h.col.bo</code></td>
<td>
<p>color of the arrowhead border.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_h.lwd">h.lwd</code></td>
<td>
<p>width of the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_h.lty">h.lty</code></td>
<td>
<p>type of line for the arrowhead.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_curved">curved</code></td>
<td>
<p>0 is a straigth line, positive of negative value make the line curved.</p>
</td></tr>
<tr><td><code id="cArrows_+3A_beautiful.arrow">beautiful.arrow</code></td>
<td>
<p>if open is false, make the arrowhead more beautiful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cArrows draws curved lines with arrowhead
</p>


<h3>Value</h3>

<p>A list wit lab.x and lab.y being the position where to draw label
</p>


<h3>Author(s)</h3>

<p>Modified from iGraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(1, 10), c(1, 10), type="n", bty="n")
cArrows(x1=2, y1=2, x2=6, y2=6, curved=1)
cArrows(x1=2, y1=2, x2=6, y2=6, curved=0)
cArrows(x1=2, y1=2, x2=6, y2=6, curved=1, sh.adj=1)
cArrows(x1=2, y1=2, x2=6, y2=6, curved=-1, open=FALSE)
cArrows(x1=9, y1=2, x2=6, y2=6, curved=-1, open=FALSE, sh.col="red")
cArrows(x1=9, y1=9, x2=6, y2=6, curved=-1, open=FALSE, h.col="red")
cArrows(x1=2, y1=9, x2=6, y2=6, curved=1, open=FALSE, h.col="red", h.col.bo="red")
</code></pre>

<hr>
<h2 id='ChangeCoordinate'>Return a value in a changed coordinate</h2><span id='topic+ChangeCoordinate'></span>

<h3>Description</h3>

<p>Return a value in a changed coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChangeCoordinate(
  x = stop("At least one value to convert must be provided"),
  initial = stop("Set of two values must be provided as references"),
  transformed = stop("Set of two transformed values must be provided")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChangeCoordinate_+3A_x">x</code></td>
<td>
<p>value to convert</p>
</td></tr>
<tr><td><code id="ChangeCoordinate_+3A_initial">initial</code></td>
<td>
<p>Set of two values in the original system</p>
</td></tr>
<tr><td><code id="ChangeCoordinate_+3A_transformed">transformed</code></td>
<td>
<p>Set of the two values in the converted system</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ChangeCoordinate returns a value in a changed coordinate
</p>


<h3>Value</h3>

<p>A value in the new system
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ChangeCoordinate(x=c(10, 20), initial=c(1, 100), transformed=c(0, 1))
</code></pre>

<hr>
<h2 id='char'>Return the characters defined by the codes</h2><span id='topic+char'></span>

<h3>Description</h3>

<p>Return a string with characters defined by the codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char_+3A_n">n</code></td>
<td>
<p>The code to be used to return a character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>char returns the characters defined by the codes
</p>


<h3>Value</h3>

<p>A string with characters defined by the codes
</p>


<h3>Author(s)</h3>

<p>Based on this blog: http://datadebrief.blogspot.com/2011/03/ascii-code-table-in-r.html
</p>


<h3>See Also</h3>

<p>Other Characters: 
<code><a href="#topic+asc">asc</a>()</code>,
<code><a href="#topic+d">d</a>()</code>,
<code><a href="#topic+tnirp">tnirp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char(65:75)
char(unlist(tapply(144:175, 144:175, function(x) {c(208, x)})))
</code></pre>

<hr>
<h2 id='compare'>Run a shiny application for basic functions of comparison</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Run a shiny application for basic functions of comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare()
</code></pre>


<h3>Details</h3>

<p>compare runs a shiny application for basic functions of comparison
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Girondot, M., Guillon, J.-M., 2018. The w-value: An alternative to t- and X2 tests. Journal of Biostatistics &amp; Biometrics 1, 1-3.
</p>


<h3>See Also</h3>

<p>Other w-value functions: 
<code><a href="#topic+contingencyTable.compare">contingencyTable.compare</a>()</code>,
<code><a href="#topic+series.compare">series.compare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
compare()

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_AIC'>Compares the AIC of several outputs</h2><span id='topic+compare_AIC'></span>

<h3>Description</h3>

<p>This function is used to compare the AIC of several outputs obtained with the same data but with different set of parameters.<br />
The parameters must be lists with $aic or $AIC or $value and $par elements or if AIC(element) is defined.<br />
if <code>$value</code> and <code>$par</code> are present in the object, the AIC is calculated as <code>2*factor.value*value+2*length(par)</code>. If <code>$value</code> is -log(likeihood), then factor.value must be 1 and if <code>$value</code> is log(likeihood), then factor.value must be -1.<br />
If several objects are within the same list, their AIC are summed.<br />
For example, compare_AIC(g1=list(group), g2=list(separe1, separe2)) can be used to compare a single model onto two different sets of data against each set of data fited with its own set of parameters.<br />
Take a look at <code>ICtab</code> in package <code>bbmle</code> which is similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_AIC(
  ...,
  factor.value = 1,
  silent = FALSE,
  FUN = function(x) specify_decimal(x, decimals = 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_AIC_+3A_...">...</code></td>
<td>
<p>Successive results to be compared as lists.</p>
</td></tr>
<tr><td><code id="compare_AIC_+3A_factor.value">factor.value</code></td>
<td>
<p>The $value of the list object is multiplied by factor.value to calculate AIC.</p>
</td></tr>
<tr><td><code id="compare_AIC_+3A_silent">silent</code></td>
<td>
<p>If TRUE, nothing is displayed.</p>
</td></tr>
<tr><td><code id="compare_AIC_+3A_fun">FUN</code></td>
<td>
<p>Function used to show values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>compare_AIC compares the AIC of several outputs obtained with the same data.
</p>


<h3>Value</h3>

<p>A list with DeltaAIC and Akaike weight for the models.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other AIC: 
<code><a href="#topic+ExtractAIC.glm">ExtractAIC.glm</a>()</code>,
<code><a href="#topic+FormatCompareAIC">FormatCompareAIC</a>()</code>,
<code><a href="#topic+compare_AICc">compare_AICc</a>()</code>,
<code><a href="#topic+compare_BIC">compare_BIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Here two different models are fitted
x &lt;- 1:30
y &lt;- rnorm(30, 10, 2)+log(x)
plot(x, y)
d &lt;- data.frame(x=x, y=y)
m1 &lt;- lm(y ~ x, data=d)
m2 &lt;- lm(y ~ log(x), data=d)
compare_AIC(linear=m1, log=m2)
# Here test if two datasets can be modeled with a single model
x2 &lt;- 1:30
y2 &lt;- rnorm(30, 15, 2)+log(x2)
plot(x, y, ylim=c(5, 25))
plot_add(x2, y2, col="red")
d2 &lt;- data.frame(x=x2, y=y2)
m1_2 &lt;- lm(y ~ x, data=d2)
x_grouped &lt;- c(x, x2)
y_grouped &lt;- c(y, y2)
d_grouped &lt;- data.frame(x=x_grouped, y=y_grouped)
m1_grouped &lt;- lm(y ~ x, data=d_grouped)
compare_AIC(separate=list(m1, m1_2), grouped=m1_grouped)

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_AICc'>Compares the AICc of several outputs</h2><span id='topic+compare_AICc'></span>

<h3>Description</h3>

<p>This function is used to compare the AICc of several outputs obtained with the same data but with different set of parameters.<br />
Each object must have associated <code>logLik()</code> method with df and nobs attributes.<br />
AICc for object x will be calculated as <code>2*factor.value*logLik(x)+(2*attributes(logLik(x))$df*(attributes(logLik(x))$df+1)/(attributes(logLik(x))$nobs-attributes(logLik(x))$df-1)</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_AICc(
  ...,
  factor.value = -1,
  silent = FALSE,
  FUN = function(x) specify_decimal(x, decimals = 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_AICc_+3A_...">...</code></td>
<td>
<p>Successive results to be compared as lists.</p>
</td></tr>
<tr><td><code id="compare_AICc_+3A_factor.value">factor.value</code></td>
<td>
<p>The $value of the list object is multiplied by factor.value to calculate BIC.</p>
</td></tr>
<tr><td><code id="compare_AICc_+3A_silent">silent</code></td>
<td>
<p>If TRUE, nothing is displayed.</p>
</td></tr>
<tr><td><code id="compare_AICc_+3A_fun">FUN</code></td>
<td>
<p>Function used to show values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>compare_AICc compares the AICc of several outputs obtained with the same data.
</p>


<h3>Value</h3>

<p>A list with DeltaAICc and Akaike weight for the models.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other AIC: 
<code><a href="#topic+ExtractAIC.glm">ExtractAIC.glm</a>()</code>,
<code><a href="#topic+FormatCompareAIC">FormatCompareAIC</a>()</code>,
<code><a href="#topic+compare_AIC">compare_AIC</a>()</code>,
<code><a href="#topic+compare_BIC">compare_BIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Here two different models are fitted
x &lt;- 1:30
y &lt;- rnorm(30, 10, 2)+log(x)
plot(x, y)
d &lt;- data.frame(x=x, y=y)
m1 &lt;- lm(y ~ x, data=d)
m2 &lt;- lm(y ~ log(x), data=d)
compare_BIC(linear=m1, log=m2, factor.value=-1)
# Here test if two datasets can be modeled with a single model
x2 &lt;- 1:30
y2 &lt;- rnorm(30, 15, 2)+log(x2)
plot(x, y, ylim=c(5, 25))
plot_add(x2, y2, col="red")
d2 &lt;- data.frame(x=x2, y=y2)
m1_2 &lt;- lm(y ~ x, data=d2)
x_grouped &lt;- c(x, x2)
y_grouped &lt;- c(y, y2)
d_grouped &lt;- data.frame(x=x_grouped, y=y_grouped)
m1_grouped &lt;- lm(y ~ x, data=d_grouped)
compare_AICc(separate=list(m1, m1_2), grouped=m1_grouped, factor.value=-1)
# Or simply
compare_AICc(m1=list(AICc=100), m2=list(AICc=102))

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_BIC'>Compares the BIC of several outputs</h2><span id='topic+compare_BIC'></span>

<h3>Description</h3>

<p>This function is used to compare the BIC of several outputs obtained with the same data but with different set of parameters.<br />
Each object must have associated <code>logLik()</code> method with df and nobs attributes.<br />
BIC for object x will be calculated as <code>2*factor.value*sum(logLik(x))+sum(attributes(logLik(x))$df)*log(attributes(logLik(x))$nobs))</code>.<br />
When several data (i..n) are included, the global BIC is calculated as:<br />
<code>2*factor.value*sum(logLik(x)) for i..n+sum(attributes(logLik(x))$df) for i..n*log(attributes(logLik(x))$nobs for i..n))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_BIC(
  ...,
  factor.value = -1,
  silent = FALSE,
  FUN = function(x) specify_decimal(x, decimals = 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_BIC_+3A_...">...</code></td>
<td>
<p>Successive results to be compared as lists.</p>
</td></tr>
<tr><td><code id="compare_BIC_+3A_factor.value">factor.value</code></td>
<td>
<p>The $value of the list object is multiplied by factor.value to calculate BIC.</p>
</td></tr>
<tr><td><code id="compare_BIC_+3A_silent">silent</code></td>
<td>
<p>If TRUE, nothing is displayed.</p>
</td></tr>
<tr><td><code id="compare_BIC_+3A_fun">FUN</code></td>
<td>
<p>Function used to show values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>compare_BIC compares the BIC of several outputs obtained with the same data.
</p>


<h3>Value</h3>

<p>A list with DeltaBIC and Akaike weight for the models.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other AIC: 
<code><a href="#topic+ExtractAIC.glm">ExtractAIC.glm</a>()</code>,
<code><a href="#topic+FormatCompareAIC">FormatCompareAIC</a>()</code>,
<code><a href="#topic+compare_AIC">compare_AIC</a>()</code>,
<code><a href="#topic+compare_AICc">compare_AICc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Here two different models are fitted
x &lt;- 1:30
y &lt;- rnorm(30, 10, 2)+log(x)
plot(x, y)
d &lt;- data.frame(x=x, y=y)
m1 &lt;- lm(y ~ x, data=d)
m2 &lt;- lm(y ~ log(x), data=d)
compare_BIC(linear=m1, log=m2, factor.value=-1)
# Here test if two datasets can be modeled with a single model
x2 &lt;- 1:30
y2 &lt;- rnorm(30, 15, 2)+log(x2)
plot(x, y, ylim=c(5, 25))
plot_add(x2, y2, col="red")
d2 &lt;- data.frame(x=x2, y=y2)
m1_2 &lt;- lm(y ~ x, data=d2)
x_grouped &lt;- c(x, x2)
y_grouped &lt;- c(y, y2)
d_grouped &lt;- data.frame(x=x_grouped, y=y_grouped)
m1_grouped &lt;- lm(y ~ x, data=d_grouped)
compare_BIC(separate=list(m1, m1_2), grouped=m1_grouped, factor.value=-1)

## End(Not run)
</code></pre>

<hr>
<h2 id='contingencyTable.compare'>Contingency table comparison using Akaike weight</h2><span id='topic+contingencyTable.compare'></span>

<h3>Description</h3>

<p>This function is used as a replacement of chisq.test() to not use p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingencyTable.compare(
  table,
  criterion = c("AIC", "AICc", "BIC"),
  probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingencyTable.compare_+3A_table">table</code></td>
<td>
<p>A matrix or a data.frame with series in rows and number of each category in column</p>
</td></tr>
<tr><td><code id="contingencyTable.compare_+3A_criterion">criterion</code></td>
<td>
<p>Which criterion is used for model selection</p>
</td></tr>
<tr><td><code id="contingencyTable.compare_+3A_probs">probs</code></td>
<td>
<p>Series of probabilities used for conformity comparison</p>
</td></tr>
</table>


<h3>Details</h3>

<p>contingencyTable.compare compares contingency table using Akaike weight.
</p>


<h3>Value</h3>

<p>The probability that a single proportion model is sufficient to explain the data
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Girondot, M., Guillon, J.-M., 2018. The w-value: An alternative to t- and X2 tests. Journal of Biostatistics &amp; Biometrics 1, 1-4.
</p>


<h3>See Also</h3>

<p>Other w-value functions: 
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+series.compare">series.compare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")

# Symmetry of Lepidochelys olivacea scutes
table &lt;- t(data.frame(SriLanka=c(200, 157), AfricaAtl=c(19, 12), 
                      Guyana=c(8, 6), Suriname=c(162, 88), 
                      MexicoPac1984=c(42, 34), MexicoPac2014Dead=c(8, 9),
                      MexicoPac2014Alive=c(13, 12), 
                      row.names =c("Symmetric", "Asymmetric")))
table
contingencyTable.compare(table)

table &lt;- t(data.frame(SriLanka=c(200, 157), AfricaAtl=c(19, 12), Guyana=c(8, 6),
                      Suriname=c(162, 88), MexicoPac1984=c(42, 34), 
                      MexicoPac2014Dead=c(8, 9),
                      MexicoPac2014Alive=c(13, 12), Lepidochelys.kempii=c(99, 1), 
                      row.names =c("Symmetric", "Asymmetric")))
table
contingencyTable.compare(table)

# Conformity to a model
table &lt;- matrix(c(33, 12, 25, 75), ncol = 2, byrow = TRUE)
probs &lt;- c(0.5, 0.5)
contingencyTable.compare(table, probs=probs)

# Conformity to a model
table &lt;- matrix(c(33, 12), ncol = 2, byrow = TRUE)
probs &lt;- c(0.5, 0.5)
contingencyTable.compare(table, probs=probs)

# Conformity to a model
table &lt;- matrix(c(33, 12, 8, 25, 75, 9), ncol = 3, byrow = TRUE)
probs &lt;- c(0.8, 0.1, 0.1)
contingencyTable.compare(table, probs=probs)

# Comparison of chisq.test() and this function
table &lt;- matrix(c(NA, NA, 25, 75), ncol = 2, byrow = TRUE)

pv &lt;- NULL
aw &lt;- NULL
par(new=FALSE)
n &lt;- 100

for (GroupA in 0:n) {
  table[1, 1] &lt;- GroupA
  table[1, 2] &lt;- n-GroupA
  pv &lt;- c(pv, chisq.test(table)$p.value)
  aw &lt;- c(aw, contingencyTable.compare(table, criterion="BIC")[1])
}

x &lt;- 0:n
y &lt;- pv
y2 &lt;- aw
plot(x=x, y=y, type="l", bty="n", las=1, xlab="Number of type P in Group B", ylab="Probability", 
     main="", lwd=2)
lines(x=x, y=y2, type="l", col="red", lwd=2)

# w-value
(l1 &lt;- x[which(aw&gt;0.05)[1]])
(l2 &lt;- rev(x)[which(rev(aw)&gt;0.05)[1]])

aw[l1]
pv[l1]

aw[l2+2]
pv[l2+2]

# p-value
l1 &lt;- which(pv&gt;0.05)[1]
l2 &lt;- max(which(pv&gt;0.05))

aw[l1]
pv[l1]

aw[l2]
pv[l2]

y[which(y2&gt;0.05)[1]]
y[which(rev(y2)&gt;0.05)[1]]

par(xpd=TRUE)
text(x=25, y=1.15, labels="Group A: 25 type P / 100", pos=1)

segments(x0=25, y0=0, x1=25, y1=1, lty=3)

# plot(1, 1)

v1 &lt;- c(expression(italic("p")*"-value"), expression("after "*chi^2*"-test"))
v2 &lt;- c(expression(italic("w")*"-value for A"), expression("and B identical models"))
legend("topright", legend=c(v1, v2), 
       y.intersp = 1, 
       col=c("black", "black", "red", "red"), bty="n", lty=c(1, 0, 1, 0))

segments(x0=0, x1=n, y0=0.05, y1=0.05, lty=2)
text(x=101, y=0.05, labels = "0.05", pos=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='convert.tz'>Convert one Date-Time from one timezone to another</h2><span id='topic+convert.tz'></span>

<h3>Description</h3>

<p>Convert one Date-Time from one timezone to another.<br />
Available timezones can be shown using OlsonNames().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.tz(x, tz = Sys.timezone())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.tz_+3A_x">x</code></td>
<td>
<p>The date-time in POSIXlt or POSIXct format</p>
</td></tr>
<tr><td><code id="convert.tz_+3A_tz">tz</code></td>
<td>
<p>The timezone</p>
</td></tr>
</table>


<h3>Details</h3>

<p>convert.tz Convert one Date-Time from one timezone to another
</p>


<h3>Value</h3>

<p>A POSIXlt or POSIXct date converted
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Function <code>with_tz()</code> from <code>lubridate</code> package does the same. I keep it here only for compatibility with old scripts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- as.POSIXlt("2010-01-01 17:34:20", tz="UTC")
convert.tz(d, tz="America/Guatemala")
</code></pre>

<hr>
<h2 id='cutter'>Distribution of the fitted distribution without cut.</h2><span id='topic+cutter'></span>

<h3>Description</h3>

<p>If observations is a data.frame, it can have 4 columns:<br />
A column for the measurements;<br />
A column for the lower detection limit;<br />
A column for the upper detection limit;<br />
A column for the truncated of censored nature of the data.<br />
The names of the different columns are in the observations.colname, lower_detection_limit.colname,
upper_detection_limit.colname and cut_method.colname.<br />
If lower_detection_limit.colname is NULL or if the column does not exist,
the data are supposed to not be left-cut
and if upper_detection_limit.colname is NULL or if the column does not exist,
the data are supposed to not be right-cut.<br />
If observations is a vector, then the parameters lower_detection_limit and/or upper_detection_limit
must be given. Then cut_method must be also provided.<br />
In abservations, -Inf must be used to indicate a value below the lower detection limit and +Inf must be used
for a value above the upper detection limit.<br />
Be careful: NA is used to represent a missing data and not a value below of above the detection limit.<br />
If lower_detection_limit, upper_detection_limit or cut_method are only one value, they are supposed to
be used for all the observations.<br />
Definitions for censored or truncated distribution vary, and the two terms are sometimes used interchangeably. Let the following data set:<br />
1 1.25 2 4 5<br />
<br />
Censoring: some observations will be censored, meaning that we only know that they are below (or above) some bound. This can for instance occur if we measure the concentration of a chemical in a water sample. If the concentration is too low, the laboratory equipment cannot detect the presence of the chemical. It may still be present though, so we only know that the concentration is below the laboratory's detection limit.<br />
<br />
If the detection limit is 1.5, so that observations that fall below this limit is censored, our example data set would become:<br />
&lt;1.5 &lt;1.5 2 4 5; that is, we don't know the actual values of the first two observations, but only that they are smaller than 1.5.<br />
<br />
Truncation: the process generating the data is such that it only is possible to observe outcomes above (or below) the truncation limit. This can for instance occur if measurements are taken using a detector which only is activated if the signals it detects are above a certain limit. There may be lots of weak incoming signals, but we can never tell using this detector.<br />
<br />
If the truncation limit is 1.5, our example data set would become: 2 4 5; and we would not know that there in fact were two signals which were not recorded.<br />
If n.iter is NULL, no Bayesian MCMC is performed but credible interval will not be available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutter(
  observations = stop("Observations must be provided"),
  observations.colname = "Observations",
  lower_detection_limit.colname = "LDL",
  upper_detection_limit.colname = "UDL",
  cut_method.colname = "Cut",
  par = NULL,
  lower_detection_limit = NULL,
  upper_detection_limit = NULL,
  cut_method = "censored",
  distribution = "gamma",
  n.mixture = 1,
  n.iter = 5000,
  n.adapt = 100,
  debug = FALSE,
  progress.bar = TRUE,
  session = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutter_+3A_observations">observations</code></td>
<td>
<p>The observations; see description</p>
</td></tr>
<tr><td><code id="cutter_+3A_observations.colname">observations.colname</code></td>
<td>
<p>If observations is a data.frame, the name of column with observations</p>
</td></tr>
<tr><td><code id="cutter_+3A_lower_detection_limit.colname">lower_detection_limit.colname</code></td>
<td>
<p>If observations is a data.frame, the name of column with lower detection limit</p>
</td></tr>
<tr><td><code id="cutter_+3A_upper_detection_limit.colname">upper_detection_limit.colname</code></td>
<td>
<p>If observations is a data.frame, the name of column with upper detection limit</p>
</td></tr>
<tr><td><code id="cutter_+3A_cut_method.colname">cut_method.colname</code></td>
<td>
<p>If observations is a data.frame, the name of column with cut method, being &quot;censored&quot; or &quot;truncated&quot;</p>
</td></tr>
<tr><td><code id="cutter_+3A_par">par</code></td>
<td>
<p>Initial values for parameters of distribution</p>
</td></tr>
<tr><td><code id="cutter_+3A_lower_detection_limit">lower_detection_limit</code></td>
<td>
<p>Value for lower detection limit</p>
</td></tr>
<tr><td><code id="cutter_+3A_upper_detection_limit">upper_detection_limit</code></td>
<td>
<p>Value for upper detection limit</p>
</td></tr>
<tr><td><code id="cutter_+3A_cut_method">cut_method</code></td>
<td>
<p>Value for cut method, being &quot;censored&quot; or &quot;truncated&quot;</p>
</td></tr>
<tr><td><code id="cutter_+3A_distribution">distribution</code></td>
<td>
<p>Can be gamma, normal, weibull, lognormal, or generalized.gamma</p>
</td></tr>
<tr><td><code id="cutter_+3A_n.mixture">n.mixture</code></td>
<td>
<p>Number of distributions</p>
</td></tr>
<tr><td><code id="cutter_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iteration for Bayesian MCMC and to estimate the goodness-of-fit</p>
</td></tr>
<tr><td><code id="cutter_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Number of burn-in iterations Bayesian MCMC</p>
</td></tr>
<tr><td><code id="cutter_+3A_debug">debug</code></td>
<td>
<p>If TRUE, show some information</p>
</td></tr>
<tr><td><code id="cutter_+3A_progress.bar">progress.bar</code></td>
<td>
<p>If TRUE, show a progress bar for MCMC</p>
</td></tr>
<tr><td><code id="cutter_+3A_session">session</code></td>
<td>
<p>The session of a shiny process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cutter returns the fitted distribution without cut
</p>


<h3>Value</h3>

<p>The parameters of distribution of values below or above the detection limit.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# _______________________________________________________________
# right censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 100
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&gt;DL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="censored")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10), col.mcmc=NULL)
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# The same data seen as truncated data with gamma distribution
# _______________________________________________________________
obc &lt;- obc[is.finite(obc)]
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="truncated")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# left censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored")
result
plot(result, xlim=c(0, 200), breaks=seq(from=0, to=300, by=10))
# _______________________________________________________________
# left censored distribution with mixture of gamma distribution
# _______________________________________________________________
#' # Detection limit
library(HelpersMG)
# Generate 200 random data from a gamma distribution
set.seed(1234)
obc &lt;- c(rgamma(100, scale=10, shape=5), rgamma(100, scale=20, shape=10))
LDL &lt;- 20
l &lt;- seq(from=0, to=LDL, length.out=1001)
p &lt;- pgamma(l, scale=10, shape=5)*0.5+pgamma(l, scale=20, shape=10)
deltal &lt;- l[2]-l[1]
expected_LDL &lt;- sum((l[-1]-deltal/2)*(p[-1]-p[-length(p)]))/sum((p[-1]-p[-length(p)]))
# remove the data below the detection limit
obc[obc&lt;LDL] &lt;- -Inf

UDL &lt;- 300
l &lt;- seq(from=UDL, to=1000, length.out=1001)
p &lt;- pgamma(l, scale=10, shape=5)*0.5+pgamma(l, scale=20, shape=10)
deltal &lt;- l[2]-l[1]
expected_UDL &lt;- sum((l[-1]-deltal/2)*(p[-1]-p[-length(p)]))/sum((p[-1]-p[-length(p)]))
obc[obc&gt;UDL] &lt;- +Inf

# search for the parameters the best fit these truncated data
result1_gamma &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="gamma", 
                          cut_method="censored", n.iter=5000, debug=0)
result1_normal &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="normal", 
                          cut_method="censored", n.iter=5000)
result1_lognormal &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="lognormal", 
                          cut_method="censored", n.iter=5000)
result1_Weibull &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL,  
                          distribution="Weibull", 
                          cut_method="censored", n.iter=5000)
result1_generalized.gamma &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="generalized.gamma", 
                          cut_method="censored", n.iter=5000)
result2_gamma &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="gamma", 
                          n.mixture=2, 
                          cut_method="censored", n.iter=5000)
result2_normal &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="normal", 
                          n.mixture=2, 
                          cut_method="censored", n.iter=5000)
result2_lognormal &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="lognormal", 
                          n.mixture=2, 
                          cut_method="censored", n.iter=5000)
result2_Weibull &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="Weibull", 
                          n.mixture=2, 
                          cut_method="censored", n.iter=5000)
result2_generalized.gamma &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                          upper_detection_limit = UDL, 
                          distribution="generalized.gamma", 
                          n.mixture=2, 
                          cut_method="censored", n.iter=5000)
                          
compare_AIC(nomixture.gamma=result1_gamma, 
             nomixture.normal=result1_normal, 
             nomixture.lognormal=result1_lognormal, 
             nomixture.Weibull=result1_Weibull, 
             nomixture.generalized.gamma=result1_generalized.gamma, 
             mixture.gamma=result2_gamma, 
             mixture.normal=result2_normal, 
             mixture.lognormal=result2_lognormal, 
             mixture.Weibull=result2_Weibull, 
             mixture.generalized.gamma=result2_generalized.gamma)
             
plot(result2_gamma, xlim=c(0, 600), breaks=seq(from=0, to=600, by=10))
plot(result2_generalized.gamma, xlim=c(0, 600), breaks=seq(from=0, to=600, by=10))

# _______________________________________________________________
# left and right censored distribution
# _______________________________________________________________
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# Detection limit
LDL &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL] &lt;- -Inf
# Detection limit
UDL &lt;- 100
# remove the data below the detection limit
obc[obc&gt;UDL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                           upper_detection_limit=UDL, 
                          cut_method="censored")
result
plot(result, xlim=c(0, 150), col.DL=c("black", "grey"), 
                             col.unobserved=c("green", "blue"), 
     breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# Example with two values for lower detection limits
# corresponding at two different methods of detection for example
# with gamma distribution
# _______________________________________________________________
obc &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL1 &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL1] &lt;- -Inf
obc2 &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL2 &lt;- 20
# remove the data below the detection limit
obc2[obc2&lt;LDL2] &lt;- -Inf
obc &lt;- c(obc, obc2)
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, 
                           lower_detection_limit=c(rep(LDL1, 50), rep(LDL2, 50)), 
                          cut_method="censored")
result
# It is difficult to choose the best set of colors
plot(result, xlim=c(0, 150), col.dist="red", 
     col.unobserved=c(rgb(red=1, green=0, blue=0, alpha=0.1), 
                      rgb(red=1, green=0, blue=0, alpha=0.2)), 
     col.DL=c(rgb(red=0, green=0, blue=1, alpha=0.5), 
                      rgb(red=0, green=0, blue=1, alpha=0.9)), 
     breaks=seq(from=0, to=200, by=10))
     
# ________________________________________________________________________
# left censored distribution comparison of normal, lognormal, 
# weibull, generalized gamma, and gamma without Bayesian MCMC
# Comparison with Akaike Information Criterion
# ________________________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf

result_gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="gamma", 
                          n.iter=NULL)
plot(result_gamma)

result_lognormal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="lognormal", 
                          n.iter=NULL)
plot(result_lognormal)

result_weibull &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="weibull", 
                          n.iter=NULL)
plot(result_weibull)

result_normal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="normal", 
                          n.iter=NULL)
plot(result_normal)

result_generalized.gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="generalized.gamma", 
                          n.iter=NULL)
plot(result_generalized.gamma)

compare_AIC(gamma=result_gamma, 
            lognormal=result_lognormal, 
            normal=result_normal, 
            Weibull=result_weibull, 
            Generalized.gamma=result_generalized.gamma)

# ______________________________________________________________________________
# left censored distribution comparison of normal, lognormal, 
# weibull, generalized gamma, and gamma
# ______________________________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result_gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="gamma")
result_gamma
plot(result_gamma, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_lognormal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="lognormal")
result_lognormal
plot(result_lognormal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_weibull &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="weibull")
result_weibull
plot(result_weibull, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_normal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="normal")
result_normal
plot(result_normal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_generalized.gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="generalized.gamma")
result_generalized.gamma
plot(result_generalized.gamma, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

# ___________________________________________________________________
# Test for similarity in gamma left censored distribution between two
# datasets
# ___________________________________________________________________
obc1 &lt;- rgamma(100, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL &lt;- 10
# remove the data below the detection limit
obc1[obc1&lt;LDL] &lt;- -Inf
obc2 &lt;- rgamma(100, scale=10, shape=2)
# remove the data below the detection limit
obc2[obc2&lt;LDL] &lt;- -Inf
# search for the parameters the best fit these censored data
result1 &lt;- cutter(observations=obc1, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored", n.iter=NULL)
logLik(result1)
plot(result1, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result2 &lt;- cutter(observations=obc2, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored", n.iter=NULL)
logLik(result2)
plot(result2, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result_totl &lt;- cutter(observations=c(obc1, obc2), 
                      distribution="gamma", 
                      lower_detection_limit=LDL, 
                      cut_method="censored", n.iter=NULL)
logLik(result_totl)
plot(result_totl, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
     
compare_AIC(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)
compare_BIC(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)           

## End(Not run)
</code></pre>

<hr>
<h2 id='d'>Write an ASCII Representation of a vector object</h2><span id='topic+d'></span>

<h3>Description</h3>

<p>Writes an ASCII text representation of an R object.<br />
It can be used as a replacement of dput() for named vectors.<br />
The controls &quot;keepNA&quot;, &quot;keepInteger&quot; and &quot;showAttributes&quot; are utilized for named vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d(
  x,
  file = "",
  control = c("keepNA", "keepInteger", "showAttributes"),
  collapse = ", \n  "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_+3A_x">x</code></td>
<td>
<p>A named vector object</p>
</td></tr>
<tr><td><code id="d_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a connection. &quot;&quot; indicates output to the console.</p>
</td></tr>
<tr><td><code id="d_+3A_control">control</code></td>
<td>
<p>character vector indicating deparsing options. See .deparseOpts for their description.</p>
</td></tr>
<tr><td><code id="d_+3A_collapse">collapse</code></td>
<td>
<p>Characters used to separate values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>d Write an ASCII Representation of a vector object
</p>


<h3>Value</h3>

<p>A string
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Characters: 
<code><a href="#topic+asc">asc</a>()</code>,
<code><a href="#topic+char">char</a>()</code>,
<code><a href="#topic+tnirp">tnirp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d(c(A=10, B=20))
dput(c(A=10, B=20))
</code></pre>

<hr>
<h2 id='dbeta_new'>Density for the Beta distributions.</h2><span id='topic+dbeta_new'></span>

<h3>Description</h3>

<p>Density for the Beta distribution with parameters mu and v or shape1 and
shape2 (and optional non-centrality parameter ncp).<br />
The returned object has three attributes:<br />
shape1, shape2, and ncp<br />
Note that if x has other attributes, they are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbeta_new(
  x,
  mu = NULL,
  v = NULL,
  shape1,
  shape2,
  ncp = 0,
  log = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbeta_new_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_mu">mu</code></td>
<td>
<p>mean of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_v">v</code></td>
<td>
<p>variance of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_shape1">shape1</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter.</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dbeta_new_+3A_silent">silent</code></td>
<td>
<p>If FALSE, show the shape1 and shape 2 values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dbeta_new returns the density for the Beta distributions
</p>
<p>The Beta distribution with parameters shape1 = a and shape2 = b has density <br />
gamma(a+b)/(gamma(a)gamma(b))x^(a-1)(1-x)^(b-1)<br />
for a &gt; 0, b &gt; 0 and 0 &lt;= x &lt;= 1 where the boundary values at x=0 or x=1 are defined as by
continuity (as limits).<br />
The mean is a/(a+b) and the variance is ab/((a+b)^2 (a+b+1)). These moments and all
distributional properties can be defined as limits.
</p>


<h3>Value</h3>

<p>dbeta_new gives the density for the Beta distributions
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pi &lt;- rbeta(100, shape1=0.48, shape2=0.12)
hist(pi, freq=FALSE, breaks=seq(from=0, to=1, by=0.1), ylim=c(0, 8), las=1)
library("HelpersMG")
mx &lt;- ScalePreviousPlot()$ylim["end"]/
      max(dbeta_new(seq(from=0.01, to=0.99, by=0.01), mu = 0.8, v=0.1))
curve(dbeta_new(x, mu = 0.8, v=0.1)*mx, add=TRUE, col="red")
out &lt;- dbeta_new(0.1, mu = 0.8, v=0.1)
out
attributes(out)$shape1; attributes(out)$shape2; attributes(out)$ncp
dbeta(0.1, shape1=attributes(out)$shape1, shape2=attributes(out)$shape2, 
      ncp=attributes(out)$ncp)

# It can be used to generate random numbers using mu and v
out &lt;- dbeta_new(0.1, mu = 0.8, v=0.1, silent=TRUE)
pi &lt;- rbeta(100, shape1=attributes(out)$shape1, shape2=attributes(out)$shape2, 
      ncp=attributes(out)$ncp)
hist(pi, freq=FALSE, breaks=seq(from=0, to=1, by=0.1), ylim=c(0, 8), las=1)
</code></pre>

<hr>
<h2 id='dcutter'>Distribution of the fitted distribution without cut.</h2><span id='topic+dcutter'></span>

<h3>Description</h3>

<p>If observations must be a data.frame with 4 columns:<br />
observations: A column for the measurements;<br />
LDL: A column for the lower detection limit;<br />
UDL: A column for the upper detection limit;<br />
Cut: A column for the truncated of censored nature of the data.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcutter(
  par,
  observations = NULL,
  distribution = "gamma",
  n.mixture = NULL,
  debug = FALSE,
  limits.lower = NULL,
  limits.upper = NULL,
  log = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcutter_+3A_par">par</code></td>
<td>
<p>Values for parameters of distribution</p>
</td></tr>
<tr><td><code id="dcutter_+3A_observations">observations</code></td>
<td>
<p>The observations; see description.</p>
</td></tr>
<tr><td><code id="dcutter_+3A_distribution">distribution</code></td>
<td>
<p>Can be gamma, normal, weibull, lognormal, or generalized.gamma.</p>
</td></tr>
<tr><td><code id="dcutter_+3A_n.mixture">n.mixture</code></td>
<td>
<p>Number of distributions</p>
</td></tr>
<tr><td><code id="dcutter_+3A_debug">debug</code></td>
<td>
<p>If TRUE, show some information. If 2, show more information.</p>
</td></tr>
<tr><td><code id="dcutter_+3A_limits.lower">limits.lower</code></td>
<td>
<p>Value for lower detection limit</p>
</td></tr>
<tr><td><code id="dcutter_+3A_limits.upper">limits.upper</code></td>
<td>
<p>Value for upper detection limit</p>
</td></tr>
<tr><td><code id="dcutter_+3A_log">log</code></td>
<td>
<p>If TRUE, return the log likelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dcutter returns the density of the cutter function
</p>


<h3>Value</h3>

<p>The density of the cutter function according to observations.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
par &lt;- c('shape1' = 0.42265849507444225, 
         'scale1' = 14.139457094879594, 
         'shape2' = 1.667131542489706, 
         'scale2' = 0.10763344388223803, 
         'p1' = 0.12283307526788023)
obs &lt;- data.frame(Observations=c(0.755, 1.013, 2.098, 6.265, 4.708, 0.078, 2.169, 0.403, 1.251, 
                                 0.008, 1.419, 1.078, 2.744, 81.534, 1.426, 13.486, 7.813, 0.165, 
                                 0.118, 0.864, 0.369, 7.159, 2.605, 1.579, 1.646, 0.484, 4.492, 
                                 0.139, 0.28, 0.154, 0.106, 0.104, 4.185, 0.735, 0.149, 0.183, 
                                 0.062, 8.246, 0.165, 0.121, 0.109, 0.092, 0.162, 0.108, 0.139, 
                                 0.141, 0.124, 0.124, 0.151, 0.141, 0.364, 0.295, 0.09, 0.135, 
                                 0.154, 0.218, 0.167, -Inf, 0.203, 0.228, 0.107, 0.162, 0.194, 
                                 0.322, 0.351, 0.17, 0.236, 0.176, 0.107, 0.12, 0.095, 0.27, 0.194, 
                                 0.125, 0.123, 0.085, 0.164, 0.106, 0.079, 0.162), 
                 LDL=0.001, UDL=NA, Cut="censored")
dcutter(par=par, observations=obs, distribution="gamma", 
        n.mixture=NULL, debug=FALSE, limits.lower=NULL, 
        limits.upper=NULL,log=FALSE)
dcutter(par=par, observations=obs, distribution="gamma", 
        n.mixture=NULL, debug=FALSE, limits.lower=NULL, 
        limits.upper=NULL, log=TRUE)
        

## End(Not run)
</code></pre>

<hr>
<h2 id='dggamma'>Generalized gamma distribution.</h2><span id='topic+dggamma'></span><span id='topic+pggamma'></span><span id='topic+qggamma'></span><span id='topic+rggamma'></span>

<h3>Description</h3>

<p>Generalized gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dggamma(x, theta, kappa, delta, log = FALSE)

pggamma(q, theta, kappa, delta, lower.tail = TRUE, log.p = FALSE)

qggamma(p, theta, kappa, delta, lower.tail = TRUE, log.p = FALSE)

rggamma(n, theta, kappa, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dggamma_+3A_x">x</code>, <code id="dggamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_theta">theta</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_kappa">kappa</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_delta">delta</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_log">log</code>, <code id="dggamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <em>p</em> are given as <em>log(p)</em>.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <em>P[X &lt;= x]</em> otherwise, <em>P[X &gt; x]</em>.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dggamma_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pggamma</code>, <code>qggamma</code>, <code>dggamma</code>, and <code>rggamma</code> are used to model the
generalized gamma distribution.
</p>
<p>The code is modified from <a href="https://rpubs.com/FJRubio/GG">https://rpubs.com/FJRubio/GG</a>.
</p>


<h3>Value</h3>

<p><code>dggamma</code> gives the density, <code>pggamma</code> gives the distribution function,
<code>qggamma</code> gives the quantile function, and <code>rggamma</code> generates random deviates.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dggamma()</code>: Density of the generalized gamma.
</p>
</li>
<li> <p><code>pggamma()</code>: Distribution function of the generalized gamma.
</p>
</li>
<li> <p><code>qggamma()</code>: Quantile of the generalized gamma.
</p>
</li>
<li> <p><code>rggamma()</code>: Random of the generalized gamma.
</p>
</li></ul>


<h3>More details here</h3>

<p>The generalized gamma is described here <a href="https://en.wikipedia.org/wiki/Generalized_gamma_distribution">https://en.wikipedia.org/wiki/Generalized_gamma_distribution</a>.<br />
With <code>a</code> being <code>theta</code>, <code>b</code> being <code>kappa</code>, and <code>p</code> being <code>delta</code>.<br />
<code>theta</code>, <code>kappa</code> and <code>delta</code> must be all &gt; 0.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To reproduce the wikipedia page graphic
x &lt;- seq(from=0, to=8, by=0.1)
plot(x, dggamma(x, theta=2, kappa=0.5, delta=0.5), lty=1, col="blue", 
     type="l", lwd=2, xlab="x", ylab="PDF")
lines(x, dggamma(x, theta=1, kappa=1, delta=0.5), lty=1, col="green", lwd=2)
lines(x, dggamma(x, theta=2, kappa=1, delta=2), lty=1, col="red", lwd=2)
lines(x, dggamma(x, theta=5, kappa=1, delta=5), lty=1, col="yellow", lwd=2)
lines(x, dggamma(x, theta=7, kappa=1, delta=7), lty=1, col="grey", lwd=2)
legend("topright", legend=c("a=2, d=0.5, p=0.5", "a=1, d=1, p=0.5", 
                            "a=2, d=1, p=2", "a=5, d=1, p=5", "a=7, d=1, p=7"), 
                            col=c("blue", "green", "red", "yellow", "grey"), 
                            lty=1, lwd=2, bty="n")
par &lt;- c(theta=2, kappa=0.5, delta=0.5)
# Mean, var and sd
mean.ggamma &lt;- function(theta, kappa, delta) 
       return(theta*(gamma((kappa+1)/delta))/gamma(kappa/delta))
var.ggamma &lt;- function(theta, kappa, delta) 
       return(theta^2* ( ( (gamma((kappa+2)/delta))/gamma(kappa/delta) ) - 
                ( (gamma((kappa+1)/delta))/gamma(kappa/delta) )^2 ) )
sd.ggamma &lt;- function(theta, kappa, delta) 
       return(sqrt(theta^2* ( ( (gamma((kappa+2)/delta))/gamma(kappa/delta) ) - 
                ( (gamma((kappa+1)/delta))/gamma(kappa/delta) )^2 ) ))
</code></pre>

<hr>
<h2 id='DIx'>Return an index of quantitative asymmetry and complexity named Developmental Instability Index (DIx)</h2><span id='topic+DIx'></span>

<h3>Description</h3>

<p>Return an index of quantitative asymmetry and complexity.<br />
Higher is the value, higher is the complexity (number of objects) and diversity (difference between them).<br />
The indice is based on the product of the average angular distance of
Edwards (1971) for all permutations of measures for both sides with the
geometric mean of the inverse of Shannon entropy H for both sides.
Let p1 and p2 two vectors of relative measures of objects with sum(p1) = 1 and sum(p2)=1
and n1 being the number of objects in p1 and n2 being the number of objects in p2.<br />
Edwards distance for all permutations of p1 and p2 objects are computed and the average value E is calculated.<br />
The maximun possible Shannon index for identical n1 is max1 = sum((1/n1) * log(1/n1)).<br />
Shannon index is v1 = sum(p1 * log(p1)).<br />
If version == 2, the complementary of Shannon index for these n1 objects is used: c1 = 2 * max1 - v1<br />
If version == 1, the Shannon index is used directly.<br />
The geometry mean between both sides defined the measure of diversity within each side: S=sqrt(c1 * c2)<br />
The Developmental Instability Index is then S * E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIx(l1, l2, details = FALSE, version = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIx_+3A_l1">l1</code></td>
<td>
<p>Set of measures at one side of an organism</p>
</td></tr>
<tr><td><code id="DIx_+3A_l2">l2</code></td>
<td>
<p>Set of measures at the other side of an organism</p>
</td></tr>
<tr><td><code id="DIx_+3A_details">details</code></td>
<td>
<p>If TRUE, will show the details of computing</p>
</td></tr>
<tr><td><code id="DIx_+3A_version">version</code></td>
<td>
<p>Can be 1 or 2; see description</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DIx returns an index of quantitative asymmetry and complexity
</p>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Edwards, A.W.F., 1971. Distances between populations on the basis of gene frequencies. Biometrics 27, 873–881.<br />
Shannon C.E. 1948 A mathematical theory of communication. Bell System Technical Journal 27(3), 379-423.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l1 &lt;- c(0.1, 0.1, 0.05, 0.2, 0.3, 0.25)
l2 &lt;- c(0.2, 0.3, 0.5)
DIx(l1, l2)

l1 &lt;- c(0.1, 0.1, 0.05, 0.2, 0.3, 0.25)
l2 &lt;- c(0.1, 0.1, 0.05, 0.2, 0.3, 0.25)
DIx(l1, l2)

l1 &lt;- c(0.2, 0.3, 0.5)
l2 &lt;- c(0.2, 0.3, 0.5)
DIx(l1, l2)

l1 &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)
l2 &lt;- c(0.2, 0.3, 0.5)
DIx(l1, l2)

l1 &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)
l2 &lt;- c(0.3333, 0.3333, 0.3333)
DIx(l1, l2)

l1 &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)
l2 &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)
DIx(l1, l2)

l1 &lt;- c(0.3333, 0.3333, 0.3333)
l2 &lt;- c(0.3333, 0.3333, 0.3333)
DIx(l1, l2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dnbinom_new'>Random numbers for the negative binomial distribution.</h2><span id='topic+dnbinom_new'></span>

<h3>Description</h3>

<p>Density for the negative binomial distribution with parameters mu, sd, var, size or prob. See <code>dnbinom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnbinom_new(
  x,
  size = NULL,
  prob = NULL,
  mu = NULL,
  sd = NULL,
  var = NULL,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnbinom_new_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion parameter (the shape parameter of the gamma mixing distribution). Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. 0 &lt; prob &lt;= 1.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_sd">sd</code></td>
<td>
<p>alternative parametrization via standard deviation.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_var">var</code></td>
<td>
<p>alternative parametrization via variance.</p>
</td></tr>
<tr><td><code id="dnbinom_new_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dnbinom_new returns density for the negative binomial distribution
</p>


<h3>Value</h3>

<p>Random numbers for the negative binomial distribution
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
set.seed(1)
x &lt;- rnbinom_new(n=100, mu=2, sd=3)
LnL &lt;- NULL
df &lt;- data.frame(mu=seq(from=0.1, to=8, by=0.1), "-LnL"=NA)
for (mu in df[, "mu"])
LnL &lt;- c(LnL, -sum(dnbinom_new(x=x, mu=mu, sd=3, log=TRUE)))
df[, "-LnL"] &lt;- LnL
ggplot(data = df, aes(x = .data[["mu"]], y = .data[["-LnL"]])) + geom_line()
# Examples of wrong parametrization
dnbinom_new(x=x, mu=c(1, 2), sd=3, log=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dSnbinom'>Distribution of the sum independent negative binomial random variables.</h2><span id='topic+dSnbinom'></span><span id='topic+pSnbinom'></span><span id='topic+qSnbinom'></span><span id='topic+rSnbinom'></span>

<h3>Description</h3>

<p>Distribution of the sum of random variable with negative binomial distributions.<br />
Technically the sum of random variable with negative binomial distributions is a convolution of negative
binomial random variables.<br />
<code>dSnbinom</code> returns the density for the sum of random variable with negative binomial distributions.<br />
<code>pSnbinom</code> returns the distribution function for the sum of random variable with negative binomial distributions.<br />
<code>qSnbinom</code> returns the quantile function for the sum of random variable with negative binomial distributions.<br />
<code>rSnbinom</code> returns random numbers for the sum of random variable with negative binomial distributions.<br />
If all prob values are the same, exact probabilities are estimated.<br />
Estimate using <code>Vellaisamy&amp;Upadhye</code> method uses parallel computing
depending on value of <code>parallel</code>. The number of cores in usage can be
defined using <code>options(mc.cores = c)</code> with <code>c</code> being the number of cores to be used. By default it will
use all the available cores. Forking will be used in Unix system and no forking on Windows systems.<br />
When <code>Furman</code> method is in use, it will return the progress of Pr(S = x) during recursion
in an attribute if verbose is TRUE (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSnbinom(
  x = stop("You must provide at least one x value"),
  size = NULL,
  prob = NULL,
  mu = NULL,
  log = FALSE,
  tol = NULL,
  method = "Furman",
  normalize = TRUE,
  max.iter = NULL,
  mean = NULL,
  sd = NULL,
  n.random = 1e+06,
  parallel = FALSE,
  verbose = FALSE
)

pSnbinom(
  q = stop("At least one quantile must be provided"),
  size = NULL,
  prob = NULL,
  mu = NULL,
  lower.tail = TRUE,
  log.p = FALSE,
  tol = NULL,
  method = "Furman",
  normalize = TRUE
)

qSnbinom(
  p = stop("At least one probability must be provided"),
  size = stop("size parameter is mandatory"),
  prob = NULL,
  mu = NULL,
  lower.tail = TRUE,
  log.p = FALSE,
  tol = NULL,
  method = "Furman"
)

rSnbinom(n = 1, size = NULL, prob = NULL, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dSnbinom_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion parameter (the shape parameter of the gamma mixing distribution). Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. 0 &lt; prob &lt;= 1.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_log">log</code>, <code id="dSnbinom_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <em>p</em> are given as <em>log(p)</em>.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_tol">tol</code></td>
<td>
<p>Tolerance for recurrence for Furman (2007) method. If NULL, will use a saddlepoint estimation.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_method">method</code></td>
<td>
<p>Can be Furman (default), Vellaisamy&amp;Upadhye or exact, approximate.normal, approximate.negativebinomial, approximate.RandomObservations, or saddlepoint.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_normalize">normalize</code></td>
<td>
<p>If TRUE (default) will normalize the saddlepoint approximation estimate.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of maximum iterations for Furman method. Can be NULL.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_mean">mean</code></td>
<td>
<p>Mean of the distribution for approximate.normal method. If NULL, the theoretical mean will be used.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the distribution for approximate.normal method. If NULL, the theoretical sd will be used.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_n.random">n.random</code></td>
<td>
<p>Number of random numbers used to estimate parameters of distribution for approximate.RandomObservations method.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_parallel">parallel</code></td>
<td>
<p>logical; if FALSE (default), parallel computing is not used for Vellaisamy&amp;Upadhye methods.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_verbose">verbose</code></td>
<td>
<p>Give more information on the method.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x], otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dSnbinom_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distribution of the Sum of Independent Negative Binomial Random Variables.
</p>


<h3>Value</h3>

<p><code>dSnbinom</code> gives the density, <code>pSnbinom</code> gives the distribution function,
<code>qSnbinom</code> gives the quantile function, and <code>rSnbinom</code> generates random deviates.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dSnbinom()</code>: Density for the sum of random variable with negative binomial distributions.
</p>
</li>
<li> <p><code>pSnbinom()</code>: Distribution function for the sum of random variable with negative binomial distributions.
</p>
</li>
<li> <p><code>qSnbinom()</code>: Quantile function for the sum of random variable with negative binomial distributions.
</p>
</li>
<li> <p><code>rSnbinom()</code>: Random numbers for the sum of random variable with negative binomial distributions.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a> and Jon Barry <a href="mailto:jon.barry@cefas.gov.uk">jon.barry@cefas.gov.uk</a>
</p>


<h3>References</h3>

<p>Furman, E., 2007. On the convolution of the negative binomial random variables. Statistics &amp; Probability Letters 77, 169-172.
</p>
<p>Vellaisamy, P. &amp; Upadhye, N.S. 2009. On the sums of compound negative binomial and gamma random variables. Journal of Applied Probability, 46, 272-283.
</p>
<p>Girondot M, Barry J. 2023. Computation of the distribution of the sum of independent negative binomial random variables. Mathematical and Computational Applications 2023, 28, 63, doi:10.3390/mca28030063
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
alpha &lt;- c(1, 2, 5, 1, 2)
p &lt;- c(0.1, 0.12, 0.13, 0.14, 0.14)
# By default, the Furman method with tol=1E-40 is used
dSnbinom(20, size=alpha, prob=p)
# Note the attribute is the dynamics of convergence of Pr(X=x)
attributes(dSnbinom(20, size=alpha, prob=p, verbose=TRUE))$Pk[, 1]

mutest &lt;- c(0.01, 0.02, 0.03)
sizetest &lt;- 2
x &lt;- 20
# Exact probability
dSnbinom(x, size=sizetest, mu=mutest, method="vellaisamy&amp;upadhye")
dSnbinom(x, size=sizetest, mu=mutest, method="vellaisamy&amp;upadhye", log=TRUE)
# With Furman method and tol=1E-12, when probability 
# is very low, it will be biased
dSnbinom(x, size=sizetest, mu=mutest, method="Furman", tol=1E-12)
# The solution is to use a tolerance lower than the estimate
dSnbinom(x, size=sizetest, mu=mutest, method="Furman", tol=1E-45)
# Here the estimate used a first estimation by saddlepoint approximation
dSnbinom(x, size=sizetest, mu=mutest, method="Furman", tol=NULL)
# Or a huge number of iterations; but it is not the best solution
dSnbinom(x, size=sizetest, mu=mutest, method="Furman", 
         tol=1E-12, max.iter=10000)
# With the saddle point approximation method
dSnbinom(x, size=sizetest, mu=mutest, method="saddlepoint", log=FALSE)
dSnbinom(x, size=sizetest, mu=mutest, method="saddlepoint", log=TRUE)

# Another example
sizetest &lt;- c(1, 1, 0.1)
mutest &lt;- c(2, 1, 10)
x &lt;- 5
(exact &lt;- dSnbinom(x=x, size=sizetest, mu=mutest, method="Vellaisamy&amp;Upadhye"))
(sp &lt;- dSnbinom(x=x, size=sizetest, mu=mutest, method="saddlepoint"))
paste0("Saddlepoint approximation: Error of ", specify_decimal(100*abs(sp-exact)/exact, 2), "%")
(furman &lt;- dSnbinom(x=x, size=sizetest, mu=mutest, method="Furman"))
paste0("Inversion of mgf: Error of ", specify_decimal(100*abs(furman-exact)/exact, 2), "%")
(na &lt;- dSnbinom(x=x, size=sizetest, mu=mutest, method="approximate.normal")) 
paste0("Gaussian approximation: Error of ", specify_decimal(100*abs(na-exact)/exact, 2), "%")
(nb &lt;- dSnbinom(x=x, size=sizetest, mu=mutest, method="approximate.negativebinomial"))
paste0("NB approximation: Error of ", specify_decimal(100*abs(nb-exact)/exact, 2), "%")

plot(0:20, dSnbinom(0:20, size=sizetest, mu=mutest, method="furman"), bty="n", type="h", 
     xlab="x", ylab="Density", ylim=c(0, 0.2), las=1)
points(x=0:20, y=dSnbinom(0:20, size=sizetest, mu=mutest, 
                           method="saddlepoint"), pch=1, col="blue")
points(x=0:20, y=dSnbinom(0:20, size=sizetest, mu=mutest, 
                           method="approximate.negativebinomial"), 
                           col="red")
points(x=0:20, y=dSnbinom(0:20, size=sizetest, mu=mutest, 
                           method="approximate.normal"), 
                           col="green")

# Test with a single distribution
dSnbinom(20, size=1, mu=20)
# when only one distribution is available, it is the same as dnbinom()
dnbinom(20, size=1, mu=20)

# If a parameter is supplied as only one value, it is supposed to be constant
dSnbinom(20, size=1, mu=c(14, 15, 10))
dSnbinom(20, size=c(1, 1, 1), mu=c(14, 15, 10))

# The functions are vectorized:
plot(0:200, dSnbinom(0:200, size=alpha, prob=p, method="furman"), bty="n", type="h", 
     xlab="x", ylab="Density")
points(0:200, dSnbinom(0:200, size=alpha, prob=p, method="saddlepoint"), 
     col="red", pch=3)
     
# Comparison with simulated distribution using rep replicates
alpha &lt;- c(2.1, 2.05, 2)
mu &lt;- c(10, 30, 20)
rep &lt;- 100000
distEmpirique &lt;- rSnbinom(rep, size=alpha, mu=mu)
tabledistEmpirique &lt;- rep(0, 301)
names(tabledistEmpirique) &lt;- as.character(0:300)
tabledistEmpirique[names(table(distEmpirique))] &lt;- table(distEmpirique)/rep

plot(0:300, dSnbinom(0:300, size=alpha, mu=mu, method="furman"), type="h", bty="n", 
   xlab="x", ylab="Density", ylim=c(0,0.02))
plot_add(0:(length(tabledistEmpirique)-1), tabledistEmpirique, type="l", col="red")
legend(x=200, y=0.02, legend=c("Empirical", "Theoretical"), 
   text.col=c("red", "black"), bty="n")


# Example from Vellaisamy, P. &amp; Upadhye, N.S. (2009) - Table 1
# Note that computing time for k = 7 using exact method is very long
k &lt;- 2:7
x &lt;- c(3, 5, 8, 10, 15)
table1_Vellaisamy &lt;- matrix(NA, ncol=length(x), nrow=length(k))
rownames(table1_Vellaisamy) &lt;- paste0("n = ", as.character(k))
colnames(table1_Vellaisamy) &lt;- paste0("x = ", as.character(x))
table1_approximateObservations &lt;- table1_Vellaisamy
table1_Furman3 &lt;- table1_Vellaisamy
table1_Furman6 &lt;- table1_Vellaisamy
table1_Furman9 &lt;- table1_Vellaisamy
table1_Furman12 &lt;- table1_Vellaisamy
table1_Furman40 &lt;- table1_Vellaisamy
table1_Furman40 &lt;- table1_Vellaisamy
table1_FurmanAuto &lt;- table1_Vellaisamy
table1_FurmanAuto_iter &lt;- table1_Vellaisamy
table1_Vellaisamy_parallel &lt;- table1_Vellaisamy
table1_Approximate_Normal &lt;- table1_Vellaisamy
table1_saddlepoint &lt;- table1_Vellaisamy

st_Furman3 &lt;- rep(NA, length(k))
st_Furman6 &lt;- rep(NA, length(k))
st_Furman9 &lt;- rep(NA, length(k))
st_Furman12 &lt;- rep(NA, length(k))
st_Furman40 &lt;- rep(NA, length(k))
st_FurmanAuto &lt;- rep(NA, length(k))
st_approximateObservations &lt;- rep(NA, length(k))
st_Vellaisamy &lt;- rep(NA, length(k))
st_Vellaisamy_parallel &lt;- rep(NA, length(k))
st_Approximate_Normal &lt;- rep(NA, length(k))
st_saddlepoint &lt;- rep(NA, length(k))

for (n in k) {
    print(n)
    alpha &lt;- 1:n
    p &lt;- (1:n)/10
    st_Vellaisamy[which(n == k)] &lt;- 
        system.time({
        table1_Vellaisamy[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Vellaisamy&amp;Upadhye", log=FALSE, verbose=FALSE)
        })[1]
    st_Vellaisamy_parallel[which(n == k)] &lt;- 
        system.time({
        table1_Vellaisamy_parallel[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     parallel=TRUE, 
                                     method="Vellaisamy&amp;Upadhye", log=FALSE, verbose=FALSE)
        })[1]
    st_approximateObservations[which(n == k)] &lt;- 
        system.time({
        table1_approximateObservations[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="approximate.RandomObservations", log=FALSE, 
                                     verbose=FALSE)
        })[1]
    st_Furman3[which(n == k)] &lt;- 
        system.time({
            table1_Furman3[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=1E-3, log=FALSE, 
                                     verbose=FALSE)
        })[1]
    st_Furman6[which(n == k)] &lt;- 
        system.time({
            table1_Furman6[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=1E-6, log=FALSE, 
                                     verbose=FALSE)
        })[1]
    st_Furman9[which(n == k)] &lt;- 
        system.time({
            table1_Furman9[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=1E-9, log=FALSE, 
                                     verbose=FALSE)
        })[1]
    st_Furman12[which(n == k)] &lt;- 
        system.time({
            table1_Furman12[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=1E-12, log=FALSE, 
                                     verbose=FALSE)
        })[1]
    st_Furman40[which(n == k)] &lt;- 
        system.time({
            table1_Furman40[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=1E-40, log=FALSE, 
                                     verbose=FALSE)
        })[1]

    st_FurmanAuto[which(n == k)] &lt;- 
        system.time({
            table1_FurmanAuto[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="Furman", tol=NULL, log=FALSE, 
                                     verbose=FALSE)
        })[1]

    st_Approximate_Normal[which(n == k)] &lt;- 
        system.time({
            table1_Approximate_Normal[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="approximate.normal", tol=1E-12, log=FALSE, 
                                     verbose=FALSE)
        })[1]
        st_saddlepoint[which(n == k)] &lt;- 
        system.time({
            table1_saddlepoint[which(n == k), ] &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                                     method="saddlepoint", tol=1E-12, log=FALSE, 
                                     verbose=FALSE)
        })[1]

for (xc in x) {
 essai &lt;- dSnbinom(x=xc, prob=p, size=alpha, method="Furman", tol=NULL, log=FALSE, verbose=TRUE)
 table1_FurmanAuto_iter[which(n == k), which(xc == x)] &lt;- nrow(attributes(essai)[[1]])
}
}

cbind(table1_Vellaisamy, st_Vellaisamy)
cbind(table1_Vellaisamy_parallel, st_Vellaisamy_parallel)
cbind(table1_Furman3, st_Furman3)
cbind(table1_Furman6, st_Furman6)
cbind(table1_Furman9, st_Furman9)
cbind(table1_Furman12, st_Furman12)
cbind(table1_Furman40, st_Furman40)
cbind(table1_FurmanAuto, st_FurmanAuto)
cbind(table1_approximateObservations, st_approximateObservations)
cbind(table1_Approximate_Normal, st_Approximate_Normal)
cbind(table1_saddlepoint, st_saddlepoint)


# Test of different methods
n &lt;- 9
x &lt;- 17
alpha &lt;- 1:n
p &lt;- (1:n)/10

# Parallel computing is not always performant
# Here it is very performant
system.time({print(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=TRUE))})
system.time({print(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=FALSE))})
         
# Test of different methods
n &lt;- 7
x &lt;- 8
alpha &lt;- 1:n
p &lt;- (1:n)/10

# Parallel computing is not always performant
# Here it is approximately the same time of execution
system.time({print(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=TRUE))})
system.time({print(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=FALSE))})
         
# Test of different methods
n &lt;- 7
x &lt;- 15
alpha &lt;- 1:n
p &lt;- (1:n)/10

# Parallel computing is sometimes very performant
# Here parallel computing is 7 times faster (with a 8 cores computer) 
#             for vellaisamy&amp;upadhye method
system.time(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=TRUE))
system.time(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=FALSE))
         
# Test of different methods
n &lt;- 2
x &lt;- 3
alpha &lt;- 1:n
p &lt;- (1:n)/10

# Parallel computing is sometimes very performant
# Here parallel computing is 7 times faster (with a 8 cores computer) 
#             for vellaisamy&amp;upadhye method
system.time(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=TRUE))
system.time(dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, 
         verbose=TRUE, parallel=FALSE))
         
# Test for different tolerant values
n &lt;- 7
x &lt;- 8
alpha &lt;- 1:n
p &lt;- (1:n)/10
dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, verbose=TRUE)
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-3, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-6, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-9, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Saddlepoint", log=FALSE, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="approximate.RandomObservations", 
         log=FALSE, verbose=TRUE))

# Test for criteria of convergence
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, 
                 verbose=TRUE)
Pr_exact;as.numeric(Pr_Furman)
plot(1:length(attributes(Pr_Furman)$Pk), 
     log10(abs(attributes(Pr_Furman)$Pk-Pr_exact)), type="l", xlab="Iterations", 
     ylab="Abs log10", bty="n")
lines(1:(length(attributes(Pr_Furman)$Pk)-1), 
      log10(abs(diff(attributes(Pr_Furman)$Pk))), col="red")
legend("bottomleft", legend=c("Log10 Convergence to true value", "Log10 Rate of change"), 
       col=c("black", "red"), 
       lty=1)
       
n &lt;- 7
x &lt;- 6
alpha &lt;- 1:n
p &lt;- (1:n)/10
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, 
                 verbose=TRUE)
Pr_saddlepoint &lt;- dSnbinom(x=x, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)                  
                 
# pdf("figure.pdf", width=7, height=7, pointsize=14)                 
ylab &lt;- as.expression(bquote(.("P(S=6) x 10")^"6"))
layout(1:2)
par(mar=c(3, 4, 1, 1))
plot(1:length(attributes(Pr_Furman)$Pk), 
     attributes(Pr_Furman)$Pk*1E6, type="l", xlab="", 
     ylab="", bty="n", las=1, xlim=c(0, 80))
mtext(text=ylab, side=2, line=2.5)
segments(x0=25, x1=80, y0=Pr_exact*1E6, y1=Pr_exact*1E6, lty=3)
par(xpd=TRUE)
text(x=0, y=6, labels="Exact probability", pos=4)
txt &lt;- "        Approximate probability\n    based on Furman (2007)\nrecursive iterations"
text(x=20, y=2, labels=txt, pos=4)
text(x=75, y=5, labels="A", cex=2)
par(mar=c(4, 4, 1, 1))
ylab &lt;- as.expression(bquote("log"["10"]*""*"(P"["k+1"]*""*" - P"["k"]*""*")"))
plot(1:(length(attributes(Pr_Furman)$Pk)-1), 
      log10(diff(attributes(Pr_Furman)$Pk)), col="black", xlim=c(0, 80), type ="l", 
      bty="n", las=1, xlab="Iterations", ylab="")
mtext(text=ylab, side=2, line=2.5)
 peak &lt;- (1:(length(attributes(Pr_Furman)$Pk)-1))[which.max(
            log10(abs(diff(attributes(Pr_Furman)$Pk))))]
segments(x0=peak, x1=peak, y0=-12, y1=-5, lty=2)
text(x=0, y=-6, labels="Positive trend", pos=4)
text(x=30, y=-6, labels="Negative trend", pos=4)
segments(x0=0, x1=43, y0=-12, y1=-12, lty=4)
segments(x0=62, x1=80, y0=-12, y1=-12, lty=4)
text(x=45, y=-12, labels="Tolerance", pos=4)
text(x=75, y=-7, labels="B", cex=2)
# dev.off()

# pdf("figure 2.pdf", width=7, height=7, pointsize=14)                 
ylab &lt;- as.expression(bquote(.("P(S=6) x 10")^"6"))
layout(1:2)
par(mar=c(3, 4, 1, 1))
plot(1:length(attributes(Pr_Furman)$Pk), 
     attributes(Pr_Furman)$Pk*1E6, type="l", xlab="", 
     ylab="", bty="n", las=1, xlim=c(0, 80))
mtext(text=ylab, side=2, line=2.5)
segments(x0=25, x1=80, y0=Pr_exact*1E6, y1=Pr_exact*1E6, lty=3)
par(xpd=TRUE)
text(x=0, y=6, labels="Exact probability", pos=4)
txt &lt;- "        Approximate probability\n    based on Furman (2007)\nrecursive iterations"
text(x=20, y=2, labels=txt, pos=4)
text(x=75, y=5, labels="A", cex=2)
par(mar=c(4, 4, 1, 1))
ylab &lt;- as.expression(bquote("(P"["k+1"]*""*" - P"["k"]*""*") x 10"^"7"))
plot(1:(length(attributes(Pr_Furman)$Pk)-1), 
      diff(attributes(Pr_Furman)$Pk)*1E7, 
      col="black", xlim=c(0, 80), type ="l", 
      bty="n", las=1, xlab="Iterations", ylab="")
mtext(text=ylab, side=2, line=2.5)
 peak &lt;- (1:(length(attributes(Pr_Furman)$Pk)-1))[which.max(diff(attributes(Pr_Furman)$Pk))]
segments(x0=peak, x1=peak, y0=0, y1=3.5, lty=2)
text(x=-2, y=3.5, labels="Positive trend", pos=4)
text(x=30, y=3.5, labels="Negative trend", pos=4)
segments(x0=0, x1=22, y0=1E-12, y1=1E-12, lty=4)
segments(x0=40, x1=80, y0=1E-12, y1=1E-12, lty=4)
text(x=22, y=1E-12+0.2, labels="Tolerance", pos=4)
text(x=75, y=3, labels="B", cex=2)
# dev.off()

# Test of different methods
n &lt;- 2
x &lt;- 15
alpha &lt;- 1:n
p &lt;- (1:n)/10
dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", log=FALSE, verbose=TRUE)
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-3, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-6, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-9, verbose=TRUE))
as.numeric(dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, verbose=TRUE))
dSnbinom(x=x, prob=p, size=alpha, method="approximate.RandomObservations", 
         log=FALSE, verbose=TRUE)


n &lt;- 50
x &lt;- 300
alpha &lt;- (1:n)/100
p &lt;- (1:n)/1000
# Produce an error
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, 
                 verbose=FALSE)
Pr_ApproximateNormal &lt;- dSnbinom(x=x, prob=p, size=alpha, method="approximate.normal", 
                        log=FALSE, 
                        verbose=TRUE)
Pr_ApproximateRandom &lt;- dSnbinom(x=x, prob=p, size=alpha, method="approximate.RandomObservations", 
                        log=FALSE, n.random=1E6, 
                        verbose=TRUE)
                        
n &lt;- 500
x &lt;- 3000
alpha &lt;- (1:n)/100
p &lt;- (1:n)/1000
# Produce an error
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, 
                 verbose=FALSE)
Pr_ApproximateNormal &lt;- dSnbinom(x=x, prob=p, size=alpha, method="approximate.normal", 
                        log=FALSE, 
                        verbose=TRUE)
Pr_ApproximateNegativeBinomial &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                        method="approximate.negativebinomial", 
                        log=FALSE, 
                        verbose=TRUE)
Pr_ApproximateRandom &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                        method="approximate.RandomObservations", 
                        log=FALSE, n.random=1E6, 
                        verbose=TRUE)
Pr_ApproximateSaddlepoint &lt;- dSnbinom(x=x, prob=p, size=alpha, 
                        method="saddlepoint", 
                        log=FALSE, 
                        verbose=TRUE)
             
             
             
layout(matrix(1:4, ncol=2, byrow=TRUE))
par(mar=c(3, 4.5, 1, 1))
alpha &lt;- seq(from=10, to=100, length.out=3)
p &lt;- seq(from=0.5, to=0.9, length.out=3)

p_nb &lt;- dSnbinom(0:100, prob=p, size=alpha, method="vellaisamy&amp;upadhye", verbose=TRUE)
p_Furman &lt;- dSnbinom(0:100, prob=p, size=alpha, method="Furman", verbose=FALSE)
p_normal &lt;- dSnbinom(0:100, prob=p, size=alpha, method="approximate.normal", verbose=TRUE)
p_aNB &lt;- dSnbinom(0:100, prob=p, size=alpha, method="approximate.negativebinomial", verbose=TRUE)
p_SA &lt;- dSnbinom(0:100, prob=p, size=alpha, method="saddlepoint", verbose=TRUE)

lab_PSnx &lt;- bquote(italic("P(S"* "" [n] * "=x)"))

plot(1, 1, las=1, bty="n", col="grey", xlab="", 
       xlim=c(10, 70), ylim=c(0, 0.05), 
       ylab=lab_PSnx, type="n")
par(xpd=FALSE)
segments(x0=(0:100), x1=(0:100), 
         y0=0, y1=as.numeric(p_nb), col="black")
         
plot(x=p_nb, y=p_normal, pch=4, cex=0.5, las=1, bty="n", 
     xlab=bquote(italic("P" * "" [exact] * "(S"* "" [n] * "=x)")), 
     ylab=bquote(italic("P" * "" [approximate] * "(S"* "" [n] * "=x)")),  
     xlim=c(0, 0.05), ylim=c(0, 0.05))
points(x=p_nb, y=p_aNB, pch=5, cex=0.5)
points(x=p_nb, y=p_SA, pch=6, cex=0.5)
points(x=p_Furman, y=p_SA, pch=19, cex=0.5)

n &lt;- 2
x &lt;- 15
alpha &lt;- 1:n
p &lt;- (1:n)/10

p_nb &lt;- dSnbinom(0:80, prob=p, size=alpha, method="vellaisamy&amp;upadhye", verbose=TRUE)
p_Furman &lt;- dSnbinom(0:80, prob=p, size=alpha, method="Furman", verbose=FALSE)
p_normal &lt;- dSnbinom(0:80, prob=p, size=alpha, method="approximate.normal", verbose=TRUE)
p_aNB &lt;- dSnbinom(0:80, prob=p, size=alpha, method="approximate.negativebinomial", verbose=TRUE)
p_SA &lt;- dSnbinom(0:80, prob=p, size=alpha, method="saddlepoint", verbose=TRUE)


par(mar=c(4, 4.5, 1, 1))
plot(1, 1, las=1, bty="n", col="grey", xlab="x", 
       xlim=c(0, 60), ylim=c(0, 0.05), 
       ylab=lab_PSnx, type="n")
par(xpd=FALSE)
segments(x0=(0:80), x1=(0:80), 
         y0=0, y1=as.numeric(p_nb), col="black")
         
plot(x=p_nb, y=p_normal, pch=4, cex=0.5, las=1, bty="n", 
     xlab=bquote(italic("P" * "" [exact] * "(S"* "" [n] * "=x)")), 
     ylab=bquote(italic("P" * "" [approximate] * "(S"* "" [n] * "=x)")), 
     xlim=c(0, 0.05), ylim=c(0, 0.05))
points(x=p_nb, y=p_aNB, pch=5, cex=0.5)
points(x=p_nb, y=p_SA, pch=6, cex=0.5)
points(x=p_Furman, y=p_SA, pch=19, cex=0.5)

# pdf("figure 1.pdf", width=7, height=7, pointsize=14)    

layout(1:2)
par(mar=c(3, 4, 1, 1))
alpha &lt;- seq(from=10, to=100, length.out=3)
p &lt;- seq(from=0.5, to=0.9, length.out=3)

p_nb &lt;- dSnbinom(0:100, prob=p, size=alpha, method="vellaisamy&amp;upadhye", verbose=TRUE)
p_Furman &lt;- dSnbinom(0:100, prob=p, size=alpha, method="Furman", verbose=FALSE)
p_normal &lt;- dSnbinom(0:100, prob=p, size=alpha, method="approximate.normal", verbose=TRUE)
p_aNB &lt;- dSnbinom(0:100, prob=p, size=alpha, method="approximate.negativebinomial", verbose=TRUE)
p_SA &lt;- dSnbinom(0:100, prob=p, size=alpha, method="saddlepoint", verbose=TRUE)

lab_PSnx &lt;- bquote(italic("P(S"* "" [n] * "=x)"))

plot(1, 1, las=1, bty="n", col="grey", xlab="", 
       xlim=c(10, 70), ylim=c(0, 0.09), 
       ylab="", type="n", yaxt="n")
axis(2, at=seq(from=0, to=0.05, by=0.01), las=1)
mtext(lab_PSnx, side = 2, adj=0.3, line=3)
par(xpd=FALSE)
segments(x0=(0:100), x1=(0:100), 
         y0=0, y1=as.numeric(p_nb), col="black")
errr &lt;- (abs((100*(p_Furman-p_nb)/p_nb)))/1000+0.055
errr &lt;- ifelse(is.infinite(errr), NA, errr)
lines(x=(0:100), y=errr, lty=5, col="red", lwd=2)
errr &lt;- (abs((100*(p_normal-p_nb)/p_nb)))/1000+0.055
lines(x=(0:100), y=errr, lty=2, col="blue", lwd=2)
errr &lt;- (abs((100*(p_aNB-p_nb)/p_nb)))/1000+0.055
lines(x=(0:100), y=errr, lty=3, col="purple", lwd=2)
errr &lt;- (abs((100*(p_SA-p_nb)/p_nb)))/1000+0.055
lines(x=(0:100), y=errr, lty=4, col="green", lwd=2)
axis(2, at=seq(from=0, to=40, by=10)/1000+0.055, las=1, 
     labels=as.character(seq(from=0, to=40, by=10)))
mtext("|% error|", side = 2, adj=0.9, line=3)
par(xpd=TRUE)
legend(x=30, y=0.1, legend=c("Inversion of mgf", "Saddlepoint", "Normal", "Negative binomial"), 
       lty=c(5, 4, 2, 3), bty="n", cex=0.8, col=c("red", "green", "blue", "purple"), lwd=2)
legend(x=10, y=0.05, legend=c("Exact"), lty=c(1), bty="n", cex=0.8)
par(xpd=TRUE)
text(x=ScalePreviousPlot(x = 0.95, y = 0.1)$x, 
     y=ScalePreviousPlot(x = 0.95, y = 0.1)$y, labels="A", cex=2)
     
     
# When normal approximation will fail
n &lt;- 2
x &lt;- 15
alpha &lt;- 1:n
p &lt;- (1:n)/10

p_nb &lt;- dSnbinom(0:80, prob=p, size=alpha, method="vellaisamy&amp;upadhye", verbose=TRUE)
p_Furman &lt;- dSnbinom(0:80, prob=p, size=alpha, method="Furman", verbose=FALSE)
p_normal &lt;- dSnbinom(0:80, prob=p, size=alpha, method="approximate.normal", verbose=TRUE)
p_aNB &lt;- dSnbinom(0:80, prob=p, size=alpha, method="approximate.negativebinomial", verbose=TRUE)
p_SA &lt;- dSnbinom(0:80, prob=p, size=alpha, method="saddlepoint", verbose=TRUE)

par(mar=c(4, 4, 1, 1))
plot(1, 1, las=1, bty="n", col="grey", xlab="x", 
       xlim=c(0, 60), ylim=c(0, 0.09), 
       ylab="", type="n", yaxt="n")
axis(2, at=seq(from=0, to=0.05, by=0.01), las=1)
mtext(lab_PSnx, side = 2, adj=0.3, line=3)
par(xpd=FALSE)
segments(x0=(0:80), x1=(0:80), 
         y0=0, y1=as.numeric(p_nb), col="black")
errr &lt;- (abs((100*(p_Furman-p_nb)/p_nb)))/1000+0.055
errr &lt;- ifelse(is.infinite(errr), NA, errr)
lines(x=(0:80), y=errr, lty=5, col="red", lwd=2)
errr &lt;- (abs((100*(p_normal-p_nb)/p_nb)))/1000+0.055
lines(x=(0:80), y=errr, lty=2, col="blue", lwd=2)
errr &lt;- (abs((100*(p_aNB-p_nb)/p_nb)))/1000+0.055
lines(x=(0:80), y=errr, lty=3, col="purple", lwd=2)
errr &lt;- (abs((100*(p_SA-p_nb)/p_nb)))/1000+0.055
lines(x=(0:80), y=errr, lty=4, col="green", lwd=2)
axis(2, at=seq(from=0, to=40, by=10)/1000+0.055, las=1, 
     labels=as.character(seq(from=0, to=40, by=10)))
mtext("|% error|", side = 2, adj=0.9, line=3)
legend(x=30, y=0.055, 
       legend=c("Exact", "Inversion of mgf", "Saddlepoint", "Normal", "Negative binomial"), 
       lty=c(1, 5, 4, 2, 3), bty="n", cex=0.8, col=c("black", "red", "green", "blue", "purple"), 
       lwd=c(1, 2, 2, 2, 2))
par(xpd=TRUE)
text(x=ScalePreviousPlot(x = 0.95, y = 0.1)$x, 
     y=ScalePreviousPlot(x = 0.95, y = 0.1)$y, labels="B", cex=2)
     

# dev.off()


# Test for criteria of convergence
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, 
                 verbose=TRUE)
Pr_exact;as.numeric(Pr_Furman)
plot(1:length(attributes(Pr_Furman)$Pk), 
     log10(abs(attributes(Pr_Furman)$Pk-Pr_exact)), type="l", xlab="Iterations", 
     ylab="Abs log10", bty="n")
lines(1:(length(attributes(Pr_Furman)$Pk)-1), 
      log10(abs(diff(attributes(Pr_Furman)$Pk))), col="red")
legend("bottomleft", legend=c("Log10 Convergence to true value", "Log10 Rate of change"), 
       col=c("black", "red"), 
       lty=1)


# Test of different methods
alpha &lt;- c(2.05, 2)
mu &lt;- c(10, 30)
test &lt;- rSnbinom(n=100000, size=alpha, mu=mu)
plot(0:200, table(test)[as.character(0:200)]/sum(table(test), na.rm=TRUE), 
     bty="n", type="h", xlab="x", ylab="Density")
lines(x=0:200, dSnbinom(0:200, size=alpha, mu=mu, log=FALSE, method="Furman"), col="blue")
lines(x=0:200, y=dSnbinom(0:200, size=alpha, mu=mu, log=FALSE, 
                          method="vellaisamy&amp;upadhye"), col="red")
lines(x=0:200, y=dSnbinom(0:200, size=alpha, mu=mu, log=FALSE, 
                          method="approximate.randomobservations"), col="green")

# Test for criteria of convergence for x = 50
x &lt;- 50
# Test for criteria of convergence
Pr_exact &lt;- dSnbinom(x=x, prob=p, size=alpha, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, prob=p, size=alpha, method="Furman", log=FALSE, tol=1E-12, 
                 verbose=TRUE)
Pr_exact;as.numeric(Pr_Furman)
plot(1:length(attributes(Pr_Furman)$Pk), 
     log10(abs(attributes(Pr_Furman)$Pk-Pr_exact)), type="l", xlab="Iterations", 
     ylab="Abs log10", bty="n")
lines(1:(length(attributes(Pr_Furman)$Pk)-1), 
      log10(abs(diff(attributes(Pr_Furman)$Pk))), col="red")
legend("bottomleft", legend=c("Log10 Convergence to true value", "Log10 Rate of change"), 
       col=c("black", "red"), 
       lty=1)

# Another example more complicated
set.seed(2)
mutest &lt;- c(56, 6.75, 1)
ktest &lt;- c(50, 50, 50)
nr &lt;- 100000
test &lt;- rSnbinom(nr, size=ktest, mu=mutest)
system.time({pr_vellaisamy &lt;- dSnbinom(x=0:150, size=ktest, mu=mutest, 
                          method = "vellaisamy&amp;upadhye", verbose=FALSE, parallel=FALSE)})
# Parallel computing is not efficient
system.time({pr_vellaisamy &lt;- dSnbinom(x=0:150, size=ktest, mu=mutest, 
                          method = "vellaisamy&amp;upadhye", verbose=FALSE, parallel=TRUE)})
system.time({pr_furman &lt;- dSnbinom(x=0:150, size=ktest, mu=mutest, prob=NULL, 
                      method = "furman", verbose=FALSE, log=FALSE)})
pr_approximateObservations &lt;- dSnbinom(0:150, size=ktest, mu=mutest, 
                                       method = "approximate.randomobservations")

plot(table(test), xlab="N", ylab="Density", las=1, bty="n", ylim=c(0, 4000), xlim=c(0, 150))
lines(0:150, pr_vellaisamy*nr, col="red")
lines(0:150, pr_furman*nr, col="blue")
lines(0:150, pr_approximateObservations*nr, col="green")

dSnbinom(x=42, size=ktest, mu=mutest, prob=NULL, 
         method = "vellaisamy&amp;upadhye", verbose=TRUE)
as.numeric(dSnbinom(x=42, size=ktest, mu=mutest, prob=NULL, 
           method = "Furman", verbose=TRUE))
dSnbinom(x=42, size=ktest, mu=mutest, prob=NULL, 
         method = "approximate.randomobservations", verbose=TRUE)

x &lt;- 100
# Test for criteria of convergence
Pr_exact &lt;- dSnbinom(x=x, size=ktest, mu=mutest, method="vellaisamy&amp;upadhye", 
                   log=FALSE, verbose=TRUE)
Pr_Furman &lt;- dSnbinom(x=x, size=ktest, mu=mutest, method="Furman", log=FALSE, 
                 verbose=TRUE)
Pr_exact;as.numeric(Pr_Furman)
plot(1:length(attributes(Pr_Furman)$Pk), 
     log10(abs(attributes(Pr_Furman)$Pk-Pr_exact)), type="l", xlab="Iterations", 
     ylab="Abs log10", bty="n", ylim=c(-100, 0))
lines(1:(length(attributes(Pr_Furman)$Pk)-1), 
      log10(abs(diff(attributes(Pr_Furman)$Pk))), col="red")
legend("bottomright", legend=c("Log10 Convergence to true value", "Log10 Rate of change"), 
       col=c("black", "red"), 
       lty=1)
       
     
# example to fit a distribution
data &lt;- rnbinom(1000, size=1, mu=10)
hist(data)
ag &lt;- rep(1:100, 10)
r &lt;- aggregate(data, by=list(ag), FUN=sum)
hist(r[,2])

parx &lt;- c(size=1, mu=10)

dSnbinomx &lt;- function(x, par) {
  -sum(dSnbinom(x=x[,2], mu=rep(par["mu"], 10), size=par["size"], log=TRUE))
}

fit_mu_size &lt;- optim(par = parx, fn=dSnbinomx, x=r, method="BFGS", control=c(trace=TRUE))
fit_mu_size$par

alpha &lt;- c(2.1, 2.05, 2)
mu &lt;- c(10, 30, 20)
p &lt;- pSnbinom(q=10, size=alpha, mu=mu, lower.tail = TRUE)

alpha &lt;- c(2.1, 2.05, 2)
mu &lt;- c(10, 30, 20)
q &lt;- qSnbinom(p=0.1, size=alpha, mu=mu, lower.tail = TRUE)

alpha &lt;- c(2.1, 2.05, 2)
mu &lt;- c(10, 30, 20)
rep &lt;- 100000
distEmpirique &lt;- rSnbinom(n=rep, size=alpha, mu=mu)
tabledistEmpirique &lt;- rep(0, 301)
names(tabledistEmpirique) &lt;- as.character(0:300)
tabledistEmpirique[names(table(distEmpirique))] &lt;- table(distEmpirique)/rep

plot(0:300, dSnbinom(0:300, size=alpha, mu=mu), type="h", bty="n", 
   xlab="x", ylab="Density", ylim=c(0,0.02))
plot_add(0:300, tabledistEmpirique, type="l", col="red")
legend(x=200, y=0.02, legend=c("Empirical", "Theoretical"), 
   text.col=c("red", "black"), bty="n")
   
   
# Test if saddlepoint approximation must be normalized
# Yes, it must be
n &lt;- 7
alpha &lt;- 1:n
p &lt;- (1:n)/10
dSnbinom(x=10, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=10, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE, normalize=FALSE)
                 
# Test for saddlepoint when x=0
n &lt;- 7
alpha &lt;- 1:n
p &lt;- (1:n)/10
dSnbinom(x=0, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=1, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=c(0, 1), prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=c(0, 1), prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=FALSE)
                 
# Test when prob are all the same
p &lt;- rep(0.2, 7)
n &lt;- 7
alpha &lt;- 1:n
dSnbinom(x=0:10, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=0:10, prob=p, size=alpha, method="furman", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=0:10, prob=p, size=alpha, method="exact", log=FALSE,  
                 verbose=TRUE)
                 
# Test when n=1
p &lt;- 0.2
n &lt;- 1
alpha &lt;- 1:n
dSnbinom(x=0:10, prob=p, size=alpha, method="saddlepoint", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=0:10, prob=p, size=alpha, method="furman", log=FALSE,  
                 verbose=TRUE)
dSnbinom(x=0:10, prob=p, size=alpha, method="exact", log=FALSE,  
                 verbose=TRUE)
                 

## End(Not run)
</code></pre>

<hr>
<h2 id='duplicated_packages'>List the duplicated packages with their locations</h2><span id='topic+duplicated_packages'></span>

<h3>Description</h3>

<p>A data.frame with the duplicated packages and their locations and version.<br />
The columns Lib1 and Version1 should have the oldest version of the packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated_packages()
</code></pre>


<h3>Details</h3>

<p>duplicated_packages lists the duplicated packages with their locations
</p>


<h3>Value</h3>

<p>A data.frame with 4 elements for each duplicated packages:<br />
</p>

<ul>
<li><p> versions: the version of the packages<br />
</p>
</li>
<li><p> libraries: the locations<br />
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
duplicated_packages()
# To remove the oldest versions of the installed packages, use
li &lt;- duplicated_packages()
if (nrow(li) != 0)
    for (i in 1:nrow(li))
        remove.packages(rownames(li)[i], lib=li[i, "Lib1"])

## End(Not run)
</code></pre>

<hr>
<h2 id='ellipse'>Plot an ellipse</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Plot a ellipse defined by the center and the radius. The options for
binomial confidence parameters are:<br />
</p>

<ul>
<li><p> conf.level<br />
</p>
</li>
<li><p> method  must be one of these &quot;wald&quot;, &quot;wilson&quot;, &quot;wilsoncc&quot;, &quot;agresti-coull&quot;, &quot;jeffreys&quot;, &quot;modified wilson&quot;, &quot;modified jeffreys&quot;, &quot;clopper-pearson&quot;, &quot;arcsine&quot;, &quot;logit&quot;, &quot;witting&quot;, &quot;pratt&quot;, &quot;midp&quot;, &quot;lik&quot; and &quot;blaker&quot;. Defaults to &quot;wilson&quot;. Abbreviation of method is accepted. See details.<br />
Default is wilsoncc (Wilson with continuity correction)
col parameter can be a list of colors. See examples
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ellipse(
  center.x = 0,
  center.y = 0,
  radius.x = 1,
  radius.y = 1,
  radius.x.lower = NULL,
  radius.x.upper = NULL,
  radius.y.lower = NULL,
  radius.y.upper = NULL,
  alpha = 0,
  binconf.x = NULL,
  binconf.y = NULL,
  control.binconf = list(conf.level = 0.95, method = "wilsoncc"),
  length = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_center.x">center.x</code></td>
<td>
<p>Center of the ellipse on x axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_center.y">center.y</code></td>
<td>
<p>Center of the ellipse on y axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.x">radius.x</code></td>
<td>
<p>Radius along the x axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.y">radius.y</code></td>
<td>
<p>Radius along the y axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.x.lower">radius.x.lower</code></td>
<td>
<p>Radius along the x axis, at left of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.x.upper">radius.x.upper</code></td>
<td>
<p>Radius along the x axis, at right of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.y.lower">radius.y.lower</code></td>
<td>
<p>Radius along the y axis, at bottom of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_radius.y.upper">radius.y.upper</code></td>
<td>
<p>Radius along the y axis, at top of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_alpha">alpha</code></td>
<td>
<p>Rotation in radians</p>
</td></tr>
<tr><td><code id="ellipse_+3A_binconf.x">binconf.x</code></td>
<td>
<p>A data.frame or a matrix with two columns, x and n or with three columns, PointEst, Lower, and Upper</p>
</td></tr>
<tr><td><code id="ellipse_+3A_binconf.y">binconf.y</code></td>
<td>
<p>A data.frame or a matrix with two columns, x and n or with three columns, PointEst, Lower, and Upper</p>
</td></tr>
<tr><td><code id="ellipse_+3A_control.binconf">control.binconf</code></td>
<td>
<p>A list with options for binomial confidence</p>
</td></tr>
<tr><td><code id="ellipse_+3A_length">length</code></td>
<td>
<p>Number of points to draw the ellipse</p>
</td></tr>
<tr><td><code id="ellipse_+3A_...">...</code></td>
<td>
<p>Graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ellipse plots an ellipse
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")
 
ellipse(center.x = c(0.2, 0.3, 0.25), center.y = c(0.7, 0.6, 0.55), 
        radius.x = c(0.1, 0.1, 0.1), radius.y = c(0.15, 0.2, 0.4), 
        border=NA, col=rgb(red = 0.1, green = 0.1, blue = 0.1, alpha = 0.1))

ellipse(center.x = 0.5, center.y = 0.5, 
        radius.x.lower = 0.1, radius.x.upper = 0.3, 
        radius.y = 0.2, 
        border=NA, col=rgb(red = 0.1, green = 0.1, blue = 0.1, alpha = 0.1))

ellipse(center.x = 0.6, center.y = 0.3, 
        radius.x.lower = 0.3, radius.x.upper = 0.3, 
        radius.y.lower = 0.2, radius.y.upper = 0.4, 
        border=NA, col=rgb(red = 0.1, green = 0.1, blue = 0.1, alpha = 0.1))

plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", bty="n", asp=1, 
     xlab="Variable x", ylab="variable y", axes=FALSE)
axis(1, at=c(0, 0.25, 0.5, 0.75, 1))
axis(2, at=c(0, 0.25, 0.5, 0.75, 1), las=1)

ellipse(center.x = 0.5, center.y = 0.5, radius.x = 0.2, radius.y = 0.4, 
       border=NA, col=rgb(red = 0.1, green = 0.1, blue = 0.1, alpha = 0.1))
ellipse(center.x = 0.5, center.y = 0.5, radius.x = 0.2, radius.y = 0.4, 
        border=NA, col=rgb(red = 0.1, green = 0.1, blue = 0.1, alpha = 0.1), alpha = pi/4)

plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")

for (k in 0:8)
  ellipse(center.x=0.5, center.y=0.5, radius.x=0.1, radius.y=0.4, 
          alpha=seq(from=0, to=pi/4, length=9)[k], 
          border=rainbow(9)[k])

# Exemple with confidence of proportions
males &lt;- c(10, 25, 3, 4)
N &lt;- c(12, 52, 17, 10)

males2 &lt;- c(12, 20, 3, 6)
N2 &lt;- c(15, 50, 20, 12)

plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")

ellipse(binconf.x = data.frame(x=males, n=N), binconf.y = data.frame(x=males2, n=N2),  
        border=NA, col=rgb(red = 0.1, green = 0.5, blue = 0.1, alpha = 0.1))
        
plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")
     
ellipse(binconf.x = data.frame(x=males, n=N), 
        binconf.y = data.frame(PointEst=c(0.1, 0.2, 0.3, 0.5), 
                               Lower=c(0.02, 0.12, 0.25, 0.30), 
                               Upper=c(0.18, 0.29, 0.35, 0.67)), 
        border=NA, col=rgb(red = 0.1, green = 0.5, blue = 0.1, alpha = 0.1))
        
# Examples with a gradient
plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")
ellipse(center.x = 0.6, center.y = 0.3, 
        radius.x.lower = 0.3, radius.x.upper = 0.3, 
        radius.y.lower = 0.2, radius.y.upper = 0.4, 
        border=NA, col=grey.colors(100, alpha = 0.1))
        
plot(0:1, 0:1, xlim=c(0, 1), ylim=c(0,1), lty=2, type="l", las=1, bty="n", 
     xlab="Variable x", ylab="variable y")
ellipse(binconf.x = data.frame(x=males, n=N), binconf.y = data.frame(x=males2, n=N2),  
        border=NA, col=grey.colors(100, alpha = 0.1))

</code></pre>

<hr>
<h2 id='ExtractAIC.glm'>Return AIC, AICc or BIC from a glm object</h2><span id='topic+ExtractAIC.glm'></span>

<h3>Description</h3>

<p>For glm fits the family's aic() function is used to compute the AIC.<br />
The choice between different criteria is done by setting a global option AIC. It can be checked using show.option=TRUE.
Indeed, it is not possible to use the ... parameter due to a bug in some functions of MASS package. If you want to use this function as a replacement for setpAIC(), do extractAIC.glm &lt;- ExtractAIC.glm before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractAIC.glm(fit, scale = 0, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractAIC.glm_+3A_fit">fit</code></td>
<td>
<p>fitted model, the result of a fitter glm.</p>
</td></tr>
<tr><td><code id="ExtractAIC.glm_+3A_scale">scale</code></td>
<td>
<p>unused for glm.</p>
</td></tr>
<tr><td><code id="ExtractAIC.glm_+3A_k">k</code></td>
<td>
<p>numeric specifying the ‘weight’ of the equivalent degrees of freedom (=: edf) part in the AIC formula.</p>
</td></tr>
<tr><td><code id="ExtractAIC.glm_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused because addterm.glm and dropterm.glm using this function do not transmit them).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ExtractAIC.glm returns AIC, AICc or BIC from a glm object
</p>


<h3>Value</h3>

<p>A numeric named vector of length 2, with first and second elements giving<br />
edf	the ‘equivalent degrees of freedom’ for the fitted model fit.<br />
x	the Information Criterion for fit.
</p>


<h3>Author(s)</h3>

<p>Modified from stats:::extract.AIC.glm
</p>


<h3>See Also</h3>

<p>Other AIC: 
<code><a href="#topic+FormatCompareAIC">FormatCompareAIC</a>()</code>,
<code><a href="#topic+compare_AIC">compare_AIC</a>()</code>,
<code><a href="#topic+compare_AICc">compare_AICc</a>()</code>,
<code><a href="#topic+compare_BIC">compare_BIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extractAIC.glm &lt;- ExtractAIC.glm
n &lt;- 100
x &lt;- rnorm(n, 20, 2)
A &lt;- rnorm(n, 20, 5)
g &lt;- glm(x ~ A)
extractAIC(g, show.option=TRUE)
options(AIC="AIC")
extractAIC(g)
options(AIC="BIC")
extractAIC(g)
options(AIC="AICc")
extractAIC(g)
</code></pre>

<hr>
<h2 id='fitdistrquantiles'>Parameters of beta, normal or gamma distribution based on quantiles.</h2><span id='topic+fitdistrquantiles'></span>

<h3>Description</h3>

<p>Return the parameters of beta or gamm that fits the best the
quantiles. The vector of probabilities can be obtained from names of
quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitdistrquantiles(
  quantiles = stop("At least two quantiles must be provided"),
  probs = NULL,
  scaled = FALSE,
  distribution = "beta"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitdistrquantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="fitdistrquantiles_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1].</p>
</td></tr>
<tr><td><code id="fitdistrquantiles_+3A_scaled">scaled</code></td>
<td>
<p>Used scaled least-square.</p>
</td></tr>
<tr><td><code id="fitdistrquantiles_+3A_distribution">distribution</code></td>
<td>
<p>Distribution to be fitted: beta, normal, or gamma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fitdistrquantiles returns the parameters of beta, normal or gamma distribution
</p>


<h3>Value</h3>

<p>Parameters of beta, normal or gamma distribution based on quantiles.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rd &lt;- rbeta(100000, shape1 = 0.7, shape2 = 6.2, ncp=0)
(q &lt;- quantile(rd, probs=c(0.025, 0.5, 0.975)))

(best &lt;- fitdistrquantiles(quantiles = q, probs = c(0.025, 0.5, 0.975), 
                           scaled=FALSE, distribution = "beta"))
rd10000 &lt;- rbeta(10000, shape1 = best["shape1"], shape2 = best["shape2"], ncp=best["ncp"])
quantile(rd10000, probs=c(0.025, 0.5, 0.975))

# Here the probabilities are obtained from names of quantiles
(best &lt;- fitdistrquantiles(quantiles = q, scaled=FALSE, distribution = "beta"))
rd10000 &lt;- rbeta(10000, shape1 = best["shape1"], shape2 = best["shape2"], ncp=best["ncp"])
quantile(rd10000, probs=c(0.025, 0.5, 0.975))

# If only two quantiles are provided, ncp cannot be fitted
(q2 &lt;- quantile(rd, probs=c(0.025, 0.975)))
(best &lt;- fitdistrquantiles(quantiles = q2, scaled=FALSE, distribution = "beta"))
rd10000 &lt;- rbeta(10000, shape1 = best["shape1"], shape2 = best["shape2"])
quantile(rd10000, probs=c(0.025, 0.975))
x &lt;- seq(from=0.00, to=1, by=0.001)
plot(x=x, y=pbeta(x, shape1 = best["shape1"], shape2 = best["shape2"]), 
     las=1, bty="n", type="l", ylim=c(0, 1))
segments(x0=q2[1], x1=q2[1], y0=0, y1=1, lty=2)
segments(x0=q2[2], x1=q2[2], y0=0, y1=1, lty=2)

(best &lt;- fitdistrquantiles(quantiles = q, probs = c(0.025, 0.5, 0.975), 
                           scaled=FALSE, distribution = "gamma"))
rd10000 &lt;- rgamma(10000, shape = best["shape"], scale = best["scale"])
quantile(rd10000, probs=c(0.025, 0.5, 0.975))

(best &lt;- fitdistrquantiles(quantiles = c(10, 20, 30), probs = c(0.025, 0.5, 0.975), 
                           scaled=FALSE, distribution = "normal"))
rd10000 &lt;- rnorm(10000, mean = best["mean"], sd = best["sd"])
quantile(rd10000, probs=c(0.025, 0.5, 0.975))
</code></pre>

<hr>
<h2 id='flexit'>Return the flexit</h2><span id='topic+flexit'></span>

<h3>Description</h3>

<p>Return a vector with the probabilities.
The flexit equation is published in:<br />
Abreu-Grobois, F.A., Morales-Mérida, B.A., Hart, C.E., Guillon, J.-M., Godfrey, M.H.,
Navarro, E. &amp; Girondot, M. (2020) Recent advances on the estimation of the thermal
reaction norm for sex ratios. PeerJ, 8, e8451.<br />
If dose &lt; P then <code class="reqn">(1 + (2^K1 - 1) *  exp(4 * S1 * (P - x)))^(-1/K1)</code><br />
If dose &gt; P then <code class="reqn">1-((1 + (2^K2 - 1) * exp(4 * S2 * (x - P)))^(-1/K2)</code><br />
with:<br />
</p>
<p style="text-align: center;"><code class="reqn">S1 = (2^(K1 - 1) * S * K1)/(2^K1 - 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">S2 = (2^(K2 - 1) * S * K2)/(2^K2 - 1)</code>
</p>

<p><br />
New in version 4.7-3 and larger:<br />
<br />
If <code class="reqn">2^K1</code> is too large to be estimated, the approximation <code class="reqn">S1 = S*K1/2</code> is used.<br />
Demonstration:<br />
</p>
<p style="text-align: center;"><code class="reqn">S1 = (2^(K1 - 1) * S * K1)/(2^K1 - 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">S1 = exp(log((2^(K1 - 1) * S * K1)/(2^K1 - 1)))</code>
</p>

<p style="text-align: center;"><code class="reqn">S1 = exp(log(2^(K1 - 1)) + log(S * K1) - log(2^K1 - 1))</code>
</p>

<p>When <code class="reqn">K1</code> is very large, <code class="reqn">2^K1 - 1 = 2^K1</code> then
</p>
<p style="text-align: center;"><code class="reqn">S1 = exp((K1 - 1) * log(2) + log(S * K1) - K1 * log(2))</code>
</p>

<p style="text-align: center;"><code class="reqn">S1 = exp((K1 * log(2) - log(2) + log(S * K1) - K1 * log(2))</code>
</p>

<p style="text-align: center;"><code class="reqn">S1 = exp(log(S * K1)- log(2))</code>
</p>

<p style="text-align: center;"><code class="reqn">S1 = S * K1 / 2</code>
</p>

<p>If <code class="reqn">2^K2</code> is too large to be estimated, the approximation <code class="reqn">S2 = S*K2/2</code> is used.<br />
</p>
<p>If <code class="reqn">(1 + (2^K1 - 1) *  exp(4 * S1 * (P - x)))^(-1/K1)</code> is not finite,
the following approximation is used:<br />
</p>
<p style="text-align: center;"><code class="reqn">exp((-1/K1)*(K1*log(2)+(4*S1*(P-x))))</code>
</p>

<p>If <code class="reqn">1-((1 + (2^K2 - 1) * exp(4 * S2 * (x - P)))^(-1/K2)</code> is not finite,
the following approximation is used:<br />
</p>
<p style="text-align: center;"><code class="reqn">1 - exp((-1/K2)*(K2*log(2)+(4*S2*(x - P))))</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>flexit(
  x,
  par = NULL,
  P = NULL,
  S = NULL,
  K1 = NULL,
  K2 = NULL,
  zero = 1e-09,
  error0 = 0,
  error1 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexit_+3A_x">x</code></td>
<td>
<p>The values at which the flexit model must be calculated</p>
</td></tr>
<tr><td><code id="flexit_+3A_par">par</code></td>
<td>
<p>The vector with P, S, K1, and K2 values</p>
</td></tr>
<tr><td><code id="flexit_+3A_p">P</code></td>
<td>
<p>P value</p>
</td></tr>
<tr><td><code id="flexit_+3A_s">S</code></td>
<td>
<p>S value</p>
</td></tr>
<tr><td><code id="flexit_+3A_k1">K1</code></td>
<td>
<p>K1 value</p>
</td></tr>
<tr><td><code id="flexit_+3A_k2">K2</code></td>
<td>
<p>K2 value</p>
</td></tr>
<tr><td><code id="flexit_+3A_zero">zero</code></td>
<td>
<p>Value to replace zero</p>
</td></tr>
<tr><td><code id="flexit_+3A_error0">error0</code></td>
<td>
<p>Value to return if an error is observed toward 0</p>
</td></tr>
<tr><td><code id="flexit_+3A_error1">error1</code></td>
<td>
<p>Value to return if an error is observed toward 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return the flexit value
</p>


<h3>Value</h3>

<p>A vector with the probabilities
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other logit: 
<code><a href="#topic+invlogit">invlogit</a>()</code>,
<code><a href="#topic+logit">logit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- flexit(x=1:100, par=c(P=50, S=0.001, K1=0.01, K2=0.02))
n &lt;- flexit(x=1:100, P=50, S=0.001, K1=0.01, K2=0.02)

1/(1+exp(0.01*4*(50-1:100)))
flexit(1:100, P=50, S=0.01, K1=1, K2=1)
</code></pre>

<hr>
<h2 id='format_ncdf'>Return an array with ncdf data</h2><span id='topic+format_ncdf'></span>

<h3>Description</h3>

<p>Return a list with two elements: data is an array and time is the POSIX.lt time.<br />
Or if label.time is NULL or if bathy is TRUE, a bathy object.<br />
If varid is NULL, it shows the available variable and dimensions of the file.<br />
Bathymetry data can be download here: <br />
https://www.gebco.net/data_and_products/gridded_bathymetry_data/#global
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ncdf(
  ncdf,
  label.latitude = "latitude",
  label.longitude = "longitude",
  label.time = "time",
  varid = NULL,
  longitude1 = NA,
  latitude1 = NA,
  longitude2 = NA,
  latitude2 = NA,
  package = "ncdf4",
  bathy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ncdf_+3A_ncdf">ncdf</code></td>
<td>
<p>An object read from package ncdf4 or a file name of ncdf file</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_label.latitude">label.latitude</code></td>
<td>
<p>Label of latitude</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_label.longitude">label.longitude</code></td>
<td>
<p>Label of longitude</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_label.time">label.time</code></td>
<td>
<p>Label of time</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_varid">varid</code></td>
<td>
<p>Name of variable to extract</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_longitude1">longitude1</code></td>
<td>
<p>Longitude for first corner</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_latitude1">latitude1</code></td>
<td>
<p>latitude for first corner</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_longitude2">longitude2</code></td>
<td>
<p>Longitude for second corner</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_latitude2">latitude2</code></td>
<td>
<p>latitude for second corner</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_package">package</code></td>
<td>
<p>If ncdf is a file, give the package to use to open the file</p>
</td></tr>
<tr><td><code id="format_ncdf_+3A_bathy">bathy</code></td>
<td>
<p>If TRUE, return a bathy object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>format_ncdf is used extract information from ncdf file
</p>


<h3>Value</h3>

<p>A list with two element: data is an array and time is the POSIX.lt time
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other ncdf: 
<code><a href="#topic+ind_long_lat">ind_long_lat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
url &lt;- "https://downloads.psl.noaa.gov/Datasets/noaa.oisst.v2.highres/"
url &lt;- paste0(url, "sst.day.mean.2012.v2.nc")
dest &lt;- paste(Sys.getenv("HOME"), "/sst.day.mean.2012.v2.nc", sep="")
download.file(url, dest)
format_ncdf(dest)

## End(Not run)
</code></pre>

<hr>
<h2 id='FormatCompareAIC'>Format data to be used with compare_AIC()</h2><span id='topic+FormatCompareAIC'></span>

<h3>Description</h3>

<p>Format data to be used with compare_AIC(), compare_AICc() and compare_BIC().<br />
Note that logLik is supposed to not be -logLik.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatCompareAIC(logLik, nobs, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormatCompareAIC_+3A_loglik">logLik</code></td>
<td>
<p>The log likelihood</p>
</td></tr>
<tr><td><code id="FormatCompareAIC_+3A_nobs">nobs</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="FormatCompareAIC_+3A_df">df</code></td>
<td>
<p>Number of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FormatCompareAIC formats data to be used with compare_AIC()
</p>


<h3>Value</h3>

<p>An object to be used with compare_AIC()
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other AIC: 
<code><a href="#topic+ExtractAIC.glm">ExtractAIC.glm</a>()</code>,
<code><a href="#topic+compare_AIC">compare_AIC</a>()</code>,
<code><a href="#topic+compare_AICc">compare_AICc</a>()</code>,
<code><a href="#topic+compare_BIC">compare_BIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ED &lt;- FormatCompareAIC(logLik=-140, nobs=100, df=3)
L &lt;- FormatCompareAIC(logLik=-145, nobs=100, df=4)
compare_AIC(L=L, ED=ED)
compare_AICc(L=L, ED=ED)
compare_BIC(L=L, ED=ED)

## End(Not run)
</code></pre>

<hr>
<h2 id='IC_clean_data'>Clean the dataframe before to be used with IC_threshold_matrix</h2><span id='topic+IC_clean_data'></span>

<h3>Description</h3>

<p>This function must be used if missing values are present in the dataset.<br />
It ensures that all correlations and partial correlations can be calculated.
The columns of the dataframe are removed one per one until all can be calculated without error.
It is possible to say that one or more columns must be retained because they are of particular importance in the analysis.
The use and method parameters are used by cor() function. The function uses by default a parallel computing in Unix or MacOSX systems.
If progress is TRUE and the package pbmcapply is present, a progress bar is displayed. If debug is TRUE, some informations are shown during the process.
<code>https://fr.wikipedia.org/wiki/Iconographie_des_corrélations</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC_clean_data(
  data = stop("A dataframe object is required"),
  use = c("pairwise.complete.obs", "everything", "all.obs", "complete.obs",
    "na.or.complete"),
  method = c("pearson", "kendall", "spearman"),
  variable.retain = NULL,
  test.partial.correlation = TRUE,
  progress = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_clean_data_+3A_data">data</code></td>
<td>
<p>The data.frame to be cleaned</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing covariances in the presence of missing values. This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient (or covariance) is to be computed. One of &quot;pearson&quot; (default), &quot;kendall&quot;, or &quot;spearman&quot;: can be abbreviated.</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_variable.retain">variable.retain</code></td>
<td>
<p>a vector with the name of columns to keep</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_test.partial.correlation">test.partial.correlation</code></td>
<td>
<p>should the partial correlations be tested ?</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_progress">progress</code></td>
<td>
<p>Show a progress bar</p>
</td></tr>
<tr><td><code id="IC_clean_data_+3A_debug">debug</code></td>
<td>
<p>if TRUE, information about progression of cleaning are shown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IC_clean_data checks and corrects the dataframe to be used with IC_threshold_matrix
</p>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Lesty, M., 1999. Une nouvelle approche dans le choix des régresseurs de la régression multiple en présence d’interactions et de colinéarités. Revue de Modulad 22, 41-77.
</p>


<h3>See Also</h3>

<p>Other Iconography of correlations: 
<code><a href="#topic+IC_correlation_simplify">IC_correlation_simplify</a>()</code>,
<code><a href="#topic+IC_threshold_matrix">IC_threshold_matrix</a>()</code>,
<code><a href="#topic+plot.IconoCorel">plot.IconoCorel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# based on https://fr.wikipedia.org/wiki/Iconographie_des_corrélations
es &lt;- structure(list(Student = c("e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8"), 
                     Mass = c(52, 59, 55, 58, 66, 62, 63, 69), 
                     Age = c(12, 12.5, 13, 14.5, 15.5, 16, 17, 18), 
                     Assiduity = c(12, 9, 15, 5, 11, 15, 12, 9), 
                     Note = c(5, 5, 9, 5, 13.5, 18, 18, 18)), 
                     row.names = c(NA, -8L), class = "data.frame")
es

df_clean &lt;- IC_clean_data(es, debug = TRUE)
cor_matrix &lt;- IC_threshold_matrix(data=df_clean, threshold = NULL, progress=FALSE)
cor_threshold &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.3)
plot(cor_threshold, show.legend.strength=FALSE, show.legend.direction = FALSE)
cor_threshold_Note &lt;- IC_correlation_simplify(matrix=cor_threshold, variable="Note")
plot(cor_threshold_Note, show.legend.strength=FALSE, show.legend.direction = FALSE)

cor_threshold &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.6)
plot(cor_threshold, 
layout=matrix(data=c(53, 53, 55, 55, 
                     55, 53, 55, 53), ncol=2, byrow=FALSE), 
show.legend.direction = FALSE,
show.legend.strength = FALSE, xlim=c(-2, 2), ylim=c(-2, 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='IC_correlation_simplify'>Simplify the correlation matrix</h2><span id='topic+IC_correlation_simplify'></span>

<h3>Description</h3>

<p>This function can be used to simplify the network of correlations.<br />
If no vector of variables is given, the variables not linked to any other variable are removed.
If a vector of variables is given, only link to these variables are retained.
<code>https://fr.wikipedia.org/wiki/Iconographie_des_corrélations</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC_correlation_simplify(matrix, variable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_correlation_simplify_+3A_matrix">matrix</code></td>
<td>
<p>The correlation matrix to simplify</p>
</td></tr>
<tr><td><code id="IC_correlation_simplify_+3A_variable">variable</code></td>
<td>
<p>a vector with the name of columns to keep</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IC_correlation_simplify simplifies the correlation matrix
</p>


<h3>Value</h3>

<p>A list
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Lesty, M., 1999. Une nouvelle approche dans le choix des régresseurs de la régression multiple en présence d’interactions et de colinéarités. Revue de Modulad 22, 41-77.
</p>


<h3>See Also</h3>

<p>Other Iconography of correlations: 
<code><a href="#topic+IC_clean_data">IC_clean_data</a>()</code>,
<code><a href="#topic+IC_threshold_matrix">IC_threshold_matrix</a>()</code>,
<code><a href="#topic+plot.IconoCorel">plot.IconoCorel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
es &lt;- structure(list(Student = c("e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8"), 
                 Mass = c(52, 59, 55, 58, 66, 62, 63, 69), 
                 Age = c(12, 12.5, 13, 14.5, 15.5, 16, 17, 18), 
                 Assiduity = c(12, 9, 15, 5, 11, 15, 12, 9), 
                 Note = c(5, 5, 9, 5, 13.5, 18, 18, 18)), 
                 row.names = c(NA, -8L), class = "data.frame")

es

df &lt;- IC_clean_data(es, debug = TRUE)
cor_matrix &lt;- IC_threshold_matrix(data=df, threshold = NULL, progress=FALSE)
cor_threshold &lt;- IC_threshold_matrix(data=df, threshold = 0.3)
par(mar=c(1,1,1,1))
set.seed(4)
plot(cor_threshold)
cor_threshold_Note &lt;- IC_correlation_simplify(matrix=cor_threshold, variable="Note")
plot(cor_threshold_Note)

## End(Not run)
</code></pre>

<hr>
<h2 id='IC_threshold_matrix'>Calculate correlation matrix</h2><span id='topic+IC_threshold_matrix'></span>

<h3>Description</h3>

<p>This function calculates the matrix of correlations thresholded using partial correlation.<br />
If the threshold is not given, the object that is produced can be used later for thresholding.<br />
For model OAT: The link between A and B is “remarkable” if and only if the total correlation between them is higher than a given threshold and if the partial correlation between A and B in respect to any other variable C is also higher in absolute values than this threshold and with the same sign as the total correlation.
For model AAT: A correlation is retained if it is higher than the threshold and the partial correlation is lower than the threshold. In this case, no missing value is accepted.<br />
The use and method parameters are used by cor() function. The function uses by default a parallel computing in Unix or MacOSX systems.
If progress is TRUE and the package pbmcapply is present, a progress bar is displayed. If debug is TRUE, some informations are shown during the process but parallel computing is not used.<br />
<code>https://fr.wikipedia.org/wiki/Iconographie_des_corrélations</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC_threshold_matrix(
  data = stop("A dataframe or an IconoCorel object is required"),
  threshold = NULL,
  use = c("pairwise.complete.obs", "everything", "all.obs", "complete.obs",
    "na.or.complete"),
  method = c("pearson", "kendall", "spearman"),
  model = c("OAT", "ATT"),
  significance.level = FALSE,
  correction.multiple.comparisons = "fdr",
  progress = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_threshold_matrix_+3A_data">data</code></td>
<td>
<p>A dataframe or an IconoCorel object from a previous run of IC_threshold_matrix</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_threshold">threshold</code></td>
<td>
<p>threshold for partial and full correlations</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing covariances in the presence of missing values. This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient (or covariance) is to be computed. One of &quot;pearson&quot; (default), &quot;kendall&quot;, or &quot;spearman&quot;: can be abbreviated.</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_model">model</code></td>
<td>
<p>a character string indicating if linear model uses all variables at a time (AAT) or one at a time (OAT).</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_significance.level">significance.level</code></td>
<td>
<p>if FALSE, does not use significance level; or use this significance level.</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_correction.multiple.comparisons">correction.multiple.comparisons</code></td>
<td>
<p>&quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_progress">progress</code></td>
<td>
<p>show a progress bar</p>
</td></tr>
<tr><td><code id="IC_threshold_matrix_+3A_debug">debug</code></td>
<td>
<p>display information about progression of computing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IC_threshold_matrix calculates correlation matrix thresholed by partial correlation
</p>


<h3>Value</h3>

<p>A list
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Lesty, M., 1999. Une nouvelle approche dans le choix des régresseurs de la régression multiple en présence d’interactions et de colinéarités. Revue de Modulad 22, 41-77.
</p>


<h3>See Also</h3>

<p>Other Iconography of correlations: 
<code><a href="#topic+IC_clean_data">IC_clean_data</a>()</code>,
<code><a href="#topic+IC_correlation_simplify">IC_correlation_simplify</a>()</code>,
<code><a href="#topic+plot.IconoCorel">plot.IconoCorel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
es &lt;- structure(list(Student = c("e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8"), 
                 Mass = c(52, 59, 55, 58, 66, 62, 63, 69), 
                 Age = c(12, 12.5, 13, 14.5, 15.5, 16, 17, 18), 
                 Assiduity = c(12, 9, 15, 5, 11, 15, 12, 9), 
                 Note = c(5, 5, 9, 5, 13.5, 18, 18, 18)), 
                 row.names = c(NA, -8L), class = "data.frame")

es

df_clean &lt;- IC_clean_data(es, debug = TRUE)
cor_matrix &lt;- IC_threshold_matrix(data=df_clean, threshold = NULL, progress=FALSE)
cor_threshold &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.3)
plot(cor_threshold, show.legend.strength=FALSE, show.legend.direction = FALSE)
cor_threshold_Note &lt;- IC_correlation_simplify(matrix=cor_threshold, variable="Note")
plot(cor_threshold_Note)

cor_threshold &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.8, progress=FALSE)
gr &lt;- plot(cor_threshold, plot=FALSE)
ly &lt;- getFromNamespace("layout_nicely", ns="igraph")(gr)
plot(cor_threshold, 
layout=matrix(data=c(53, 53, 55, 55, 
                     55, 53, 55, 53), ncol=2, byrow=FALSE), 
show.legend.direction = FALSE,
show.legend.strength = FALSE, xlim=c(-2, 2), ylim=c(-2, 2))

# Using significance level

cor_threshold &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.3, 
                                     significance.level=0.05)
plot(cor_threshold, show.legend.strength=FALSE, show.legend.direction = FALSE)
cor_threshold_Note &lt;- IC_correlation_simplify(matrix=cor_threshold, variable="Note")
plot(cor_threshold_Note)

# Using the model All at a time

cor_threshold_AAT &lt;- IC_threshold_matrix(data=df_clean, threshold = 0.3, model="AAT")
par(mar=c(1,1,1,1))
set.seed(4)
plot(cor_threshold_AAT, show.legend.strength="bottomleft")



############
dta &lt;- structure(list(Student = c("e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8"), 
                     Mass = c(52, 59, 55, 58, 66, 62, 63, 69), 
                     Age = c(12, 12.5, 13, 14.5, 15.5, 16, 17, 18), 
                     Assiduity = c(12, 9, 15, 5, 11, 15, 12, 9), 
                     Note = c(5, 5, 9, 5, 13.5, 18, 18, 18)), 
                     row.names = c(NA, -8L), class = "data.frame")

dta0 &lt;- dta[, 2:ncol(dta)]
ic0 &lt;- IC_threshold_matrix(data = dta0)
cor_threshold &lt;- IC_threshold_matrix(data=ic0, threshold = 0.3)
par(mar=c(1,1,1,1))
set.seed(4)
library("igraph")

plot(cor_threshold, vertex.color="red", show.legend.strength = FALSE)
plot(IC_correlation_simplify(matrix=cor_threshold), 
     show.legend.strength = FALSE, show.legend.direction = FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='iCutter'>Run a shiny application to fit bone section</h2><span id='topic+iCutter'></span>

<h3>Description</h3>

<p>Run a shiny application to fit bone section
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iCutter()
</code></pre>


<h3>Details</h3>

<p>BP runs a shiny application to fit bone section
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not run:
library(HelpersMG)
iCutter()

## End(Not run)
</code></pre>

<hr>
<h2 id='ind_long_lat'>Return or the index in ncdf object from lat/longitude or inverse</h2><span id='topic+ind_long_lat'></span>

<h3>Description</h3>

<p>Return or the index in ncdf object from lat/longitude or reverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_long_lat(
  ncdf = stop("The ncdf data must be supplied"),
  long = NULL,
  lat = NULL,
  indice.long = NULL,
  indice.lat = NULL,
  label.longitude = "lon",
  label.latitude = "lat"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_long_lat_+3A_ncdf">ncdf</code></td>
<td>
<p>An object read from package ncdf4, ncdf or RNetCDF</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_long">long</code></td>
<td>
<p>Longitude in decimal format</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_lat">lat</code></td>
<td>
<p>Latitude in decimal format</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_indice.long">indice.long</code></td>
<td>
<p>Index of longitude</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_indice.lat">indice.lat</code></td>
<td>
<p>Index of latitude</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_label.longitude">label.longitude</code></td>
<td>
<p>Name of argument for longitude, default is lon</p>
</td></tr>
<tr><td><code id="ind_long_lat_+3A_label.latitude">label.latitude</code></td>
<td>
<p>Name of argument for latitude, default is lat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ind_long_lat is used to manage ncdf information
</p>


<h3>Value</h3>

<p>Or the index in ncdf object from lat/longitude or inverse
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other ncdf: 
<code><a href="#topic+format_ncdf">format_ncdf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
url &lt;- "https://downloads.psl.noaa.gov/Datasets/noaa.oisst.v2.highres/"
url &lt;- paste0(url, "sst.day.mean.2012.v2.nc")
dest &lt;- paste(Sys.getenv("HOME"), "/sst.day.mean.2012.v2.nc", sep="")
download.file(url, dest)
library("ncdf4")
dta2012 &lt;- nc_open(dest)
indices &lt;- ind_long_lat(ncdf=dta2012, lat=5.89, long=-20.56)
coordinates &lt;- ind_long_lat(ncdf=dta2012, indice.lat=20, indice.long=30)
# library("RNetCDF")
# dta2012 &lt;- open.nc(dest)
# indices &lt;- ind_long_lat(ncdf=dta2012, lat=5.89, long=-20.56)
# coordinates &lt;- ind_long_lat(ncdf=dta2012, indice.lat=20, indice.long=30)
# ncdf library is depreciated in CRAN
# library("ncdf")
# dta2012 &lt;- open.ncdf(dest)
# indices &lt;- ind_long_lat(ncdf=dta2012, lat=5.89, long=-20.56)
# coordinates &lt;- ind_long_lat(ncdf=dta2012, indice.lat=20, indice.long=30)

## End(Not run)
</code></pre>

<hr>
<h2 id='index.periodic'>Estimate indices in periodic timeseries based on anchored minimum and maximum</h2><span id='topic+index.periodic'></span>

<h3>Description</h3>

<p>Estimate indices in periodic timeseries based on anchored minimum and maximum.<br />
The data.frame minmax can be generated manually. It should have three columns (time, index, SD),
with all the successive minimum and maximum indices.<br />
It can be used with sun.info() to get the time of minimum and maximum air temperature or
with getTide() to reconstruct the sea level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.periodic(minmax, time = NULL, replicates = 100, progressbar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.periodic_+3A_minmax">minmax</code></td>
<td>
<p>A data.frame returned by minmax.periodic</p>
</td></tr>
<tr><td><code id="index.periodic_+3A_time">time</code></td>
<td>
<p>The time at which produced the estimate</p>
</td></tr>
<tr><td><code id="index.periodic_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicates to estimate SD</p>
</td></tr>
<tr><td><code id="index.periodic_+3A_progressbar">progressbar</code></td>
<td>
<p>Does a progression bar must be shown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>index.periodic estimate indices in periodic timeseries based on anchored minimum and maximum
</p>


<h3>Value</h3>

<p>A data.frame with a column time and a column index
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Periodic patterns of indices: 
<code><a href="#topic+minmax.periodic">minmax.periodic</a>()</code>,
<code><a href="#topic+moon.info">moon.info</a>()</code>,
<code><a href="#topic+sun.info">sun.info</a>()</code>,
<code><a href="#topic+tide.info">tide.info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a timeserie of time
time.obs &lt;- NULL
for (i in 0:9) time.obs &lt;- c(time.obs, c(0, 6, 12, 18)+i*24)
# For these time, generate a timeseries of temperatures
temp.obs &lt;- rep(NA, length(time.obs))
temp.obs[3+(0:9)*4] &lt;- rnorm(10, 25, 3)
temp.obs[1+(0:9)*4] &lt;- rnorm(10, 10, 3)
for (i in 1:(length(time.obs)-1)) 
  if (is.na(temp.obs[i])) 
  temp.obs[i] &lt;- mean(c(temp.obs[i-1], temp.obs[i+1]))
  if (is.na(temp.obs[length(time.obs)])) 
  temp.obs[length(time.obs)] &lt;- temp.obs[length(time.obs)-1]/2
observed &lt;- data.frame(time=time.obs, temperature=temp.obs)
# Search for the minimum and maximum values
r &lt;- minmax.periodic(time.minmax.daily=c(Min=2, Max=15), 
observed=observed, period=24, colname.index="temperature")

# Estimate all the temperatures for these values
t &lt;- index.periodic(minmax=r)

plot_errbar(x=t[,"time"], y=t[,"index"],
errbar.y=ifelse(is.na(t[,"sd"]), 0, 2*t[,"sd"]),
type="l", las=1, bty="n", errbar.y.polygon = TRUE, 
xlab="hours", ylab="Temperatures", ylim=c(0, 35), 
errbar.y.polygon.list = list(col="grey"))

plot_add(x=t[,"time"], y=t[,"index"], type="l")

plot_add(observed$time, observed$temperature, pch=19, cex=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='inside'>Search a string within files of a folder</h2><span id='topic+inside'></span>

<h3>Description</h3>

<p>Search for a string inside the files of a folder and return where the string is found.<br />
The pattern for files that must be included uses regex for filtering.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside(
  text = stop("A text to be searched for is necessary"),
  path = ".",
  pattern = "*\\.R$",
  showallfilenames = FALSE,
  ...,
  fixed = TRUE,
  ignore.case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside_+3A_text">text</code></td>
<td>
<p>Text to search in files</p>
</td></tr>
<tr><td><code id="inside_+3A_path">path</code></td>
<td>
<p>Path of the folder to search in</p>
</td></tr>
<tr><td><code id="inside_+3A_pattern">pattern</code></td>
<td>
<p>Pattern for file names to search in</p>
</td></tr>
<tr><td><code id="inside_+3A_showallfilenames">showallfilenames</code></td>
<td>
<p>logical. Show all the filenames search for in</p>
</td></tr>
<tr><td><code id="inside_+3A_...">...</code></td>
<td>
<p>Options for readLines(), example warn = FALSE</p>
</td></tr>
<tr><td><code id="inside_+3A_fixed">fixed</code></td>
<td>
<p>logical. If TRUE, pattern is a string to be matched as is. Overrides all conflicting arguments (see gsub)</p>
</td></tr>
<tr><td><code id="inside_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical. if FALSE, the pattern matching for text is case sensitive and if TRUE, case is ignored during matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>inside Search a string within files of a folder
</p>


<h3>Value</h3>

<p>Return an invisible vector with filenames in which the pattern occurs
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# Search for files in path with names based on pattern that have the string search inside.
inside("embryogrowth", path=".", pattern="*\\.R$")

## End(Not run)
</code></pre>

<hr>
<h2 id='invlogit'>Return the inverse logit</h2><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Return the inverse logit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlogit(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invlogit_+3A_n">n</code></td>
<td>
<p>The value to inverse to get the probability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>invlogit returns the inverse logit
</p>


<h3>Value</h3>

<p>A value
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other logit: 
<code><a href="#topic+flexit">flexit</a>()</code>,
<code><a href="#topic+logit">logit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- logit(0.5)
invlogit(n)
</code></pre>

<hr>
<h2 id='LD50'>Estimate the parameters that best describe LD50</h2><span id='topic+LD50'></span>

<h3>Description</h3>

<p>Estimate the parameters that best describe LD50<br />
Logistic and logit models are the same but with different parametrization:<br />
logistic = 1/(1+exp((1/S)<em>(P-d)))<br />
logit = 1/(1+exp(P+d</em>S))<br />
See these publications for the description of equations:<br />
Girondot, M. 1999. Statistical description of temperature-dependent sex determination using maximum likelihood. Evolutionary Ecology Research, 1, 479-486.<br />
Godfrey, M.H., Delmas, V., Girondot, M., 2003. Assessment of patterns of temperature-dependent sex determination using maximum likelihood model selection. Ecoscience 10, 265-272.<br />
Hulin, V., Delmas, V., Girondot, M., Godfrey, M.H., Guillon, J.-M., 2009. Temperature-dependent sex determination and global change: are some species at greater risk? Oecologia 160, 493-506.<br />
The flexit equation is not still published :
</p>
<p style="text-align: center;"><code class="reqn">if dose &lt; P then (1 + (2^K1 - 1) *  exp(4 * S1 * (P - x)))^(-1/K1)</code>
</p>

<p style="text-align: center;"><code class="reqn">if dose &gt; P then 1-((1 + (2^K2 - 1) * exp(4 * S2 * (x - P)))^(-1/K2)</code>
</p>

<p>with:<br />
</p>
<p style="text-align: center;"><code class="reqn">S1 = S/((4/K1)*(2^(-K1))^(1/K1+1)*(2^K1-1))</code>
</p>

<p style="text-align: center;"><code class="reqn">S2 = S/((4/K2)*(2^(-K2))^(1/K2+1)*(2^K2-1))</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>LD50(
  df = NULL,
  alive = NULL,
  dead = NULL,
  N = NULL,
  doses = NULL,
  l = 0.05,
  parameters.initial = NULL,
  fixed.parameters = NULL,
  SE = NULL,
  equation = "logistic",
  replicates = 1000,
  range.CI = 0.95,
  limit.low.TRD.minimum = 5,
  limit.high.TRD.maximum = 1000,
  print = TRUE,
  doses.plot = seq(from = 0, to = 1000, by = 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD50_+3A_df">df</code></td>
<td>
<p>A dataframe with at least two columns named alive, dead or N and doses columns</p>
</td></tr>
<tr><td><code id="LD50_+3A_alive">alive</code></td>
<td>
<p>A vector with alive individuals at the end of experiment</p>
</td></tr>
<tr><td><code id="LD50_+3A_dead">dead</code></td>
<td>
<p>A vector with dead individuals at the end of experiment</p>
</td></tr>
<tr><td><code id="LD50_+3A_n">N</code></td>
<td>
<p>A vector with total numbers of tested individuals</p>
</td></tr>
<tr><td><code id="LD50_+3A_doses">doses</code></td>
<td>
<p>The doses</p>
</td></tr>
<tr><td><code id="LD50_+3A_l">l</code></td>
<td>
<p>The limit to define TRD (see Girondot, 1999)</p>
</td></tr>
<tr><td><code id="LD50_+3A_parameters.initial">parameters.initial</code></td>
<td>
<p>Initial values for P, S or K search as a vector, ex. c(P=29, S=-0.3)</p>
</td></tr>
<tr><td><code id="LD50_+3A_fixed.parameters">fixed.parameters</code></td>
<td>
<p>Parameters that will not be changed during fit</p>
</td></tr>
<tr><td><code id="LD50_+3A_se">SE</code></td>
<td>
<p>Standard errors for parameters</p>
</td></tr>
<tr><td><code id="LD50_+3A_equation">equation</code></td>
<td>
<p>Could be &quot;logistic&quot;, &quot;logit&quot;, &quot;probit&quot;, Hill&quot;, &quot;Richards&quot;, &quot;Hulin&quot;, &quot;flexit&quot; or &quot;Double-Richards&quot;</p>
</td></tr>
<tr><td><code id="LD50_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicates to estimate confidence intervals</p>
</td></tr>
<tr><td><code id="LD50_+3A_range.ci">range.CI</code></td>
<td>
<p>The range of confidence interval for estimation, default=0.95</p>
</td></tr>
<tr><td><code id="LD50_+3A_limit.low.trd.minimum">limit.low.TRD.minimum</code></td>
<td>
<p>Minimum lower limit for TRD</p>
</td></tr>
<tr><td><code id="LD50_+3A_limit.high.trd.maximum">limit.high.TRD.maximum</code></td>
<td>
<p>Maximum higher limit for TRD</p>
</td></tr>
<tr><td><code id="LD50_+3A_print">print</code></td>
<td>
<p>Do the results must be printed at screen? TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="LD50_+3A_doses.plot">doses.plot</code></td>
<td>
<p>Sequences of doses that will be used for plotting. If NULL, does not estimate them</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LD50 estimates the parameters that best describe LD50
</p>


<h3>Value</h3>

<p>A list with the LD50, Transitional Range of Doses and their SE
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50_MHmcmc">LD50_MHmcmc</a>()</code>,
<code><a href="#topic+LD50_MHmcmc_p">LD50_MHmcmc_p</a>()</code>,
<code><a href="#topic+logLik.LD50">logLik.LD50</a>()</code>,
<code><a href="#topic+plot.LD50">plot.LD50</a>()</code>,
<code><a href="#topic+predict.LD50">predict.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
predict(LD50_logistic, doses=c(140, 170))
plot(LD50_logistic, xlim=c(0, 300), at=seq(from=0, to=300, by=50))
LD50_probit &lt;- LD50(data, equation="probit")
predict(LD50_probit, doses=c(140, 170))
plot(LD50_probit)
LD50_logit &lt;- LD50(data, equation="logit")
predict(LD50_logit, doses=c(140, 170))
plot(LD50_logit)
LD50_hill &lt;- LD50(data, equation="hill")
predict(LD50_hill, doses=c(140, 170))
plot(LD50_hill)
LD50_Richards &lt;- LD50(data, equation="Richards")
predict(LD50_Richards, doses=c(140, 170))
plot(LD50_Richards)
LD50_Hulin &lt;- LD50(data, equation="Hulin")
predict(LD50_Hulin, doses=c(140, 170))
plot(LD50_Hulin)
LD50_DoubleRichards &lt;- LD50(data, equation="Double-Richards")
predict(LD50_DoubleRichards, doses=c(140, 170))
plot(LD50_DoubleRichards)
LD50_flexit &lt;- LD50(data, equation="flexit")
predict(LD50_flexit, doses=c(140, 170))
plot(LD50_flexit)

## End(Not run)
</code></pre>

<hr>
<h2 id='LD50_MHmcmc'>Metropolis-Hastings algorithm for LD50</h2><span id='topic+LD50_MHmcmc'></span>

<h3>Description</h3>

<p>Run the Metropolis-Hastings algorithm for tsd.<br />
Deeply modified from a MCMC script by Olivier Martin (INRA, Paris-Grignon).<br />
The number of iterations is n.iter+n.adapt+1 because the initial likelihood is also displayed.<br />
I recommend that thin=1 because the method to estimate SE uses resampling.<br />
If initial point is maximum likelihood, n.adapt = 0 is a good solution.<br />
To get the SE from result_mcmc &lt;- tsd_MHmcmc(result=try), use:<br />
result_mcmc$BatchSE or result_mcmc$TimeSeriesSE<br />
The batch standard error procedure is usually thought to be not as accurate as the time series methods.<br />
Based on Jones, Haran, Caffo and Neath (2005), the batch size should be equal to sqrt(n.iter).<br />
Jones, G.L., Haran, M., Caffo, B.S. and Neath, R. (2006) Fixed Width Output Analysis for Markov chain Monte Carlo , Journal of the American Statistical Association, 101:1537-1547.<br />
coda package is necessary for this function.<br />
The parameters intermediate and filename are used to save intermediate results every 'intermediate' iterations (for example 1000). Results are saved in a file of name filename.<br />
The parameter previous is used to indicate the list that has been save using the parameters intermediate and filename. It permits to continue a mcmc search.<br />
These options are used to prevent the consequences of computer crash or if the run is very very long and processes at time limited.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD50_MHmcmc(
  result = stop("A result of LD50() fit must be provided"),
  n.iter = 10000,
  parametersMCMC = NULL,
  n.chains = 1,
  n.adapt = 0,
  thin = 1,
  trace = FALSE,
  batchSize = sqrt(n.iter),
  adaptive = FALSE,
  adaptive.lag = 500,
  adaptive.fun = function(x) {
     ifelse(x &gt; 0.234, 1.3, 0.7)
 },
  intermediate = NULL,
  filename = "intermediate.Rdata",
  previous = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD50_MHmcmc_+3A_result">result</code></td>
<td>
<p>An object obtained after a SearchR fit</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations for each step</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_parametersmcmc">parametersMCMC</code></td>
<td>
<p>A set of parameters used as initial point for searching with information on priors</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of replicates</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Number of iterations before to store outputs</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_thin">thin</code></td>
<td>
<p>Number of iterations between each stored output</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_trace">trace</code></td>
<td>
<p>True or False, shows progress</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_batchsize">batchSize</code></td>
<td>
<p>Number of observations to include in each batch fo SE estimation</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_adaptive">adaptive</code></td>
<td>
<p>Should an adaptive process for SDProp be used</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_adaptive.lag">adaptive.lag</code></td>
<td>
<p>Lag to analyze the SDProp value in an adaptive content</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_adaptive.fun">adaptive.fun</code></td>
<td>
<p>Function used to change the SDProp</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_intermediate">intermediate</code></td>
<td>
<p>Period for saving intermediate result, NULL for no save</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_filename">filename</code></td>
<td>
<p>If intermediate is not NULL, save intermediate result in this file</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_+3A_previous">previous</code></td>
<td>
<p>Previous result to be continued. Can be the filename in which intermediate results are saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LD50_MHmcmc runs the Metropolis-Hastings algorithm for LD50 (Bayesian MCMC)
</p>


<h3>Value</h3>

<p>A list with resultMCMC being mcmc.list object, resultLnL being likelihoods and parametersMCMC being the parameters used
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50">LD50</a>()</code>,
<code><a href="#topic+LD50_MHmcmc_p">LD50_MHmcmc_p</a>()</code>,
<code><a href="#topic+logLik.LD50">logLik.LD50</a>()</code>,
<code><a href="#topic+plot.LD50">plot.LD50</a>()</code>,
<code><a href="#topic+predict.LD50">predict.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
pMCMC &lt;- LD50_MHmcmc_p(LD50_logistic, accept=TRUE)
# Take care, it can be very long
result_mcmc_LD50 &lt;- LD50_MHmcmc(result=LD50_logistic, 
		parametersMCMC=pMCMC, n.iter=10000, n.chains = 1,  
		n.adapt = 0, thin=1, trace=1000, adaptive=TRUE, )
# summary() permits to get rapidly the standard errors for parameters
summary(result_mcmc_LD50)
plot(x=result_mcmc_LD50, parameters="S", scale.prior=TRUE, las=1)
plot(result_mcmc_LD50, parameters="S", scale.prior=TRUE, las=1, xlim=c(-20, 20))
plot(result_mcmc_LD50, parameters="P", scale.prior=TRUE, las=1)
1-rejectionRate(as.mcmc(result_mcmc_LD50))
raftery.diag(as.mcmc(result_mcmc_LD50))
heidel.diag(as.mcmc(result_mcmc_LD50))

#### Example with Uniforms priors

pMCMC &lt;- structure(list(Density = c("dunif", "dunif"), 
Prior1 = c(77.6216005852911, -31.0438095277258), 
Prior2 = c(310.486402341165, 31.0438095277258), 
SDProp = c(2, 0.5), 
Min = c(77.6216005852911, -31.0438095277258), 
Max = c(310.486402341165, 31.0438095277258), 
Init = c(155.243201170582, -15.5219047638629)), 
row.names = c("P", "S"), class = "data.frame")
result_mcmc_LD50 &lt;- LD50_MHmcmc(result=LD50_logistic, 
		parametersMCMC=pMCMC, n.iter=10000, n.chains = 1,  
		n.adapt = 0, thin=1, trace=1000, adaptive=TRUE, )
# summary() permits to get rapidly the standard errors for parameters
summary(result_mcmc_LD50)
plot(x=result_mcmc_LD50, parameters="S", scale.prior=TRUE, las=1)
plot(result_mcmc_LD50, parameters="S", scale.prior=TRUE, las=1, xlim=c(-40, 40))
plot(result_mcmc_LD50, parameters="P", scale.prior=TRUE, las=1)
1-rejectionRate(as.mcmc(result_mcmc_LD50))
raftery.diag(as.mcmc(result_mcmc_LD50))
heidel.diag(as.mcmc(result_mcmc_LD50))


## End(Not run)
</code></pre>

<hr>
<h2 id='LD50_MHmcmc_p'>Generates set of parameters to be used with LD50_MHmcmc()</h2><span id='topic+LD50_MHmcmc_p'></span>

<h3>Description</h3>

<p>Interactive script used to generate set of parameters to be
used with LD50_MHmcmc().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD50_MHmcmc_p(
  result = stop("An output from LD50() must be provided"),
  accept = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD50_MHmcmc_p_+3A_result">result</code></td>
<td>
<p>An object obtained after a LD50 fit</p>
</td></tr>
<tr><td><code id="LD50_MHmcmc_p_+3A_accept">accept</code></td>
<td>
<p>If TRUE, the script does not wait user information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LD50_MHmcmc_p generates set of parameters to be used with LD50_MHmcmc()
</p>


<h3>Value</h3>

<p>A matrix with the parameters
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50">LD50</a>()</code>,
<code><a href="#topic+LD50_MHmcmc">LD50_MHmcmc</a>()</code>,
<code><a href="#topic+logLik.LD50">logLik.LD50</a>()</code>,
<code><a href="#topic+plot.LD50">plot.LD50</a>()</code>,
<code><a href="#topic+predict.LD50">predict.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
pmcmc &lt;- LD50_MHmcmc_p(LD50_logistic, accept=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='list.packages'>List the installed packages with their locations</h2><span id='topic+list.packages'></span>

<h3>Description</h3>

<p>List the installed packages with their locations and version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.packages()
</code></pre>


<h3>Details</h3>

<p>list.packages lists the installed packages with their locations
</p>


<h3>Value</h3>

<p>A list with the installed packages and their version.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
list.packages()

## End(Not run)
</code></pre>

<hr>
<h2 id='local.search'>Return path of file searched for in local disk based on its file name</h2><span id='topic+local.search'></span>

<h3>Description</h3>

<p>Return path of file searched for in local disk based on its file name.<br />
It has been tested only with Windows XP and MacOSX. In MacOSX, you must have created the locate database first. Use OnyX utilities for this purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local.search(
  pattern,
  directory = "",
  folder = "$HOME",
  intern = TRUE,
  ignore.stdout = FALSE,
  ignore.stderr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local.search_+3A_pattern">pattern</code></td>
<td>
<p>The name of file to be searched for. Can use wildcards *</p>
</td></tr>
<tr><td><code id="local.search_+3A_directory">directory</code></td>
<td>
<p>The path of directory to be explored in for Windows</p>
</td></tr>
<tr><td><code id="local.search_+3A_folder">folder</code></td>
<td>
<p>The path of folder to be explored in for Unix based systems</p>
</td></tr>
<tr><td><code id="local.search_+3A_intern">intern</code></td>
<td>
<p>A logical (not NA) which indicates whether to capture the output of the command as an R character vector (see system()).</p>
</td></tr>
<tr><td><code id="local.search_+3A_ignore.stdout">ignore.stdout</code></td>
<td>
<p>a logical (not NA) indicating whether messages written to 'stdout' should be ignored  (see system()).</p>
</td></tr>
<tr><td><code id="local.search_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>a logical (not NA) indicating whether messages written to 'stderr' should be ignored  (see system()).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>local.search() returns path of file serached in local disk based on its file name
</p>


<h3>Value</h3>

<p>A vector with paths
</p>


<h3>Author(s)</h3>

<p>Marc Girondot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
RnwFiles &lt;- local.search("*.Rnw")
nc.files &lt;- local.search("*.nc", folder=paste0("'",getwd(),"'"))

## End(Not run)
</code></pre>

<hr>
<h2 id='logit'>Return the logit</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Return the logit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>The probability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logit returns the logit
</p>


<h3>Value</h3>

<p>A value
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other logit: 
<code><a href="#topic+flexit">flexit</a>()</code>,
<code><a href="#topic+invlogit">invlogit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- logit(0.5)
invlogit(n)
</code></pre>

<hr>
<h2 id='logLik.compareAIC'>Return Log Likelihood generated by FormatCompareAIC</h2><span id='topic+logLik.compareAIC'></span>

<h3>Description</h3>

<p>Return Log Likelihood generated by FormatCompareAIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compareAIC'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.compareAIC_+3A_object">object</code></td>
<td>
<p>A result generated by FormatCompareAIC</p>
</td></tr>
<tr><td><code id="logLik.compareAIC_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logLik.compareAIC Return Log Likelihood of a fit
</p>


<h3>Value</h3>

<p>The Log Likelihood value for the fitted model with data
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ED &lt;- FormatCompareAIC(logLik=-140, nobs=100, df=3)
logLik(ED)

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.cutter'>Return log likelihood of a cutter fitted model</h2><span id='topic+logLik.cutter'></span>

<h3>Description</h3>

<p>Return log likelihood of a cutter fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutter'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.cutter_+3A_object">object</code></td>
<td>
<p>A result file generated by cutter</p>
</td></tr>
<tr><td><code id="logLik.cutter_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logLik.cutter return log likelihood of a cutter fitted model
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ___________________________________________________________________
# Test for similarity in gamma left censored distribution between two
# datasets
# ___________________________________________________________________
obc1 &lt;- rgamma(100, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL &lt;- 10
# remove the data below the detection limit
obc1[obc1&lt;LDL] &lt;- -Inf
obc2 &lt;- rgamma(100, scale=10, shape=2)
# remove the data below the detection limit
obc2[obc2&lt;LDL] &lt;- -Inf
# search for the parameters the best fit these censored data
result1 &lt;- cutter(observations=obc1, 
                           lower_detection_limit=LDL, 
                          cut_method="censored")
logLik(result1)
result2 &lt;- cutter(observations=obc2, 
                           lower_detection_limit=LDL, 
                          cut_method="censored")
logLik(result2)
result_totl &lt;- cutter(observations=c(obc1, obc2), 
                           lower_detection_limit=LDL, 
                          cut_method="censored")
logLik(result_totl)
compare_AICc(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)
compare_BIC(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1) 

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.LD50'>Return Log Likelihood of a fit generated by LD50</h2><span id='topic+logLik.LD50'></span>

<h3>Description</h3>

<p>Return Log Likelihood of a fit generated by LD50
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LD50'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.LD50_+3A_object">object</code></td>
<td>
<p>A result file generated by fitRMU</p>
</td></tr>
<tr><td><code id="logLik.LD50_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logLik.LD50 Return Log Likelihood of a fit for LD50
</p>


<h3>Value</h3>

<p>The Log Likelihood value for the fitted model with data
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50">LD50</a>()</code>,
<code><a href="#topic+LD50_MHmcmc">LD50_MHmcmc</a>()</code>,
<code><a href="#topic+LD50_MHmcmc_p">LD50_MHmcmc_p</a>()</code>,
<code><a href="#topic+plot.LD50">plot.LD50</a>()</code>,
<code><a href="#topic+predict.LD50">predict.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
logLik(LD50_logistic)
AIC(LD50_logistic)

## End(Not run)
</code></pre>

<hr>
<h2 id='merge.mcmcComposite'>Merge two mcmcComposite results</h2><span id='topic+merge.mcmcComposite'></span>

<h3>Description</h3>

<p>Merge two mcmcComposite results and produced a new one mcmcComposite object.<br />
Note that the initial value
for the second run must use the last value of the first one as shown in example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcComposite'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.mcmcComposite_+3A_x">x</code></td>
<td>
<p>A mcmcComposite obtained as a result of <code>MHalgoGen()</code> function</p>
</td></tr>
<tr><td><code id="merge.mcmcComposite_+3A_y">y</code></td>
<td>
<p>A mcmcComposite obtained as a result of <code>MHalgoGen()</code> function</p>
</td></tr>
<tr><td><code id="merge.mcmcComposite_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>merge.mcmcComposite Merge two mcmcComposite results
</p>


<h3>Value</h3>

<p>A mcmcComposite result
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='MHalgoGen'>Monte-Carlo Markov-chain with Metropolis-Hastings algorithm</h2><span id='topic+MHalgoGen'></span>

<h3>Description</h3>

<p>The parameters must be stored in a data.frame with named rows for each parameter with the following columns:<br />
</p>

<ul>
<li><p> Density. The density function name, example <code>dnorm</code>, <code>dlnorm</code>, <code>dunif</code>, <code>dbeta</code>
</p>
</li>
<li><p> Prior1. The first parameter to send to the <code>Density</code> function
</p>
</li>
<li><p> Prior2. The second parameter to send to the <code>Density</code> function
</p>
</li>
<li><p> SDProp. The standard error from new proposition value of this parameter
</p>
</li>
<li><p> Min. The minimum value for this parameter
</p>
</li>
<li><p> Max. The maximum value for this parameter
</p>
</li>
<li><p> Init. The initial value for this parameter
</p>
</li></ul>

<p>This script has been deeply modified from a MCMC script provided by Olivier Martin (INRA, Paris-Grignon).<br />
The likelihood function must use a parameter named parameters_name for the nammed parameters.<br />
For adaptive mcmc, see:<br />
Rosenthal, J. S. 2011. Optimal Proposal Distributions and Adaptive MCMC. Pages 93-112 in S. Brooks, A. Gelman,
G. Jones, and X.-L. Meng, editors. MCMC Handbook. Chapman and Hall/CRC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MHalgoGen(
  likelihood = stop("A likelihood function must be supplied"),
  parameters = stop("Priors  must be supplied"),
  ...,
  parameters_name = "x",
  n.iter = 10000,
  n.chains = 1,
  n.adapt = 100,
  thin = 30,
  trace = FALSE,
  traceML = FALSE,
  progress.bar.ini = NULL,
  progress.bar = NULL,
  adaptive = FALSE,
  adaptive.lag = 500,
  adaptive.fun = function(x) {
     ifelse(x &gt; 0.234, 1.3, 0.7)
 },
  intermediate = NULL,
  filename = "intermediate.Rdata",
  previous = NULL,
  session = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MHalgoGen_+3A_likelihood">likelihood</code></td>
<td>
<p>The function that returns -ln likelihood using data and parameters</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_parameters">parameters</code></td>
<td>
<p>A data.frame with priors; see description and examples</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_...">...</code></td>
<td>
<p>Parameters to be transmitted to likelihood function</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_parameters_name">parameters_name</code></td>
<td>
<p>The name of the parameters in the likelihood function, default is &quot;x&quot;</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of iterations for each chain</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of chains</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Number of iteration to stabilize likelihood</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_thin">thin</code></td>
<td>
<p>Interval for thinning likelihoods</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_trace">trace</code></td>
<td>
<p>Or FALSE or period to show progress</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_traceml">traceML</code></td>
<td>
<p>TRUE or FALSE to show ML</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_progress.bar.ini">progress.bar.ini</code></td>
<td>
<p>The command to initialize progress bar</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_progress.bar">progress.bar</code></td>
<td>
<p>The command to run the progress bar</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_adaptive">adaptive</code></td>
<td>
<p>Should an adaptive process for SDProp be used</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_adaptive.lag">adaptive.lag</code></td>
<td>
<p>Lag to analyze the SDProp value in an adaptive context</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_adaptive.fun">adaptive.fun</code></td>
<td>
<p>Function used to change the SDProp</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_intermediate">intermediate</code></td>
<td>
<p>Or NULL of period to save intermediate result</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_filename">filename</code></td>
<td>
<p>Name of file in which intermediate results are saved</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_previous">previous</code></td>
<td>
<p>The content of the file in which intermediate results are saved</p>
</td></tr>
<tr><td><code id="MHalgoGen_+3A_session">session</code></td>
<td>
<p>The shiny session</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MHalgoGen is a function to use mcmc with Metropolis-Hastings algorithm
</p>


<h3>Value</h3>

<p>A mcmcComposite object with all characteristics of the model and mcmc run
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
val &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
# Use of trace and traceML parameters
# trace=1 : Only one likelihood is printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
# trace=10 : 10 likelihoods are printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=10)
# trace=TRUE : all likelihoods are printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=TRUE)
# trace=FALSE : No likelihood is printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE)
# traceML=TRUE : values when likelihood is better are shown
mcmc_run &lt;- MHalgoGen(n.iter=100, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=TRUE, traceML=TRUE)
mcmc_run &lt;- MHalgoGen(n.iter=100, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE, traceML=TRUE)

plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
library(graphics)
library(fields)
# show a scatter plot of the result
x &lt;- mcmc_run$resultMCMC[[1]][, 1]
y &lt;- mcmc_run$resultMCMC[[1]][, 2]
marpre &lt;- par(mar=c(4, 4, 2, 6)+0.4)
smoothScatter(x, y)
# show a scale
n &lt;- matrix(0, ncol=128, nrow=128)
xrange &lt;- range(x)
yrange &lt;- range(y)
for (i in 1:length(x)) {
  posx &lt;- 1+floor(127*(x[i]-xrange[1])/(xrange[2]-xrange[1]))
  posy &lt;- 1+floor(127*(y[i]-yrange[1])/(yrange[2]-yrange[1]))
  n[posx, posy] &lt;- n[posx, posy]+1
}
image.plot(legend.only=TRUE, zlim= c(0, max(n)), nlevel=128, 
 col=colorRampPalette(c("white", blues9))(128))
# Compare with a heatmap
x &lt;- seq(from=8, to=12, by=0.2)
y &lt;- seq(from=1, to=4, by=0.2)
df &lt;- expand.grid(mean=x, sd=y)
df &lt;- cbind(df, L=rep(0, length(nrow(df))))
for (i in 1:nrow(df)) df[i, "L"] &lt;- -sum(dnorm(val, df[i, 1], df[i, 2], log = TRUE))
hm &lt;- matrix(df[, "L"], nrow=length(x))
par(mar = marpre)
image.plot(x=x, y=y, z=hm, las=1)
# Diagnostic function from coda library
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, x=x, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, x=x, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)
# Here is how to use adaptive mcmc
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, adaptive = FALSE, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
1-rejectionRate(as.mcmc(mcmc_run))
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, adaptive = TRUE,  
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
1-rejectionRate(as.mcmc(mcmc_run))
# To see the dynamics :
var &lt;- "mean"
par(mar=c(4, 4, 1, 1)+0.4)
plot(1:nrow(mcmc_run$resultMCMC[[1]]), mcmc_run$resultMCMC[[1]][, var], type="l", 
       xlab="Iterations", ylab=var, bty="n", las=1)
# Exemple with a progress bar

val &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
# Set up the progress bar
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
                      likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE, 
                       progress.bar.ini=function(n.iter) {
                                 assign("pb", txtProgressBar(min=0, max=n.iter, style=3), 
                                        env = parent.frame())}, 
        progress.bar=function(iter) {setTxtProgressBar(get("pb", envir = parent.frame()), iter)})
 

## End(Not run)
</code></pre>

<hr>
<h2 id='minmax.periodic'>Search for minimum and maximum indices in periodic timeseries</h2><span id='topic+minmax.periodic'></span>

<h3>Description</h3>

<p>Search for minimum and maximum for periodic timeseries when only intermediate values are known.<br />
For each couple of value with an increasing or decreasing segment of
the sinusoid function, it is possible to estimate a minimum and maximum
values using analytical algebra.<br />
Then the average and standard deviations of all minima and maxima are evaluated.<br />
It should be noted that any extremum can be estimated at least twice, one by
increasing segment and one by decreasing segment. Both are used here to produce SD.<br />
<code>time.minmax.daily</code> should be used when the time at which maximum and minimum indices are regular and
<code>time.minmax</code> permits to define this time day by day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmax.periodic(
  time.minmax.daily = NULL,
  time.minmax = NULL,
  progressbar = FALSE,
  observed = stop("data.frame with observed indices"),
  period = 24,
  colname.time = "time",
  colname.index = "index",
  colname.SD = "SD",
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minmax.periodic_+3A_time.minmax.daily">time.minmax.daily</code></td>
<td>
<p>A named vector with Min and Max being the time in the day with minimum and maximum indices (temperature or level)</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_time.minmax">time.minmax</code></td>
<td>
<p>A named vector daily with time in the day at which minimum and maximum indices are observed</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_progressbar">progressbar</code></td>
<td>
<p>Tell if a progression bar must be shown</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_observed">observed</code></td>
<td>
<p>A dataframe with at least two columns: time and temperatures. A third column SD can indicate the know error in index</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_period">period</code></td>
<td>
<p>The unit of day period (24 for hours, 24*60 for minutes)</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_colname.time">colname.time</code></td>
<td>
<p>The name of the column for time in observed</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_colname.index">colname.index</code></td>
<td>
<p>The name of the column for indices in observed</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_colname.sd">colname.SD</code></td>
<td>
<p>The name of the column for SD in observed</p>
</td></tr>
<tr><td><code id="minmax.periodic_+3A_plot">plot</code></td>
<td>
<p>If TRUE, show a plot with the different estimates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>minmax.periodic search for minimum and maximum indices (temperatures or levels) in periodic timeseries
</p>


<h3>Value</h3>

<p>A data.frame with a column time, a column index and a column SD
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Periodic patterns of indices: 
<code><a href="#topic+index.periodic">index.periodic</a>()</code>,
<code><a href="#topic+moon.info">moon.info</a>()</code>,
<code><a href="#topic+sun.info">sun.info</a>()</code>,
<code><a href="#topic+tide.info">tide.info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Generate a timeserie of time
time.obs &lt;- NULL
for (i in 0:9) time.obs &lt;- c(time.obs, c(0, 6, 12, 18)+i*24)
# For these time, generate a timeseries of temperatures
temp.obs &lt;- rep(NA, length(time.obs))
temp.obs[3+(0:9)*4] &lt;- rnorm(10, 25, 3)
temp.obs[1+(0:9)*4] &lt;- rnorm(10, 10, 3)
for (i in 1:(length(time.obs)-1)) 
  if (is.na(temp.obs[i])) 
  temp.obs[i] &lt;- mean(c(temp.obs[i-1], temp.obs[i+1]))
  if (is.na(temp.obs[length(time.obs)])) 
  temp.obs[length(time.obs)] &lt;- temp.obs[length(time.obs)-1]/2
observed &lt;- data.frame(time=time.obs, temperature=temp.obs)
# Search for the minimum and maximum values
r &lt;- minmax.periodic(time.minmax.daily=c(Min=2, Max=15), 
observed=observed, period=24, colname.index="temperature")

# Estimate all the temperatures for these values
t &lt;- index.periodic(minmax=r)

plot_errbar(x=t[,"time"], y=t[,"index"],
errbar.y=ifelse(is.na(t[,"sd"]), 0, 2*t[,"sd"]),
type="l", las=1, bty="n", errbar.y.polygon = TRUE, 
xlab="hours", ylab="Temperatures", ylim=c(0, 35), 
errbar.y.polygon.list = list(col="grey"))

plot_add(x=t[,"time"], y=t[,"index"], type="l")

plot_add(observed$time, observed$temperature, pch=19, cex=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='modeled.hist'>Return the theoretical value for the histogram bar</h2><span id='topic+modeled.hist'></span>

<h3>Description</h3>

<p>Return the theoretical value for the histogram bar based on
a model of distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeled.hist(breaks, FUN, ..., sum = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeled.hist_+3A_breaks">breaks</code></td>
<td>
<p>Vector with the breaks; it can be obtained directly from hist()</p>
</td></tr>
<tr><td><code id="modeled.hist_+3A_fun">FUN</code></td>
<td>
<p>Function to be used to integrate the density, ex. pnorm</p>
</td></tr>
<tr><td><code id="modeled.hist_+3A_...">...</code></td>
<td>
<p>Parameters to be used by FUN</p>
</td></tr>
<tr><td><code id="modeled.hist_+3A_sum">sum</code></td>
<td>
<p>Total numbers in the histogram; 1 for emperical frequencies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>modeled.hist returns the theoretical value for the histogram bar based on a model of distribution.
</p>


<h3>Value</h3>

<p>A list with x (the center of the bar) and y components
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- rnorm(100, mean=10, sd=2)
breaks &lt;- 0:20
hist(n, breaks=breaks)

s &lt;- modeled.hist(breaks=breaks, FUN=pnorm, mean=10, sd=2, sum=100)

points(s$x, s$y, pch=19)
lines(s$x, s$y)

n &lt;- rlnorm(100, meanlog=2, sdlog=0.4)
b &lt;- hist(n, ylim=c(0, 70))

s &lt;- modeled.hist(breaks=b$breaks, FUN=plnorm, meanlog=2, sdlog=0.4, sum=100)

points(s$x, s$y, pch=19)
lines(s$x, s$y)

## End(Not run)
</code></pre>

<hr>
<h2 id='modifyVector'>Modifies Elements of a Vector</h2><span id='topic+modifyVector'></span>

<h3>Description</h3>

<p>Modifies a vector by changing a subset of elements to match a second vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyVector(x, val, add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifyVector_+3A_x">x</code></td>
<td>
<p>A named vector.</p>
</td></tr>
<tr><td><code id="modifyVector_+3A_val">val</code></td>
<td>
<p>A named vector with components to replace corresponding components in x.</p>
</td></tr>
<tr><td><code id="modifyVector_+3A_add">add</code></td>
<td>
<p>If FALSE, only existing elements of x are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>modifyVector modifies elements of a vector
</p>


<h3>Value</h3>

<p>A modified version of x, with the elements of val replacing the elements of x
</p>


<h3>Author(s)</h3>

<p>Marc Girondot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("HelpersMG")
e &lt;- c(M=10, L=20, J=30)
modifyVector(e, c(U=10, M=30))
modifyVector(e, c(U=10, M=30), add=FALSE)
</code></pre>

<hr>
<h2 id='moon.info'>Moon phase based on a date</h2><span id='topic+moon.info'></span>

<h3>Description</h3>

<p>The script gives an index (base 100) that represents moon phase.<br />
If the return value (from 0 to 100) is between:<br />
0 and 1.6931595 or 98.3068405 and 100, it is full moon,<br />
23.3068405 and 26.6931595, last quarter,<br />
48.3068405 and 51.6931595, new moon,<br />
73.3068405 and 76.6931595, first quarter<br />
When phase is set to TRUE, a character representing the moon phase is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moon.info(date = Sys.Date(), phase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moon.info_+3A_date">date</code></td>
<td>
<p>A date in class Date. By default, it will use today date</p>
</td></tr>
<tr><td><code id="moon.info_+3A_phase">phase</code></td>
<td>
<p>If TRUE, a vector of characters with NM, FQ, FL LQ will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>moon.info calculates the moon phase based on a date.
</p>


<h3>Value</h3>

<p>Return a value describing the moon phase:<br />
0 and 100 are full moon, 50 is new moon, 25 last quarter and 75 first quater
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Periodic patterns of indices: 
<code><a href="#topic+index.periodic">index.periodic</a>()</code>,
<code><a href="#topic+minmax.periodic">minmax.periodic</a>()</code>,
<code><a href="#topic+sun.info">sun.info</a>()</code>,
<code><a href="#topic+tide.info">tide.info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
moon.info(as.Date("2001-12-31"))
moon.info(as.Date("14/04/2010", "%d/%m/%Y"))
moon.info(as.Date("22/06/07", "%d/%m/%y"))
moon.info(seq(from=as.Date("2012-03-01"), 
	to=as.Date("2012-04-15"), by="days"))
moon.info(seq(from=as.Date("2012-03-01"), 
		to=as.Date("2012-04-15"), by="days"), phase=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MovingWindow'>Return a moving average of a vector.</h2><span id='topic+MovingWindow'></span>

<h3>Description</h3>

<p>Return a moving average of a vector./cr
hole parameter can be none, bothL, bothR, both, begin, end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MovingWindow(x, window, hole = "begin", fill = TRUE, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MovingWindow_+3A_x">x</code></td>
<td>
<p>The vector to analyze</p>
</td></tr>
<tr><td><code id="MovingWindow_+3A_window">window</code></td>
<td>
<p>The window size</p>
</td></tr>
<tr><td><code id="MovingWindow_+3A_hole">hole</code></td>
<td>
<p>Should the returned vector have the same length than x</p>
</td></tr>
<tr><td><code id="MovingWindow_+3A_fill">fill</code></td>
<td>
<p>TRUE or FALSE, should the vector return NA</p>
</td></tr>
<tr><td><code id="MovingWindow_+3A_fun">FUN</code></td>
<td>
<p>Function to apply to the window</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MovingWindow returns a moving average of a vector.
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MovingWindow(1:10, window = 4, fill = TRUE, hole="bothL")
MovingWindow(1:10, window = 4, fill = TRUE, hole="bothR")
MovingWindow(1:10, window = 4, fill = TRUE, hole="both")
MovingWindow(1:10, window = 4, fill = TRUE, hole="none")
MovingWindow(1:10, window = 4, fill = TRUE, hole="begin")
MovingWindow(1:10, window = 4, fill = TRUE, hole="end")
MovingWindow(1:10, window = 4, fill = TRUE, hole="end", FUN=sd)
</code></pre>

<hr>
<h2 id='NagelkerkeScaledR2'>Return the scaled R2 defined by Nagelkerke (1991)</h2><span id='topic+NagelkerkeScaledR2'></span>

<h3>Description</h3>

<p>Return the scaled R2 of a binomial model based on:<br />
Nagelkerke NJD (1991) A note on a general definition of the coefficient
of determination. Biometrika 78:691-192.<br />
This definition of scaled R2 by Nagelkerke (1991) has the following properties:<br />
(i) It is consistent with classical R2, that is the general definition applied to e.g. linear regression yields the classical R2.<br />
(ii) It is consistent with maximum likelihood as an estimation method, i.e. the maximum likelihood estimates of the model parameters maximize R2.<br />
(iii) It is asymptotically independent of the sample size n.<br />
(iv) 1-R2 has the interpretation of the proportion of unexplained 'variation'.<br />
(v) It is dimensionless, i.e. it does not depend on the units used.<br />
The reported value is similar to the value estimated with nagelkerke() function from rcompanion package but not
from the NagelkerkeR2() function from fmsb package. I don't know why.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NagelkerkeScaledR2(x, size, prediction, scaled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NagelkerkeScaledR2_+3A_x">x</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code id="NagelkerkeScaledR2_+3A_size">size</code></td>
<td>
<p>Number of trials</p>
</td></tr>
<tr><td><code id="NagelkerkeScaledR2_+3A_prediction">prediction</code></td>
<td>
<p>Prediction of x/size</p>
</td></tr>
<tr><td><code id="NagelkerkeScaledR2_+3A_scaled">scaled</code></td>
<td>
<p>If TRUE, return the scaled R2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NagelkerkeScaledR2 returns the scaled R2 defined by Nagelkerke (1991)
</p>


<h3>Value</h3>

<p>The scaled R2 value
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(10, 9, 6, 4, 3, 1, 0)
size &lt;- c(10, 10, 10, 10, 10, 10, 10)
prediction &lt;- c(0.9, 0.8, 0.7, 0.5, 0.4, 0.3, 0.2)
NagelkerkeScaledR2(x, size, prediction)

# Using the example in fmsb::NagelkerkeR2
res &lt;- glm(cbind(ncases,ncontrols) ~ agegp+alcgp+tobgp, data=esoph, family=binomial())
NagelkerkeScaledR2(x=esoph$ncases, size = esoph$ncases+esoph$ncontrols, 
                   prediction = res$fitted.values)
</code></pre>

<hr>
<h2 id='newcompassRose'>Display a compass rose</h2><span id='topic+newcompassRose'></span>

<h3>Description</h3>

<p>Displays a basic compass rose, usually to orient a map.<br />
newcompassRose displays a conventional compass rose at the position requested.<br />
The size of the compass rose is determined by the character expansion,
as the central &quot;rose&quot; is calculated relative to the character size.<br />
Rotation is in degrees counterclockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcompassRose(
  x,
  y,
  rot = 0,
  cex = 1,
  col = "black",
  col.arrows.light = "white",
  col.arrows.dark = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newcompassRose_+3A_x">x</code></td>
<td>
<p>The position of the center of the compass rose in user units.</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_y">y</code></td>
<td>
<p>The position of the center of the compass rose in user units.</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_rot">rot</code></td>
<td>
<p>Rotation for the compass rose in degrees. See Details.</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_cex">cex</code></td>
<td>
<p>The character expansion to use in the display.</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_col">col</code></td>
<td>
<p>The color of text</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_col.arrows.light">col.arrows.light</code></td>
<td>
<p>The color of lighter lines</p>
</td></tr>
<tr><td><code id="newcompassRose_+3A_col.arrows.dark">col.arrows.dark</code></td>
<td>
<p>The color of darker lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>newcompassRose Display a compass rose
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>modified from Jim Lemon; See <code><a href="sp.html#topic+compassRose">sp::compassRose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require("maps")
map("world", "China")
newcompassRose(x=110, y=35, col.arrows.light="grey")

## End(Not run)
</code></pre>

<hr>
<h2 id='newmap.scale'>Add Scale to Existing Unprojected Map</h2><span id='topic+newmap.scale'></span>

<h3>Description</h3>

<p>Adds a scale to an existing map, both as a ratio and a distance gauge.
If x or y are not specified, this will be taken to be near the lower left corner of the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newmap.scale(
  x,
  y,
  relwidth = 0.15,
  metric = TRUE,
  ratio = TRUE,
  col.line = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newmap.scale_+3A_x">x</code></td>
<td>
<p>Location of left end of distance gauge.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_y">y</code></td>
<td>
<p>Location of left end of distance gauge.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_relwidth">relwidth</code></td>
<td>
<p>Proportion of width of display to be used for the scale. The default is 0.15.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_metric">metric</code></td>
<td>
<p>If TRUE, the distance gauge will be in km, otherwise miles.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_ratio">ratio</code></td>
<td>
<p>If FALSE, the scale ratio of the map is not displayed.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_col.line">col.line</code></td>
<td>
<p>The color of lines for the gauge.</p>
</td></tr>
<tr><td><code id="newmap.scale_+3A_...">...</code></td>
<td>
<p>Further plotting parameters may be specified as for the command text().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>newmap.scale Add Scale to Existing Unprojected Map
</p>


<h3>Value</h3>

<p>The exact calculated scale is returned.
</p>


<h3>Author(s)</h3>

<p>See <code><a href="maps.html#topic+map.scale">maps::map.scale()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("maps")
library("HelpersMG")
map("world", "China")
newmap.scale(col.line = "red", col="blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='openwd'>Open a finder window with current working directory in MacOS X and windows</h2><span id='topic+openwd'></span>

<h3>Description</h3>

<p>This function opens a finder window with directory files
in MacOS X. It has not been fully tested in Windows. In linux, it just returns the
list of files in directory.<br />
By defaut, it uses the current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openwd(directory = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="openwd_+3A_directory">directory</code></td>
<td>
<p>The directory you want to open</p>
</td></tr>
</table>


<h3>Details</h3>

<p>openwd will open a finder window with current working directory
</p>


<h3>Value</h3>

<p>A vector with the list of files.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
openwd()

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_add'>Add a plot to a previous one</h2><span id='topic+plot_add'></span>

<h3>Description</h3>

<p>To plot data, just add use it as a normal plot. It will plot
the new data without axes, or labels for axes.<br />
This function is complementary to matlines() and matpoints() from package graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_add(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_add_+3A_...">...</code></td>
<td>
<p>Parameters for plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot_add adds a plot to a previous one
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other plot and barplot functions: 
<code><a href="#topic+ScalePreviousPlot">ScalePreviousPlot</a>()</code>,
<code><a href="#topic+barplot_errbar">barplot_errbar</a>()</code>,
<code><a href="#topic+plot_errbar">plot_errbar</a>()</code>,
<code><a href="#topic+show_name">show_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(x=1:100, y=sin(1:100), type="l", bty="n", xlim=c(1,200), xlab="x", ylab="y")
plot_add(x=1:200, y=cos(1:200), type="l", bty="n", col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_errbar'>Plot a xy graph with error bar on x and/or y</h2><span id='topic+plot_errbar'></span>

<h3>Description</h3>

<p>To plot data, just use it as a normal plot but add the errbar.x
and errbar.y values or errbar.x.minus, errbar.x.plus if bars for x axis are
asymetric and errbar.y.minus, errbar.y.plus if bars for y axis are
asymetric. Use x.plus, x.minus, y.plus and y.minus to set absolut limits for
error bars. Note that x.plus and x.minus have priority over errbar.x, errbar.x.minus and
errbar.x.plus and that y.plus and y.minus have priority over errbar.y, errbar.y.minus and
errbar.y.plus.<br />
The parameter errbar.y.polygon=TRUE permits to define error as an envolop for y axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_errbar(
  ...,
  errbar.x = NULL,
  errbar.y = NULL,
  errbar.x.plus = NULL,
  errbar.x.minus = NULL,
  errbar.y.plus = NULL,
  errbar.y.minus = NULL,
  x.plus = NULL,
  x.minus = NULL,
  y.plus = NULL,
  y.minus = NULL,
  errbar.tick = 1/50,
  errbar.lwd = par("lwd"),
  errbar.lty = par("lty"),
  errbar.col = par("fg"),
  errbar.y.polygon = FALSE,
  errbar.y.polygon.list = list(NULL),
  names = NULL,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_errbar_+3A_...">...</code></td>
<td>
<p>Parameters for plot() such as main= or ylim=</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.x">errbar.x</code></td>
<td>
<p>The length of error bars for x. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.y">errbar.y</code></td>
<td>
<p>The length of error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.x.plus">errbar.x.plus</code></td>
<td>
<p>The length of positive error bars for x. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.x.minus">errbar.x.minus</code></td>
<td>
<p>The length of negative error bars for x. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.y.plus">errbar.y.plus</code></td>
<td>
<p>The length of positive error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.y.minus">errbar.y.minus</code></td>
<td>
<p>The length of negative error bars for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_x.plus">x.plus</code></td>
<td>
<p>The absolut position of the positive error bar for x. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_x.minus">x.minus</code></td>
<td>
<p>The absolut position of the negative error bar for x. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_y.plus">y.plus</code></td>
<td>
<p>The absolut position of the positive error bar for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_y.minus">y.minus</code></td>
<td>
<p>The absolut position of the nagative error bar for y. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.tick">errbar.tick</code></td>
<td>
<p>Size of small ticks at the end of error bars defined as a proportion of total width or height graph size.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.lwd">errbar.lwd</code></td>
<td>
<p>Error bar line width, see par(&quot;lwd&quot;)</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.lty">errbar.lty</code></td>
<td>
<p>Error bar line type, see par(&quot;lwd&quot;)</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.col">errbar.col</code></td>
<td>
<p>Error bar line color, see par(&quot;col&quot;)</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.y.polygon">errbar.y.polygon</code></td>
<td>
<p>If true, the errors are shown as a filed polygon.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_errbar.y.polygon.list">errbar.y.polygon.list</code></td>
<td>
<p>List of parameters to be used for polygon.</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_names">names</code></td>
<td>
<p>The names of the points to be used with show_name().</p>
</td></tr>
<tr><td><code id="plot_errbar_+3A_add">add</code></td>
<td>
<p>If true, add the graph to the previous one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot_errbar plot a xy graph with error bar on x and/or y
</p>


<h3>Value</h3>

<p>A list with x, y and names for points
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>barplot_errorbar</code>
</p>
<p>Other plot and barplot functions: 
<code><a href="#topic+ScalePreviousPlot">ScalePreviousPlot</a>()</code>,
<code><a href="#topic+barplot_errbar">barplot_errbar</a>()</code>,
<code><a href="#topic+plot_add">plot_add</a>()</code>,
<code><a href="#topic+show_name">show_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_errbar(1:100, rnorm(100, 1, 2), 
	xlab="axe x", ylab="axe y", bty="n", xlim=c(1,100), 
		errbar.x=2, errbar.y=rnorm(100, 1, 0.1))
x &lt;- 1:100
plot_errbar(x=1:100, rnorm(100, 1, 2), 
               	xlab="axe x", ylab="axe y", bty="n", xlim=c(1,100), 
            		x.minus=x-2, x.plus=x+2)
x &lt;- 1:100
plot_errbar(x=1:100, rnorm(100, 1, 2), 
               	xlab="axe x", ylab="axe y", bty="n", 
               	pch=21, bg="white", 
            		x.minus=x-10, x.plus=x+10)
x &lt;- (1:200)/10
y &lt;- sin(x)
plot_errbar(x=x, y=y, xlab="axe x", ylab="axe y", bty="n", xlim=c(1,20), 
     y.minus=y-1, y.plus=y+1, ylim=c(-3, 3), type="l",  
		errbar.y.polygon=TRUE, 
		errbar.y.polygon.list=list(border=NA, col=rgb(0, 0, 0, 0.5)))
		
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.cutter'>Plot results of cutter that best describe distribution</h2><span id='topic+plot.cutter'></span>

<h3>Description</h3>

<p>Plot the estimates of cut distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutter'
plot(
  x,
  col.hist = "grey",
  col.DL = "blue",
  col.dist = "black",
  col.unobserved = "green",
  col.mcmc = rgb(red = 0.6, green = 0, blue = 0, alpha = 0.01),
  legend = TRUE,
  show.DL = TRUE,
  show.plot = TRUE,
  set = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cutter_+3A_x">x</code></td>
<td>
<p>A result file generated by cutter</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_col.hist">col.hist</code></td>
<td>
<p>The color of histogram</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_col.dl">col.DL</code></td>
<td>
<p>The color of below of above samples</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_col.dist">col.dist</code></td>
<td>
<p>The color of distribution</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_col.unobserved">col.unobserved</code></td>
<td>
<p>The color of unobserved states</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_col.mcmc">col.mcmc</code></td>
<td>
<p>The color of mcmc outputs</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_legend">legend</code></td>
<td>
<p>If TRUE, a legend is shown</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_show.dl">show.DL</code></td>
<td>
<p>If TRUE, the limits of DL are shown</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_show.plot">show.plot</code></td>
<td>
<p>If FALSE, no plot is shown</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_set">set</code></td>
<td>
<p>In case of mixture, will show and return only this set</p>
</td></tr>
<tr><td><code id="plot.cutter_+3A_...">...</code></td>
<td>
<p>Parameters for plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.cutter plot result of cutter
</p>


<h3>Value</h3>

<p>The matrix of all the mcmc curves with invisible state.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# _______________________________________________________________
# right censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 100
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&gt;DL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="censored")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# The same data seen as truncated data with gamma distribution
# _______________________________________________________________
obc &lt;- obc[is.finite(obc)]
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="truncated")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# left censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored")
result
plot(result)
plot(result, xlim=c(0, 200), breaks=seq(from=0, to=200, by=10))
# _______________________________________________________________
# left and right censored distribution
# _______________________________________________________________
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# Detection limit
LDL &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL] &lt;- -Inf
# Detection limit
UDL &lt;- 100
# remove the data below the detection limit
obc[obc&gt;UDL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                           upper_detection_limit=UDL, 
                          cut_method="censored")
result
plot(result, xlim=c(0, 150), col.DL=c("black", "grey"), 
                             col.unobserved=c("green", "blue"), 
     breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# Example with two values for lower detection limits
# corresponding at two different methods of detection for example
# with gamma distribution
# _______________________________________________________________
obc &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL1 &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL1] &lt;- -Inf
obc2 &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL2 &lt;- 20
# remove the data below the detection limit
obc2[obc2&lt;LDL2] &lt;- -Inf
obc &lt;- c(obc, obc2)
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, 
                           lower_detection_limit=c(rep(LDL1, 50), rep(LDL2, 50)), 
                          cut_method="censored")
result
# It is difficult to choose the best set of colors
plot(result, xlim=c(0, 150), col.dist="red", 
     col.unobserved=c(rgb(red=1, green=0, blue=0, alpha=0.1), 
                      rgb(red=1, green=0, blue=0, alpha=0.2)), 
     col.DL=c(rgb(red=0, green=0, blue=1, alpha=0.5), 
                      rgb(red=0, green=0, blue=1, alpha=0.9)), 
     breaks=seq(from=0, to=200, by=10))
# ___________________________________________________________________
# left censored distribution comparison of normal, lognormal and gamma
# ___________________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result_gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="gamma")
result_gamma
plot(result_gamma, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_lognormal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="lognormal")
result_lognormal
plot(result_lognormal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_normal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="normal")
result_normal
plot(result_normal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

compare_AICc(gamma=result_gamma, 
            lognormal=result_lognormal, 
            normal=result_normal)
# ___________________________________________________________________
# Test for similarity in gamma left censored distribution between two
# datasets
# ___________________________________________________________________
obc1 &lt;- rgamma(100, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL &lt;- 10
# remove the data below the detection limit
obc1[obc1&lt;LDL] &lt;- -Inf
obc2 &lt;- rgamma(100, scale=10, shape=2)
# remove the data below the detection limit
obc2[obc2&lt;LDL] &lt;- -Inf
# search for the parameters the best fit these censored data
result1 &lt;- cutter(observations=obc1, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored")
logLik(result1)
plot(result1, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result2 &lt;- cutter(observations=obc2, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored")
logLik(result2)
plot(result2, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result_totl &lt;- cutter(observations=c(obc1, obc2), 
                      distribution="gamma", 
                      lower_detection_limit=LDL, 
                      cut_method="censored")
logLik(result_totl)
plot(result_totl, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
     
compare_AICc(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)
compare_BIC(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)           

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.IconoCorel'>Clean the dataframe before to be used with IC_threshold_matrix</h2><span id='topic+plot.IconoCorel'></span>

<h3>Description</h3>

<p>This function plots the data as a network. It returns an invisible object that can be used with visIgraph from package visNetwork.
<code>https://fr.wikipedia.org/wiki/Iconographie_des_corrélations</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IconoCorel'
plot(
  x,
  ...,
  show.legend.direction = "bottomright",
  show.legend.strength = "topleft",
  title = "Correlation iconography",
  vertex.label.color = "black",
  vertex.label = NULL,
  vertex.color = "white",
  vertex.label.cex = 1,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.IconoCorel_+3A_x">x</code></td>
<td>
<p>The correlation matrix to show</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_...">...</code></td>
<td>
<p>other options of plot.igraph()</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_show.legend.direction">show.legend.direction</code></td>
<td>
<p>the position of the legend of direction; FALSE to not show it</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_show.legend.strength">show.legend.strength</code></td>
<td>
<p>the position of the legend with intensity of correlation; FALSE to not show it</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_title">title</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>a vector with the colors of labels</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_vertex.label">vertex.label</code></td>
<td>
<p>a vector with the labels</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_vertex.color">vertex.color</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>a vector of cex</p>
</td></tr>
<tr><td><code id="plot.IconoCorel_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the plot is shown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.IconoCorel checks and corrects the dataframe to be used with IC_threshold_matrix
</p>


<h3>Value</h3>

<p>A igraph object
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Lesty, M., 1999. Une nouvelle approche dans le choix des régresseurs de la régression multiple en présence d’interactions et de colinéarités. Revue de Modulad 22, 41-77.
</p>


<h3>See Also</h3>

<p>Other Iconography of correlations: 
<code><a href="#topic+IC_clean_data">IC_clean_data</a>()</code>,
<code><a href="#topic+IC_correlation_simplify">IC_correlation_simplify</a>()</code>,
<code><a href="#topic+IC_threshold_matrix">IC_threshold_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
es &lt;- structure(list(Student = c("e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8"), 
                 Mass = c(52, 59, 55, 58, 66, 62, 63, 69), 
                 Age = c(12, 12.5, 13, 14.5, 15.5, 16, 17, 18), 
                 Assiduity = c(12, 9, 15, 5, 11, 15, 12, 9), 
                 Note = c(5, 5, 9, 5, 13.5, 18, 18, 18)), 
                 row.names = c(NA, -8L), class = "data.frame")

es

df &lt;- IC_clean_data(es, debug = TRUE)
cor_matrix &lt;- IC_threshold_matrix(data=df, threshold = NULL, progress=FALSE)
cor_threshold &lt;- IC_threshold_matrix(data=df, threshold = 0.3)
par(mar=c(1,1,1,1))
set.seed(4)
library("igraph")
library("visNetwork")
kk &lt;- plot(cor_threshold, vertex.color="red")
# it can be shown also with the visNetwork package
visIgraph(kk)
cor_threshold_Note &lt;- IC_correlation_simplify(matrix=cor_threshold, variable="Note")
plot(cor_threshold_Note)

# You can record the position of elements and use them later
ly &lt;- layout_nicely(kk)
plot(cor_threshold, vertex.color="red", layout=ly)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.LD50'>Plot results of LD50() that best describe LD50</h2><span id='topic+plot.LD50'></span>

<h3>Description</h3>

<p>Plot the estimates that best describe lethality of doses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LD50'
plot(
  x,
  ...,
  las.x = 1,
  las.y = 1,
  lab.PT = "LD50",
  at = NULL,
  lab.TRD = paste0("Transitional range of doses l=", l * 100, "%"),
  col.TRD = "gray",
  col.TRD.CI = rgb(0.8, 0.8, 0.8, 0.5),
  col.PT.CI = rgb(0.8, 0.8, 0.8, 0.5),
  show.CI = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LD50_+3A_x">x</code></td>
<td>
<p>A result file generated by IC50()</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_...">...</code></td>
<td>
<p>Parameters for plot()</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_las.x">las.x</code></td>
<td>
<p>las parameter for x axis</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_las.y">las.y</code></td>
<td>
<p>las parameter for y axis</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_lab.pt">lab.PT</code></td>
<td>
<p>Label to describe pivotal dose</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_at">at</code></td>
<td>
<p>Position of ticks in x-axis</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_lab.trd">lab.TRD</code></td>
<td>
<p>Label to describe transitional range of dose</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_col.trd">col.TRD</code></td>
<td>
<p>The color of TRD</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_col.trd.ci">col.TRD.CI</code></td>
<td>
<p>The color of CI of TRD based on range.CI</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_col.pt.ci">col.PT.CI</code></td>
<td>
<p>The color of CI of PT based on range.CI</p>
</td></tr>
<tr><td><code id="plot.LD50_+3A_show.ci">show.CI</code></td>
<td>
<p>Do the CI for the curve should be shown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.LD50 plot result of IC50() that best describe IC50
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50">LD50</a>()</code>,
<code><a href="#topic+LD50_MHmcmc">LD50_MHmcmc</a>()</code>,
<code><a href="#topic+LD50_MHmcmc_p">LD50_MHmcmc_p</a>()</code>,
<code><a href="#topic+logLik.LD50">logLik.LD50</a>()</code>,
<code><a href="#topic+predict.LD50">predict.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
predict(LD50_logistic, doses=c(140, 170))
plot(LD50_logistic, xlim=c(0, 300))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mcmcComposite'>Plot the result of a mcmcComposite object</h2><span id='topic+plot.mcmcComposite'></span>

<h3>Description</h3>

<p>Plot the results within a mcmcComposite object.<br />
If scale.prior is TRUE, another scale is shown at right.<br />
legend can take these values: <br />
FALSE, TRUE, topleft, topright, bottomleft, bottomright, c(x=, y=)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcComposite'
plot(
  x,
  ...,
  chain = 1,
  parameters = 1,
  transform = NULL,
  scale.prior = TRUE,
  legend = "topright",
  ylab = "Posterior density",
  las = 1,
  show.prior = TRUE,
  col.prior = "red",
  lty.prior = 1,
  lwd.prior = 1,
  col.posterior = "white",
  lty.posterior = 1,
  lwd.posterior = 1,
  ylab.prior = "Prior density"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcmcComposite_+3A_x">x</code></td>
<td>
<p>A mcmcComposite object</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_...">...</code></td>
<td>
<p>Graphical parameters to be sent to hist()</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_chain">chain</code></td>
<td>
<p>The chain to use</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_parameters">parameters</code></td>
<td>
<p>Name of parameters or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_transform">transform</code></td>
<td>
<p>Function to be used to transform the variable</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_scale.prior">scale.prior</code></td>
<td>
<p>If TRUE, the prior is scaled at the same size as posterior</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_legend">legend</code></td>
<td>
<p>If FALSE, the legend is not shown; see description</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_ylab">ylab</code></td>
<td>
<p>y-label for posterior</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_las">las</code></td>
<td>
<p>las parameter (orientation of y-axis graduation)</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_show.prior">show.prior</code></td>
<td>
<p>whould the prior be shown?</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_col.prior">col.prior</code></td>
<td>
<p>Color for prior curve</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_lty.prior">lty.prior</code></td>
<td>
<p>Type of line for prior curve</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_lwd.prior">lwd.prior</code></td>
<td>
<p>Width of line for prior curve</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_col.posterior">col.posterior</code></td>
<td>
<p>Color for posterior histogram</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_lty.posterior">lty.posterior</code></td>
<td>
<p>Type of line for posterior histogram</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_lwd.posterior">lwd.posterior</code></td>
<td>
<p>Width of line for posterior histogram</p>
</td></tr>
<tr><td><code id="plot.mcmcComposite_+3A_ylab.prior">ylab.prior</code></td>
<td>
<p>y-label for prior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.mcmcComposite plots the result of a MCMC search
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)

#########################
## Example with transform
#########################

x.1&lt;-rnorm(6000, 2.4, 0.6)
x.2&lt;-rlnorm(10000, 1.3,0.1)

X&lt;-c(x.1, x.2)
hist(X,100,freq=FALSE, ylim=c(0,1.5))
Lnormlnorm &lt;- function(par, val) {
  p &lt;- invlogit(par["p"])
  return(-sum(log(p*dnorm(val, par["m1"], abs(par["s1"]), log = FALSE)+
                    (1-p)*dlnorm(val, par["m2"], abs(par["s2"]), log = FALSE))))
}
# Mean 1
m1=2.3; s1=0.5
# Mean 2
m2=1.3; s2=0.1
# proportion of category 1 - logit transform
p=0

par&lt;-c(m1=m1, s1=s1, m2=m2, s2=s2, p=p)

result2&lt;-optim(par, Lnormlnorm, method="BFGS", val=X, 
              hessian=FALSE, control=list(trace=1))
              
lines(seq(from=0, to=5, length=100), 
dnorm(seq(from=0, to=5, length=100), 
      result2$par["m1"], abs(result2$par["s1"])), col="red")

lines(seq(from=0, to=5, length=100), 
      dlnorm(seq(from=0, to=5, length=100), 
             result2$par["m2"], abs(result2$par["s2"])), col="green")

p &lt;- invlogit(result2$par["p"])

paste("Proportion of Gaussian data",  p)

lines(seq(from=0, to=5, length=100), 
      p*dnorm(seq(from=0, to=5, length=100), 
              result2$par["m1"], result2$par["s1"])+
        (1-p)*dlnorm(seq(from=0, to=5, length=100), 
                     result2$par["m2"], result2$par["s2"]), col="blue")               

parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dunif'), 
                                        Prior1=c(0, 0.001, 0, 0.001, -3), 
                                        Prior2=c(10, 10, 10, 10, 3), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, -3), 
                                        Max=c(10, 10, 10, 10, 3), 
                                        Init=result2$par, stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run, parameters="p", transform=invlogit, xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=0.10))
plot(mcmc_run, parameters="p", xlim=c(-3,3), 
     breaks=seq(from=-3, to =3, by=0.05), legend=c(x=1, y= 0.10))
     
parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dnorm'), 
                                        Prior1=c(0, 0.001, 0, 0.001, 0.5), 
                                        Prior2=c(10, 10, 10, 10, 1), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, -3), 
                                        Max=c(10, 10, 10, 10, 3), 
                                        Init=result2$par, stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run_pnorm &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run_pnorm, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run_pnorm, parameters="p", transform=invlogit, xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=0.10))
plot(x=mcmc_run_pnorm, parameters="p", xlim=c(-3,3), 
     breaks=seq(from=-3, to =3, by=0.05), legend=c(x=1, y= 0.10))
     
     
# Note that it is more logic to use beta distribution for p as a  
# proportion. However p value must be checked to be used in optim
# The use of logit transform can be a problem because it can stuck 
# the p value to 1 or 0 during fit.

Lnormlnorm &lt;- function(par, val) {
  p &lt;- par["p"]
  return(-sum(log(p*dnorm(val, par["m1"], abs(par["s1"]), log = FALSE)+
                    (1-p)*dlnorm(val, par["m2"], abs(par["s2"]), log = FALSE))))
}

# Example of beta distribution

# Mean is alpha/(alpha+beta)
# Variance is (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
alpha = 5
beta = 9
plot(x = seq(0.0001, 1, by = .0001), 
    y = dbeta(seq(0.0001, 1, by = .0001), alpha, beta),
    type = "l", ylab="Density", xlab="p", bty="n")
points(x=alpha/(alpha+beta), y=0, pch=4)
segments(x0=alpha/(alpha+beta)-sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1))), 
        x1=alpha/(alpha+beta)+sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1))),
        y0=0, y1=0)

# Use of optim with L-BFGS-B to limit p between 0 and 1 and s &gt; 0

# Mean 1
m1=2.3; s1=0.5
# Mean 2
m2=1.3; s2=0.1
# proportion of category 1 - logit transform
p=0.5

par &lt;- c(m1=m1, s1=s1, m2=m2, s2=s2, p=p)

result2 &lt;- optim(par, Lnormlnorm, method="L-BFGS-B", val=X, 
              lower = c(-Inf, 0, -Inf, 0, 0), 
              upper = c(Inf, Inf, Inf, Inf, 1),
              hessian=FALSE, control=list(trace=1))

parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dbeta'), 
                                        Prior1=c(0, 0.001, 0, 0.001, 5), 
                                        Prior2=c(10, 10, 10, 10, 9), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, 0), 
                                        Max=c(10, 10, 10, 10, 1), 
                                        Init=c('m1' = 2.4, 
                                               's1' = 0.6, 
                                               'm2' = 1.3, 
                                               's2' = 0.1, 
                                               'p' = 0.5), stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run_pbeta &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run_pbeta, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run_pbeta, parameters="p", xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=2))



## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PriorsmcmcComposite'>Plot a prior defined with setPriors function</h2><span id='topic+plot.PriorsmcmcComposite'></span>

<h3>Description</h3>

<p>Create a ggplot graph with prior.<br />
The function makes minimal effort to decorate the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PriorsmcmcComposite'
plot(x, parameter = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PriorsmcmcComposite_+3A_x">x</code></td>
<td>
<p>The priors to show</p>
</td></tr>
<tr><td><code id="plot.PriorsmcmcComposite_+3A_parameter">parameter</code></td>
<td>
<p>The name or rank of prior to show</p>
</td></tr>
<tr><td><code id="plot.PriorsmcmcComposite_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.PriorsmcmcComposite plot a prior
</p>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
par &lt;- c(a0=10, a1=2, b2=20, b1=-1)
rules &lt;- rbind(data.frame(Name="^a", Min=0, Max="x*2"), 
              data.frame(Name="^b", Min=0, Max=100))
p &lt;- setPriors(par=par, se=NULL, density="dgamma", rules=rules)
plot(p, parameter="a0")
q &lt;- plot(p, parameter="b1")
q + geom_line(color = "red") + theme_bw() + 
theme(plot.margin=unit(c(2,1,1,1), 'cm'), 
      panel.border = element_blank(), 
      axis.line.x.bottom = element_line(colour = "black"), 
      axis.line.y.left = element_line(colour = "black")) + 
labs(title="Parameter: b1") + theme(plot.title = element_text(hjust = 0.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.LD50'>Estimate survival according to doses</h2><span id='topic+predict.LD50'></span>

<h3>Description</h3>

<p>Estimate survival according to doses.<br />
The returned data.frame has the following components:<br />
doses, SE, survival, CI.minus.sexratio, CI.plus.sexratio, range.CI<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LD50'
predict(
  object,
  doses = NULL,
  SE = NULL,
  range.CI = 0.95,
  replicates = 1000,
  progressbar = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.LD50_+3A_object">object</code></td>
<td>
<p>A result file generated by LD50</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_doses">doses</code></td>
<td>
<p>A vector of temperatures</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_se">SE</code></td>
<td>
<p>The standard error for doses, optional</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_range.ci">range.CI</code></td>
<td>
<p>The range of confidence interval for estimation, default=0.95</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicates to estimate CI</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_progressbar">progressbar</code></td>
<td>
<p>Logical. Does a progression bar must be shown</p>
</td></tr>
<tr><td><code id="predict.LD50_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>predict.LD50 Estimate survival according to doses
</p>


<h3>Value</h3>

<p>A data.frame with informations about survival
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other LD50 functions: 
<code><a href="#topic+LD50">LD50</a>()</code>,
<code><a href="#topic+LD50_MHmcmc">LD50_MHmcmc</a>()</code>,
<code><a href="#topic+LD50_MHmcmc_p">LD50_MHmcmc_p</a>()</code>,
<code><a href="#topic+logLik.LD50">logLik.LD50</a>()</code>,
<code><a href="#topic+plot.LD50">plot.LD50</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#' data &lt;- data.frame(Doses=c(80, 120, 150, 150, 180, 200),
Alive=c(10, 12, 8, 6, 2, 1),
Dead=c(0, 1, 5, 6, 9, 15))
LD50_logistic &lt;- LD50(data, equation="logistic")
predict(LD50_logistic, doses=c(140, 170))
plot(LD50_logistic

## End(Not run)
</code></pre>

<hr>
<h2 id='print.cutter'>Print results of cutter that best describe distribution</h2><span id='topic+print.cutter'></span>

<h3>Description</h3>

<p>Print the estimates of cut distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cutter'
print(x, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cutter_+3A_x">x</code></td>
<td>
<p>A result file generated by cutter</p>
</td></tr>
<tr><td><code id="print.cutter_+3A_silent">silent</code></td>
<td>
<p>If TRUE does not show the outpout</p>
</td></tr>
<tr><td><code id="print.cutter_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>print.cutter plot result of cutter
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# _______________________________________________________________
# right censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 100
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&gt;DL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="censored")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# The same data seen as truncated data with gamma distribution
# _______________________________________________________________
obc &lt;- obc[is.finite(obc)]
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="truncated")
result
plot(result, xlim=c(0, 150), breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# left censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored")
result
plot(result, xlim=c(0, 200), breaks=seq(from=0, to=200, by=10))
# _______________________________________________________________
# left and right censored distribution
# _______________________________________________________________
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# Detection limit
LDL &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL] &lt;- -Inf
# Detection limit
UDL &lt;- 100
# remove the data below the detection limit
obc[obc&gt;UDL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, lower_detection_limit=LDL, 
                           upper_detection_limit=UDL, 
                          cut_method="censored")
result
plot(result, xlim=c(0, 150), col.DL=c("black", "grey"), 
                             col.unobserved=c("green", "blue"), 
     breaks=seq(from=0, to=150, by=10))
# _______________________________________________________________
# Example with two values for lower detection limits
# corresponding at two different methods of detection for example
# with gamma distribution
# _______________________________________________________________
obc &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL1 &lt;- 10
# remove the data below the detection limit
obc[obc&lt;LDL1] &lt;- -Inf
obc2 &lt;- rgamma(50, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL2 &lt;- 20
# remove the data below the detection limit
obc2[obc2&lt;LDL2] &lt;- -Inf
obc &lt;- c(obc, obc2)
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, 
                           lower_detection_limit=c(rep(LDL1, 50), rep(LDL2, 50)), 
                          cut_method="censored")
result
# It is difficult to choose the best set of colors
plot(result, xlim=c(0, 150), col.dist="red", 
     col.unobserved=c(rgb(red=1, green=0, blue=0, alpha=0.1), 
                      rgb(red=1, green=0, blue=0, alpha=0.2)), 
     col.DL=c(rgb(red=0, green=0, blue=1, alpha=0.5), 
                      rgb(red=0, green=0, blue=1, alpha=0.9)), 
     breaks=seq(from=0, to=200, by=10))
# ___________________________________________________________________
# left censored distribution comparison of normal, lognormal and gamma
# ___________________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result_gamma &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="gamma")
result_gamma
plot(result_gamma, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_lognormal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="lognormal")
result_lognormal
plot(result_lognormal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

result_normal &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored", distribution="normal")
result_normal
plot(result_normal, xlim=c(0, 250), breaks=seq(from=0, to=250, by=10))

compare_AICc(gamma=result_gamma, 
            lognormal=result_lognormal, 
            normal=result_normal)
# ___________________________________________________________________
# Test for similarity in gamma left censored distribution between two
# datasets
# ___________________________________________________________________
obc1 &lt;- rgamma(100, scale=20, shape=2)
# Detection limit for sample 1 to 50
LDL &lt;- 10
# remove the data below the detection limit
obc1[obc1&lt;LDL] &lt;- -Inf
obc2 &lt;- rgamma(100, scale=10, shape=2)
# remove the data below the detection limit
obc2[obc2&lt;LDL] &lt;- -Inf
# search for the parameters the best fit these censored data
result1 &lt;- cutter(observations=obc1, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored")
logLik(result1)
plot(result1, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result2 &lt;- cutter(observations=obc2, 
                  distribution="gamma", 
                  lower_detection_limit=LDL, 
                  cut_method="censored")
logLik(result2)
plot(result2, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
result_totl &lt;- cutter(observations=c(obc1, obc2), 
                      distribution="gamma", 
                      lower_detection_limit=LDL, 
                      cut_method="censored")
logLik(result_totl)
plot(result_totl, xlim=c(0, 200), 
     breaks=seq(from=0, to=200, by=10))
     
compare_AICc(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)
compare_BIC(Separate=list(result1, result2), 
            Common=result_totl, factor.value=1)           

## End(Not run)
</code></pre>

<hr>
<h2 id='qvlmer'>Quasi Variances for lmer Model Coefficients</h2><span id='topic+qvlmer'></span>

<h3>Description</h3>

<p>Computes a set of quasi variances (and corresponding quasi standard errors)
for estimated model coefficients relating to the levels of a categorical (i.e., factor)
explanatory variable. For details of the method see Firth (2000), Firth (2003) or Firth
and de Menezes (2004). Quasi variances generalize and improve the accuracy of “floating
absolute risk” (Easton et al., 1991). This device for economical model summary was first
suggested by Ridout (1989).<br />
Modified from qvcalc.lm() of packages qvcalc by David Firth, d.firth@warwick.ac.uk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qvlmer(object, factorname = NULL, coef.indices = NULL, dispersion = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qvlmer_+3A_object">object</code></td>
<td>
<p>A object obtained using lmer from package lme4</p>
</td></tr>
<tr><td><code id="qvlmer_+3A_factorname">factorname</code></td>
<td>
<p>Either NULL, or a character vector of length 1</p>
</td></tr>
<tr><td><code id="qvlmer_+3A_coef.indices">coef.indices</code></td>
<td>
<p>Either NULL, or a numeric vector of length at least 3</p>
</td></tr>
<tr><td><code id="qvlmer_+3A_dispersion">dispersion</code></td>
<td>
<p>An optional scalar multiplier for the covariance matrix, to cope with overdispersion for example</p>
</td></tr>
<tr><td><code id="qvlmer_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to qvcalc.default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>qvlmer is Quasi Variances for lmer Model Coefficients
</p>


<h3>Value</h3>

<p>A list of class qv.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Easton, D. F, Peto, J. and Babiker, A. G. A. G. (1991) Floating absolute risk: an alternative to relative risk in survival and case-control analysis avoiding an arbitrary reference group. Statistics in Medicine 10, 1025–1035.
</p>
<p>Firth, D. (2000) Quasi-variances in Xlisp-Stat and on the web. Journal of Statistical Software 5.4, 1–13. At http://www.jstatsoft.org
</p>
<p>Firth, D. (2003) Overcoming the reference category problem in the presentation of statistical models. Sociological Methodology 33, 1–18.
</p>
<p>Firth, D. and de Mezezes, R. X. (2004) Quasi-variances. Biometrika 91, 65–80.
</p>
<p>McCullagh, P. and Nelder, J. A. (1989) Generalized Linear Models. London: Chapman and Hall.
</p>
<p>Menezes, R. X. de (1999) More useful standard errors for group and factor effects in generalized linear models. D.Phil. Thesis, Department of Statistics, University of Oxford.
</p>
<p>Ridout, M.S. (1989). Summarizing the results of fitting generalized linear models to data from designed experiments. In: Statistical Modelling: Proceedings of GLIM89 and the 4th International Workshop on Statistical Modelling held in Trento, Italy, July 17–21, 1989 (A. Decarli et al., eds.), pp 262–269. New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- rnorm(100)
y &lt;- rnorm(100)
G &lt;- as.factor(sample(c("A", "B", "C", "D"), 100, replace = TRUE))
R &lt;- as.factor(rep(1:25, 4))
library(lme4)
m &lt;- lmer(y ~ x + G + (1 | R))
qvlmer(m, factorname="G")

## End(Not run)
</code></pre>

<hr>
<h2 id='r2norm'>Random generation for Gaussian distributions different at left and right</h2><span id='topic+r2norm'></span>

<h3>Description</h3>

<p>Random generation for Gaussian distributions different at left and right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2norm(n, mean = 0, sd_low = 1, sd_high = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2norm_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="r2norm_+3A_mean">mean</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="r2norm_+3A_sd_low">sd_low</code></td>
<td>
<p>vector of standard deviations below the mean.</p>
</td></tr>
<tr><td><code id="r2norm_+3A_sd_high">sd_high</code></td>
<td>
<p>vector of standard deviations above the mean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>r2norm returns random numbers for Gaussian distributions different at left and right
</p>


<h3>Value</h3>

<p>r2norm returns random numbers
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- r2norm(1000, mean=25, sd_low=2, sd_high=10)

hist(n)

## End(Not run)
</code></pre>

<hr>
<h2 id='RandomFromHessianOrMCMC'>Random numbers based on Hessian matrix or MCMC</h2><span id='topic+RandomFromHessianOrMCMC'></span>

<h3>Description</h3>

<p>If it is very long, use silent parameter to check if something goes wrong.<br />
If replicates is NULL or is 0, or if method is NULL, parameters are just copied into data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomFromHessianOrMCMC(
  se = NULL,
  Hessian = NULL,
  mcmc = NULL,
  chain = 1,
  regularThin = TRUE,
  MinMax = NULL,
  fitted.parameters = NULL,
  fixed.parameters = NULL,
  method = NULL,
  probs = c(0.025, 0.5, 0.975),
  replicates = 10000,
  fn = NULL,
  silent = FALSE,
  ParTofn = "par",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_se">se</code></td>
<td>
<p>A named vector with SE of parameters</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_hessian">Hessian</code></td>
<td>
<p>An Hessian matrix</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_mcmc">mcmc</code></td>
<td>
<p>A result from MHalgogen()</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_chain">chain</code></td>
<td>
<p>MCMC chain to be used</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_regularthin">regularThin</code></td>
<td>
<p>If TRUE, use regular thin for MCMC</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_minmax">MinMax</code></td>
<td>
<p>A data.frame with at least two columns: Min and Max and rownames being the variable names</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_fitted.parameters">fitted.parameters</code></td>
<td>
<p>The fitted parameters</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_fixed.parameters">fixed.parameters</code></td>
<td>
<p>The fixed parameters</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_method">method</code></td>
<td>
<p>Can be NULL, &quot;SE&quot;, &quot;Hessian&quot;, &quot;MCMC&quot;, or &quot;PseudoHessianFromMCMC&quot;</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_probs">probs</code></td>
<td>
<p>Probability for quantiles</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicates to generate the randoms</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_fn">fn</code></td>
<td>
<p>The function to apply to each replicate</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_silent">silent</code></td>
<td>
<p>Should the function display some information</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_partofn">ParTofn</code></td>
<td>
<p>Name of the parameter to send random values to fn</p>
</td></tr>
<tr><td><code id="RandomFromHessianOrMCMC_+3A_...">...</code></td>
<td>
<p>Parameters send to fn function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RandomFromHessianOrMCMC returns random numbers based on Hessian matrix or MCMC
</p>


<h3>Value</h3>

<p>Returns a list with three data.frames named random, fn, and quantiles
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
val &lt;- rnorm(100, mean=20, sd=5)+(1:100)/10
# Return -ln L of values in val in Gaussian distribution with mean and sd in par
fitnorm &lt;- function(par, data) {
  -sum(dnorm(data, par["mean"], abs(par["sd"]), log = TRUE))
}
# Initial values for search
p&lt;-c(mean=20, sd=5)
# fit the model
result &lt;- optim(par=p, fn=fitnorm, data=val, method="BFGS", hessian=TRUE)
# Using Hessian
df &lt;- RandomFromHessianOrMCMC(Hessian=result$hessian, 
                              fitted.parameters=result$par, 
                              method="Hessian")$random
hist(df[, 1], main="mean")
hist(df[, 2], main="sd")
plot(df[, 1], df[, 2], xlab="mean", ylab="sd", las=1, bty="n")

# Using MCMC
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
# Use of trace and traceML parameters
# trace=1 : Only one likelihood is printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
parameters_name = "par", 
likelihood=fitnorm, n.chains=1, n.adapt=100, thin=1, trace=1)
df &lt;- RandomFromHessianOrMCMC(mcmc=mcmc_run, fitted.parameters=NULL, 
                              method="MCMC")$random
hist(df[, 1], main="mean")
hist(df[, 2], main="sd")
plot(df[, 1], df[, 2], xlab="mean", ylab="sd", las=1, bty="n")

# Using a function fn
fitnorm &lt;- function(par, data, x) { 
  y=par["a"]*(x)+par["b"]
  -sum(dnorm(data, y, abs(par["sd"]), log = TRUE))
}
p&lt;-c(a=0.1, b=20, sd=5)
# fit the model
x &lt;- 1:100
result &lt;- optim(par=p, fn=fitnorm, data=val, x=x, method="BFGS", hessian=TRUE)
# Using Hessian
df &lt;- RandomFromHessianOrMCMC(Hessian=result$hessian, fitted.parameters=result$par, 
                              method="Hessian", 
                              fn=function(par) (par["a"]*(x)+par["b"]))
plot(1:100, val)
lines(1:100, df$quantiles["50%", ])
lines(1:100, df$quantiles["2.5%", ], lty=2)
lines(1:100, df$quantiles["97.5%", ], lty=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='rcutter'>Random values of unobserved values of cut distribution.</h2><span id='topic+rcutter'></span>

<h3>Description</h3>

<p>Return n random numbers.<br />
It can be used to get the posterior predictive distribution; see example.<br />
If random_method is &quot;ML&quot;, the parameter values obtained using maximum likelihood are used.<br />
If random_method is &quot;medianMCMC&quot;, the parameter values obtained using median of posterior distribution are used.<br />
If random_method is &quot;MCMC&quot;, the parameter values are one sample of the MCMC posterior distribution.<br />
if observed_detection_limit is set to TRUE, the number of random number is equal to the number of observations; n is not used.<br />
rcutter is the abbreviation for random-cutter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcutter(
  cutter = stop("A result of cutter() must be provided"),
  n = 1,
  lower_detection_limit = NULL,
  upper_detection_limit = NULL,
  method_cut = c("censored", "truncated"),
  observed_detection_limit = FALSE,
  random_method = c("medianMCMC", "MCMC", "ML"),
  index_mcmc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcutter_+3A_cutter">cutter</code></td>
<td>
<p>The fitted model obtained with cutter()</p>
</td></tr>
<tr><td><code id="rcutter_+3A_n">n</code></td>
<td>
<p>number of random numbers</p>
</td></tr>
<tr><td><code id="rcutter_+3A_lower_detection_limit">lower_detection_limit</code></td>
<td>
<p>The lower detection limit</p>
</td></tr>
<tr><td><code id="rcutter_+3A_upper_detection_limit">upper_detection_limit</code></td>
<td>
<p>The upper detection limit</p>
</td></tr>
<tr><td><code id="rcutter_+3A_method_cut">method_cut</code></td>
<td>
<p>What method is used to cut the distribution: &quot;censored&quot;, &quot;truncated&quot;?</p>
</td></tr>
<tr><td><code id="rcutter_+3A_observed_detection_limit">observed_detection_limit</code></td>
<td>
<p>If TRUE, will use the pattern of detection limit as in observations</p>
</td></tr>
<tr><td><code id="rcutter_+3A_random_method">random_method</code></td>
<td>
<p>How to get parameters; it can be &quot;ML&quot;, &quot;medianMCMC&quot;, or &quot;MCMC&quot;</p>
</td></tr>
<tr><td><code id="rcutter_+3A_index_mcmc">index_mcmc</code></td>
<td>
<p>For MCMC random_method, the index of data to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rcutter returns random values based on fitted distribution with cut.
</p>


<h3>Value</h3>

<p>A vector with the random numbers.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# _______________________________________________________________
# right censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 100
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&gt;DL] &lt;- +Inf
# search for the parameters the best fit these censored data
result &lt;- cutter(observations=obc, upper_detection_limit=DL, 
                           cut_method="censored")
result
# Posterior predictive distribution
r &lt;- rcutter(cutter=result, upper_detection_limit=DL, n=100)
hist(r)
# _______________________________________________________________
# left censored distribution with gamma distribution
# _______________________________________________________________
# Detection limit
DL &lt;- 10
# Generate 100 random data from a gamma distribution
obc &lt;- rgamma(100, scale=20, shape=2)
# remove the data below the detection limit
obc[obc&lt;DL] &lt;- -Inf
# search for the parameters the best fit these truncated data
result &lt;- cutter(observations=obc, lower_detection_limit=DL, 
                          cut_method="censored")
result
plot(result, breaks=seq(from=0, to=200, by=10))
r &lt;- rcutter(cutter=result, n=100)
hist(r, breaks=seq(from=0, to=200, by=10))
r &lt;- rcutter(cutter=result, lower_detection_limit=DL, n=100)
hist(r, breaks=seq(from=0, to=250, by=10))
# With censored method, some values are replaced with +Inf or -Inf
any(is.infinite(r))
r &lt;- rcutter(cutter=result, upper_detection_limit=DL, n=100, 
             method_cut="truncated")
# With truncated method, the values below LDL or upper UDL are not present
any(is.infinite(r))
hist(r, breaks=seq(from=0, to=10, by=0.25))
r &lt;- rcutter(cutter=result, observed_detection_limit=TRUE)
hist(r, breaks=seq(from=0, to=300, by=10))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_folder'>Read files present in a folder and creates a list with the content of these files</h2><span id='topic+read_folder'></span>

<h3>Description</h3>

<p>To create a list, the syntax is:<br />
datalist &lt;- read_folder(folder=&quot;.&quot;, read=read.delim, header=FALSE)<br />
It returns an error if the folder does not exist.<br />
The names of the elements of the list are the filenames.<br />
The parameter file can be used to predefine a list of file. If file is NULL, all the files of the folder/directory are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_folder(
  folder = try(file.choose(), silent = TRUE),
  file = NULL,
  wildcard = "*.*",
  read = read.delim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_folder_+3A_folder">folder</code></td>
<td>
<p>Where to search for files; can be or a file path or a folder path</p>
</td></tr>
<tr><td><code id="read_folder_+3A_file">file</code></td>
<td>
<p>list of files</p>
</td></tr>
<tr><td><code id="read_folder_+3A_wildcard">wildcard</code></td>
<td>
<p>Define which files are to be read (examples: &quot;<em>.</em>&quot;, &quot;<em>.xls&quot;, &quot;essai</em>.txt&quot;). It can be also a vector with all filenames.</p>
</td></tr>
<tr><td><code id="read_folder_+3A_read">read</code></td>
<td>
<p>Function used to read file. Ex: read.delim or read.xls from gdata package</p>
</td></tr>
<tr><td><code id="read_folder_+3A_...">...</code></td>
<td>
<p>Parameters send to the read function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>read_folder reads all files present in a folder
</p>


<h3>Value</h3>

<p>Return a list with the data in the files of the folder (directory for windows users)
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# Read all the .csv files from the current folder/directory
contentaslist &lt;- read_folder(folder=".", wildcard="*.csv", read=read.csv2)
# Read all the files from the current folder/directory
contentaslist &lt;- read_folder(folder=".", wildcard="*.*", read=read.csv2)
# Read two files from the current folder/directory
files &lt;- c("filename1.csv", "filename2.csv")
contentaslist &lt;- read_folder(folder=".", wildcard=files, read=read.csv2)

## End(Not run)
</code></pre>

<hr>
<h2 id='RectangleRegression'>Return parameters of rectangle regression</h2><span id='topic+RectangleRegression'></span>

<h3>Description</h3>

<p>Fit a line using least rectangle method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RectangleRegression(
  x1,
  x2,
  replicate = 1000,
  x1new = seq(from = min(x1), to = max(x1), length.out = 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RectangleRegression_+3A_x1">x1</code></td>
<td>
<p>The first series of data</p>
</td></tr>
<tr><td><code id="RectangleRegression_+3A_x2">x2</code></td>
<td>
<p>The second series of data</p>
</td></tr>
<tr><td><code id="RectangleRegression_+3A_replicate">replicate</code></td>
<td>
<p>Number of replicates for bootstrap</p>
</td></tr>
<tr><td><code id="RectangleRegression_+3A_x1new">x1new</code></td>
<td>
<p>Values for x1 to generate x2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RectangleRegression performs rectangle regression
</p>


<h3>Value</h3>

<p>A list with parameters of rectangle regression
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- runif(100, min=10, max=20)
x2 &lt;- runif(100, min=10, max=20)+x1

rectreg &lt;- RectangleRegression(x1, x2)

plot(x=x1, y=x2, bty="n", las=1, xlim=c(10, 20), ylim=c(20, 40))
abline(a=rectreg$par["Intercept"], b=rectreg$par["Slope"], lwd=2)
par(xpd=FALSE)
lines(rectreg$x2new["x1new", ], rectreg$x2new["50%", ])
lines(rectreg$x2new["x1new", ], rectreg$x2new["2.5%", ], lty=2)
lines(rectreg$x2new["x1new", ], rectreg$x2new["97.5%", ], lty=2)

abline(a=rectreg$Intercept[1], b=rectreg$Slope[3], col="red")
abline(a=rectreg$Intercept[3], b=rectreg$Slope[1], col="red")

</code></pre>

<hr>
<h2 id='RM_add'>Create a results managment or add a value in a results managment to an object</h2><span id='topic+RM_add'></span>

<h3>Description</h3>

<p>Return original object with a new value or a new results managment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RM_add(
  x = stop("An object with results managment must be provided"),
  RM = "RM",
  RMname = stop("A results managment name must be provided"),
  valuename = NULL,
  value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RM_add_+3A_x">x</code></td>
<td>
<p>The object to add a results managment or a result in a results managment</p>
</td></tr>
<tr><td><code id="RM_add_+3A_rm">RM</code></td>
<td>
<p>The name of results managment stored</p>
</td></tr>
<tr><td><code id="RM_add_+3A_rmname">RMname</code></td>
<td>
<p>The name of the results managment to be modified or created</p>
</td></tr>
<tr><td><code id="RM_add_+3A_valuename">valuename</code></td>
<td>
<p>The name of the new value to be added</p>
</td></tr>
<tr><td><code id="RM_add_+3A_value">value</code></td>
<td>
<p>The value to be added</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RM_add adds a results managment or a value in results managment to an object
</p>


<h3>Value</h3>

<p>The original object with a new value in a results managment object or a new results managment
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Results Managment: 
<code><a href="#topic+RM_delete">RM_delete</a>()</code>,
<code><a href="#topic+RM_duplicate">RM_duplicate</a>()</code>,
<code><a href="#topic+RM_get">RM_get</a>()</code>,
<code><a href="#topic+RM_list">RM_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Let an object of class objclass being created
obj &lt;- list(A=100, name="My object")
class(obj) &lt;- "objclass"
# And now I create a RM to this object
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V1", value=100)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V1", value=200)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V2", value=300)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V2")
RM_list(obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='RM_delete'>Delete a results managment or a result within a results managment from an object</h2><span id='topic+RM_delete'></span>

<h3>Description</h3>

<p>Return the original object with the deleted results managment or result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RM_delete(
  x = stop("An object with results managment must be provided"),
  RM = "RM",
  RMname = stop("A name must be provided"),
  valuename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RM_delete_+3A_x">x</code></td>
<td>
<p>The object to delete a results managment</p>
</td></tr>
<tr><td><code id="RM_delete_+3A_rm">RM</code></td>
<td>
<p>The name of results managment stored</p>
</td></tr>
<tr><td><code id="RM_delete_+3A_rmname">RMname</code></td>
<td>
<p>The name of the result that will be deleted or its rank</p>
</td></tr>
<tr><td><code id="RM_delete_+3A_valuename">valuename</code></td>
<td>
<p>The name of the result that will be deleted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RM_delete deletes a results managment or a result within a results managment from an object
</p>


<h3>Value</h3>

<p>The original object with the deleted results managment
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Results Managment: 
<code><a href="#topic+RM_add">RM_add</a>()</code>,
<code><a href="#topic+RM_duplicate">RM_duplicate</a>()</code>,
<code><a href="#topic+RM_get">RM_get</a>()</code>,
<code><a href="#topic+RM_list">RM_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Let an object of class objclass being created
obj &lt;- list(A=100, name="My object")
class(obj) &lt;- "objclass"
# And now I create a RM to this object
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2")
RM_list(obj)
obj &lt;- RM_delete(x=obj, RMname="NewAnalysis1")
RM_list(obj)
obj &lt;- RM_delete(x=obj, RMname=1)
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1", valuename="V1", value=100)
RM_list(obj)
RM_get(x=obj, RMname="NewAnalysis1", valuename="V1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1", valuename="V2", value=200)
RM_get(x=obj, RMname="NewAnalysis1", valuename="V2")
obj &lt;- RM_delete(x=obj, RMname="NewAnalysis1", valuename="V1")
RM_get(x=obj, RMname="NewAnalysis1", valuename="V1")
RM_get(x=obj, RMname="NewAnalysis1", valuename="V2")

## End(Not run)
</code></pre>

<hr>
<h2 id='RM_duplicate'>Duplicate a results managment within an object.</h2><span id='topic+RM_duplicate'></span>

<h3>Description</h3>

<p>RM_duplicate duplicates a results managment within an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RM_duplicate(
  x = stop("An object with results managment must be provided"),
  RM = "RM",
  RMnamefrom = 1,
  RMnameto = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RM_duplicate_+3A_x">x</code></td>
<td>
<p>The object to duplicate a results managment</p>
</td></tr>
<tr><td><code id="RM_duplicate_+3A_rm">RM</code></td>
<td>
<p>The name of results managment stored</p>
</td></tr>
<tr><td><code id="RM_duplicate_+3A_rmnamefrom">RMnamefrom</code></td>
<td>
<p>The name of the results managment to be duplicated</p>
</td></tr>
<tr><td><code id="RM_duplicate_+3A_rmnameto">RMnameto</code></td>
<td>
<p>The new name of the results managment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RM_duplicate duplicates a results managment within an object
</p>


<h3>Value</h3>

<p>The original object with a duplicated results managment.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Results Managment: 
<code><a href="#topic+RM_add">RM_add</a>()</code>,
<code><a href="#topic+RM_delete">RM_delete</a>()</code>,
<code><a href="#topic+RM_get">RM_get</a>()</code>,
<code><a href="#topic+RM_list">RM_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Let an object of class objclass being created
obj &lt;- list(A=100, name="My object")
class(obj) &lt;- "objclass"
# And now I create a RM to this object
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1")
RM_list(obj)
obj &lt;- RM_duplicate(x=obj, RMnamefrom="NewAnalysis1", RMnameto="NewAnalysis2")
RM_list(obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='RM_get'>Get a value in a results managment to an object</h2><span id='topic+RM_get'></span>

<h3>Description</h3>

<p>Return the value valuename of the results managment RMname.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RM_get(
  x = stop("An object with results managment must be provided"),
  RM = "RM",
  RMname = stop("A results managment name must be provided"),
  valuename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RM_get_+3A_x">x</code></td>
<td>
<p>The object in which to get a result in a results managment</p>
</td></tr>
<tr><td><code id="RM_get_+3A_rm">RM</code></td>
<td>
<p>The name of results managment stored</p>
</td></tr>
<tr><td><code id="RM_get_+3A_rmname">RMname</code></td>
<td>
<p>The name of the results managment to be read</p>
</td></tr>
<tr><td><code id="RM_get_+3A_valuename">valuename</code></td>
<td>
<p>The name of the value to be read</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RM_get gets a value in results managment to an object
</p>


<h3>Value</h3>

<p>Return a value in a results managment object
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Results Managment: 
<code><a href="#topic+RM_add">RM_add</a>()</code>,
<code><a href="#topic+RM_delete">RM_delete</a>()</code>,
<code><a href="#topic+RM_duplicate">RM_duplicate</a>()</code>,
<code><a href="#topic+RM_list">RM_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Let an object of class objclass being created
obj &lt;- list(A=100, name="My object")
class(obj) &lt;- "objclass"
# And now I create a RM to this object
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V1", value=100)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V1")

## End(Not run)
</code></pre>

<hr>
<h2 id='RM_list'>Return the list of results managment of an object.</h2><span id='topic+RM_list'></span>

<h3>Description</h3>

<p>RM_list returns the list of results managment of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RM_list(
  x = stop("An object with results managment must be provided"),
  RM = "RM",
  silent = FALSE,
  max.level = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RM_list_+3A_x">x</code></td>
<td>
<p>The object to add a results managment</p>
</td></tr>
<tr><td><code id="RM_list_+3A_rm">RM</code></td>
<td>
<p>The name of results managment stored</p>
</td></tr>
<tr><td><code id="RM_list_+3A_silent">silent</code></td>
<td>
<p>Should the results be shown ?</p>
</td></tr>
<tr><td><code id="RM_list_+3A_max.level">max.level</code></td>
<td>
<p>If TRUE, will return all list element of the objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RM_list returns the list of results managment of an object
</p>


<h3>Value</h3>

<p>A list with the names of results stored in an object
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Results Managment: 
<code><a href="#topic+RM_add">RM_add</a>()</code>,
<code><a href="#topic+RM_delete">RM_delete</a>()</code>,
<code><a href="#topic+RM_duplicate">RM_duplicate</a>()</code>,
<code><a href="#topic+RM_get">RM_get</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
# Let an object of class objclass being created
obj &lt;- list(A=100, name="My object")
class(obj) &lt;- "objclass"
# And now I create a RM to this object
obj &lt;- RM_add(x=obj, RMname="NewAnalysis1")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2")
RM_list(obj)
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V1", value=100)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V1", value=200)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V1")
obj &lt;- RM_add(x=obj, RMname="NewAnalysis2", valuename="V2", value=300)
RM_get(x=obj, RMname="NewAnalysis2", valuename="V2")
RM_list(obj)
rmlist &lt;- RM_list(obj, max.level=TRUE)
rmlist

## End(Not run)
</code></pre>

<hr>
<h2 id='rmnorm'>Generate random numbers from the multivariate normal distribution</h2><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p>rmnorm generate random numbers from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm(n = 1, mean = rep(0, d), varcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_+3A_n">n</code></td>
<td>
<p>the number of random vectors to be generated.</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_mean">mean</code></td>
<td>
<p>a vector with means of length d.</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_varcov">varcov</code></td>
<td>
<p>a variance-covariance matrix with dimentions d * d.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rmnorm Generate random numbers from the multivariate normal distribution
</p>


<h3>Value</h3>

<p>For n &gt; 1 rmnorm returns a matrix of n rows of random vectors, while for n = 1 rmnorm returns a named random vector.
</p>


<h3>Author(s)</h3>

<p>Based on lmf package
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rnbinom_new">rnbinom_new</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Variance-covariance matrix
varcov &lt;- matrix(c(2.047737e-03, 3.540039e-05, 0.0075178920, 3.540039e-05,
6.122832e-07, 0.0001299661, 7.517892e-03, 1.299661e-04, 0.0276005740), ncol = 3)
#Set names
nam &lt;- c("a", "b", "c")
dimnames(varcov) &lt;- list(nam, nam)
#Check positive definiteness (all positive eigenvalues = positive definite)
eigen(varcov) $values
#Mean
mean &lt;- c(1, 0.3, 0.5)
#Generate n = 1 random vector
rmnorm(n = 1, mean = mean, varcov = varcov)
#Generate n = 10 random vectors
rmnorm(n = 10, mean = mean, varcov = varcov)
#Generate n = 1 random vectors when varcov is non-positive definite
#Non-positive definite varcov matrix
varcov2 &lt;- matrix(c(2.04e-03, 3.54e-05, 7.52e-03, 3.54e-05, 6.15e-07,
  1.30e-04, 7.52e-03, 1.30e-04, 2.76e-02), ncol = 3)
  dimnames(varcov2) &lt;- dimnames(varcov)
eigen(varcov2)
#Random vector
rmnorm(n = 1, mean = mean, varcov = varcov2)

## End(Not run)
</code></pre>

<hr>
<h2 id='rnbinom_new'>Random numbers for the negative binomial distribution.</h2><span id='topic+rnbinom_new'></span>

<h3>Description</h3>

<p>See <code>rnbinom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnbinom_new(n, size = NULL, prob = NULL, mu = NULL, sd = NULL, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnbinom_new_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rnbinom_new_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion parameter (the shape parameter of the gamma mixing distribution). Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="rnbinom_new_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. 0 &lt; prob &lt;= 1.</p>
</td></tr>
<tr><td><code id="rnbinom_new_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean.</p>
</td></tr>
<tr><td><code id="rnbinom_new_+3A_sd">sd</code></td>
<td>
<p>alternative parametrization via standard deviation.</p>
</td></tr>
<tr><td><code id="rnbinom_new_+3A_var">var</code></td>
<td>
<p>alternative parametrization via variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rnbinom_new returns random numbers for the negative binomial distribution
</p>


<h3>Value</h3>

<p>Random numbers for the negative binomial distribution
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Distributions: 
<code><a href="#topic+cutter">cutter</a>()</code>,
<code><a href="#topic+dSnbinom">dSnbinom</a>()</code>,
<code><a href="#topic+dbeta_new">dbeta_new</a>()</code>,
<code><a href="#topic+dcutter">dcutter</a>()</code>,
<code><a href="#topic+dggamma">dggamma</a>()</code>,
<code><a href="#topic+logLik.cutter">logLik.cutter</a>()</code>,
<code><a href="#topic+plot.cutter">plot.cutter</a>()</code>,
<code><a href="#topic+print.cutter">print.cutter</a>()</code>,
<code><a href="#topic+r2norm">r2norm</a>()</code>,
<code><a href="#topic+rcutter">rcutter</a>()</code>,
<code><a href="#topic+rmnorm">rmnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
set.seed(1)
x &lt;- rnbinom_new(n=1000, prob=6.25/(5+6.25), size=6.25)
mean(x)
sd(x)
set.seed(1)
x &lt;- rnbinom_new(n=1000, mu=5, sd=3)
mean(x)
sd(x)
set.seed(1)
x &lt;- rnbinom_new(n=1000, mu=5, var=3^2)
mean(x)
sd(x)
set.seed(1)
x &lt;- rnbinom_new(n=1000, mu=5, size=6.25)
mean(x)
sd(x)
set.seed(1)
x &lt;- rnbinom_new(n=1000, size=6.25, var=3^2)
mean(x)
sd(x)
set.seed(1)
x &lt;- rnbinom_new(n=1000, prob=6.25/(5+6.25), var=3^2)
mean(x)
sd(x)
# Example of wrong parametrization
set.seed(1)
x &lt;- rnbinom_new(n=1000, sd=3, var=3^2)
set.seed(1)
x &lt;- rnbinom_new(n=1000, mu=10, var=3^2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ScalePreviousPlot'>Return the scale of the previous plot</h2><span id='topic+ScalePreviousPlot'></span>

<h3>Description</h3>

<p>Return a list with the limits of the previous plot, the center, the range, and the position of label on this axe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScalePreviousPlot(x = NULL, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalePreviousPlot_+3A_x">x</code></td>
<td>
<p>The position in x as relative position</p>
</td></tr>
<tr><td><code id="ScalePreviousPlot_+3A_y">y</code></td>
<td>
<p>The position in y as relative position</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ScalePreviousPlot returns the scale of the previous plot
</p>


<h3>Value</h3>

<p>A list with xlim and ylim
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other plot and barplot functions: 
<code><a href="#topic+barplot_errbar">barplot_errbar</a>()</code>,
<code><a href="#topic+plot_add">plot_add</a>()</code>,
<code><a href="#topic+plot_errbar">plot_errbar</a>()</code>,
<code><a href="#topic+show_name">show_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(xaxs="i", yaxs="i")
plot(x=1:100, y=sin(1:100), type="l", bty="n", xlim=c(1,200), xlab="x", ylab="y")
xlim= ScalePreviousPlot()$xlim[1:2]
ylim= ScalePreviousPlot()$ylim[1:2]
par(xaxs="r", yaxs="i")
plot(x=1:100, y=sin(1:100), type="l", bty="n", xlim=c(1,200), xlab="x", ylab="y")
xlim= ScalePreviousPlot()$xlim[1:2]
ylim= ScalePreviousPlot()$ylim[1:2]
# Here is an example of the use of the label output
plot(x=1:100, y=sin(1:100), type="l", bty="n", xlim=c(1,200), xlab="", ylab="")
text(x=ScalePreviousPlot()$xlim["label"], y=ScalePreviousPlot()$ylim["center"], 
  xpd=TRUE, "Legend for Y axes", pos=3, srt=90)
text(x=ScalePreviousPlot()$xlim["center"], y=ScalePreviousPlot()$ylim["label"], 
  xpd=TRUE, "Legend for X axes", pos=1)
Example to plot legend always in the same place
layout(1:2)
plot(x=1:100, y=sin(1:100), type="l", bty="n", xlim=c(1,200), xlab="", ylab="")
text(x=ScalePreviousPlot(x=0.95, y=0.05)$x, 
     y=ScalePreviousPlot(x=0.95, y=0.05)$y, 
     labels="A", cex=2)
plot(x=0:1, y=0:1, type="p", bty="n")
text(x=ScalePreviousPlot(x=0.95, y=0.05)$x, 
     y=ScalePreviousPlot(x=0.95, y=0.05)$y, 
     labels="B", cex=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='SEfromHessian'>Standard error of parameters based on Hessian matrix</h2><span id='topic+SEfromHessian'></span>

<h3>Description</h3>

<p>Standard error of parameters based on Hessian matrix.<br />
The strategy is as follow:<br />
First it tries to inverse the Hessian matrix. If it fails, it uses the near
positive definite matrix of the Hessian.<br />
So now the inverse of the Hessian matrix can be computed.<br />
The diagonal of the inverse of the Hessian matrix is calculated. If all values are positive,
the SEs are the square root of the inverse of the Hessian.<br />
If not all values are positive, it will estimate the pseudo-variance
matrix based on Gill &amp; King (2004). It necessitates a Cholesky matrix.<br />
If from some reason it fails (for example all SE are 0 in output), then the strategy of
Rebonato and Jackel (2000) will be used to generate the Cholesky matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEfromHessian(a, hessian = FALSE, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEfromHessian_+3A_a">a</code></td>
<td>
<p>An Hessian matrix</p>
</td></tr>
<tr><td><code id="SEfromHessian_+3A_hessian">hessian</code></td>
<td>
<p>If TRUE, return a list with the hessian and SE</p>
</td></tr>
<tr><td><code id="SEfromHessian_+3A_silent">silent</code></td>
<td>
<p>If TRUE, report some problems</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SEfromHessian returns standard error of parameters based on Hessian matrix
</p>


<h3>Value</h3>

<p>SEfromHessian returns a vector with standard errors
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Gill J. and G. King 2004. What to do when your Hessian is not invertible:
Alternatives to model respecification in nonlinear estimation. Sociological Methods
&amp; Research 33: 54-87.
</p>
<p>Rebonato and Jackel, “The most general methodology for creating a valid
correlation matrix for risk management and option pricing purposes”, Journal of Risk,
Vol 2, No 2, 2000.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
val=rnorm(100, mean=20, sd=5)
# Return -ln L of values in val in Gaussian distribution with mean and sd in par
fitnorm&lt;-function(par, val) {
  -sum(dnorm(val, par["mean"], par["sd"], log = TRUE))
}
# Initial values for search
p&lt;-c(mean=20, sd=5)
# fit the model
result &lt;- optim(par=p, fn=fitnorm, val=val, method="BFGS", hessian=TRUE)
SE &lt;- SEfromHessian(result$hessian)
library(MASS)
fitdistr(val, densfun = "normal")

## End(Not run)
</code></pre>

<hr>
<h2 id='series.compare'>Data series comparison using Akaike weight</h2><span id='topic+series.compare'></span>

<h3>Description</h3>

<p>This function is used as a replacement of t.test() to not use p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series.compare(..., criterion = c("BIC", "AIC", "AICc"), var.equal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series.compare_+3A_...">...</code></td>
<td>
<p>Series of data (at least two or data are in a table with series in different rows)</p>
</td></tr>
<tr><td><code id="series.compare_+3A_criterion">criterion</code></td>
<td>
<p>Which criterion is used for model selection. can be AIC, AICc or BIC</p>
</td></tr>
<tr><td><code id="series.compare_+3A_var.equal">var.equal</code></td>
<td>
<p>Should the variances of all series being equal? Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>series.compare compares series of data using Akaike weight.
</p>


<h3>Value</h3>

<p>The probability that a single proportion model is sufficient to explain the data
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Girondot, M., Guillon, J.-M., 2018. The w-value: An alternative to t- and X2 tests. Journal of Biostatistics &amp; Biometrics 1, 1-4.
</p>


<h3>See Also</h3>

<p>Other w-value functions: 
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+contingencyTable.compare">contingencyTable.compare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
A &lt;- rnorm(100, 10, 2)
B &lt;- rnorm(100, 11.1, 2)
series.compare(A, B, criterion = "BIC", var.equal=TRUE)
B &lt;- B[1:10]
series.compare(A, B, criterion = "BIC", var.equal=TRUE)
A &lt;- rnorm(100, 10, 2)
B &lt;- rnorm(100, 10.1, 2)
C &lt;- rnorm(100, 10.5, 2)
series.compare(A, B, C, criterion = "BIC", var.equal=TRUE)
B &lt;- B[1:10]
series.compare(A, B, criterion = "BIC", var.equal=TRUE)
t.test(A, B, var.equal=TRUE)
# Example with a data.frame
series.compare(t(data.frame(A=c(10, 27, 19, 20, NA), B=c(10, 20, NA, NA, NA))))
# Test in the context of big data
A &lt;- rnorm(10000, 10, 2)
B &lt;- rnorm(10000, 10.1, 2)
series.compare(A, B, criterion = "BIC", var.equal=TRUE)
t.test(A, B, var.equal=TRUE)
###########################
w &lt;- NULL
p &lt;- NULL

for (i in 1:1000) {
  
  A &lt;- rnorm(50000, 10, 2)
  B &lt;- rnorm(50000, 10.01, 2)
  w &lt;- c(w, unname(series.compare(A, B, criterion = "BIC", var.equal=TRUE)[1]))
  p &lt;- c(p, t.test(A, B, var.equal=TRUE)$p.value)

}

layout(mat = 1:2)
par(mar=c(4, 4, 1, 1)+0.4)
hist(p, main="", xlim=c(0, 1), las=1, breaks = (0:20)/20, 
     freq=FALSE, xlab = expression(italic("p")*"-value"))
hist(w, main="", xlim=c(0, 1), las=1, breaks = (0:20)/20, 
    freq=FALSE, xlab = expression(italic("w")*"-value"))
###########################

x &lt;- seq(from=8, to=13, by=0.1)

pv &lt;- NULL
aw &lt;- NULL
A &lt;- rnorm(100, mean=10, sd=2)
B &lt;- A-2

for (meanB in x) {
  pv &lt;- c(pv, t.test(A, B, var.equal = FALSE)$p.value)
  aw &lt;- c(aw, series.compare(A, B, criterion="BIC", var.equal = FALSE)[1])
  B &lt;- B + 0.1
}

par(mar=c(4, 4, 2, 1)+0.4)
y &lt;- pv
plot(x=x, y=y, type="l", lwd=2,
     bty="n", las=1, xlab="Mean B value (SD = 4)", ylab="Probability", ylim=c(0,1), 
     main="")
y2 &lt;- aw
lines(x=x, y=y2, type="l", col="red", lwd=2)

l1 &lt;- which(aw&gt;0.05)[1]
l2 &lt;- max(which(aw&gt;0.05))

aw[l1]
pv[l1]

aw[l2]
pv[l2]

l1 &lt;- which(pv&gt;0.05)[1]
l2 &lt;- max(which(pv&gt;0.05))

aw[l1]
pv[l1]

aw[l2]
pv[l2]

par(xpd=TRUE)
segments(x0=10-1.96*2/10, x1=10+1.96*2/10, y0=1.1, y1=1.1, lwd=2)
segments(x0=10, x1=10, y0=1.15, y1=1.05, lwd=2)
par(xpd=TRUE)
text(x=10.5, y=1.1, labels = "Mean A = 10, SD = 2", pos=4)

v1 &lt;- c(expression(italic("p")*"-value"), expression("based on "*italic("t")*"-test"))
v2 &lt;- c(expression(italic("w")*"-value for A"), expression("and B identical models"))
legend("topright", legend=c(v1, v2), 
       y.intersp = 1, 
       col=c("black", "black", "red", "red"), bty="n", lty=c(1, 0, 1, 0))

segments(x0=min(x), x1=max(x), y0=0.05, y1=0.05, lty=2)
par(xpd = TRUE)
text(x=13.05, y=0.05, labels = "0.05", pos=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='setPriors'>Set priors for MHalgoGen()</h2><span id='topic+setPriors'></span>

<h3>Description</h3>

<p>Set priors for MHalgoGen()<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPriors(
  par = stop("A vector with init values is necessary."),
  se = NULL,
  density = "dunif",
  rules = NULL,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPriors_+3A_par">par</code></td>
<td>
<p>Named vector with init value of parameters</p>
</td></tr>
<tr><td><code id="setPriors_+3A_se">se</code></td>
<td>
<p>Named vector with standard error of parameters</p>
</td></tr>
<tr><td><code id="setPriors_+3A_density">density</code></td>
<td>
<p>Named vector with density or single value</p>
</td></tr>
<tr><td><code id="setPriors_+3A_rules">rules</code></td>
<td>
<p>List of rules to define priors</p>
</td></tr>
<tr><td><code id="setPriors_+3A_silent">silent</code></td>
<td>
<p>If TRUE, do not show warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setPriors is a general function to set priors for MHalgoGen()
</p>


<h3>Value</h3>

<p>Return a data.frame with priors
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+summary.mcmcComposite">summary.mcmcComposite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
rules &lt;- rbind(data.frame(Name="^a", Min=0, Max="x*2"), 
              data.frame(Name="^b", Min=0, Max=100))
par &lt;- c(a0=10, a1=2, b2=20)
(p &lt;- setPriors(par=par, se=NULL, density="dgamma", rules=rules))
(p &lt;- setPriors(par=par, se=NULL, density="dnorm", rules=rules))
(p &lt;- setPriors(par=par, se=NULL, density="dunif", rules=rules))
par &lt;- c(a0=10, a1=2, b2=20, b1=-1)
(p &lt;- setPriors(par=par, se=NULL, density="dgamma", rules=rules))

## End(Not run)
</code></pre>

<hr>
<h2 id='show_name'>Show the name of a point</h2><span id='topic+show_name'></span>

<h3>Description</h3>

<p>Click on a point in plot region and it will tell you what is the point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_name(
  points = NULL,
  x = NULL,
  y = NULL,
  names = NULL,
  col = "red",
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_name_+3A_points">points</code></td>
<td>
<p>A list with x, y and names elements</p>
</td></tr>
<tr><td><code id="show_name_+3A_x">x</code></td>
<td>
<p>The x coordinates</p>
</td></tr>
<tr><td><code id="show_name_+3A_y">y</code></td>
<td>
<p>The y coordinates.</p>
</td></tr>
<tr><td><code id="show_name_+3A_names">names</code></td>
<td>
<p>The names of the points</p>
</td></tr>
<tr><td><code id="show_name_+3A_col">col</code></td>
<td>
<p>Color of the legend.</p>
</td></tr>
<tr><td><code id="show_name_+3A_silent">silent</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Show the name of a point
</p>


<h3>Value</h3>

<p>Name of the point
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>plot_errorbar</code>
</p>
<p>Other plot and barplot functions: 
<code><a href="#topic+ScalePreviousPlot">ScalePreviousPlot</a>()</code>,
<code><a href="#topic+barplot_errbar">barplot_errbar</a>()</code>,
<code><a href="#topic+plot_add">plot_add</a>()</code>,
<code><a href="#topic+plot_errbar">plot_errbar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
k &lt;- plot_errbar(1:100, rnorm(100, 1, 2), 
	xlab="axe x", ylab="axe y", bty="n", xlim=c(1,100), 
		errbar.x=2, errbar.y=rnorm(100, 1, 0.1))
show_name(k)
k &lt;- plot_errbar(1:10, rnorm(10, 1, 2), 
	xlab="axe x", ylab="axe y", bty="n", xlim=c(1,10), 
		errbar.x=2, errbar.y=rnorm(10, 1, 0.1), 
		names=LETTERS[1:10])
show_name(k)
k &lt;- plot_errbar(1:10, rnorm(10, 1, 2), 
	xlab="axe x", ylab="axe y", bty="n", xlim=c(1,10), 
		errbar.x=2, errbar.y=rnorm(10, 1, 0.1))
show_name(k, names=LETTERS[1:10])
		
## End(Not run)
</code></pre>

<hr>
<h2 id='similar'>Test if two vectors contains the same elements independently of their order</h2><span id='topic+similar'></span>

<h3>Description</h3>

<p>Return TRUE only if all elements of x are present and only once in y.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similar(x, y, test.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similar_+3A_x">x</code></td>
<td>
<p>A vector with numeric or character elements</p>
</td></tr>
<tr><td><code id="similar_+3A_y">y</code></td>
<td>
<p>A vector with numeric or character elements</p>
</td></tr>
<tr><td><code id="similar_+3A_test.names">test.names</code></td>
<td>
<p>Logical. If TRUE, the names of the vector elements must be also identical and unique</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
A &lt;- c("A", "B", "C", "D")
B &lt;- c("A", "B", "C", "D")
similar(A, B)
similar(B, A)
A &lt;- c(x="A", y="B", z="C", k="D")
B &lt;- c(x="A", y="B", z="C", l="D")
similar(B, A)
similar(A, B, test.names=TRUE)
A &lt;- c(x="A", y="B", z="C", k="D")
B &lt;- c(x="A", z="C", k="D", y="B")
similar(B, A)
similar(A, B, test.names=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='specify_decimal'>Return a number as character with specified number of decimals</h2><span id='topic+specify_decimal'></span>

<h3>Description</h3>

<p>Return a number as character with specified number of decimals.
If a is a matrix, it will return a matrix of the same size and the same attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_decimal(x, decimals = NULL, decimal.point = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specify_decimal_+3A_x">x</code></td>
<td>
<p>The numbers to be formated</p>
</td></tr>
<tr><td><code id="specify_decimal_+3A_decimals">decimals</code></td>
<td>
<p>Number of decimals to print</p>
</td></tr>
<tr><td><code id="specify_decimal_+3A_decimal.point">decimal.point</code></td>
<td>
<p>Character to be used as decimal point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>specify_decimals format a number with specified number of decimals
</p>


<h3>Value</h3>

<p>A character
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>specify_decimal(x=pi, decimal.point=".")
specify_decimal(x=pi, decimals=4, decimal.point=".")
specify_decimal(x=c(pi, exp(1)), decimals=3, decimal.point=",")
specify_decimal(x=c(pi, exp(1)), decimal.point=",")
specify_decimal(x=c(pi*10, pi, pi/10, pi/100, pi/1000))
specify_decimal(x=c(pi=pi), decimal.point=".")
specify_decimal(x=matrix(pi*1:4, ncol=2), decimal.point=".")
m &lt;- matrix(pi*1:4, ncol=2)
rownames(m) &lt;- c("A", "B")
colnames(m) &lt;- c("C", "D")
specify_decimal(x=m, decimal.point=".")
</code></pre>

<hr>
<h2 id='summary.mcmcComposite'>Summarize the result of a mcmcComposite object</h2><span id='topic+summary.mcmcComposite'></span>

<h3>Description</h3>

<p>Summary for the result of a mcmcComposite object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcComposite'
summary(object, chain = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcmcComposite_+3A_object">object</code></td>
<td>
<p>A mcmcComposite object</p>
</td></tr>
<tr><td><code id="summary.mcmcComposite_+3A_chain">chain</code></td>
<td>
<p>The chain to use</p>
</td></tr>
<tr><td><code id="summary.mcmcComposite_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>summary.mcmcComposite get info on the result of a mcmcComposite object
</p>


<h3>Value</h3>

<p>A summary of the result
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code><a href="#topic+MHalgoGen">MHalgoGen</a>()</code>,
<code><a href="#topic+as.mcmc.mcmcComposite">as.mcmc.mcmcComposite</a>()</code>,
<code><a href="#topic+as.parameters">as.parameters</a>()</code>,
<code><a href="#topic+as.quantiles">as.quantiles</a>()</code>,
<code><a href="#topic+merge.mcmcComposite">merge.mcmcComposite</a>()</code>,
<code><a href="#topic+plot.PriorsmcmcComposite">plot.PriorsmcmcComposite</a>()</code>,
<code><a href="#topic+plot.mcmcComposite">plot.mcmcComposite</a>()</code>,
<code><a href="#topic+setPriors">setPriors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='sun.info'>Estimate the time of sunrise and sunset according to longitude, latitude and date</h2><span id='topic+sun.info'></span>

<h3>Description</h3>

<p>Estimate the sun fates according to latitude and date.<br />
Can be compared with the function <code>sunrise.set()</code> of package <code>StreamMetabolism</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun.info(date, latitude, longitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sun.info_+3A_date">date</code></td>
<td>
<p>A vector with the time at which sun fates are needed</p>
</td></tr>
<tr><td><code id="sun.info_+3A_latitude">latitude</code></td>
<td>
<p>The latitude at which estimate the sun fates</p>
</td></tr>
<tr><td><code id="sun.info_+3A_longitude">longitude</code></td>
<td>
<p>The longitude at which estimate the sun fates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sun.info estimate the time of sunrise and sunset according to longitude, latitude and date
</p>


<h3>Value</h3>

<p>A data.frame with information about daily sun
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>References</h3>

<p>Teets, D.A. 2003. Predicting sunrise and sunset times. The College Mathematics Journal 34(4):317-321.
</p>


<h3>See Also</h3>

<p>Other Periodic patterns of indices: 
<code><a href="#topic+index.periodic">index.periodic</a>()</code>,
<code><a href="#topic+minmax.periodic">minmax.periodic</a>()</code>,
<code><a href="#topic+moon.info">moon.info</a>()</code>,
<code><a href="#topic+tide.info">tide.info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a timeserie of time
date &lt;- seq(from=as.Date("2000-01-01"), to=as.Date("2000-12-31"), by="1 day")
plot(date, sun.info(date, latitude=23, longitude=0)$day.length, bty="n", 
 las=1, type="l", xlab="Ordinal days", ylab="Day length in hours")
plot(date, sun.info(date, latitude=23, longitude=0)$sunrise, bty="n", 
 las=1, type="l", xlab="Ordinal days", ylab="Sun rise in hours")

## End(Not run)
</code></pre>

<hr>
<h2 id='symbol.Female'>Plot a female symbol in the plotting region</h2><span id='topic+symbol.Female'></span>

<h3>Description</h3>

<p>Plot a female symbol in the plotting region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbol.Female(centerx, centery, rayonx, lwd = 2, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbol.Female_+3A_centerx">centerx</code></td>
<td>
<p>The x position of the center of the circle</p>
</td></tr>
<tr><td><code id="symbol.Female_+3A_centery">centery</code></td>
<td>
<p>The y position of the center of the circle</p>
</td></tr>
<tr><td><code id="symbol.Female_+3A_rayonx">rayonx</code></td>
<td>
<p>The size of the rayon in the scale of the x axis</p>
</td></tr>
<tr><td><code id="symbol.Female_+3A_lwd">lwd</code></td>
<td>
<p>The width of the line of the symbol</p>
</td></tr>
<tr><td><code id="symbol.Female_+3A_col">col</code></td>
<td>
<p>The color of the symbol</p>
</td></tr>
</table>


<h3>Details</h3>

<p>symbol.Female plot a female symbol in the plotting region
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Symbol: 
<code><a href="#topic+symbol.Male">symbol.Male</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(x=1:2, y=c(10,20), type="n", bty="n", xlab="", ylab="")

rayonx &lt;- 0.01
centerx &lt;- 1.2
centery &lt;- 15

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx)
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx)

rayonx &lt;- 0.03
centerx &lt;- 1.2
centery &lt;- 18

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx, lwd=3)
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx, lwd=3, col="red")

rayonx &lt;- 0.05
centerx &lt;- 1.4
centery &lt;- 13

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx, lwd=4, col="blue")
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx, lwd=4, col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='symbol.Male'>Plot a male symbol in the plotting region</h2><span id='topic+symbol.Male'></span>

<h3>Description</h3>

<p>Plot a male symbol in the plotting region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbol.Male(centerx, centery, rayonx, lwd = 2, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbol.Male_+3A_centerx">centerx</code></td>
<td>
<p>The x position of the center of the circle</p>
</td></tr>
<tr><td><code id="symbol.Male_+3A_centery">centery</code></td>
<td>
<p>The y position of the center of the circle</p>
</td></tr>
<tr><td><code id="symbol.Male_+3A_rayonx">rayonx</code></td>
<td>
<p>The size of the rayon in the scale of the x axis</p>
</td></tr>
<tr><td><code id="symbol.Male_+3A_lwd">lwd</code></td>
<td>
<p>The width of the line of the symbol</p>
</td></tr>
<tr><td><code id="symbol.Male_+3A_col">col</code></td>
<td>
<p>The color of the symbol</p>
</td></tr>
</table>


<h3>Details</h3>

<p>symbol.Male plot a male symbol in the plotting region
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Symbol: 
<code><a href="#topic+symbol.Female">symbol.Female</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(x=1:2, y=c(10,20), type="n", bty="n", xlab="", ylab="")

rayonx &lt;- 0.01
centerx &lt;- 1.2
centery &lt;- 15

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx)
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx)

rayonx &lt;- 0.03
centerx &lt;- 1.2
centery &lt;- 18

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx, lwd=3)
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx, lwd=3, col="red")

rayonx &lt;- 0.05
centerx &lt;- 1.4
centery &lt;- 13

symbol.Male(centerx=centerx, centery = centery, rayonx=rayonx, lwd=4, col="blue")
symbol.Female(centerx=centerx+0.5, centery = centery, rayonx=rayonx, lwd=4, col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='symmetricize'>Make a matrix symmetric</h2><span id='topic+symmetricize'></span>

<h3>Description</h3>

<p>This function was part of the package ENA. This package is no more available
and it cannot be installed from archive because some dependencies are no more
available.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetricize(
  matrix,
  method = c("max", "min", "avg", "ld", "ud"),
  adjacencyList = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetricize_+3A_matrix">matrix</code></td>
<td>
<p>The matrix to make symmetric</p>
</td></tr>
<tr><td><code id="symmetricize_+3A_method">method</code></td>
<td>
<p>The method to use to make the matrix symmetric. Default is to take the maximum.
</p>

<dl>
<dt>&quot;max&quot;</dt><dd><p>For each position, <code class="reqn">m_{i,j}</code>, use the maxiumum of <code class="reqn">(m_{i,j}, m_{j,i})</code></p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>For each position, <code class="reqn">m_{i,j}</code>, use the minimum of <code class="reqn">(m_{i,j}, m_{j,i})</code></p>
</dd>
<dt>&quot;avg&quot;</dt><dd><p>For each position, <code class="reqn">m_{i,j}</code>, use the mean: <code class="reqn">(m_{i,j} + m_{j,i})/2</code></p>
</dd>
<dt>&quot;ld&quot;</dt><dd><p>Copy the lower triangular portion of the matrix to the upper triangular portion.</p>
</dd>
<dt>&quot;ud&quot;</dt><dd><p>Copy the upper triangular portion of the matrix to the lower triangular portion.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="symmetricize_+3A_adjacencylist">adjacencyList</code></td>
<td>
<p>Logical. If false, returns the symmetric matrix (the same format as the input). If true, returns an adjacency list representing the upper triangular portion of the adjacency matrix with addressing based on the row.names of the matrix provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make the matrix symmetric by making all &quot;mirrored&quot; positions consistent. A variety of methods are provided to make the matrix symmetrical.
</p>


<h3>Value</h3>

<p>The symmetric matrix
</p>


<h3>Author(s)</h3>

<p>Jeffrey D. Allen <a href="mailto:Jeffrey.Allen@UTSouthwestern.edu">Jeffrey.Allen@UTSouthwestern.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a sample 3x3 matrix
mat &lt;- matrix(1:9, ncol=3)

#Copy the upper diagonal portion to the lower
symmetricize(mat, "ud")

#Take the average of each symmetric location
symmetricize(mat, "avg")

</code></pre>

<hr>
<h2 id='tide.info'>Annual tide calendar for one particular location</h2><span id='topic+tide.info'></span>

<h3>Description</h3>

<p>Annual tide information.<br />
The columns are: Location, Longitude, Latitude, Phase, DateTime.local, DateTime.UTC, Tide.meter<br />
This function uses an API linking xtide software
(https://flaterco.com/xtide/) with tide.info() function.<br />
You must have a working internet connection for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tide.info(
  location = NULL,
  year = 2021,
  longitude = NULL,
  latitude = NULL,
  force.tide.height = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tide.info_+3A_location">location</code></td>
<td>
<p>Textual information about location name</p>
</td></tr>
<tr><td><code id="tide.info_+3A_year">year</code></td>
<td>
<p>Year to get the calendar</p>
</td></tr>
<tr><td><code id="tide.info_+3A_longitude">longitude</code></td>
<td>
<p>Longitude to search for</p>
</td></tr>
<tr><td><code id="tide.info_+3A_latitude">latitude</code></td>
<td>
<p>Latitude to search for</p>
</td></tr>
<tr><td><code id="tide.info_+3A_force.tide.height">force.tide.height</code></td>
<td>
<p>If FALSE, can return a current speed rather than tide height</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tide.info gets the annual tide calendar for one particular location.
</p>


<h3>Value</h3>

<p>Return a data.frame with annual tide calendar.
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Periodic patterns of indices: 
<code><a href="#topic+index.periodic">index.periodic</a>()</code>,
<code><a href="#topic+minmax.periodic">minmax.periodic</a>()</code>,
<code><a href="#topic+moon.info">moon.info</a>()</code>,
<code><a href="#topic+sun.info">sun.info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("HelpersMG")
Location &lt;- "Les Hattes"
Year &lt;- 2010
tide &lt;- tide.info(Location, Year)
plot(tide[, "DateTime.local"], tide[, "Tide.meter"], 
     type="l", bty="n", las=1, 
     main=tide[1, "Location"], 
     xlab=as.character(Year), ylab="Tide level in meter")

Location &lt;- "Hawaii"
Year &lt;- 2010
tide &lt;- tide.info(Location, Year)

Location &lt;- "Hanamaulu Bay, Kauai Island, Hawaii"
Year &lt;- 2010
tide &lt;- tide.info(Location, Year)
plot(tide[, "DateTime.local"], tide[, "Tide.meter"], 
     type="l", bty="n", las=1, 
     main=tide[1, "Location"], 
     xlab=as.character(Year), ylab="Tide level in meter")
     
tide &lt;- tide.info(year=2010, longitude=-32, latitude=-4)
library(maps)
map(database = "world", regions = "Brazil", asp=1, 
    xlim=c(-80, -30), ylim=c(-33, 5))
points(tide[1, "Longitude"], tide[1, "Latitude"], col="red", pch=19)
points(-32, -4, col="blue", pch=19)
axis(1)
axis(2, las=1)

# Show the locations with data    
library(maps)
map(xlim=c(-180, 180), ylim=c(-90, 90))
title("Locations with harmonics data")
axis(1, at=seq(from=-180, to=180, by=45))
axis(2, las=1, at=seq(from=-90, to=90, by=15))
points(getFromNamespace(x="tide_location", ns="HelpersMG")[, c("longitude")], 
       getFromNamespace(x="tide_location", ns="HelpersMG")[, c("latitude")], 
       pch=".", col="red", cex=2)
# Another example
tikei_lon  &lt;- (-144.5465183)
tikei_lat &lt;- -14.9505897
Year &lt;- 2021
tikei_tide &lt;- tide.info(year=Year, longitude=tikei_lon, latitude=tikei_lat)
plot(tikei_tide[, "DateTime.local"], tikei_tide[, "Tide.meter"], 
     type="l", bty="n", las=1, 
     main=tikei_tide[1, "Location"], 
     xlab=as.character(Year), ylab="Tide level in meter")
## Another one
tikei_lon &lt;- (-75.56861111)
tikei_lat &lt;- 39.50083333
Year &lt;- 2012
tikei_tide &lt;- tide.info(year=Year, longitude=tikei_lon, latitude=tikei_lat)

library(mapdata)
map('worldHires', xlim=c(-77, -74), ylim=c(37, 40))
points(x=tikei_lon, y=tikei_lat, pch=19, col="red", cex=1)
points(x=tikei_tide$Longitude[1], y=tikei_tide$Latitude[2], 
       pch=19, col="blue", cex=1)

par(mar=c(4, 4, 2, 2))
plot(tikei_tide$DateTime.local, tikei_tide$Tide.meter, type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='tnirp'>Read an ASCII text representation of a named or not vector object</h2><span id='topic+tnirp'></span>

<h3>Description</h3>

<p>Read an ASCII text representation of a named or not vector object.<br />
Note that paste0(rev(c(&quot;p&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;t&quot;)), collapse=&quot;&quot;) = &quot;tnirp&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnirp(x, named = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnirp_+3A_x">x</code></td>
<td>
<p>A string or a vector of strings with value and possibly names.</p>
</td></tr>
<tr><td><code id="tnirp_+3A_named">named</code></td>
<td>
<p>TRUE if names are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tnirp reads an ASCII text representation of a named or not vector object
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other Characters: 
<code><a href="#topic+asc">asc</a>()</code>,
<code><a href="#topic+char">char</a>()</code>,
<code><a href="#topic+d">d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- structure(runif(26), .Names=letters)
text &lt;- capture.output(A)
tnirp(text)

tnirp("         mu   mu_season         OTN       p1.09       p1.10       p1.11 
 4.63215947 10.78627511  0.36108497  0.08292101 -0.52558196 -0.76430859 
       p1.12       p1.13       p1.14       p1.15       p1.16       p1.17 
       -0.75186542 -0.57632291 -0.58017174 -0.57048696 -0.56234135 -0.80645122 
       p1.18       p1.19       p1.20       p1.21       p1.22       p1.23 
       -0.77752524 -0.80909494 -0.56920540 -0.55317302  0.45757298 -0.64155368 
       p1.24       p1.25       p1.26       p1.27       p1.28       p1.29 
       -0.59119637 -0.66006794 -0.66582399 -0.66772684 -0.67351412 -0.66941992 
       p1.30       p1.31       p1.32       p1.33       p1.34       p1.35 
       -0.67038245 -0.68938726 -0.68889078 -0.68779016 -0.68604629 -0.68361820 
       p1.36       p1.37       p2.09       p2.10       p2.11       p2.12 
       -0.67045238 -0.66115613  2.55403149  2.31060620  2.31348160  2.20958757 
       p2.13       p2.14       p2.15       p2.16       p2.17       p2.18 
       2.14304918  2.19699719  2.30705457  2.18740019  2.32305811  2.31668302 
       p2.19       p2.20       p2.21       p2.22       p2.23       p2.24 
       1.99424288  2.06613445  2.38092301  2.40551276  2.31987342  2.30344402 
       p2.25       p2.26       p2.27       p2.28       p2.29       p2.30 
       2.26869058  2.25008836  2.23385204  2.22768782  2.25341904  1.77043360 
       p2.31       p2.32       p2.33       p2.34       p2.35       p2.36 
       2.21606813  2.21581431  2.21153872  2.21118013  2.21375660  2.21182196 
       p2.37 
       1.86137833 ")
tnirp("   27.89 289.99
      90.56", named=FALSE)
</code></pre>

<hr>
<h2 id='universalmclapply'>Run the function FUN on X using parallel computing</h2><span id='topic+universalmclapply'></span>

<h3>Description</h3>

<p>Return the results of the function FUN applied to X. It uses forking in unix system and not in windows system.<br />
By default, it will send all the content of environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>universalmclapply(
  X,
  FUN,
  ...,
  mc.cores = getOption("mc.cores", parallel::detectCores()),
  mc.preschedule = TRUE,
  clusterExport = list(),
  clusterEvalQ = list(),
  forking = ifelse(.Platform$OS.type == "windows", FALSE, TRUE),
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="universalmclapply_+3A_x">X</code></td>
<td>
<p>A vector (atomic or list) or an expressions vector. Other objects (including classed objects) will be coerced by as.list.</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied to each element of X</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_...">...</code></td>
<td>
<p>Optional arguments to FUN</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>if set to TRUE then the computation is first divided to (at most) as many jobs are there are cores and then the jobs are started, each job possibly covering more than one value. If set to FALSE then one job is forked for each value of X. The former is better for short computations or large number of values in X, the latter is better for jobs that have high variance of completion time and not too many values of X compared to mc.cores.</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_clusterexport">clusterExport</code></td>
<td>
<p>List of clusterExport parameters as list</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_clusterevalq">clusterEvalQ</code></td>
<td>
<p>List of clusterEvalQ parameters as list</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_forking">forking</code></td>
<td>
<p>If TRUE will use forking</p>
</td></tr>
<tr><td><code id="universalmclapply_+3A_progressbar">progressbar</code></td>
<td>
<p>If pbapply package is installed, show a progressbar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>universalmclapply runs the function FUN on X using parallel computing
</p>


<h3>Value</h3>

<p>The results of the function FUN applied to X
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
x &lt;- 1:1000
funx &lt;- function(y) {
  mint &lt;- rep(NA, length(y))
  for (i in seq_along(y)) {
    k &lt;- rnorm(runif(n = 1, 50, 50), mean=10, sd=2)
    mint[i] &lt;- mean(k)
  }
  mint
}
# Note that parallel computing is not always the best solution !
(tp &lt;- system.time({
   m &lt;- lapply(X=x, FUN=funx)
}))
(tp &lt;- system.time({
   m &lt;- universalmclapply(X=x, FUN=funx, forking=FALSE)
}))
(tp &lt;- system.time({
   m &lt;- universalmclapply(X=x, FUN=funx, forking=TRUE)
}))

### An example using clusterExport
# Here no error is generated because environment was exported
# However forking is not possible in windows and non parallel code is ran
pp &lt;- runif(100)
x &lt;- 1:100
funx1 &lt;- function(y) {pp[y]*10}
u &lt;- universalmclapply(x, FUN=funx1, forking=TRUE)

# Here an error is generated because environment was not exported when parLapplyLB is used
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE)
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list())

# here no error is generated because the variable pp is exported
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list(varlist=c("pp"), envir=environment()))

# here no error is generated because all the environment is exported
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list(varlist=c(ls()), envir=environment()))

### An example using clusterEvalQ
asc("a") # asc() is a function from packages HelpersMG
funx2 &lt;- function(y) {asc("a")*10}
# In unix, the loaded packages are visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=TRUE)
# In windows, the loaded packages are not visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=FALSE)
# In windows, the loaded packages are not visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=FALSE, 
clusterEvalQ=list(expr=expression(library(HelpersMG)))
)

### If package pbapply is available, progress bar can be shown
m &lt;- universalmclapply(X=x, FUN=funx, forking=FALSE, progressbar=TRUE)
m &lt;- universalmclapply(X=x, FUN=funx, forking=TRUE, progressbar=TRUE)

## You can manage the number of cores used using:
options(mc.cores=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='wget'>Download a file from internet and save it locally</h2><span id='topic+wget'></span>

<h3>Description</h3>

<p>Download a file from internet and save it locally. This function is a wrapper for
download.files() that keep the name identical and can get several files at once. It was written to simplify
downloading of file. It doest not use the true wget function (https://www.gnu.org/software/wget/) which is
much more complex but also powerful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wget(url = stop("At least one internet adress is required"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wget_+3A_url">url</code></td>
<td>
<p>The url where to download file</p>
</td></tr>
<tr><td><code id="wget_+3A_...">...</code></td>
<td>
<p>The parameters send to download.file()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>wget download a file from internet and save it locally
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Marc Girondot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(HelpersMG)
# Save locally the files send in the parameter url
wget(c("https://cran.r-project.org/web/packages/HelpersMG/HelpersMG.pdf", 
         "https://cran.r-project.org/web/packages/embryogrowth/embryogrowth.pdf"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
