<!DOCTYPE html><html lang="en"><head><title>Help for package Gmedian</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Gmedian}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Gmedian-package'>
<p>Geometric Median, k-Medians Clustering and Robust Median PCA</p></a></li>
<li><a href='#Gmedian'><p>Gmedian</p></a></li>
<li><a href='#GmedianCov'><p>GmedianCov</p></a></li>
<li><a href='#kGmedian'><p>kGmedian</p></a></li>
<li><a href='#Weiszfeld'><p>Weiszfeld</p></a></li>
<li><a href='#WeiszfeldCov'><p>WeiszfeldCov</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometric Median, k-Medians Clustering and Robust Median PCA</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Herve Cardot</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Herve Cardot &lt;herve.cardot@u-bourgogne.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast algorithms for robust estimation with large samples of multivariate observations. Estimation of the geometric median, robust k-Gmedian clustering, and robust PCA based on the Gmedian covariation matrix.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.6), RSpectra, robustbase</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RSpectra</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-08 13:22:37 UTC; hcardot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-08 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Gmedian-package'>
Geometric Median, k-Medians Clustering and Robust Median PCA
</h2><span id='topic+Gmedian-package'></span>

<h3>Description</h3>

<p>The geometric median (also called spatial median or L1 median) is a robust multivariate indicator of central position. This library provides fast estimation procedures  that can handle rapidly large samples of high dimensional data. Function <code><a href="#topic+Gmedian">Gmedian</a></code> computes the geometric median of a numerical data set with averaged stochastic gradient algorithms, whereas <code><a href="#topic+GmedianCov">GmedianCov</a></code> computes the median covariation matrix, a useful indicator for robust PCA. Robust clustering, based on the geometric k-medians, can also be performed with the same type of recursive algorithm thanks to <code><a href="#topic+kGmedian">kGmedian</a></code>.
Less fast estimation procedures  based on Weiszfeld's algorithm are also available : function  <code><a href="#topic+Weiszfeld">Weiszfeld</a></code> computes the geometric median whereas <code><a href="#topic+WeiszfeldCov">WeiszfeldCov</a></code> computes the median covariation matrix. These procedures may be preferred for small and moderate sample sizes. Note that weighting statistical units (for example with survey sampling weights) is allowed. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Gmedian</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Geometric Median, k-Medians Clustering and Robust Median PCA</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-06</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Herve Cardot</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Herve Cardot &lt;herve.cardot@u-bourgogne.fr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Fast algorithms for robust estimation with large samples of multivariate observations. Estimation of the geometric median, robust k-Gmedian clustering, and robust PCA based on the Gmedian covariation matrix.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.12.6), RSpectra, robustbase</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo, RSpectra</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2016-09-03 12:29:52 UTC; cardot</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2016-09-05 16:35:51</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Gmedian                 Gmedian
Gmedian-package         Geometric Median, k-Medians Clustering and
                        Robust Median PCA
GmedianCov              GmedianCov
Weiszfeld               Weiszfeld
WeiszfeldCov            WeiszfeldCov
kGmedian                kGmedian
</pre>


<h3>Author(s)</h3>

<p>Herve Cardot
</p>
<p>Maintainer: Herve Cardot &lt;herve.cardot@u-bourgogne.fr&gt;
</p>


<h3>References</h3>

<p>Cardot, H., Cenac, P. and Zitt, P-A. (2013). Efficient and fast estimation of the geometric median in Hilbert spaces with an averaged stochastic gradient algorithm. <em>Bernoulli</em>, 19, 18-43.
</p>
<p>Cardot, H. and Godichon-Baggioni, A. (2017). Fast Estimation of the Median Covariation Matrix with Application to Online Robust Principal Component7s Analysis. <em>TEST</em>, 26, 461-480.
</p>
<p>Cardot, H., Cenac, P. and Monnez, J-M. (2012). A fast and recursive algorithm for clustering large datasets with k-medians.  <em>Computational Statistics and Data Analysis</em>, 56, 1434-1449.
</p>
<p>Lardin, P., Cardot, H. and Goga, C. (2014). Analyzing large datasets of functional data : a survey sampling point of view.  <em>Journal de la SFdS</em>, 155, 70-94.
</p>
<p>Vardi, Y. and Zhang, C.-H. (2000). The multivariate L1-median and associated data depth. <em>Proc. Natl. Acad. Sci. USA</em>, 97(4):1423-1426.
</p>

<hr>
<h2 id='Gmedian'>Gmedian</h2><span id='topic+Gmedian'></span>

<h3>Description</h3>

<p>Computes recursively the Geometric median (also named spatial median or L1-median) with a fast averaged stochastic gradient algorithms that can deal rapidly with large samples of high dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmedian(X, init = NULL, gamma = 2, alpha = 0.75, nstart=2, epsilon=1e-08) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gmedian_+3A_x">X</code></td>
<td>
<p>Data matrix, with n (rows) observations in dimension d (columns).</p>
</td></tr>
<tr><td><code id="Gmedian_+3A_init">init</code></td>
<td>
<p>When <code>NULL</code> the starting point of the algorithm is the first observation. Else the starting point of the algorithm is provided by <code>init</code>.</p>
</td></tr>  
<tr><td><code id="Gmedian_+3A_gamma">gamma</code></td>
<td>
<p>Value (positive) of the constant controling the descent steps (see details).</p>
</td></tr>
<tr><td><code id="Gmedian_+3A_alpha">alpha</code></td>
<td>
<p>Rate of decrease of the descent steps (see details). Should satisfy <code class="reqn">1/2&lt; alpha &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="Gmedian_+3A_nstart">nstart</code></td>
<td>
<p>Number of times the algorithm is ran over all the data set.</p>
</td></tr>
<tr><td><code id="Gmedian_+3A_epsilon">epsilon</code></td>
<td>
<p>Numerical tolerance. By defaut set to 1e-08.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recursive averaged algorithm is described in Cardot, Cenac, Zitt (2013), with descent steps defined as <code class="reqn">\alpha_n = gamma/n^{alpha}</code>.
</p>


<h3>Value</h3>

<p>Vector of the geometric median.
</p>


<h3>References</h3>

<p>Cardot, H., Cenac, P. and Zitt, P-A. (2013). Efficient and fast estimation of the geometric median in Hilbert spaces with an averaged stochastic gradient algorithm. <em>Bernoulli</em>, 19, 18-43.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GmedianCov">GmedianCov</a></code>, <code><a href="#topic+kGmedian">kGmedian</a></code> and <code><a href="#topic+Weiszfeld">Weiszfeld</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data - Brownian paths
n &lt;- 1e2
d &lt;- 100
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))

## Computation speed
system.time(replicate(10, {
  median.est = Gmedian(x)})) 
system.time(replicate(10, {
  mean.est = apply(x,2,mean)}))
##

## Accuracy with contaminated data
n &lt;- 1e03
d &lt;- 10
n.contaminated &lt;- 0.05*n ## 5% of contaminated observations
n.experiment &lt;- 100
err.L2 &lt;- matrix(NA,ncol=3,nrow=n.experiment)
colnames(err.L2) = c("mean (no contam.)", "mean (contam.)","Gmedian")

for (n.sim in 1:n.experiment){
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))
err.L2[n.sim,1] &lt;- sum((apply(x,2,mean))^2/d)
ind.contaminated &lt;- sample(1:n,n.contaminated) ## contam. units
x[ind.contaminated,] &lt;- 5 
err.L2[n.sim,2] &lt;- sum((apply(x,2,mean))^2/d)
err.L2[n.sim,3] &lt;- sum(Gmedian(x)^2/d)
}
boxplot(err.L2,main="L2 error")
</code></pre>

<hr>
<h2 id='GmedianCov'>GmedianCov</h2><span id='topic+GmedianCov'></span>

<h3>Description</h3>

<p>Computes recursively the Geometric median and the (geometric) median covariation matrix  with fast averaged stochastic gradient algorithms. The estimation of the Geometric median is performed first and then the median covariation matrix is estimated, as well as its leading eigenvectors. The original recursive estimator of the median covariation matrix may not be a non negative matrix. A fast projected estimator onto the convex closed cone of the non negative matrices allows to get a non negative solution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GmedianCov(X, init=NULL, nn=TRUE, scores=2, gamma=2, gc=2, alpha=0.75, nstart=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GmedianCov_+3A_x">X</code></td>
<td>
<p>Data matrix, with n observations (rows) in dimension d (columns).</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_init">init</code></td>
<td>
<p>When <code>NULL</code> the starting point of the algorithm estimating the median is the first observation.</p>
</td></tr> 
<tr><td><code id="GmedianCov_+3A_nn">nn</code></td>
<td>
<p>When <code>TRUE</code> the algorithm provides a non negative estimates of the median covariation matrix. When <code>nn=FALSE</code>, the original algorithm is performed, with no guaranty that all the eigenvalues of the estimates are non negative</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_scores">scores</code></td>
<td>
<p>An integer <code>q</code>, by default <code>q=2</code>. The function computes the eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues and the corresponding principal component scores. No output if <code>scores=0</code>.</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_gamma">gamma</code></td>
<td>
<p>Value (positive) of the constant controling the descent steps (see details) for the algorithm computing median.</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_gc">gc</code></td>
<td>
<p>Value (positive) of the constant controling the descent steps (see details) for algorithm computing the median covariation matrix</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_alpha">alpha</code></td>
<td>
<p>Rate of decrease of the descent steps, <code class="reqn"> 1/2 &lt; alpha &lt;=1</code>.</p>
</td></tr>
<tr><td><code id="GmedianCov_+3A_nstart">nstart</code></td>
<td>
<p>Number of time the algorithms are ran.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (fast) computation of the eigenvectors is performed by  <code><a href="RSpectra.html#topic+eigs_sym">eigs_sym</a></code> of package <code>RSpectra</code>.
See Cardot, H. and Godichon-Baggioni (2017) for more details on the recursive algorithm. See also <code><a href="#topic+Gmedian">Gmedian</a></code>.
When <code>nn=TRUE</code>, the descent step is bounded above so that the solution remains non negative at each iteration.
The principal components standard deviation is estimed robustly thanks to function <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> from package <code>robustbase</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>median</code></td>
<td>
<p>Vector of the geometric median</p>
</td></tr>
<tr><td><code>covmedian</code></td>
<td>
<p>Median covariation matrix</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>The <code>scores=q</code> eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Principal component scores corresponding to the <code>scores=q</code> eigenvectors</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>The <code>scores=q</code> estimates of the standard deviation of the <code>scores=q</code> principal components.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cardot, H., Cenac, P. and Zitt, P-A. (2013). Efficient and fast estimation of the geometric median in Hilbert spaces with an averaged stochastic gradient algorithm. <em>Bernoulli</em>, 19, 18-43.
</p>
<p>Cardot, H. and Godichon-Baggioni, A. (2017). Fast Estimation of the Median Covariation Matrix with Application to Online Robust Principal Components Analysis. TEST, 26, 461-480.
</p>


<h3>See Also</h3>

<p>See also  <code><a href="#topic+Gmedian">Gmedian</a></code> and <code><a href="#topic+WeiszfeldCov">WeiszfeldCov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data - Brownian paths
n &lt;- 1e3
d &lt;- 20
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))

## Estimation
median.est &lt;- GmedianCov(x)

par(mfrow=c(1,2))
image(median.est$covmedian) ## median covariation function
plot(c(1:d)/d,median.est$vectors[,1]*sqrt(d),type="l",xlab="Time",
ylab="Eigenvectors",ylim=c(-1.4,1.4))
lines(c(1:d)/d,median.est$vectors[,2]*sqrt(d),lty=2)
</code></pre>

<hr>
<h2 id='kGmedian'>kGmedian</h2><span id='topic+kGmedian'></span>

<h3>Description</h3>

<p>Fast k-medians clustering based on recursive averaged stochastic gradient algorithms.
The procedure is similar to the <code><a href="stats.html#topic+kmeans">kmeans</a></code> clustering technique performed recursively with the <code>MacQueen</code> algorithm. The advantage of the kGmedian algorithm compared to MacQueen strategy is that it deals with sum of norms instead of sum of squared norms, ensuring a more robust behaviour against outlying values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kGmedian(X, ncenters=2, gamma=1, alpha=0.75, nstart = 10, nstartkmeans = 10, 
iter.max = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kGmedian_+3A_x">X</code></td>
<td>
<p>matrix, with n observations (rows) in dimension d (columns).</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_ncenters">ncenters</code></td>
<td>
<p>Either the number of clusters, say k, or a set of initial (distinct) cluster centres. If a number, the initial centres are chosen as the output of the <code><a href="stats.html#topic+kmeans">kmeans</a></code> function computed with the <code>MacQueen</code> algorithm.</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_gamma">gamma</code></td>
<td>
<p>Value of the constant controling the descent steps (see details).</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_alpha">alpha</code></td>
<td>
<p>Rate of decrease of the descent steps.</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_nstart">nstart</code></td>
<td>
<p>Number of times the algorithm is ran, with  random sets of initialization centers chosen among the observations.</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_nstartkmeans">nstartkmeans</code></td>
<td>
<p>Number of initialization points in the <code><a href="stats.html#topic+kmeans">kmeans</a></code> function for choosing the starting point of <code>kGmedian</code>.</p>
</td></tr>
<tr><td><code id="kGmedian_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations considered in the <code><a href="stats.html#topic+kmeans">kmeans</a></code> function for choosing the starting point of <code>kGmedian</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Cardot, Cenac and Monnez (2012).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cluster</code></td>
<td>
<p>A vector of integers (from 1:k) indicating the cluster to which each point is allocated.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>A matrix of cluster centres.</p>
</td></tr>
<tr><td><code>withinsrs</code></td>
<td>
<p>Vector of within-cluster sum of norms, one component per cluster.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The number of points in each cluster.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cardot, H., Cenac, P. and Monnez, J-M. (2012). A fast and recursive algorithm for clustering large datasets with k-medians.  <em>Computational Statistics and Data Analysis</em>, 56, 1434-1449.
</p>
<p>Cardot, H., Cenac, P. and Zitt, P-A. (2013). Efficient and fast estimation of the geometric median in Hilbert spaces with an averaged stochastic gradient algorithm. <em>Bernoulli</em>, 19, 18-43.
</p>
<p>MacQueen, J. (1967). Some methods for classification and analysis of multivariate observations. In Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability, eds L. M. Le Cam and J. Neyman, 1, pp. 281-297. Berkeley, CA: University of California Press.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Gmedian">Gmedian</a></code> and <code><a href="stats.html#topic+kmeans">kmeans</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 2-dimensional example 
x &lt;- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) &lt;- c("x", "y")

cl.kmeans &lt;- kmeans(x, 2)
cl.kmedian &lt;- kGmedian(x)

par(mfrow=c(1,2))
plot(x, col = cl.kmeans$cluster, main="kmeans")
points(cl.kmeans$centers, col = 1:2, pch = 8, cex = 2)

plot(x, col = cl.kmedian$cluster, main="kmedian")
points(cl.kmedian$centers, col = 1:2, pch = 8, cex = 2)
</code></pre>

<hr>
<h2 id='Weiszfeld'>Weiszfeld</h2><span id='topic+Weiszfeld'></span>

<h3>Description</h3>

<p>Computes the Geometric median (also named spatial median or L1-median) with Weiszfeld's algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Weiszfeld(X, weights = NULL, epsilon=1e-08, nitermax = 100) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Weiszfeld_+3A_x">X</code></td>
<td>
<p>Data matrix, with n (rows) observations in dimension d (columns).</p>
</td></tr>
<tr><td><code id="Weiszfeld_+3A_weights">weights</code></td>
<td>
<p>When <code>NULL</code>, all observations have the same weight, say 1/n. Else, the user can provide a size n vector of weights (such as sampling weights). These weights are used in the estimating equation (see details).</p>
</td></tr> 
<tr><td><code id="Weiszfeld_+3A_epsilon">epsilon</code></td>
<td>
<p>Numerical tolerance. By defaut 1e-08.</p>
</td></tr>
<tr><td><code id="Weiszfeld_+3A_nitermax">nitermax</code></td>
<td>
<p>Maximum number of iterations of the algorithm. By default set to 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weizfeld's algorithm (see Vardi and Zhang, 2000) is fast and accurate and can deal with large samples of high dimension data. However it is not as fast as the recursive approach proposed in <code><a href="#topic+Gmedian">Gmedian</a></code>, which may be preferred for very large samples in high dimension. 
Weights can be given for statistical units, allowing to deal with data drawn from  unequal probability sampling designs (see Lardin-Puech, Cardot and Goga, 2014). 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>median</code></td>
<td>
<p>Vector of the geometric median.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lardin-Puech, P., Cardot, H.  and Goga, C. (2014). Analysing large datasets of functional data: a survey sampling point of view,   <em>J. de la SFdS</em>, 155(4), 70-94. 
</p>
<p>Vardi, Y. and Zhang, C.-H. (2000). The multivariate L1-median and associated data depth. <em>Proc. Natl. Acad. Sci. USA</em>, 97(4):1423-1426.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Gmedian">Gmedian</a></code> and <code><a href="#topic+WeiszfeldCov">WeiszfeldCov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Robustness of the geometric median of n=3 points in dimension d=2.
a1 &lt;- c(-1,0); a2 &lt;- c(1,0); a3 &lt;-c(0,1)
data.mat &lt;- rbind(a1,a2,a3)
plot(data.mat,xlab="x",ylab="y")
med.est &lt;- Weiszfeld(data.mat)
points(med.est$median,pch=19)

 ### weighted units
poids = c(3/2,1,1)
plot(data.mat,xlab="x",ylab="y")
med.est &lt;- Weiszfeld(data.mat,weights=poids)
plot(data.mat,xlab="x",ylab="y")
points(med.est$median,pch=19)

## outlier
data.mat[3,] &lt;- c(0,10) 
plot(data.mat,xlab="x",ylab="y")
med.est &lt;- Weiszfeld(data.mat)
points(med.est$median,pch=19)

## Computation speed
## Simulated data - Brownian paths
n &lt;- 1e2 ## choose n &lt;- 1e5 for better evaluation
d &lt;- 20
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))

system.time(replicate(10, {
  median.est = Weiszfeld(x)}))
system.time(replicate(10, {
  median.est = Gmedian(x)})) 
system.time(replicate(10, {
  mean.est = apply(x,2,mean)}))
</code></pre>

<hr>
<h2 id='WeiszfeldCov'>WeiszfeldCov</h2><span id='topic+WeiszfeldCov'></span>

<h3>Description</h3>

<p>Estimation of the Geometric median covariation matrix  with Weiszfeld's algorithm. Weights (such as sampling weights) for statistical units are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeiszfeldCov(X, weights=NULL, scores=2, epsilon=1e-08, nitermax = 100) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WeiszfeldCov_+3A_x">X</code></td>
<td>
<p>Data matrix, with n (rows) observations in dimension d (columns).</p>
</td></tr>
<tr><td><code id="WeiszfeldCov_+3A_weights">weights</code></td>
<td>
<p>When <code>NULL</code>, all observations have the same weight, say 1/n. Else, the user can provide a size n vector of weights (such as sampling weights). These weights are used in the estimating equation (see details).</p>
</td></tr> 
<tr><td><code id="WeiszfeldCov_+3A_scores">scores</code></td>
<td>
<p>An integer <code>q</code>, by default <code>q=2</code>. The function computes the eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues and the corresponding principal component scores. No output if <code>scores=0</code>.</p>
</td></tr>
<tr><td><code id="WeiszfeldCov_+3A_epsilon">epsilon</code></td>
<td>
<p>Numerical tolerance. By defaut 1e-08.</p>
</td></tr>
<tr><td><code id="WeiszfeldCov_+3A_nitermax">nitermax</code></td>
<td>
<p>Maxium number of iterations of the algorithm. By default set to 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This fast and accurate iterative algorithm can deal with moderate size datasets. For large datasets use preferably <code><a href="#topic+GmedianCov">GmedianCov</a></code>, if fast estimations are required.
Weights can be given for statistical units, allowing to deal with data drawn from  unequal probability sampling designs (see Lardin-Puech, Cardot and Goga, 2014). The principal components standard deviation is estimed robustly thanks to function <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> from package <code>robustbase</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>median</code></td>
<td>
<p>Vector of the geometric median</p>
</td></tr>
<tr><td><code>covmedian</code></td>
<td>
<p>Median covariation matrix</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>The <code>scores=q</code> eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Principal component scores corresponding to the <code>scores=q</code> eigenvectors</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>The <code>scores=q</code> robust estimates of the standard deviation of the principal components scores</p>
</td></tr>
<tr><td><code>iterm</code></td>
<td>
<p>Number of iterations needed to estimate the median</p>
</td></tr>
<tr><td><code>itercov</code></td>
<td>
<p>Number of iterations needed to estimate the median covariation matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cardot, H. and Godichon-Baggioni, A. (2017). Fast Estimation of the Median Covariation Matrix with Application to Online Robust Principal Components Analysis.  TEST, 26, 461-480.
</p>
<p>Lardin-Puech, P., Cardot, H.  and Goga, C. (2014). Analysing large datasets of functional data: a survey sampling point of view,   Journal de la Soc. Fr. de Statis., 155(4), 70-94. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Weiszfeld">Weiszfeld</a></code> and <code><a href="#topic+GmedianCov">GmedianCov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data - Brownian paths
n &lt;- 1e3
d &lt;- 20
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))

## Estimation
median.est &lt;- WeiszfeldCov(x)

par(mfrow=c(1,2))
image(median.est$covmedian) ## median covariation function
plot(c(1:d)/d,median.est$vectors[,1]*sqrt(d),type="l",xlab="Time",
ylab="Eigenvectors",ylim=c(-1.4,1.4))
lines(c(1:d)/d,median.est$vectors[,2]*sqrt(d),lty=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
